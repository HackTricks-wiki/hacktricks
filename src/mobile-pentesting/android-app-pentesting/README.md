# Pentesting des applications Android

{{#include ../../banners/hacktricks-training.md}}

## Notions de base des applications Android

It's highly recommended to start reading this page to know about the **most important parts related to Android security and the most dangerous components in an Android application**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

This is the main tool you need to connect to an android device (emulated or physical).\
**ADB** allows to control devices either over **USB** or **Network** from a computer. This utility enables the **copying** of files in both directions, **installation** and **uninstallation** of apps, **execution** of shell commands, **backing up** of data, **reading** of logs, among other functions.

Consultez la liste suivante de [**ADB Commands**](adb-commands.md) pour apprendre à utiliser adb.

## Smali

Parfois il est intéressant de **modifier le code de l'application** pour accéder à des **informations cachées** (maybe well obfuscated passwords or flags). Then, it could be interesting to decompile the apk, modify the code and recompile it.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Cela peut être très utile comme **alternative pour plusieurs tests lors de l'analyse dynamique** qui sont going to presented. Then, **keep always in mid this possibility**.

## Autres astuces intéressantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Télécharger des APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extraire l'APK depuis l'appareil:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusionnez tous les splits et les apks de base avec [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Études de cas & Vulnérabilités


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Analyse statique

Tout d'abord, pour analyser un APK vous devriez **regarder le code Java** en utilisant un décompilateur.\
Veuillez [**lire ici pour trouver des informations sur les différents décompilateurs disponibles**](apk-decompilers.md).

### Recherche d'informations intéressantes

En regardant simplement les **strings** de l'APK vous pouvez rechercher des **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), des **api** keys, **encryption**, **bluetooth uuids**, **tokens** et tout ce qui est intéressant... cherchez même des backdoors d'exécution de code ou des backdoors d'authentification (hardcoded admin credentials dans l'app).

**Firebase**

Faites particulièrement attention aux **firebase URLs** et vérifiez si elles sont mal configurées. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Compréhension basique de l'application - Manifest.xml, strings.xml

L'**examen des fichiers _Manifest.xml_ et _strings.xml_ d'une application peut révéler des vulnérabilités de sécurité potentielles**. Ces fichiers peuvent être consultés avec des décompilateurs ou en renommant l'extension du fichier APK en .zip puis en le décompressant.

Les **vulnérabilités** identifiées dans le **_Manifest.xml_** incluent :

- **Applications débogables** : Les applications marquées comme debuggable (`debuggable="true"`) dans le fichier _Manifest.xml_ présentent un risque car elles permettent des connexions pouvant conduire à une exploitation. Pour mieux comprendre comment exploiter des applications debuggable, référez-vous à un tutoriel sur la découverte et l'exploitation des applications debuggable sur un appareil.
- **Paramètres de backup** : L'attribut `android:allowBackup="false"` devrait être explicitement défini pour les applications traitant des informations sensibles afin d'empêcher des sauvegardes de données non autorisées via adb, surtout lorsque USB debugging est activé.
- **Sécurité réseau** : Les configurations de security réseau personnalisées (`android:networkSecurityConfig="@xml/network_security_config"`) dans _res/xml/_ peuvent spécifier des détails de sécurité tels que le certificate pinning et les paramètres du trafic HTTP. Un exemple est d'autoriser le trafic HTTP pour des domaines spécifiques.
- **Activities et Services exportés** : Identifier les activities et services exportés dans le manifest peut mettre en évidence des composants susceptibles d'être abusés. Une analyse plus poussée lors de tests dynamiques peut révéler comment exploiter ces composants.
- **Content Providers et FileProviders** : Des content providers exposés pourraient permettre un accès ou une modification non autorisés des données. La configuration des FileProviders doit aussi être examinée.
- **Broadcast Receivers et URL Schemes** : Ces composants pourraient être exploités, en prêtant une attention particulière à la gestion des URL schemes pour les vulnérabilités d'entrée.
- **Versions SDK** : Les attributs `minSdkVersion`, `targetSDKVersion` et `maxSdkVersion` indiquent les versions Android supportées, soulignant l'importance de ne pas supporter des versions Android obsolètes et vulnérables pour des raisons de sécurité.

À partir du fichier **strings.xml**, des informations sensibles telles que des API keys, des custom schemas et d'autres notes de développeur peuvent être découvertes, ce qui souligne la nécessité d'un examen attentif de ces ressources.

### Tapjacking

Le **Tapjacking** est une attaque où une **application malveillante** est lancée et **se positionne au-dessus d'une application victime**. Une fois qu'elle obscurcit visuellement l'application victime, son interface utilisateur est conçue de manière à tromper l'utilisateur pour qu'il interagisse avec elle, tandis qu'elle transmet l'interaction à l'application victime.\
En effet, c'est **empêcher l'utilisateur de savoir qu'il effectue en réalité des actions sur l'application victime**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Une **activity** avec le `launchMode` réglé sur `singleTask` sans `taskAffinity` défini est vulnérable au **Task Hijacking**. Cela signifie qu'une **application** peut être installée et, si elle est lancée avant la vraie application, elle pourrait **détourner la task de la vraie application** (l'utilisateur interagira donc avec l'application malveillante en pensant utiliser la vraie).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Stockage de données non sécurisé

**Stockage interne**

Sur Android, les fichiers **stockés** en **stockage interne** sont **conçus** pour être **accessibles** exclusivement par l'**app** qui les a **créés**. Cette mesure de sécurité est **appliquée** par le système d'exploitation Android et est généralement suffisante pour les besoins de sécurité de la plupart des applications. Cependant, les développeurs utilisent parfois des modes tels que `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE` pour **permettre** le partage de fichiers entre différentes applications. Ces modes **n'empêchent pas l'accès** à ces fichiers par d'autres applications, y compris potentiellement malveillantes.

1. **Analyse statique :**
- **Vérifiez** que l'utilisation de `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE` est **examinée attentivement**. Ces modes **peuvent potentiellement exposer** des fichiers à un accès non intentionnel ou non autorisé.
2. **Analyse dynamique :**
- **Vérifiez** les **permissions** définies sur les fichiers créés par l'app. Plus précisément, **vérifiez** si des fichiers sont définis comme lisibles ou modifiables par tous. Cela peut représenter un risque de sécurité important, car cela permettrait à **toute application** installée sur l'appareil, quelle que soit son origine ou son intention, de **lire ou modifier** ces fichiers.

**Stockage externe**

Lorsqu'on traite des fichiers sur le **stockage externe**, comme les cartes SD, certaines précautions doivent être prises :

1. **Accessibilité** :
- Les fichiers sur le stockage externe sont **globalement lisibles et modifiables**. Cela signifie que n'importe quelle application ou utilisateur peut accéder à ces fichiers.
2. **Problèmes de sécurité** :
- Étant donné la facilité d'accès, il est conseillé **de ne pas stocker d'informations sensibles** sur le stockage externe.
- Le stockage externe peut être retiré ou accédé par n'importe quelle application, le rendant moins sûr.
3. **Traitement des données provenant du stockage externe** :
- Effectuez toujours une **validation des entrées** sur les données récupérées depuis le stockage externe. Ceci est crucial car les données proviennent d'une source non fiable.
- Il est fortement déconseillé de stocker des exécutables ou des fichiers de classe sur le stockage externe pour un chargement dynamique.
- Si votre application doit récupérer des fichiers exécutables depuis le stockage externe, assurez-vous que ces fichiers sont **signés et vérifiés cryptographiquement** avant d'être chargés dynamiquement. Cette étape est essentielle pour maintenir l'intégrité de la sécurité de votre application.

Le stockage externe peut être **accédé** dans `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> À partir d'Android 4.4 (**API 17**), la carte SD a une structure de répertoires qui **limite l'accès d'une app au répertoire qui lui est spécifiquement dédié**. Cela empêche une application malveillante d'obtenir un accès en lecture ou écriture aux fichiers d'une autre app.

**Données sensibles stockées en clair**

- **Shared preferences** : Android permet à chaque application de facilement sauvegarder des fichiers xml dans le chemin `/data/data/<packagename>/shared_prefs/` et parfois il est possible de trouver des informations sensibles en clair dans ce dossier.
- **Databases** : Android permet à chaque application de sauvegarder facilement des bases sqlite dans le chemin `/data/data/<packagename>/databases/` et parfois il est possible de trouver des informations sensibles en clair dans ce dossier.

### TLS cassé

**Accept All Certificates**

Pour une raison quelconque, parfois des développeurs acceptent tous les certificats même si, par exemple, le hostname ne correspond pas, avec des lignes de code comme celle-ci :
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Une bonne façon de tester cela est d'essayer de capturer le traffic en utilisant un proxy comme Burp sans autoriser le Burp CA sur l'appareil. Aussi, vous pouvez générer avec Burp un certificat pour un hostname différent et l'utiliser.

### Cryptographie défaillante

**Mauvaises procédures de gestion des clés**

Certains développeurs sauvegardent des données sensibles dans le stockage local et les chiffrent avec une clé hardcodée/prédictible dans le code. Cela ne devrait pas être fait car un peu de reversing pourrait permettre à des attackers d'extraire l'information confidentielle.

**Utilisation d'algorithmes non sécurisés et/ou obsolètes**

Les développeurs ne devraient pas utiliser d'**algorithmes obsolètes** pour effectuer des **vérifications d'autorisation**, **stocker** ou **envoyer** des données. Certains de ces algorithmes sont : RC4, MD4, MD5, SHA1... Si des **hashes** sont utilisés pour stocker des mots de passe par exemple, des hashes **résistants** au brute-force devraient être utilisés avec du salt.

### Autres vérifications

- Il est recommandé d'**obfusquer l'APK** pour rendre le travail de reverse engineer plus difficile aux attackers.
- Si l'app est sensible (comme les apps bancaires), elle devrait effectuer ses **propres vérifications pour savoir si le mobile est rooté** et agir en conséquence.
- Si l'app est sensible (comme les apps bancaires), elle devrait vérifier si un **emulator** est utilisé.
- Si l'app est sensible (comme les apps bancaires), elle devrait **vérifier son intégrité avant exécution** pour détecter si elle a été modifiée.
- Utilisez [**APKiD**](https://github.com/rednaga/APKiD) pour vérifier quel compiler/packer/obfuscator a été utilisé pour construire l'APK

### React Native Application

Lisez la page suivante pour apprendre comment accéder facilement au code javascript des applications React :


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Lisez la page suivante pour apprendre comment accéder facilement au code C# d'une application xamarin :


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Selon ce [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/), superpacked est un algorithme Meta qui compresse le contenu d'une application en un seul fichier. Le blog parle de la possibilité de créer une app qui décompresse ce type d'apps... et d'une méthode plus rapide qui consiste à **exécuter l'application et récupérer les fichiers décompressés depuis le filesystem.**

### Analyse statique automatisée du code

L'outil [**mariana-trench**](https://github.com/facebook/mariana-trench) est capable de trouver des **vulnérabilités** en **scannant** le **code** de l'application. Cet outil contient une série de **known sources** (qui indiquent à l'outil les **endroits** où l'**input** est **contrôlé par l'utilisateur**), **sinks** (qui indiquent à l'outil les **endroits dangereux** où un input malveillant pourrait causer des dommages) et des **rules**. Ces rules indiquent la **combinaison** de **sources-sinks** qui signale une vulnérabilité.

Avec ces informations, **mariana-trench va analyser le code et trouver d'éventuelles vulnérabilités**.

### Secrets leaked

Une application peut contenir des secrets (API keys, mots de passe, urls cachées, sous-domaines...) à l'intérieur d'elle que vous pourriez être capable de découvrir. Vous pouvez utiliser un outil tel que [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Autres fonctions intéressantes

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** déclarées comme `native`: `public native, System.loadLibrary, System.load`
- [Lisez ceci pour apprendre **comment reverse native functions**](reversing-native-libraries.md)

### **Autres astuces**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> Tout d'abord, vous avez besoin d'un environnement où vous pouvez installer l'application et tout l'environnement (Burp CA cert, Drozer et Frida principalement). Par conséquent, un device rooté (emulated ou non) est fortement recommandé.

### Online Dynamic analysis

Vous pouvez créer un **compte gratuit** sur : [https://appetize.io/](https://appetize.io). Cette plateforme permet d'**uploader** et **d'exécuter** des APKs, donc elle est utile pour voir comment un apk se comporte.

Vous pouvez même **voir les logs de votre application** sur le web et vous connecter via **adb**.

![](<../../images/image (831).png>)

Grâce à la connexion ADB vous pouvez utiliser **Drozer** et **Frida** à l'intérieur des emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Vous pouvez créer des devices **x86** et **arm**, et selon [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**les dernières versions x86** supportent les libraries ARM sans avoir besoin d'un emulator ARM lent).
- Apprenez à le configurer sur cette page :


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(version gratuite :** Personal Edition, création de compte requise. _Il est recommandé de **télécharger** la version **AVEC**_ _**VirtualBox** pour éviter des erreurs potentielles._)
- [**Nox**](https://es.bignox.com) (Gratuit, mais il ne supporte pas Frida ou Drozer).

> [!TIP]
> Lors de la création d'un nouvel emulator sur n'importe quelle plateforme, souvenez-vous que plus l'écran est grand, plus l'emulator sera lent. Donc sélectionnez des écrans petits si possible.

Pour **installer les google services** (comme AppStore) dans Genymotion vous devez cliquer sur le bouton marqué en rouge dans l'image suivante :

![](<../../images/image (277).png>)

Notez aussi que dans la **configuration de la VM Android dans Genymotion** vous pouvez sélectionner le **Bridge Network mode** (cela sera utile si vous devez vous connecter à la VM Android depuis une VM différente contenant les outils).

#### Use a physical device

Vous devez activer les options de **debugging** et ce serait bien si vous pouvez le **rooter** :

1. **Settings**.
2. (FromAndroid 8.0) Sélectionnez **System**.
3. Sélectionnez **About phone**.
4. Appuyez **Build number** 7 fois.
5. Revenez et vous trouverez les **Developer options**.

> Une fois que vous avez installé l'application, la première chose à faire est de l'essayer et d'étudier ce qu'elle fait, comment elle fonctionne et de vous familiariser avec elle.\
> Je suggère d'**effectuer cette analyse dynamique initiale en utilisant MobSF dynamic analysis + pidcat**, ainsi nous pourrons **apprendre comment l'application fonctionne** pendant que MobSF **capture** beaucoup de **données intéressantes** que vous pourrez revoir ensuite.

Magisk/Zygisk quick notes (recommandé sur les appareils Pixel)
- Patch boot.img avec l'app Magisk et flashez via fastboot pour obtenir un systemless root
- Activez Zygisk + DenyList pour masquer le root ; envisagez LSPosed/Shamiko quand un masquage plus robuste est nécessaire
- Conservez le boot.img original pour récupérer après les OTA ; re-patchez après chaque OTA
- Pour le mirroring d'écran, utilisez scrcpy sur l'hôte

### Unintended Data Leakage

**Logging**

Les développeurs doivent être prudents en exposant des **informations de debugging** publiquement, car cela peut mener à des fuites de données sensibles. Les outils [**pidcat**](https://github.com/JakeWharton/pidcat) et `adb logcat` sont recommandés pour surveiller les logs d'application afin d'identifier et protéger les informations sensibles. **Pidcat** est préféré pour sa facilité d'utilisation et sa lisibilité.

> [!WARNING]
> Notez que à partir des **versions postérieures à Android 4.0**, **les applications ne peuvent accéder qu'à leurs propres logs**. Ainsi les applications ne peuvent pas accéder aux logs d'autres apps.\
> Quoi qu'il en soit, il est toujours recommandé de **ne pas logger d'informations sensibles**.

**Copy/Paste Buffer Caching**

Le framework basé sur le **clipboard** d'Android permet la fonctionnalité copy-paste dans les apps, mais présente un risque car **d'autres applications** peuvent **accéder** au clipboard, exposant potentiellement des données sensibles. Il est crucial de **désactiver les fonctions de copy/paste** pour les sections sensibles d'une application, comme les détails de carte bancaire, afin de prévenir les leaks.

**Crash Logs**

Si une application **crashe** et **sauvegarde des logs**, ces logs peuvent aider des attackers, particulièrement quand l'application ne peut pas être reverse-engineerée. Pour atténuer ce risque, évitez de logger lors de crashs, et si les logs doivent être transmis sur le réseau, assurez-vous qu'ils sont envoyés via un canal SSL pour la sécurité.

En tant que pentester, **essayez de jeter un œil à ces logs**.

**Analytics Data Sent To 3rd Parties**

Les applications intègrent souvent des services comme Google Adsense, qui peuvent involontairement **leak des données sensibles** à cause d'une implémentation incorrecte par les développeurs. Pour identifier de potentielles leaks, il est conseillé d'**intercepter le traffic de l'application** et de vérifier si des informations sensibles sont envoyées à des services tiers.

### SQLite DBs

La plupart des applications utiliseront des **bases de données SQLite internes** pour sauvegarder des informations. Pendant le pentest, jetez un **œil** aux **databases** créées, aux noms des **tables** et des **colonnes** et à toutes les **données** sauvegardées car vous pourriez trouver des **informations sensibles** (ce qui serait une vulnérabilité).\
Les bases de données devraient se trouver dans `/data/data/the.package.name/databases` comme `/data/data/com.mwr.example.sieve/databases`

Si la base de données sauvegarde des informations confidentielles et est **encrypted** mais que vous pouvez **find** le **password** à l'intérieur de l'application, c'est toujours une **vulnérabilité**.

Enumérez les tables en utilisant `.tables` et énumérez les colonnes des tables en faisant `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** permet de **prendre le rôle d'une app Android** et d'interagir avec d'autres apps. Il peut faire **tout ce qu'une application installée peut faire**, comme utiliser le mécanisme d'Inter-Process Communication (IPC) d'Android et interagir avec le système d'exploitation sous-jacent. .\
Drozer est un outil utile pour **exploiter des activities exportées, des services exportés et des Content Providers** comme vous l'apprendrez dans les sections suivantes.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Rappelez-vous aussi que le code d'une activity démarre dans la méthode **`onCreate`**.

**Authorisation bypass**

Quand une Activity est exportée vous pouvez invoquer son écran depuis une app externe. Donc, si une activity contenant des **informations sensibles** est **exportée** vous pourriez **bypasser** les mécanismes d'**authentication** **pour y accéder.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Vous pouvez aussi démarrer une activity exportée depuis adb :

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Notez qu'un authorisation bypass n'est pas toujours une vulnérabilité ; cela dépend de la façon dont le bypass fonctionne et des informations exposées.

**Sensitive information leakage**

Les Activities peuvent aussi renvoyer des résultats. Si vous parvenez à trouver une activity exportée et non protégée appelant la méthode **`setResult`** et **renvoyant des informations sensibles**, il y a un sensitive information leakage.

#### Tapjacking

Si le Tapjacking n'est pas empêché, vous pourriez abuser de l'activity exportée pour faire en sorte que **l'utilisateur réalise des actions inattendues**. Pour plus d'info sur [**ce qu'est le Tapjacking, suivez le lien**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Les Content providers sont essentiellement utilisés pour **partager des données**. Si une app dispose de content providers accessibles, vous pourriez être capable d'**extraire des données sensibles** depuis ceux-ci. Il est aussi intéressant de tester d'éventuelles **SQL injections** et **Path Traversals** car elles pourraient être vulnérables.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Rappelez-vous que les actions d'un Service commencent dans la méthode `onStartCommand`.

Un Service est essentiellement quelque chose qui **peut recevoir des données**, les **traiter** et **renvoyer** (ou non) une réponse. Donc, si une application exporte des services, vous devriez **vérifier** le **code** pour comprendre ce qu'il fait et le **tester** **dynamiquement** afin d'extraire des informations confidentielles, contourner des mesures d'authentification...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Rappelez-vous que les actions d'un Broadcast Receiver commencent dans la méthode `onReceive`.

Un Broadcast Receiver attend un certain type de message. Selon la manière dont le receiver gère le message, il pourrait être vulnérable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Vous pouvez rechercher des deep links manuellement, en utilisant des outils comme MobSF ou des scripts comme [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Vous pouvez **ouvrir** un **scheme** déclaré en utilisant **adb** ou un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Notez que vous pouvez **omettre le nom du package** et le mobile appellera automatiquement l'application qui doit ouvrir ce lien._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code exécuté**

Pour trouver le **code qui sera exécuté dans l'App**, allez à l'activité appelée par le deeplink et recherchez la fonction **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

Chaque fois que vous trouvez un deep link, vérifiez qu'**il ne reçoit pas de données sensibles (comme des mots de passe) via des paramètres d'URL**, car n'importe quelle autre application pourrait **usurper le deep link et voler ces données !**

**Parameters in path**

Vous **devez aussi vérifier si un deep link utilise un paramètre à l'intérieur du path** de l'URL comme : `https://api.example.com/v1/users/{username}` , dans ce cas vous pouvez forcer un path traversal en accédant à quelque chose comme : `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Notez que si vous trouvez les endpoints corrects dans l'application vous pourriez provoquer un **Open Redirect** (si une partie du path est utilisée comme nom de domaine), un **account takeover** (si vous pouvez modifier les users details sans token CSRF et que l'endpoint vulnérable utilise la méthode appropriée) et toute autre vuln. Plus d'[info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Un [intéressant bug bounty report](https://hackerone.com/reports/855618) au sujet des links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Les certificats ne sont pas toujours correctement inspectés** par les applications Android. Il est courant que ces applications ignorent les avertissements et acceptent des certificats auto-signés ou, dans certains cas, reviennent à des connexions HTTP.
- **Les négociations lors du handshake SSL/TLS sont parfois faibles**, employant des suites de chiffrement non sécurisées. Cette vulnérabilité rend la connexion susceptible à des attaques man-in-the-middle (MITM), permettant aux attaquants de déchiffrer les données.
- **Leakage of private information** représente un risque lorsque les applications s'authentifient via des canaux sécurisés puis communiquent via des canaux non sécurisés pour d'autres transactions. Cette approche ne protège pas les données sensibles, comme les cookies de session ou les informations utilisateur, d'une interception par des entités malveillantes.

#### Certificate Verification

Nous allons nous concentrer sur la **vérification des certificats**. L'intégrité du certificat du serveur doit être vérifiée pour améliorer la sécurité. C'est crucial car des configurations TLS non sécurisées et la transmission de données sensibles sur des canaux non chiffrés peuvent présenter des risques importants. Pour des étapes détaillées sur la vérification des certificats serveur et la correction des vulnérabilités, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) fournit un guide complet.

#### SSL Pinning

SSL Pinning est une mesure de sécurité où l'application vérifie le certificat du serveur par rapport à une copie connue stockée dans l'application elle-même. Cette méthode est essentielle pour prévenir les attaques MITM. Implémenter SSL Pinning est fortement recommandé pour les applications manipulant des informations sensibles.

#### Traffic Inspection

Pour inspecter le trafic HTTP, il est nécessaire d'**installer le certificat de l'outil proxy** (par ex., Burp). Sans l'installation de ce certificat, le trafic chiffré pourrait ne pas être visible via le proxy. Pour un guide sur l'installation d'un certificat CA personnalisé, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Les applications ciblant **API Level 24 and above** nécessitent des modifications du Network Security Config pour accepter le certificat CA du proxy. Cette étape est critique pour inspecter le trafic chiffré. Pour des instructions sur la modification du Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Si **Flutter** est utilisé vous devez suivre les instructions sur [**this page**](flutter.md). Ceci est parce que, simplement ajouter le certificat dans le store ne fonctionnera pas car Flutter a sa propre liste de CAs valides.

#### Static detection of SSL/TLS pinning

Avant d'essayer des contournements à l'exécution, cartographiez rapidement où le pinning est appliqué dans l'APK. La découverte statique vous aide à planifier les hooks/patches et à vous concentrer sur les bons code paths.

Tool: SSLPinDetect
- Utilitaire open-source d'analyse statique qui décompile l'APK en Smali (via apktool) et scanne des motifs regex sélectionnés des implémentations de SSL/TLS pinning.
- Rapporte le chemin de fichier exact, le numéro de ligne et un extrait de code pour chaque correspondance.
- Couvre les frameworks courants et les code paths personnalisés : OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, et les pins Network Security Config XML.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Utilisation
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemples de règles de pattern (JSON)

Utilisez ou étendez des signatures pour détecter des styles de pinning propriétaires/personnalisés. Vous pouvez charger votre propre JSON et scanner à grande échelle.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Analyse rapide des grandes apps via multi-threading et I/O mémoire mappée ; les regex précompilées réduisent la surcharge/les faux positifs.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typical detection targets to triage next:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, surcharges de checkServerTrusted
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Use the matched locations to plan Frida hooks, static patches, or config reviews before dynamic testing.



#### Bypassing SSL Pinning

Quand SSL Pinning est implémenté, le bypass devient nécessaire pour inspecter le trafic HTTPS. Différentes méthodes sont disponibles pour ça :

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Le principal avantage de cette option est que vous n'aurez pas besoin de root pour bypass SSL Pinning, mais il faudra désinstaller l'application et réinstaller la nouvelle, et cela ne fonctionnera pas toujours.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Il est important de rechercher aussi des vulnérabilités web courantes dans l'application. Les détails sur l'identification et l'atténuation de ces vulnérabilités dépassent le cadre de ce résumé mais sont largement traités ailleurs.

### Frida

[Frida](https://www.frida.re) est un toolkit d'instrumentation dynamique pour développeurs, reverse-engineers, et chercheurs en sécurité.\
**Vous pouvez accéder à l'application en cours d'exécution et hooker des méthodes à l'exécution pour modifier le comportement, changer des valeurs, extraire des valeurs, exécuter un code différent...**\
Si vous voulez pentest des applications Android vous devez savoir utiliser Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Vérifiez si l'application stocke des informations sensibles en mémoire qu'elle ne devrait pas stocker, comme des mots de passe ou des mnémoniques.

En utilisant [**Fridump3**](https://github.com/rootbsd/fridump3) vous pouvez effectuer un dump de la mémoire de l'app avec:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Cela va dump la mémoire dans le dossier ./dump, et vous pouvez y faire un grep avec quelque chose comme :
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Données sensibles dans Keystore**

Sur Android, le Keystore est l'endroit idéal pour stocker des données sensibles, cependant, avec suffisamment de privilèges il est toujours **possible d'y accéder**. Comme les applications ont tendance à stocker ici des **données sensibles en clear text**, les pentests devraient le vérifier en tant que root user, car quelqu'un ayant un accès physique au périphérique pourrait voler ces données.

Même si une app stocke des données dans le keystore, ces données doivent être chiffrées.

Pour accéder aux données à l'intérieur du keystore, vous pouvez utiliser ce script Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

En utilisant le script Frida suivant, il pourrait être possible de **bypass fingerprint authentication** mis en œuvre par des applications Android pour **protéger certaines zones sensibles :**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Images d'arrière-plan**

Lorsque vous placez une application en arrière-plan, Android enregistre un **instantané de l'application** : lorsqu'elle est ramenée au premier plan, l'image est chargée avant l'application pour donner l'impression que celle-ci s'est chargée plus rapidement.

Cependant, si cet instantané contient des **informations sensibles**, une personne ayant accès à l'instantané pourrait **voler ces informations** (notez que vous avez besoin de root pour y accéder).

Les instantanés sont généralement stockés à : **`/data/system_ce/0/snapshots`**

Android fournit un moyen de **prévenir la capture d'écran en définissant le paramètre de layout FLAG_SECURE**. En utilisant ce flag, le contenu de la fenêtre est traité comme sécurisé, l'empêchant d'apparaître dans des captures d'écran ou d'être affiché sur des écrans non sécurisés.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

This tool could help you managing different tools during the dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Les développeurs créent souvent des composants proxy comme activities, services, et broadcast receivers qui gèrent ces Intents et les passent à des méthodes telles que `startActivity(...)` ou `sendBroadcast(...)`, ce qui peut être risqué.

Le danger réside dans le fait de permettre aux attaquants de déclencher des composants d'application non-exportés ou d'accéder à des content providers sensibles en détournant ces Intents. Un exemple notable est le composant `WebView` qui convertit les URLs en objets `Intent` via `Intent.parseUri(...)` puis les exécute, pouvant mener à des injections d'Intent malveillantes.

### Essential Takeaways

- **Intent Injection** est similaire au problème d'Open Redirect sur le web.
- Les exploits impliquent de passer des objets `Intent` en tant qu'extras, qui peuvent être redirigés pour exécuter des opérations dangereuses.
- Cela peut exposer des composants non-exportés et des content providers aux attaquants.
- La conversion d'URL en `Intent` par le `WebView` peut faciliter des actions non prévues.

### Injections côté client Android et autres

Vous connaissez probablement ce type de vulnérabilités depuis le Web. Vous devez être particulièrement prudent avec ces vulnérabilités dans une application Android :

- **SQL Injection:** Lorsqu'on manipule des requêtes dynamiques ou des Content-Providers, assurez-vous d'utiliser des requêtes paramétrées.
- **JavaScript Injection (XSS):** Vérifiez que le support JavaScript et Plugin est désactivé pour tous les WebViews (désactivé par défaut). [Plus d'infos ici](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Les WebViews devraient avoir l'accès au système de fichiers désactivé (activé par défaut) - `(webview.getSettings().setAllowFileAccess(false);)`. [Plus d'infos ici](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Dans plusieurs cas, lorsque l'application Android termine la session, le cookie n'est pas révoqué ou peut même être sauvegardé sur le disque
- [**Secure Flag** dans les cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Analyse automatique

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analyse statique**

![](<../../images/image (866).png>)

**Évaluation des vulnérabilités de l'application** via une interface web agréable. Vous pouvez aussi effectuer une analyse dynamique (mais vous devez préparer l'environnement).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Remarquez que MobSF peut analyser **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
De plus, si vous créez un fichier **ZIP** contenant le code source d'une application **Android** ou **IOS** (allez dans le dossier racine de l'application, sélectionnez tout et créez un ZIPfile), il pourra aussi l'analyser.

MobSF permet également de **diff/Compare** les analyses et d'intégrer **VirusTotal** (vous devrez définir votre clé API dans _MobSF/settings.py_ et l'activer : `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Vous pouvez aussi définir `VT_UPLOAD` à `False`, alors le **hash** sera **upload** au lieu du fichier.

### Assisted Dynamic analysis with MobSF

**MobSF** peut aussi être très utile pour l'**analyse dynamique** sur **Android**, mais dans ce cas vous devrez installer MobSF et **genymotion** sur votre hôte (une VM ou Docker ne fonctionneront pas). _Note : Vous devez **démarrer d'abord une VM dans genymotion** puis **MobSF.**_\
L'**analyseur dynamique MobSF** peut :

- **Dump application data** (URLs, logs, clipboard, captures d'écran faites par vous, captures d'écran faites par "**Exported Activity Tester**", emails, bases de données SQLite, fichiers XML, et autres fichiers créés). Tout ceci est fait automatiquement sauf pour les captures d'écran : vous devez appuyer quand vous voulez une capture d'écran ou appuyer sur "**Exported Activity Tester**" pour obtenir les captures d'écran de toutes les activités exportées.
- Capturer le **HTTPS traffic**
- Utiliser **Frida** pour obtenir des **runtime** **information**

À partir des versions Android **> 5**, il **démarrera automatiquement Frida** et configurera les paramètres de **proxy** globaux pour **capture** le traffic. Il ne capturera le traffic que de l'application testée.

**Frida**

Par défaut, il utilisera aussi certains Frida Scripts pour **bypass SSL pinning**, **root detection** et **debugger detection** et pour **monitor interesting APIs**.\
MobSF peut aussi **invoke exported activities**, prendre des **screenshots** de celles-ci et les **save** pour le rapport.

Pour **start** le test dynamique, appuyez sur le bouton vert : "**Start Instrumentation**". Appuyez sur "**Frida Live Logs**" pour voir les logs générés par les Frida scripts et "**Live API Monitor**" pour voir toutes les invocations des méthodes hookées, les arguments passés et les valeurs retournées (cela apparaîtra après avoir appuyé sur "Start Instrumentation").\
MobSF permet aussi de charger vos propres **Frida scripts** (pour envoyer les résultats de vos scripts Frida à MobSF utilisez la fonction `send()`). Il propose également **plusieurs scripts pré-écrits** que vous pouvez charger (vous pouvez en ajouter d'autres dans `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), il suffit de **les sélectionner**, d'appuyer sur "**Load**" puis sur "**Start Instrumentation**" (vous pourrez voir les logs de ces scripts dans "**Frida Live Logs**").

![](<../../images/image (419).png>)

De plus, vous avez quelques fonctionnalités auxiliaires Frida :

- **Enumerate Loaded Classes** : Affiche toutes les classes chargées
- **Capture Strings** : Affiche toutes les strings capturées lors de l'utilisation de l'application (très bruyant)
- **Capture String Comparisons** : Peut être très utile. Il **montrera les 2 strings comparées** et si le résultat était True ou False.
- **Enumerate Class Methods** : Indiquez le nom de la classe (comme "java.io.File") et il affichera toutes les méthodes de la classe.
- **Search Class Pattern** : Recherche des classes par pattern
- **Trace Class Methods** : **Trace** une **classe entière** (voir les entrées et sorties de toutes les méthodes de la classe). Rappelez-vous que par défaut MobSF trace plusieurs méthodes Android intéressantes.

Une fois que vous avez sélectionné le module auxiliaire que vous voulez utiliser, vous devez appuyer sur "**Start Intrumentation**" et vous verrez toutes les sorties dans "**Frida Live Logs**".

**Shell**

MobSF apporte aussi un shell avec quelques commandes **adb**, **MobSF commands**, et commandes **shell** courantes en bas de la page d'analyse dynamique. Quelques commandes intéressantes :
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Outils HTTP**

Lorsque le trafic http est capturé, vous pouvez voir une vue brute du trafic capturé sur le bouton "**HTTP(S) Traffic**" en bas ou une vue plus agréable dans le bouton vert "**Start HTTPTools**". Depuis la deuxième option, vous pouvez **envoyer** les **requêtes capturées** vers des **proxies** comme Burp ou Owasp ZAP.\
Pour ce faire, _démarrez Burp -->_ _désactivez Intercept --> dans MobSB HTTPTools sélectionnez la requête_ --> appuyez sur "**Send to Fuzzer**" --> _sélectionnez l'adresse du proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Une fois que vous avez terminé l'analyse dynamique avec MobSF, vous pouvez cliquer sur "**Start Web API Fuzzer**" pour **fuzz des requêtes http** et rechercher des vulnérabilités.

> [!TIP]
> Après avoir effectué une analyse dynamique avec MobSF, les paramètres de proxy peuvent être mal configurés et vous ne pourrez pas les corriger depuis la GUI. Vous pouvez corriger les paramètres de proxy en exécutant :
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Analyse dynamique assistée avec Inspeckage

Vous pouvez obtenir l'outil depuis [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Cet outil utilise des **Hooks** pour vous indiquer **ce qui se passe dans l'application** pendant que vous effectuez une **analyse dynamique**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

C'est un **excellent outil pour effectuer une analyse statique avec une interface graphique**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Cet outil est conçu pour rechercher plusieurs **security related Android application vulnerabilities**, soit dans le **source code** soit dans les **packaged APKs**. L'outil est également **capable of creating a "Proof-of-Concept" deployable APK** et des **ADB commands**, pour exploiter certaines des vulnérabilités trouvées (Exposed activities, intents, tapjacking...). Comme avec Drozer, il n'est pas nécessaire de rooter l'appareil de test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Affiche tous les fichiers extraits pour une consultation facile
- Décompile automatiquement les fichiers APK en formats Java et Smali
- Analyse AndroidManifest.xml pour les vulnérabilités courantes et le comportement
- Analyse statique du code source pour détecter les vulnérabilités courantes et le comportement
- Informations sur l'appareil
- et plus encore
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER est une application en ligne de commande utilisable sous Windows, MacOS X et Linux, qui analyse des fichiers _.apk_ à la recherche de vulnérabilités. Elle fonctionne en décompressant les APKs et en appliquant une série de règles pour détecter ces vulnérabilités.

Toutes les règles sont centralisées dans un fichier `rules.json`, et chaque entreprise ou testeur peut créer ses propres règles pour analyser ce dont ils ont besoin.

Téléchargez les derniers binaires depuis la [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn est un outil **multi-plateforme** qui aide les développeurs, bugbounty hunters et ethical hackers effectuant [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) sur les applications mobiles.

Le concept est que vous glissez-déposez votre fichier d'application mobile (un fichier .apk ou .ipa) sur l'application StaCoAn et elle générera un rapport visuel et portable pour vous. Vous pouvez ajuster les paramètres et les wordlists pour obtenir une expérience personnalisée.

Télécharger[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework est un système d'analyse de vulnérabilités Android qui aide les développeurs ou hackers à trouver des vulnérabilités potentielles dans les applications Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** est un outil dont le but principal est de détecter et d'alerter l'utilisateur sur les comportements potentiellement malveillants développés par une application Android.

La détection est effectuée par **static analysis** du bytecode Dalvik de l'application, représenté en **Smali**, à l'aide de la bibliothèque [`androguard`](https://github.com/androguard/androguard).

Cet outil recherche les **comportements courants des applications "malveillantes"** tels que : Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** est un framework d'ingénierie inverse et d'analyse d'applications mobiles. C'est un outil qui regroupe des outils couramment utilisés pour l'ingénierie inverse et l'analyse d'applications mobiles, afin d'aider à tester les applications mobiles face aux menaces de sécurité mobile OWASP. Son objectif est de rendre cette tâche plus facile et plus accessible pour les développeurs d'applications mobiles et les professionnels de la sécurité.

Il permet de :

- Extraire du code Java et Smali en utilisant différents outils
- Analyser des APKs en utilisant : [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraire des informations privées de l'APK en utilisant des regexps.
- Analyser le Manifest.
- Analyser les domaines trouvés en utilisant : [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) et [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Désobfusquer l'APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile pour détecter les malware : [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Notez qu'en fonction du service et de la configuration utilisés pour obfusquer le code, les secrets peuvent ou non finir obfusqués.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** est un outil open source en ligne de commande qui réduit, optimise et obfusque le code Java. Il est capable d'optimiser le bytecode ainsi que de détecter et supprimer les instructions inutilisées. ProGuard est un logiciel libre distribué sous la GNU General Public License, version 2.

ProGuard est distribué dans le cadre de l'Android SDK et s'exécute lors de la compilation de l'application en mode release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Trouvez un guide pas à pas pour désobfusquer l'apk sur [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) La dernière fois que nous avons vérifié, le mode d'opération de Dexguard était :

- charger une ressource en tant que InputStream ;
- passer le résultat à une classe héritant de FilterInputStream pour la déchiffrer ;
- effectuer une obfuscation inutile pour faire perdre quelques minutes à un reverseur ;
- passer le résultat déchiffré à un ZipInputStream pour obtenir un fichier DEX ;
- enfin charger le DEX résultant comme Resource en utilisant la méthode `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard inverse le processus d'obfuscation réalisé par les outils d'obfuscation Android. Cela permet de réaliser de nombreuses analyses de sécurité, y compris l'inspection du code et l'identification des bibliothèques.**

Vous pouvez téléverser un APK obfusqué sur leur plateforme.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

C'est un **déobfuscateur Android générique.** Simplify **exécute virtuellement une app** pour comprendre son comportement puis **essaie d'optimiser le code** afin qu'il se comporte de façon identique mais soit plus facile à comprendre pour un humain. Chaque type d'optimisation est simple et générique, donc peu importe le type spécifique d'obfuscation utilisé.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD vous donne des informations sur **la façon dont un APK a été créé**. Il identifie de nombreux **compilateurs**, **packers**, **obfuscators**, et autres éléments étranges. C'est [_PEiD_](https://www.aldeid.com/wiki/PEiD) pour Android.

### Manual

[Lisez ce tutoriel pour apprendre quelques astuces sur **comment déobfusquer une obfuscation personnalisée**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b est une machine virtuelle de sécurité Android basée sur ubuntu-mate qui inclut une collection des derniers frameworks, tutoriels et labs provenant de différents passionnés et chercheurs en sécurité pour le reverse engineering et l'analyse de malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) C'est une excellente liste de ressources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
