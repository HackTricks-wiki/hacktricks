# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

Inashauriwa sana kuanza kusoma ukurasa huu ili kujua kuhusu **sehemu muhimu zaidi zinazohusiana na usalama wa Android na vipengele hatari zaidi katika programu ya Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Hii ni zana kuu unayohitaji kuunganishwa na kifaa cha Android (emulated au halisi).\
**ADB** inaruhusu kudhibiti vifaa kwa njia ya **USB** au **Network** kutoka kwenye kompyuta. Kifaa hiki kinawezesha **kunakili** mafaili pande zote mbili, **kusakinisha** na **kuondoa** apps, **kutekeleza** amri za shell, **kufanya backup** ya data, **kusoma** logi, pamoja na kazi nyingine.

Angalia orodha ifuatayo ya [**ADB Commands**](adb-commands.md) ili kujifunza jinsi ya kutumia adb.

## Smali

Wakati mwingine ni muhimu **kubadilisha msimbo wa programu** ili kupata **taarifa zilizofichwa** (labda nywila zilizofichwa vizuri au flagi). Kwa hivyo, inaweza kuwa muhimu ku-decompile APK, kubadilisha msimbo na kuirecompile.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Hii inaweza kuwa msaada mkubwa kama **mbadala kwa vipimo kadhaa wakati wa dynamic analysis** vitakavyoonyeshwa. Kwa hivyo, **kumbuka daima uwezekano huu**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Unganisha splits zote na base apks kwa kutumia [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

Kwanza kabisa, kwa kuchambua APK unapaswa **kuangalia msimbo wa Java** kwa kutumia decompiler.\
Tafadhali, [**soma hapa kupata taarifa kuhusu decompilers tofauti zinazopatikana**](apk-decompilers.md).

### Looking for interesting Info

Kwa kuangalia tu **strings** za APK unaweza kutafuta **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** na chochote kinachovutia... angalia hata kwa code execution **backdoors** au authentication backdoors (hardcoded admin credentials kwenye app).

**Firebase**

Lipa umakini maalum kwa **firebase URLs** na angalia kama imewekwa vibaya. [Taarifa zaidi kuhusu ni nini Firebase na jinsi ya kuitumia hapa.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

Uchunguzi wa faili za programu za _Manifest.xml_ na **_strings.xml_** unaweza kufichua udhaifu wa usalama. Faili hizi zinaweza kufikiwa kwa kutumia decompilers au kwa kubadilisha extension ya faili ya APK kuwa .zip kisha kuizikamua.

**Vulnerabilities** zilizotambulika kutoka kwa **Manifest.xml** ni pamoja na:

- **Debuggable Applications**: Programu zilizowekwa kama debuggable (`debuggable="true"`) katika _Manifest.xml_ zina hatari kwa sababu zinaruhusu muunganisho ambao unaweza kusababisha exploitation. Kwa uelewa zaidi juu ya jinsi ya kutumia programu debuggable, rejea mafunzo juu ya kutafuta na kushambulia debuggable applications kwenye kifaa.
- **Backup Settings**: Sifa `android:allowBackup="false"` inapaswa kuwekwa wazi kwa programu zinazoshughulikia taarifa nyeti ili kuzuia backups zisizoidhinishwa kupitia adb, hasa wakati usb debugging imewezeshwa.
- **Network Security**: Custom network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) katika _res/xml/_ zinaweza kueleza undani wa usalama kama certificate pins na mipangilio ya HTTP traffic. Mfano ni kuruhusu HTTP traffic kwa domains maalum.
- **Exported Activities and Services**: Kutambua exported activities na services katika manifest kunaweza kuonyesha vipengele vinavyoweza kutumiwa vibaya. Uchambuzi zaidi wakati wa dynamic testing unaweza kufichua jinsi ya kushambulia vipengele hivi.
- **Content Providers and FileProviders**: Content providers zilizo wazi zinaweza kuruhusu ufikiaji usioidhinishwa au urekebishaji wa data. Usanidi wa FileProviders pia unapaswa kuchunguzwa kwa makini.
- **Broadcast Receivers and URL Schemes**: Vipengele hivi vinaweza kutumiwa kwa exploitation, na umakini maalum unapaswa kuwekwa jinsi URL schemes zinavyosimamiwa kwa ajili ya input vulnerabilities.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, na `maxSdkVersion` zinaonyesha matoleo ya Android yanayounga mkono, yakionyesha umuhimu wa kutoendelea kuunga mkono matoleo ya zamani na yenye udhaifu kwa sababu za usalama.

Kutoka kwa faili ya **strings.xml**, taarifa nyeti kama API keys, custom schemas, na maelezo mengine ya developer zinaweza kugunduliwa, ikisisitiza umuhimu wa ukaguzi wa makini wa rasilimali hizi.

### Tapjacking

**Tapjacking** ni shambulio ambapo **malicious** **application** inazinduliwa na **kujipangia juu ya application ya mwathiriwa**. Mara inapoificha app ya mwathiriwa, kiolesura chake kimeundwa kwa njia inayodanganya mtumiaji kuingiliana nayo, wakati kiingiliano hicho kinapitishwa kwa app ya mwathiriwa.\
Kwa ufanisi, inamficha mtumiaji ili asijue kuwa kwa kweli anafanya vitendo kwenye app ya mwathiriwa.

Pata habari zaidi katika:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity yenye **`launchMode`** imewekwa kwa **`singleTask` bila `taskAffinity`** yoyote iliyobainishwa ni nyeti kwa task Hijacking. Hii ina maana kwamba, application inaweza kusakinishwa na ikiwa itaendeshwa kabla ya application halisi inaweza **hijack task ya application halisi** (hivyo mtumiaji atakuwa akishirikiana na **malicious application akidhani anatumia ile halisi**).

Taarifa zaidi katika:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Katika Android, faili zilizohifadhiwa katika **internal** storage zimetengenezwa kuwa zinapatikana mahsusi kwa **app** iliyozianzisha. Hatua hii ya usalama inatekelezwa na mfumo wa uendeshaji wa Android na kwa kawaida inatosheleza mahitaji ya usalama ya programu nyingi. Hata hivyo, waendelezaji wakati mwingine hutumia modes kama `MODE_WORLD_READABLE` na `MODE_WORLD_WRITABLE` kuruhusu faili kushirikiwa kati ya applications mbalimbali. Modes hizi hata hivyo **hazizuizi ufikiaji** wa faili hizi na applications nyingine, ikiwa ni pamoja na zile zinazoweza kuwa zenye malice.

1. **Static Analysis:**
- **Hakikisha** matumizi ya `MODE_WORLD_READABLE` na `MODE_WORLD_WRITABLE` yanachunguzwa kwa makini. Modes hizi **zinaweza kuonyesha** faili kwa ufikiaji usiokusudiwa au usioidhinishwa.
2. **Dynamic Analysis:**
- **Thibitisha** ruhusa zilizowekwa kwenye faili zilizotengenezwa na app. Haswa, **angalia** kama faili yoyote imewekwa kuwa readable au writable kwa wote. Hii inaweza kuwa hatari kubwa ya usalama, kwani itaruhusu **programu yoyote** iliyosakinishwa kwenye kifaa, bila kujali asili au nia yake, kusoma au kurekebisha faili hizi.

**External Storage**

Unapotumia faili kwenye **external storage**, kama SD Cards, tahadhari zifuatazo zinapaswa kuchukuliwa:

1. **Accessibility**:
- Faili kwenye external storage ni **globally readable and writable**. Hii inamaanisha programu yoyote au mtumiaji anaweza kufikia faili hizi.
2. **Security Concerns**:
- Kutokana na urahisi wa ufikiaji, inadokezwa **kuto hifadhi taarifa nyeti** kwenye external storage.
- External storage inaweza kuondolewa au kufikiwa na programu yoyote, ikifanya isiwe salama.
3. **Handling Data from External Storage**:
- Daima **fanya input validation** kwenye data inayorekebishwa kutoka external storage. Hii ni muhimu kwa sababu data ni kutoka chanzo kisichoaminika.
- Kuingiza executables au class files kwenye external storage kwa ajili ya dynamic loading inachukuliwa kuwa hatari na haipendekezwi.
- Ikiwa application yako lazima ipate faili za executable kutoka external storage, hakikisha faili hizi zimesainiwa na kuthibitishwa kwa cryptographic kabla ya kupakiwa kwa dynamic. Hatua hii ni muhimu kwa kudumisha uadilifu wa usalama wa application yako.

External storage inaweza kufikiwa katika `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Kuanzia na Android 4.4 (**API 17**), SD card ina muundo wa directories ambao **unapunguza ufikiaji kutoka kwa app hadi directory ambayo ni maalum kwa app hiyo**. Hii inazuia application hasidi kupata ufikiaji wa kusoma au kuandika kwa faili za app nyingine.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android inaruhusu kila application kuhifadhi faili za xml kwa urahisi katika path `/data/data/<packagename>/shared_prefs/` na wakati mwingine inawezekana kupata taarifa nyeti kwa clear-text katika folda hiyo.
- **Databases**: Android inaruhusu kila application kuhifadhi sqlite databases kwa urahisi katika path `/data/data/<packagename>/databases/` na wakati mwingine inawezekana kupata taarifa nyeti kwa clear-text katika folda hiyo.

### Broken TLS

**Accept All Certificates**

Kwa sababu fulani wakati mwingine developers wanakubali certificates zote hata kama kwa mfano hostname haifai na mistari ya msimbo kama ifuatayo:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Njia nzuri ya kujaribu hii ni kujaribu kunasa trafiki kwa kutumia proxy kama Burp bila kuthibitisha Burp CA ndani ya kifaa. Pia, unaweza kuz生成 certificate na Burp kwa hostname tofauti na kuitumia.

### Kriptografia Iliyovunjika

**Mchakato Duni wa Usimamizi wa Funguo**

Baadhi ya developers huhifadhi data nyeti kwenye storage ya ndani na kuikryptisha na ufunguo uliowekwa ndani/unaoweza kutabirika kwenye code. Hii haipaswi kufanywa kwa sababu reversing inaweza kuruhusu attackers kutoa taarifa za siri.

**Matumizi ya Algorithimu zisizo salama na/au Zilizotumika kwa Muda Mrefu**

Developers hawapaswi kutumia **deprecated algorithms** kufanya authorization **checks**, **store** au **send** data. Baadhi ya algorithm hizi ni: RC4, MD4, MD5, SHA1... Ikiwa **hashes** zinatumiwa kuhifadhi nywila kwa mfano, hash ambazo ni **brute-force resistant** zinapaswa kutumika pamoja na salt.

### Mambo mengine ya kukagua

- Inapendekezwa **ku-obfuscate the APK** ili kufanya kazi ya reverse engineer kuwa ngumu kwa attackers.
- Ikiwa app ni nyeti (kama bank apps), inapaswa kufanya **checks zake kuona kama simu ime-rooted** na kuchukua hatua ipasavyo.
- Ikiwa app ni nyeti (kama bank apps), inapaswa kuangalia kama **emulator** inatumiwa.
- Ikiwa app ni nyeti (kama bank apps), inapaswa **kuangalia integriti yake kabla ya kuitekeleza** ili kuhakikisha haijabadilishwa.
- Tumia [**APKiD**](https://github.com/rednaga/APKiD) kuona compiler/packer/obfuscator gani ilitumiwa kujenga APK

### React Native Application

Soma ukurasa ufuatao ili kujifunza jinsi ya kupata javascript code za React applications kwa urahisi:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Soma ukurasa ufuatao ili kujifunza jinsi ya kupata C# code za xamarin applications kwa urahisi:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Kulingana na [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked ni Meta algorithm inayobana (compress) yaliyomo ya application ndani ya faili moja. Blogu inazungumzia uwezekano wa kuunda app inayoweza ku-decompress aina hizi za apps... na njia ya haraka zaidi ambayo inahusisha **ku-execute application na kukusanya files zilizo-decompressed kutoka filesystem.**

### Automated Static Code Analysis

Tool ya [**mariana-trench**](https://github.com/facebook/mariana-trench) inaweza kupatikana kwa kutafuta **vulnerabilities** kwa **scanning** **code** ya application. Tool hii ina mfululizo wa **known sources** (inayoonyesha sehemu kwa tool ambapo **input** iko **controlled by the user**), **sinks** (inayoonyesha sehemu **dangerous** ambapo input ya mtumiaji mbaya inaweza kusababisha uharibifu) na **rules**. Kanuni hizi zinaeleza **mchanganyiko** wa **sources-sinks** unaoashiria udhaifu.

Kwa maarifa haya, **mariana-trench itapitia code na kupata udhaifu unaowezekana ndani yake**.

### Secrets leaked

Application inaweza kuwa na siri (API keys, passwords, hidden urls, subdomains...) ndani yake ambazo unaweza kugundua. Unaweza kutumia zana kama [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Mengineyo ya kazi za kuvutia

- **Utekelezaji wa Msimbo**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Kutuma SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Funsi za native** zilizo elezwa kama `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Mab trick mengine**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Uchambuzi wa Muda

> Kwanza kabisa, unahitaji mazingira ambapo unaweza kusakinisha application na mazingira yote (Burp CA cert, Drozer na Frida hasa). Kwa hivyo, kifaa chenye root (emulated au siyo) kinashauriwa sana.

### Online Dynamic analysis

Unaweza kuunda **free account** katika: [https://appetize.io/](https://appetize.io). Jukwaa hili linakuwezesha **upload** na **execute** APKs, hivyo ni muhimu kuona jinsi apk inavyo behave.

Hata unaweza **kuona logs za application yako** kwenye wavuti na kuungana kupitia **adb**.

![](<../../images/image (831).png>)

Shukrani kwa muunganisho wa ADB unaweza kutumia **Drozer** na **Frida** ndani ya emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Unaweza kuunda **x86** na **arm** devices, na kulingana na [**hii** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** bila kuhitaji slow arm emulator).
- Jifunze jinsi ya kuiweka hapa:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, unahitaji kuunda account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** ili kuepuka makosa ya uwezekano._)
- [**Nox**](https://es.bignox.com) (Free, lakini haitsupport Frida au Drozer).

> [!TIP]
> Unapotengeneza emulator mpya kwenye jukwaa lolote kumbuka kuwa skrini kubwa inafanya emulator kukimbia polepole. Hivyo chagua skrini ndogo iwezekanavyo.

Ili **kusakinisha google services** (kama AppStore) kwenye Genymotion unahitaji kubofya kitufe kilichowekwa kwa rangi nyekundu kwenye picha ifuatayo:

![](<../../images/image (277).png>)

Pia, fahamu kuwa katika **configuration ya Android VM katika Genymotion** unaweza kuchagua **Bridge Network mode** (hii itakuwa muhimu ikiwa utaungana kwenye Android VM kutoka VM tofauti yenye tools).

#### Use a physical device

Unahitaji kuwezesha chaguzi za **debugging** na itakuwa vizuri ikiwa unaweza kuendelea kui-**root**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Mara baada ya kusakinisha application, jambo la kwanza unalopaswa kufanya ni kuijaribu na kuchunguza inafanya nini, inafanya kazi vipi na kuzoea kuifanya.\
> Napendekeza **kufanya uchambuzi huu wa awali wa dynamic kwa kutumia MobSF dynamic analysis + pidcat**, hivyo tutaweza **kujifunza jinsi application inavyofanya kazi** wakati MobSF inakayaza data nyingi **zazovutia** ambazo unaweza kuzitathmini baadaye.

### Unintended Data Leakage

**Logging**

Developers wanapaswa kuwa waangalifu kutoonyesha **debugging information** hadharani, kwa maana inaweza kusababisha sensitive data leaks. Tools [**pidcat**](https://github.com/JakeWharton/pidcat) na `adb logcat` zinapendekezwa kwa kufuatilia application logs ili kubaini na kulinda taarifa nyeti. **Pidcat** inapendelewa kwa urahisi wa matumizi na readability.

> [!WARNING]
> Kumbuka kuwa kutoka **later newer than Android 4.0**, **applications are only able to access their own logs**. Hivyo applications haziwezi kupata logs za apps nyingine.\
> Hata hivyo, bado inashauriwa **kutoi-log taarifa nyeti**.

**Copy/Paste Buffer Caching**

Mfumo wa Android unaotegemea **clipboard** unaruhusu ufanyaji wa copy-paste katika apps, lakini una hatari ya kuwa **applications nyingine** zinaweza **access** clipboard, kwa hivyo zinaweza kufunua data nyeti. Ni muhimu **kuzima kazi za copy/paste** kwa sehemu nyeti za application, kama maelezo ya kadi ya mkopo, ili kuzuia data leaks.

**Crash Logs**

Ikiwa application inavunjika (crashes) na **inahifadhi logs**, logs hizi zinaweza kumsaidia attacker, hasa wakati application haiwezi kureverse-engineered. Ili kupunguza hatari hii, epuka kuandika logs wakati wa crash, na ikiwa logs lazima zitumwa kwenye network, hakikisha zinatumwa kwa njia ya SSL kwa usalama.

Kama pentester, **jaribu kuangalia logs hizi**.

**Analytics Data Sent To 3rd Parties**

Applications mara nyingi hujumuisha huduma kama Google Adsense, ambazo zinaweza kwa bahati mbaya **leak sensitive data** kutokana na utekelezaji usio sahihi na developers. Ili kubaini potential data leaks, inashauriwa **ku-intercept traffic ya application** na kuangalia kama taarifa nyeti zinatumwa kwa huduma za watu wa tatu.

### SQLite DBs

Wengi wa applications zitatafuta kutumia **internal SQLite databases** kuhifadhi taarifa. Wakati wa pentest angalia **databases** zilizoundwa, majina ya **tables** na **columns** na data zote zilizohifadhiwa kwa sababu unaweza kupata habari nyeti (ambayo inaweza kuwa vulnerability).\
Databases zinapaswa kuwa ziko kwenye `/data/data/the.package.name/databases` kama `/data/data/com.mwr.example.sieve/databases`

Ikiwa database inahifadhi taarifa za siri na ime **encrypted** lakini unaweza **find** **password** ndani ya application bado ni **vulnerability**.

Taja meza (tables) kwa kutumia `.tables` na orodhesha columns za meza kwa kutumia `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer ni tool muhimu ya **exploit exported activities, exported services and Content Providers** kama utakavyojifunza katika sehemu zifuatazo.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Kumbuka pia kwamba code ya activity inaanzia katika method ya **`onCreate`**.

**Authorisation bypass**

Wakati Activity ime-exported unaweza kuitia kwenye screen kutoka kwa app ya nje. Kwa hivyo, ikiwa activity yenye **taarifa nyeti** ime **exported** unaweza **bypass** mekanisme za **authentication** ili kuipata.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Unaweza pia kuanzisha exported activity kutoka adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**TAARIFA**: MobSF itaona kama hatari matumizi ya _**singleTask/singleInstance**_ kama `android:launchMode` katika activity, lakini kutokana na [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), inaonekana hii ni hatari tu kwenye toleo za zamani (API versions < 21).

> [!TIP]
> Kumbuka kwamba authorisation bypass si kila mara ni vulnerability; yote yatategemea jinsi bypass inavyofanya kazi na ni taarifa gani zinazoonyeshwa.

**Sensitive information leakage**

**Activities can also return results**. Ikiwa unaweza kupata activity iliyotumwa (exported) na isiyolindwa ikiyaita method ya **`setResult`** na **kurudisha sensitive information**, kuna sensitive information leakage.

#### Tapjacking

Kama tapjacking haizingwi, unaweza kutumia activity iliyotumwa (exported) kumuambia mtumiaji afanye vitendo visivyotarajiwa. Kwa maelezo zaidi kuhusu [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers kwa msingi hutumika **kushiriki data**. Ikiwa app ina content providers zinazopatikana, huenda ukaweza **kutoa sensitive** data kutoka kwazo. Ni muhimu pia kujaribu uwezekano wa **SQL injections** na **Path Traversals** kwani zinaweza kuwa vunerable.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Kumbuka kwamba vitendo vya Service huanza katika method `onStartCommand`.

Service kwa msingi ni kitu ambacho **kinaweza kupokea data**, **kuchakata** na **kurudisha** (au la) majibu. Hivyo, ikiwa application inatoa services, inapaswa **kagua** **code** ili kuelewa inafanya nini na **jaribu** kivitendo (**dynamically**) kupata taarifa za siri, kuzuia authentication measures...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Kumbuka kwamba vitendo vya Broadcast Receiver huanza katika method `onReceive`.

Broadcast receiver itakuwa ikisubiri aina fulani ya ujumbe. Kulingana na jinsi receiver inavyoshughulikia ujumbe, inaweza kuwa vunerable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Unaweza kutafuta deep links kwa mikono, ukitumia zana kama MobSF au scripts kama [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Unaweza **fungua** scheme iliyotangazwa kwa kutumia **adb** au **kivinjari**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Kumbuka kwamba unaweza **omit the package name** na kifaa cha mkononi kitaiteisha moja kwa moja app inayofaa kufungua link hiyo._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Msimbo unaotekelezwa**

Ili kupata **msimbo utakaoendeshwa katika App**, nenda kwenye activity inayoitwa na deeplink na tafuta function **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Taarifa nyeti**

Kila unapopata deep link hakikisha kwamba **haipokei data nyeti (kama passwords) kupitia vigezo vya URL**, kwa sababu programu nyingine yoyote inaweza **kuiga deep link na kuiba data hiyo!**

**Vigezo katika path**

Unapaswa **pia kukagua ikiwa deep link yoyote inatumia parameter ndani ya path** ya URL kama: `https://api.example.com/v1/users/{username}`, katika kesi hiyo unaweza kulazimisha path traversal kwa kuingia kitu kama: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Kumbuka kwamba ukipata endpoints sahihi ndani ya application unaweza kusababisha **Open Redirect** (ikiwa sehemu ya path inatumika kama domain name), **account takeover** (ikiwa unaweza kubadilisha maelezo ya users bila CSRF token na endpoint dhaifu ilitumia method sahihi) na aina nyingine yoyote ya vuln. Maelezo zaidi [hapa](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Ripoti ya [bug bounty ya kuvutia](https://hackerone.com/reports/855618) kuhusu links (_/.well-known/assetlinks.json_).

### Ukaguzi wa Transport Layer na Kushindwa kwa Uthibitishaji

- **Certificates hazichunguzwi kila mara ipasavyo** na applications za Android. Ni kawaida kwa applications hizi kupuuza onyo na kukubali self-signed certificates au, katika baadhi ya matukio, kurudi kutumia HTTP connections.
- **Mazungumzo wakati wa SSL/TLS handshake wakati mwingine ni dhaifu**, yakitumia insecure cipher suites. Uraha huo unafanya koneksheni kuwa nyeti kwa man-in-the-middle (MITM) attacks, na kuruhusu watakanya ku-decrypt data.
- **Leakage of private information** ni hatari wakati applications zina-authenticate kwa kutumia secure channels lakini kisha kuwasiliana kwa channels zisizo-secure kwa miamala mingine. Njia hii hairuhusu ulinzi wa data nyeti, kama session cookies au user details, dhidi ya interception na wahalifu.

#### Certificate Verification

Tutazingatia **certificate verification**. Uadilifu wa server's certificate lazima uathibitishwe ili kuboresha usalama. Hii ni muhimu kwa sababu misanidi ya TLS isiyo salama na upeleka wa data nyeti kupitia channels zisizo-encrypted vinaweza kusababisha hatari kubwa. Kwa hatua za kina juu ya kuthibitisha server certificates na kushughulikia vulnerabilities, rasilimali hii [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) inatoa mwongozo kamili.

#### SSL Pinning

SSL Pinning ni hatua ya usalama ambapo application inathibitisha server's certificate dhidi ya nakala inayojulikana iliyohifadhiwa ndani ya application yenyewe. Mbinu hii ni muhimu kuzuia MITM attacks. Kutekeleza SSL Pinning kunapendekezwa kwa nguvu kwa applications zinazoshughulikia taarifa nyeti.

#### Traffic Inspection

Ili kuchunguza HTTP traffic, ni muhimu **kufunga certificate ya proxy tool** (km: Burp). Bila kufunga certificate hii, traffic iliyosimbwa huenda ikasionelezeka kupitia proxy. Kwa mwongozo wa jinsi ya kufunga custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Applications zinazolenga **API Level 24 and above** zinahitaji mabadiliko kwenye Network Security Config ili kukubali proxy's CA certificate. Hatua hii ni muhimu kwa kuchunguza traffic iliyosimbwa. Kwa maelekezo ya kubadilisha Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Ikiwa **Flutter** inatumika, lazima ufuate maelekezo katika [**this page**](flutter.md). Hii ni kwa sababu, kuongeza tu certificate kwenye store haitafanya kazi kwani Flutter ina orodha yake ya CA zinazokubalika.

#### Static detection of SSL/TLS pinning

Kabla ya kujaribu runtime bypasses, panga haraka mahali pinning inatekelezwa ndani ya APK. Ugunduzi wa static utakusaidia kupanga hooks/patches na kuzingatia code paths sahihi.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Matumizi
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Mifano ya kanuni za pattern (JSON)
Tumia au ongeza signatures ili kugundua proprietary/custom pinning styles. Unaweza kupakia JSON yako mwenyewe na kufanya scan kwa kiwango kikubwa.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Skanning ya haraka kwenye apps kubwa kwa kutumia multi-threading na memory-mapped I/O; regex zilizotanguliwa hupunguza mzigo/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Lengo za kawaida za kugundua za kutathmini kisha:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Tumia maeneo yaliyolingana kupanga Frida hooks, static patches, au ukaguzi wa config kabla ya majaribio ya dynamic.



#### Bypassing SSL Pinning

When SSL Pinning is implemented, bypassing it becomes necessary to inspect HTTPS traffic. Mbinu mbalimbali zinapatikana kwa madhumuni haya:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Ni muhimu pia kutafuta udhaifu wa kawaida wa web ndani ya application. Maelezo ya kina juu ya kutambua na kupunguza udhaifu haya yapo mahali pengine na hayajumuishwi hapa.

### Frida

[Frida](https://www.frida.re) ni dynamic instrumentation toolkit kwa developers, reverse-engineers, na watafiti wa usalama.\
**Unaweza kufikia application inayokimbia na kuhook methods wakati wa run time ili kubadilisha tabia, kubadilisha thamani, kutoa thamani, kuendesha code tofauti...**\
Kama unataka pentest Android applications unahitaji kujua jinsi ya kutumia Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Kagua kama application inahifadhi taarifa nyeti ndani ya memory ambazo haipaswi kuhifadhi, kama passwords au mnemonics.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Hii itadump memory kwenye folda ./dump, na hapo unaweza grep kwa kitu kama:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Data nyeti katika Keystore**

Katika Android, Keystore ni mahali bora pa kuhifadhi data nyeti, hata hivyo, kwa ruhusa za kutosha bado ni **inawezekana kuifikia**. Kwa kuwa applications huwa zinaweka hapa **sensitive data in clear text**, pentests zinapaswa kukagua hili kwa kutumia root user, kwani mtu mwenye ufikiaji wa kimwili kwa kifaa anaweza kuiba data hii.

Hata kama app iliweka data katika Keystore, data inapaswa kusimbwa.

Ili kufikia data ndani ya keystore unaweza kutumia Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Kutumia script ifuatayo ya Frida kunaweza kumwezesha **bypass fingerprint authentication** ambayo Android applications zinaweza kutumia ili **kulinda maeneo fulani nyeti:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Picha za Usuli**

Unapoweka programu kwenye usuli, Android huhifadhi **snapshot ya programu** ili inaporekebishwa kurudi kwenye mbele (foreground) inaanza kupakia picha kabla ya programu, hivyo inaonekana kama programu ilipakiwa kwa haraka.

Hata hivyo, ikiwa snapshot hii ina **taarifa nyeti**, mtu mwenye ufikiaji wa snapshot anaweza **kuiba taarifa hiyo** (kumbuka unahitaji root ili kuifikia).

Snapshots hizi kwa kawaida huhifadhiwa hapa: **`/data/system_ce/0/snapshots`**

Android inatoa njia ya **kuzuia kunyakuliwa picha za skrini kwa kuweka parametro ya layout FLAG_SECURE**. Kwa kutumia flag hii, yaliyomo kwenye dirisha yanachukuliwa kuwa salama, na kuzuia kuonekana kwenye picha za skrini au kuonyeshwa kwenye skrini zisizo salama.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Mchambuzi wa Programu za Android**

Zana hii inaweza kukusaidia kusimamia zana tofauti wakati wa dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Waendelezaji mara nyingi huunda proxy components kama activities, services, na broadcast receivers ambazo zinashughulikia Intent hizi na kuzipeleka kwa methods kama `startActivity(...)` au `sendBroadcast(...)`, ambazo zinaweza kuwa hatarishi.

Hatari iko katika kuruhusu washambuliaji kuanzisha components za app zisizokuwa exported au kupata content providers nyeti kwa kubeleza Intent hizi. Mfano unaojulikana ni component ya `WebView` kubadilisha URLs kuwa vitu vya `Intent` kupitia `Intent.parseUri(...)` kisha kuvitekeleza, jambo ambalo linaweza kusababisha intent zenye madhara.

### Essential Takeaways

- **Intent Injection** ni sawa na tatizo la Open Redirect la web.
- Maenendo yanahusisha kupitisha `Intent` objects kama extras, ambayo yanaweza kuelekezwa tena ili kutekeleza operesheni zisizo salama.
- Inaweza kufichua components zisizokuwa exported na content providers kwa washambuliaji.
- Ubadilishaji wa URL kuwa `Intent` katika `WebView` unaweza kurahisisha vitendo visivyokusudiwa.

### Android Client Side Injections and others

Huenda unajua kuhusu aina hizi za vulnerabilities kutoka kwa Web. Lazima uwe mwangalifu hasa na vulnerabilities hizi katika application ya Android:

- **SQL Injection:** Unaposhughulika na dynamic queries au Content-Providers hakikisha unatumia parameterized queries.
- **JavaScript Injection (XSS):** Thibitisha kwamba support ya JavaScript na Plugin imezimwa kwa WebViews zote (imezimwa kwa default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews zinapaswa kuwa na ufikiaji wa file system uzimw (umewezeshwa kwa default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Katika kesi kadhaa, wakati application ya Android inapo maliza session cookie haifutwi au inaweza hata kuhifadhiwa kwenye disk
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Tathmini ya udhaifu ya application** ikitumia frontend nzuri inayotegemea web. Unaweza pia kufanya dynamic analysis (lakini unahitaji kuandaa mazingira).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF pia inaruhusu kufanya **diff/Compare** ya analysis na kuunganisha **VirusTotal** (utahitaji kuweka API key yako katika _MobSF/settings.py_ na kuiwezesha: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Unaweza pia kuweka `VT_UPLOAD` kuwa `False`, basi the **hash** itakuwa **upload** badala ya faili.

### Uchambuzi wa Dynamic uliosaidiwa na MobSF

**MobSF** inaweza pia kuwa msaada mkubwa kwa ajili ya **dynamic analysis** katika **Android**, lakini katika kesi hiyo utahitaji kusanidi MobSF na **genymotion** kwenye host yako (VM au Docker hazitafanya kazi). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** inaweza:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Yote haya hufanywa kwa otomatiki isipokuwa kwa screenshots, unahitaji kubofya unapotaka screenshot au unahitaji kubofya "**Exported Activity Tester**" kupata screenshots za exported activities zote.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Kuanzia android **versions > 5**, itaanza **Frida** kwa **automatic** na itaweka global **proxy** settings ili **capture** trafiki. Itakamata trafiki tu kutoka kwa application inayojaribiwa.

**Frida**

Kwa default, itatumia pia baadhi ya Frida Scripts ili **bypass SSL pinning**, **root detection** na **debugger detection** na pia **monitor interesting APIs**.\
MobSF pia inaweza **invoke exported activities**, kuchukua **screenshots** za hizo activities na **save** kwa ajili ya report.

Ili kuanza dynamic testing bonyeza kitufe kijani: "**Start Instrumentation**". Bonyeza "**Frida Live Logs**" ili kuona logs zinazozalishwa na Frida scripts na "**Live API Monitor**" kuona mikao yote ya invocation kwa hooked methods, arguments zilizopita na values zilizorejeshwa (hii itaonekana baada ya kubofya "Start Instrumentation").\
MobSF pia inakuwezesha kupakia **Frida scripts** zako mwenyewe (to send the results of your Friday scripts to MobSF use the function `send()`). Ina pia **several pre-written scripts** unaweza kupakia (unaweza kuongeza zaidi katika `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), chagua tu, bonyeza "**Load**" na kisha bonyeza "**Start Instrumentation**" (utaweza kuona logs za scripts hizo ndani ya "**Frida Live Logs**").

![](<../../images/image (419).png>)

Zaidi ya hayo, una baadhi ya functionalities za ziada za Frida:

- **Enumerate Loaded Classes**: Itaonyesha madarasa yote yaliyo loaded
- **Capture Strings**: Itaonyesha strings zote zinazokamatwa wakati wa kutumia application (inazalisha kelele nyingi)
- **Capture String Comparisons**: Inaweza kuwa muhimu sana. Itaonyesha **strings 2 zinazolinganishwa** na kama matokeo yalikuwa True au False.
- **Enumerate Class Methods**: Weka jina la class (kama "java.io.File") na itaonyesha methods zote za class hiyo.
- **Search Class Pattern**: Tafuta classes kwa pattern
- **Trace Class Methods**: **Trace** class nzima (ona inputs na outputs za methods zote za class). Kumbuka kwamba kwa default MobSF hufuatilia methods kadhaa zenye umuhimu za Android Api.

Mara tu unapochagua module ya ziada unayotaka kutumia unahitaji kubofya "**Start Intrumentation**" na utaona outputs zote katika "**Frida Live Logs**".

**Shell**

Mobsf pia inakuleta shell yenye amri za **adb**, **MobSF commands**, na amri za kawaida za **shell** chini ya ukurasa wa dynamic analysis. Baadhi ya amri zinazovutia:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Wakati trafiki ya HTTP inapokamatwa unaweza kuona muonekano mbaya wa trafiki iliyokamatwa kwenye kitufe "**HTTP(S) Traffic**" au muonekano mzuri kwenye kitufe kijani "**Start HTTPTools**". Kutoka chaguo la pili, unaweza **send** the **captured requests** to **proxies** kama Burp au Owasp ZAP.\
Ili kufanya hivyo, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> bonyeza "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Mara baada ya kumaliza the dynamic analysis na MobSF unaweza kubonyeza "**Start Web API Fuzzer**" ili **fuzz http requests** na kutafuta udhaifu.

> [!TIP]
> Baada ya kufanya the dynamic analysis na MobSF mipangilio ya proxy inaweza kuwa imepangwa vibaya na huwezi kuirekebisha kutoka GUI. Unaweza kurekebisha mipangilio ya proxy kwa kufanya:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Uchambuzi wa Dynamic uliosaidiwa na Inspeckage

Unaweza kupata zana kutoka [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Zana hii itatumia baadhi ya **Hooks** kukujulisha **kinachotokea katika application** wakati unafanya a **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Hii ni **zana nzuri ya kufanya static analysis kwa GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Zana hii imeundwa kutafuta udhaifu mbalimbali zinazohusiana na usalama za Android application, iwe katika **source code** au **packaged APKs**. Zana pia ina uwezo wa kuunda "Proof-of-Concept" deployable APK na **ADB commands**, ili kutumia baadhi ya udhaifu uliopatikana (Exposed activities, intents, tapjacking...). Kama ilivyo kwa Drozer, hakuna haja ya ku-root kifaa cha mtihani.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Inaonyesha faili zote zilizotolewa kwa marejeo rahisi
- Hu-decompile faili za APK moja kwa moja hadi muundo wa Java na Smali
- Huchambua AndroidManifest.xml kwa ajili ya udhaifu na tabia za kawaida
- Uchambuzi wa static wa source code kwa ajili ya udhaifu na tabia za kawaida
- Taarifa za kifaa
- na zaidi
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER ni programu ya command-line inayoweza kutumika kwenye Windows, MacOS X na Linux, inayochambua faili za _.apk_ kwa kutafuta vulnerabilities. Inafanya hivyo kwa kuzifungua APKs na kutumia mfululizo wa sheria kugundua vulnerabilities hizo.

Sheria zote ziko katika faili ya `rules.json`, na kila kampuni au mtapimaji anaweza kuunda sheria zake za kuchambua wanazohitaji.

Pakua binaries za hivi karibuni kutoka kwenye [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn ni zana ya **crossplatform** inayowawezesha waendelezaji, bugbounty hunters na ethical hackers kufanya [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) kwenye programu za rununu.

Dhana ni kwamba unaburuta na kuachia faili ya programu yako ya rununu (faili .apk au .ipa) kwenye application ya StaCoAn na itatengeneza ripoti ya kuona na inayoweza kubebwa kwako. Unaweza kubadilisha mipangilio na wordlists ili kupata uzoefu uliyobinafsishwa.

Pakua[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework ni mfumo wa uchambuzi wa udhaifu wa Android unaosaidia waendelezaji au hackers kugundua udhaifu za usalama zinazowezekana katika programu za Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** ni zana ambayo lengo lake kuu ni kugundua na kuwaonya mtumiaji kuhusu tabia hatari zinazoweza kufanywa na Android application.

Ugundaji hufanywa kwa **static analysis** ya application's Dalvik bytecode, inayowakilishwa kama **Smali**, kwa kutumia maktaba [`androguard`](https://github.com/androguard/androguard).

Zana hii inatafuta **common behavior of "bad" applications** like: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Ni chombo kinachoongeza pamoja zana zinazotumika mara kwa mara za mobile application reverse engineering na analysis, kusaidia katika kujaribu mobile applications dhidi ya vitisho vya OWASP mobile security. Lengo lake ni kufanya kazi hii iwe rahisi na rafiki kwa watengenezaji wa mobile application na wataalamu wa usalama.

Ina uwezo wa:

- Kutoa msimbo wa Java na Smali kwa kutumia zana mbalimbali
- Kuchambua APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Kutoa taarifa za kibinafsi kutoka kwenye APK kwa kutumia regexps.
- Kuchambua Manifest.
- Kuchambua domain zilizopatikana using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Kuondoa obfuscation ya APK kupitia [apk-deguard.com]

### Koodous

Inafaa kugundua malware: [https://koodous.com/](https://koodous.com/)

## Kuficha/Kuondoa kuficha msimbo

Kumbuka kwamba, kulingana na huduma na usanidi unayotumia kuficha msimbo, siri zinaweza kufichwa au zisifichwe.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** ni zana ya open source ya command-line inayopunguza, kuboresha na kuficha Java code. Ina uwezo wa kuboresha bytecode pamoja na kugundua na kuondoa maagizo yasiyotumika. ProGuard ni programu huria na inasambazwa chini ya GNU General Public License, version 2.

ProGuard inatolewa kama sehemu ya Android SDK na inafanya kazi wakati wa kujenga application katika release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Pata mwongozo hatua kwa hatua wa ku-deobfuscate apk katika [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Mara ya mwisho tulipoangalia, mode ya uendeshaji wa Dexguard ilikuwa:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Unaweza kupakia APK iliyofichwa kwenda kwenye platform yao.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Hii ni zana ya LLM ya kutafuta udhaifu wowote wa usalama katika android apps na ku-deobfuscate android app code. Inatumia Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Ni generic android deobfuscator. Simplify virtually executes an app ili kuelewa mienendo yake kisha inajaribu optimize the code ili iitende sawa lakini iwe rahisi kwa binadamu kuelewa. Kila aina ya optimization ni rahisi na generic, hivyo haijalishi aina maalum ya obfuscation inayotumiwa.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD inakupa taarifa kuhusu **how an APK was made**. Inatambua many **compilers**, **packers**, **obfuscators**, na mambo mengine ya ajabu. Ni [_PEiD_](https://www.aldeid.com/wiki/PEiD) kwa Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Maabara

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b ni Android security virtual machine inayotokana na ubuntu-mate inayojumuisha mkusanyiko wa latest framework, tutorials na labs kutoka kwa security geeks na researchers mbalimbali kwa reverse engineering na malware analysis.

## Marejeo

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Ni orodha nzuri ya rasilimali
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Bado kujaribu

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
