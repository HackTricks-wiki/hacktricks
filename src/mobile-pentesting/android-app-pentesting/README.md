# Androidアプリケーション Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Androidアプリケーションの基本

このページを先に読むことを強く推奨します。**Androidのセキュリティに関連する最も重要な部分と、Androidアプリケーション内で最も危険なコンポーネント**について知るためです：


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

これは、Androidデバイス（エミュレートされたものまたは実機）に接続するために必要な主要なツールです。\
**ADB**を使うと、コンピュータから**USB**または**Network**経由でデバイスを制御できます。このユーティリティは、ファイルの双方向の**コピー**、アプリの**インストール**および**アンインストール**、**shell**コマンドの実行、データの**バックアップ**、ログの**読み取り**などの機能を提供します。

ADBの使い方を学ぶには、次の[**ADB Commands**](adb-commands.md)の一覧を参照してください。

## Smali

場合によっては、アプリケーションのコードを修正して隠された情報（難読化されたパスワードやフラグなど）へアクセスすることが有効です。その場合、APKを逆コンパイルしてコードを変更し、再コンパイルすることが有用です。\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md)。これは、後述する動的解析のテストの代替手段として非常に役立ちます。常にこの可能性を念頭に置いてください。

## その他の興味深いテクニック

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **APKをダウンロード**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- デバイスからAPKを抽出:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- すべての splits と base apks を [APKEditor](https://github.com/REAndroid/APKEditor) でマージする:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

まず、APKを解析する際はデコンパイラを使って**Javaコードを確認する**べきです。\
[**利用可能なさまざまなデコンパイラについてはこちらを参照してください**](apk-decompilers.md)。

### Looking for interesting Info

APKの**strings**をざっと見るだけでも、**passwords**、**URLs**（https://github.com/ndelphit/apkurlgrep）、**api keys**、**encryption**、**bluetooth uuids**、**tokens**など興味深いものを探せます。コード実行のbackdoorsや認証backdoors（アプリにハードコードされた管理者資格情報）も探してください。

Firebase

**firebase URLs**には特に注意し、設定ミスがないか確認してください。[More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

アプリの**Manifest.xml**および**strings.xml**の確認は、潜在的なセキュリティ脆弱性を明らかにすることがあります。これらのファイルはデコンパイラで取得するか、APKの拡張子を .zip に変更して展開することでアクセスできます。

**Manifest.xml**から判明する可能性がある脆弱性には次があります:

- **Debuggable Applications**: _Manifest.xml_ に `debuggable="true"` が設定されたアプリは、接続を許可し悪用につながるリスクがあります。デバッグ可能なアプリの発見と悪用方法については関連チュートリアルを参照してください。
- **Backup Settings**: 機密情報を扱うアプリでは `android:allowBackup="false"` を明示的に設定して、特に usb debugging が有効な場合の adb を介した不正なデータバックアップを防ぐべきです。
- **Network Security**: _res/xml/_ のカスタム network security 設定（`android:networkSecurityConfig="@xml/network_security_config"`）は、証明書ピン（certificate pins）や HTTP トラフィックの許可設定などのセキュリティ詳細を指定できます。特定ドメインに対して HTTP を許可する例などがあります。
- **Exported Activities and Services**: マニフェスト内でエクスポートされた activities や services を特定すると、悪用されうるコンポーネントが分かります。動的テスト中の詳細解析でこれらの悪用方法が明らかになることがあります。
- **Content Providers and FileProviders**: 公開された content providers は不正なアクセスやデータ改ざんを許す可能性があります。FileProviders の設定も注意深く確認してください。
- **Broadcast Receivers and URL Schemes**: これらのコンポーネントは悪用に使われることがあり、特に URL スキームの扱いによる入力の脆弱性に注意が必要です。
- **SDK Versions**: `minSdkVersion`、`targetSDKVersion`、`maxSdkVersion` 属性はサポートされる Android バージョンを示します。古く脆弱な Android バージョンをサポートしていないか確認することが重要です。

**strings.xml** からは API keys、カスタムスキーマ、開発者メモなどの機密情報が見つかる場合があり、これらのリソースは注意深く確認する必要があります。

### Tapjacking

Tapjacking は、悪意のある application を起動して被害者アプリの上に**自身を重ねて配置する**攻撃です。被害者アプリを視覚的に覆い隠すと、そのユーザインタフェースはユーザを騙して操作させるように設計され、同時にその操作を被害者アプリへ渡します。\
結果として、ユーザは実際には被害者アプリ上で操作を行っていることに気づかずに操作を続けてしまいます。

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode` が `singleTask` に設定され、かつ `taskAffinity` が定義されていない activity は task Hijacking の脆弱性があります。これは、悪意ある application をインストールし、本物のアプリより先に起動すると**本物のアプリのタスクをハイジャックする**可能性があるということです（ユーザは本物のアプリを使っているつもりで、実際には悪意あるアプリとやり取りしていることになります）。

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

Internal Storage

Androidでは、内部ストレージに保存されたファイルは作成したアプリのみがアクセスできるよう設計されています。このセキュリティ措置はOSにより強制され、ほとんどのアプリのセキュリティ要件には十分です。しかし、開発者が `MODE_WORLD_READABLE` や `MODE_WORLD_WRITABLE` のようなモードを使用してファイルを他のアプリ間で共有することがあります。これらのモードはファイルへのアクセスを他のアプリ（悪意あるアプリを含む）から制限しません。

1. Static Analysis:
- `MODE_WORLD_READABLE` と `MODE_WORLD_WRITABLE` の使用は**慎重に精査**してください。これらのモードはファイルを**意図しない、または不正なアクセスに対して露出させる**可能性があります。
2. Dynamic Analysis:
- アプリが作成するファイルに設定された権限を**検証**してください。特に、ファイルが世界中で読み取り可能または書き込み可能に設定されていないか**確認**します。これは重大なセキュリティリスクとなり、デバイスにインストールされている**任意のアプリ**がこれらのファイルを読み書きできることを意味します。

External Storage

SDカードなどの外部ストレージ上のファイルを扱う際には、以下に注意してください:

1. Accessibility:
- 外部ストレージ上のファイルは**グローバルに読み書き可能**です。つまり、任意のアプリやユーザがアクセスできます。
2. Security Concerns:
- アクセスが容易なため、機密情報を外部ストレージに保存しないことが推奨されます。
- 外部ストレージは取り外されたり、任意のアプリによってアクセスされ得るため、セキュリティ面で脆弱です。
3. Handling Data from External Storage:
- 外部ストレージから取得したデータは必ず**入力検証**を行ってください。外部ストレージ上のデータは信頼できないソースからのものであるため、これは非常に重要です。
- 外部ストレージに実行ファイルやクラスファイルを配置して動的にロードすることは強く推奨されません。
- アプリがどうしても外部ストレージから実行ファイルを取得して動的にロードする必要がある場合、それらのファイルが**署名され、暗号学的に検証されている**ことを確認してください。これはアプリのセキュリティ整合性を維持するために重要です。

外部ストレージには /storage/emulated/0、/sdcard、/mnt/sdcard でアクセスできます

> [!TIP]
> Android 4.4（**API 17**）以降、SDカードにはアプリごとに専用のディレクトリ構造があり、アプリが自分用のディレクトリ以外へアクセスすることを制限します。これにより、悪意のあるアプリが別アプリのファイルに読み書きアクセスするのを防ぎます。

Sensitive data stored in clear-text

- **Shared preferences**: Android は各アプリが `/data/data/<packagename>/shared_prefs/` に簡単に xml ファイルを保存できるようにしており、そのフォルダ内に平文で保存された機密情報が見つかることがあります。
- **Databases**: Android は各アプリが `/data/data/<packagename>/databases/` に sqlite データベースを保存できるようにしており、そのフォルダ内に平文で保存された機密情報が見つかることがあります。

### Broken TLS

Accept All Certificates

なぜか開発者がすべての証明書を受け入れてしまうことがあり、例えばホスト名が一致しない場合でも次のようなコード行でそれを許してしまうことがあります:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 暗号化の不備

**不十分なキー管理プロセス**

一部の開発者は機密データをローカルストレージに保存し、コード内にハードコード/予測可能なキーで暗号化します。これはリバースによって攻撃者が機密情報を抽出できる可能性があるため、行うべきではありません。

**安全でない／非推奨のアルゴリズムの使用**

開発者は認証の**チェック**、データの**保存**や**送信**に**非推奨のアルゴリズム**を使用すべきではありません。これらのアルゴリズムには RC4, MD4, MD5, SHA1... などがあります。例えばパスワードの保存にハッシュを使用する場合は、ソルトを用いたブルートフォース耐性のあるハッシュを使うべきです。

### その他のチェック

- APKを**難読化**してリバースエンジニアの作業を困難にすることを推奨します。
- アプリが機密性の高いもの（銀行アプリ等）であれば、端末がroot化されているかどうかを確認する**独自のチェック**を行い、それに応じて対処するべきです。
- アプリが機密性の高いもの（銀行アプリ等）であれば、**エミュレータ**が使用されているかを確認するべきです。
- アプリが機密性の高いもの（銀行アプリ等）であれば、実行前に**自身の整合性をチェック**して改変されていないか確認するべきです。
- APKがどのコンパイラ/パッカー/難読化ツールでビルドされたかを確認するには [**APKiD**](https://github.com/rednaga/APKiD) を使用してください。

### React Native Application

Reactアプリケーションのjavascriptコードに簡単にアクセスする方法を学ぶには次のページを参照してください:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

XamarinアプリのC#コードに簡単にアクセスする方法を学ぶには次のページを参照してください:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

この[**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)によれば、superpackedはアプリケーションのコンテンツを単一ファイルに圧縮するMetaアルゴリズムです。ブログではこの種のアプリを解凍するアプリを作成する可能性について述べており、より高速な方法として**アプリケーションを実行してファイルシステムから解凍済みファイルを収集する**手法も紹介しています。

### Automated Static Code Analysis

ツール [**mariana-trench**](https://github.com/facebook/mariana-trench) はアプリケーションの**コード**を**スキャン**して**脆弱性**を発見することができます。このツールは一連の**known sources**（ツールに対して**入力がユーザにより制御される場所**を示す）、**sinks**（悪意あるユーザ入力が害を与える可能性のある**危険な場所**を示す）および**rules**を含んでいます。これらのルールは脆弱性を示す**sources-sinks の組み合わせ**を定義します。

この仕組みにより、**mariana-trench はコードをレビューして潜在的な脆弱性を検出します**。

### Secrets leaked

アプリケーションには APIキー、パスワード、隠れた URL、サブドメインなどの機密情報が含まれている場合があり、それらを発見できることがあります。例えば [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) のようなツールを使うことができます。

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [ネイティブ関数を逆解析する方法はこちらを参照してください](reversing-native-libraries.md)
- JNI経由でのメモリ内ネイティブコード実行（ダウンロードしたshellcode → mmap/mprotect → call）:

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> まず第一に、アプリケーションをインストールでき、環境（Burp CA cert、Drozer、Frida など）を整えられる環境が必要です。したがって、root化されたデバイス（エミュレータか実機かを問わず）が強く推奨されます。

### Online Dynamic analysis

無料アカウントを作成できるサービス: [https://appetize.io/](https://appetize.io)。このプラットフォームではAPKを**アップロード**して**実行**できるため、APKの挙動を確認するのに便利です。

ウェブ上で**アプリのログを確認**したり、**adb**で接続することもできます。

![](<../../images/image (831).png>)

ADB接続を利用することでエミュレータ内で **Drozer** や **Frida** を使用できます。

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio)（**x86**および**arm**デバイスを作成可能。 [**こちら**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) によれば最新の x86 は遅い arm エミュレータを使わずとも ARM ライブラリをサポートします。）
- セットアップ方法は次のページを参照してください:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(無料版: Personal Edition、アカウント作成が必要です。エラーを避けるために**VirtualBox**同梱版を**ダウンロード**することを推奨します。)**
- [**Nox**](https://es.bignox.com)（無料。ただし Frida や Drozer をサポートしていません。）

> [!TIP]
> 新しいエミュレータを作成する際、画面が大きいほどエミュレータは遅くなります。可能なら小さい画面を選んでください。

Genymotion に Google サービス（AppStore 等）をインストールするには、次の画像の赤で表示されたボタンをクリックしてください:

![](<../../images/image (277).png>)

また、**Genymotion の Android VM の設定**で **Bridge Network mode** を選択できる点に注意してください（これは別の VM からツールで Android VM に接続する場合に便利です）。

#### Use a physical device

デバッグオプションを有効にし、可能であればroot化しておくと便利です:

1. **Settings**.
2. (Android 8.0以降) **System** を選択。
3. **About phone** を選択。
4. **Build number** を7回押す。
5. 戻ると **Developer options** が表示されます。

> アプリをインストールしたら、まずは動作を確認して何をするのか、どのように動くのかを調べて慣れてください。\
> 初期の動的解析は MobSF dynamic analysis + pidcat を使って行うことを推奨します。これにより、アプリの動作を学びつつ MobSF が後で確認できる多くの興味深いデータをキャプチャします。

Magisk/Zygisk クイックノート（Pixelデバイスで推奨）
- Magiskアプリで boot.img をパッチし fastboot でフラッシュして systemless root を取得。
- Zygisk を有効化し DenyList で root 隠蔽；より強い隠蔽が必要な場合は LSPosed/Shamiko を検討。
- OTA アップデートから回復するために元の boot.img を保存しておき、OTA 後に再パッチする。
- 画面ミラーリングにはホスト側で scrcpy を使用。

### Unintended Data Leakage

**Logging**

開発者は**デバッグ情報**を公に晒すことに注意すべきです。これは機密データの漏洩につながる可能性があります。アプリのログを監視して機密情報の保護を確認するには [**pidcat**](https://github.com/JakeWharton/pidcat) や `adb logcat` を使用することを推奨します。**Pidcat** は使いやすさと可読性の面で好まれます。

> [!WARNING]
> Android 4.0 より新しいバージョンでは、**アプリは自身のログのみアクセス可能**です。他のアプリのログにはアクセスできません。\
> とはいえ、機密情報をログに出力しないことを強く推奨します。

**Copy/Paste Buffer Caching**

Android の**クリップボードベース**のフレームワークはコピー＆ペーストの機能を提供しますが、**他のアプリがクリップボードにアクセスできる**ため機密データが露出するリスクがあります。クレジットカード情報などの機密セクションではコピー／ペースト機能を無効にすることが重要です。

**Crash Logs**

アプリが**クラッシュ**してログを保存する場合、これらのログはリバースできない状況でも攻撃者の助けになることがあります。このリスクを軽減するために、クラッシュ時にログを記録しないようにするか、ネットワーク経由で送信する必要がある場合は必ず SSL チャネルで送信してください。

ペンテスターとして、**これらのログを確認する**ことを試みてください。

**Analytics Data Sent To 3rd Parties**

アプリはしばしば Google Adsense のようなサービスを統合しており、開発者の実装ミスにより機密データを第三者に**送信してしまう**ことがあります。潜在的なデータ漏洩を特定するためには、アプリのトラフィックをインターセプトして、第三者に送信されている機密情報がないか確認することを推奨します。

### SQLite DBs

ほとんどのアプリは情報保存のために**内部の SQLite データベース**を使用します。ペンテスト中には作成された**データベース**、**テーブル名**や**カラム名**、保存されている**全データ**を確認してください。ここに機密情報が見つかることがあります（これは脆弱性となります）。\
データベースは通常 `/data/data/the.package.name/databases` にあります（例: `/data/data/com.mwr.example.sieve/databases`）。

データベースが暗号化されていても、もしアプリ内でその**パスワード**を見つけられるなら、それは依然として**脆弱性**です。

.tables を使ってテーブルを列挙し、`.schema <table_name>` でテーブルのカラムを確認してください。

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** は Android アプリの役割を引き受け、他のアプリと相互作用することを可能にします。インストールされたアプリができることは何でも行え、Android の Inter-Process Communication (IPC) 機構を利用して基盤となる OS とやり取りできます。\
Drozer はエクスポートされた Activities、エクスポートされた Services、および Content Providers を**悪用**するのに有用なツールです。以下のセクションで学びます。

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
また、Activity のコードは **`onCreate`** メソッドから始まることを覚えておいてください。

**Authorisation bypass**

Activity が exported になっている場合、外部アプリからその画面を呼び出すことができます。したがって、**機密情報**を表示する Activity が **exported** になっている場合は、その認証機構を**バイパスしてアクセス**できる可能性があります。

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

また、adb からエクスポートされた Activity を起動することもできます:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Note that an authorisation bypass is not always a vulnerability, it would depend on how the bypass works and which information is exposed.

**機密情報の漏洩**

**Activities can also return results**. If you manage to find an exported and unprotected activity calling the **`setResult`** method and **returning sensitive information**, there is a sensitive information leakage.

#### Tapjacking

If Tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers are basically used to **share data**. If an app has available content providers you may be able to **extract sensitive** data from them. It also interesting to test possible **SQL injections** and **Path Traversals** as they could be vulnerable.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Remember that a the actions of a Service start in the method `onStartCommand`.

As service is basically something that **can receive data**, **process** it and **returns** (or not) a response. Then, if an application is exporting some services you should **check** the **code** to understand what is it doing and **test** it **dynamically** for extracting confidential info, bypassing authentication measures...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Remember that a the actions of a Broadcast Receiver start in the method `onReceive`.

A broadcast receiver will be waiting for a type of message. Depending on how the receiver handles the message it could be vulnerable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
You can **open** a declared **scheme** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_パッケージ名を**省略**できることに注意してください。モバイルはそのリンクを開くアプリを自動的に呼び出します._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

アプリで実行される**code that will be executed in the App**を見つけるには、deeplinkで呼ばれる activity に移動し、関数 **`onNewIntent`** を検索します。

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

deep link を見つけたら、**URL parameters 経由で sensitive data（例: passwords）を受け取っていないか**必ず確認してください。なぜなら他のアプリケーションが**deep link を偽装してそのデータを盗む**可能性があるためです！

**Parameters in path**

URL のパス内でパラメータを使用している deep link がないか**も確認する必要があります**。例えば `https://api.example.com/v1/users/{username}` のような場合、`example://app/users?username=../../unwanted-endpoint%3fparam=value` のようにパス・トラバーサルを強制できることがあります。\
アプリ内で正しい endpoints を見つけられれば、パスの一部がドメイン名として使われている場合の **Open Redirect**、CSRF トークンなしでユーザ情報を変更できる場合の **account takeover**（脆弱なエンドポイントが正しいメソッドを使っている場合）、その他の脆弱性を引き起こせる可能性があります。More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates が常に正しく検査されているとは限りません。** Android アプリでは自己署名証明書を受け入れたり、場合によっては HTTP 接続にフォールバックしてしまうことがよくあります。
- **SSL/TLS ハンドシェイク時のネゴシエーションが弱い場合があり、** 安全でない cipher suites を使っていることがあります。この脆弱性により MITM 攻撃を受け、通信内容が復号される可能性があります。
- **private information の漏洩** は、アプリが一部の認証を安全なチャネルで行いながら、他のトランザクションを非暗号化チャネルで行う場合にリスクとなります。この方法だとセッション cookie やユーザ情報などの機密データが悪意ある第三者に傍受される可能性があります。

#### Certificate Verification

ここでは **certificate verification** に焦点を当てます。サーバの証明書の整合性を検証することはセキュリティ向上のために重要です。不適切な TLS 設定や機密データを暗号化されていないチャンネルで送信することは重大なリスクをもたらします。サーバ証明書の検証と脆弱性対応手順についての詳細は、[**this resource**](https://manifestsecurity.com/android-application-security-part-10/) を参照してください。

#### SSL Pinning

SSL Pinning は、アプリがサーバ証明書をアプリ内に保持された既知のコピーと照合するセキュリティ手法です。これは MITM 攻撃を防ぐために重要で、機密情報を扱うアプリでは実装が強く推奨されます。

#### Traffic Inspection

HTTP トラフィックを検査するには、プロキシツール（例: Burp）の証明書を**インストールする必要があります**。この証明書を入れないと、暗号化されたトラフィックはプロキシ経由で見えないことがあります。カスタム CA 証明書のインストール方法については [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine) を参照してください。

API Level 24 以上をターゲットにしているアプリは、プロキシの CA 証明書を受け入れるために Network Security Config の変更が必要です。暗号化トラフィックを検査するにはこの手順が重要です。Network Security Config の変更方法は [**refer to this tutorial**](make-apk-accept-ca-certificate.md) をご覧ください。

もし **Flutter** を使用している場合は [**this page**](flutter.md) の指示に従う必要があります。単に証明書をストアに追加するだけでは機能しないためです。Flutter は独自の有効な CA リストを持っています。

#### Static detection of SSL/TLS pinning

ランタイムでのバイパスを試す前に、APK 内で pinning がどこに強制されているかを静的にマッピングしておきます。静的検出によりフックやパッチの計画が立てやすく、適切なコードパスに注力できます。

Tool: SSLPinDetect
- APK を Smali（apktool 経由）にデコンパイルし、SSL/TLS pinning 実装の正規表現パターンをスキャンするオープンソースの静的解析ユーティリティです。
- 各マッチについて正確なファイルパス、行番号、コードスニペットを報告します。
- 一般的なフレームワークやカスタム実装をカバーします: OkHttp CertificatePinner、カスタム javax.net.ssl.X509TrustManager.checkServerTrusted、SSLContext.init とカスタム TrustManagers/KeyManagers、Network Security Config XML pins など。

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
使い方
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
パターンルールの例 (JSON)
signatures を使用または拡張して、proprietary/custom pinning styles を検出します。  
独自の JSON を読み込んで、大規模に scan できます。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
ノートとヒント
- 大規模アプリを multi-threading と memory-mapped I/O で高速スキャン；pre-compiled regex はオーバーヘッドや false positives を減らす。
- パターン集: https://github.com/aancw/smali-sslpin-patterns
- 次にトリアージすべき典型的な検出対象:
- OkHttp: CertificatePinner の使用、setCertificatePinner、okhttp3/okhttp パッケージ参照
- Custom TrustManagers: javax.net.ssl.X509TrustManager、checkServerTrusted のオーバーライド
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init とカスタムマネージャ
- res/xml の network security config に宣言された pins と manifest の参照
- 一致した場所を使って、動的テストの前に Frida hooks、static patches、または config reviews を計画する。



#### SSL Pinning のバイパス

SSL Pinning が実装されている場合、HTTPS トラフィックを確認するためにそれをバイパスする必要があります。この目的のためにいくつかの方法が利用可能です:

- 自動的に **apk** を修正して [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) を使って SSLPinning を **バイパス** する。 このオプションの最大の利点は、SSL Pinning をバイパスするのに root が不要な点だが、アプリを削除して新しいものを再インストールする必要があり、常にうまくいくとは限らない。
- この保護をバイパスするために **Frida**（下記参照）を使うことができる。Burp+Frida+Genymotion を使うためのガイド: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- また [**objection**](frida-tutorial/objection-tutorial.md) を使って **自動的に SSL Pinning をバイパス** することも可能： `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- また **MobSF dynamic analysis** を使用して **自動的に SSL Pinning をバイパス** することも試せる（下記参照）
- それでもキャプチャできていないトラフィックがあると思われる場合は、**iptables を使ってトラフィックを burp に転送** することを試せる。ブログを読む: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 一般的なWeb脆弱性の探索

アプリ内の一般的な Web 脆弱性も検索することが重要です。これらの脆弱性の特定や緩和に関する詳細はこの要約の範囲を超えますが、他の場所で広く扱われています。

### Frida

[Frida](https://www.frida.re) は開発者、リバースエンジニア、セキュリティ研究者向けの動的インストゥルメンテーションツールキットです.\
**実行中のアプリケーションにアクセスして、ランタイムでメソッドにフックし、振る舞いを変更したり、値を変更・抽出したり、別のコードを実行したりできます...**\
Android アプリを pentest するなら Frida の使い方を知っておく必要があります。

- Frida の使い方を学ぶ: [**Frida tutorial**](frida-tutorial/index.html)
- Frida の操作用の "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection は Frida の利用を自動化するのに便利: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- 便利な Frida スクリプトがいくつか見つかる: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- anti-debugging / anti-frida 機構を回避するために Frida をロードしてバイパスする方法を試してみてください: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace)（ツール [linjector](https://github.com/erfur/linjector-rs)）

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **メモリダンプ - Fridump**

アプリがメモリ内に保存すべきでない機密情報（パスワードやニーモニックなど）を保持していないか確認する。

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
これによりメモリが ./dump フォルダにダンプされ、そこで次のようなコマンドで grep できます:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore内の機密データ**

AndroidではKeystoreが機密データを格納する最適な場所ですが、十分な権限があれば**アクセス可能**です。アプリケーションはここに**平文での機密データ**を保存する傾向があるため、pentestsはroot userとして確認するべきです。あるいはデバイスにphysical accessを持つ者がこのデータを盗む可能性があります。

アプリがkeystoreにデータを保存している場合でも、そのデータは暗号化されているべきです。

keystore内のデータにアクセスするには、このFridaスクリプトを使用できます: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

以下のFridaスクリプトを使用すると、Androidアプリが**特定の機密領域を保護するため**に実装している **bypass fingerprint authentication** を回避できる可能性があります：
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **バックグラウンド画像**

アプリをバックグラウンドに移動すると、Android はアプリの **snapshot of the application** を保存します。フォアグラウンドに復帰した際、アプリ本体より先にそのイメージを読み込むため、起動が速く見えます。

しかし、この **snapshot** に **機密情報** が含まれている場合、その snapshot にアクセスできる者が **その情報を盗む** 可能性があります（アクセスには root が必要である点に注意）。

スナップショットは通常以下に保存されます: **`/data/system_ce/0/snapshots`**

Android は、レイアウトパラメータに **FLAG_SECURE** を設定することで screenshot の取得を防ぐ手段を提供します。 このフラグを使用すると、ウィンドウの内容はセキュアとして扱われ、screenshots に表示されたり、非セキュアなディスプレイ上で表示されるのを防ぎます。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

このツールは、dynamic analysis 中に複数のツールを管理するのに役立ちます: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

開発者はしばしば activities、services、broadcast receivers のようなプロキシコンポーネントを作成し、これらの Intents を処理して `startActivity(...)` や `sendBroadcast(...)` のようなメソッドに渡しますが、これはリスクを伴います。

危険なのは、攻撃者がこれらの Intents を誤誘導して non-exported なアプリコンポーネントをトリガーしたり、機密性の高い content providers にアクセスしたりできる点です。顕著な例としては、`WebView` コンポーネントが URL を `Intent` オブジェクトに `Intent.parseUri(...)` を介して変換し、それを実行することで、悪意ある Intent injection を引き起こす可能性があります。

### Essential Takeaways

- **Intent Injection** は web の Open Redirect 問題に類似しています。
- エクスプロイトは `Intent` オブジェクトを extras として渡し、それをリダイレクトして安全でない操作を実行させることを含みます。
- 非エクスポートのコンポーネントや content providers を攻撃者に露出させる可能性があります。
- `WebView` の URL → `Intent` 変換は意図しない動作を促進することがあります。

### Android Client Side Injections and others

この種の脆弱性は Web で知っていることが多いでしょう。Android アプリケーションでは特に次の脆弱性に注意する必要があります:

- **SQL Injection:** 動的なクエリや Content-Providers を扱う場合は、parameterized queries を使用していることを確認してください。
- **JavaScript Injection (XSS):** すべての WebViews で JavaScript と Plugin のサポートが無効になっていることを確認してください（デフォルトでは無効）。 [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews はファイルシステムへのアクセスを無効にしておくべきです（デフォルトでは有効） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 多くの場合、Android アプリケーションがセッションを終了してもクッキーが取り消されなかったり、ディスクに保存されることがあります。
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** は使いやすい web-based frontend を使って行えます。dynamic analysis も実行できます（ただし環境の準備が必要です）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- **Capture HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP ツール**

http トラフィックがキャプチャされると、"**HTTP(S) Traffic**" ボタンでキャプチャされたトラフィックの簡易表示を、また "**Start HTTPTools**" の緑色のボタンでより見やすい表示を見ることができます。2つ目のオプションから、キャプチャしたリクエストを Burp や Owasp ZAP のような **proxies** に **send** することができます。\
その手順は、_power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

MobSF で dynamic analysis を終了したら、"**Start Web API Fuzzer**" を押して **fuzz http requests** を実行し、脆弱性を探すことができます。

> [!TIP]
> MobSF で dynamic analysis を実行した後、proxy 設定が誤って構成され、GUI から修正できない場合があります。proxy 設定は次のコマンドで修正できます:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

ツールは [**Inspeckage**](https://github.com/ac-pm/Inspeckage) から入手できます。\
このツールはいくつかの **Hooks** を利用して、dynamic analysis を行っている間に **what is happening in the application** を把握できるようにします。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

GUI で static analysis を行うのに**優れたツール**です。

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

このツールは、**security related Android application vulnerabilities** を、**source code** または **packaged APKs** のいずれかで検出するよう設計されています。さらに、検出された脆弱性（Exposed activities、intents、tapjacking...）の悪用のために、**"Proof-of-Concept" deployable APK** や **ADB commands** を作成することも可能です。Drozer と同様に、テストデバイスを root する必要はありません。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 参照しやすいようにすべての抽出されたファイルを表示します
- APKファイルを自動でJavaおよびSmali形式にデコンパイルします
- AndroidManifest.xmlを一般的な脆弱性や挙動について解析します
- 静的ソースコード解析を行い、一般的な脆弱性や挙動を検出します
- デバイス情報
- など
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER は Windows、MacOS X、Linux 上で使用できるコマンドラインアプリケーションで、_.apk_ ファイルを解析して脆弱性を検索します。APK を展開し、一連のルールを適用してこれらの脆弱性を検出します。

すべてのルールは `rules.json` ファイルに集約されており、各企業やテスターは必要に応じた独自のルールを作成して解析に利用できます。

最新のバイナリは [download page](https://superanalyzer.rocks/download.html) からダウンロードできます。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn は**crossplatform**なツールで、モバイルアプリケーションの[static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)を行う開発者、bugbounty hunters、ethical hackers を支援します。

コンセプトは、モバイルアプリケーションファイル（.apk または .ipa ファイル）を StaCoAn アプリにドラッグ＆ドロップすると、視覚的でポータブルなレポートを生成するというものです。設定やwordlistsを調整してカスタマイズされた体験を得ることができます。

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Frameworkは、Androidアプリケーションの潜在的なセキュリティ脆弱性をdevelopers or hackersが発見するのを支援する脆弱性解析システムです。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** は、Android アプリケーションによって開発された潜在的な悪意のある振る舞いを検出してユーザーに警告することを主目的としたツールです。

検出は、アプリケーションの Dalvik bytecode が **Smali** として表現されたものに対する **static analysis** を [`androguard`](https://github.com/androguard/androguard) ライブラリで行います。

このツールは、以下のような **common behavior of "bad" applications** を検出します: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. It is a tool that puts together commonly used mobile application reverse engineering and analysis tools, to assist in testing mobile applications against the OWASP mobile security threats. Its objective is to make this task easier and friendlier to mobile application developers and security professionals.

それは以下を行うことができます：

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Useful to detect malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Note that depending the service and configuration you use to obfuscate the code. Secrets may or may not ended obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

You can upload an obfuscated APK to their platform.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) It is a great list of resources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
