# Android aplikacije Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Osnove Android aplikacija

Toplo se preporučuje da počnete sa čitanjem ove stranice kako biste se upoznali sa **najvažnijim delovima vezanim za Android bezbednost i najopasnijim komponentama u Android aplikaciji**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Ovo je glavni alat koji vam je potreban da se povežete sa Android uređajem (emuliranim ili fizičkim).\
**ADB** omogućava upravljanje uređajima preko **USB** ili **mreže** sa računara. Ovaj alat omogućava **kopiranje** fajlova u oba smera, **instalaciju** i **deinstalaciju** aplikacija, **izvođenje** shell komandi, **pravljenje rezervnih kopija** podataka, **čitanje** logova, među ostalim funkcijama.

Pogledajte sledeću listu [**ADB Commands**](adb-commands.md) da naučite kako da koristite adb.

## Smali

Ponekad je korisno **izmeniti kod aplikacije** da bi se pristupilo **skrivenim informacijama** (možda dobro obfuskovanim lozinkama ili flagovima). U tom slučaju može biti korisno dekompajlirati apk, izmeniti kod i ponovo ga kompajlirati.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Ovo može biti veoma korisno kao **alternativa za nekoliko testova tokom dinamičke analize** koji će biti predstavljeni. Dakle, **uvek imajte ovu mogućnost na umu**.

## Ostali zanimljivi trikovi

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Preuzimanje APK-ova**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Izvlačenje APK-a sa uređaja:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Spojite sve splits i base apks pomoću [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Studije slučaja & Ranjivosti


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statička analiza

Prvo, za analizu APK-a treba da **pogledate Java kod** koristeći decompiler.\
Molimo, [**pročitajte ovde da biste pronašli informacije o različitim dostupnim decompilerima**](apk-decompilers.md).

### Potražite zanimljive informacije

Samo pregledom **strings** iz APK-a možete tražiti **lozinke**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API** keys, **encryption**, **bluetooth uuids**, **tokens** i sve što je interesantno... tražite čak i code execution **backdoors** ili authentication backdoors (hardcoded admin credentials u aplikaciji).

**Firebase**

Obratite posebnu pažnju na **Firebase URL-ove** i proverite da li je loše konfigurisan. [Više informacija o tome šta je Firebase i kako ga eksploatisati ovde.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Osnovno razumevanje aplikacije - Manifest.xml, strings.xml

Pregled aplikacionih fajlova _Manifest.xml_ i **_strings.xml_** može otkriti potencijalne sigurnosne ranjivosti. Ovi fajlovi se mogu pristupiti koristeći decompile ili preimenovanjem APK fajla u .zip i njegovim raspakivanjem.

**Ranjivosti** identifikovane iz **Manifest.xml** uključuju:

- **Debuggable Applications**: Aplikacije postavljene kao debuggable (`debuggable="true"`) u _Manifest.xml_ predstavljaju rizik jer omogućavaju konekcije koje mogu dovesti do eksploatacije. Za dalje razumevanje kako eksploatisati debuggable aplikacije, pogledajte tutorijal o pronalaženju i eksploataciji debuggable aplikacija na uređaju.
- **Backup Settings**: Atribut `android:allowBackup="false"` treba eksplicitno postaviti za aplikacije koje rade sa osetljivim informacijama kako bi se sprečilo neautorizovano pravljenje backup-a preko adb-a, naročito kada je usb debugging omogućен.
- **Network Security**: Custom network security konfiguracije (`android:networkSecurityConfig="@xml/network_security_config"`) u _res/xml/_ mogu specificirati detalje kao što su certificate pins i HTTP podešavanja. Primer je dozvoljavanje HTTP saobraćaja za specifične domene.
- **Exported Activities and Services**: Identifikacija exported activities i services u manifestu može ukazati na komponente koje bi mogle biti zloupotrebljene. Dalja analiza tokom dinamičkog testiranja može otkriti kako eksploatisati ove komponente.
- **Content Providers and FileProviders**: Izloženi content provider-i mogu dozvoliti neautorizovan pristup ili modifikaciju podataka. Konfiguracija FileProviders takođe zahteva pažljivo ispitivanje.
- **Broadcast Receivers and URL Schemes**: Ove komponente se mogu iskoristiti za eksploataciju, sa posebnom pažnjom na to kako su URL schemes obrađeni zbog mogućih input ranjivosti.
- **SDK Versions**: Atributi `minSdkVersion`, `targetSDKVersion`, i `maxSdkVersion` ukazuju na podržane Android verzije, naglašavajući važnost ne podržavanja zastarelih, ranjivih Android verzija iz bezbednosnih razloga.

Iz **strings.xml** fajla mogu se otkriti osetljive informacije kao što su API ključevi, custom schemas i druge beleške developera, što naglašava potrebu za pažljivim pregledom ovih resursa.

### Tapjacking

**Tapjacking** je napad gde se **zlonamerna** **aplikacija** pokreće i **pozicionira iznad žrtvine aplikacije**. Kada vizuelno zaseni žrtvinu aplikaciju, njen UI je dizajniran tako da prevari korisnika da interaguje sa njom, dok se ta interakcija prosleđuje žrtvinoj aplikaciji.\
U efektu, to **slepi korisnika da zna da zapravo izvodi akcije u žrtvinoj aplikaciji**.

Više informacija pronađite u:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity sa `launchMode` podešenim na `singleTask` bez definisanog `taskAffinity` je ranjiva na task Hijacking. To znači da se **maliciozna aplikacija** može instalirati i, ako se pokrene pre prave aplikacije, može **oteti task prave aplikacije** (tako da će korisnik interagovati sa **malicioznom aplikacijom misleći da koristi pravu**).

Više informacija u:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Nesigurno skladištenje podataka

**Internal Storage**

U Androidu, fajlovi **smešteni** u **internal** storage su dizajnirani da budu dostupni isključivo aplikaciji koja ih je **kreirala**. Ova mera sigurnosti se **sprovodi** od strane Android OS-a i obično je dovoljna za potrebe većine aplikacija. Međutim, developeri ponekad koriste režime poput `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` da bi **dozvolili** deljenje fajlova između različitih aplikacija. Ipak, ovi režimi **ne ograničavaju pristup** tim fajlovima od strane drugih aplikacija, uključujući potencijalno maliciozne.

1. **Static Analysis:**
- **Proverite** da li je upotreba `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` **pažljivo ispitana**. Ovi režimi **mogu potencijalno izložiti** fajlove neželjenom ili neautorizovanom pristupu.
2. **Dynamic Analysis:**
- **Verifikujte** permisije postavljene na fajlovima koje aplikacija kreira. Konkretno, **proverite** da li su neki fajlovi **postavljeni da budu čitljivi ili pisljivi svima**. Ovo može predstavljati značajan sigurnosni rizik, jer bi omogućilo **svakoj aplikaciji** instaliranoj na uređaju, bez obzira na poreklo ili nameru, da **čita ili menja** te fajlove.

**External Storage**

Kada je reč o fajlovima na **external storage**, kao što su SD kartice, treba preduzeti određene mere opreza:

1. **Pristupačnost**:
- Fajlovi na external storage su **globalno čitljivi i pisljivi**. To znači da bilo koja aplikacija ili korisnik može pristupiti tim fajlovima.
2. **Bezbednosne brige**:
- S obzirom na lakoću pristupa, ne preporučuje se čuvanje osetljivih informacija na external storage.
- External storage može biti uklonjen ili mu može pristupiti bilo koja aplikacija, što ga čini manje sigurnim.
3. **Rukovanje podacima sa external storage**:
- Uvek **vršite validaciju unosa** na podacima dohvaćenim sa external storage. To je ključno jer podaci dolaze iz nepouzdanog izvora.
- Ne preporučuje se čuvanje izvršnih fajlova ili class fajlova na external storage za dinamičko učitavanje.
- Ako aplikacija mora da učita izvršne fajlove sa external storage, osigurajte da su ti fajlovi **potpisani i kriptografski verifikovani** pre dinamičkog učitavanja. Ovaj korak je vitalan za očuvanje sigurnosnog integriteta aplikacije.

External storage može se **pristupiti** u `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Počevši od Android 4.4 (**API 17**), SD kartica ima strukturu direktorijuma koja **ograničava pristup iz aplikacije samo na direktorijum koji je specifičan za tu aplikaciju**. Ovo sprečava malicioznu aplikaciju da stekne read ili write pristup fajlovima druge aplikacije.

**Osetljivi podaci uskladišteni u čistom tekstu**

- **Shared preferences**: Android omogućava svakoj aplikaciji da lako sačuva xml fajlove u putanji `/data/data/<packagename>/shared_prefs/` i ponekad je moguće naći osetljive informacije u čistom tekstu u tom folderu.
- **Databases**: Android omogućava svakoj aplikaciji da lako sačuva sqlite baze u putanji `/data/data/<packagename>/databases/` i ponekad je moguće naći osetljive informacije u čistom tekstu u tom folderu.

### Broken TLS

**Accept All Certificates**

Iz nekog razloga, ponekad developeri prihvataju sve sertifikate čak i kada, na primer, hostname ne odgovara, sa linijama koda kao što su sledeće:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Neispravna kriptografija

**Loši procesi upravljanja ključevima**

Neki developeri čuvaju osetljive podatke u lokalnoj memoriji i kriptuju ih ključem hardkodiranim/predvidljivim u kodu. Ovo ne bi trebalo raditi jer bi reverzovanje moglo omogućiti napadačima da izvuku poverljive informacije.

**Korišćenje nesigurnih i/ili zastarelih algoritama**

Developeri ne bi trebalo da koriste **deprecated algorithms** za izvršavanje autorizacionih **checks**, **store** ili **send** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se koriste **hashes** za skladištenje lozinki na primer, treba koristiti hashove otporne na brute-force uz salt.

### Ostale provere

- Preporučuje se da **obfuscate the APK** kako bi se otežao posao reverse engineer-ima.
- Ako je aplikacija osetljiva (kao bank apps), treba da izvodi svoje provere da li je mobilni rooted i da postupi u skladu s tim.
- Ako je aplikacija osetljiva (kao bank apps), treba da proveri da li se koristi **emulator**.
- Ako je aplikacija osetljiva (kao bank apps), treba da **check it's own integrity before executing** kako bi proverila da li je modifikovana.
- Koristite [**APKiD**](https://github.com/rednaga/APKiD) da proverite koji compiler/packer/obfuscator je korišćen za izgradnju APK-a

### React Native aplikacija

Pročitajte sledeću stranu da naučite kako lako pristupiti javascript kodu React aplikacija:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin aplikacije

Pročitajte sledeću stranu da naučite kako lako pristupiti C# kodu xamarin aplikacija:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked aplikacije

Prema ovom [**blog postu**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked je Meta algoritam koji kompresuje sadržaj aplikacije u jednu datoteku. Blog govori o mogućnosti kreiranja aplikacije koja dekompresuje ovakve aplikacije... i bržem načinu koji podrazumeva **pokretanje aplikacije i prikupljanje dekompresovanih fajlova iz fajl sistema.**

### Automatizovana statička analiza koda

Alat [**mariana-trench**](https://github.com/facebook/mariana-trench) je sposoban da pronađe **vulnerabilities** skeniranjem **code** aplikacije. Ovaj alat sadrži niz **known sources** (koji ukazuju alatu **places** gde je **input** **controlled by the user**), **sinks** (koji ukazuju alatu na **dangerous** **places** gde maliciozan korisnički unos može prouzrokovati štetu) i **rules**. Ove rules ukazuju na **combination** of **sources-sinks** koja označava ranjivost.

Sa ovim znanjem, **mariana-trench će pregledati kod i pronaći moguće ranjivosti u njemu**.

### Secrets leaked

Aplikacija može sadržati secrets (API keys, passwords, hidden urls, subdomains...) unutar nje koje možete otkriti. Možete koristiti alat kao što je [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Druge interesantne funkcije

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamička analiza

> Pre svega, potrebno je okruženje gde možete instalirati aplikaciju i sve komponente okruženja (Burp CA cert, Drozer i Frida pre svega). Stoga se toplo preporučuje rooted uređaj (emuliran ili ne).

### Online dinamička analiza

Možete napraviti **free account** na: [https://appetize.io/](https://appetize.io). Ova platforma omogućava da **upload** i **execute** APK-e, pa je korisna da vidite kako se apk ponaša.

Možete čak **videti logove vaše aplikacije** na webu i povezati se preko **adb**.

![](<../../images/image (831).png>)

Zahvaljujući ADB konekciji možete koristiti **Drozer** i **Frida** unutar emulatora.

### Lokalna dinamička analiza

#### Korišćenje emulatora

- [**Android Studio**](https://developer.android.com/studio) (Možete kreirati **x86** i **arm** uređaje, i prema [**ovome**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) **novije x86** verzije **podržavaju ARM biblioteke** bez potrebe za sporim ARM emulatorom).
- Naučite kako da ga podesite na ovoj strani:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, potrebno je napraviti nalog. _Preporučeno je da **download** verziju **WITH** _**VirtualBox** da bi se izbegle potencijalne greške._)
- [**Nox**](https://es.bignox.com) (Free, ali ne podržava Frida ili Drozer).

> [!TIP]
> Kada kreirate novi emulator na bilo kojoj platformi zapamtite da veći ekran usporava emulatore. Zato izaberite male ekrane ako je moguće.

Da biste **install google services** (kao AppStore) u Genymotion, potrebno je da kliknete na crveno označeno dugme na sledećoj slici:

![](<../../images/image (277).png>)

Takođe, obratite pažnju da u **konfiguraciji Android VM-a u Genymotion-u** možete izabrati **Bridge Network mode** (ovo će biti korisno ako ćete se povezivati na Android VM sa drugog VM-a sa alatima).

#### Korišćenje fizičkog uređaja

Potrebno je aktivirati **debugging** opcije i poželjno je da možete **root** uređaj:

1. **Settings**.
2. (FromAndroid 8.0) Izaberite **System**.
3. Izaberite **About phone**.
4. Pritisnite **Build number** 7 puta.
5. Vratite se i naći ćete **Developer options**.

> Kada instalirate aplikaciju, prvo što treba da uradite je da je probate, istražite šta radi, kako funkcioniše i da se naviknete na nju.\
> Predlažem da **obavite ovu početnu dinamičku analizu koristeći MobSF dynamic analysis + pidcat**, tako ćemo moći da **naučimo kako aplikacija radi** dok MobSF **hvata** mnogo **interesantnih** **podataka** koje možete kasnije pregledati.

Magisk/Zygisk kratke beleške (preporučeno na Pixel uređajima)
- Patch-ujte boot.img pomoću Magisk aplikacije i flash-ujte preko fastboot-a da dobijete systemless root
- Omogućite Zygisk + DenyList za skrivanje root-a; razmotrite LSPosed/Shamiko kada je potrebno jače skrivanje
- Sačuvajte originalni boot.img za oporavak posle OTA update-a; ponovo patch-ujte posle svakog OTA
- Za screen mirroring koristite scrcpy na hostu

### Neplanirano curenje podataka

**Logovanje**

Developeri treba da budu oprezni u izlaganju **debugging information** javno, jer to može dovesti do curenja osetljivih podataka. Preporučeni alati za praćenje logova aplikacije radi identifikacije i zaštite osetljivih informacija su [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat`. **Pidcat** se preferira zbog jednostavnosti upotrebe i preglednosti.

> [!WARNING]
> Imajte na umu da od **novijih verzija Android-a nakon 4.0**, **applications mogu pristupiti samo svojim logovima**. Dakle, aplikacije ne mogu pristupiti logovima drugih aplikacija.\
> U svakom slučaju, i dalje se preporučuje da **ne logujete osetljive informacije**.

**Copy/Paste Buffer Caching**

Android-ov **clipboard-based** framework omogućava funkcionalnost copy-paste u aplikacijama, ali predstavlja rizik jer **other applications** mogu **access** clipboard i time potencijalno otkriti osetljive podatke. Važno je **onemogućiti copy/paste** funkcije za osetljive delove aplikacije, poput podataka o platnim karticama, kako bi se sprečilo curenje podataka.

**Crash Logs**

Ako aplikacija **crashes** i **saves logs**, ti logovi mogu pomoći napadačima, posebno kada aplikacija ne može da se reverzuje. Da biste smanjili ovaj rizik, izbegavajte logovanje prilikom crash-a, a ako logovi moraju biti poslati preko mreže, obezbedite da se šalju preko SSL kanala.

Kao pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Aplikacije često integrišu servise kao što je Google Adsense, što može slučajno dovesti do **leak** osetljivih podataka zbog nepravilne implementacije od strane developera. Da biste identifikovali potencijalna curenja podataka, preporučuje se da **intercept** saobraćaj aplikacije i proverite da li se osetljivi podaci šalju trećim stranama.

### SQLite DBs

Većina aplikacija koristi **internal SQLite databases** za čuvanje informacija. Tokom pentesta pregledajte **databases** koje su kreirane, imena **tables** i **columns** i sve **data** u njima jer možete pronaći **sensitive information** (što bi predstavljalo ranjivost).\
Baze bi trebalo da se nalaze u `/data/data/the.package.name/databases` kao npr. `/data/data/com.mwr.example.sieve/databases`

Ako baza čuva poverljive informacije i **encrypted** je, ali možete **find** **password** unutar aplikacije, i dalje je to **vulnerability**.

Enumerišite tabele koristeći `.tables` i enumerišite kolone tabela koristeći `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Prema [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** vam omogućava da **assume the role of an Android app** i komunicirate sa drugim aplikacijama. Može uraditi **anything that an installed application can do**, kao što je korišćenje Android-ovog Inter-Process Communication (IPC) mehanizma i interakcija sa osnovnim operativnim sistemom.\
Drozer je koristan alat za **exploit exported activities, exported services and Content Providers** kao što ćete naučiti u narednim sekcijama.

### Eksploatacija exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Takođe zapamtite da kod jedne activity počinje u **`onCreate`** metodi.

**Authorisation bypass**

Kada je Activity exported, možete pozvati njegov ekran iz eksternе aplikacije. Dakle, ako je activity sa **sensitive information** exported, možete **bypass** **authentication** mehanizme da biste mu pristupili.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Takođe možete startovati exported activity preko adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Imajte na umu da authorisation bypass nije uvek ranjivost; zavisi od toga kako bypass funkcioniše i koje informacije su izložene.

**Sensitive information leakage**

Activities mogu takođe da vraćaju rezultate. Ako uspete da pronađete exported i unprotected activity koja poziva metod **`setResult`** i **returning sensitive information**, postoji sensitive information leakage.

#### Tapjacking

Ako Tapjacking nije sprečen, možete zloupotrebiti exported activity da naterate korisnika da izvrši **neočekivane akcije**. Za više informacija o [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers se uglavnom koriste za **deljenje podataka**. Ako aplikacija ima dostupne Content providers, možda ćete moći da **extract sensitive** podatke iz njih. Takođe je korisno testirati moguće **SQL injections** i **Path Traversals**, jer oni mogu biti ranjivi.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Zapamtite da radnje Service-a počinju u metodu `onStartCommand`.

Service je u osnovi nešto što može da primi podatke, obradi ih i vrati (ili ne) odgovor. Dakle, ako aplikacija export-uje neke servise, trebalo bi da pregledate kod da biste razumeli šta radi i da ga testirate dinamički kako biste izvukli poverljive informacije, zaobišli mere autentifikacije...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Zapamtite da radnje Broadcast Receiver-a počinju u metodu `onReceive`.

Broadcast receiver će čekati određenu vrstu poruke. U zavisnosti od toga kako receiver rukuje porukom, može biti ranjiv.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Možete potražiti deep links ručno, koristeći alate kao MobSF ili skripte kao [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Možete otvoriti deklarisani scheme koristeći **adb** ili **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Imajte na umu da možete **izostaviti naziv paketa** i mobilni će automatski pozvati aplikaciju koja treba da otvori taj link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod koji će biti izvršen**

Da biste pronašli **kod koji će biti izvršen u App**, idite na aktivnost koju poziva deeplink i potražite funkciju **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Osetljive informacije**

Svaki put kada pronađete deep link, proverite da li **ne prima osetljive podatke (poput lozinki) putem URL parametara**, jer bilo koja druga aplikacija može **lažno da se predstavi kao taj deep link i ukrade te podatke!**

**Parametri u putanji**

Obavezno proverite i da li neki deep link koristi parametar unutar putanje URL-a, npr.: `https://api.example.com/v1/users/{username}` , u tom slučaju možete forsirati path traversal pristupom nečemu poput: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Obratite pažnju da, ako pronađete odgovarajuće endpoint-e unutar aplikacije, možete izazvati **Open Redirect** (ako se deo putanje koristi kao naziv domena), **account takeover** (ako možete izmeniti detalje korisnika bez CSRF tokena i ranjivi endpoint koristi odgovarajuću metodu) i druge vrste vuln-ova. Više [info about this here](http://dphoeniixx.com/2020/12/13-2/).

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspekcija transportnog sloja i propusti u verifikaciji

- **Certificates are not always inspected properly** by Android applications. It's common for these applications to overlook warnings and accept self-signed certificates or, in some instances, revert to using HTTP connections.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, employing insecure cipher suites. This vulnerability makes the connection susceptible to man-in-the-middle (MITM) attacks, allowing attackers to decrypt the data.
- Otkrivanje privatnih informacija predstavlja rizik kada aplikacije autentifikuju koristeći secure channels ali zatim komuniciraju preko non-secure kanala za druge transakcije. Ovakav pristup ne uspeva da zaštiti osetljive podatke, kao što su session cookies ili detalji korisnika, od presretanja od strane zlonamernih entiteta.

#### Provera sertifikata

Usredsredićemo se na **proveru sertifikata**. Integritet serverovog sertifikata mora biti verifikovan kako bi se poboljšala bezbednost. Ovo je ključno jer nesigurne TLS konfiguracije i prenos osetljivih podataka preko neenkriptovanih kanala mogu predstavljati značajne rizike. Za detaljne korake o verifikaciji server sertifikata i rešavanju ranjivosti, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) pruža sveobuhvatne smernice.

#### SSL Pinning

SSL Pinning je bezbednosna mera u kojoj aplikacija verifikuje serverov sertifikat naspram poznate kopije uskladištene u samoj aplikaciji. Ova metoda je ključna za sprečavanje MITM napada. Preporučuje se implementacija SSL Pinning-a za aplikacije koje obrađuju osetljive informacije.

#### Inspekcija saobraćaja

Za inspekciju HTTP saobraćaja, neophodno je **instalirati sertifikat proxy alata** (npr. Burp). Bez instaliranja tog sertifikata, enkriptovani saobraćaj možda neće biti vidljiv kroz proxy. Za vodič o instaliranju custom CA sertifikata, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacije koje targetiraju **API Level 24 and above** zahtevaju izmene u Network Security Config da bi prihvatile CA sertifikat proxy-ja. Ovaj korak je kritičan za inspekciju enkriptovanog saobraćaja. Za instrukcije o izmeni Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Ako se koristi **Flutter**, potrebno je pratiti instrukcije na [**this page**](flutter.md). Ovo je zato što samo dodavanje sertifikata u store neće raditi, jer Flutter ima sopstvenu listu važećih CA.

#### Statička detekcija SSL/TLS pinning

Pre nego što pokušate runtime bypass-ove, brzo mapirajte gde se pinning primenjuje u APK-u. Statičko otkrivanje pomaže da isplanirate hooks/patches i da se fokusirate na prave putanje koda.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Zahtevi: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Korišćenje
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Primer pravila obrazaca (JSON)
Koristite ili proširite signatures da otkrijete proprietary/custom pinning styles. Možete učitati sopstveni JSON i scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Napomene i saveti
- Brzo skeniranje velikih aplikacija putem multi-threading i memory-mapped I/O; pre-compiled regex smanjuje overhead/false positives.
- Kolekcija patterna: https://github.com/aancw/smali-sslpin-patterns
- Tipični ciljevi detekcije za dalju trijažu:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Koristite pronađene lokacije za planiranje Frida hooks, static patches, ili pregleda konfiguracija pre dynamic testing.



#### Bypassing SSL Pinning

When SSL Pinning is implemented, bypassing it becomes necessary to inspect HTTPS traffic. Various methods are available for this purpose:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Traženje uobičajenih web ranjivosti

Važno je takođe pretražiti aplikaciju za uobičajene web ranjivosti. Detaljna objašnjenja kako ih identifikovati i ublažiti su van opsega ovog rezimea, ali su detaljno obrađena drugde.

### Frida

[Frida](https://www.frida.re) is a dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.\
**Možete pristupiti pokrenutoj aplikaciji i hook-ovati metode u runtime-u da biste promenili ponašanje, promenili vrednosti, ekstrahovali vrednosti, izvršili drugačiji kod...**\
Ako želite pentest Android applications morate znati kako koristiti Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump memorije - Fridump**

Proverite da li aplikacija čuva osetljive informacije u memoriji koje ne bi trebalo da čuva, kao što su lozinke ili mnemonici.

Koristeći [**Fridump3**](https://github.com/rootbsd/fridump3) možete dump-ovati memoriju aplikacije pomoću:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Ovo će napraviti dump memorije u ./dump folderu, i tamo možete koristiti grep sa nečim poput:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Osetljivi podaci u Keystore**

U Androidu je Keystore najbolje mesto za čuvanje osetljivih podataka, međutim, uz dovoljne privilegije i dalje je **moguće pristupiti njemu**. Pošto aplikacije imaju tendenciju da ovde čuvaju **osetljive podatke u čistom tekstu**, pentests bi trebalo da to provere, jer root korisnik ili neko sa fizičkim pristupom uređaju može ukrasti te podatke.

Čak i ako aplikacija skladišti podatke u Keystore-u, ti podaci treba da budu šifrovani.

Da biste pristupili podacima unutar Keystore-a, možete koristiti ovaj Frida skript: https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Korišćenjem sledećeg Frida skripta može biti moguće **bypass fingerprint authentication** koje Android aplikacije mogu primenjivati kako bi **zaštitile određene osetljive oblasti:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Pozadinske slike**

Kada aplikaciju stavite u pozadinu, Android čuva **snimak aplikacije** tako da kada se vrati u prvi plan počne da učitava sliku pre same aplikacije, kako bi izgledalo da se aplikacija brže učitala.

Međutim, ako ovaj snimak sadrži **osetljive informacije**, neko ko ima pristup snimku može **ukrasti te informacije** (napomena: za pristup je potreban root).

Snimci se obično nalaze na: **`/data/system_ce/0/snapshots`**

Android pruža način da se **spreči pravljenje screenshot-a postavljanjem FLAG_SECURE** layout parametra. Korišćenjem ove zastavice, sadržaj prozora se tretira kao bezbedan, što sprečava njegovo pojavljivanje na screenshot-ovima ili prikazivanje na nebezbednim ekranima.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Ovaj alat vam može pomoći da upravljate različitim alatima tokom dinamičke analize: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Programeri često kreiraju proxy komponente kao što su activities, services i broadcast receivers koje obrađuju ove Intents i prosleđuju ih metodama kao što su `startActivity(...)` ili `sendBroadcast(...)`, što može biti rizično.

Opasnost leži u dopuštanju napadačima da pokrenu neeksportovane komponente aplikacije ili pristupe osetljivim content providers tako što će pogrešno usmeriti ove Intents. Značajan primer je `WebView` komponenta koja konvertuje URL-ove u `Intent` objekte preko `Intent.parseUri(...)` i zatim ih izvršava, što potencijalno može dovesti do malicioznih Intent injekcija.

### Suštinske napomene

- **Intent Injection** je sličan web Open Redirect problemu.
- Eksploati uključuju prosleđivanje `Intent` objekata kao extras, koji mogu biti preusmereni da izvrše nesigurne operacije.
- Može izložiti neeksportovane komponente i content providers napadačima.
- `WebView`-ova konverzija URL-a u `Intent` može omogućiti neželjene akcije.

### Android Client Side Injections and others

Verovatno poznajete ovu vrstu ranjivosti sa weba. Morate biti posebno oprezni sa ovim ranjivostima u Android aplikaciji:

- **SQL Injection:** Kada radite sa dinamičkim upitima ili Content-Providers, osigurajte da koristite parametrizovane upite.
- **JavaScript Injection (XSS):** Proverite da li je podrška za JavaScript i Plugin onemogućena za bilo koje WebViews (onemogućeno po podrazumevanoj vrednosti). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews treba da imaju onemogućen pristup fajl sistemu (omogućen podrazumevano) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: U nekoliko slučajeva, kada Android aplikacija završi sesiju, cookie nije opozvan ili čak može biti sačuvan na disku
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatska analiza

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statička analiza**

![](<../../images/image (866).png>)

**Procena ranjivosti aplikacije** putem lepog web grafičkog interfejsa. Takođe možete izvršiti dinamičku analizu (ali morate pripremiti okruženje).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Pomoćna dinamička analiza sa MobSF

**MobSF** može biti veoma koristan i za **dynamic analysis** na **Android**, ali u tom slučaju morate instalirati MobSF i **genymotion** na vaš host (VM ili Docker neće raditi). _Napomena: Potrebno je prvo **start a VM in genymotion** i **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Sve ovo se radi automatski osim za screenshots — za njih morate pritisnuti kada želite screenshot ili pritisnuti "**Exported Activity Tester**" da biste dobili screenshots svih exported activities.
- Presretanje **HTTPS** saobraćaja
- Koristi **Frida** za dobijanje **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Frida scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Pored toga, imate neke pomoćne Frida funkcionalnosti:

- **Enumerate Loaded Classes**: Ispisuje sve učitane klase
- **Capture Strings**: Ispisuje sve uhvaćene stringove dok koristite aplikaciju (veoma bučno)
- **Capture String Comparisons**: Može biti veoma korisno. Pokazaće **the 2 strings being compared** i da li je rezultat True ili False.
- **Enumerate Class Methods**: Unesite ime klase (npr. "java.io.File") i ispisaće sve metode te klase.
- **Search Class Pattern**: Pretražuje klase po obrascu
- **Trace Class Methods**: **Trace** a **whole class** (videti ulaze i izlaze svih metoda klase). Zapamtite da po defaultu MobSF prati nekoliko interesantnih Android Api metoda.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

MobSF takođe donosi shell sa nekim **adb** komandama, **MobSF commands**, i uobičajenim **shell** **commands** na dnu stranice dinamičke analize. Neke interesantne komande:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP alati**

Kada se HTTP saobraćaj uhvati, možete videti ružan prikaz uhvaćenog saobraćaja na dnu "**HTTP(S) Traffic**" ili lepši prikaz na zelenom dugmetu "**Start HTTPTools**". Iz druge opcije možete **send** **captured requests** na **proxies** kao što su Burp ili Owasp ZAP.\
Da to uradite, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> pritisnite "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Kada završite dinamičku analizu sa MobSF možete pritisnuti "**Start Web API Fuzzer**" da **fuzz http requests** i tražite ranjivosti.

> [!TIP]
> Nakon izvršene dinamičke analize sa MobSF proxy podešavanja mogu biti pogrešno konfigurisana i nećete moći da ih popravite iz GUI-ja. Možete popraviti proxy podešavanja tako što ćete uraditi:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Možete preuzeti alat sa [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Ovaj alat koristi neke **Hooks** da vam pokaže **šta se dešava u aplikaciji** dok izvodite **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Ovo je **odličan alat za izvođenje static analysis sa GUI-jem**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Ovaj alat je dizajniran da traži nekoliko **security related Android application vulnerabilities**, bilo u **source code** ili **packaged APKs**. Alat je takođe sposoban da kreira **"Proof-of-Concept" deployable APK** i **ADB commands**, kako bi iskoristio neke od pronađenih ranjivosti (Exposed activities, intents, tapjacking...). Kao i sa Drozer, nema potrebe za root-ovanjem test uređaja.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Prikazuje sve ekstrahovane fajlove radi lakšeg pregleda
- Automatski dekompajlira APK fajlove u Java i Smali format
- Analizira AndroidManifest.xml za uobičajene ranjivosti i ponašanja
- Statička analiza izvornog koda za uobičajene ranjivosti i ponašanja
- Informacije o uređaju
- i još više
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER je aplikacija komandne linije koja se može koristiti na Windows, MacOS X i Linux, koja analizira _.apk_ fajlove u potrazi za ranjivostima. To radi dekompresovanjem APK-ova i primenom niza pravila za otkrivanje tih ranjivosti.

Sva pravila su u fajlu `rules.json`, i svaka kompanija ili tester može kreirati sopstvena pravila za analizu po potrebi.

Preuzmite najnovije binarije sa [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn je **crossplatform** alat koji pomaže programerima, bugbounty hunterima i ethical hackerima pri izvođenju [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) na mobilnim aplikacijama.

Koncept je da prevučete i ispustite fajl vaše mobilne aplikacije (an .apk or .ipa file) na StaCoAn aplikaciju i on će generisati vizuelni i prenosivi izveštaj za vas. Možete prilagoditi podešavanja i wordlists da biste dobili personalizovano iskustvo.

Preuzmite[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework je sistem za analizu ranjivosti Android aplikacija koji pomaže programerima i hakerima da otkriju potencijalne bezbednosne propuste.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** je alat čiji je glavni cilj da otkrije i upozori korisnika na potencijalno maliciozno ponašanje koje može razviti Android aplikacija.

Detekcija se vrši pomoću **static analysis** Dalvik bytecode-a aplikacije, predstavljenog kao **Smali**, koristeći biblioteku [`androguard`](https://github.com/androguard/androguard).

Ovaj alat traži **common behavior of "bad" applications** kao što su: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** je **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. To je alat koji okuplja često korišćene mobile application reverse engineering i analysis alate, kako bi pomogao pri testiranju mobilnih aplikacija protiv OWASP mobile security threats. Njegov cilj je da ovaj zadatak učini jednostavnijim i pristupačnijim za mobile application developers i security professionals.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Ekstrahuje privatne informacije iz APK-a koristeći regexps.
- Analizira Manifest.
- Analizira pronađene domene koristeći: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Koristan za detekciju malware-a: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Imajte na umu da, u zavisnosti od servisa i konfiguracije koje koristite za obfuscate koda, secrets mogu ili ne moraju ostati obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** je open source command-line alat koji smanjuje, optimizes i obfuscates Java kod. Sposoban je da optimizuje bytecode kao i da detektuje i ukloni neiskorišćene instrukcije. ProGuard je free software i distribuira se pod GNU General Public License, verzija 2.

ProGuard se distribuira kao deo Android SDK-a i pokreće se prilikom build-a aplikacije u release modu.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Poslednji put kad smo proveravali, način rada Dexguard-a je bio:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Možete upload-ovati obfuskovani APK na njihovu platformu.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Ovo je LLM alat za pronalaženje potencijalnih security ranjivosti u android apps i deobfuscate android app code. Koristi Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

To je **generic android deobfuscator.** Simplify **virtually executes an app** da razume njegovo ponašanje i zatim **tries to optimize the code** tako da se ponaša identično, ali je lakše za čoveka da razume. Svaki tip optimizacije je prost i generic, tako da nije važno koji konkretan tip obfuscation je korišćen.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD vam daje informacije o **how an APK was made**. Identifikuje mnoge **compilers**, **packers**, **obfuscators**, i druge čudne stvari. To je [_PEiD_](https://www.aldeid.com/wiki/PEiD) za Android.

### Manual

[Pročitajte ovaj tutorijal da naučite neke trikove o **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b je Android security virtual machine zasnovana na ubuntu-mate koja uključuje kolekciju najnovijih framework-ova, tutorijala i labova od različitih security geeka i istraživača za reverse engineering i malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To je sjajna lista resursa
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
