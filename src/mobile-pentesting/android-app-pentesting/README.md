# Pentesting Android додатків

{{#include ../../banners/hacktricks-training.md}}

## Основи Android додатків

Рекомендується почати з цієї сторінки, щоб ознайомитися з **найважливішими частинами, пов'язаними з безпекою Android, та найбільш небезпечними компонентами в Android-додатку**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Це основний інструмент, який потрібен для підключення до Android-пристрою (емульованого або фізичного).\
**ADB** дозволяє контролювати пристрої через **USB** або **Network** з комп'ютера. Ця утиліта дає змогу **копіювати** файли в обох напрямках, **встановлювати** та **видаляти** apps, **виконувати** shell-команди, **робити резервні копії** даних, **читати** логи та виконувати інші функції.

Погляньте на наступний список [**ADB Commands**](adb-commands.md), щоб дізнатися, як користуватися adb.

## Smali

Іноді цікаво **змінити код додатку**, щоб отримати доступ до **прихованої інформації** (наприклад добре обфускованих паролів або flags). У такому випадку корисно декомпілювати apk, змінити код і повторно скомпілювати його.\
[**У цьому уроці** ви можете **навчитися декомпілювати APK, змінювати Smali code та повторно компілювати APK** з новою функціональністю](smali-changes.md). Це може бути дуже корисним як **альтернатива для кількох тестів під час динамічного аналізу**, які будуть представлені. Тому **завжди майте на увазі цю можливість**.

## Інші цікаві трюки

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Play Integrity attestation spoofing (SafetyNet replacement)](play-integrity-attestation-bypass.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Витягнути APK з пристрою:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Об'єднайте всі splits і base apks за допомогою [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Static Analysis

По-перше, для аналізу APK слід **переглянути Java код** за допомогою де-компілятора.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Looking for interesting Info

Просто переглянувши **strings** APK, можна шукати **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** та будь-що цікаве... перевіряйте навіть наявність code execution **backdoors** або authentication backdoors (hardcoded admin credentials до додатку).

**Firebase**

Зверніть особливу увагу на **firebase URLs** та перевірте, чи немає неправильних налаштувань. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

**Огляд файлів _Manifest.xml_ та **_strings.xml_** додатку може виявити потенційні вразливості безпеки**. До цих файлів можна отримати доступ за допомогою де-компіляторів або перейменувавши розширення APK на .zip та розпакувавши його.

**Уразливості**, які можна знайти в **Manifest.xml**, включають:

- **Debuggable Applications**: Додатки, позначені як debuggable (`debuggable="true"`) в _Manifest.xml_, становлять ризик, оскільки дозволяють підключення, що може призвести до експлуатації. Для детального розуміння того, як експлуатувати debuggable додатки, ознайомтеся з підручником з пошуку та експлуатації таких додатків на пристрої.
- **Backup Settings**: Атрибут `android:allowBackup="false"` слід явно вказувати для додатків, що працюють з чутливою інформацією, щоб запобігти несанкціонованому резервному копіюванню через adb, особливо коли usb debugging увімкнено.
- **Network Security**: Користувацькі конфігурації безпеки мережі (`android:networkSecurityConfig="@xml/network_security_config"`) в _res/xml/_ можуть визначати такі деталі безпеки, як certificate pins та налаштування HTTP traffic. Наприклад, можна дозволяти HTTP трафік для конкретних доменів.
- **Exported Activities and Services**: Ідентифікація exported activities та services у манифесті може підказати компоненти, які можуть бути зловживані. Подальший аналіз під час dynamic testing може виявити способи їх експлуатації.
- **Content Providers and FileProviders**: Відкриті content providers можуть дозволити несанкціонований доступ або зміну даних. Конфігурацію FileProviders також слід ретельно перевіряти.
- **Broadcast Receivers and URL Schemes**: Ці компоненти можуть бути використані для експлуатації, особливо зверніть увагу на те, як керуються URL schemes щодо вразливостей вводу.
- **SDK Versions**: Атрибути `minSdkVersion`, `targetSDKVersion` та `maxSdkVersion` вказують підтримувані версії Android, підкреслюючи важливість невикористання застарілих, вразливих версій Android з міркувань безпеки.

Зі файлу **strings.xml** можна виявити чутливу інформацію, таку як API keys, custom schemas та інші нотатки розробника, що підкреслює необхідність ретельного перегляду цих ресурсів.

### Tapjacking

**Tapjacking** — це атака, коли **malicious** **application** запускається і **позиціонується поверх victim application**. Коли воно візуально приховує victim app, його інтерфейс розроблений так, щоб обдурити користувача взаємодіяти з ним, водночас передаючи ці взаємодії до victim app.\
Фактично, це **осліплює користувача, не дозволяючи йому знати, що він насправді виконує дії в victim app**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity з `launchMode`, встановленим як `singleTask` без визначеного `taskAffinity`, вразлива до Task Hijacking. Це означає, що **додаток** може бути встановлений і, якщо його запустити раніше за справжній додаток, він може **hijack the task of the real application** (тому користувач буде взаємодіяти з **malicious application**, думаючи, що використовує справжній).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

В Android файли, що **зберігаються** у **internal** storage, **призначені** бути доступними виключно тим **додатком**, який їх **створив**. Цей механізм безпеки **забезпечується** операційною системою Android і, як правило, є достатнім для потреб більшості додатків. Однак розробники іноді використовують режими на кшталт `MODE_WORLD_READABLE` та `MODE_WORLD_WRITABLE`, щоб **дозволити** файлам **ділитися** між різними додатками. Проте ці режими **не обмежують доступ** до файлів з боку інших додатків, включно з потенційно шкідливими.

1. **Static Analysis:**
- **Ensure** що використання `MODE_WORLD_READABLE` та `MODE_WORLD_WRITABLE` **ретельно перевіряється**. Ці режими **можуть потенційно зробити** файли доступними для **непередбаченого або несанкціонованого доступу**.
2. **Dynamic Analysis:**
- **Verify** permissions, встановлені на файлах, створених додатком. Зокрема, **перевірте**, чи якісь файли **встановлені як readable або writable worldwide**. Це може становити серйозний ризик безпеки, оскільки дозволить **будь-якому додатку**, встановленому на пристрої, незалежно від походження чи намірів, **читати або змінювати** ці файли.

**External Storage**

Працюючи з файлами на **external storage**, такими як SD Cards, слід вживати такі запобіжні заходи:

1. **Accessibility**:
- Файли на external storage є **глобально читаємими та записуваними**. Це означає, що будь-який додаток або користувач може отримати до них доступ.
2. **Security Concerns**:
- Через простоту доступу не рекомендується **зберігати чутливу інформацію** на external storage.
- External storage може бути видалено або до нього може отримати доступ будь-який додаток, що робить його менш безпечним.
3. **Handling Data from External Storage**:
- Завжди **виконуйте валідацію вводу** на даних, отриманих з external storage. Це критично, бо дані надходять з ненадійного джерела.
- Не рекомендується зберігати виконувані файли або class файли на external storage для динамічного завантаження.
- Якщо ваш додаток має отримувати виконувані файли з external storage, переконайтеся, що ці файли **підписані та криптографічно перевірені** перед їх динамічним завантаженням. Це важливий крок для збереження цілісності безпеки вашого додатку.

External storage можна **доступитись** за шляхами /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Починаючи з Android 4.4 (**API 17**), SD card має структуру директорій, яка **обмежує доступ додатка до директорії, що конкретно відведена для цього додатка**. Це запобігає тому, щоб malicious application отримав доступ на читання або запис до файлів іншого додатка.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android дозволяє кожному додатку легко зберігати xml файли у шляху `/data/data/<packagename>/shared_prefs/` і іноді в цій папці можна знайти чутливу інформацію у clear-text.
- **Databases**: Android дозволяє кожному додатку легко зберігати sqlite databases у шляху `/data/data/<packagename>/databases/` і іноді в цій папці можна знайти чутливу інформацію у clear-text.

### Broken TLS

**Accept All Certificates**

Іноді розробники з якоїсь причини приймають всі certificates навіть якщо, наприклад, hostname не відповідає, використовуючи рядки коду на кшталт наступного:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

Деякі розробники зберігають чутливі дані в локальному сховищі й шифрують їх за допомогою ключа, вбудованого/передбачуваного у коді. Так робити не варто, оскільки реверсінг може дозволити ата-керам витягти конфіденційну інформацію.

**Use of Insecure and/or Deprecated Algorithms**

Розробники не повинні використовувати **deprecated algorithms** для виконання авторизаційних **checks**, **store** або **send** даних. Деякі з цих алгоритмів: RC4, MD4, MD5, SHA1... Якщо для збереження паролів, наприклад, використовуються **hashes**, слід застосовувати хеші, стійкі до brute-force, з солью.

### Other checks

- Рекомендується **обфускувати APK**, щоб ускладнити роботу реверс-інженерів.
- Якщо додаток є чутливим (наприклад, bank apps), він повинен виконувати власні **перевірки, чи пристрій рутований**, і діяти відповідно.
- Якщо додаток є чутливим (наприклад, bank apps), він повинен перевіряти, чи використовується **emulator**.
- Якщо додаток є чутливим (наприклад, bank apps), він повинен **перевіряти власну цілісність перед виконанням**, щоб упевнитися, що його не модифіковано.
- Використовуйте [**APKiD**](https://github.com/rednaga/APKiD) для перевірки, який compiler/packer/obfuscator було використано для збірки APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Інструмент [**mariana-trench**](https://github.com/facebook/mariana-trench) здатний знаходити **vulnerabilities**, скануючи **code** додатку. Цей інструмент містить набір **known sources** (що вказують інструменту **місця**, де **input** контролюється користувачем), **sinks** (що вказують інструменту **небезпечні** **місця**, де шкідливий ввід користувача може завдати шкоди) і **rules**. Ці правила вказують **комбінації** **sources-sinks**, які сигналізують про вразливість.

Завдяки цьому **mariana-trench перегляне код і знайде можливі vulnerabilities у ньому**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Розробникам слід бути обережними з тим, щоб не робити **debugging information** публічно доступною, адже це може спричинити витік чутливої інформації. Інструменти [**pidcat**](https://github.com/JakeWharton/pidcat) та `adb logcat` рекомендовані для моніторингу логів додатку з метою виявлення й захисту чутливої інформації. **Pidcat** віддають перевагу за його простоту використання та зручність читання.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android's **clipboard-based** framework забезпечує функціональність копіювання/вставки в додатках, але несе ризик, оскільки **інші додатки** можуть **доступатися** до буфера обміну, потенційно розкриваючи чутливі дані. Важливо **відключати функції copy/paste** для чутливих секцій додатку, наприклад даних кредитної картки, щоб уникнути leak.

**Crash Logs**

Якщо додаток **падає** і зберігає логи, ці логи можуть допомогти ата-керам, особливо коли додаток важко реверснути. Щоб зменшити цей ризик, уникайте логування при крашах, а якщо логи все ж потрібно передавати мережею — надсилайте їх через SSL-канал для безпеки.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Додатки часто інтегрують сервіси типу Google Adsense, які можуть непередбачено спричинити leak чутливої інформації через неправильну імплементацію розробниками. Щоб виявити потенційні витоки, радимо **перехопити трафік додатку** і перевірити, чи не надсилається чутлива інформація до сторонніх сервісів.

### SQLite DBs

Більшість додатків використовують **internal SQLite databases** для збереження інформації. Під час pentest перегляньте **databases**, які створюються, назви **tables** і **columns** та всі збережені **data**, оскільки ви можете знайти **sensitive information** (що буде вразливістю).\
Databases мають знаходитися в `/data/data/the.package.name/databases` як от `/data/data/com.mwr.example.sieve/databases`

Якщо база даних зберігає конфіденційну інформацію і **encrypted** але ви можете **find** пароль всередині додатку — це все ще є **vulnerability**.

Перерахуйте таблиці за допомогою `.tables` і перегляньте схему таблиці через `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** дозволяє вам **уявити себе Android app** і взаємодіяти з іншими додатками. Воно може робити **все, що може зробити встановлений додаток**, наприклад використовувати механізм Inter-Process Communication (IPC) Android і взаємодіяти з підлягаючою операційною системою.\
Drozer — корисний інструмент для **експлуатації exported activities, exported services і Content Providers**, про що ви дізнаєтесь у наступних розділах.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Також пам'ятайте, що виконання коду активності починається в методі **`onCreate`**.

**Authorisation bypass**

Коли Activity exported, ви можете викликати її екран з зовнішнього додатку. Тому, якщо activity з **чутливою інформацією** **exported**, ви можете **bypass** механізми **authentication** і отримати до неї доступ.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF визначатиме як шкідливе використання _**singleTask/singleInstance**_ як `android:launchMode` в activity, але через [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), схоже, це небезпечно тільки в старих версіях (API versions < 21).

> [!TIP]
> Зауважте, що authorisation bypass не завжди є вразливістю — це залежить від того, як bypass працює і яка інформація стає доступною.

**Sensitive information leakage**

Activities також можуть повертати результати. Якщо вам вдасться знайти exported і незахищену activity, яка викликає метод **`setResult`** і **повертає чутливу інформацію**, це призводить до витоку чутливої інформації.

#### Tapjacking

Якщо Tapjacking не запобігається, ви можете зловживати exported activity, щоб змусити **користувача виконати непередбачені дії**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers в основному використовуються для **share data**. Якщо додаток має доступні content providers, ви можете мати змогу **extract sensitive** дані з них. Також варто перевірити можливі **SQL injections** і **Path Traversals**, оскільки вони можуть бути вразливими.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Пам'ятайте, що дії Service починаються в методі `onStartCommand`.

Сервіс — це по суті те, що **can receive data**, **process** її і **returns** (або ні) відповідь. Тому, якщо додаток експортує якісь services, ви повинні **check** код, щоб зрозуміти, що він робить, і **test** його **dynamically** для витягання конфіденційної інформації, bypassing authentication measures...
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Пам'ятайте, що дії Broadcast Receiver починаються в методі `onReceive`.

Broadcast receiver очікує на певний тип повідомлення. Залежно від того, як receiver обробляє повідомлення, він може бути вразливим.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Ви можете шукати deep links вручну, використовуючи інструменти на кшталт MobSF або скрипти типу [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Ви можете **open** задекларований **scheme** за допомогою **adb** або **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Зауважте, що ви можете **пропустити ім'я пакету** і мобільний пристрій автоматично викличе додаток, який має відкрити це посилання._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Код, що буде виконано**

Щоб знайти **code that will be executed in the App**, перейдіть до activity, яку викликає deeplink, і знайдіть функцію **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Чутлива інформація**

Кожного разу, коли ви знаходите deep link, перевіряйте, що **він не отримує чутливі дані (наприклад паролі) через URL parameters**, оскільки будь-який інший додаток може **impersonate the deep link and steal that data!**

**Parameters in path**

Ви **must check also if any deep link is using a parameter inside the path** URL, наприклад: `https://api.example.com/v1/users/{username}`. У такому випадку ви можете примусити path traversal, отримавши доступ до чогось на кшталт: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Зверніть увагу, що якщо ви знайдете коректні endpoints всередині додатка, ви можете спричинити **Open Redirect** (якщо частина шляху використовується як домен), **account takeover** (якщо можна змінювати дані користувача без CSRF token і вразливий endpoint використовував правильний метод) та будь-яку іншу vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Інспекція транспортного шару та помилки верифікації

- **Certificates are not always inspected properly** Android-додатками. Часто додатки ігнорують застереження і приймають self-signed certificates або, в деяких випадках, повертаються до використання HTTP-з’єднань.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, застосовуючи небезпечні cipher suites. Це робить з'єднання вразливим до man-in-the-middle (MITM) атак, що дозволяє зловмисникам розшифровувати дані.
- Витік приватної інформації можливий, коли додатки автентифікуються через захищені канали, але потім спілкуються по незахищених каналах для інших транзакцій. Такий підхід не захищає чутливі дані, наприклад session cookies або дані користувачів, від перехоплення зловмисниками.

#### Certificate Verification

Ми зосередимося на **certificate verification**. Потрібно перевіряти цілісність сертифіката сервера для підвищення безпеки. Це критично, оскільки insecure TLS configurations і передача чутливих даних по незашифрованих каналах можуть спричинити значні ризики. Для детальних кроків із перевірки серверних сертифікатів і усунення вразливостей [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) надає вичерпні рекомендації.

#### SSL Pinning

SSL Pinning — це захід безпеки, коли додаток перевіряє сертифікат сервера проти відомої копії, збереженої всередині додатка. Цей метод важливий для запобігання MITM-атакам. Для додатків, що опрацьовують чутливу інформацію, настійно рекомендовано впровадити SSL Pinning.

#### Traffic Inspection

Щоб інспектувати HTTP-трафік, необхідно **встановити сертифікат proxy tool** (наприклад, Burp). Без встановлення цього сертифіката зашифрований трафік може бути невидимим для proxy. Для інструкції зі встановлення custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Додатки, що таргетять **API Level 24 and above**, вимагають змін у Network Security Config, щоб прийняти CA certificate проксі. Цей крок критичний для інспекції зашифрованого трафіку. Для інструкцій зі зміни Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Якщо використовується **Flutter**, потрібно виконати інструкції на [**this page**](flutter.md). Це тому, що просто додати сертифікат у сховище не спрацює — Flutter має власний список валідних CA.

#### Static detection of SSL/TLS pinning

Перед тим як намагатися обхід під час виконання (runtime), швидко відобразіть місця, де pinning застосовується в APK. Static discovery допомагає спланувати hooks/patches і зосередитись на потрібних шляхах коду.

Tool: SSLPinDetect
- Open-source static-analysis utility, що декомпілює APK у Smali (via apktool) і сканує за curated regex patterns реалізацій SSL/TLS pinning.
- Reports exact file path, line number, and a code snippet для кожного збігу.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Використання
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Приклад правил шаблонів (JSON)
Використовуйте або розширюйте сигнатури для виявлення proprietary/custom pinning styles. Ви можете завантажити власний JSON і масштабно сканувати.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Швидке сканування великих додатків через мультипоточність та memory-mapped I/O; попередньо скомпільовані regex зменшують накладні витрати/хибні спрацьовування.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Типові цілі для подальшого тріажу:
- OkHttp: використання CertificatePinner, setCertificatePinner, посилання на пакети okhttp3/okhttp
- Користувацькі TrustManagers: javax.net.ssl.X509TrustManager, перевизначення checkServerTrusted
- Користувацькі SSL контексти: SSLContext.getInstance + SSLContext.init з кастомними менеджерами
- Declarative pins у res/xml network security config та посилання в manifest
- Використовуйте знайдені місця, щоб спланувати Frida hooks, статичні патчі або рев’ю конфігурацій перед динамічним тестуванням.



#### Обхід SSL Pinning

Коли реалізовано SSL Pinning, його обхід необхідний для аналізу HTTPS-трафіку. Для цього доступні різні методи:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- Ви можете використати **Frida** (описано нижче) для обходу цього захисту. Ось гайд для використання Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Можна також спробувати **автоматично обійти SSL Pinning** за допомогою [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Можна також спробувати **автоматично обійти SSL Pinning** за допомогою **MobSF dynamic analysis** (описано нижче)
- Якщо ви все ще вважаєте, що частину трафіку не перехоплюєте, можна спробувати **перенаправити трафік у burp за допомогою iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Пошук поширених web-вразливостей

Важливо також шукати поширені web-вразливості у додатку. Детальна інформація про їх виявлення та пом'якшення виходить за рамки цього резюме, але детально розглянута в інших джерелах.

### Frida

[Frida](https://www.frida.re) — це набір інструментів для динамічної інструменталізації для розробників, реверс-інженерів та дослідників безпеки.\
**Ви можете отримувати доступ до запущеного додатку та hook методів під час виконання, щоб змінювати поведінку, змінювати значення, витягувати значення, виконувати інший код...**\
Якщо ви хочете pentest Android додатки, вам потрібно вміти користуватись Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Деякі "GUI" для роботи з Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Тут можна знайти деякі корисні Frida-скрипти: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Спробуйте обійти anti-debugging / anti-frida механізми, завантажуючи Frida як вказано в [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (інструмент [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & workflow обходу SSL pinning

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Дамп пам'яті - Fridump**

Перевірте, чи додаток зберігає в пам'яті конфіденційну інформацію, яку не повинен зберігати, наприклад паролі або мнемоніки.

Використовуючи [**Fridump3**](https://github.com/rootbsd/fridump3) ви можете зняти дамп пам'яті додатку за допомогою:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Це вивантажить пам'ять у папку ./dump, і там ви можете виконати grep приблизно так:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Чутливі дані в Keystore**

В Android Keystore — найкраще місце для зберігання чутливих даних, однак при наявності достатніх привілеїв все ще **можливо отримати до нього доступ**. Оскільки застосунки мають тенденцію зберігати тут **чутливі дані у відкритому вигляді**, pentests повинні перевіряти це з правами root user, або особи з фізичним доступом до пристрою можуть вкрасти ці дані.

Навіть якщо додаток зберіг дані в Keystore, ці дані повинні бути зашифровані.

Щоб отримати доступ до даних всередині Keystore ви можете використати цей Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

За допомогою наведеного Frida script може бути можливим **bypass fingerprint authentication**, яке Android-застосунки можуть робити для захисту певних чутливих областей:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Фонові зображення**

Коли ви переводите додаток у фоновий режим, Android зберігає **snapshot of the application**, тож при відновленні на передній план спочатку завантажується це зображення і здається, що додаток запустився швидше.

Однак, якщо цей **snapshot** містить **чутливу інформацію**, людина з доступом до snapshot може **викрасти цю інформацію** (зверніть увагу, що для доступу потрібен root).

Зазвичай snapshots зберігаються за адресою: **`/data/system_ce/0/snapshots`**

Android надає спосіб **запобігти захопленню скріншотів, встановивши параметр розмітки FLAG_SECURE**. Використовуючи цей прапорець, вміст вікна позначається як захищений, що не дозволяє йому з’являтися на скріншотах або переглядатися на ненадійних дисплеях.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Цей інструмент може допомогти вам керувати різними інструментами під час динамічного аналізу: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Розробники часто створюють проксі-компоненти, такі як activities, services і broadcast receivers, які обробляють ці Intents і передають їх у методи на зразок `startActivity(...)` або `sendBroadcast(...)`, що може бути небезпечно.

Небезпека полягає в тому, що атакам дозволяється запускати non-exported компоненти додатку або отримувати доступ до чутливих content providers, перенаправляючи ці Intents. Яскравий приклад — компонент `WebView`, що конвертує URL у `Intent` об'єкти через `Intent.parseUri(...)` і потім виконує їх, що потенційно може призвести до malicious Intent injections.

### Essential Takeaways

- **Intent Injection** is similar to web's Open Redirect issue.
- Експлойти включають передачу об'єктів `Intent` як extras, які можуть бути перенаправлені для виконання небезпечних операцій.
- Це може відкрити non-exported components та content providers для атакуючих.
- `WebView`’s URL to `Intent` conversion can facilitate unintended actions.

### Android Client Side Injections and others

Ймовірно, ви знаєте про цей тип вразливостей з вебу. Ви маєте бути особливо обережні з цими вразливостями в Android-додатку:

- **SQL Injection:** When dealing with dynamic queries or Content-Providers ensure you are using parameterized queries.
- **JavaScript Injection (XSS):** Перевірте, що підтримка JavaScript та Plugin відключена для всіх WebViews (за замовчуванням відключено). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews should have access to the file system disabled (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: У декількох випадках, коли Android-додаток завершує сесію, cookie не відкликається або може бути навіть збережений на диск
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Статичний аналіз**

![](<../../images/image (866).png>)

**Оцінка вразливостей додатку** за допомогою зручного веб-інтерфейсу. Ви також можете виконувати динамічний аналіз (але потрібно підготувати середовище).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Зверніть увагу, що MobSF може аналізувати **Android**(apk)**, IOS**(ipa) **та Windows**(apx) додатки (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF також дозволяє робити **diff/Compare** аналіз і інтегрувати **VirusTotal** (вам потрібно встановити свій API ключ у _MobSF/settings.py_ та увімкнути його: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Ви також можете встановити `VT_UPLOAD` в `False`, тоді **hash** буде **upload** замість файлу.

### Assisted Dynamic analysis with MobSF

**MobSF** також може бути дуже корисним для **dynamic analysis** на **Android**, але в цьому випадку вам потрібно встановити MobSF і **genymotion** на ваш хост (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **автоматично запустить Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP інструменти**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> Після виконання dynamic analysis з MobSF налаштування проксі можуть бути некоректними, і ви не зможете виправити їх через GUI. Ви можете виправити налаштування проксі, виконавши:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Асистований динамічний аналіз з Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
This tool with use some **Hooks** to let you know **what is happening in the application** while you perform a **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Відображає всі витягнуті файли для зручного перегляду
- Автоматично декомпілює APK файли у Java та Smali формати
- Аналізує AndroidManifest.xml на предмет загальних вразливостей та поведінки
- Статичний аналіз вихідного коду на наявність загальних вразливостей та поведінки
- Інформація про пристрій
- та інше
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER — це консольний застосунок, який можна використовувати в Windows, MacOS X та Linux; він аналізує _.apk_ файли в пошуках вразливостей. Він робить це шляхом розпакування APK-файлів та застосування набору правил для виявлення цих вразливостей.

Усі правила зосереджені у файлі `rules.json`, і кожна компанія чи тестувальник можуть створити власні правила для аналізу того, що їм потрібно.

Завантажте останні бінарні файли зі сторінки [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn — це **crossplatform** інструмент, який допомагає розробникам, bugbounty hunters та ethical hackers у проведенні [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) мобільних додатків.

Ідея полягає в тому, що ви перетягуєте файл вашого мобільного додатка (файл .apk або .ipa) у застосунок StaCoAn, і він згенерує для вас візуальний та портативний звіт. Ви можете змінювати налаштування та wordlists, щоб отримати персоналізований досвід.

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework — це система аналізу вразливостей Android, яка допомагає розробникам або hackers виявляти потенційні вразливості в Android-додатках.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** — інструмент, основна мета якого — виявляти та попереджати користувача про потенційно шкідливу поведінку, реалізовану Android-додатком.

Виявлення здійснюється шляхом **статичного аналізу** байткоду Dalvik застосунку, представленого як **Smali**, за допомогою бібліотеки [`androguard`](https://github.com/androguard/androguard).

Цей інструмент шукає **типову поведінку «шкідливих» додатків**, наприклад: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Це інструмент, який об'єднує commonly used mobile application reverse engineering and analysis tools, щоб допомогти в тестуванні мобільних додатків щодо загроз OWASP mobile security. Його мета — зробити це завдання простішим і зручнішим для розробників мобільних додатків та фахівців із безпеки.

It is able to:

- Витягувати Java і Smali код, використовуючи різні інструменти
- Аналізувати APK за допомогою: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Витягувати приватну інформацію з APK за допомогою regexps.
- Аналізувати Manifest.
- Аналізувати знайдені домени за допомогою: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com]

### Koodous

Корисно для виявлення malware: [https://koodous.com/](https://koodous.com/)

## Обфускація/Деобфускація коду

Зверніть увагу, що залежно від сервісу та конфігурації, яку ви використовуєте для обфускації коду, секрети можуть бути або не бути обфусцовані.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Він здатен оптимізувати bytecode, а також виявляти та видаляти невикористані інструкції. ProGuard — вільне програмне забезпечення і розповсюджується під GNU General Public License, version 2.

ProGuard постачається як частина Android SDK і запускається під час збірки додатку в release режимі.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Ви можете завантажити обфускований APK на їхню платформу.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [Play Integrity API: How It Works & How to Bypass It](https://m4kr0.vercel.app/posts/play-integrity-api-how-it-works--how-to-bypass-it/)
- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) It is a great list of resources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
