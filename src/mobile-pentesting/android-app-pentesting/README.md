# Android 애플리케이션 Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android 애플리케이션 기초

이 페이지를 먼저 읽어 **Android 보안 및 Android 애플리케이션에서 가장 위험한 구성 요소와 관련된 가장 중요한 부분**을 파악하는 것을 강력히 권장합니다:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

이 도구는 에뮬레이터 또는 실기기 등 Android 디바이스에 연결할 때 필요한 주요 도구입니다.\
**ADB**는 컴퓨터에서 **USB** 또는 **Network**를 통해 디바이스를 제어할 수 있게 해줍니다. 이 유틸리티는 양방향 파일 **복사**, 앱의 **설치** 및 **제거**, 셸 명령 **실행**, 데이터 **백업**, 로그 **읽기** 등 다양한 기능을 제공합니다.

다음의 [**ADB Commands**](adb-commands.md) 목록을 확인하여 adb 사용법을 익히세요.

## Smali

때로는 숨겨진 정보(예: 잘 난독화된 비밀번호나 플래그)에 접근하기 위해 애플리케이션 코드를 수정하는 것이 유용할 수 있습니다. 그런 경우 apk를 디컴파일하고 코드를 수정한 뒤 다시 컴파일하는 것이 흥미로울 수 있습니다.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). 이는 동적 분석 중 수행할 여러 테스트의 **대안**으로 매우 유용할 수 있습니다. 따라서 **항상 이 가능성을 염두에 두세요**.

## 기타 흥미로운 트릭

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **APK 다운로드**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 디바이스에서 APK 추출:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 모든 splits 및 base apks를 [APKEditor](https://github.com/REAndroid/APKEditor)로 병합:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Static Analysis

먼저, APK를 분석할 때는 디컴파일러를 사용해 **Java 코드를 확인해야 합니다**.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Looking for interesting Info

APK의 **strings**를 살펴보면 **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** 등 흥미로운 항목을 찾을 수 있습니다. 코드 실행을 위한 **backdoors**나 인증 백도어(앱에 하드코딩된 관리자 자격증명)도 확인하세요.

**Firebase**

**firebase URLs**에 특히 주의하고 잘못 구성되어 있는지 확인하세요. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

애플리케이션의 _Manifest.xml_ 및 **_strings.xml_** 파일을 검사하면 잠재적인 보안 취약점을 발견할 수 있습니다. 이러한 파일은 디컴파일러로 접근하거나 APK 파일 확장자를 .zip으로 바꿔 압축을 풀어 확인할 수 있습니다.

_Manifest.xml_에서 식별 가능한 **취약점**에는 다음이 포함됩니다:

- **Debuggable Applications**: _Manifest.xml_ 파일에서 `debuggable="true"`로 설정된 애플리케이션은 연결을 허용하여 악용될 위험이 있습니다. 디버거 사용 애플리케이션을 찾고 악용하는 방법에 대해서는 관련 튜토리얼을 참조하세요.
- **Backup Settings**: 민감한 정보를 다루는 애플리케이션은 adb를 통한 무단 데이터 백업을 방지하기 위해 `android:allowBackup="false"` 속성을 명시적으로 설정해야 합니다(특히 usb debugging이 활성화된 경우).
- **Network Security**: `android:networkSecurityConfig="@xml/network_security_config"` 같은 커스텀 네트워크 보안 설정은 res/xml/에 위치하며 인증서 핀이나 HTTP 트래픽 설정 등 보안 세부사항을 지정할 수 있습니다. 예를 들어 특정 도메인에 대해 HTTP 트래픽을 허용하도록 설정할 수 있습니다.
- **Exported Activities and Services**: 매니페스트에서 exported된 activity나 service를 식별하면 악용될 수 있는 컴포넌트를 확인할 수 있습니다. 동적 테스트 중 추가 분석을 통해 이러한 컴포넌트를 어떻게 악용할 수 있는지 밝혀낼 수 있습니다.
- **Content Providers and FileProviders**: 노출된 content provider는 무단 접근 또는 데이터 수정이 가능할 수 있습니다. FileProvider의 구성도 꼼꼼히 검토해야 합니다.
- **Broadcast Receivers and URL Schemes**: 이러한 컴포넌트는 악용될 수 있으며, 특히 URL 스킴이 입력 처리에 어떻게 작용하는지 주의 깊게 살펴야 합니다.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, `maxSdkVersion` 속성은 지원되는 Android 버전을 나타내며, 오래되고 취약한 Android 버전을 지원하지 않는 것이 중요함을 시사합니다.

**strings.xml** 파일에서는 API 키, custom schemas 및 기타 개발자 메모와 같은 민감한 정보가 발견될 수 있으므로 이러한 리소스를 신중히 검토해야 합니다.

### Tapjacking

Tapjacking은 **악성** **애플리케이션**이 실행되어 **피해자 애플리케이션 위에 자신을 배치**하는 공격입니다. 일단 피해자 앱을 시각적으로 가리면, 공격자의 UI는 사용자가 조작하도록 속이도록 설계되고 그 상호작용을 피해자 앱으로 전달합니다.\
결과적으로 사용자는 자신이 실제로는 피해자 앱에서 동작을 수행하고 있다는 사실을 인지하지 못하게 됩니다.

자세한 내용은 다음을 참조하세요:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode`가 **`singleTask`이고 `taskAffinity`가 정의되지 않은** activity는 Task Hijacking에 취약합니다. 이는 악성 **application**이 설치되어 실제 애플리케이션보다 먼저 실행되면 실제 애플리케이션의 task를 **hijack**할 수 있음을 의미합니다(따라서 사용자는 **실제 앱을 사용하고 있다고 생각하면서 악성 앱과 상호작용하게 됩니다**).

자세한 내용은:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

Internal Storage

Android에서 내부 저장소에 저장된 파일은 이를 생성한 **앱**만 접근할 수 있도록 설계되어 있습니다. 이 보안 조치는 Android 운영체제에 의해 강제되며 대부분의 애플리케이션 보안 요구사항에 대해 충분합니다. 그러나 개발자들이 `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE` 같은 모드를 사용하여 파일을 다른 애플리케이션과 공유하도록 허용하는 경우가 있습니다. 이 모드들은 잠재적으로 악의적인 애플리케이션을 포함한 다른 애플리케이션에 의해 파일 접근을 제한하지 않습니다.

1. **Static Analysis:**
- `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`의 사용을 신중하게 검토하세요. 이러한 모드는 파일을 의도치 않거나 무단 접근에 노출시킬 수 있습니다.
2. **Dynamic Analysis:**
- 애플리케이션이 생성한 파일에 설정된 **permissions**를 확인하세요. 특히 어떤 파일이 전역으로 읽기 또는 쓰기 가능한지 확인하십시오. 이는 어떤 애플리케이션이든, 출처나 의도와 상관없이 해당 파일을 읽거나 수정할 수 있게 하므로 심각한 보안 위험이 될 수 있습니다.

External Storage

SD 카드와 같은 외부 저장소의 파일을 다룰 때는 다음 주의사항을 따르세요:

1. **Accessibility**:
- 외부 저장소의 파일은 전역적으로 읽기/쓰기가 가능합니다. 즉, 어떤 애플리케이션이나 사용자라도 이 파일들에 접근할 수 있습니다.
2. **Security Concerns**:
- 접근이 쉬우므로 민감한 정보를 외부 저장소에 저장하지 않는 것이 좋습니다.
- 외부 저장소는 제거되거나 어떤 애플리케이션이라도 접근할 수 있어 보안이 낮습니다.
3. **Handling Data from External Storage**:
- 외부 저장소에서 가져온 데이터는 항상 입력 검증을 수행하세요. 외부 저장소의 데이터는 신뢰할 수 없는 출처에서 온 것이기 때문에 검증이 중요합니다.
- 외부 저장소에 실행 파일이나 class 파일을 저장해 동적으로 로드하는 것은 강력히 권장하지 않습니다.
- 애플리케이션이 외부 저장소에서 실행 파일을 받아야 하는 경우, 해당 파일이 동적 로드되기 전에 서명되어 있고 암호학적으로 검증되었는지 확인하세요. 이는 애플리케이션의 보안 무결성을 유지하는 데 필수적입니다.

외부 저장소는 `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`에서 접근할 수 있습니다.

> [!TIP]
> Android 4.4(**API 17**)부터 SD 카드에는 앱별로 해당 앱 전용 디렉터리에 대한 접근을 제한하는 디렉터리 구조가 도입되었습니다. 이는 악성 애플리케이션이 다른 앱의 파일에 대한 읽기 또는 쓰기 접근을 얻는 것을 방지합니다.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android는 각 애플리케이션이 `/data/data/<packagename>/shared_prefs/` 경로에 XML 파일을 쉽게 저장할 수 있게 해주며, 때때로 해당 폴더에서 평문으로 된 민감한 정보를 발견할 수 있습니다.
- **Databases**: Android는 각 애플리케이션이 `/data/data/<packagename>/databases/` 경로에 sqlite 데이터베이스를 쉽게 저장할 수 있게 해주며, 때때로 해당 폴더에서 평문으로 된 민감한 정보를 발견할 수 있습니다.

### Broken TLS

**Accept All Certificates**

어떤 이유로 개발자들이 호스트네임이 일치하지 않더라도 모든 인증서를 수락하는 경우가 있습니다. 예를 들어 다음과 같은 코드 라인처럼:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 암호화 취약점

**열악한 키 관리 프로세스**

일부 개발자는 민감한 데이터를 로컬 스토리지에 저장하고 코드에 하드코딩되었거나 예측 가능한 키로 암호화합니다. 이는 reversing 같은 역분석 기법으로 공격자가 기밀 정보를 추출할 수 있으므로 해서는 안 됩니다.

**보안에 취약하거나 더 이상 사용되지 않는 알고리즘의 사용**

개발자는 권한 부여 **checks**, 데이터 **store** 또는 **send**에 **deprecated algorithms**를 사용해서는 안 됩니다. 예시로는 RC4, MD4, MD5, SHA1 등이 있습니다. 예를 들어 비밀번호 저장에 **hashes**를 사용하는 경우에는 salt와 함께 brute-force에 **resistant**한 해시 알고리즘을 사용해야 합니다.

### 기타 점검

- 공격자의 reverse engineer 작업을 어렵게 만들기 위해 **APK를 obfuscate**하는 것이 권장됩니다.
- 앱이 민감한 경우(예: bank apps)는 자체적으로 모바일이 **rooted**인지 확인하고 이에 따라 동작해야 합니다.
- 앱이 민감한 경우(예: bank apps)는 **emulator** 사용 여부를 확인해야 합니다.
- 앱이 민감한 경우(예: bank apps)는 실행 전에 **자기 무결성(integrity)**을 확인하여 수정되었는지 검사해야 합니다.
- 어떤 compiler/packer/obfuscator로 APK가 빌드되었는지 확인하려면 [**APKiD**](https://github.com/rednaga/APKiD)를 사용하세요

### React Native Application

다음 페이지를 읽어 React 애플리케이션의 javascript 코드를 쉽게 접근하는 방법을 배우세요:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

다음 페이지를 읽어 xamarin 애플리케이션의 C# 코드에 쉽게 접근하는 방법을 배우세요:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

이 [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)에 따르면 superpacked는 애플리케이션의 내용을 하나의 파일로 압축하는 Meta 알고리즘입니다. 블로그는 이러한 앱을 압축 해제하는 앱을 만드는 가능성에 대해 이야기하며... 더 빠른 방법으로는 **애플리케이션을 실행하고 파일시스템에서 압축 해제된 파일을 수집하는 것을 포함**한다고 합니다.

### Automated Static Code Analysis

도구 [**mariana-trench**](https://github.com/facebook/mariana-trench)는 애플리케이션의 **code**를 **scanning**하여 **vulnerabilities**를 찾을 수 있습니다. 이 도구는 **known sources**(툴에 **input**이 **사용자에 의해 제어되는 위치**를 알려주는 것), **sinks**(악의적 사용자 입력이 피해를 줄 수 있는 **위험한 위치**) 및 **rules**의 집합을 포함합니다. 이러한 rules는 취약점을 나타내는 **sources-sinks**의 **조합**을 정의합니다.

이 지식을 바탕으로 **mariana-trench는 코드를 검토하고 잠재적 취약점을 찾아냅니다**.

### Secrets leaked

애플리케이션에는 API keys, passwords, hidden urls, subdomains 등과 같은 secrets가 포함되어 있어 발견할 수 있습니다. 다음과 같은 도구를 사용할 수 있습니다: [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

무료 계정을 생성할 수 있는 플랫폼: [https://appetize.io/](https://appetize.io). 이 플랫폼은 APK를 **업로드**하고 **실행**할 수 있게 해주므로 apk가 어떻게 동작하는지 확인하는 데 유용합니다.

웹에서 애플리케이션의 로그를 **보고 adb로 연결**할 수도 있습니다.

![](<../../images/image (831).png>)

ADB 연결 덕분에 에뮬레이터 내에서 **Drozer**와 **Frida**를 사용할 수 있습니다.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (x86 및 arm 디바이스를 생성할 수 있으며, [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**최신 x86** 버전은 느린 arm emulator가 필요 없이 ARM libraries를 지원합니다).
- 설정 방법은 다음 페이지를 참조하세요:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, 계정 생성 필요. _잠재적 오류를 피하려면 VirtualBox가 포함된 버전을 **다운로드**하는 것이 권장됩니다._)
- [**Nox**](https://es.bignox.com) (무료이지만 Frida나 Drozer를 지원하지 않습니다).

> [!TIP]
> 새로운 emulator를 생성할 때 화면이 클수록 emulator가 느려집니다. 가능하면 작은 화면을 선택하세요.

Genymotion에 Google 서비스를 설치하려면 다음 이미지에서 빨간색으로 표시된 버튼을 클릭해야 합니다:

![](<../../images/image (277).png>)

또한 **Genymotion의 Android VM 구성**에서 **Bridge Network mode**를 선택할 수 있는 것을 확인하세요(다른 VM에서 도구로 Android VM에 연결할 경우 유용합니다).

#### Use a physical device

**debugging** 옵션을 활성화해야 하며, 가능하면 **root**하는 것이 좋습니다:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. 뒤로 가면 **Developer options**를 찾을 수 있습니다.

> 애플리케이션을 설치한 후 가장 먼저 해야 할 일은 앱을 직접 사용해 보고 무엇을 하는지, 어떻게 동작하는지 조사하여 익숙해지는 것입니다.\
> 초기 동적 분석은 MobSF dynamic analysis + pidcat를 사용하여 수행하는 것을 권장합니다. 이렇게 하면 MobSF가 나중에 검토할 수 있는 많은 **interesting data**를 캡처하는 동안 애플리케이션의 동작을 **배울 수 있습니다**.

Magisk/Zygisk 빠른 노트 (Pixel 기기에서 권장)
- Magisk 앱으로 boot.img를 패치하고 fastboot로 플래시하여 systemless root 획득
- Zygisk + DenyList 활성화로 root 숨기기; 더 강력한 숨김이 필요하면 LSPosed/Shamiko 고려
- OTA 업데이트에서 복구할 수 있도록 원본 boot.img를 보관; 각 OTA 후 재패치
- 화면 미러링은 호스트에서 scrcpy 사용

### Unintended Data Leakage

**Logging**

개발자는 **debugging information**을 공개적으로 노출하는 것을 주의해야 합니다. 이는 민감한 데이터의 leak로 이어질 수 있습니다. 애플리케이션 로그를 모니터링하여 민감한 정보를 식별하고 보호하려면 [**pidcat**](https://github.com/JakeWharton/pidcat)와 `adb logcat` 도구를 사용하는 것이 권장됩니다. **Pidcat**은 사용 편의성과 가독성 때문에 선호됩니다.

> [!WARNING]
> **Android 4.0** 이후 버전부터는 **applications are only able to access their own logs**입니다. 따라서 앱은 다른 앱의 로그에 접근할 수 없습니다.\
> 어쨌든 민감한 정보를 로그에 남기지 않는 것이 좋습니다.

**Copy/Paste Buffer Caching**

Android의 **clipboard-based** 프레임워크는 앱 간 복사-붙여넣기 기능을 제공하지만, **다른 applications**이 클립보드에 접근할 수 있어 민감한 데이터가 노출될 위험이 있습니다. 신용카드 정보와 같은 민감한 섹션에 대해서는 복사/붙여넣기 기능을 비활성화하는 것이 중요합니다.

**Crash Logs**

애플리케이션이 **crash**하여 로그를 저장하면, 특히 애플리케이션을 리버스할 수 없는 경우 이러한 로그가 공격자에게 도움이 될 수 있습니다. 이 위험을 완화하려면 크래시 시 로깅을 피하고, 로그를 네트워크로 전송해야 할 경우 SSL 채널을 통해 전송하도록 하세요.

페네트스터로서, **이러한 로그들을 확인해 보세요**.

**Analytics Data Sent To 3rd Parties**

애플리케이션은 종종 Google Adsense 같은 서비스를 통합하는데, 개발자의 잘못된 구현으로 인해 민감한 데이터가 unintentionally leak될 수 있습니다. 잠재적 데이터 누수를 식별하려면 애플리케이션의 트래픽을 가로채어 제3자 서비스로 민감한 정보가 전송되는지 확인하는 것이 좋습니다.

### SQLite DBs

대부분의 애플리케이션은 정보를 저장하기 위해 **internal SQLite databases**를 사용합니다. 펜테스트 중에는 생성된 **databases**, **tables**와 **columns** 이름 및 저장된 모든 **data**를 확인하세요. 여기에서 민감한 정보(취약점)가 발견될 수 있습니다.\
데이터베이스는 일반적으로 `/data/data/the.package.name/databases`에 위치합니다. 예: `/data/data/com.mwr.example.sieve/databases`

데이터베이스가 기밀 정보를 저장하고 있고 **encrypted**되어 있더라도, 애플리케이션 내에서 그 **password**를 찾을 수 있다면 여전히 **취약점**입니다.

`.tables`를 사용해 테이블을 열거하고 `.schema <table_name>`으로 테이블의 컬럼을 열거하세요.

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer**는 당신이 **Android app의 역할을 가정**하고 다른 앱과 상호작용할 수 있게 해줍니다. 그것은 설치된 애플리케이션이 할 수 있는 거의 모든 것을 수행할 수 있으며, Android의 Inter-Process Communication (IPC) 메커니즘을 사용하고 기본 운영체제와 상호작용할 수 있습니다.\
Drozer는 **exported activities, exported services 및 Content Providers**를 **exploit**하는 데 유용한 도구입니다. 다음 섹션에서 이를 배우게 될 것입니다.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
또한 activity의 코드는 **`onCreate`** 메서드에서 시작된다는 것을 기억하세요.

**Authorisation bypass**

Activity가 exported된 경우 외부 앱에서 해당 화면을 호출할 수 있습니다. 따라서 **민감한 정보**를 가진 Activity가 **exported**되어 있다면 **authentication** 메커니즘을 우회하여 접근할 수 있습니다.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

adb로 exported activity를 시작할 수도 있습니다:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF는 activity에서 `android:launchMode`로 _**singleTask/singleInstance**_ 사용을 악성으로 감지하지만, [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) 때문에 이는 구버전(API versions < 21)에서만 위험한 것으로 보인다.

> [!TIP]
> authorisation bypass가 항상 취약점은 아니라는 점을 유의하라. 우회가 어떻게 동작하는지와 어떤 정보가 노출되는지에 따라 달라진다.

**Sensitive information leakage**

**Activities는 결과를 반환할 수도 있다**. 만약 exported and unprotected activity가 `setResult` 메서드를 호출하여 민감한 정보를 반환하는 것을 찾으면, 민감한 정보 유출이 발생한다.

#### Tapjacking

Tapjacking이 방지되지 않으면, exported activity를 악용하여 **사용자가 예상치 못한 동작을 수행하게 만들 수 있다**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers는 기본적으로 데이터를 공유하는 데 사용된다. 앱에 사용 가능한 content providers가 있으면, 그들로부터 민감한 데이터를 추출할 수 있을지도 모른다. 또한 잠재적으로 취약할 수 있으므로 **SQL injections** 및 **Path Traversals**에 대한 테스트도 흥미롭다.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Service의 동작은 `onStartCommand` 메서드에서 시작된다는 점을 기억하라.

Service는 기본적으로 데이터를 수신하고 이를 처리하며 응답을 반환(또는 반환하지 않을 수)한다. 따라서 애플리케이션이 일부 서비스를 export하고 있다면, 무엇을 하는지 이해하기 위해 코드를 확인하고 기밀 정보를 추출하거나 인증 우회 등을 위해 동적으로 테스트해야 한다.\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Broadcast Receiver의 동작은 `onReceive` 메서드에서 시작된다는 점을 기억하라.

Broadcast receiver는 특정 유형의 메시지를 대기한다. 리시버가 메시지를 처리하는 방식에 따라 취약할 수 있다.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

MobSF 같은 도구나 스크립트([this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) 등)를 사용해 deep links를 수동으로 찾을 수 있다.\
선언된 **scheme**을 **adb**나 **browser**를 사용해 **open**할 수 있다:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_패키지 이름을 **생략할 수 있으며** 모바일이 해당 링크를 열 앱을 자동으로 호출합니다._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**실행되는 코드**

앱에서 **실행될 코드**를 찾으려면, deeplink에 의해 호출된 activity로 이동해 함수 **`onNewIntent`**를 검색하세요.

![](<../../images/image (436) (1) (1) (1).png>)

**민감한 정보**

deep link를 찾을 때마다 **URL 파라미터를 통해 민감한 데이터(예: 비밀번호)를 수신하지 않는지** 확인하세요. 그렇지 않으면 다른 애플리케이션이 **deep link를 사칭해 해당 데이터를 탈취할 수 있습니다!**

**경로 내 파라미터**

URL 경로 안에 파라미터를 사용하는 deep link가 있는지 **반드시 확인해야 합니다**. 예: `https://api.example.com/v1/users/{username}`. 이 경우 다음과 같이 경로 순회(path traversal)를 강제할 수 있습니다: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
앱 내부에서 올바른 엔드포인트를 찾으면 경로의 일부가 도메인으로 사용되는 경우 **Open Redirect**를 유발할 수 있고, CSRF 토큰 없이 사용자 세부정보를 수정할 수 있고 vuln endpoint가 올바른 메서드를 사용했다면 **account takeover**를 일으킬 수 있으며 기타 여러 취약점을 야기할 수 있습니다. 자세한 내용은 [info about this here](http://dphoeniixx.com/2020/12/13-2/)를 참조하세요.

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### 전송 계층 검사 및 검증 실패

- **Certificates are not always inspected properly** by Android applications. Android 애플리케이션은 경고를 무시하고 self-signed 인증서를 수락하거나 경우에 따라 HTTP로 폴백하는 경우가 흔합니다.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, 취약한 cipher suite를 사용하면 연결이 man-in-the-middle (MITM) 공격에 취약해져 공격자가 데이터를 복호화할 수 있습니다.
- **Leakage of private information**은 애플리케이션이 인증은 보안 채널에서 수행하지만 다른 통신은 비보안 채널로 진행할 때 발생할 수 있는 위험입니다. 이 방식은 세션 쿠키나 사용자 정보 같은 민감한 데이터를 악의적인 주체가 가로채는 것으로부터 보호하지 못합니다.

#### Certificate Verification

우리는 **certificate verification**에 초점을 맞출 것입니다. 서버 인증서의 무결성을 검증하는 것은 보안을 강화하기 위해 필수적입니다. 불안정한 TLS 구성이나 암호화되지 않은 채널을 통한 민감한 데이터 전송은 심각한 위험을 초래할 수 있습니다. 서버 인증서 검증 및 취약점 대응에 대한 자세한 단계는 [**this resource**](https://manifestsecurity.com/android-application-security-part-10/)를 참조하세요.

#### SSL Pinning

SSL Pinning은 애플리케이션이 서버의 인증서를 앱 내부에 저장된 알려진 복사본과 대조하여 검증하는 보안 조치입니다. 이 방법은 MITM 공격을 방지하는 데 중요합니다. 민감한 정보를 다루는 애플리케이션에는 SSL Pinning 구현을 강력히 권장합니다.

#### Traffic Inspection

HTTP 트래픽을 검사하려면 프록시 도구의 인증서(예: Burp)를 **설치해야** 합니다. 이 인증서를 설치하지 않으면 암호화된 트래픽이 프록시를 통해 보이지 않을 수 있습니다. 커스텀 CA 인증서 설치 가이드는 [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)를 참조하세요.

API Level 24 이상을 타겟팅하는 애플리케이션은 프록시의 CA 인증서를 수락하도록 Network Security Config를 수정해야 합니다. 암호화된 트래픽을 검사하려면 이 단계가 필수적입니다. Network Security Config 수정 방법은 [**refer to this tutorial**](make-apk-accept-ca-certificate.md)를 확인하세요.

만약 **Flutter**를 사용한다면 [**this page**](flutter.md)에 있는 지침을 따라야 합니다. 이는 인증서를 스토어에 추가하는 것만으로는 작동하지 않기 때문인데, Flutter는 자체 유효 CA 목록을 사용합니다.

#### Static detection of SSL/TLS pinning

런타임 바이패스를 시도하기 전에 APK에서 pinning이 적용된 위치를 빠르게 맵핑하세요. 정적 탐지는 훅/패치 계획을 세우고 올바른 코드 경로에 집중하는 데 도움을 줍니다.

Tool: SSLPinDetect
- 오픈소스 정적 분석 유틸리티로 APK를 Smali로 디컴파일(apktool 사용)한 뒤 SSL/TLS pinning 구현에 대한 선별된 정규식 패턴을 스캔합니다.
- 각 매치에 대해 정확한 파일 경로, 라인 번호, 코드 스니펫을 리포트합니다.
- 일반적인 프레임워크 및 커스텀 코드 경로를 다룹니다: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, 그리고 Network Security Config XML pins 등.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
사용법
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
예시 패턴 규칙 (JSON)
proprietary/custom pinning styles를 탐지하기 위해 signatures를 사용하거나 확장하세요. 자신의 JSON을 로드해 대규모로 스캔할 수 있습니다.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- 대규모 앱을 멀티스레딩 및 memory-mapped I/O로 빠르게 스캔; 미리 컴파일된 정규식은 오버헤드/오탐을 줄여줍니다.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 다음으로 우선 검토할 일반적인 탐지 대상:
- OkHttp: CertificatePinner 사용, setCertificatePinner, okhttp3/okhttp 패키지 참조
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted 오버라이드
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init (커스텀 매니저 포함)
- res/xml network security config의 선언적 pins 및 매니페스트 참조
- 동적 테스트 전에 일치하는 위치를 활용해 Frida hooks, static patches 또는 구성 검토를 계획하세요.



#### SSL Pinning 우회

SSL Pinning이 구현된 경우 HTTPS 트래픽을 검사하려면 이를 우회해야 합니다. 이를 위한 다양한 방법이 있습니다:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). 이 방법의 가장 큰 장점은 SSL Pinning을 우회하기 위해 root가 필요 없다는 점이지만, 애플리케이션을 삭제 후 새로 설치해야 하고 항상 동작하지는 않습니다.
- You could use **Frida** (discussed below) to bypass this protection. Burp+Frida+Genymotion 사용 가이드: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- 또한 [**objection**](frida-tutorial/objection-tutorial.md)를 사용해 **자동으로 SSL Pinning을 우회**해볼 수 있습니다:**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dynamic analysis**를 사용해 **자동으로 SSL Pinning을 우회**해 볼 수도 있습니다 (아래에 설명됨)
- 아직 캡처되지 않은 트래픽이 있다고 생각되면 **iptables를 사용해 트래픽을 burp로 포워딩**해 보세요. 블로그: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 일반적인 웹 취약점 찾기

애플리케이션 내에서 일반적인 웹 취약점을 검색하는 것도 중요합니다. 이러한 취약점 식별 및 완화에 대한 자세한 내용은 이 요약의 범위를 벗어나지만 다른 곳에 광범위하게 다뤄져 있습니다.

### Frida

[Frida](https://www.frida.re) 는 개발자, 리버스 엔지니어, 보안 연구원을 위한 동적 계측 도구킷입니다.\
**실행 중인 애플리케이션에 접근해 런타임에 메서드를 훅(hook)하여 동작을 변경하거나 값 변경, 값 추출, 다른 코드 실행 등을 할 수 있습니다...**\
Android 애플리케이션을 pentest하려면 Frida 사용법을 알아야 합니다.

- Frida 사용법 배우기: [**Frida tutorial**](frida-tutorial/index.html)
- Frida 작업용 "GUI" 도구: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection은 Frida 사용 자동화에 유용합니다: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- 일부 Awesome Frida 스크립트: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- anti-debugging / anti-frida 메커니즘을 우회하려면 [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace)에 설명된 것처럼 Frida를 로드해 보세요 (도구 [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **메모리 덤프 - Fridump**

애플리케이션이 비밀번호나 니모닉 등 보관해서는 안 되는 민감한 정보를 메모리에 저장하고 있는지 확인하세요.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) 를 사용하면 다음과 같이 앱의 메모리를 덤프할 수 있습니다:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
이것은 메모리를 ./dump 폴더에 덤프하고, 그 안에서 다음과 같이 grep할 수 있습니다:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore의 민감한 데이터**

Android에서 Keystore는 민감한 데이터를 저장하기에 가장 적합한 장소이지만, 권한이 충분하면 여전히 **접근할 수 있습니다**.

애플리케이션은 종종 Keystore에 **민감한 데이터를 평문으로** 저장하기 때문에, 루트 사용자나 기기에 물리적으로 접근할 수 있는 사람이 이 데이터를 탈취할 수 있습니다. 따라서 pentests에서는 이를 확인해야 합니다.

앱이 Keystore에 데이터를 저장하더라도, 그 데이터는 암호화되어 있어야 합니다.

Keystore 내부의 데이터에 접근하려면 다음 Frida 스크립트를 사용할 수 있습니다: https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

다음 Frida 스크립트를 사용하면 Android 애플리케이션이 특정 민감한 영역을 보호하기 위해 수행하는 **bypass fingerprint authentication**을 우회할 수 있습니다:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **배경 이미지**

애플리케이션을 백그라운드로 보낼 때, Android는 애플리케이션의 **스냅샷**을 저장합니다. 포그라운드로 복구될 때 앱보다 먼저 이미지를 로드해 앱이 더 빨리 로드된 것처럼 보이게 하기 위함입니다.

하지만 이 스냅샷에 **민감한 정보**가 포함되어 있다면, 스냅샷에 접근할 수 있는 사람이 그 정보를 **탈취할 수 있습니다**(접근하려면 root 권한이 필요합니다).

스냅샷은 보통 다음 경로에 저장됩니다: **`/data/system_ce/0/snapshots`**

Android는 FLAG_SECURE 레이아웃 파라미터를 설정해 **screenshot 캡처를 방지하는 방법**을 제공합니다. 이 플래그를 사용하면 창 내용이 보안 처리되어, screenshots에 나타나거나 non-secure displays에서 보여지는 것을 방지합니다.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

이 도구는 dynamic analysis 중 다양한 도구를 관리하는 데 도움을 줄 수 있습니다: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

개발자는 종종 이러한 Intent를 처리하고 `startActivity(...)` 또는 `sendBroadcast(...)` 같은 메서드로 전달하는 activities, services, broadcast receivers와 같은 프록시 컴포넌트를 만듭니다. 이는 위험할 수 있습니다.

위험은 공격자가 이러한 Intent를 잘못 유도하여 non-exported app components를 트리거하거나 민감한 content providers에 접근할 수 있게 하는 데 있습니다. 예로 `WebView`가 URL을 `Intent.parseUri(...)`를 통해 Intent 객체로 변환한 뒤 실행해 악의적인 Intent injection을 초래할 수 있습니다.

### Essential Takeaways

- **Intent Injection**는 웹의 Open Redirect 문제와 유사합니다.
- 공격은 `Intent` 객체를 extras로 전달하여 리디렉션되어 안전하지 않은 동작을 실행하게 하는 것을 포함합니다.
- 이는 non-exported components와 content providers를 공격자에게 노출시킬 수 있습니다.
- `WebView`의 URL을 `Intent`로 변환하는 동작은 의도하지 않은 동작을 야기할 수 있습니다.

### Android Client Side Injections and others

이러한 유형의 취약점은 웹에서 이미 알고 있을 것입니다. Android 애플리케이션에서는 다음 취약점들에 대해 특히 주의해야 합니다:

- **SQL Injection:** 동적 쿼리나 Content-Providers를 다룰 때는 parameterized queries를 사용하고 있는지 확인하세요.
- **JavaScript Injection (XSS):** 모든 WebView에서 JavaScript 및 Plugin 지원이 비활성화되어 있는지 확인하세요(기본적으로 비활성화되어 있음). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebView는 파일 시스템 접근이 비활성화되어야 합니다(기본적으로 활성화됨) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 몇몇 경우, android 애플리케이션이 세션을 종료할 때 쿠키가 취소되지 않거나 심지어 디스크에 저장될 수 있습니다
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application**을 웹 기반 프런트엔드를 통해 제공하며, dynamic analysis도 수행할 수 있습니다(단, 환경을 준비해야 합니다).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### MobSF를 이용한 보조 동적 분석

**MobSF**는 Android의 동적 분석에도 매우 유용하지만, 이 경우 호스트에 **MobSF**와 **genymotion**을 설치해야 합니다(가상 머신이나 Docker로는 동작하지 않습니다). _Note: You need to **start first a VM in genymotion** and **then MobSF.**._\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- **HTTPS traffic** 캡처
- **Frida**를 사용해 **런타임 정보** 획득

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Frida scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: 애플리케이션 사용 중 캡처된 모든 문자열을 출력합니다 (출력이 매우 많음)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: 패턴으로 클래스를 검색합니다
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 도구**

HTTP 트래픽을 캡처하면 **"HTTP(S) Traffic"** 하단에서 캡처된 트래픽의 거친 뷰를 보거나 **"Start HTTPTools"** 녹색 버튼에서 더 보기 좋은 뷰를 볼 수 있습니다. 두 번째 옵션에서는 캡처된 요청을 Burp나 Owasp ZAP 같은 **proxies**로 **send**할 수 있습니다.\
이를 위해, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF로 동적 분석을 마치면 "**Start Web API Fuzzer**"를 눌러 **fuzz http requests**를 수행하고 취약점을 찾을 수 있습니다.

> [!TIP]
> MobSF로 동적 분석을 수행한 후 프록시 설정이 잘못 구성되어 GUI에서 수정할 수 없게 되는 경우가 있습니다. 프록시 설정은 다음을 실행하여 수정할 수 있습니다:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

도구는 [**Inspeckage**](https://github.com/ac-pm/Inspeckage)에서 얻을 수 있습니다.\
이 도구는 일부 **Hooks**를 사용하여 동적 분석을 수행하는 동안 애플리케이션에서 **무슨 일이 일어나고 있는지** 알려줍니다.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

GUI로 정적 분석을 수행하기에 **훌륭한 도구**입니다.

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

이 도구는 **security related Android application vulnerabilities**를 **source code** 또는 **packaged APKs**에서 찾도록 설계되었습니다. 또한 이 도구는 발견된 일부 취약점을 악용하기 위한 **"Proof-of-Concept" deployable APK**와 **ADB commands**를 생성할 수 있습니다(Exposed activities, intents, tapjacking...). Drozer와 마찬가지로 테스트 기기를 루팅할 필요는 없습니다.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 참고하기 쉽도록 추출된 모든 파일을 표시합니다
- APK 파일을 자동으로 Java 및 Smali 형식으로 디컴파일합니다
- AndroidManifest.xml을 분석하여 일반적인 취약점 및 동작을 확인합니다
- 정적 소스 코드 분석을 통해 일반적인 취약점 및 동작을 찾습니다
- 기기 정보
- 및 기타 기능
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER는 Windows, MacOS X 및 Linux에서 사용할 수 있는 command-line application으로, 취약점을 찾기 위해 _.apk_ 파일을 분석합니다. 이 도구는 APK를 압축 해제한 후 일련의 규칙을 적용하여 취약점을 탐지합니다.

모든 규칙은 `rules.json` 파일에 집중되어 있으며, 각 회사나 테스터는 필요한 분석을 위해 자체 규칙을 생성할 수 있습니다.

최신 바이너리는 [download page](https://superanalyzer.rocks/download.html)에서 다운로드하세요.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn은 모바일 애플리케이션의 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)를 수행하는 개발자, bugbounty hunters 및 ethical hackers에게 도움이 되는 **crossplatform** 도구입니다.

개념은 모바일 애플리케이션 파일(.apk 또는 .ipa 파일)을 StaCoAn 애플리케이션으로 드래그 앤 드롭하면 시각적이고 휴대 가능한 리포트를 생성해 준다는 것입니다. 설정과 wordlists를 조정하여 맞춤형 경험을 얻을 수 있습니다.

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework은 Android 애플리케이션에서 개발자나 hackers가 잠재적인 보안 취약점을 찾는 데 도움을 주는 취약점 분석 시스템입니다.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**은 Android 애플리케이션이 개발한 잠재적 악성 동작을 탐지하고 사용자에게 경고하는 것을 주요 목적으로 하는 도구입니다.

탐지는 애플리케이션의 Dalvik bytecode를 **Smali**로 표현한 것에 대해 [`androguard`](https://github.com/androguard/androguard) 라이브러리를 사용한 **static analysis**로 수행됩니다.

이 도구는 **common behavior of "bad" applications**와 같은 항목들(예: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...)을 찾습니다.
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. 이 도구는 일반적으로 사용되는 모바일 애플리케이션 reverse engineering 및 analysis 도구들을 모아 OWASP 모바일 보안 위협에 대해 모바일 애플리케이션을 테스트하는 데 도움을 줍니다. 목표는 이 작업을 모바일 애플리케이션 개발자와 보안 전문가에게 더 쉽고 친숙하게 만드는 것입니다.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Useful to detect malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

코드를 obfuscate하는 데 사용하는 서비스와 설정에 따라, Secrets는 obfuscated될 수도 있고 아닐 수도 있습니다.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard는 Android SDK의 일부로 배포되며 release 모드로 애플리케이션을 빌드할 때 실행됩니다.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

You can upload an obfuscated APK to their platform.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b는 ubuntu-mate 기반의 Android 보안 가상 머신으로, 리버스 엔지니어링과 멀웨어 분석을 위한 최신 프레임워크, 튜토리얼 및 실습을 다양한 보안 연구자와 리서처들로부터 모아 포함하고 있습니다.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) It is a great list of resources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
