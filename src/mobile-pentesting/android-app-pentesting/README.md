# Pentesting de Aplicações Android

{{#include ../../banners/hacktricks-training.md}}

## Conceitos Básicos de Aplicações Android

Recomenda-se fortemente começar por ler esta página para conhecer as **partes mais importantes relacionadas com a segurança do Android e os componentes mais perigosos de uma aplicação Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta é a ferramenta principal que você precisa para conectar-se a um dispositivo Android (emulado ou físico).\
**ADB** permite controlar dispositivos tanto por **USB** quanto por **Network** a partir de um computador. Esta utilidade permite o **copiamento** de arquivos em ambas as direções, **instalação** e **desinstalação** de apps, **execução** de comandos de shell, **backup** de dados, **leitura** de logs, entre outras funções.

Veja a lista a seguir de [**ADB Commands**](adb-commands.md) para aprender a usar o adb.

## Smali

Às vezes é interessante **modificar o código da aplicação** para acessar **informações ocultas** (talvez senhas fortemente ofuscadas ou flags). Nesse caso, pode ser interessante decompilar o apk, modificar o código e recompilá-lo.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Isso pode ser muito útil como uma **alternativa para vários testes durante a análise dinâmica** que serão apresentados. Portanto, **mantenha sempre em mente essa possibilidade**.

## Outros truques interessantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Mescle todos os splits e base apks com [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

Primeiro de tudo, para analisar um APK você deve **dar uma olhada no código Java** usando um decompiler.\
Por favor, [**leia aqui para encontrar informações sobre os diferentes decompilers disponíveis**](apk-decompilers.md).

### Looking for interesting Info

Apenas olhando as **strings** do APK você pode procurar por **senhas**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** e qualquer coisa interessante... procure até por backdoors de execução de código ou backdoors de autenticação (credenciais admin hardcoded no app).

**Firebase**

Preste atenção especial às **Firebase URLs** e verifique se está mal configurado. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

A **análise do _Manifest.xml_ e dos arquivos **_strings.xml_** de um aplicativo pode revelar potenciais vulnerabilidades de segurança**. Esses arquivos podem ser acessados usando decompilers ou renomeando a extensão do arquivo APK para .zip e então descompactando-o.

**Vulnerabilidades** identificadas a partir do **Manifest.xml** incluem:

- **Debuggable Applications**: Aplicações configuradas como debuggable (`debuggable="true"`) no arquivo _Manifest.xml_ representam um risco, pois permitem conexões que podem levar à exploração. Para entender melhor como explorar aplicações debuggable, consulte um tutorial sobre como encontrar e explorar aplicativos debuggable em um dispositivo.
- **Backup Settings**: O atributo `android:allowBackup="false"` deve ser explicitamente definido para aplicações que lidam com informações sensíveis para prevenir backups não autorizados via adb, especialmente quando usb debugging está habilitado.
- **Network Security**: Configurações de segurança de rede customizadas (`android:networkSecurityConfig="@xml/network_security_config"`) em _res/xml/_ podem especificar detalhes de segurança como certificate pins e configurações de tráfego HTTP. Um exemplo é permitir tráfego HTTP para domínios específicos.
- **Exported Activities and Services**: Identificar activities e services exportados no manifest pode evidenciar componentes que podem ser mal utilizados. Uma análise mais aprofundada durante testes dinâmicos pode revelar como explorar esses componentes.
- **Content Providers and FileProviders**: Content providers expostos podem permitir acesso ou modificação não autorizada de dados. A configuração de FileProviders também deve ser examinada com atenção.
- **Broadcast Receivers and URL Schemes**: Esses componentes podem ser aproveitados para exploração, com atenção especial em como os URL schemes são gerenciados para vulnerabilidades de input.
- **SDK Versions**: Os atributos `minSdkVersion`, `targetSDKVersion`, e `maxSdkVersion` indicam as versões do Android suportadas, ressaltando a importância de não suportar versões antigas e vulneráveis do Android por razões de segurança.

A partir do arquivo **strings.xml**, informações sensíveis como API keys, schemas customizados e outras notas de desenvolvedor podem ser descobertas, ressaltando a necessidade de uma revisão cuidadosa desses recursos.

### Tapjacking

**Tapjacking** é um ataque onde uma **aplicação** **maliciosa** é lançada e **se posiciona por cima de uma aplicação vítima**. Uma vez que obscurece visivelmente o app vítima, sua interface é projetada de forma a enganar o usuário para interagir com ela, enquanto passa a interação para o app vítima.\
Na prática, isso **cega o usuário para o fato de que ele está realmente executando ações no app vítima**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Uma **activity** com o **`launchMode`** definida como **`singleTask` sem qualquer `taskAffinity`** definida é vulnerável a Task Hijacking. Isso significa que uma **aplicação** pode ser instalada e, se for iniciada antes da aplicação real, pode **sequestrar a task da aplicação real** (assim o usuário estará interagindo com a **aplicação maliciosa achando que está usando a original**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

No Android, arquivos **armazenados** em **internal** storage são **projetados** para serem **acessíveis** exclusivamente pelo **app** que os **criou**. Essa medida de segurança é **imposta** pelo sistema operacional Android e geralmente é adequada para as necessidades de segurança da maioria das aplicações. Contudo, desenvolvedores às vezes utilizam modos como `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` para **permitir** que arquivos sejam **compartilhados** entre diferentes aplicações. Ainda assim, esses modos **não restringem o acesso** a esses arquivos por outras aplicações, incluindo potenciais maliciosas.

1. **Static Analysis:**
- **Verifique** que o uso de `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` seja **cuidadosamente inspecionado**. Esses modos **podem expor** arquivos a **acessos não intencionais ou não autorizados**.
2. **Dynamic Analysis:**
- **Confirme** as **permissões** definidas nos arquivos criados pelo app. Especificamente, **verifique** se algum arquivo está definido como legível ou gravável por todos. Isto pode representar um risco significativo de segurança, pois permitiria que **qualquer aplicação** instalada no dispositivo, independentemente de sua origem ou intenção, **leia ou modifique** esses arquivos.

**External Storage**

Ao lidar com arquivos em **external storage**, como SD Cards, certas precauções devem ser tomadas:

1. **Acessibilidade**:
- Arquivos em external storage são **legíveis e graváveis globalmente**. Isso significa que qualquer aplicação ou usuário pode acessar esses arquivos.
2. **Preocupações de Segurança**:
- Dada a facilidade de acesso, é aconselhável **não armazenar informações sensíveis** em external storage.
- External storage pode ser removido ou acessado por qualquer aplicação, tornando-o menos seguro.
3. **Tratamento de Dados vindos do External Storage**:
- Sempre **realize validação de input** nos dados recuperados do external storage. Isso é crucial porque os dados são de uma fonte não confiável.
- Armazenar executáveis ou class files no external storage para carregamento dinâmico é fortemente desaconselhado.
- Se sua aplicação necessariamente precisa recuperar arquivos executáveis do external storage, garanta que esses arquivos estejam **assinados e verificados criptograficamente** antes de serem carregados dinamicamente. Essa etapa é vital para manter a integridade de segurança da sua aplicação.

External storage pode ser **acessado** em `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> A partir do Android 4.4 (**API 17**), o SD card possui uma estrutura de diretórios que **limita o acesso de um app ao diretório que é especificamente para aquele app**. Isso impede que uma aplicação maliciosa obtenha acesso de leitura ou escrita aos arquivos de outro app.

**Sensitive data stored in clear-text**

- **Shared preferences**: O Android permite que cada aplicação salve facilmente arquivos xml no caminho `/data/data/<packagename>/shared_prefs/` e às vezes é possível encontrar informações sensíveis em clear-text nessa pasta.
- **Databases**: O Android permite que cada aplicação salve facilmente bancos de dados sqlite no caminho `/data/data/<packagename>/databases/` e às vezes é possível encontrar informações sensíveis em clear-text nessa pasta.

### Broken TLS

**Accept All Certificates**

Por alguma razão, às vezes desenvolvedores aceitam todos os certificados mesmo quando, por exemplo, o hostname não coincide, com trechos de código como o seguinte:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Uma boa forma de testar isto é tentar capturar o tráfego usando um proxy como Burp sem autorizar a Burp CA dentro do dispositivo. Além disso, você pode gerar com o Burp um certificado para um hostname diferente e usá-lo.

### Criptografia Quebrada

**Processos de Gerenciamento de Chaves Fracos**

Alguns desenvolvedores salvam dados sensíveis no armazenamento local e os criptografam com uma chave hardcoded/predictable no código. Isso não deveria ser feito, pois alguma engenharia reversa pode permitir que atacantes extraiam a informação confidencial.

**Uso de Algoritmos Inseguros e/ou Depreciados**

Desenvolvedores não devem usar **algoritmos depreciados** para realizar checks de authorisation, **store** ou **send** dados. Alguns desses algoritmos são: RC4, MD4, MD5, SHA1... Se **hashes** são usados para armazenar senhas, por exemplo, devem ser usados hashes resistentes a brute-force com salt.

### Outras verificações

- É recomendado **obfuscate the APK** para dificultar o trabalho de reverse engineer dos atacantes.
- Se o app for sensível (como apps bancários), ele deve realizar seus **own checks to see if the mobile is rooted** e agir em consequência.
- Se o app for sensível (como apps bancários), ele deve verificar se um **emulator** está sendo usado.
- Se o app for sensível (como apps bancários), ele deve **check it's own integrity before executing** para verificar se foi modificado.
- Use [**APKiD**](https://github.com/rednaga/APKiD) para checar qual compiler/packer/obfuscator foi usado para buildar o APK

### Aplicação React Native

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Aplicações Xamarin

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Análise Estática de Código Automatizada

A ferramenta [**mariana-trench**](https://github.com/facebook/mariana-trench) é capaz de encontrar **vulnerabilidades** ao **scanear** o **código** da aplicação. Esta ferramenta contém uma série de **known sources** (que indicam ao ferramenta os **lugares** onde o **input** é **controlado pelo usuário**), **sinks** (que indicam ao ferramenta **lugares** **perigosos** onde input malicioso do usuário poderia causar danos) e **rules**. Essas regras indicam a **combinação** de **sources-sinks** que aponta uma vulnerabilidade.

Com esse conhecimento, **mariana-trench vai revisar o código e encontrar possíveis vulnerabilidades nele**.

### Secrets leaked

Uma aplicação pode conter segredos (API keys, passwords, hidden urls, subdomains...) dentro dela que você pode conseguir descobrir. Você pode usar uma ferramenta como [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Outras funções interessantes

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Análise Dinâmica

> Primeiro, você precisa de um ambiente onde possa instalar a aplicação e todo o ambiente (Burp CA cert, Drozer and Frida principalmente). Portanto, um dispositivo rootado (emulado ou não) é extremamente recomendado.

### Análise Dinâmica Online

Você pode criar uma **conta gratuita** em: [https://appetize.io/](https://appetize.io). Esta plataforma permite **fazer upload** e **executar** APKs, então é útil para ver como um apk está se comportando.

Você pode até **ver os logs da sua aplicação** na web e conectar via **adb**.

![](<../../images/image (831).png>)

Graças à conexão ADB você pode usar **Drozer** e **Frida** dentro dos emuladores.

### Análise Dinâmica Local

#### Usando um emulador

- [**Android Studio**](https://developer.android.com/studio) (Você pode criar dispositivos **x86** e **arm**, e de acordo com [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** sem precisar de um emulador arm lento).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versão gratuita:** Personal Edition, é necessário criar uma conta. _É recomendável **baixar** a versão **WITH**_ _**VirtualBox** para evitar possíveis erros._)
- [**Nox**](https://es.bignox.com) (Gratuito, mas não suporta Frida ou Drozer).

> [!TIP]
> Ao criar um novo emulador em qualquer plataforma lembre-se que quanto maior a tela, mais lento o emulador ficará. Então selecione telas pequenas se possível.

Para **install google services** (like AppStore) no Genymotion você precisa clicar no botão marcado em vermelho na imagem a seguir:

![](<../../images/image (277).png>)

Além disso, observe que na **configuração da Android VM no Genymotion** você pode selecionar **Bridge Network mode** (isso será útil se você for conectar à Android VM a partir de uma VM diferente com as ferramentas).

#### Usar um dispositivo físico

Você precisa ativar as opções de **debugging** e é recomendado que você consiga **root**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Uma vez que você tenha instalado a aplicação, a primeira coisa que deve fazer é testá-la e investigar o que ela faz, como funciona e se familiarizar com ela.\
> Sugiro **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, assim seremos capazes de **aprender como a aplicação funciona** enquanto o MobSF **captura** muitos **dados interessantes** que você pode revisar mais tarde.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Vazamento de Dados Não Intencional

**Logging**

Desenvolvedores devem ter cuidado ao expor **debugging information** publicamente, pois isso pode levar a vazamentos de dados sensíveis. As ferramentas [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` são recomendadas para monitorar os logs da aplicação e identificar/proteger informações sensíveis. **Pidcat** é preferida por sua facilidade de uso e legibilidade.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

O framework baseado na **clipboard** do Android permite a funcionalidade de copy-paste em apps, mas apresenta risco, já que **other applications** podem **access** a clipboard, potencialmente expondo dados sensíveis. É crucial **disable copy/paste** em sessões sensíveis de uma aplicação, como detalhes de cartão de crédito, para prevenir vazamentos de dados.

**Crash Logs**

Se uma aplicação **crasha** e **salva logs**, esses logs podem ajudar atacantes, especialmente quando a aplicação não pode ser facilmente reversa. Para mitigar esse risco, evite logar em crashes, e se os logs tiverem que ser transmitidos pela rede, garanta que sejam enviados via um canal SSL para segurança.

Como pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Aplicações frequentemente integram serviços como Google Adsense, que podem inadvertidamente **leak sensitive data** devido a implementações incorretas por desenvolvedores. Para identificar possíveis vazamentos, é recomendável **interceptar o tráfego da aplicação** e checar se alguma informação sensível está sendo enviada a serviços de terceiros.

### SQLite DBs

A maioria das aplicações usa **databases SQLite internas** para salvar informações. Durante o pentest, dê uma **olhada** nos **databases** criados, nos nomes das **tables** e **columns** e em todos os **dados** salvos porque você pode encontrar **informação sensível** (o que seria uma vulnerabilidade).\
Os databases devem estar localizados em `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`

Se o database está salvando informação confidencial e está **criptografado**, mas você conseguir encontrar a senha dentro da aplicação, isso ainda é uma **vulnerabilidade**.

Enumere as tables usando `.tables` e enumere as columns das tabelas usando `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is a useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF detectará como malicioso o uso de _**singleTask/singleInstance**_ como `android:launchMode` em uma activity, mas devido a [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), aparentemente isso é perigoso apenas em versões antigas (API versions < 21).

> [!TIP]
> Note that an authorisation bypass is not always a vulnerability — depende de como o bypass funciona e quais informações são expostas.

**Sensitive information leakage**

**Activities can also return results**. Se você conseguir encontrar uma activity exportada e sem proteção que chama o método **`setResult`** e **retorna informações sensíveis**, existe um vazamento de informação sensível.

#### Tapjacking

Se o Tapjacking não for prevenido, você pode abusar da activity exportada para fazer o **usuário executar ações inesperadas**. Para mais informações sobre [**o que é Tapjacking — siga o link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Leia isto se quiser relembrar o que é um Content Provider.**](android-applications-basics.md#content-provider)\
Content providers são basicamente usados para **compartilhar dados**. Se um app tiver content providers disponíveis você pode ser capaz de **extrair dados sensíveis** deles. Também é interessante testar possíveis **SQL injections** e **Path Traversals**, pois eles podem ser vulneráveis.

[**Aprenda como explorar Content Providers com Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploring Services**

[**Leia isto se quiser relembrar o que é um Service.**](android-applications-basics.md#services)\
Lembre-se que as ações de um Service começam no método `onStartCommand`.

Um Service é basicamente algo que **pode receber dados**, **processá-los** e **retornar** (ou não) uma resposta. Então, se uma aplicação estiver exportando alguns services você deve **verificar** o **código** para entender o que ele está fazendo e **testá-lo** **dinamicamente** para extrair info confidencial, contornar medidas de autenticação...\
[**Aprenda como explorar Services com Drozer.**](drozer-tutorial/index.html#services)

### **Exploring Broadcast Receivers**

[**Leia isto se quiser relembrar o que é um Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Lembre-se que as ações de um Broadcast Receiver começam no método `onReceive`.

Um broadcast receiver ficará aguardando um tipo de mensagem. Dependendo de como o receiver lida com a mensagem, ele pode ser vulnerável.\
[**Aprenda como explorar Broadcast Receivers com Drozer.**](#exploiting-broadcast-receivers)

### **Exploring Schemes / Deep links**

Você pode procurar por deep links manualmente, usando ferramentas como MobSF ou scripts como [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Você pode **abrir** um **scheme** declarado usando **adb** ou um **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Observe que você pode **omitir o nome do pacote** e o dispositivo móvel chamará automaticamente o app que deve abrir esse link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código executado**

Para encontrar o **código que será executado no App**, vá até a activity chamada pelo deeplink e procure a função **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informação sensível**

Sempre que encontrar um deep link verifique que i**não está recebendo dados sensíveis (como senhas) via parâmetros de URL**, porque qualquer outra aplicação poderia **se passar pelo deep link e roubar esses dados!**

**Parâmetros no path**

Você **também deve verificar se algum deep link está usando um parâmetro dentro do path** da URL como: `https://api.example.com/v1/users/{username}` , nesse caso você pode forçar um path traversal acessando algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note que se você encontrar os endpoints corretos dentro da aplicação você pode ser capaz de causar um **Open Redirect** (se parte do path for usada como domain name), **account takeover** (se você conseguir modificar detalhes de usuários sem token CSRF e o endpoint vuln usar o método correto) e qualquer outra vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspeção da Camada de Transporte e Falhas de Verificação

- **Certificados nem sempre são verificados corretamente** por aplicações Android. É comum que essas aplicações ignorem avisos e aceitem certificados autoassinados ou, em alguns casos, revertam para conexões HTTP.
- **As negociações durante o handshake SSL/TLS às vezes são fracas**, empregando cipher suites inseguros. Essa vulnerabilidade torna a conexão suscetível a ataques man-in-the-middle (MITM), permitindo que atacantes decifrem os dados.
- **Leakage of private information** é um risco quando aplicações autenticam usando canais seguros mas então se comunicam por canais não seguros para outras transações. Essa abordagem não protege dados sensíveis, como session cookies ou detalhes do usuário, contra interceptação por entidades maliciosas.

#### Certificate Verification

Vamos focar em **certificate verification**. A integridade do certificado do servidor deve ser verificada para aumentar a segurança. Isso é crucial porque configurações TLS inseguras e a transmissão de dados sensíveis por canais não encriptados podem representar riscos significativos. Para passos detalhados sobre verificação de certificados de servidor e correção de vulnerabilidades, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) fornece orientação abrangente.

#### SSL Pinning

SSL Pinning é uma medida de segurança onde a aplicação verifica o certificado do servidor contra uma cópia conhecida armazenada dentro da própria aplicação. Esse método é essencial para prevenir ataques MITM. Recomenda-se fortemente implementar SSL Pinning em aplicações que lidam com informação sensível.

#### Traffic Inspection

Para inspecionar o tráfego HTTP, é necessário **instalar o certificado da ferramenta proxy** (por exemplo, Burp). Sem instalar esse certificado, o tráfego encriptado pode não ficar visível através do proxy. Para um guia sobre como instalar um CA customizado, [**clique aqui**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplicações targeting **API Level 24 and above** requerem modificações no Network Security Config para aceitar o certificado CA do proxy. Esse passo é crítico para inspecionar tráfego encriptado. Para instruções sobre como modificar o Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Se **Flutter** estiver sendo usado você precisa seguir as instruções em [**this page**](flutter.md). Isso ocorre porque apenas adicionar o certificado no store não funcionará já que o Flutter tem sua própria lista de CAs válidos.

#### Static detection of SSL/TLS pinning

Antes de tentar bypasses em runtime, mapeie rapidamente onde o pinning é aplicado no APK. A descoberta estática ajuda a planejar hooks/patches e a focar nos caminhos de código corretos.

Tool: SSLPinDetect
- Utilitário de análise estática open-source que decompila o APK para Smali (via apktool) e busca por padrões regex selecionados de implementações de SSL/TLS pinning.
- Reporta caminho exato do arquivo, número da linha e um snippet de código para cada match.
- Cobre frameworks comuns e caminhos de código customizados: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init com custom TrustManagers/KeyManagers, e pins em Network Security Config XML.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemplo de regras de padrão (JSON)
Use ou estenda assinaturas para detectar estilos proprietários/personalizados de pinning. Você pode carregar seu próprio JSON e escanear em escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notas e dicas
- Escaneamento rápido em apps grandes via multi-threading e memory-mapped I/O; regex pré-compilada reduz overhead/falsos positivos.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Alvos típicos de detecção para triagem a seguir:
- OkHttp: uso de CertificatePinner, setCertificatePinner, referências aos pacotes okhttp3/okhttp
- TrustManagers personalizados: javax.net.ssl.X509TrustManager, overrides de checkServerTrusted
- Contextos SSL personalizados: SSLContext.getInstance + SSLContext.init com managers personalizados
- Pins declarativos em res/xml network security config e referências no manifest
- Use os locais correspondentes para planejar Frida hooks, static patches, ou revisões de config antes de testes dinâmicos.



#### Contornando SSL Pinning

Quando SSL Pinning está implementado, contorná-lo se torna necessário para inspecionar o tráfego HTTPS. Vários métodos estão disponíveis para esse propósito:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). O maior ponto positivo dessa opção é que você não precisará de root para contornar o SSL Pinning, mas será necessário deletar o aplicativo e reinstalar o novo, e isso nem sempre funciona.
- You could use **Frida** (discussed below) to bypass this protection. Aqui está um guia para usar Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Procurando por Vulnerabilidades Web Comuns

É importante também procurar por vulnerabilidades web comuns dentro do aplicativo. Informações detalhadas sobre identificação e mitigação dessas vulnerabilidades estão além do escopo deste resumo, mas são amplamente abordadas em outros materiais.

### Frida

[Frida](https://www.frida.re) é um dynamic instrumentation toolkit para developers, reverse-engineers e pesquisadores de segurança.\
**Você pode acessar a aplicação em execução e hook methods em tempo de execução para alterar o comportamento, modificar valores, extrair valores, executar código diferente...**\
Se você quer pentest em aplicações Android, precisa saber usar o Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection é ótimo para automatizar o uso do Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Você pode encontrar alguns Awesome Frida scripts aqui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Tente contornar mecanismos anti-debugging / anti-frida carregando o Frida conforme indicado em [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (ferramenta [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump de Memória - Fridump**

Verifique se o aplicativo está armazenando informações sensíveis na memória que não deveria, como senhas ou mnemônicos.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) você pode dumpar a memória do app com:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Isso fará o dump da memória na pasta ./dump, e lá você pode usar grep com algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dados sensíveis no Keystore**

No Android o Keystore é o melhor lugar para armazenar dados sensíveis, entretanto, com privilégios suficientes ainda é **possível acessá-lo**. Como as aplicações tendem a armazenar aqui **dados sensíveis em clear text**, os pentests devem verificar isso como usuário root, pois alguém com acesso físico ao dispositivo poderia roubar esses dados.

Mesmo que um app armazene dados no keystore, os dados devem ser criptografados.

Para acessar os dados dentro do keystore você pode usar este Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando o seguinte script do Frida, pode ser possível **bypass fingerprint authentication** que aplicações Android executam para **proteger certas áreas sensíveis:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imagens em segundo plano**

Quando você coloca um aplicativo em segundo plano, o Android armazena um **instantâneo do aplicativo** de modo que, quando ele é restaurado para o primeiro plano, começa carregando a imagem antes do app, fazendo parecer que o aplicativo foi carregado mais rápido.

No entanto, se esse instantâneo contiver **informações sensíveis**, alguém com acesso a ele pode **roubar essas informações** (observe que é necessário root para acessá-lo).

Os instantâneos geralmente são armazenados em: **`/data/system_ce/0/snapshots`**

O Android fornece uma maneira de **impedir a captura de tela definindo o FLAG_SECURE** no parâmetro de layout. Ao usar essa flag, o conteúdo da janela é tratado como seguro, impedindo que apareça em capturas de tela ou que seja exibido em telas não seguras.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Esta ferramenta pode ajudar você a gerenciar diferentes ferramentas durante a análise dinâmica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Desenvolvedores frequentemente criam componentes proxy como activities, services, e broadcast receivers que lidam com esses Intents e os encaminham para métodos como `startActivity(...)` ou `sendBroadcast(...)`, o que pode ser arriscado.

O perigo está em permitir que atacantes acionem componentes do app não-exportados ou acessem content providers sensíveis ao redirecionar esses Intents. Um exemplo notável é o componente `WebView` convertendo URLs em objetos `Intent` via `Intent.parseUri(...)` e então executando-os, potencialmente levando a malicious Intent injections.

### Essential Takeaways

- **Intent Injection** é semelhante ao problema Open Redirect da web.
- Exploits envolvem passar objetos `Intent` como extras, que podem ser redirecionados para executar operações inseguras.
- Pode expor componentes não-exportados e content providers a atacantes.
- A conversão de URL para `Intent` do `WebView` pode facilitar ações não intencionais.

### Android Client Side Injections and others

Provavelmente você conhece esse tipo de vulnerabilidade da Web. Deve ter cuidado especial com essas vulnerabilidades em uma aplicação Android:

- **SQL Injection:** Ao lidar com consultas dinâmicas ou Content-Providers, assegure-se de usar consultas parametrizadas.
- **JavaScript Injection (XSS):** Verifique se o suporte a JavaScript e plugins está desativado para qualquer WebView (desativado por padrão). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** O acesso ao sistema de arquivos dos WebViews deve estar desativado (ativado por padrão) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Em vários casos, quando a aplicação Android finaliza a sessão o cookie não é revogado ou pode até ser salvo em disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Avaliação de vulnerabilidades da aplicação** usando uma interface web agradável. Você também pode realizar análise dinâmica (mas precisa preparar o ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Observe que o MobSF pode analisar **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Além disso, se você criar um arquivo **ZIP** com o código fonte de um app **Android** ou **IOS** (vá para a pasta raiz da aplicação, selecione tudo e crie um ZIPfile), ele também conseguirá analisá-lo.

MobSF também permite fazer **diff/Compare** de análises e integrar o **VirusTotal** (você precisará configurar sua API key em _MobSF/settings.py_ e habilitá-la: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Você também pode definir `VT_UPLOAD` para `False`, então o **hash** será **upload** em vez do arquivo.

### Assisted Dynamic analysis with MobSF

**MobSF** também pode ser muito útil para **dynamic analysis** em **Android**, mas nesse caso você precisará instalar o MobSF e o **genymotion** no seu host (uma VM ou Docker não funcionarão). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
O **MobSF dynamic analyser** pode:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Tudo isso é feito automaticamente, exceto as screenshots — você precisa apertar quando quiser uma screenshot ou pressionar "**Exported Activity Tester**" para obter screenshots de todas as atividades exportadas.
- Capturar **HTTPS traffic**
- Usar **Frida** para obter **informação em tempo de execução**

A partir de versões Android **> 5**, ele **iniciará automaticamente o Frida** e ajustará as configurações globais de **proxy** para **capturar** o tráfego. Ele só capturará o tráfego da aplicação testada.

**Frida**

Por padrão, também usará alguns Frida Scripts para **bypass SSL pinning**, **root detection** e **debugger detection** e para **monitorar APIs interessantes**.\
MobSF também pode **invocar exported activities**, tirar **screenshots** delas e **salvá-las** no relatório.

Para **start** o teste dinâmico pressione o botão verde: "**Start Instrumentation**". Pressione "**Frida Live Logs**" para ver os logs gerados pelos Frida scripts e "**Live API Monitor**" para ver todas as invocações aos métodos hookados, os argumentos passados e os valores retornados (isso aparecerá depois de pressionar "Start Instrumentation").\
MobSF também permite carregar seus próprios **Frida scripts** (para enviar os resultados dos seus Frida scripts para o MobSF use a função `send()`). Ele também possui **vários scripts pré-escritos** que você pode carregar (você pode adicionar mais em `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), basta **selecioná-los**, pressionar "**Load**" e pressionar "**Start Instrumentation**" (você poderá ver os logs desses scripts dentro de "**Frida Live Logs**").

![](<../../images/image (419).png>)

Além disso, você tem algumas funcionalidades auxiliares do Frida:

- **Enumerate Loaded Classes**: Vai imprimir todas as classes carregadas
- **Capture Strings**: Vai imprimir todas as strings capturadas enquanto você usa a aplicação (muito ruidoso)
- **Capture String Comparisons**: Pode ser muito útil. Vai **mostrar as 2 strings sendo comparadas** e se o resultado foi True ou False.
- **Enumerate Class Methods**: Coloque o nome da classe (como "java.io.File") e ele imprimirá todos os métodos da classe.
- **Search Class Pattern**: Buscar classes por padrão
- **Trace Class Methods**: **Trace** uma **classe inteira** (ver entradas e saídas de todos os métodos da classe). Lembre-se que por padrão o MobSF traça vários métodos interessantes da Android Api.

Uma vez que você tenha selecionado o módulo auxiliar que quer usar, você precisa pressionar "**Start Intrumentation**" e verá todas as saídas em "**Frida Live Logs**".

**Shell**

Mobsf também traz um shell com alguns comandos **adb**, **MobSF commands**, e comandos comuns de **shell** na parte inferior da página de dynamic analysis. Alguns comandos interessantes:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Ferramentas HTTP**

Quando o tráfego HTTP é capturado você pode ver uma visão feia do tráfego capturado no botão "**HTTP(S) Traffic**" na parte inferior ou uma visão mais agradável no botão verde "**Start HTTPTools**". A partir da segunda opção, você pode **enviar** as **captured requests** para **proxies** como Burp ou Owasp ZAP.\
Para isso, _power on Burp -->_ _turn off Intercept --> in MobSF HTTPTools select the request_ --> pressione "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Depois de terminar a análise dinâmica com MobSF você pode pressionar "**Start Web API Fuzzer**" para **fuzz HTTP requests** e procurar vulnerabilidades.

> [!TIP]
> Após realizar uma análise dinâmica com MobSF, as configurações de proxy podem ficar incorretas e você não conseguirá corrigi-las pela GUI. Você pode corrigir as configurações de proxy executando:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Análise Dinâmica Assistida com Inspeckage

Você pode obter a ferramenta em [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta ferramenta usa alguns **Hooks** para informar **o que está acontecendo na aplicação** enquanto você realiza uma **análise dinâmica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta é uma **ótima ferramenta para realizar análise estática com uma GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta ferramenta foi projetada para procurar diversas **vulnerabilidades relacionadas à segurança em aplicações Android**, tanto em **source code** quanto em **packaged APKs**. A ferramenta também é **capaz de criar um "Proof-of-Concept" APK implantável** e **comandos ADB**, para explorar algumas das vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Como com Drozer, não é necessário rootar o dispositivo de teste.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Exibe todos os arquivos extraídos para referência fácil
- Descompila automaticamente arquivos APK para os formatos Java e Smali
- Analisa AndroidManifest.xml em busca de common vulnerabilities e comportamento
- Análise estática do código-fonte para common vulnerabilities e comportamento
- Informações do dispositivo
- e mais
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER é uma aplicação de linha de comando que pode ser usada no Windows, MacOS X e Linux, que analisa arquivos _.apk_ em busca de vulnerabilidades. Faz isso descompactando APKs e aplicando uma série de regras para detectar essas vulnerabilidades.

Todas as regras estão centralizadas em um arquivo `rules.json`, e cada empresa ou testador pode criar suas próprias regras para analisar o que for necessário.

Baixe os binários mais recentes na [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn é uma ferramenta **multiplataforma** que auxilia desenvolvedores, bugbounty hunters e ethical hackers realizando [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) em aplicações móveis.

O conceito é que você arraste e solte o arquivo da sua aplicação móvel (um .apk ou .ipa file) na aplicação StaCoAn e ela irá gerar um relatório visual e portátil para você. Você pode ajustar as configurações e wordlists para obter uma experiência personalizada.

Baixe[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework é um sistema de análise de vulnerabilidades para Android que ajuda desenvolvedores ou hackers a encontrar potenciais vulnerabilidades de segurança em aplicações Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** é uma ferramenta cujo objetivo principal é detectar e alertar o usuário sobre potenciais comportamentos maliciosos desenvolvidos por uma aplicação Android.

A detecção é realizada por meio de **static analysis** do Dalvik bytecode da aplicação, representado como **Smali**, utilizando a biblioteca [`androguard`](https://github.com/androguard/androguard).

Esta ferramenta procura por **comportamentos comuns de aplicações "maliciosas"** como: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** é um framework de engenharia reversa e análise de aplicações móveis (**M**obile **A**pplication **R**everse engineering and **A**nalysis Framework). É uma ferramenta que reúne ferramentas comumente usadas para engenharia reversa e análise de aplicações mobile, para auxiliar nos testes de aplicações móveis contra as ameaças de segurança móvel do OWASP. Seu objetivo é tornar essa tarefa mais fácil e acessível para desenvolvedores de aplicações móveis e profissionais de segurança.

Ele é capaz de:

- Extrair código Java e Smali usando diferentes ferramentas
- Analisar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extrair informações privadas do APK usando regexps.
- Analisar o Manifest.
- Analisar domínios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Desofuscar APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Ofuscação/Desofuscação de código

Note que, dependendo do serviço e da configuração usada para ofuscar o código, segredos podem ou não ficar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** é uma ferramenta open source de linha de comando que reduz, otimiza e ofusca código Java. É capaz de otimizar bytecode, bem como detectar e remover instruções não utilizadas. ProGuard é software livre e é distribuído sob a GNU General Public License, version 2.

ProGuard é distribuído como parte do Android SDK e é executado ao construir a aplicação em modo release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Do guia) Na última vez que verificamos, o modo de operação do DexGuard era:

- carregar um recurso como um InputStream;
- passar o resultado para uma classe que herda de FilterInputStream para descriptografá-lo;
- fazer alguma obfuscação inútil para gastar alguns minutos do tempo de um reverser;
- passar o resultado descriptografado para um ZipInputStream para obter um arquivo DEX;
- finalmente carregar o DEX resultante como um Resource usando o método `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverte o processo de ofuscação realizado por ferramentas de ofuscação Android. Isso possibilita diversas análises de segurança, incluindo inspeção de código e predição de bibliotecas.**

Você pode enviar um APK ofuscado para a plataforma deles.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Esta é uma ferramenta LLM para encontrar potenciais vulnerabilidades de segurança em apps Android e desofuscar o código de apps Android. Usa a Gemini public API do Google.

### [Simplify](https://github.com/CalebFenton/simplify)

É um **desofuscador genérico para Android.** Simplify **executa virtualmente um app** para entender seu comportamento e então **tenta otimizar o código** para que ele se comporte de forma idêntica, porém mais fácil de entender por um humano. Cada tipo de otimização é simples e genérico, então não importa qual tipo específico de ofuscação foi usado.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD fornece informações sobre **como um APK foi criado**. Identifica muitos **compilers**, **packers**, **obfuscators**, e outras coisas estranhas. É o [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

[Leia este tutorial para aprender alguns truques sobre **como reverter ofuscação personalizada**](manual-deobfuscation.md)

## Laboratórios

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b é uma máquina virtual de segurança Android baseada em ubuntu-mate que inclui a coleção dos frameworks, tutoriais e labs mais recentes de diferentes especialistas e pesquisadores de segurança para engenharia reversa e análise de malware.

## Referências

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) É uma ótima lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Curso rápido de Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
