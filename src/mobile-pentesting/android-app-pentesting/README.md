# Pentesting delle Applicazioni Android

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

Si raccomanda vivamente di iniziare leggendo questa pagina per conoscere le **parti più importanti relative alla sicurezza Android e i componenti più pericolosi in un'applicazione Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Questo è lo strumento principale di cui hai bisogno per connetterti a un dispositivo Android (emulato o fisico).\
**ADB** permette di controllare i dispositivi sia via **USB** sia via **Network** da un computer. Questa utility consente la **copia** di file in entrambe le direzioni, l'**installazione** e la **disinstallazione** di app, l'**esecuzione** di comandi shell, il **backup** dei dati, la **lettura** dei log, tra le altre funzioni.

Dai un'occhiata alla seguente lista di [**ADB Commands**](adb-commands.md) per imparare come usare adb.

## Smali

A volte è utile **modificare il codice dell'applicazione** per accedere a **informazioni nascoste** (ad esempio password ben offuscate o flag). In tal caso, può essere interessante decompilare l'apk, modificare il codice e ricompilarlo.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Questo può essere molto utile come **alternativa per diversi test durante l'analisi dinamica** che verranno presentati. Quindi, **tieni sempre presente questa possibilità**.

## Altri trucchi interessanti

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Scarica APK**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Estrarre APK dal dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Unire tutti gli splits e base apks con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Casi di studio & Vulnerabilità


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Analisi statica

Prima di tutto, per analizzare un APK dovresti **dare un'occhiata al codice Java** usando un decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Ricerca di informazioni interessanti

Solo guardando le **strings** dell'APK puoi cercare **password**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** e qualsiasi cosa interessante... cerca anche eventuali backdoor di esecuzione codice o backdoor di autenticazione (credenziali admin hardcoded nell'app).

**Firebase**

Presta particolare attenzione alle **firebase URLs** e verifica se è mal configurato. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensione di base dell'applicazione - Manifest.xml, strings.xml

L'**esame dei file _Manifest.xml_ e **_strings.xml_** di un'applicazione può rivelare potenziali vulnerabilità di sicurezza**. Questi file possono essere accessi usando decompiler o rinominando l'estensione del file APK in .zip e poi scompattandolo.

Le **vulnerabilità** identificate dal **Manifest.xml** includono:

- **Debuggable Applications**: Le applicazioni impostate come debuggable (`debuggable="true"`) nel file _Manifest.xml_ presentano un rischio perché permettono connessioni che possono portare a exploitation. Per capire meglio come sfruttare applicazioni debuggable, fai riferimento a un tutorial su come trovare e sfruttare applicazioni debuggable su un device.
- **Backup Settings**: L'attributo `android:allowBackup="false"` dovrebbe essere esplicitamente impostato per applicazioni che trattano informazioni sensibili per impedire backup non autorizzati dei dati tramite adb, specialmente quando usb debugging è abilitato.
- **Network Security**: Le configurazioni personalizzate di network security (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ possono specificare dettagli di sicurezza come certificate pins e impostazioni del traffico HTTP. Un esempio è permettere traffico HTTP per domini specifici.
- **Exported Activities and Services**: Identificare attività e servizi esportati nel manifest può evidenziare componenti che potrebbero essere abusati. Un'analisi più approfondita durante i test dinamici può rivelare come sfruttare questi componenti.
- **Content Providers and FileProviders**: Content provider esposti potrebbero permettere accesso o modifica non autorizzata dei dati. Anche la configurazione dei FileProviders va esaminata con attenzione.
- **Broadcast Receivers and URL Schemes**: Questi componenti potrebbero essere sfruttati per l'exploitation, con particolare attenzione a come vengono gestiti gli URL schemes per vulnerabilità di input.
- **SDK Versions**: Gli attributi `minSdkVersion`, `targetSDKVersion`, e `maxSdkVersion` indicano le versioni Android supportate, sottolineando l'importanza di non supportare versioni Android obsolete e vulnerabili per motivi di sicurezza.

Dal file **strings.xml** si possono scoprire informazioni sensibili come API keys, custom schemas e altre note degli sviluppatori, evidenziando la necessità di una revisione attenta di queste risorse.

### Tapjacking

Tapjacking è un attacco in cui una **applicazione** **malintenzionata** viene lanciata e **si posiziona sopra un'applicazione vittima**. Una volta che oscura visivamente l'app vittima, la sua interfaccia utente è progettata in modo da ingannare l'utente a interagirvi, mentre inoltra l'interazione all'app vittima.\
In pratica, sta **accecando l'utente facendogli ignorare che sta effettivamente eseguendo azioni sull'app vittima**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Un'attività con il **`launchMode`** impostato su **`singleTask` senza alcun `taskAffinity`** definito è vulnerabile al task Hijacking. Ciò significa che un'**applicazione** può essere installata e, se lanciata prima dell'app reale, potrebbe **hijackare il task dell'app reale** (quindi l'utente interagirà con l'**applicazione malintenzionata** pensando di usare quella reale).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Memorizzazione dei dati insicura

Internal Storage

In Android, i file **memorizzati** in **archiviazione interna** sono **progettati** per essere **accessibili** esclusivamente dall'**app** che li ha **creati**. Questa misura di sicurezza è **applicata** dal sistema operativo Android ed è generalmente adeguata per le esigenze di sicurezza della maggior parte delle applicazioni. Tuttavia, gli sviluppatori a volte utilizzano modalità come `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` per **consentire** che i file siano **condivisi** tra diverse applicazioni. Queste modalità **non limitano l'accesso** a questi file da parte di altre applicazioni, incluse quelle potenzialmente malintenzionate.

1. **Static Analysis:**
- **Assicurati** che l'uso di `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` sia **esaminato con attenzione**. Queste modalità **possono potenzialmente esporre** i file ad **accessi non intenzionati o non autorizzati**.
2. **Dynamic Analysis:**
- **Verifica** i **permessi** impostati sui file creati dall'app. In particolare, **controlla** se qualche file è **impostato come leggibile o scrivibile worldwide**. Questo può costituire un rischio significativo per la sicurezza, poiché permetterebbe a **qualsiasi applicazione** installata sul dispositivo, indipendentemente dalla sua origine o intento, di **leggere o modificare** tali file.

External Storage

Quando si lavora con file su **archiviazione esterna**, come le SD Card, è necessario prendere alcune precauzioni:

1. **Accessibilità**:
- I file su archiviazione esterna sono **globalmente leggibili e scrivibili**. Questo significa che qualsiasi applicazione o utente può accedere a questi file.
2. **Problemi di sicurezza**:
- Data la facilità di accesso, è sconsigliato **memorizzare informazioni sensibili** su archiviazione esterna.
- L'archiviazione esterna può essere rimossa o accessibile da qualsiasi applicazione, rendendola meno sicura.
3. **Gestione dei dati dall'archiviazione esterna**:
- Esegui sempre **validazione dell'input** sui dati recuperati dall'archiviazione esterna. Questo è cruciale perché i dati provengono da una fonte non attendibile.
- È fortemente sconsigliato memorizzare eseguibili o class files su archiviazione esterna per il caricamento dinamico.
- Se la tua applicazione deve recuperare file eseguibili dall'archiviazione esterna, assicurati che questi file siano **signed e verificati crittograficamente** prima del caricamento dinamico. Questo passaggio è vitale per mantenere l'integrità di sicurezza della tua applicazione.

External storage può essere **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Dati sensibili memorizzati in chiaro**

- **Shared preferences**: Android permette a ogni applicazione di salvare facilmente file xml nel percorso `/data/data/<packagename>/shared_prefs/` e talvolta è possibile trovare informazioni sensibili in chiaro in quella cartella.
- **Databases**: Android permette a ogni applicazione di salvare facilmente database sqlite nel percorso `/data/data/<packagename>/databases/` e talvolta è possibile trovare informazioni sensibili in chiaro in quella cartella.

### Broken TLS

Accept All Certificates

Per qualche motivo a volte gli sviluppatori accettano tutti i certificati anche se, ad esempio, l'hostname non corrisponde, con righe di codice come la seguente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Un buon modo per testare questo è provare a catturare il traffico usando un proxy come Burp senza autorizzare la Burp CA all'interno del dispositivo. Inoltre, puoi generare con Burp un certificato per un hostname diverso e usarlo.

### Crittografia debole

**Processi di gestione delle chiavi inadeguati**

Alcuni sviluppatori salvano dati sensibili nello storage locale e li cifrano con una chiave hardcoded/predicibile nel codice. Questo non dovrebbe essere fatto poiché del reverse potrebbe permettere agli attacker di estrarre le informazioni riservate.

**Uso di algoritmi insicuri e/o deprecati**

Gli sviluppatori non dovrebbero usare **algoritmi deprecati** per effettuare controlli di **autorizzazione**, **memorizzare** o **inviare** dati. Alcuni di questi algoritmi sono: RC4, MD4, MD5, SHA1... Se vengono usati **hash** per memorizzare password per esempio, dovrebbero essere usati hash resistenti al brute-force con salt.

### Altri controlli

- È consigliato **offuscare l'APK** per rendere più difficile il lavoro di reverse engineering agli attacker.
- Se l'app è sensibile (come le app bancarie), dovrebbe eseguire i suoi **propri controlli per verificare se il mobile è rooted** e agire di conseguenza.
- Se l'app è sensibile (come le app bancarie), dovrebbe verificare se viene usato un **emulator**.
- Se l'app è sensibile (come le app bancarie), dovrebbe **verificare la propria integrità prima di eseguire** se è stata modificata.
- Usa [**APKiD**](https://github.com/rednaga/APKiD) per controllare quale compiler/packer/obfuscator è stato usato per costruire l'APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analisi Dinamica

> Prima di tutto, hai bisogno di un ambiente dove puoi installare l'applicazione e tutto l'ambiente (Burp CA cert, Drozer and Frida principalmente). Pertanto, un dispositivo rooted (emulato o no) è fortemente raccomandato.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> Quando crei un nuovo emulator su qualsiasi piattaforma ricorda che più grande è lo schermo, più lento sarà l'emulator. Quindi seleziona schermi piccoli se possibile.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Impostazioni**.
2. (Da Android 8.0) Seleziona **System**.
3. Seleziona **Informazioni sul telefono**.
4. Premi **Numero build** 7 volte.
5. Torna indietro e troverai le **Opzioni sviluppatore**.

> Una volta che hai installato l'applicazione, la prima cosa che dovresti fare è provarla e investigare cosa fa, come funziona e familiarizzare con essa.\
> Ti suggerisco di **eseguire questa analisi dinamica iniziale usando MobSF dynamic analysis + pidcat**, così saremo in grado di **imparare come funziona l'applicazione** mentre MobSF **cattura** molti **dati** **interessanti** che potrai rivedere in seguito.

### Unintended Data Leakage

**Logging**

Gli sviluppatori dovrebbero essere cauti nell'esporre **informazioni di debugging** pubblicamente, poiché possono portare a leak di dati sensibili. Gli strumenti [**pidcat**](https://github.com/JakeWharton/pidcat) and `adb logcat` sono raccomandati per monitorare i log dell'applicazione per identificare e proteggere informazioni sensibili. **Pidcat** è preferito per la sua facilità d'uso e leggibilità.

> [!WARNING]
> Nota che dalle **versioni successive ad Android 4.0**, **le applicazioni sono in grado di accedere solo ai propri log**. Quindi le applicazioni non possono accedere ai log di altre app.\
> Comunque, è sempre consigliato di **non loggare informazioni sensibili**.

**Copy/Paste Buffer Caching**

Il framework **clipboard-based** di Android abilita la funzionalità copia-incolla nelle app, ma rappresenta un rischio poiché **altre applicazioni** possono **accedere** alla clipboard, potenzialmente esponendo dati sensibili. È fondamentale **disabilitare copia/incolla** nelle sezioni sensibili di un'applicazione, come i dettagli della carta di credito, per prevenire leak di dati.

**Crash Logs**

Se un'applicazione **crasha** e **salva log**, questi log possono aiutare gli attacker, particolarmente quando l'applicazione non può essere reverse-engineerata. Per mitigare questo rischio, evita di loggare in caso di crash, e se i log devono essere trasmessi sulla rete, assicurati che siano inviati tramite un canale SSL per sicurezza.

Come pentester, **prova a dare un'occhiata a questi logs**.

**Analytics Data Sent To 3rd Parties**

Le applicazioni spesso integrano servizi come Google Adsense, che possono involontariamente **leak sensitive data** a causa di implementazioni improprie da parte degli sviluppatori. Per identificare potenziali data leaks, è consigliabile **intercettare il traffico dell'applicazione** e verificare se informazioni sensibili vengono inviate a servizi di terze parti.

### SQLite DBs

La maggior parte delle applicazioni userà **database SQLite interni** per salvare informazioni. Durante il pentest dai un'occhiata ai **database** creati, ai nomi delle **tabelle** e delle **colonne** e a tutti i **dati** salvati perché potresti trovare **informazioni sensibili** (che sarebbero una vulnerabilità).\
I database dovrebbero trovarsi in `/data/data/the.package.name/databases` come `/data/data/com.mwr.example.sieve/databases`

Se il database salva informazioni confidenziali ed è **encrypted** ma puoi **trovare** la **password** all'interno dell'applicazione è comunque una **vulnerabilità**.

Enumera le tabelle usando `.tables` ed enumera le colonne delle tabelle con `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** permette di **assumere il ruolo di un'app Android** e interagire con altre app. Può fare **qualsiasi cosa che un'app installata può fare**, come utilizzare il meccanismo di Inter-Process Communication (IPC) di Android e interagire con il sistema operativo sottostante. .\
Drozer è uno strumento utile per **sfruttare exported activities, exported services e Content Providers** come imparerai nelle sezioni seguenti.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ricorda anche che il codice di un activity inizia nel metodo **`onCreate`**.

**Authorisation bypass**

Quando un Activity è exported puoi invocare la sua schermata da un'app esterna. Pertanto, se un activity con **informazioni sensibili** è **exported** potresti **bypassare** i meccanismi di **autenticazione** **per accedervi.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Puoi anche avviare un activity esportato da adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF rileverà come malevolo l'uso di _**singleTask/singleInstance**_ come `android:launchMode` in un'attività, ma a causa di [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparentemente questo è pericoloso solo su versioni più vecchie (API versions < 21).

> [!TIP]
> Nota che un authorisation bypass non è sempre una vulnerabilità: dipende da come funziona il bypass e quali informazioni vengono esposte.

**Perdita di informazioni sensibili**

**Le Activities possono anche restituire risultati**. Se riesci a trovare un'attività esportata e non protetta che chiama il metodo **`setResult`** e **restituisce informazioni sensibili**, c'è una perdita di informazioni sensibili.

#### Tapjacking

Se il Tapjacking non è prevenuto, potresti abusare dell'attività esportata per far sì che **l'utente esegua azioni inaspettate**. Per maggiori informazioni su [**per saperne di più su Tapjacking segui il link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Leggi questo se vuoi rinfrescare cos'è un Content Provider.**](android-applications-basics.md#content-provider)\
I content providers sono fondamentalmente usati per **condividere dati**. Se un'app ha content providers disponibili potresti essere in grado di **estrarre dati sensibili** da essi. È anche interessante testare possibili **SQL injections** e **Path Traversals** in quanto potrebbero essere vulnerabili.

[**Scopri come sfruttare Content Providers con Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Leggi questo se vuoi rinfrescare cos'è un Service.**](android-applications-basics.md#services)\
Ricorda che le azioni di un Service iniziano nel metodo `onStartCommand`.

Un service è fondamentalmente qualcosa che **può ricevere dati**, **elaborarli** e **restituire** (o meno) una risposta. Quindi, se un'applicazione esporta dei services dovresti **controllare** il **codice** per capire cosa sta facendo e **testarlo** **dinamicamente** per estrarre info confidenziali, bypassare misure di autenticazione...\
[**Scopri come sfruttare Services con Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Leggi questo se vuoi rinfrescare cos'è un Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Ricorda che le azioni di un Broadcast Receiver iniziano nel metodo `onReceive`.

Un broadcast receiver attenderà un tipo di messaggio. A seconda di come il receiver gestisce il messaggio, potrebbe essere vulnerabile.\
[**Scopri come sfruttare i Broadcast Receivers con Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Puoi cercare deep links manualmente, usando tool come MobSF o script come [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puoi **aprire** uno **scheme** dichiarato usando **adb** o un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Nota che puoi **omettere il nome del pacchetto** e il dispositivo mobile chiamerà automaticamente l'app che dovrebbe aprire quel link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

Per trovare il **codice che verrà eseguito nell'App**, vai all'activity chiamata dal deeplink e cerca la funzione **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

Ogni volta che trovi un deep link verifica che **non riceva dati sensibili (come password) tramite parametri URL**, perché qualsiasi altra applicazione potrebbe **impersonare il deep link e rubare quei dati!**

**Parameters in path**

Devi verificare anche se un deep link utilizza un parametro all'interno del path dell'URL come: `https://api.example.com/v1/users/{username}` , in tal caso puoi forzare un path traversal accedendo a qualcosa come: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Nota che se trovi gli endpoint corretti all'interno dell'applicazione potresti essere in grado di causare una **Open Redirect** (se parte del path è usata come nome di dominio), **account takeover** (se puoi modificare i dettagli degli utenti senza CSRF token e il vuln endpoint utilizzava il metodo corretto) e qualsiasi altra vuln. Maggiori [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Un interessante report di bug bounty su link (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **I certificati non vengono sempre ispezionati correttamente** dalle applicazioni Android. È comune che queste applicazioni ignorino avvisi e accettino certificati self-signed o, in alcuni casi, tornino a usare connessioni HTTP.
- **Le negoziazioni durante lo SSL/TLS handshake sono talvolta deboli**, impiegando cipher suite insicuri. Questa vulnerabilità rende la connessione suscettibile ad attacchi MITM, permettendo agli attaccanti di decrittare i dati.
- **Leakage of private information** è un rischio quando le applicazioni si autenticano usando canali sicuri ma poi comunicano su canali non sicuri per altre transazioni. Questo approccio non protegge dati sensibili, come cookie di sessione o dettagli utente, dall'intercettazione da parte di entità malevole.

#### Certificate Verification

Ci concentreremo sulla **verifica dei certificati**. L'integrità del certificato del server deve essere verificata per aumentare la sicurezza. Questo è cruciale perché configurazioni TLS insicure e la trasmissione di dati sensibili su canali non cifrati possono rappresentare rischi significativi. Per passaggi dettagliati su come verificare i certificati del server e risolvere le vulnerabilità, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) fornisce una guida completa.

#### SSL Pinning

SSL Pinning è una misura di sicurezza in cui l'applicazione verifica il certificato del server rispetto a una copia nota memorizzata all'interno dell'app stessa. Questo metodo è essenziale per prevenire attacchi MITM. Implementare SSL Pinning è fortemente raccomandato per applicazioni che gestiscono informazioni sensibili.

#### Traffic Inspection

Per ispezionare il traffico HTTP, è necessario **installare il certificato dello strumento proxy** (es. Burp). Senza installare questo certificato, il traffico cifrato potrebbe non essere visibile tramite il proxy. Per una guida sull'installazione di una CA personalizzata, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Le applicazioni con target **API Level 24 e superiori** richiedono modifiche al Network Security Config per accettare il certificato CA del proxy. Questo passaggio è critico per ispezionare il traffico cifrato. Per istruzioni su come modificare il Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Se viene usato **Flutter** devi seguire le istruzioni in [**this page**](flutter.md). Questo perché, semplicemente aggiungendo il certificato nello store non funzionerà, dato che Flutter ha la propria lista di CA valide.

#### Static detection of SSL/TLS pinning

Prima di tentare bypass a runtime, mappa rapidamente dove il pinning è applicato nell'APK. La scoperta statica ti aiuta a pianificare hook/patch e a concentrarti sui percorsi di codice giusti.

Tool: SSLPinDetect
- Open-source static-analysis utility che decompila l'APK in Smali (via apktool) e scansiona pattern regex curati delle implementazioni di SSL/TLS pinning.
- Riporta il percorso file esatto, il numero di riga e uno snippet di codice per ogni match.
- Copre framework comuni e percorsi di codice custom: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init con custom TrustManagers/KeyManagers, e Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Esempio di regole pattern (JSON)
Usa o estendi signatures per rilevare stili proprietari/custom di pinning. Puoi caricare il tuo JSON e scansionare su larga scala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Note e suggerimenti
- Scansione rapida su grandi app tramite multi-threading e memory-mapped I/O; regex pre-compilata riduce overhead/falsi positivi.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Tipici target di rilevamento da esaminare subito:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Usa le posizioni trovate per pianificare Frida hooks, patch statiche o revisioni di config prima dei test dinamici.



#### Bypassare SSL Pinning

Quando SSL Pinning è implementato, diventa necessario bypassarlo per ispezionare il traffico HTTPS. Sono disponibili varie metodologie per questo scopo:

- Modificare automaticamente l'apk per bypassare SSLPinning con [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Il vantaggio principale di questa opzione è che non avrai bisogno dei permessi di root per bypassare SSL Pinning, ma dovrai disinstallare l'applicazione e reinstallare quella modificata, e questo non funzionerà sempre.
- Puoi usare **Frida** (discussa sotto) per bypassare questa protezione. Qui trovi una guida per usare Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Puoi anche provare a bypassare automaticamente SSL Pinning usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Puoi anche provare a bypassare automaticamente SSL Pinning usando **MobSF dynamic analysis** (spiegato sotto)
- Se pensi ancora che ci sia traffico che non stai catturando, puoi provare a inoltrare il traffico a Burp usando iptables. Leggi questo blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Ricerca di vulnerabilità web comuni

È importante cercare anche vulnerabilità web comuni all'interno dell'applicazione. Informazioni dettagliate su come identificare e mitigare queste vulnerabilità esulano dal riassunto qui presente ma sono trattate estensivamente altrove.

### Frida

[Frida](https://www.frida.re) è un toolkit di instrumentazione dinamica per sviluppatori, reverse-engineer e ricercatori di sicurezza.\
**Puoi accedere all'applicazione in esecuzione e hookare metodi a run time per cambiare il comportamento, modificare valori, estrarre valori, eseguire codice differente...**\
Se vuoi fare pentesting di applicazioni Android devi sapere come usare Frida.

- Impara a usare Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Alcune "GUI" per operazioni con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puoi trovare alcuni Awesome Frida scripts qui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Prova a bypassare meccanismi anti-debugging / anti-frida caricando Frida come indicato in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Verifica se l'applicazione sta memorizzando informazioni sensibili nella memoria che non dovrebbe conservare, come password o mnemoniche.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Questo eseguirà il dump della memoria nella cartella ./dump, e lì puoi usare grep con qualcosa come:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dati sensibili nel Keystore**

Su Android il Keystore è il posto migliore per conservare dati sensibili, tuttavia, con privilegi sufficienti è ancora **possibile accedervi**. Poiché le applicazioni tendono a memorizzare qui **dati sensibili in chiaro**, i pentests dovrebbero controllarlo, dato che un root user o qualcuno con accesso fisico al dispositivo potrebbe riuscire a rubare questi dati.

Anche se un'app memorizzasse dati nel keystore, i dati dovrebbero essere cifrati.

Per accedere ai dati all'interno del keystore puoi usare questo Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando il seguente Frida script potrebbe essere possibile **bypass fingerprint authentication** che le applicazioni Android potrebbero eseguire per **proteggere alcune aree sensibili:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Immagini in background**

Quando metti un'applicazione in background, Android salva un'**istantanea dell'applicazione** così quando viene riportata in primo piano inizia a caricare l'immagine prima dell'app, dando l'impressione che l'app sia stata avviata più velocemente.

Tuttavia, se questa istantanea contiene **informazioni sensibili**, qualcuno con accesso all'istantanea potrebbe **rubare tali dati** (nota che è necessario avere root per accedervi).

Le istantanee sono solitamente memorizzate in: **`/data/system_ce/0/snapshots`**

Android fornisce un modo per **impedire la cattura di screenshot impostando il parametro di layout FLAG_SECURE**. Usando questo flag, il contenuto della finestra viene trattato come sicuro, impedendo che compaia negli screenshot o che sia visualizzato su display non sicuri.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Questo strumento può aiutarti a gestire diversi tool durante l'analisi dinamica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Gli sviluppatori spesso creano componenti proxy come activities, services e broadcast receivers che gestiscono questi Intent e li passano a metodi come `startActivity(...)` o `sendBroadcast(...)`, il che può essere rischioso.

Il pericolo consiste nel permettere ad un attacker di attivare componenti non-exported dell'app o di accedere a content providers sensibili deviano questi Intent. Un esempio notevole è il componente `WebView` che converte URL in oggetti `Intent` tramite `Intent.parseUri(...)` e poi li esegue, potenzialmente portando a malicious Intent injections.

### Essential Takeaways

- **Intent Injection** è simile all'Open Redirect del web.
- Gli exploit consistono nel passare oggetti `Intent` come extras, che possono essere reindirizzati per eseguire operazioni non sicure.
- Può esporre componenti non-exported e content providers agli attacker.
- La conversione da URL a `Intent` di `WebView` può facilitare azioni non intenzionali.

### Android Client Side Injections and others

Probabilmente conosci questo tipo di vulnerabilità dal Web. Devi prestare particolare attenzione a queste vulnerabilità in un'app Android:

- **SQL Injection:** Quando si gestiscono query dinamiche o Content-Providers assicurati di usare query parametrizzate.
- **JavaScript Injection (XSS):** Verifica che il supporto a JavaScript e Plugin sia disabilitato per qualsiasi WebView (disabilitato di default). [Maggiori informazioni qui](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Le WebView dovrebbero avere l'accesso al file system disabilitato (abilitato di default) - `(webview.getSettings().setAllowFileAccess(false);)`. [Maggiori informazioni qui](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In molti casi, quando l'app Android termina la sessione il cookie non viene revocato o può essere addirittura salvato su disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Valutazione delle vulnerabilità dell'applicazione** tramite una comoda interfaccia web. È possibile anche eseguire analisi dinamiche (ma è necessario preparare l'ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF consente inoltre di **diff/Compare** le analisi e di integrare **VirusTotal** (dovrai impostare la tua API key in _MobSF/settings.py_ e abilitarla: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Puoi anche impostare `VT_UPLOAD` su `False`; in tal caso verrà **upload** solo l'**hash** invece del file.

### Assisted Dynamic analysis with MobSF

MobSF può anche essere molto utile per la dynamic analysis su **Android**, ma in questo caso dovrai installare MobSF e **genymotion** sul tuo host (una VM o Docker non funzionerà). _Nota: Devi **start first a VM in genymotion** e **then MobSF**._\
Il MobSF dynamic analyser può:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Tutto questo viene fatto automaticamente eccetto per gli screenshot: devi premere quando vuoi uno screenshot oppure premere "**Exported Activity Tester**" per ottenere screenshot di tutte le attività esportate.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

Di default, utilizzerà anche alcuni Frida Scripts per **bypass SSL pinning**, **root detection** e **debugger detection** e per **monitor** API interessanti.\
MobSF può anche **invoke exported activities**, catturare **screenshots** di esse e **save**le per il report.

Per **start** il dynamic testing premi il bottone verde: "**Start Instrumentation**". Premi "**Frida Live Logs**" per vedere i log generati dagli script Frida e "**Live API Monitor**" per vedere tutte le invocazioni ai metodi hooked, gli argomenti passati e i valori restituiti (questo apparirà dopo aver premuto "Start Instrumentation").\
MobSF permette anche di caricare i tuoi **Frida scripts** (per inviare i risultati dei tuoi Frida scripts a MobSF usa la funzione `send()`). Include anche **diversi script pre-written** che puoi caricare (puoi aggiungerne altri in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), selezionali, premi "**Load**" e poi "**Start Instrumentation**" (potrai vedere i log di quegli script dentro "**Frida Live Logs**").

![](<../../images/image (419).png>)

Inoltre, hai alcune funzionalità ausiliarie di Frida:

- **Enumerate Loaded Classes**: mostrerà tutte le classi caricate
- **Capture Strings**: mostrerà tutte le stringhe catturate durante l'uso dell'applicazione (molto rumoroso)
- **Capture String Comparisons**: può essere molto utile. Mostrerà le 2 stringhe confrontate e se il risultato è True o False.
- **Enumerate Class Methods**: inserisci il nome della classe (per esempio "java.io.File") e mostrerà tutti i metodi della classe.
- **Search Class Pattern**: cerca classi per pattern
- **Trace Class Methods**: traccia un'intera classe (vedi input e output di tutti i metodi della classe). Ricorda che per default MobSF traccia diversi metodi Android API interessanti.

Una volta selezionato il modulo ausiliario che vuoi usare devi premere "**Start Instrumentation**" e vedrai tutti gli output in "**Frida Live Logs**".

**Shell**

MobSF offre anche una shell con alcuni comandi **adb**, comandi **MobSF**, e comandi **shell** comuni in fondo alla pagina di dynamic analysis. Alcuni comandi interessanti:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Strumenti HTTP**

Quando il traffico http viene catturato puoi vedere una vista grezza del traffico catturato nel pulsante "**HTTP(S) Traffic**" in basso oppure una vista più pulita nel pulsante verde "**Start HTTPTools**". Dalla seconda opzione, puoi **inviare** le **captured requests** a **proxies** come Burp o Owasp ZAP.\
Per farlo, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> premi "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una volta terminata la dynamic analysis con MobSF puoi premere "**Start Web API Fuzzer**" per **fuzz http requests** e cercare vulnerabilità.

> [!TIP]
> Dopo aver eseguito una dynamic analysis con MobSF le impostazioni del proxy potrebbero essere malconfigurate e potresti non riuscire a sistemarle dalla GUI. Puoi correggere le impostazioni del proxy eseguendo:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Analisi Dynamic Analysis assistita con Inspeckage

Puoi ottenere lo strumento da [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Questo tool utilizza alcuni **Hooks** per farti sapere **cosa succede nell'applicazione** mentre esegui una **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Questo è un **ottimo tool per eseguire static analysis con una GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Questo tool è progettato per cercare diverse **vulnerabilità relative alla sicurezza delle applicazioni Android**, sia nel **source code** sia negli **packaged APKs**. Lo strumento è inoltre **capace di creare un "Proof-of-Concept" deployable APK** e **ADB commands**, per sfruttare alcune delle vulnerabilità trovate (Exposed activities, intents, tapjacking...). Come con Drozer, non è necessario rootare il dispositivo di test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Visualizza tutti i file estratti per riferimento rapido
- Decompila automaticamente i file APK in formato Java e Smali
- Analizza AndroidManifest.xml per vulnerabilità e comportamenti comuni
- Analisi statica del codice sorgente per vulnerabilità e comportamenti comuni
- Informazioni sul dispositivo
- e altro
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER è un'applicazione da riga di comando utilizzabile su Windows, MacOS X e Linux, che analizza file _.apk_ alla ricerca di vulnerabilità. Lo fa decomprimendo gli APK e applicando una serie di regole per rilevare tali vulnerabilità.

Tutte le regole sono contenute in un file `rules.json` e ogni azienda o tester può creare regole proprie per analizzare ciò di cui ha bisogno.

Scarica i binari più recenti dalla [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn è uno strumento **crossplatform** che aiuta sviluppatori, bugbounty hunters e ethical hackers a eseguire [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) su applicazioni mobili.

Il concetto è che trascini e rilasci il file della tua applicazione mobile (un file .apk o .ipa) sull'applicazione StaCoAn e questa genererà per te un report visivo e portabile. Puoi modificare le impostazioni e le wordlists per ottenere un'esperienza personalizzata.

Scarica[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework è un sistema di analisi delle vulnerabilità Android che aiuta sviluppatori o hackers a individuare potenziali vulnerabilità di sicurezza nelle applicazioni Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** è uno strumento il cui obiettivo principale è rilevare e avvisare l'utente su potenziali comportamenti dannosi sviluppati da un'applicazione Android.

La rilevazione viene eseguita tramite la **static analysis** del Dalvik bytecode dell'applicazione, rappresentato come **Smali**, usando la libreria [`androguard`](https://github.com/androguard/androguard).

Questo strumento cerca i **comportamenti comuni delle applicazioni "maligne"** come: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** è un **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. È uno strumento che mette insieme tool comunemente usati per il reverse engineering e l'analisi di mobile application, per assistere nei test delle app mobili contro le minacce OWASP mobile security. Il suo obiettivo è rendere questo compito più semplice e accessibile agli sviluppatori di applicazioni mobili e ai professionisti della sicurezza.

È in grado di:

- Estrarre codice Java e Smali usando diversi tool
- Analizzare APK usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Estrarre informazioni private dall'APK usando regexp.
- Analizzare il Manifest.
- Analizzare i domini trovati usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) e [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile per rilevare malware: [https://koodous.com/](https://koodous.com)

## Offuscamento/Deoffuscamento del codice

Tieni presente che, a seconda del servizio e della configurazione che usi per offuscare il codice, i segreti potrebbero essere offuscati oppure no.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** è uno strumento open source da riga di comando che riduce, ottimizza e offusca codice Java. È in grado di ottimizzare il bytecode così come di rilevare e rimuovere istruzioni non usate. ProGuard è software libero e viene distribuito sotto la GNU General Public License, versione 2.

ProGuard viene distribuito come parte dell'Android SDK ed esegue quando si compila l'applicazione in modalità release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Trova una guida passo-passo per deobfuscate l'apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard inverte il processo di offuscamento eseguito dagli strumenti di offuscamento Android. Questo abilita numerose analisi di sicurezza, inclusa l'ispezione del codice e la predizione delle librerie.**

Puoi caricare un APK offuscato sulla loro piattaforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

È un **deobfuscator Android generico.** Simplify **esegue virtualmente un'app** per comprenderne il comportamento e poi **cerca di ottimizzare il codice** in modo che si comporti in modo identico ma sia più facile da capire per un umano. Ogni tipo di ottimizzazione è semplice e generica, quindi non importa quale specifico tipo di offuscamento sia stato usato.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD ti dà informazioni su **come un APK è stato creato**. Identifica molti **compilatori**, **packers**, **obfuscators** e altre cose strane. È [_PEiD_](https://www.aldeid.com/wiki/PEiD) per Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b è una virtual machine per la sicurezza Android basata su ubuntu-mate che include una collezione dei più recenti framework, tutorial e lab provenienti da diversi esperti e ricercatori per reverse engineering e analisi di malware.

## Riferimenti

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) It is a great list of resources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Da provare

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
