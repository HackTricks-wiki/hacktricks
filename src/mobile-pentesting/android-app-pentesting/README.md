# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

이 페이지를 먼저 읽어 Android 보안과 Android 애플리케이션에서 가장 위험한 구성 요소와 관련된 **가장 중요한 부분들**을 아는 것을 강력히 권장합니다:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

이것은 에뮬레이션된 장치나 물리적 장치에 연결하는 데 필요한 주요 도구입니다.\
**ADB**를 사용하면 컴퓨터에서 **USB** 또는 **Network**를 통해 장치를 제어할 수 있습니다. 이 유틸리티는 파일 양방향 **복사**, 앱의 **설치** 및 **제거**, 셸 명령의 **실행**, 데이터의 **백업**, 로그의 **읽기** 등 다양한 기능을 제공합니다.

다음 [**ADB Commands**](adb-commands.md) 목록을 확인하여 adb 사용법을 배우세요.

## Smali

때때로 **애플리케이션 코드를 수정**하여 **숨겨진 정보**(예: 잘 난독화된 비밀번호나 플래그)에 접근하는 것이 유용할 수 있습니다. 이럴 때 apk를 디컴파일하고 코드를 수정한 뒤 다시 컴파일하는 것이 흥미로운 방법일 수 있습니다.\
[**이 튜토리얼에서** 새 기능을 위해 **APK를 디컴파일하고 Smali 코드를 수정한 뒤 APK를 리컴파일하는 방법을 배울 수 있습니다**](smali-changes.md). 이는 이후 제시될 다이나믹 분석 중 여러 테스트에 대한 **대안**으로 매우 유용할 수 있습니다. 그러므로 **항상 이 가능성을 염두에 두세요**.

## Other interesting tricks

- [Play Store에서 위치 스푸핑](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Insecure In-App Update Mechanisms 악용](insecure-in-app-update-rce.md)
- [접근성 서비스 악용 (Android RAT)](accessibility-services-abuse.md)
- **APK 다운로드**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 모든 splits 및 base apks를 [APKEditor](https://github.com/REAndroid/APKEditor)로 병합:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## 사례 연구 및 취약점


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## 정적 분석

무엇보다도, APK를 분석할 때는 decompiler를 사용하여 **Java 코드를 살펴봐야 합니다**.\
자세한 decompiler 정보는 [**여기**](apk-decompilers.md)를 참조하세요.

### 흥미로운 정보 찾기

APK의 **strings**만 살펴봐도 **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** 등 흥미로운 항목을 찾을 수 있습니다... 코드 실행을 위한 **backdoors**나 인증 backdoors(앱에 하드코딩된 admin 자격증명)도 확인하세요.

**Firebase**

**firebase URLs**에 특히 주의하고 잘못 구성되었는지 확인하세요. 자세한 내용과 Firebase를 악용하는 방법은 [여기](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)를 참조하세요.

### 기본적인 애플리케이션 이해 - Manifest.xml, strings.xml

애플리케이션의 _Manifest.xml_ 및 **_strings.xml_** 파일을 검토하면 잠재적인 보안 취약점을 발견할 수 있습니다. 이 파일들은 decompiler로 접근하거나 APK 파일 확장자를 .zip으로 변경한 뒤 압축을 풀어 확인할 수 있습니다.

Manifest.xml에서 확인되는 **취약점**에는 다음이 포함됩니다:

- **Debuggable Applications**: _Manifest.xml_ 파일에서 `debuggable="true"`로 설정된 애플리케이션은 연결을 허용해 악용될 가능성이 있으므로 위험합니다. 디버깅 가능 애플리케이션을 디바이스에서 찾고 악용하는 방법에 대한 튜토리얼을 참조하세요.
- **Backup Settings**: 민감한 정보를 다루는 애플리케이션의 경우 `android:allowBackup="false"` 속성을 명시적으로 설정하여 usb debugging이 활성화된 경우 adb를 통한 무단 데이터 백업을 방지해야 합니다.
- **Network Security**: _res/xml/_의 커스텀 네트워크 보안 구성(`android:networkSecurityConfig="@xml/network_security_config"`)은 certificate pinning이나 HTTP 트래픽 허용 여부 같은 보안 세부사항을 지정할 수 있습니다. 예로 특정 도메인에 대해 HTTP 트래픽을 허용하는 설정이 있습니다.
- **Exported Activities and Services**: Manifest에서 exported된 activities와 services를 식별하면 오용될 수 있는 컴포넌트를 찾아낼 수 있습니다. 동적 테스트 중 추가 분석을 통해 이러한 컴포넌트를 어떻게 악용할 수 있는지 파악하세요.
- **Content Providers and FileProviders**: 노출된 content provider는 무단 접근이나 데이터 변경을 허용할 수 있습니다. FileProvider의 구성도 면밀히 검토해야 합니다.
- **Broadcast Receivers and URL Schemes**: 이들 컴포넌트는 익스플로잇에 이용될 수 있으며, 특히 URL schemes가 입력 취약성에 대해 어떻게 처리되는지 주의해야 합니다.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, `maxSdkVersion` 속성은 지원되는 Android 버전을 나타내며, 오래된 취약한 Android 버전을 지원하지 않도록 하는 것이 중요함을 보여줍니다.

**strings.xml** 파일에서는 API keys, custom schemas, 기타 개발자 메모 등 민감한 정보를 발견할 수 있으므로 이러한 리소스를 신중히 검토해야 합니다.

### Tapjacking

Tapjacking은 **malicious** **application**이 실행되어 **victim application 위에 위치**하는 공격입니다. 악성 앱이 피해자 앱을 시각적으로 가리면, UI는 사용자가 상호작용하도록 유도하도록 설계되고 그 상호작용을 피해자 앱으로 전달합니다.\
결과적으로 사용자는 자신이 실제로는 피해자 앱에서 작업하고 있다는 사실을 **알지 못하게 됩니다**.

자세한 내용은 다음을 참조하세요:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode`가 **`singleTask`**로 설정되어 있고 `taskAffinity`가 정의되어 있지 않은 **activity**는 Task Hijacking에 취약합니다. 이는 악성 **application**을 설치하고 실제 앱보다 먼저 실행하면 **실제 앱의 task를 hijack**할 수 있다는 뜻이며(따라서 사용자는 실제 앱을 사용한다고 생각하면서 **악성 앱과 상호작용**하게 됩니다).

자세한 내용은:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android에서 내부 저장소에 **저장된** 파일은 해당 파일을 **생성한 앱만 접근하도록 설계**되어 있습니다. 이 보안 조치는 Android OS에 의해 강제되며 대부분의 애플리케이션에 대해 충분합니다. 다만 개발자가 `MODE_WORLD_READABLE` 또는 `MODE_WORLD_WRITABLE`과 같은 모드를 사용하여 서로 다른 애플리케이션 간 파일 공유를 허용하는 경우가 있습니다. 이러한 모드는 잠재적으로 악성 앱을 포함한 다른 애플리케이션에 의해 파일 접근을 **제한하지 않습니다**.

1. **Static Analysis:**
- `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE` 사용 여부를 **주의 깊게 검토**하세요. 이러한 모드는 파일이 **의도치 않거나 무단으로 노출**될 수 있습니다.
2. **Dynamic Analysis:**
- 앱이 생성한 파일에 설정된 **권한**을 **확인**하세요. 특히 어떤 파일이 전 세계적으로 읽기 또는 쓰기 가능하게 설정되어 있는지 확인해야 합니다. 이는 어떤 애플리케이션이든(출처나 의도와 관계없이) 해당 파일을 **읽거나 수정**할 수 있게 하므로 심각한 보안 위험을 초래할 수 있습니다.

**External Storage**

SD 카드와 같은 **external storage**의 파일을 다룰 때는 다음을 유의하세요:

1. **접근성**:
- 외부 저장소의 파일은 **전역적으로 읽기 및 쓰기 가능**합니다. 즉, 어떤 애플리케이션이나 사용자도 접근할 수 있습니다.
2. **보안 문제**:
- 접근이 쉬우므로 민감한 정보를 외부 저장소에 저장하지 않는 것이 좋습니다.
- 외부 저장소는 제거될 수 있고 어떤 애플리케이션에서도 접근할 수 있어 보안성이 낮습니다.
3. **외부 저장소의 데이터 처리**:
- 외부 저장소에서 가져온 데이터에 대해 항상 **입력 검증(input validation)**을 수행하세요. 외부 저장소의 데이터는 신뢰할 수 없는 소스에서 왔기 때문에 중요합니다.
- 외부 저장소에 executables나 class 파일을 저장해 동적으로 로드하는 것은 강력히 권장되지 않습니다.
- 애플리케이션이 외부 저장소에서 실행 파일을 가져와야 하는 경우, 동적으로 로드하기 전에 해당 파일들이 **서명되고 암호학적으로 검증**되었는지 확인하세요. 이는 애플리케이션의 보안 무결성을 유지하는 데 필수적입니다.

외부 저장소는 /storage/emulated/0 , /sdcard , /mnt/sdcard 에서 접근할 수 있습니다.

> [!TIP]
> Android 4.4(**API 17**)부터 SD 카드에는 앱별 디렉터리 구조가 있어 **앱이 자기 전용 디렉터리로만 접근을 제한**합니다. 이는 악성 애플리케이션이 다른 앱의 파일을 읽거나 쓰는 접근을 얻는 것을 방지합니다.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android는 각 애플리케이션이 `/data/data/<packagename>/shared_prefs/` 경로에 xml 파일을 쉽게 저장하도록 허용하며, 이 폴더에서 민감한 정보가 평문으로 저장되어 있는 경우가 종종 있습니다.
- **Databases**: Android는 각 애플리케이션이 `/data/data/<packagename>/databases/` 경로에 sqlite 데이터베이스를 쉽게 저장하도록 허용하며, 이 폴더에서 민감한 정보가 평문으로 저장되어 있는 경우가 종종 있습니다.

### Broken TLS

**Accept All Certificates**

어떤 이유로 개발자들이 호스트명이 일치하지 않아도 모든 인증서를 수락하는 경우가 있습니다. 예를 들어 다음과 같은 코드 라인처럼:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
좋은 방법은 기기 내부에서 Burp CA를 신뢰(허가)하지 않은 상태로 Burp 같은 프록시를 사용해 트래픽을 캡처해보는 것이다. 또한 Burp로 다른 호스트명에 대한 인증서를 생성해 사용해볼 수도 있다.

### 취약한 암호화

**부적절한 키 관리 프로세스**

일부 개발자는 민감한 데이터를 로컬 스토리지에 저장하고 코드에 하드코딩되었거나 예측 가능한 키로 암호화한다. 리버싱을 통해 공격자가 기밀 정보를 추출할 수 있으므로 이렇게 해서는 안 된다.

**안전하지 않거나/또는 폐기된 알고리즘의 사용**

개발자는 권한 부여 **검사**(authorization **checks**), 데이터 **저장** 또는 **전송**에 **deprecated algorithms**를 사용해서는 안 된다. 이러한 알고리즘의 예로는 RC4, MD4, MD5, SHA1 등이 있다. 예를 들어 비밀번호를 저장하기 위해 **hashes**를 사용한다면, 솔트와 함께 브루트포스에 **강한** 해시 알고리즘을 사용해야 한다.

### 기타 확인사항

- 역공학 작업을 어렵게 하기 위해 **obfuscate the APK** 하는 것이 권장된다.
- 앱이 민감한 경우(예: 은행 앱)에는 모바일이 **rooted** 되었는지 확인하는 **자체 검사(own checks to see if the mobile is rooted)**를 수행하고 그에 맞게 동작해야 한다.
- 앱이 민감한 경우(예: 은행 앱)에는 **emulator** 사용 여부를 확인해야 한다.
- 앱이 민감한 경우(예: 은행 앱)에는 실행 전에 **자기 무결성(self integrity)** 을 **체크**하여 수정 여부를 확인해야 한다.
- 어떤 compiler/packer/obfuscator로 APK가 빌드되었는지 확인하려면 [**APKiD**](https://github.com/rednaga/APKiD)를 사용하라

### React Native Application

React 애플리케이션의 javascript 코드를 쉽게 접근하는 방법을 배우려면 다음 페이지를 읽어라:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Xamarin 애플리케이션의 C# 코드에 쉽게 접근하는 방법을 배우려면 다음 페이지를 읽어라:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

이 [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)에 따르면 superpacked는 애플리케이션의 내용을 하나의 파일로 압축하는 Meta 알고리즘이다. 블로그는 이런 종류의 앱을 압축 해제하는 앱을 만드는 가능성에 대해 이야기한다... 그리고 더 빠른 방법으로는 **애플리케이션을 실행하고 파일시스템에서 압축 해제된 파일을 수집하는 것**이 있다.

### Automated Static Code Analysis

도구 [**mariana-trench**](https://github.com/facebook/mariana-trench)는 애플리케이션의 **코드**를 **스캔**하여 **취약점(vulnerabilities)** 을 찾을 수 있다. 이 도구는 **known sources**(사용자가 제어하는 **입력(input)** 이 위치하는 **지점**을 도구에 알려주는 것), **sinks**(악의적인 사용자 입력이 피해를 줄 수 있는 **위험한 지점**) 및 **rules**의 집합을 포함한다. 이러한 규칙들은 취약점을 나타내는 **sources-sinks 조합**을 지정한다.

이 지식을 바탕으로 **mariana-trench**는 코드를 검토하고 잠재적인 취약점을 찾아낼 것이다.

### Secrets leaked

애플리케이션 내부에 API 키, 비밀번호, 숨겨진 URL, 서브도메인 등과 같은 secrets가 포함되어 있을 수 있으며 이를 발견할 수 있다. 다음과 같은 도구를 사용할 수 있다: [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> 먼저, 애플리케이션과 환경(Burp CA cert, Drozer 및 Frida 등)을 설치할 수 있는 환경이 필요하다. 따라서 루팅된 기기(에뮬레이터든 실제든)가 강력히 추천된다.

### Online Dynamic analysis

[https://appetize.io/](https://appetize.io/)에서 **무료 계정**을 만들 수 있다. 이 플랫폼은 APK를 **업로드**하고 **실행**할 수 있게 해 주므로 APK가 어떻게 동작하는지 확인하는 데 유용하다.

웹에서 애플리케이션의 로그를 **볼 수 있고** adb로 연결할 수도 있다.

![](<../../images/image (831).png>)

ADB 연결 덕분에 에뮬레이터 내부에서 **Drozer**와 **Frida**를 사용할 수 있다.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (x86 및 arm 디바이스를 생성할 수 있으며, [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**에 따르면 최신 x86** 버전은 느린 arm 에뮬레이터가 없어도 **ARM 라이브러리**를 지원한다.)
- 이 페이지에서 설정하는 법을 배우라:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, 계정 생성 필요. _잠재적 오류를 피하려면_ _**VirtualBox 포함**_ 버전을 **다운로드**하는 것이 권장된다._)
- [**Nox**](https://es.bignox.com) (무료, 하지만 Frida나 Drozer는 지원하지 않음).

> [!TIP]
> 어떤 플랫폼에서 새 에뮬레이터를 생성할 때 화면이 클수록 에뮬레이터가 느려진다. 가능한 경우 작은 화면을 선택하라.

Genymotion에서 Google 서비스(예: AppStore)를 설치하려면 다음 이미지의 빨간 표시된 버튼을 클릭해야 한다:

![](<../../images/image (277).png>)

또한 **Genymotion의 Android VM 설정**에서 **Bridge Network mode**를 선택할 수 있는데(이것은 다른 VM에서 도구로 Android VM에 연결할 경우 유용하다) 이를 확인하라.

#### Use a physical device

디버깅 옵션을 활성화해야 하며, 가능하다면 **root**하는 것이 좋다:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> 애플리케이션을 설치한 후 가장 먼저 해야 할 일은 앱을 실행해 무엇을 하는지, 어떻게 동작하는지 조사하여 익숙해지는 것이다.\
> 초기 동적 분석은 MobSF dynamic analysis + pidcat를 사용해 수행할 것을 권장한다. 이렇게 하면 MobSF가 나중에 검토할 수 있는 많은 **흥미로운 데이터**를 캡처하는 동안 애플리케이션의 동작을 학습할 수 있다.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Magisk 앱으로 boot.img를 패치하고 fastboot로 플래시하여 systemless root를 얻는다
- Zygisk + DenyList를 활성화하여 루트 숨기기를 수행; 더 강한 숨김이 필요하면 LSPosed/Shamiko 고려
- OTA 업데이트에서 복구할 수 있도록 원본 boot.img를 보관; OTA 후 재패치 필요
- 화면 미러링은 호스트에서 scrcpy 사용

### Unintended Data Leakage

**Logging**

개발자는 **디버깅 정보**를 공개적으로 노출하지 않도록 주의해야 한다. 이는 민감한 데이터 유출로 이어질 수 있다. 애플리케이션 로그를 모니터링하여 민감한 정보를 식별하고 보호하기 위해 도구 [**pidcat**](https://github.com/JakeWharton/pidcat)와 `adb logcat`를 권장한다. **Pidcat**은 사용 편의성과 가독성 때문에 선호된다.

> [!WARNING]
> Android 4.0보다 **이후 버전부터는**, **애플리케이션은 자신의 로그만 접근할 수 있다**는 점을 유의하라. 따라서 앱은 다른 앱의 로그에 접근할 수 없다.\
> 어쨌든, 민감한 정보를 로그에 남기지 않는 것이 여전히 권장된다.

**Copy/Paste Buffer Caching**

Android의 **클립보드 기반** 프레임워크는 앱 간 복사-붙여넣기 기능을 제공하지만, **다른 애플리케이션**이 클립보드에 접근할 수 있어 민감한 데이터가 노출될 위험이 있다. 신용카드 정보와 같이 민감한 섹션에서는 복사/붙여넣기 기능을 비활성화하는 것이 중요하다.

**Crash Logs**

애플리케이션이 **크래시**하여 로그를 저장하면, 특히 애플리케이션을 리버스 엔지니어링할 수 없을 때 공격자에게 도움이 될 수 있다. 이를 완화하려면 크래시 시 로깅을 피하고, 로그를 네트워크로 전송해야 한다면 SSL 채널을 통해 전송하도록 하라.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

애플리케이션은 종종 Google Adsense와 같은 서비스를 통합하는데, 개발자의 잘못된 구현으로 인해 민감한 데이터가 **leak**될 수 있다. 잠재적 데이터 누수를 식별하려면 애플리케이션의 트래픽을 가로채고 제3자 서비스로 전송되는 민감한 정보가 있는지 확인하는 것이 바람직하다.

### SQLite DBs

대부분의 애플리케이션은 정보를 저장하기 위해 **내부 SQLite 데이터베이스**를 사용한다. 펜테스트 중에는 생성된 **데이터베이스**, **테이블** 및 **컬럼 이름**, 그리고 저장된 모든 **데이터**를 살펴보라. 민감한 정보를 찾을 수 있으며 이는 취약점이 될 수 있다.\
데이터베이스는 `/data/data/the.package.name/databases`에 위치해야 한다(예: `/data/data/com.mwr.example.sieve/databases`).

만약 데이터베이스가 기밀 정보를 저장하는데 **암호화되어 있고**, 그 암호를 애플리케이션 내부에서 **찾을 수 있다면** 이것은 여전히 **취약점**이다.

테이블을 열거하려면 `.tables`를 사용하고, 테이블의 컬럼을 나열하려면 `.schema <table_name>`을 사용하라.

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer**는 Android 앱의 역할을 가정하고 다른 앱과 상호작용할 수 있게 해준다. 설치된 애플리케이션이 할 수 있는 모든 것을 수행할 수 있으며, Android의 Inter-Process Communication(IPC) 메커니즘을 사용하고 기본 운영체제와 상호작용할 수 있다.\
Drozer는 export된 activities, export된 services 및 Content Providers를 **exploit**하는 데 유용한 도구이며, 다음 섹션에서 이를 배우게 될 것이다.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
또한 activity의 코드는 **`onCreate`** 메서드에서 시작된다는 것을 기억하라.

**Authorisation bypass**

Activity가 export되어 있으면 외부 앱에서 해당 화면을 호출할 수 있다. 따라서 **민감한 정보**를 가진 액티비티가 **exported** 되어 있다면 인증 메커니즘을 **bypass**하여 접근할 수 있다.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

다음과 같이 adb에서 export된 activity를 시작할 수도 있다:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**참고**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> 권한 우회(authorisation bypass)가 항상 취약점은 아니며, 우회 방식과 어떤 정보가 노출되는지에 따라 달라집니다.

**민감한 정보 누출**

Activities can also return results. If you manage to find an exported and unprotected activity calling the **`setResult`** method and **returning sensitive information**, there is a sensitive information leakage.

#### Tapjacking

If tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers are basically used to **share data**. If an app has available content providers you may be able to **extract sensitive** data from them. It also interesting to test possible **SQL injections** and **Path Traversals** as they could be vulnerable.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Remember that a the actions of a Service start in the method `onStartCommand`.

서비스는 기본적으로 **데이터를 수신**하고, **처리**하며 (응답을) **반환**할 수 있습니다. 따라서 애플리케이션이 일부 서비스를 export하고 있다면 무엇을 하는지 이해하기 위해 **코드**를 **확인**하고 기밀 정보를 추출하거나 인증 우회를 시도하기 위해 **동적으로** **테스트**해야 합니다.\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Remember that a the actions of a Broadcast Receiver start in the method `onReceive`.

브로드캐스트 리시버는 특정 타입의 메시지를 기다립니다. 리시버가 메시지를 처리하는 방식에 따라 취약해질 수 있습니다.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
You can **open** a declared **scheme** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_참고로 패키지 이름을 **생략할 수 있으며**, 모바일이 해당 링크를 열 앱을 자동으로 호출합니다._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**실행되는 코드**

앱에서 **실행될 코드**를 찾으려면 deeplink가 호출하는 activity로 가서 함수 **`onNewIntent`**를 검색하세요.

![](<../../images/image (436) (1) (1) (1).png>)

**민감한 정보**

deep link를 찾을 때마다 URL 파라미터를 통해 비밀번호와 같은 **민감한 데이터가 전달되지 않는지 반드시 확인하세요**, 다른 애플리케이션이 해당 deep link를 **가로채어 그 데이터를 훔칠 수 있기 때문입니다!**

**경로의 파라미터**

URL 경로 내부에 파라미터를 사용하는 deep link가 있는지 **반드시 확인해야 합니다**. 예: `https://api.example.com/v1/users/{username}`. 이런 경우 다음과 같이 path traversal을 강제할 수 있습니다: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
애플리케이션 내에서 올바른 엔드포인트를 찾으면 경로의 일부가 도메인 이름으로 사용되는 경우 **Open Redirect**를 유발할 수 있고, CSRF 토큰 없이 사용자 정보를 수정할 수 있고 취약한 엔드포인트가 올바른 메소드를 사용했다면 **account takeover** 등을 발생시킬 수 있습니다. 자세한 내용은 [여기](http://dphoeniixx.com/2020/12/13-2/)를 참조하세요.

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### 전송 계층 검사 및 검증 실패

- **Certificates are not always inspected properly** by Android applications. It's common for these applications to overlook warnings and accept self-signed certificates or, in some instances, revert to using HTTP connections.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, employing insecure cipher suites. This vulnerability makes the connection susceptible to man-in-the-middle (MITM) attacks, allowing attackers to decrypt the data.
- **Leakage of private information** is a risk when applications authenticate using secure channels but then communicate over non-secure channels for other transactions. This approach fails to protect sensitive data, such as session cookies or user details, from interception by malicious entities.

#### Certificate Verification

우리는 **certificate verification**에 초점을 맞출 것입니다. 서버 인증서의 무결성을 검증하는 것은 보안을 강화하는 데 매우 중요합니다. 불안전한 TLS 구성과 민감한 데이터를 암호화되지 않은 채널로 전송하는 것은 큰 위험을 초래할 수 있습니다. 서버 인증서 검증 및 취약점 대응에 대한 자세한 단계는 [**이 자료**](https://manifestsecurity.com/android-application-security-part-10/)에서 확인할 수 있습니다.

#### SSL Pinning

SSL Pinning은 애플리케이션이 서버의 인증서를 애플리케이션 내부에 저장된 알려진 복사본과 비교하여 검증하는 보안 기법입니다. 이 방법은 MITM 공격을 방지하는 데 필수적입니다. 민감한 정보를 취급하는 애플리케이션에는 SSL Pinning 구현을 강력히 권장합니다.

#### Traffic Inspection

HTTP 트래픽을 검사하려면 프록시 도구의 인증서(예: Burp)를 **설치해야** 합니다. 이 인증서를 설치하지 않으면 암호화된 트래픽이 프록시를 통해 보이지 않을 수 있습니다. 커스텀 CA 인증서 설치 가이드는 [**여기**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)를 참조하세요.

Applications targeting **API Level 24 and above** require modifications to the Network Security Config to accept the proxy's CA certificate. 이 단계는 암호화된 트래픽을 검사할 때 매우 중요합니다. Network Security Config 수정 방법은 [**이 튜토리얼**](make-apk-accept-ca-certificate.md)을 참고하세요.

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). This is becasue, just adding the certificate into the store won't work as Flutter has its own list of valid CAs.

#### Static detection of SSL/TLS pinning

런타임 우회를 시도하기 전에 APK에서 pinning이 적용된 위치를 빠르게 매핑하세요. 정적 탐지는 훅/패치 계획을 세우고 올바른 코드 경로에 집중하는 데 도움이 됩니다.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

설치
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
사용법
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
예시 패턴 규칙 (JSON)
signatures를 사용하거나 확장하여 독점적/맞춤형 pinning 스타일을 탐지하세요. 자체 JSON을 로드하여 대규모로 scan할 수 있습니다.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
노트 및 팁
- 대형 앱을 multi-threading과 memory-mapped I/O로 빠르게 스캔; 미리 컴파일된 regex가 오버헤드/오탐을 줄여줌.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 다음으로 우선 분류할 일반적인 탐지 대상:
- OkHttp: CertificatePinner 사용, setCertificatePinner, okhttp3/okhttp 패키지 참조
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted 오버라이드
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- 일치한 위치를 사용해 dynamic testing 전에 Frida hooks, static patches, 또는 config 검토를 계획하세요.



#### SSL Pinning 우회

앱에 SSL Pinning이 구현되어 있으면 HTTPS 트래픽을 검사하기 위해 이를 우회할 필요가 있다. 이를 위한 다양한 방법이 있다:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 일반적인 웹 취약점 탐색

애플리케이션 내에서 일반적인 웹 취약점도 검색하는 것이 중요하다. 이러한 취약점을 식별하고 완화하는 자세한 정보는 이 요약의 범위를 벗어나지만 다른 곳에 광범위하게 다루어져 있다.

### Frida

[Frida](https://www.frida.re) 는 개발자, 리버스 엔지니어, 보안 연구원을 위한 동적 계측 툴킷이다.\
**실행 중인 애플리케이션에 접근하여 런타임에 메서드를 hook하여 동작을 변경하거나 값을 변경/추출하고 다른 코드를 실행할 수 있다...**\
Android 애플리케이션을 pentest하려면 Frida 사용법을 알아야 한다.

- Frida 사용법 배우기: [**Frida tutorial**](frida-tutorial/index.html)
- Frida로 작업을 위한 일부 "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- 여기에서 몇몇 Awesome Frida 스크립트를 찾을 수 있다: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- anti-debugging / anti-frida 메커니즘을 우회하려면 Frida를 다음에 안내된 방식으로 로드해 보세요: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (도구 [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **메모리 덤프 - Fridump**

애플리케이션이 메모리 안에 저장해서는 안 되는 비밀번호나 mnemonics 같은 민감한 정보를 저장하고 있는지 확인하세요.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
이 명령은 메모리를 ./dump 폴더에 덤프하며, 그 안에서 다음과 같이 grep할 수 있습니다:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore의 민감한 데이터**

Android에서 Keystore는 민감한 데이터를 저장하기에 가장 좋은 장소지만, 충분한 권한이 있으면 여전히 **접근할 수 있습니다**. 애플리케이션은 여기서 **민감한 데이터를 평문으로 저장하는 경향이 있기 때문에**, pentests는 root user 권한으로 이를 확인해야 합니다. 장치에 물리적 접근이 가능한 사람도 이 데이터를 탈취할 수 있습니다.

앱이 Keystore에 데이터를 저장하더라도, 그 데이터는 암호화되어야 합니다.

Keystore 내부의 데이터에 접근하려면 다음 Frida script를 사용할 수 있습니다: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

다음 Frida script를 사용하면 Android 애플리케이션이 특정 민감 영역을 보호하기 위해 수행하고 있을 수 있는 **bypass fingerprint authentication**을 우회할 수 있습니다:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **백그라운드 이미지**

애플리케이션을 백그라운드로 보낼 때, Android는 **snapshot of the application**을 저장합니다. 그래서 포그라운드로 복구될 때 앱보다 먼저 이미지를 불러와 앱이 더 빨리 로드된 것처럼 보입니다.

하지만 이 snapshot에 **민감한 정보**가 포함되어 있다면, snapshot에 접근할 수 있는 누군가가 그 정보를 **탈취할 수 있습니다**(접근하려면 root가 필요합니다).

스냅샷은 보통 다음 위치에 저장됩니다: **`/data/system_ce/0/snapshots`**

Android는 FLAG_SECURE 레이아웃 파라미터를 설정하여 **screenshot 캡처를 방지**할 수 있는 방법을 제공합니다. 이 플래그를 사용하면 창 내용이 보안 처리되어 스크린샷에 나타나거나 보안되지 않은 디스플레이에서 보여지는 것을 방지합니다.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

이 도구는 동적 분석 중 여러 도구를 관리하는 데 도움이 될 수 있습니다: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

개발자는 종종 이러한 Intent를 처리하고 `startActivity(...)`나 `sendBroadcast(...)`와 같은 메소드로 전달하는 activity, service, broadcast receiver와 같은 프록시 컴포넌트를 만들며, 이는 위험할 수 있습니다.

위험은 공격자가 이러한 Intent를 잘못 유도하여 export되지 않은 앱 구성요소를 트리거하거나 민감한 content providers에 접근할 수 있게 하는 데 있습니다. 예를 들어, `WebView` 컴포넌트가 URL을 `Intent.parseUri(...)`로 `Intent` 객체로 변환한 뒤 이를 실행하면 악의적인 Intent injections로 이어질 수 있습니다.

### 핵심 요약

- **Intent Injection**은 웹의 Open Redirect 문제와 유사합니다.
- 공격은 `Intent` 객체를 extras로 전달하여 이를 리다이렉트해 안전하지 않은 동작을 실행하도록 하는 방식으로 이루어집니다.
- 이는 export되지 않은 컴포넌트 및 content providers를 공격자에게 노출시킬 수 있습니다.
- `WebView`의 URL → `Intent` 변환은 의도치 않은 동작을 촉진할 수 있습니다.

### Android Client Side Injections 및 기타

아마도 웹에서 이러한 유형의 취약점을 알고 있을 것입니다. Android 애플리케이션에서는 다음 취약점들에 특히 주의해야 합니다:

- **SQL Injection:** 동적 쿼리나 Content-Providers를 다룰 때는 파라미터화된 쿼리를 사용하고 있는지 확인하세요.
- **JavaScript Injection (XSS):** 모든 WebView에 대해 JavaScript와 Plugin 지원이 비활성화되어 있는지 확인하세요(기본적으로 비활성화됨). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebView는 파일 시스템 접근이 비활성화되어야 합니다(기본값은 활성화됨) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 많은 경우 Android 애플리케이션이 세션을 종료할 때 쿠키가 해지되지 않거나 디스크에 저장될 수 있습니다.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## 자동 분석

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**정적 분석**

![](<../../images/image (866).png>)

**애플리케이션의 취약점 평가**는 보기 좋은 웹 기반 프론트엔드를 사용합니다. 동적 분석도 수행할 수 있습니다(단, 환경을 준비해야 합니다).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### MobSF를 이용한 Assisted Dynamic analysis

**MobSF**는 Android에서의 **Dynamic analysis**에 매우 유용하지만, 이 경우 호스트에 MobSF와 **genymotion**을 설치해야 합니다(가상 머신이나 Docker는 작동하지 않습니다). _참고: 먼저 **genymotion**에서 VM을 시작한 다음 **MobSF**를 시작해야 합니다._\
**MobSF dynamic analyser**는 다음을 수행할 수 있습니다:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). 이들 중 스크린샷을 제외한 모든 항목은 자동으로 수집됩니다. 스크린샷은 원할 때 직접 찍거나 "**Exported Activity Tester**"를 눌러 모든 exported activities의 스크린샷을 얻어야 합니다.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

android **versions > 5**에서는 **Frida**를 자동으로 시작하고 트래픽을 캡처하기 위해 전역 **proxy** 설정을 구성합니다. 캡처되는 트래픽은 테스트 중인 애플리케이션에서 발생하는 트래픽만 해당됩니다.

**Frida**

기본적으로 몇몇 Frida Scripts를 사용해 **SSL pinning**, **root detection**, **debugger detection**을 우회하고 흥미로운 API를 모니터링합니다.\
MobSF는 또한 **invoke exported activities**, 해당 활동의 **screenshots**을 캡처하고 리포트용으로 **save**할 수 있습니다.

동적 테스트를 **start**하려면 녹색 버튼인: "**Start Instrumentation**"을 누르세요. "**Frida Live Logs**"를 눌러 Frida 스크립트가 생성한 로그를 보고, "**Live API Monitor**"를 눌러 후킹된 메서드의 호출, 전달된 인자 및 반환값을 확인할 수 있습니다(이 항목은 "Start Instrumentation"을 누른 후에 표시됩니다).\
MobSF는 또한 자체 **Frida scripts**를 불러올 수 있습니다(Frida 스크립트의 결과를 MobSF로 보내려면 `send()` 함수를 사용하세요). 또한 미리 작성된 **여러 스크립트**를 불러올 수 있으며(더 추가하려면 `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`에 추가), 단순히 선택 후 "**Load**"를 누르고 "**Start Instrumentation**"을 누르면 해당 스크립트의 로그를 "**Frida Live Logs**"에서 볼 수 있습니다.

![](<../../images/image (419).png>)

또한 몇 가지 보조 Frida 기능이 있습니다:

- **Enumerate Loaded Classes**: 로드된 모든 클래스를 출력합니다
- **Capture Strings**: 애플리케이션 사용 중 캡처된 모든 문자열을 출력합니다(매우 많은 노이즈 발생)
- **Capture String Comparisons**: 매우 유용할 수 있습니다. 비교되는 두 문자열과 결과(True/False)를 **표시**합니다.
- **Enumerate Class Methods**: 클래스 이름(예: "java.io.File")을 입력하면 해당 클래스의 모든 메서드를 출력합니다.
- **Search Class Pattern**: 패턴으로 클래스 검색
- **Trace Class Methods**: **Trace** a **whole class** (해당 클래스의 모든 메서드의 입력과 출력을 확인). 기본적으로 MobSF는 여러 흥미로운 Android API 메서드를 trace 합니다.

원하는 보조 모듈을 선택한 후 "**Start Intrumentation**"을 누르면 모든 출력이 "**Frida Live Logs**"에 표시됩니다.

**Shell**

MobSF는 동적 분석 페이지 하단에 몇 가지 **adb** 명령, **MobSF commands**, 일반적인 **shell** **commands**가 포함된 쉘도 제공합니다. 몇 가지 흥미로운 명령:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 도구**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" 버튼 or a nicer view in "**Start HTTPTools**" green 버튼. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage를 이용한 보조 동적 분석

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
이 도구는 몇 가지 **Hooks**를 사용하여 **dynamic analysis**를 수행하는 동안 애플리케이션에서 **무슨 일이 일어나고 있는지** 알려줍니다.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 참조하기 쉽게 모든 추출된 파일을 표시합니다
- APK 파일을 자동으로 Java 및 Smali 형식으로 디컴파일합니다
- AndroidManifest.xml을 분석하여 일반적인 취약점 및 동작을 확인합니다
- 정적 소스 코드 분석을 통해 일반적인 취약점 및 동작을 검사합니다
- 장치 정보
- 그리고 더 많은 기능
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER는 Windows, MacOS X 및 Linux에서 사용할 수 있는 커맨드라인 애플리케이션으로, 취약점을 찾기 위해 _.apk_ 파일을 분석합니다. 이 도구는 APKs를 압축 해제하고 일련의 규칙을 적용하여 해당 취약점을 탐지합니다.

모든 규칙은 `rules.json` 파일에 집중되어 있으며, 각 회사나 테스터는 필요에 맞게 자체 규칙을 만들어 분석할 수 있습니다.

최신 바이너리는 [download page](https://superanalyzer.rocks/download.html)에서 다운로드하세요.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn은 모바일 애플리케이션에서 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)를 수행하는 개발자, bugbounty hunters 및 ethical hackers를 지원하는 **크로스플랫폼** 도구입니다.

개념은 모바일 애플리케이션 파일(.apk 또는 .ipa 파일)을 StaCoAn 애플리케이션에 드래그 앤 드롭하면 시각적이고 휴대 가능한 리포트를 생성해 준다는 것입니다. 설정과 wordlists를 조정하여 맞춤형 경험을 얻을 수 있습니다.

다운로드[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework는 개발자나 해커가 Android 애플리케이션에서 잠재적인 보안 취약점을 찾도록 돕는 취약점 분석 시스템입니다.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**는 Android 애플리케이션이 수행할 수 있는 잠재적 악성 행위를 탐지하고 사용자에게 경고하는 것을 주된 목적으로 하는 도구입니다.

탐지는 [`androguard`](https://github.com/androguard/androguard) 라이브러리를 사용해 **Smali**로 표현된 애플리케이션의 Dalvik 바이트코드에 대한 **static analysis**로 수행됩니다.

이 도구는 다음과 같은 Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution 등과 같은 **common behavior of "bad" applications**를 탐지합니다...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. 이는 OWASP mobile security 위협에 대해 모바일 애플리케이션을 테스트할 때 자주 사용하는 모바일 애플리케이션 리버스 엔지니어링 및 분석 도구들을 한데 모아 둔 툴입니다. 목적은 모바일 애플리케이션 개발자와 보안 전문가들이 이 작업을 더 쉽고 친숙하게 수행할 수 있도록 돕는 것입니다.

가능한 기능:

- 다양한 도구를 사용하여 Java 및 Smali 코드를 추출합니다.
- 다음을 사용해 APK를 분석합니다: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- regexps를 사용해 APK에서 private 정보를 추출합니다.
- Manifest를 분석합니다.
- 다음을 사용해 발견된 도메인을 분석합니다: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- [apk-deguard.com](http://www.apk-deguard.com)을 통해 APK 난독화 해제(deobfuscate)를 시도합니다.

### Koodous

악성코드 탐지에 유용: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

사용하는 서비스와 구성에 따라 코드가 난독화될 때 비밀(Secrets)이 난독화되지 않거나 난독화될 수 있다는 점에 유의하세요.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard**는 Java 코드를 축소(shrink), 최적화(optimize), 난독화(obfuscate)하는 오픈 소스 커맨드라인 도구입니다. 바이트코드를 최적화하고 사용되지 않는 명령을 탐지 및 제거할 수 있습니다. ProGuard는 무료 소프트웨어이며 GNU General Public License, version 2 하에 배포됩니다.

ProGuard는 Android SDK의 일부로 배포되며 release 모드로 애플리케이션을 빌드할 때 실행됩니다.

### [DexGuard](https://www.guardsquare.com/dexguard)

APK 난독화 해제에 대한 단계별 가이드는 [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)에서 확인하세요.

(해당 가이드에서) 마지막으로 확인했을 때 Dexguard의 동작 방식은 다음과 같았습니다:

- 리소스를 InputStream으로 로드합니다;
- 결과를 FilterInputStream을 상속한 클래스에 전달하여 복호화합니다;
- 리버서의 시간을 조금 낭비시키기 위해 쓸데없는 난독화를 수행합니다;
- 복호화된 결과를 ZipInputStream에 전달하여 DEX 파일을 얻습니다;
- 마지막으로 결과 DEX를 `loadDex` 메서드를 사용해 Resource로 로드합니다.

### [DeGuard](http://apk-deguard.com)

**DeGuard는 Android 난독화 도구가 수행한 난독화 과정을 역으로 수행합니다. 이를 통해 코드 검사와 라이브러리 예측 등 다양한 보안 분석이 가능해집니다.**

난독화된 APK를 플랫폼에 업로드할 수 있습니다.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

이는 일반적인 android deobfuscator입니다. Simplify는 앱을 사실상 실행(virtually executes)하여 동작을 이해한 뒤, 사람이 이해하기 쉽도록 동일한 동작을 유지하면서 코드를 최적화하려고 시도합니다. 각 최적화 유형은 단순하고 일반적이므로 사용된 특정 난독화 유형이 무엇이든 상관없습니다.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD는 APK가 어떻게 만들어졌는지에 대한 정보를 제공합니다. 많은 컴파일러, packer, obfuscator 및 기타 이상한 것들을 식별합니다. Android용 [_PEiD_](https://www.aldeid.com/wiki/PEiD)입니다.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b는 Ubuntu MATE 기반의 Android 보안 가상머신으로, 리버스 엔지니어링 및 멀웨어 분석을 위한 최신 프레임워크, 튜토리얼 및 랩 컬렉션을 포함합니다. 보안 연구자들과 다양한 기여자들의 자료를 포함하고 있습니다.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 훌륭한 리소스 목록입니다
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 빠른 코스
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
