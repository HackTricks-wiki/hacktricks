# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

Συνιστάται έντονα να ξεκινήσετε διαβάζοντας αυτή τη σελίδα για να γνωρίσετε τα **πιο σημαντικά μέρη που σχετίζονται με την ασφάλεια του Android και τα πιο επικίνδυνα συστατικά σε μια Android εφαρμογή**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Αυτό είναι το κύριο εργαλείο που χρειάζεστε για να συνδεθείτε σε μια android συσκευή (εξομοιωμένη ή φυσική).\
**ADB** επιτρέπει τον έλεγχο συσκευών είτε μέσω **USB** είτε μέσω **Network** από έναν υπολογιστή. Αυτό το εργαλείο επιτρέπει την **αντιγραφή** αρχείων και προς τις δύο κατευθύνσεις, την **εγκατάσταση** και **απεγκατάσταση** εφαρμογών, την **εκτέλεση** εντολών shell, τη **δημιουργία αντιγράφων ασφαλείας** των δεδομένων, την **ανάγνωση** logs, μεταξύ άλλων λειτουργιών.

Ρίξτε μια ματιά στην παρακάτω λίστα με [**ADB Commands**](adb-commands.md) για να μάθετε πώς να χρησιμοποιείτε το adb.

## Smali

Μερικές φορές είναι ενδιαφέρον να **τροποποιήσετε τον κώδικα της εφαρμογής** για να αποκτήσετε πρόσβαση σε **κρυφές πληροφορίες** (ίσως καλά συγκεχυμένοι κωδικοί πρόσβασης ή flags). Τότε, μπορεί να είναι χρήσιμο να decompile το apk, να τροποποιήσετε τον κώδικα και να τον recompile.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Αυτό μπορεί να είναι πολύ χρήσιμο ως **εναλλακτική για διάφορα tests κατά τη διάρκεια της δυναμικής ανάλυσης** που πρόκειται να παρουσιαστούν. Συνεπώς, **κρατήστε πάντα στο μυαλό αυτή τη δυνατότητα**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Λήψη APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Εξαγωγή APK από συσκευή:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Συγχώνευσε όλα τα splits και base apks με [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Μελέτες Περίπτωσης & Ευπάθειες


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Στατική Ανάλυση

Πρώτα απ' όλα, για να αναλύσετε ένα APK θα πρέπει να **ρίξετε μια ματιά στον Java κώδικα** χρησιμοποιώντας έναν decompiler.\
Παρακαλώ, [**διαβάστε εδώ για να βρείτε πληροφορίες σχετικά με διαφορετικούς διαθέσιμους decompilers**](apk-decompilers.md).

### Αναζήτηση ενδιαφερόντων πληροφοριών

Απλώς κοιτάζοντας τα **strings** του APK μπορείτε να ψάξετε για **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** και οτιδήποτε ενδιαφέρον... ψάξτε ακόμη και για code execution **backdoors** ή authentication backdoors (hardcoded admin credentials στην εφαρμογή).

**Firebase**

Δώστε ειδική προσοχή στις **Firebase URLs** και ελέγξτε αν είναι κακώς διαμορφωμένες. [Περισσότερες πληροφορίες για το τι είναι η Firebase και πώς να την εκμεταλλευτείτε εδώ.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Βασική κατανόηση της εφαρμογής - Manifest.xml, strings.xml

Η εξέταση των αρχείων _Manifest.xml_ και _strings.xml_ μιας εφαρμογής μπορεί να αποκαλύψει πιθανές ευπάθειες ασφαλείας. Αυτά τα αρχεία είναι προσπελάσιμα μέσω decompilers ή μετονομάζοντας την επέκταση του APK σε .zip και στη συνέχεια αποσυμπιέζοντάς το.

**Ευπάθειες** που εντοπίζονται από το **Manifest.xml** περιλαμβάνουν:

- **Debuggable Applications**: Εφαρμογές που έχουν οριστεί ως debuggable (`debuggable="true"`) στο _Manifest.xml_ αποτελούν κίνδυνο καθώς επιτρέπουν συνδέσεις που μπορεί να οδηγήσουν σε εκμετάλλευση. Για περαιτέρω κατανόηση του πώς να εκμεταλλευτείτε debuggable εφαρμογές, ανατρέξτε σε ένα tutorial για τον εντοπισμό και την εκμετάλλευση debuggable εφαρμογών σε μια συσκευή.
- **Backup Settings**: Το attribute `android:allowBackup="false"` θα πρέπει να ορίζεται ρητά για εφαρμογές που χειρίζονται ευαίσθητες πληροφορίες για να αποτραπούν μη εξουσιοδοτημένα backups δεδομένων μέσω adb, ειδικά όταν το usb debugging είναι ενεργοποιημένο.
- **Network Security**: Προσαρμοσμένες ρυθμίσεις network security (`android:networkSecurityConfig="@xml/network_security_config"`) στο _res/xml/_ μπορούν να καθορίσουν λεπτομέρειες ασφαλείας όπως certificate pins και ρυθμίσεις HTTP traffic. Ένα παράδειγμα είναι η επιτρεπτή HTTP κίνηση για συγκεκριμένα domains.
- **Exported Activities and Services**: Ο εντοπισμός exported activities και services στο manifest μπορεί να αναδείξει components που μπορεί να κακοχρησιμοποιηθούν. Περαιτέρω ανάλυση κατά τη διάρκεια dynamic testing μπορεί να αποκαλύψει πώς να εκμεταλλευτείτε αυτά τα components.
- **Content Providers and FileProviders**: Εκτεθειμένοι content providers μπορεί να επιτρέψουν μη εξουσιοδοτημένη πρόσβαση ή τροποποίηση δεδομένων. Η διαμόρφωση των FileProviders πρέπει επίσης να ελεγχθεί προσεκτικά.
- **Broadcast Receivers and URL Schemes**: Αυτά τα components μπορούν να αξιοποιηθούν για εκμετάλλευση, με ιδιαίτερη προσοχή στον τρόπο που τα URL schemes διαχειρίζονται για input vulnerabilities.
- **SDK Versions**: Τα attributes `minSdkVersion`, `targetSDKVersion`, και `maxSdkVersion` υποδεικνύουν τις υποστηριζόμενες εκδόσεις Android, τονίζοντας τη σημασία του να μην υποστηρίζονται παρωχημένες, ευάλωτες εκδόσεις Android για λόγους ασφάλειας.

Από το αρχείο **strings.xml**, μπορούν να ανακαλυφθούν ευαίσθητες πληροφορίες όπως API keys, custom schemas και άλλες developer notes, υπογραμμίζοντας την ανάγκη για προσεκτική ανασκόπηση αυτών των πόρων.

### Tapjacking

Το Tapjacking είναι μια επίθεση όπου μια κακόβουλη εφαρμογή εκκινείται και τοποθετείται πάνω από μια εφαρμογή-θύμα. Μόλις καλύψει οπτικά την εφαρμογή-θύμα, το user interface της σχεδιάζεται ώστε να ξεγελάσει τον χρήστη να αλληλεπιδράσει με αυτό, ενώ παράλληλα προωθεί την αλληλεπίδραση στην εφαρμογή-θύμα. Στην πράξη, τυφλώνει τον χρήστη ώστε να μην γνωρίζει ότι στην πραγματικότητα εκτελεί ενέργειες στην εφαρμογή-θύμα.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Μια **activity** με το **`launchMode`** ρυθμισμένο σε **`singleTask` χωρίς να ορίζεται `taskAffinity`** είναι ευάλωτη σε Task Hijacking. Αυτό σημαίνει ότι μια **εφαρμογή** μπορεί να εγκατασταθεί και, αν εκκινηθεί πριν από την πραγματική εφαρμογή, να **καταλάβει το task της πραγματικής εφαρμογής** (έτσι ο χρήστης θα αλληλεπιδρά με την **κακόβουλη εφαρμογή πιστεύοντας ότι χρησιμοποιεί την πραγματική**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Μη ασφαλής αποθήκευση δεδομένων

**Internal Storage**

Στο Android, τα αρχεία **αποθηκευμένα** στην **εσωτερική** αποθήκευση έχουν σχεδιαστεί να είναι προσπελάσιμα αποκλειστικά από την **εφαρμογή** που τα **δημιούργησε**. Αυτό το μέτρο ασφαλείας **επιβάλλεται** από το Android λειτουργικό σύστημα και είναι γενικά επαρκές για τις ανάγκες ασφαλείας των περισσότερων εφαρμογών. Ωστόσο, οι προγραμματιστές μερικές φορές χρησιμοποιούν modes όπως `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE` για να **επιτρέψουν** να **μοιράζονται** αρχεία μεταξύ διαφορετικών εφαρμογών. Αυτές οι λειτουργίες όμως **δεν περιορίζουν την πρόσβαση** σε αυτά τα αρχεία από άλλες εφαρμογές, συμπεριλαμβανομένων ενδεχόμενα κακόβουλων.

1. **Static Analysis:**
- **Ελέγξτε** προσεκτικά τη χρήση των `MODE_WORLD_READABLE` και `MODE_WORLD_WRITABLE`. Αυτά τα modes **μπορεί να εκθέσουν** αρχεία σε **μη επιδιωκόμενη ή μη εξουσιοδοτημένη πρόσβαση**.
2. **Dynamic Analysis:**
- **Επαληθεύστε** τα **permissions** που έχουν οριστεί σε αρχεία που δημιουργεί η εφαρμογή. Συγκεκριμένα, **ελέγξτε** αν κάποια αρχεία έχουν οριστεί ως αναγνώσιμα ή εγγράψιμα από όλο τον κόσμο. Αυτό μπορεί να συνιστά σημαντικό κίνδυνο ασφαλείας, καθώς θα επέτρεπε σε **οποιαδήποτε εφαρμογή** εγκατεστημένη στη συσκευή, ανεξάρτητα από την προέλευση ή τον σκοπό της, να **διαβάσει ή να τροποποιήσει** αυτά τα αρχεία.

**External Storage**

Όταν χειρίζεστε αρχεία στην εξωτερική αποθήκευση, όπως SD Cards, πρέπει να ληφθούν ορισμένες προφυλάξεις:

1. **Accessibility**:
- Τα αρχεία στην εξωτερική αποθήκευση είναι **παγκοσμίως αναγνώσιμα και εγγράψιμα**. Αυτό σημαίνει ότι οποιαδήποτε εφαρμογή ή χρήστης μπορεί να έχει πρόσβαση σε αυτά τα αρχεία.
2. **Security Concerns**:
- Δεδομένης της ευκολίας πρόσβασης, συνιστάται **να μην αποθηκεύετε ευαίσθητες πληροφορίες** στην εξωτερική αποθήκευση.
- Η εξωτερική αποθήκευση μπορεί να αφαιρεθεί ή να προσπελαστεί από οποιαδήποτε εφαρμογή, καθιστώντας την λιγότερο ασφαλή.
3. **Handling Data from External Storage**:
- Πάντα **εκτελείτε input validation** στα δεδομένα που ανακτώνται από την εξωτερική αποθήκευση. Αυτό είναι κρίσιμο επειδή τα δεδομένα προέρχονται από μια μη έμπιστη πηγή.
- Η αποθήκευση εκτελέσιμων ή class files στην εξωτερική αποθήκευση για dynamic loading αποθαρρύνεται έντονα.
- Αν η εφαρμογή σας πρέπει να ανακτήσει εκτελέσιμα αρχεία από εξωτερική αποθήκευση, βεβαιωθείτε ότι αυτά τα αρχεία είναι **signed και cryptographically verified** πριν φορτωθούν δυναμικά. Αυτό το βήμα είναι ζωτικής σημασίας για τη διατήρηση της ασφάλειας της εφαρμογής σας.

External storage can be **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Ξεκινώντας από το Android 4.4 (**API 17**), η SD κάρτα έχει μια δομή καταλόγων που περιορίζει την πρόσβαση από μια εφαρμογή στον κατάλογο που προορίζεται ειδικά για αυτήν την εφαρμογή. Αυτό αποτρέπει κακόβουλες εφαρμογές από το να αποκτήσουν πρόσβαση ανάγνωσης ή εγγραφής στα αρχεία άλλης εφαρμογής.

**Ευαίσθητα δεδομένα αποθηκευμένα σε απλό κείμενο**

- **Shared preferences**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα xml αρχεία στη διαδρομή `/data/data/<packagename>/shared_prefs/` και μερικές φορές είναι πιθανό να βρεθούν ευαίσθητες πληροφορίες σε clear-text σε αυτόν τον φάκελο.
- **Databases**: Το Android επιτρέπει σε κάθε εφαρμογή να αποθηκεύει εύκολα sqlite databases στη διαδρομή `/data/data/<packagename>/databases/` και μερικές φορές είναι πιθανό να βρεθούν ευαίσθητες πληροφορίες σε clear-text σε αυτόν τον φάκελο.

### Broken TLS

**Accept All Certificates**

Για κάποιο λόγο μερικές φορές οι προγραμματιστές αποδέχονται όλα τα πιστοποιητικά ακόμα και αν, για παράδειγμα, το hostname δεν ταιριάζει, με γραμμές κώδικα όπως η ακόλουθη:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Ένας καλός τρόπος να το δοκιμάσετε είναι να προσπαθήσετε να καταγράψετε την κίνηση χρησιμοποιώντας κάποιο proxy όπως το Burp χωρίς να πιστοποιήσετε το Burp CA μέσα στη συσκευή. Επίσης, μπορείτε με το Burp να δημιουργήσετε ένα πιστοποιητικό για διαφορετικό hostname και να το χρησιμοποιήσετε.

### Broken Cryptography

**Κακές Διαδικασίες Διαχείρισης Κλειδιών**

Κάποιοι developers αποθηκεύουν ευαίσθητα δεδομένα στο local storage και τα κρυπτογραφούν με ένα κλειδί hardcoded/προβλέψιμο μέσα στον κώδικα. Αυτό δεν θα πρέπει να γίνεται καθώς κάποια reversing μπορεί να επιτρέψει σε επιτιθέμενους να εξάγουν τις εμπιστευτικές πληροφορίες.

**Χρήση Μη Ασφαλών και/ή Αποσυρμένων Αλγορίθμων**

Οι developers δεν θα πρέπει να χρησιμοποιούν **deprecated algorithms** για να εκτελούν έλεγχους authorisation, να **αποθηκεύουν** ή να **στέλνουν** δεδομένα. Κάποιοι από αυτούς τους αλγορίθμους είναι: RC4, MD4, MD5, SHA1... Εάν **hashes** χρησιμοποιούνται για να αποθηκεύονται κωδικοί για παράδειγμα, πρέπει να χρησιμοποιούνται hashes ανθεκτικοί σε brute-force με salt.

### Other checks

- Συνιστάται να **obfuscate the APK** για να δυσκολέψετε την εργασία του reverse engineer στους επιτιθέμενους.
- Αν η εφαρμογή είναι ευαίσθητη (όπως τραπεζικές εφαρμογές), θα πρέπει να πραγματοποιεί τα **own checks to see if the mobile is rooted** και να ενεργεί ανάλογα.
- Αν η εφαρμογή είναι ευαίσθητη (όπως τραπεζικές εφαρμογές), θα πρέπει να ελέγχει αν χρησιμοποιείται **emulator**.
- Αν η εφαρμογή είναι ευαίσθητη (όπως τραπεζικές εφαρμογές), θα πρέπει να **ελέγχει την ακεραιότητά της πριν την εκτέλεση** για να διαπιστώσει αν έχει τροποποιηθεί.
- Use [**APKiD**](https://github.com/rednaga/APKiD) για να ελέγξετε ποιος compiler/packer/obfuscator χρησιμοποιήθηκε για να κατασκευαστεί το APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Το εργαλείο [**mariana-trench**](https://github.com/facebook/mariana-trench) είναι ικανό να βρίσκει **vulnerabilities** σαρώνοντας τον **code** της εφαρμογής. Αυτό το εργαλείο περιλαμβάνει μια σειρά **known sources** (που υποδεικνύουν στο εργαλείο τα **σημεία** όπου το **input** ελέγχεται από τον χρήστη), **sinks** (που υποδεικνύουν στο εργαλείο τα **επικίνδυνα** σημεία όπου κακόβουλο input χρήστη μπορεί να προκαλέσει ζημιά) και **rules**. Αυτοί οι κανόνες υποδεικνύουν τους **συνδυασμούς** **sources-sinks** που δηλώνουν μια ευπάθεια.

Με αυτή τη γνώση, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

Μπορείτε να δημιουργήσετε ένα **free account** στο: [https://appetize.io/](https://appetize.io). Αυτή η πλατφόρμα επιτρέπει να **upload** και να **εκτελέσετε** APKs, οπότε είναι χρήσιμη για να δείτε πώς συμπεριφέρεται ένα apk.

Μπορείτε ακόμα να **δειτε τα logs της εφαρμογής σας** στο web και να συνδεθείτε μέσω **adb**.

![](<../../images/image (831).png>)

Χάρη στη σύνδεση ADB μπορείτε να χρησιμοποιήσετε **Drozer** και **Frida** μέσα στους emulator.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Μπορείτε να δημιουργήσετε **x86** και **arm** συσκευές, και σύμφωνα με [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** χωρίς την ανάγκη ενός αργού arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

Για να **install google services** (όπως AppStore) σε Genymotion πρέπει να κάνετε κλικ στο κόκκινο κουμπί της παρακάτω εικόνας:

![](<../../images/image (277).png>)

Επίσης, να σημειωθεί ότι στην **configuration of the Android VM in Genymotion** μπορείτε να επιλέξετε **Bridge Network mode** (αυτό θα είναι χρήσιμο αν θα συνδέεστε στο Android VM από ένα διαφορετικό VM με τα εργαλεία).

#### Use a physical device

Πρέπει να ενεργοποιήσετε τις **debugging** επιλογές και είναι καλό αν μπορείτε να την **root**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Οι developers πρέπει να είναι προσεκτικοί ώστε να μην εκθέτουν **debugging information** δημόσια, καθώς αυτό μπορεί να οδηγήσει σε διαρροή ευαίσθητων δεδομένων. Τα εργαλεία [**pidcat**](https://github.com/JakeWharton/pidcat) και `adb logcat` προτείνονται για την παρακολούθηση των application logs ώστε να εντοπιστεί και να προστατευτεί ευαίσθητη πληροφορία. **Pidcat** προτιμάται για την ευκολία χρήσης και την αναγνωσιμότητά του.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Το framework του Android που βασίζεται στο **clipboard** επιτρέπει λειτουργίες αντιγραφής/επικόλλησης στις εφαρμογές, ωστόσο εγκυμονεί κινδύνους καθώς **άλλες εφαρμογές** μπορούν να **έχουν πρόσβαση** στο clipboard, ενδεχομένως εκθέτοντας ευαίσθητα δεδομένα. Είναι κρίσιμο να **απενεργοποιούνται οι λειτουργίες copy/paste** για ευαίσθητες περιοχές της εφαρμογής, όπως στοιχεία πιστωτικών καρτών, για να αποτραπεί η διαρροή δεδομένων.

**Crash Logs**

Αν μια εφαρμογή **crashes** και **αποθηκεύει logs**, αυτά τα logs μπορούν να βοηθήσουν τους επιτιθέμενους, ειδικά όταν η εφαρμογή δεν μπορεί να γίνει reverse-engineered. Για να μειώσετε αυτόν τον κίνδυνο, αποφύγετε το logging σε crashes, και αν τα logs πρέπει να μεταβιβαστούν μέσω του δικτύου, βεβαιωθείτε ότι αποστέλλονται μέσω SSL καναλιού για ασφάλεια.

Ως pentester, **προσπαθήστε να ρίξετε μια ματιά σε αυτά τα logs**.

**Analytics Data Sent To 3rd Parties**

Οι εφαρμογές συχνά ενσωματώνουν υπηρεσίες όπως το Google Adsense, οι οποίες μπορούν ακούσια να **leak sensitive data** λόγω λανθασμένης υλοποίησης από τους developers. Για να εντοπίσετε πιθανές διαρροές, συνίσταται να **intercept** την κίνηση της εφαρμογής και να ελέγξετε αν ευαίσθητες πληροφορίες αποστέλλονται σε τρίτους.

### SQLite DBs

Οι περισσότερες εφαρμογές θα χρησιμοποιήσουν **internal SQLite databases** για να αποθηκεύουν πληροφορίες. Κατά τη διάρκεια του pentest, κοιτάξτε τις **databases** που δημιουργούνται, τα ονόματα των **tables** και **columns** και όλα τα **δεδομένα** που αποθηκεύονται γιατί μπορεί να βρείτε **ευαίσθητες πληροφορίες** (που θα συνιστούσαν ευπάθεια).\
Οι βάσεις δεδομένων θα πρέπει να βρίσκονται στο `/data/data/the.package.name/databases` όπως στο `/data/data/com.mwr.example.sieve/databases`

Αν η βάση δεδομένων αποθηκεύει εμπιστευτικές πληροφορίες και είναι **encrypted** αλλά μπορείτε να **βρείτε** το **password** μέσα στην εφαρμογή, αυτό εξακολουθεί να αποτελεί **ευπάθεια**.

Αναγνωρίστε τους πίνακες χρησιμοποιώντας `.tables` και αναγνωρίστε τις στήλες των πινάκων με `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**ΣΗΜΕΙΩΣΗ**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Σημειώστε ότι ένα authorisation bypass δεν είναι πάντα ευπάθεια — εξαρτάται από το πώς λειτουργεί το bypass και ποιες πληροφορίες αποκαλύπτονται.

**Διαρροή ευαίσθητων πληροφοριών**

**Activities can also return results**. Αν καταφέρετε να βρείτε μία exported και unprotected activity που καλεί τη μέθοδο **`setResult`** και **επιστρέφει ευαίσθητες πληροφορίες**, υπάρχει διαρροή ευαίσθητων πληροφοριών.

#### Tapjacking

Αν το Tapjacking δεν αποτρέπεται, μπορείτε να καταχραστείτε την exported activity για να κάνετε τον **χρήστη να εκτελέσει απρόσμενες ενέργειες**. Για περισσότερες πληροφορίες σχετικά με [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers are basically used to **share data**. Εάν μια εφαρμογή διαθέτει content providers, μπορεί να καταφέρετε να **εξάγετε ευαίσθητα** δεδομένα από αυτά. Επίσης είναι ενδιαφέρον να δοκιμάσετε πιθανές **SQL injections** και **Path Traversals**, καθώς μπορεί να είναι ευπαθείς.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Υπενθύμιση ότι οι ενέργειες ενός Service ξεκινούν στη μέθοδο `onStartCommand`.

Ένα service είναι βασικά κάτι που **μπορεί να λαμβάνει δεδομένα**, να τα **επεξεργάζεται** και να **επιστρέφει** (ή όχι) μια απάντηση. Επομένως, αν μια εφαρμογή εξάγει κάποιο services πρέπει να **ελέγξετε** τον **κώδικα** για να καταλάβετε τι κάνει και να το **δοκιμάσετε** **δυναμικά** για εξαγωγή εμπιστευτικών πληροφοριών, bypassing authentication measures...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Υπενθύμιση ότι οι ενέργειες ενός Broadcast Receiver ξεκινούν στη μέθοδο `onReceive`.

Ένας broadcast receiver θα περιμένει έναν τύπο μηνύματος. Ανάλογα με το πώς ο receiver χειρίζεται το μήνυμα, μπορεί να είναι ευπαθής.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Μπορείτε να αναζητήσετε deep links χειροκίνητα, χρησιμοποιώντας εργαλεία όπως MobSF ή scripts όπως [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Μπορείτε να **ανοίξετε** ένα δηλωμένο **scheme** χρησιμοποιώντας **adb** ή έναν **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Σημειώστε ότι μπορείτε να **παραλείψετε το όνομα πακέτου** και το κινητό θα καλέσει αυτόματα την εφαρμογή που πρέπει να ανοίξει αυτόν τον σύνδεσμο._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

Για να βρείτε τον **κώδικα που θα εκτελεστεί στην App**, πηγαίνετε στην activity που καλείται από το deeplink και αναζητήστε τη συνάρτηση **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

Κάθε φορά που βρίσκετε ένα deep link ελέγξτε ότι **δεν λαμβάνει sensitive data (όπως passwords) μέσω URL parameters**, γιατί οποιαδήποτε άλλη εφαρμογή θα μπορούσε να **προσποιηθεί το deep link και να κλέψει αυτά τα δεδομένα!**

**Parameters in path**

Πρέπει επίσης να ελέγξετε αν κάποιο deep link χρησιμοποιεί παράμετρο μέσα στο path του URL όπως: `https://api.example.com/v1/users/{username}` , σε αυτή την περίπτωση μπορείτε να προκαλέσετε path traversal προσπελάζοντας κάτι σαν: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Σημειώστε ότι αν βρείτε τα σωστά endpoints μέσα στην εφαρμογή μπορεί να καταφέρετε να προκαλέσετε **Open Redirect** (αν μέρος του path χρησιμοποιείται ως domain name), **account takeover** (αν μπορείτε να τροποποιήσετε λεπτομέρειες χρηστών χωρίς CSRF token και το vuln endpoint χρησιμοποιούσε τη σωστή μέθοδο) και οποιαδήποτε άλλη vuln. Περισσότερα [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Ένα [interesting bug bounty report](https://hackerone.com/reports/855618) σχετικά με links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** από Android applications. Είναι συχνό αυτές οι εφαρμογές να αγνοούν προειδοποιήσεις και να αποδέχονται self-signed certificates ή, σε μερικές περιπτώσεις, να επιστρέφουν στη χρήση HTTP connections.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, χρησιμοποιώντας insecure cipher suites. Αυτό το πρόβλημα κάνει τη σύνδεση ευάλωτη σε man-in-the-middle (MITM) attacks, επιτρέποντας σε επιτιθέμενους να αποκρυπτογραφήσουν τα δεδομένα.
- **Leakage of private information** είναι ένας κίνδυνος όταν εφαρμογές authenticate χρησιμοποιώντας secure channels αλλά στη συνέχεια επικοινωνούν μέσω non-secure channels για άλλες συναλλαγές. Αυτή η προσέγγιση δεν προστατεύει ευαίσθητα δεδομένα, όπως session cookies ή στοιχεία χρήστη, από υποκλοπή από κακόβουλους φορείς.

#### Certificate Verification

Θα επικεντρωθούμε στην **certificate verification**. Η ακεραιότητα του server's certificate πρέπει να επαληθεύεται για να ενισχυθεί η ασφάλεια. Αυτό είναι κρίσιμο γιατί insecure TLS configurations και η μετάδοση sensitive data πάνω από μη κρυπτογραφημένες συνδέσεις μπορούν να δημιουργήσουν σημαντικούς κινδύνους. Για αναλυτικά βήματα σχετικά με την επαλήθευση server certificates και την επίλυση ευπαθειών, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) παρέχει πλήρεις οδηγίες.

#### SSL Pinning

SSL Pinning είναι ένα security μέτρο όπου η εφαρμογή επαληθεύει το server's certificate σε σχέση με ένα γνωστό αντίγραφό του που φυλάσσεται μέσα στην εφαρμογή. Αυτή η μέθοδος είναι απαραίτητη για την αποτροπή MITM attacks. Συνιστάται έντονα η υλοποίηση του SSL Pinning για εφαρμογές που χειρίζονται sensitive information.

#### Traffic Inspection

Για να επιθεωρήσετε HTTP traffic, είναι απαραίτητο να **εγκαταστήσετε το proxy tool's certificate** (π.χ. Burp). Χωρίς την εγκατάσταση αυτού του πιστοποιητικού, το κρυπτογραφημένο traffic μπορεί να μην είναι ορατό μέσω του proxy. Για οδηγίες σχετικά με την εγκατάσταση ενός custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Εφαρμογές που στοχεύουν **API Level 24 and above** απαιτούν τροποποιήσεις στο Network Security Config για να αποδεχτούν το proxy's CA certificate. Αυτό το βήμα είναι κρίσιμο για την επιθεώρηση κρυπτογραφημένου traffic. Για οδηγίες σχετικά με την τροποποίηση του Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Αν χρησιμοποιείται **Flutter** πρέπει να ακολουθήσετε τις οδηγίες σε [**this page**](flutter.md). Αυτό συμβαίνει γιατί, απλά προσθέτοντας το certificate στο store δεν θα λειτουργήσει καθώς το Flutter έχει τη δική του λίστα με έγκυρες CAs.

#### Static detection of SSL/TLS pinning

Πριν επιχειρήσετε runtime bypasses, χαρτογραφήστε γρήγορα που επιβάλλεται το pinning στο APK. Η static discovery βοηθά στο να σχεδιάσετε hooks/patches και να εστιάσετε στα σωστά code paths.

Tool: SSLPinDetect
- Open-source static-analysis utility που decompiles το APK σε Smali (μέσω apktool) και σαρώνει για curated regex patterns υλοποιήσεων SSL/TLS pinning.
- Αναφέρει ακριβές file path, αριθμό γραμμής, και ένα code snippet για κάθε match.
- Καλύπτει κοινά frameworks και custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, και Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Χρήση
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Παραδείγματα pattern κανόνων (JSON)
Χρησιμοποιήστε ή επεκτείνετε signatures για να εντοπίσετε proprietary/custom pinning styles. Μπορείτε να φορτώσετε το δικό σας JSON και να σαρώσετε σε μεγάλη κλίμακα.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Γρήγορο scanning σε μεγάλες εφαρμογές μέσω multi-threading και memory-mapped I/O· pre-compiled regex μειώνει το overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typical detection targets to triage next:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Χρησιμοποιήστε τις εντοπισμένες τοποθεσίες για να σχεδιάσετε Frida hooks, static patches, ή reviews των config πριν από dynamic testing.



#### Παράκαμψη SSL Pinning

Όταν εφαρμόζεται το SSL Pinning, η παράκαμψή του γίνεται απαραίτητη για να ελεγχθεί η κίνηση HTTPS. Διατίθενται διάφορες μέθοδοι για αυτόν τον σκοπό:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Το μεγαλύτερο πλεονέκτημα αυτής της επιλογής είναι ότι δεν θα χρειαστείτε root για να παρακάμψετε το SSL Pinning, αλλά θα χρειαστεί να διαγράψετε την εφαρμογή και να εγκαταστήσετε ξανά τη νέα, και αυτό δεν λειτουργεί πάντα.
- Μπορείτε να χρησιμοποιήσετε **Frida** (συστήνεται παρακάτω) για να παρακάμψετε αυτή την προστασία. Εδώ υπάρχει ένας οδηγός για χρήση Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Μπορείτε επίσης να δοκιμάσετε να **αυτόματα παρακάμψετε το SSL Pinning** χρησιμοποιώντας [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Μπορείτε επίσης να δοκιμάσετε να **αυτόματα παρακάμψετε το SSL Pinning** χρησιμοποιώντας **MobSF dynamic analysis** (εξηγείται παρακάτω)
- Αν νομίζετε ότι υπάρχει ακόμα κίνηση που δεν καταγράφετε, μπορείτε να δοκιμάσετε να **προωθήσετε την κίνηση στο burp χρησιμοποιώντας iptables**. Διαβάστε αυτό το blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Αναζήτηση κοινών web ευπαθειών

Είναι σημαντικό επίσης να αναζητήσετε κοινές web ευπάθειες μέσα στην εφαρμογή. Λεπτομέρειες για τον εντοπισμό και την αντιμετώπιση αυτών των ευπαθειών υπερβαίνουν το πλαίσιο αυτής της περιληπτικής παρουσίασης αλλά καλύπτονται εκτενώς αλλού.

### Frida

[Frida](https://www.frida.re) είναι ένα toolkit δυναμικής instrumentation για developers, reverse-engineers και ερευνητές ασφαλείας.\
**Μπορείτε να αποκτήσετε πρόσβαση στην τρέχουσα εφαρμογή και να κάνετε hook μεθόδους σε runtime για να αλλάξετε τη συμπεριφορά, να αλλάξετε τιμές, να εξάγετε τιμές, να τρέξετε διαφορετικό κώδικα...**\
Αν θέλετε να pentest εφαρμογές Android πρέπει να ξέρετε πώς να χρησιμοποιείτε το Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Προσπαθήστε να παρακάμψετε anti-debugging / anti-frida μηχανισμούς φορτώνοντας το Frida όπως υποδεικνύεται στο [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (εργαλείο [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning ροή παράκαμψης

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Ελέγξτε αν η εφαρμογή αποθηκεύει ευαίσθητες πληροφορίες στη μνήμη που δεν θα έπρεπε να αποθηκεύει, όπως κωδικούς πρόσβασης ή mnemonics.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Αυτό θα dump τη μνήμη στο φάκελο ./dump, και εκεί μπορείτε να κάνετε grep με κάτι σαν:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Ευαίσθητα δεδομένα στο Keystore**

Στο Android το Keystore είναι το καλύτερο μέρος για την αποθήκευση ευαίσθητων δεδομένων, όμως με επαρκή προνόμια εξακολουθεί να είναι **εφικτό να αποκτηθεί πρόσβαση σε αυτό**. 

Επειδή οι εφαρμογές τείνουν να αποθηκεύουν εδώ **sensitive data in clear text**, οι pentests πρέπει να το ελέγξουν, καθώς ένας χρήστης root ή κάποιος με φυσική πρόσβαση στη συσκευή θα μπορούσε να κλέψει αυτά τα δεδομένα.

Ακόμη και αν μια εφαρμογή αποθήκευσε δεδομένα στο Keystore, τα δεδομένα πρέπει να είναι κρυπτογραφημένα.

Για να αποκτήσετε πρόσβαση στα δεδομένα μέσα στο Keystore μπορείτε να χρησιμοποιήσετε αυτό το Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Χρησιμοποιώντας το παρακάτω Frida script, ενδέχεται να είναι δυνατό να γίνει **bypass fingerprint authentication** που πραγματοποιούν οι εφαρμογές Android προκειμένου να **προστατεύσουν ορισμένες ευαίσθητες περιοχές:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Εικόνες φόντου**

Όταν βάζετε μια εφαρμογή στο παρασκήνιο, Android αποθηκεύει ένα **στιγμιότυπο της εφαρμογής** ώστε όταν επανέλθει στο προσκήνιο να αρχίζει να φορτώνει την εικόνα πριν την εφαρμογή ώστε να φαίνεται ότι η εφαρμογή φορτώθηκε πιο γρήγορα.

Ωστόσο, αν αυτό το στιγμιότυπο περιέχει **ευαίσθητες πληροφορίες**, κάποιος με πρόσβαση στο στιγμιότυπο μπορεί να **κλέψει αυτές τις πληροφορίες** (σημείωση: χρειάζεται root για να αποκτήσετε πρόσβαση).

Τα στιγμιότυπα συνήθως αποθηκεύονται στη διαδρομή: **`/data/system_ce/0/snapshots`**

Android παρέχει τρόπο για να **αποτραπεί η λήψη στιγμιότυπου οθόνης ρυθμίζοντας την παράμετρο layout FLAG_SECURE**. Χρησιμοποιώντας αυτή τη σημαία, τα περιεχόμενα του παραθύρου θεωρούνται ασφαλή, αποτρέποντας να εμφανίζονται σε στιγμιότυπα οθόνης ή να προβάλλονται σε μη ασφαλείς οθόνες.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Αυτό το εργαλείο μπορεί να σας βοηθήσει στη διαχείριση διαφορετικών εργαλείων κατά τη διάρκεια της δυναμικής ανάλυσης: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Οι προγραμματιστές συχνά δημιουργούν proxy components όπως activities, services και broadcast receivers που χειρίζονται αυτά τα Intents και τα μεταβιβάζουν σε μεθόδους όπως `startActivity(...)` ή `sendBroadcast(...)`, κάτι που μπορεί να είναι επικίνδυνο.

Ο κίνδυνος έγκειται στο να επιτρέπεται σε επιτιθέμενους να ενεργοποιήσουν μη-exported components της εφαρμογής ή να αποκτήσουν πρόσβαση σε ευαίσθητους content providers με την παραπλάνηση αυτών των Intents. Ένα χαρακτηριστικό παράδειγμα είναι το `WebView` component που μετατρέπει URLs σε `Intent` αντικείμενα μέσω `Intent.parseUri(...)` και στη συνέχεια τα εκτελεί, γεγονός που μπορεί να οδηγήσει σε malicious Intent injections.

### Essential Takeaways

- **Intent Injection** είναι παρόμοιο με το Open Redirect στο web.
- Οι εκμεταλλεύσεις περιλαμβάνουν τη μεταβίβαση `Intent` αντικειμένων ως extras, τα οποία μπορούν να αναδρομολογηθούν για να εκτελέσουν μη ασφαλείς ενέργειες.
- Μπορεί να εκθέσει μη-exported components και content providers σε επιτιθέμενους.
- Η μετατροπή URL σε `Intent` από το `WebView` μπορεί να διευκολύνει ανεπιθύμητες ενέργειες.

### Android Client Side Injections and others

Πιθανόν να γνωρίζετε αυτού του είδους τις ευπάθειες από το Web. Θα πρέπει να είστε ιδιαίτερα προσεκτικοί με αυτές τις ευπάθειες σε μια εφαρμογή Android:

- **SQL Injection:** Όταν χειρίζεστε δυναμικά queries ή Content-Providers βεβαιωθείτε ότι χρησιμοποιείτε parameterized queries.
- **JavaScript Injection (XSS):** Ελέγξτε ότι η υποστήριξη JavaScript και Plugin είναι απενεργοποιημένη για οποιαδήποτε WebViews (απενεργοποιημένη από προεπιλογή). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Οι WebViews θα πρέπει να έχουν απενεργοποιημένη την πρόσβαση στο file system (ενεργοποιημένη από προεπιλογή) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Σε αρκετές περιπτώσεις όταν η εφαρμογή Android τελειώνει τη συνεδρία, το cookie δεν ανακαλείται ή μπορεί ακόμη και να αποθηκευτεί στο δίσκο.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Στατική ανάλυση**

![](<../../images/image (866).png>)

**Αξιολόγηση ευπαθειών της εφαρμογής** χρησιμοποιώντας ένα ευχάριστο web-based frontend. Μπορείτε επίσης να εκτελέσετε δυναμική ανάλυση (αλλά χρειάζεται να προετοιμάσετε το περιβάλλον).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Σημειώστε ότι το MobSF μπορεί να αναλύσει **Android**(apk)**, IOS**(ipa) **and Windows**(apx) εφαρμογές (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Επίσης, αν δημιουργήσετε ένα **ZIP** αρχείο με τον πηγαίο κώδικα μιας **Android** ή μιας **IOS** εφαρμογής (πηγαίνετε στον root φάκελο της εφαρμογής, επιλέξτε τα πάντα και δημιουργήστε ένα ZIPfile), θα μπορεί επίσης να το αναλύσει.

MobSF επίσης σας επιτρέπει να κάνετε **diff/Compare** των αναλύσεων και να ενσωματώσετε το **VirusTotal** (θα χρειαστεί να ορίσετε το API key σας στο _MobSF/settings.py_ και να το ενεργοποιήσετε: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Μπορείτε επίσης να θέσετε `VT_UPLOAD` σε `False`, τότε το **hash** θα γίνει **upload** αντί για το αρχείο.

### Βοηθούμενη δυναμική ανάλυση με MobSF

Το **MobSF** μπορεί επίσης να είναι πολύ χρήσιμο για **dynamic analysis** σε **Android**, αλλά σε αυτή την περίπτωση θα χρειαστεί να εγκαταστήσετε το MobSF και το **genymotion** στον host σας (μία VM ή Docker δεν θα λειτουργήσει). _Σημείωση: Πρέπει πρώτα να **ξεκινήσετε μια VM στο genymotion** και μετά να **ξεκινήσετε το MobSF**._\
Ο **MobSF dynamic analyser** μπορεί:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, και άλλα δημιουργημένα αρχεία). Όλα αυτά γίνονται αυτόματα εκτός από τα screenshots — πρέπει να πατήσετε όταν θέλετε ένα screenshot ή να πατήσετε "**Exported Activity Tester**" για να λάβετε screenshots όλων των exported activities.
- Καταγραφή **HTTPS traffic**
- Χρήση του **Frida** για απόκτηση **runtime information**

Από Android **versions > 5**, θα **automatically start Frida** και θα ορίσει global **proxy** ρυθμίσεις για να **capture** traffic. Θα καταγράφει μόνο την κίνηση από την εφαρμογή που δοκιμάζεται.

**Frida**

Κατά προεπιλογή, θα χρησιμοποιήσει επίσης κάποια Frida scripts για να **bypass SSL pinning**, **root detection** και **debugger detection** και για να **monitor interesting APIs**.\
Το MobSF μπορεί επίσης να **invoke exported activities**, να τραβήξει **screenshots** αυτών και να τα **save** στην αναφορά.

Για να **start** το dynamic testing πατήστε το πράσινο κουμπί: "**Start Instrumentation**". Πατήστε το "**Frida Live Logs**" για να δείτε τα logs που παράγονται από τα Frida scripts και το "**Live API Monitor**" για να δείτε όλες τις invocations σε hooked methods, τα arguments που περνάνε και τις επιστρεφόμενες τιμές (αυτό θα εμφανιστεί μετά το πάτημα του "Start Instrumentation").\
Το MobSF επίσης σας επιτρέπει να φορτώσετε τα δικά σας **Frida scripts** (για να στείλετε τα αποτελέσματα των Frida scripts στο MobSF χρησιμοποιήστε τη συνάρτηση `send()`). Έχει επίσης **πολλά προεγγεγραμμένα scripts** που μπορείτε να φορτώσετε (μπορείτε να προσθέσετε περισσότερα στο `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), απλά **επιλέξτε τα**, πατήστε "**Load**" και πατήστε "**Start Instrumentation**" (θα μπορείτε να δείτε τα logs αυτών των scripts μέσα στα "**Frida Live Logs**").

![](<../../images/image (419).png>)

Επιπλέον, έχετε μερικές βοηθητικές λειτουργίες Frida:

- **Enumerate Loaded Classes**: Θα εμφανίσει όλες τις loaded classes
- **Capture Strings**: Θα εμφανίζει όλες τις captured strings κατά τη χρήση της εφαρμογής (πολύ θορυβώδες)
- **Capture String Comparisons**: Μπορεί να είναι πολύ χρήσιμο. Θα δείξει τις 2 strings που συγκρίνονται και αν το αποτέλεσμα ήταν True ή False.
- **Enumerate Class Methods**: Βάλτε το όνομα της κλάσης (π.χ. "java.io.File") και θα εμφανίσει όλες τις μεθόδους της κλάσης.
- **Search Class Pattern**: Αναζήτηση κλάσεων με pattern
- **Trace Class Methods**: **Trace** ολόκληρης της κλάσης (δείτε inputs και outputs όλων των μεθόδων της κλάσης). Θυμηθείτε ότι από προεπιλογή το MobSF κάνει trace αρκετές ενδιαφέρουσες Android Api methods.

Μόλις επιλέξετε το auxiliary module που θέλετε να χρησιμοποιήσετε, πρέπει να πατήσετε "**Start Intrumentation**" και θα δείτε όλες τις εξόδους στα "**Frida Live Logs**".

**Shell**

Το MobSF παρέχει επίσης ένα shell με μερικές εντολές **adb**, **MobSF commands**, και κοινές **shell commands** στο κάτω μέρος της σελίδας δυναμικής ανάλυσης. Μερικές ενδιαφέρουσες εντολές:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP εργαλεία**

Όταν η κίνηση http καταγράφεται μπορείτε να δείτε μια άσχημη προβολή της καταγεγραμμένης κίνησης στο κουμπί "**HTTP(S) Traffic**" ή μια πιο ωραία προβολή στο πράσινο κουμπί "**Start HTTPTools**". Από τη δεύτερη επιλογή, μπορείτε να **στείλετε** τα **καταγεγραμμένα requests** σε **proxies** όπως Burp ή Owasp ZAP.\
Για να το κάνετε, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> πατήστε "**Send to Fuzzer**" --> _επιλέξτε τη διεύθυνση του proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Μόλις ολοκληρώσετε τη δυναμική ανάλυση με MobSF μπορείτε να πατήσετε "**Start Web API Fuzzer**" για να **fuzz http requests** και να αναζητήσετε ευπάθειες.

> [!TIP]
> Μετά την εκτέλεση δυναμικής ανάλυσης με MobSF οι ρυθμίσεις proxy μπορεί να είναι λανθασμένες και να μην μπορείτε να τις διορθώσετε από το GUI. Μπορείτε να διορθώσετε τις ρυθμίσεις proxy κάνοντας:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Βοηθημένη δυναμική ανάλυση με Inspeckage

Μπορείτε να αποκτήσετε το εργαλείο από [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Αυτό το εργαλείο θα χρησιμοποιήσει μερικά **Hooks** για να σας δείξει **τι συμβαίνει στην εφαρμογή** ενώ εκτελείτε μια **δυναμική ανάλυση**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Αυτό είναι ένα **εξαιρετικό εργαλείο για εκτέλεση στατικής ανάλυσης με GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Αυτό το εργαλείο έχει σχεδιαστεί για να αναζητά διάφορες **ευπάθειες σε Android εφαρμογές που σχετίζονται με την ασφάλεια**, είτε στον **πηγαίο κώδικα** είτε σε **packaged APKs**. Το εργαλείο είναι επίσης **ικανό να δημιουργήσει ένα "Proof-of-Concept" deployable APK** και **ADB commands**, για να εκμεταλλευτεί κάποιες από τις βρεθείσες ευπάθειες (Exposed activities, intents, tapjacking...). Όπως και με το Drozer, δεν υπάρχει ανάγκη να κάνετε root στη συσκευή δοκιμών.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Εμφανίζει όλα τα εξαγόμενα αρχεία για εύκολη αναφορά
- Κάνει αυτόματα decompile αρχεία APK σε μορφή Java και Smali
- Αναλύει το AndroidManifest.xml για κοινές ευπάθειες και συμπεριφορά
- Στατική ανάλυση πηγαίου κώδικα για κοινές ευπάθειες και συμπεριφορά
- Πληροφορίες συσκευής
- και άλλα
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

Το SUPER είναι μια εφαρμογή γραμμής εντολών που μπορεί να χρησιμοποιηθεί σε Windows, MacOS X και Linux και αναλύει _.apk_ αρχεία αναζητώντας ευπάθειες. Το κάνει αποσυμπιέζοντας τα APKs και εφαρμόζοντας μια σειρά κανόνων για να εντοπίσει αυτές τις ευπάθειες.

Όλοι οι κανόνες βρίσκονται σε ένα αρχείο `rules.json`, και κάθε εταιρεία ή tester μπορεί να δημιουργήσει τους δικούς της κανόνες για να αναλύσει ό,τι χρειάζεται.

Κατεβάστε τα τελευταία binaries από τη [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn είναι ένα εργαλείο **crossplatform** που βοηθά τους προγραμματιστές, bugbounty hunters και ethical hackers να πραγματοποιούν [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) σε εφαρμογές για κινητά.

Η ιδέα είναι ότι σύρετε και αποθέτετε το αρχείο της εφαρμογής σας (ένα .apk ή .ipa αρχείο) στην εφαρμογή StaCoAn και αυτή θα δημιουργήσει μια οπτική και φορητή αναφορά για εσάς. Μπορείτε να τροποποιήσετε τις ρυθμίσεις και τα wordlists για να αποκτήσετε μια προσαρμοσμένη εμπειρία.

Κατεβάστε[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

Το AndroBugs Framework είναι ένα σύστημα ανάλυσης ευπαθειών για Android που βοηθά προγραμματιστές ή hackers να εντοπίσουν πιθανές ευπάθειες ασφαλείας σε εφαρμογές Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** είναι ένα εργαλείο του οποίου ο κύριος σκοπός είναι να ανιχνεύει και να ειδοποιεί τον χρήστη για πιθανές κακόβουλες συμπεριφορές που αναπτύσσονται από μια εφαρμογή Android.

Η ανίχνευση πραγματοποιείται μέσω της **static analysis** του Dalvik bytecode της εφαρμογής, που αντιπροσωπεύεται ως **Smali**, με τη βιβλιοθήκη [`androguard`](https://github.com/androguard/androguard).

Αυτό το εργαλείο αναζητά **common behavior of "bad" applications** όπως: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Είναι ένα εργαλείο που συγκεντρώνει κοινώς χρησιμοποιούμενα εργαλεία mobile application reverse engineering και analysis, για να βοηθήσει στο testing κινητών εφαρμογών έναντι των OWASP mobile security threats. Στόχος του είναι να κάνει αυτή τη δουλειά πιο εύκολη και φιλική για τους mobile application developers και security professionals.

It is able to:

- Εξάγει Java και Smali code χρησιμοποιώντας διάφορα εργαλεία
- Αναλύει APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Εξάγει private information από το APK χρησιμοποιώντας regexps.
- Αναλύει το Manifest.
- Αναλύει τα βρεθέντα domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Χρήσιμο για ανίχνευση malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Σημειώστε ότι ανάλογα με την υπηρεσία και τη ρύθμιση που χρησιμοποιείτε για να obfuscate τον code, τα secrets μπορεί ή να μην καταλήξουν obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Είναι ικανό να βελτιστοποιεί το bytecode καθώς και να εντοπίζει και να αφαιρεί μη χρησιμοποιούμενες εντολές. Το ProGuard είναι free software και διανέμεται υπό τη GNU General Public License, version 2.

Το ProGuard διανέμεται ως μέρος του Android SDK και τρέχει όταν γίνεται build της εφαρμογής σε release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Βρείτε έναν βήμα-προς-βήμα οδηγό για να deobfuscate το apk στο [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Την τελευταία φορά που ελέγξαμε, ο τρόπος λειτουργίας του Dexguard ήταν:

- φορτώνει ένα resource ως InputStream;
- περνάει το αποτέλεσμα σε μια κλάση που κληρονομεί από FilterInputStream για να το decrypt;
- κάνει κάποια άσκοπη obfuscation για να χάσει μερικά λεπτά από τον reverser;
- περνάει το decrypted αποτέλεσμα σε ένα ZipInputStream για να πάρει ένα DEX file;
- τελικά φορτώνει το προκύπτον DEX ως Resource χρησιμοποιώντας τη μέθοδο `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Μπορείτε να ανεβάσετε ένα obfuscated APK στην πλατφόρμα τους.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Αυτό είναι ένα LLM εργαλείο για να βρει πιθανές security vulnerabilities σε android apps και να deobfuscate τον android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Το Simplify **virtually executes an app** για να κατανοήσει τη συμπεριφορά του και στη συνέχεια **tries to optimize the code** έτσι ώστε να συμπεριφέρεται πανομοιότυπα αλλά να είναι ευκολότερο για έναν άνθρωπο να καταλάβει. Κάθε τύπος optimization είναι απλός και generic, οπότε δεν έχει σημασία ποιος συγκεκριμένος τύπος obfuscation έχει χρησιμοποιηθεί.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. Αναγνωρίζει πολλούς **compilers**, **packers**, **obfuscators**, και άλλα περίεργα πράγματα. Είναι [_PEiD_](https://www.aldeid.com/wiki/PEiD) για Android.

### Manual

[Διαβάστε αυτόν τον οδηγό για να μάθετε μερικά κόλπα για **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate που περιλαμβάνει συλλογή από τα τελευταία framework, tutorials και labs από διαφορετικούς security geeks και researchers για reverse engineering και malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Είναι μια εξαιρετική λίστα πόρων
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Γρήγορο μάθημα Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
