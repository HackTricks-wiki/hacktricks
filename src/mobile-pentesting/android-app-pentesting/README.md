# Android Uygulamaları Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Uygulamaları Temelleri

**Android güvenliği ile ilgili en önemli kısımlar ve bir Android uygulamasındaki en tehlikeli bileşenler** hakkında bilgi edinmek için bu sayfayı okumaya başlamanız şiddetle tavsiye edilir:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Bu, bir android cihazına (emüle edilmiş veya fiziksel) bağlanmak için ihtiyaç duyduğunuz ana araçtır.\
**ADB**, cihazları bir bilgisayardan **USB** veya **Ağ** üzerinden kontrol etmeyi sağlar. Bu yardımcı program, dosyaların her iki yönde **kopyalanmasını**, uygulamaların **yüklenmesini** ve **kaldırılmasını**, kabuk komutlarının **çalıştırılmasını**, verilerin **yedeklenmesini**, **logların okunmasını** ve diğer işlevleri sağlar.

ADB'yi nasıl kullanacağınızı öğrenmek için aşağıdaki [**ADB Komutları**](adb-commands.md) listesine göz atın.

## Smali

Bazen **gizli bilgilere** erişmek için **uygulama kodunu değiştirmek** ilginç olabilir (belki iyi obfuscate edilmiş şifreler veya bayraklar). Bu durumda, apk'yı decompile etmek, kodu değiştirmek ve yeniden derlemek ilginç olabilir.\
[**Bu eğitimde** **APK'yı decompile etmeyi, Smali kodunu değiştirmeyi ve APK'yı yeni işlevsellik ile yeniden derlemeyi** öğrenebilirsiniz](smali-changes.md). Bu, sunulacak dinamik analiz sırasında birkaç test için **alternatif olarak** çok faydalı olabilir. Bu nedenle, **her zaman bu olasılığı aklınızda bulundurun**.

## Diğer ilginç hileler

- [Play Store'da konumunuzu sahtelemek](spoofing-your-location-in-play-store.md)
- [Shizuku Ayrıcalıklı API (ADB tabanlı köksüz ayrıcalıklı erişim)](shizuku-privileged-api.md)
- [Güvensiz Uygulama İçi Güncelleme Mekanizmalarını Sömürmek](insecure-in-app-update-rce.md)
- [Erişilebilirlik Hizmetlerini Kötüye Kullanma (Android RAT)](accessibility-services-abuse.md)
- **APK'ları İndirin**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Cihazdan APK çıkarın:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Tüm bölümleri ve temel apk'ları [APKEditor](https://github.com/REAndroid/APKEditor) ile birleştirin:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Vaka Çalışmaları & Güvenlik Açıkları


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statik Analiz

Öncelikle, bir APK'yı analiz etmek için **Java koduna göz atmalısınız** bir dekompiler kullanarak.\
Lütfen, [**farklı mevcut dekompilerler hakkında bilgi bulmak için burayı okuyun**](apk-decompilers.md).

### İlginç Bilgiler Aramak

APK'nın **string'lerine** bakarak **şifreler**, **URL'ler** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** anahtarları, **şifreleme**, **bluetooth uuids**, **token'lar** ve ilginç olabilecek her şeyi arayabilirsiniz... hatta kod yürütme **arka kapıları** veya kimlik doğrulama arka kapıları (uygulama için hardcoded admin kimlik bilgileri) arayın.

**Firebase**

**firebase URL'lerine** özel dikkat gösterin ve kötü yapılandırılıp yapılandırılmadığını kontrol edin. [Firebase nedir ve nasıl istismar edileceği hakkında daha fazla bilgi burada.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Uygulamanın Temel Anlayışı - Manifest.xml, strings.xml

Bir uygulamanın _Manifest.xml_ ve **_strings.xml_** dosyalarının **incelemesi potansiyel güvenlik açıklarını ortaya çıkarabilir**. Bu dosyalar dekompilerler kullanılarak veya APK dosya uzantısı .zip olarak yeniden adlandırılıp çıkarılarak erişilebilir.

**Manifest.xml** dosyasından tespit edilen **güvenlik açıkları** şunlardır:

- **Hata Ayıklanabilir Uygulamalar**: _Manifest.xml_ dosyasında hata ayıklanabilir (`debuggable="true"`) olarak ayarlanan uygulamalar, istismar edilebilecek bağlantılara izin verdiği için risk taşır. Hata ayıklanabilir uygulamaları nasıl istismar edeceğinizi anlamak için bir cihazda hata ayıklanabilir uygulamaları bulma ve istismar etme üzerine bir eğitime başvurun.
- **Yedekleme Ayarları**: Hassas bilgilerle ilgilenen uygulamalar için `android:allowBackup="false"` niteliği açıkça ayarlanmalıdır, böylece adb üzerinden yetkisiz veri yedeklemeleri önlenir, özellikle usb hata ayıklama etkinleştirildiğinde.
- **Ağ Güvenliği**: _res/xml/_ içindeki özel ağ güvenliği yapılandırmaları (`android:networkSecurityConfig="@xml/network_security_config"`) sertifika pinleri ve HTTP trafiği ayarları gibi güvenlik detaylarını belirtebilir. Örneğin, belirli alanlar için HTTP trafiğine izin vermek.
- **Dışa Aktarılan Aktiviteler ve Servisler**: Manifestte dışa aktarılan aktiviteleri ve servisleri tanımlamak, kötüye kullanılabilecek bileşenleri vurgulayabilir. Dinamik testler sırasında daha fazla analiz, bu bileşenlerin nasıl istismar edileceğini ortaya çıkarabilir.
- **İçerik Sağlayıcıları ve FileProviders**: Açık içerik sağlayıcıları, yetkisiz erişim veya veri değişikliği izni verebilir. FileProviders'ın yapılandırması da incelenmelidir.
- **Broadcast Alıcıları ve URL Şemaları**: Bu bileşenler istismar için kullanılabilir, özellikle URL şemalarının giriş açıkları için nasıl yönetildiğine dikkat edilmelidir.
- **SDK Sürümleri**: `minSdkVersion`, `targetSDKVersion` ve `maxSdkVersion` nitelikleri desteklenen Android sürümlerini gösterir, güvenlik nedenleriyle eski, savunmasız Android sürümlerinin desteklenmemesinin önemini vurgular.

**strings.xml** dosyasından, API anahtarları, özel şemalar ve diğer geliştirici notları gibi hassas bilgiler keşfedilebilir, bu da bu kaynakların dikkatli bir şekilde gözden geçirilmesi gerektiğini vurgular.

### Tapjacking

**Tapjacking**, **kötü niyetli** bir **uygulamanın** başlatıldığı ve **bir kurban uygulamasının üzerine yerleştiği** bir saldırıdır. Kurban uygulamasını görünür bir şekilde gizlediğinde, kullanıcı arayüzü, kullanıcının onunla etkileşimde bulunmasını sağlamak için tasarlanmıştır, oysa etkileşimi kurban uygulamasına iletmektedir.\
Sonuç olarak, bu, **kullanıcının aslında kurban uygulamasında eylem gerçekleştirdiğini bilmesini engellemektedir**.

Daha fazla bilgi bulabilirsiniz:


{{#ref}}
tapjacking.md
{{#endref}}

### Görev Ele Geçirme

**`launchMode`**'u **`singleTask`** olarak ayarlanmış ve herhangi bir `taskAffinity` tanımlanmamış bir **aktivite**, görev ele geçirmeye karşı savunmasızdır. Bu, bir **uygulamanın** yüklenebileceği ve gerçek uygulamadan önce başlatılırsa, **gerçek uygulamanın görevini ele geçirebileceği** anlamına gelir (bu durumda kullanıcı, **gerçek uygulamayı kullanıyormuş gibi kötü niyetli uygulama ile etkileşimde bulunacaktır**).

Daha fazla bilgi için:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Güvensiz veri depolama

**Dahili Depolama**

Android'de, **dahili** depolamada **saklanan** dosyalar yalnızca **oluşturan** **uygulama** tarafından **erişilebilir** olacak şekilde **tasarlanmıştır**. Bu güvenlik önlemi, Android işletim sistemi tarafından **uygulanır** ve çoğu uygulamanın güvenlik ihtiyaçları için genellikle yeterlidir. Ancak, geliştiriciler bazen `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` gibi modlar kullanarak dosyaların farklı uygulamalar arasında **paylaşılmasına** izin verir. Ancak, bu modlar diğer uygulamalar tarafından, potansiyel olarak kötü niyetli olanlar da dahil olmak üzere, bu dosyalara erişimi **kısıtlamaz**.

1. **Statik Analiz:**
- `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` kullanımının **dikkatlice incelenmesini sağlayın**. Bu modlar, dosyaları **istenmeyen veya yetkisiz erişime** açabilir.
2. **Dinamik Analiz:**
- Uygulama tarafından oluşturulan dosyaların üzerindeki **izinleri** **doğrulayın**. Özellikle, herhangi bir dosyanın **dünya çapında okunabilir veya yazılabilir olarak ayarlanıp ayarlanmadığını kontrol edin**. Bu, cihazda yüklü olan **herhangi bir uygulamanın**, kökeni veya niyeti ne olursa olsun, bu dosyaları **okumasına veya değiştirmesine** izin vereceğinden önemli bir güvenlik riski oluşturabilir.

**Harici Depolama**

**Harici depolama** ile ilgili dosyalarla çalışırken, belirli önlemler alınmalıdır:

1. **Erişilebilirlik**:
- Harici depolamadaki dosyalar **genel olarak okunabilir ve yazılabilir**. Bu, herhangi bir uygulamanın veya kullanıcının bu dosyalara erişebileceği anlamına gelir.
2. **Güvenlik Endişeleri**:
- Erişimin kolaylığı göz önüne alındığında, **hassas bilgileri harici depolamada saklamamanız önerilir**.
- Harici depolama, herhangi bir uygulama tarafından çıkarılabilir veya erişilebilir, bu da onu daha az güvenli hale getirir.
3. **Harici Depolamadan Veri İşleme**:
- Harici depolamadan alınan veriler üzerinde her zaman **girdi doğrulaması** yapın. Bu, verilerin güvenilir bir kaynaktan gelmediği için kritik öneme sahiptir.
- Dinamik yükleme için harici depolamada yürütülebilir dosyalar veya sınıf dosyaları saklamak kesinlikle önerilmez.
- Uygulamanız harici depolamadan yürütülebilir dosyalar almak zorundaysa, bu dosyaların dinamik olarak yüklenmeden önce **imzalanmış ve kriptografik olarak doğrulanmış** olduğundan emin olun. Bu adım, uygulamanızın güvenlik bütünlüğünü korumak için hayati öneme sahiptir.

Harici depolama, `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard` konumlarında **erişilebilir**.

> [!TIP]
> Android 4.4 ile birlikte (**API 17**), SD kartın bir dizin yapısı vardır ve bu, **bir uygulamanın yalnızca o uygulama için özel olan dizine erişimini sınırlar**. Bu, kötü niyetli uygulamaların başka bir uygulamanın dosyalarına okuma veya yazma erişimi kazanmasını engeller.

**Açık metin olarak saklanan hassas veriler**

- **Paylaşılan tercihleri**: Android, her uygulamanın `/data/data/<packagename>/shared_prefs/` yolunda xml dosyalarını kolayca saklamasına izin verir ve bazen o klasörde açık metin olarak hassas bilgiler bulmak mümkündür.
- **Veritabanları**: Android, her uygulamanın `/data/data/<packagename>/databases/` yolunda sqlite veritabanlarını kolayca saklamasına izin verir ve bazen o klasörde açık metin olarak hassas bilgiler bulmak mümkündür.

### Kırık TLS

**Tüm Sertifikaları Kabul Etme**

Bazı nedenlerden dolayı, bazen geliştiriciler tüm sertifikaları kabul eder, örneğin, ana bilgisayar adı aşağıdaki gibi kod satırlarıyla eşleşmediğinde:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Bir bunu test etmenin iyi bir yolu, Burp gibi bir proxy kullanarak trafiği yakalamaya çalışmaktır, ancak cihaz içinde Burp CA'yı yetkilendirmeden. Ayrıca, Burp ile farklı bir hostname için bir sertifika oluşturabilir ve bunu kullanabilirsiniz.

### Kırık Kriptografi

**Zayıf Anahtar Yönetim Süreçleri**

Bazı geliştiriciler hassas verileri yerel depolamada saklar ve bunu kodda hardcoded/tahmin edilebilir bir anahtar ile şifreler. Bu yapılmamalıdır çünkü bazı tersine mühendislik işlemleri, saldırganların gizli bilgileri çıkarmasına izin verebilir.

**Güvensiz ve/veya Kullanımdan Kaldırılmış Algoritmaların Kullanımı**

Geliştiriciler, yetkilendirme **kontrolleri**, **veri saklama** veya **gönderme** işlemleri için **kullanımdan kaldırılmış algoritmalar** kullanmamalıdır. Bu algoritmalardan bazıları: RC4, MD4, MD5, SHA1... Örneğin, şifreleri saklamak için **hash'ler** kullanılıyorsa, tuz ile birlikte **brute-force saldırılarına dayanıklı** hash'ler kullanılmalıdır.

### Diğer Kontroller

- **APK'yı obfuscate etmek** önerilir, böylece tersine mühendislik işlemleri saldırganlar için zorlaşır.
- Uygulama hassas ise (örneğin banka uygulamaları), **mobilin köklenip köklenmediğini kontrol etmek için kendi kontrollerini** gerçekleştirmelidir ve buna göre hareket etmelidir.
- Uygulama hassas ise (örneğin banka uygulamaları), bir **emülatör** kullanılıp kullanılmadığını kontrol etmelidir.
- Uygulama hassas ise (örneğin banka uygulamaları), **çalıştırılmadan önce kendi bütünlüğünü kontrol etmelidir**.
- [**APKiD**](https://github.com/rednaga/APKiD) kullanarak APK'nın hangi derleyici/paketleyici/obfuscator ile oluşturulduğunu kontrol edin.

### React Native Uygulaması

React uygulamalarının javascript koduna kolayca erişmeyi öğrenmek için aşağıdaki sayfayı okuyun:

{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Uygulamaları

Xamarin uygulamalarının C# koduna kolayca erişmeyi öğrenmek için aşağıdaki sayfayı okuyun:

{{#ref}}
../xamarin-apps.md
{{#endref}}

### Süper Paketlenmiş Uygulamalar

Bu [**blog yazısına**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) göre süper paketlenmiş, bir uygulamanın içeriğini tek bir dosyaya sıkıştıran bir Meta algoritmadır. Blog, bu tür uygulamaları açan bir uygulama oluşturma olasılığından bahsediyor... ve **uygulamayı çalıştırıp dosya sisteminden açılmış dosyaları toplamak** gibi daha hızlı bir yol.

### Otomatik Statik Kod Analizi

[**mariana-trench**](https://github.com/facebook/mariana-trench) aracı, uygulamanın **kodunu tarayarak** **zayıflıkları** bulma yeteneğine sahiptir. Bu araç, **kullanıcı tarafından kontrol edilen** **giriş** yerlerini gösteren bir dizi **bilinen kaynak** (kaynaklar), kötü niyetli kullanıcı girişinin zarar verebileceği **tehlikeli** **yerleri** gösteren **sinkler** ve **kurallar** içerir. Bu kurallar, bir zayıflığı gösteren **kaynak-sink kombinasyonlarını** belirtir.

Bu bilgiyle, **mariana-trench kodu gözden geçirecek ve olası zayıflıkları bulacaktır**.

### Sızdırılan Gizli Bilgiler

Bir uygulama, içinde keşfedebileceğiniz gizli bilgiler (API anahtarları, şifreler, gizli URL'ler, alt alan adları...) içerebilir. [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) gibi bir araç kullanabilirsiniz.

### Biyometrik Kimlik Doğrulama Atlatma

{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Diğer İlginç Fonksiyonlar

- **Kod yürütme**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **SMS gönderme**: `sendTextMessage, sendMultipartTestMessage`
- **Native fonksiyonlar** `native` olarak tanımlanmıştır: `public native, System.loadLibrary, System.load`
- [Native fonksiyonları **tersine mühendislik yapmayı öğrenmek için bunu okuyun**](reversing-native-libraries.md)

### **Diğer Hileler**

{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamik Analiz

> Öncelikle, uygulamayı ve tüm ortamı (özellikle Burp CA sertifikası, Drozer ve Frida) kurabileceğiniz bir ortama ihtiyacınız var. Bu nedenle, köklü bir cihaz (emüle edilmiş veya değil) son derece önerilir.

### Çevrimiçi Dinamik Analiz

[https://appetize.io/](https://appetize.io) adresinde **ücretsiz bir hesap** oluşturabilirsiniz. Bu platform, APK'ları **yüklemenize** ve **çalıştırmanıza** olanak tanır, bu nedenle bir APK'nın nasıl davrandığını görmek için faydalıdır.

Ayrıca, uygulamanızın **loglarını** webde görebilir ve **adb** üzerinden bağlanabilirsiniz.

![](<../../images/image (831).png>)

ADB bağlantısı sayesinde, emülatörler içinde **Drozer** ve **Frida** kullanabilirsiniz.

### Yerel Dinamik Analiz

#### Bir emülatör kullanarak

- [**Android Studio**](https://developer.android.com/studio) (X86 ve ARM cihazları oluşturabilirsiniz ve [**bu**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**en son x86** sürümleri **ARM kütüphanelerini** yavaş bir ARM emülatörüne ihtiyaç duymadan destekler).
- Bunu ayarlamayı öğrenmek için bu sayfayı okuyun:

{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Ücretsiz sürüm:** Kişisel Sürüm, bir hesap oluşturmanız gerekir. _Potansiyel hataları önlemek için **VirtualBox ile** sürümü **indirmeyi** öneririm._)
- [**Nox**](https://es.bignox.com) (Ücretsiz, ancak Frida veya Drozer'ı desteklemiyor).

> [!TIP]
> Herhangi bir platformda yeni bir emülatör oluştururken, ekranın ne kadar büyük olursa, emülatörün o kadar yavaş çalışacağını unutmayın. Bu nedenle, mümkünse küçük ekranlar seçin.

Genymotion'da **Google hizmetlerini** (AppStore gibi) kurmak için aşağıdaki resmin kırmızı ile işaretlenmiş butonuna tıklamanız gerekir:

![](<../../images/image (277).png>)

Ayrıca, Genymotion'daki **Android VM yapılandırmasında** **Bridge Network mode** seçeneğini seçebileceğinizi unutmayın (bu, Android VM'ye farklı bir VM'den bağlanıyorsanız faydalı olacaktır).

#### Fiziksel bir cihaz kullanma

**Hata ayıklama** seçeneklerini etkinleştirmeniz gerekir ve eğer **kökleyebilirseniz** harika olur:

1. **Ayarlar**.
2. (Android 8.0'dan itibaren) **Sistem**'i seçin.
3. **Telefon Hakkında**'yı seçin.
4. **Build numarasına** 7 kez basın.
5. Geri dönün ve **Geliştirici seçeneklerini** bulacaksınız.

> Uygulamayı kurduktan sonra yapmanız gereken ilk şey, onu denemek ve ne yaptığını, nasıl çalıştığını araştırmak ve onunla rahat olmaktır.\
> **MobSF dinamik analizi + pidcat** kullanarak bu ilk dinamik analizi gerçekleştirmenizi öneririm, böylece MobSF **ilginç** **verileri** toplarken uygulamanın nasıl çalıştığını **öğrenebiliriz**.

### İstenmeyen Veri Sızıntısı

**Günlükleme**

Geliştiriciler, **hata ayıklama bilgilerini** kamuya açık bir şekilde ifşa etme konusunda dikkatli olmalıdır, çünkü bu hassas veri sızıntılarına yol açabilir. Uygulama günlüklerini izlemek ve hassas bilgileri korumak için [**pidcat**](https://github.com/JakeWharton/pidcat) ve `adb logcat` araçları önerilir. **Pidcat**, kullanım kolaylığı ve okunabilirliği nedeniyle tercih edilmektedir.

> [!WARNING]
> **Android 4.0'dan** daha yeni sürümlerden itibaren, **uygulamalar yalnızca kendi günlüklerine erişebilir**. Yani uygulamalar diğer uygulamaların günlüklerine erişemez.\
> Yine de, **hassas bilgileri günlüğe kaydetmemek** önerilir.

**Kopyala/Yapıştır Tamponu Önbellekleme**

Android'in **panoya dayalı** çerçevesi, uygulamalarda kopyala-yapıştır işlevselliği sağlar, ancak **diğer uygulamalar** panoya **erişebileceğinden** hassas verilerin açığa çıkma riski taşır. Hassas bölümler için, örneğin kredi kartı bilgileri gibi, **kopyala/yapıştır** işlevlerini devre dışı bırakmak kritik öneme sahiptir.

**Çökme Günlükleri**

Bir uygulama **çökerse** ve **günlükleri kaydederse**, bu günlükler saldırganlara yardımcı olabilir, özellikle uygulama tersine mühendislik yapılamıyorsa. Bu riski azaltmak için, çökme durumunda günlüğe kaydetmekten kaçının ve eğer günlükler ağ üzerinden iletilmesi gerekiyorsa, güvenlik için SSL kanalı üzerinden gönderildiğinden emin olun.

Pentester olarak, **bu günlükleri incelemeye çalışın**.

**Üçüncü Taraflara Gönderilen Analitik Veriler**

Uygulamalar genellikle Google Adsense gibi hizmetleri entegre eder, bu da geliştiricilerin yanlış uygulaması nedeniyle hassas verilerin **sızmasına** neden olabilir. Potansiyel veri sızıntılarını belirlemek için, uygulamanın trafiğini **yakalamak** ve üçüncü taraf hizmetlere gönderilen hassas bilgileri kontrol etmek önerilir.

### SQLite DB'leri

Çoğu uygulama, bilgileri saklamak için **içsel SQLite veritabanları** kullanacaktır. Pentest sırasında oluşturulan **veritabanlarına**, **tabloların** ve **sütunların** adlarına ve saklanan tüm **verilere** bir **göz atın** çünkü **hassas bilgiler** bulabilirsiniz (bu bir zayıflık olacaktır).\
Veritabanları `/data/data/the.package.name/databases` içinde yer almalıdır, örneğin `/data/data/com.mwr.example.sieve/databases`

Eğer veritabanı gizli bilgileri saklıyorsa ve **şifrelenmişse** ancak uygulama içinde **şifreyi** bulabiliyorsanız, bu hala bir **zayıflıktır**.

Tabloları `.tables` ile listeleyin ve tabloların sütunlarını `.schema <table_name>` ile listeleyin.

### Drozer (Saldırı Aktiviteleri, İçerik Sağlayıcıları ve Servisler)

[Drozer Belgeleri](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)'nden: **Drozer**, bir Android uygulamasının rolünü üstlenmenizi ve diğer uygulamalarla etkileşimde bulunmanızı sağlar. Yüklenmiş bir uygulamanın yapabileceği her şeyi yapabilir, örneğin Android’in Araçlar Arası İletişim (IPC) mekanizmasını kullanabilir ve temel işletim sistemi ile etkileşimde bulunabilir.\
Drozer, **ihracat yapılmış aktiviteleri, ihracat yapılmış servisleri ve İçerik Sağlayıcıları** istismar etmek için yararlı bir araçtır, bunu aşağıdaki bölümlerde öğreneceksiniz.

### İhracat Yapılmış Aktiviteleri İstismar Etme

[**Bir Android Aktivitesinin ne olduğunu tazelemek istiyorsanız bunu okuyun.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ayrıca, bir aktivitenin kodunun **`onCreate`** metodunda başladığını unutmayın.

**Yetkilendirme atlatma**

Bir Aktivite ihracat yapıldığında, dış bir uygulamadan ekranını çağırabilirsiniz. Bu nedenle, **hassas bilgileri** içeren bir aktivite **ihracat** edilmişse, **kimlik doğrulama** mekanizmalarını **atlatabilirsiniz**.

[**Drozer ile ihracat yapılmış aktiviteleri nasıl istismar edeceğinizi öğrenin.**](drozer-tutorial/index.html#activities)

Ayrıca, adb'den ihracat yapılmış bir aktivite başlatabilirsiniz:

- Paket Adı com.example.demo
- İhracat Yapılmış Aktivite Adı com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOT**: MobSF, bir aktivitede `android:launchMode` olarak _**singleTask/singleInstance**_ kullanımını kötü niyetli olarak tespit edecektir, ancak [buna](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) göre, bu durum görünüşe göre yalnızca eski sürümlerde (API sürümleri < 21) tehlikelidir.

> [!İPUCU]
> Bir yetkilendirme atlamanın her zaman bir zafiyet olmadığını unutmayın, bu atlamanın nasıl çalıştığına ve hangi bilgilerin açığa çıktığına bağlıdır.

**Hassas bilgi sızıntısı**

**Aktiviteler ayrıca sonuç döndürebilir**. Eğer **`setResult`** metodunu çağıran ve **hassas bilgi döndüren** bir dışa aktarılmış ve korunmasız aktivite bulursanız, burada bir hassas bilgi sızıntısı vardır.

#### Tapjacking

Eğer tapjacking engellenmezse, dışa aktarılmış aktiviteyi **kullanıcının beklenmedik eylemler gerçekleştirmesi** için kötüye kullanabilirsiniz. Daha fazla bilgi için [**Tapjacking nedir, bağlantıyı takip edin**](#tapjacking).

### İçerik Sağlayıcılarını Sömürme - Hassas bilgilere erişim ve manipülasyon

[**Bir İçerik Sağlayıcının ne olduğunu tazelemek istiyorsanız bunu okuyun.**](android-applications-basics.md#content-provider)\
İçerik sağlayıcılar temelde **veri paylaşmak** için kullanılır. Eğer bir uygulamanın mevcut içerik sağlayıcıları varsa, onlardan **hassas** verileri **çıkartma** imkanınız olabilir. Ayrıca, olası **SQL enjeksiyonlarını** ve **Path Traversals** test etmek de ilginçtir çünkü bunlar zayıf olabilir.

[**Drozer ile İçerik Sağlayıcıları nasıl sömüreceğinizi öğrenin.**](drozer-tutorial/index.html#content-providers)

### **Hizmetleri Sömürme**

[**Bir Hizmetin ne olduğunu tazelemek istiyorsanız bunu okuyun.**](android-applications-basics.md#services)\
Bir Hizmetin eylemlerinin `onStartCommand` metodunda başladığını unutmayın.

Hizmet, temelde **veri alabilen**, **işleyebilen** ve **bir yanıt döndüren** (ya da döndürmeyen) bir şeydir. Dolayısıyla, bir uygulama bazı hizmetleri dışa aktarıyorsa, ne yaptığını anlamak için **kodunu kontrol etmeli** ve **gizli bilgileri çıkartmak, kimlik doğrulama önlemlerini atlamak...** için **dinamik olarak test etmelisiniz**.\
[**Drozer ile Hizmetleri nasıl sömüreceğinizi öğrenin.**](drozer-tutorial/index.html#services)

### **Broadcast Alıcılarını Sömürme**

[**Bir Broadcast Alıcının ne olduğunu tazelemek istiyorsanız bunu okuyun.**](android-applications-basics.md#broadcast-receivers)\
Bir Broadcast Alıcının eylemlerinin `onReceive` metodunda başladığını unutmayın.

Bir yayın alıcısı bir tür mesaj bekleyecektir. Alıcının mesajı nasıl işlediğine bağlı olarak, zayıf olabilir.\
[**Drozer ile Broadcast Alıcılarını nasıl sömüreceğinizi öğrenin.**](#exploiting-broadcast-receivers)

### **Şemaları / Derin bağlantıları Sömürme**

Derin bağlantıları manuel olarak, MobSF gibi araçlar veya [bu script](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) gibi scriptler kullanarak arayabilirsiniz.\
Bir tanımlanmış **şemayı** **adb** veya bir **tarayıcı** kullanarak **açabilirsiniz**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Not edin ki **paket adını atlayabilirsiniz** ve mobil, o bağlantıyı açması gereken uygulamayı otomatik olarak çağıracaktır._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod çalıştırıldı**

Uygulamada **çalıştırılacak kodu** bulmak için, derin bağlantıyla çağrılan aktiviteye gidin ve **`onNewIntent`** fonksiyonunu arayın.

![](<../../images/image (436) (1) (1) (1).png>)

**Hassas bilgi**

Her derin bağlantı bulduğunuzda, **URL parametreleri aracılığıyla hassas veri (şifreler gibi) almadığından emin olun**, çünkü başka bir uygulama **derin bağlantıyı taklit edebilir ve bu veriyi çalabilir!**

**Yolda parametreler**

**URL'nin yolunda bir parametre kullanan herhangi bir derin bağlantıyı da kontrol etmelisiniz**: `https://api.example.com/v1/users/{username}` , bu durumda bir yol geçişi zorlayarak şuna erişebilirsiniz: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Uygulama içinde doğru uç noktaları bulursanız, **Açık Yönlendirme** (eğer yolun bir kısmı alan adı olarak kullanılıyorsa), **hesap ele geçirme** (eğer kullanıcı detaylarını CSRF token olmadan değiştirebiliyorsanız ve zayıf uç nokta doğru yöntemi kullanıyorsa) ve diğer herhangi bir zayıflık oluşturabilirsiniz. Daha fazla [bilgi burada](http://dphoeniixx.com/2020/12/13-2/).

**Daha fazla örnek**

Bağlantılar hakkında [ilginç bir hata avı raporu](https://hackerone.com/reports/855618) (_/.well-known/assetlinks.json_).

### Taşıma Katmanı İncelemesi ve Doğrulama Hataları

- **Sertifikalar her zaman düzgün bir şekilde incelenmez** Android uygulamaları tarafından. Bu uygulamaların uyarıları göz ardı etmesi ve kendinden imzalı sertifikaları kabul etmesi veya bazı durumlarda HTTP bağlantılarına geri dönmesi yaygındır.
- **SSL/TLS el sıkışması sırasında müzakereler bazen zayıftır**, güvensiz şifreleme takımları kullanır. Bu zayıflık, bağlantıyı adam ortası (MITM) saldırılarına karşı savunmasız hale getirir ve saldırganların verileri şifrelerini çözmesine olanak tanır.
- **Özel bilgilerin sızması** güvenli kanallar aracılığıyla kimlik doğrulaması yapan uygulamalar, ancak diğer işlemler için güvenli olmayan kanallar üzerinden iletişim kurduğunda bir risk oluşturur. Bu yaklaşım, oturum çerezleri veya kullanıcı detayları gibi hassas verilerin kötü niyetli varlıklar tarafından ele geçirilmesini korumaz.

#### Sertifika Doğrulama

**Sertifika doğrulama** üzerine odaklanacağız. Sunucunun sertifikasının bütünlüğü, güvenliği artırmak için doğrulanmalıdır. Bu, güvensiz TLS yapılandırmaları ve hassas verilerin şifrelenmemiş kanallar üzerinden iletilmesinin önemli riskler oluşturabileceği için kritik öneme sahiptir. Sunucu sertifikalarını doğrulama ve zayıflıkları ele alma konusunda ayrıntılı adımlar için, [**bu kaynak**](https://manifestsecurity.com/android-application-security-part-10/) kapsamlı rehberlik sağlamaktadır.

#### SSL Pinning

SSL Pinning, uygulamanın sunucunun sertifikasını uygulama içinde saklanan bilinen bir kopya ile doğruladığı bir güvenlik önlemidir. Bu yöntem, MITM saldırılarını önlemek için gereklidir. Hassas bilgi işleyen uygulamalar için SSL Pinning uygulamak şiddetle önerilir.

#### Trafik İncelemesi

HTTP trafiğini incelemek için, **proxy aracının sertifikasını yüklemek** gereklidir (örneğin, Burp). Bu sertifikayı yüklemeden, şifreli trafik proxy üzerinden görünmeyebilir. Özel CA sertifikası yükleme konusunda bir rehber için, [**buraya tıklayın**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

**API Seviye 24 ve üzeri** hedefleyen uygulamalar, proxy'nin CA sertifikasını kabul etmek için Ağ Güvenliği Yapılandırmasında değişiklikler gerektirir. Bu adım, şifreli trafiği incelemek için kritik öneme sahiptir. Ağ Güvenliği Yapılandırmasını değiştirme talimatları için, [**bu eğitime başvurun**](make-apk-accept-ca-certificate.md).

**Flutter** kullanılıyorsa, [**bu sayfadaki**](flutter.md) talimatları takip etmeniz gerekir. Bunun nedeni, sertifikayı depoya eklemenin işe yaramayacak olmasıdır, çünkü Flutter'ın kendi geçerli CA listesi vardır.

#### SSL Pinning'i Atlatma

SSL Pinning uygulandığında, HTTPS trafiğini incelemek için bunu atlatmak gerekli hale gelir. Bu amaçla çeşitli yöntemler mevcuttur:

- **apk'yi otomatik olarak değiştirerek** SSLPinning'i **atlatmak için** [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) kullanabilirsiniz. Bu seçeneğin en iyi yanı, SSL Pinning'i atlatmak için root'a ihtiyacınız olmamasıdır, ancak uygulamayı silip yeni olanı yeniden yüklemeniz gerekecek ve bu her zaman işe yaramayabilir.
- Bu korumayı atlatmak için **Frida** kullanabilirsiniz (aşağıda tartışılmıştır). Burp+Frida+Genymotion kullanma kılavuzunuz burada: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- **SSL Pinning'i otomatik olarak atlatmayı** denemek için [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dinamik analizi** kullanarak da **SSL Pinning'i otomatik olarak atlatmayı** deneyebilirsiniz (aşağıda açıklanmıştır).
- Hala yakalamadığınız bazı trafiğin olduğunu düşünüyorsanız, trafiği **iptables kullanarak burp'a yönlendirmeyi** deneyebilirsiniz. Bu blogu okuyun: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Yaygın Web Zayıflıklarını Arama

Uygulama içinde yaygın web zayıflıklarını da aramak önemlidir. Bu zayıflıkları tanımlama ve hafifletme konusunda ayrıntılı bilgi, bu özetin kapsamının ötesindedir ancak başka yerlerde kapsamlı bir şekilde ele alınmaktadır.

### Frida

[Frida](https://www.frida.re), geliştiriciler, ters mühendisler ve güvenlik araştırmacıları için dinamik bir enstrümantasyon aracıdır.\
**Çalışan uygulamaya erişebilir ve çalışma zamanında yöntemleri yakalayarak davranışını değiştirebilir, değerleri değiştirebilir, değerleri çıkarabilir, farklı kodlar çalıştırabilirsiniz...**\
Android uygulamalarını pentest etmek istiyorsanız, Frida'yı nasıl kullanacağınızı bilmelisiniz.

- Frida'yı nasıl kullanacağınızı öğrenin: [**Frida eğitimi**](frida-tutorial/index.html)
- Frida ile eylemler için bazı "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection, Frida kullanımını otomatikleştirmek için harika: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Burada bazı Harika Frida betikleri bulabilirsiniz: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Frida'yı [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) adresinde belirtildiği gibi yükleyerek anti-debugging / anti-frida mekanizmalarını atlatmayı deneyin (araç [linjector](https://github.com/erfur/linjector-rs))

#### Anti-enstrümantasyon & SSL pinning atlatma iş akışı

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Bellek Dökümü - Fridump**

Uygulamanın, saklamaması gereken hassas bilgileri, örneğin şifreler veya mnemonikler gibi, bellekte saklayıp saklamadığını kontrol edin.

[**Fridump3**](https://github.com/rootbsd/fridump3) kullanarak uygulamanın belleğini dökebilirsiniz:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Bu, belleği ./dump klasörüne dökecektir ve orada şunlarla grep yapabilirsiniz:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore'daki Hassas Veriler**

Android'de Keystore, hassas verileri saklamak için en iyi yerdir, ancak yeterli ayrıcalıklara sahip olunduğunda **erişmek mümkündür**. Uygulamalar burada **hassas verileri düz metin olarak** saklama eğiliminde olduğundan, pentestlerin bunu root kullanıcı olarak kontrol etmesi gerekir; aksi takdirde, cihaza fiziksel erişimi olan birisi bu verileri çalabilir.

Bir uygulama verileri keystore'da saklasa bile, verilerin şifrelenmiş olması gerekir.

Keystore içindeki verilere erişmek için bu Frida script'ini kullanabilirsiniz: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Parmak İzi/Biyometrik Bypass**

Aşağıdaki Frida betiğini kullanarak, Android uygulamalarının **belirli hassas alanları korumak** amacıyla gerçekleştirebileceği **parmak izi kimlik doğrulamasını atlamak** mümkün olabilir:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Arka Plan Görüntüleri**

Bir uygulamayı arka plana aldığınızda, Android **uygulamanın bir anlık görüntüsünü** saklar, böylece ön plana geri döndüğünde, uygulama yüklenmeden önce görüntüyü yüklemeye başlar, böylece uygulamanın daha hızlı yüklendiği izlenimi verir.

Ancak, bu anlık görüntü **hassas bilgiler** içeriyorsa, anlık görüntüye erişimi olan biri bu bilgileri **çalıp alabilir** (erişim için root gereklidir).

Anlık görüntüler genellikle şu konumda saklanır: **`/data/system_ce/0/snapshots`**

Android, **FLAG_SECURE** düzen parametresini ayarlayarak ekran görüntüsü alımını **önlemenin** bir yolunu sağlar. Bu bayrağı kullanarak, pencere içeriği güvenli olarak kabul edilir, ekran görüntülerinde görünmesini veya güvenli olmayan ekranlarda görüntülenmesini engeller.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Uygulama Analizörü**

Bu araç, dinamik analiz sırasında farklı araçları yönetmenize yardımcı olabilir: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Enjeksiyonu

Geliştiriciler genellikle bu Intents'i işleyen ve `startActivity(...)` veya `sendBroadcast(...)` gibi yöntemlere ileten proxy bileşenleri, aktiviteleri ve hizmetleri oluştururlar; bu da riskli olabilir.

Tehlike, saldırganların bu Intents'i yanlış yönlendirerek dışa aktarılmamış uygulama bileşenlerini tetiklemelerine veya hassas içerik sağlayıcılarına erişmelerine izin vermekte yatmaktadır. Dikkate değer bir örnek, URL'leri `Intent` nesnelerine dönüştüren `WebView` bileşenidir; bu, potansiyel olarak kötü niyetli Intent enjeksiyonlarına yol açabilir.

### Temel Çıkarımlar

- **Intent Enjeksiyonu**, webin Açık Yönlendirme sorununa benzer.
- Sömürü, `Intent` nesnelerini ek olarak geçirmeyi içerir; bu, güvensiz işlemleri yürütmek için yönlendirilebilir.
- Dışa aktarılmamış bileşenleri ve içerik sağlayıcılarını saldırganlara açabilir.
- `WebView`’in URL'den `Intent` dönüşümü, istenmeyen eylemleri kolaylaştırabilir.

### Android İstemci Tarafı Enjeksiyonları ve Diğerleri

Bu tür güvenlik açıkları hakkında Web'den bilgi sahibi olmalısınız. Bir Android uygulamasında bu güvenlik açıklarına özellikle dikkat etmelisiniz:

- **SQL Enjeksiyonu:** Dinamik sorgular veya İçerik Sağlayıcılarla çalışırken, parametreli sorgular kullandığınızdan emin olun.
- **JavaScript Enjeksiyonu (XSS):** Herhangi bir WebView için JavaScript ve Eklenti desteğinin devre dışı olduğundan emin olun (varsayılan olarak devre dışıdır). [Daha fazla bilgi burada](webview-attacks.md#javascript-enabled).
- **Yerel Dosya Dahil Etme:** WebView'lerin dosya sistemine erişimi devre dışı olmalıdır (varsayılan olarak etkindir) - `(webview.getSettings().setAllowFileAccess(false);)`. [Daha fazla bilgi burada](webview-attacks.md#javascript-enabled).
- **Sonsuz çerezler**: Birçok durumda, android uygulaması oturumu bitirdiğinde çerez iptal edilmez veya hatta diske kaydedilebilir.
- [**Çerezlerde Güvenli Bayrak**](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Otomatik Analiz

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statik analiz**

![](<../../images/image (866).png>)

**Uygulamanın güvenlik açığı değerlendirmesi**, güzel bir web tabanlı ön yüz kullanarak yapılır. Ayrıca dinamik analiz de gerçekleştirebilirsiniz (ancak ortamı hazırlamanız gerekir).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSF, **Android**(apk)**, IOS**(ipa) **ve Windows**(apx) uygulamalarını (_Windows uygulamaları, Windows ana bilgisayarında kurulu bir MobSF'den analiz edilmelidir_) analiz edebilir.\
Ayrıca, bir **Android** veya **IOS** uygulamasının kaynak koduyla bir **ZIP** dosyası oluşturursanız (uygulamanın kök klasörüne gidin, her şeyi seçin ve bir ZIP dosyası oluşturun), bunu da analiz edebilecektir.

MobSF ayrıca **diff/Compare** analizi yapmanıza ve **VirusTotal** ile entegre olmanıza olanak tanır (API anahtarınızı _MobSF/settings.py_ dosyasında ayarlamanız ve etkinleştirmeniz gerekecek: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Ayrıca `VT_UPLOAD`'u `False` olarak ayarlayabilirsiniz, bu durumda **hash** dosya yerine **yüklenir**.

### MobSF ile Yardımlı Dinamik Analiz

**MobSF**, **Android**'de **dinamik analiz** için de çok yardımcı olabilir, ancak bu durumda MobSF ve **genymotion**'ı ana bilgisayarınıza kurmanız gerekecek (bir VM veya Docker çalışmayacaktır). _Not: Öncelikle **genymotion'da bir VM başlatmalısınız** ve **sonra MobSF'yi başlatmalısınız.**_\
**MobSF dinamik analizörü** şunları yapabilir:

- **Uygulama verilerini dökme** (URL'ler, günlükler, panoya kopyalananlar, sizin yaptığınız ekran görüntüleri, "**Exported Activity Tester**" tarafından yapılan ekran görüntüleri, e-postalar, SQLite veritabanları, XML dosyaları ve diğer oluşturulan dosyalar). Tüm bunlar otomatik olarak yapılır, ekran görüntüleri için istediğinizde basmanız veya tüm dışa aktarılan etkinliklerin ekran görüntülerini elde etmek için "**Exported Activity Tester**" butonuna basmanız gerekir.
- **HTTPS trafiğini yakalama**
- **Çalışma zamanı** **bilgilerini** elde etmek için **Frida** kullanma

Android **sürümleri > 5**'ten itibaren, **Frida**'yı **otomatik olarak başlatacak** ve trafiği **yakalamak** için global **proxy** ayarlarını ayarlayacaktır. Sadece test edilen uygulamadan gelen trafiği yakalayacaktır.

**Frida**

Varsayılan olarak, **SSL pinning**'i **bypass** etmek, **root tespiti** ve **hata ayıklayıcı tespiti** yapmak ve **ilginç API'leri** izlemek için bazı Frida Script'lerini de kullanacaktır.\
MobSF ayrıca **dışa aktarılan etkinlikleri** çağırabilir, bunların **ekran görüntülerini** alabilir ve rapor için **kaydedebilir**.

Dinamik testi **başlatmak** için yeşil butona basın: "**Start Instrumentation**". Frida script'leri tarafından üretilen günlükleri görmek için "**Frida Live Logs**" butonuna basın ve bağlı yöntemlere yapılan tüm çağrıları, geçirilen argümanları ve döndürülen değerleri görmek için "**Live API Monitor**" butonuna basın (bu, "Start Instrumentation" butonuna bastıktan sonra görünecektir).\
MobSF ayrıca kendi **Frida script'lerinizi** yüklemenize olanak tanır (Frida script'lerinizin sonuçlarını MobSF'ye göndermek için `send()` fonksiyonunu kullanın). Ayrıca yükleyebileceğiniz **birçok önceden yazılmış script** vardır (daha fazlasını `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` dizinine ekleyebilirsiniz), sadece **seçin**, "**Load**" butonuna basın ve "**Start Instrumentation**" butonuna basın (bu script'lerin günlüklerini "**Frida Live Logs**" içinde görebileceksiniz).

![](<../../images/image (419).png>)

Ayrıca, bazı Yardımcı Frida işlevsellikleriniz var:

- **Yüklenen Sınıfları Sayma**: Tüm yüklenen sınıfları yazdırır
- **Dizeleri Yakalama**: Uygulamayı kullanırken tüm yakalanan dizeleri yazdırır (çok gürültülü)
- **Dize Karşılaştırmalarını Yakalama**: Çok faydalı olabilir. **Karşılaştırılan 2 dizeyi** gösterecek ve sonucun True veya False olup olmadığını belirtecektir.
- **Sınıf Yöntemlerini Sayma**: Sınıf adını (örneğin "java.io.File") girin ve sınıfın tüm yöntemlerini yazdıracaktır.
- **Sınıf Deseni Arama**: Desene göre sınıfları arama
- **Sınıf Yöntemlerini İzleme**: **Bütün bir sınıfı izleme** (sınıfın tüm yöntemlerinin giriş ve çıkışlarını görme). Unutmayın ki varsayılan olarak MobSF, birkaç ilginç Android API yöntemini izler.

Kullanmak istediğiniz yardımcı modülü seçtikten sonra "**Start Instrumentation**" butonuna basmanız gerekir ve tüm çıktıları "**Frida Live Logs**" içinde göreceksiniz.

**Shell**

MobSF ayrıca dinamik analiz sayfasının altında bazı **adb** komutları, **MobSF komutları** ve yaygın **shell** **komutları** ile bir shell sunar. Bazı ilginç komutlar:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP araçları**

HTTP trafiği yakalandığında, "**HTTP(S) Trafiği**" altında yakalanan trafiğin çirkin bir görünümünü veya "**HTTP Araçlarını Başlat**" yeşil butonunda daha güzel bir görünümünü görebilirsiniz. İkinci seçenekten, **yakalanan istekleri** Burp veya Owasp ZAP gibi **proxy'lere** **gönderebilirsiniz**.\
Bunu yapmak için, _Burp'ı açın -->_ _Intercept'i kapatın --> MobSB HTTP Araçları'nda isteği seçin_ --> "**Fuzzer'a Gönder**" butonuna basın --> _proxy adresini seçin_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF ile dinamik analizi tamamladıktan sonra, **http isteklerini fuzz** etmek ve güvenlik açıklarını aramak için "**Web API Fuzzer'ı Başlat**" butonuna basabilirsiniz.

> [!TIP]
> MobSF ile dinamik bir analiz gerçekleştirdikten sonra proxy ayarları yanlış yapılandırılmış olabilir ve bunları GUI'den düzeltemezsiniz. Proxy ayarlarını düzeltmek için:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage ile Yardımlı Dinamik Analiz

Aracı [**Inspeckage**](https://github.com/ac-pm/Inspeckage) adresinden edinebilirsiniz.\
Bu araç, **dinamik analiz** gerçekleştirirken **uygulamada neler olduğunu** anlamanızı sağlamak için bazı **Hooks** kullanacaktır.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Bu, **GUI ile statik analiz gerçekleştirmek için harika bir araçtır.**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Bu araç, **kaynak kodunda** veya **paketlenmiş APK'larda** çeşitli **güvenlik ile ilgili Android uygulama açıklarını** aramak için tasarlanmıştır. Araç ayrıca, bulunan bazı güvenlik açıklarını (Açık aktiviteler, intentler, tapjacking...) istismar etmek için **"Proof-of-Concept" dağıtılabilir APK** ve **ADB komutları** oluşturma yeteneğine de sahiptir. Drozer ile olduğu gibi, test cihazını root etmenize gerek yoktur.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Kolay referans için tüm çıkarılan dosyaları görüntüler
- APK dosyalarını otomatik olarak Java ve Smali formatına decompile eder
- Yaygın güvenlik açıkları ve davranışlar için AndroidManifest.xml'i analiz eder
- Yaygın güvenlik açıkları ve davranışlar için statik kaynak kodu analizi
- Cihaz bilgisi
- ve daha fazlası
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER, Windows, MacOS X ve Linux'ta kullanılabilen bir komut satırı uygulamasıdır ve güvenlik açıklarını aramak için _.apk_ dosyalarını analiz eder. Bunu, APK'ları sıkıştırmasını açarak ve bu güvenlik açıklarını tespit etmek için bir dizi kural uygulayarak yapar.

Tüm kurallar `rules.json` dosyasında toplanmıştır ve her şirket veya testçi, ihtiyaç duydukları şeyleri analiz etmek için kendi kurallarını oluşturabilir.

En son ikili dosyaları [indirme sayfasından](https://superanalyzer.rocks/download.html) indirin.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn, geliştiricilere, bugbounty avcılarına ve etik hackerlara mobil uygulamalar üzerinde [statik kod analizi](https://en.wikipedia.org/wiki/Static_program_analysis) yapmalarında yardımcı olan **çapraz platform** bir araçtır.

Kavram, mobil uygulama dosyanızı (bir .apk veya .ipa dosyası) StaCoAn uygulamasına sürükleyip bırakmanız ve bunun için size görsel ve taşınabilir bir rapor oluşturmasıdır. Özelleştirilmiş bir deneyim elde etmek için ayarları ve kelime listelerini değiştirebilirsiniz.

[son sürümü](https://github.com/vincentcox/StaCoAn/releases) indirin:
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework, geliştiricilerin veya hackerların Android uygulamalarındaki potansiyel güvenlik açıklarını bulmalarına yardımcı olan bir Android zafiyet analiz sistemidir.\
[Windows sürümleri](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**, bir Android uygulaması tarafından geliştirilen potansiyel kötü niyetli davranışları tespit etmek ve kullanıcıyı uyarmak amacıyla tasarlanmış bir araçtır.

Tespit, uygulamanın Dalvik bytecode'unun **statik analizi** ile gerçekleştirilir ve bu, **Smali** olarak temsil edilir; [`androguard`](https://github.com/androguard/androguard) kütüphanesi kullanılır.

Bu araç, aşağıdaki gibi **"kötü" uygulamaların yaygın davranışlarını** arar: Telefon kimliklerinin sızdırılması, Ses/görüntü akışının kesilmesi, PIM verilerinin değiştirilmesi, Rastgele kod yürütme...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA**, **Mobil Uygulama** **Tersine Mühendislik** ve **Analiz** Çerçevesidir. Bu, mobil uygulamaları OWASP mobil güvenlik tehditlerine karşı test etmeye yardımcı olmak için yaygın olarak kullanılan mobil uygulama tersine mühendislik ve analiz araçlarını bir araya getiren bir araçtır. Amacı, bu görevi mobil uygulama geliştiricileri ve güvenlik profesyonelleri için daha kolay ve daha dostane hale getirmektir.

Şunları yapabilir:

- Farklı araçlar kullanarak Java ve Smali kodunu çıkarmak
- APK'ları analiz etmek için: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- APK'den özel bilgileri regex kullanarak çıkarmak.
- Manifest'i analiz etmek.
- Bulunan alan adlarını analiz etmek için: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) ve [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APK'yi [apk-deguard.com](http://www.apk-deguard.com) üzerinden deşifre etmek.

### Koodous

Kötü amaçlı yazılımları tespit etmek için kullanışlı: [https://koodous.com/](https://koodous.com)

## Kodun Obfuscation/Deobfuscation'ı

Kodu obfuscate etmek için kullandığınız hizmet ve yapılandırmaya bağlı olarak, gizli bilgiler obfuscate edilmiş veya edilmemiş olabilir.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

[Wikipedia'dan](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard**, Java kodunu küçülten, optimize eden ve obfuscate eden açık kaynaklı bir komut satırı aracıdır. Bytecode'u optimize etmenin yanı sıra kullanılmayan talimatları tespit edip kaldırabilir. ProGuard, ücretsiz bir yazılımdır ve GNU Genel Kamu Lisansı, sürüm 2 altında dağıtılmaktadır.

ProGuard, Android SDK'nın bir parçası olarak dağıtılır ve uygulama yayın modunda derlenirken çalışır.

### [DexGuard](https://www.guardsquare.com/dexguard)

APK'yi deşifre etmek için adım adım bir kılavuzu [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html) adresinde bulabilirsiniz.

(Bu kılavuzdan) En son kontrol ettiğimizde, Dexguard çalışma modu şuydu:

- Bir kaynağı InputStream olarak yüklemek;
- Sonucu deşifre etmek için FilterInputStream'den türetilen bir sınıfa beslemek;
- Bir tersine mühendislik uzmanının birkaç dakikasını boşa harcamak için gereksiz obfuscation yapmak;
- Deşifre edilmiş sonucu bir ZipInputStream'e beslemek ve bir DEX dosyası almak;
- Son olarak, elde edilen DEX'i `loadDex` yöntemi kullanarak bir Kaynak olarak yüklemek.

### [DeGuard](http://apk-deguard.com)

**DeGuard, Android obfuscation araçları tarafından gerçekleştirilen obfuscation sürecini tersine çevirir. Bu, kod incelemesi ve kütüphaneleri tahmin etme gibi birçok güvenlik analizini mümkün kılar.**

Obfuscate edilmiş bir APK'yı platformlarına yükleyebilirsiniz.

### [Deobfuscate android App](https://github.com/In3tinct/deobfuscate-android-app)

Bu, Android uygulamalarındaki potansiyel güvenlik açıklarını bulmak ve Android uygulama kodunu deşifre etmek için bir LLM aracıdır. Google'ın Gemini kamu API'sini kullanır.

### [Simplify](https://github.com/CalebFenton/simplify)

Bu, **genel bir android deobfuscator'dır.** Simplify, **bir uygulamayı sanal olarak çalıştırır** ve davranışını anlamaya çalışır ve ardından **kodun optimize edilmesini** sağlar, böylece aynı şekilde davranır ancak bir insanın anlaması daha kolaydır. Her optimizasyon türü basit ve genel olduğundan, kullanılan obfuscation türü önemli değildir.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD, **bir APK'nın nasıl yapıldığını** hakkında bilgi verir. Birçok **derleyici**, **paketleyici**, **obfuscator** ve diğer garip şeyleri tanımlar. Android için [_PEiD_](https://www.aldeid.com/wiki/PEiD) gibidir.

### Manual

[Özel obfuscation'ı nasıl tersine mühendislik yapacağınızı öğrenmek için bu eğitimi okuyun](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b, tersine mühendislik ve kötü amaçlı yazılım analizi için farklı güvenlik uzmanları ve araştırmacılardan en son çerçeve, eğitim ve laboratuvar koleksiyonunu içeren ubuntu-mate tabanlı bir Android güvenlik sanal makinesidir.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Harika bir kaynak listesi
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android hızlı kursu
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
