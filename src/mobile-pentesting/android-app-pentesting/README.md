# Android-Anwendungen Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Grundlagen der Android-Anwendungen

Es wird dringend empfohlen, diese Seite zu lesen, um die **wichtigsten Teile im Zusammenhang mit der Android-Sicherheit und die gefährlichsten Komponenten in einer Android-Anwendung** zu kennen:

{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dies ist das Hauptwerkzeug, das Sie benötigen, um eine Verbindung zu einem Android-Gerät (emuliert oder physisch) herzustellen.\
**ADB** ermöglicht die Steuerung von Geräten entweder über **USB** oder **Netzwerk** von einem Computer aus. Dieses Dienstprogramm ermöglicht das **Kopieren** von Dateien in beide Richtungen, die **Installation** und **Deinstallation** von Apps, die **Ausführung** von Shell-Befehlen, das **Sichern** von Daten, das **Lesen** von Protokollen und viele andere Funktionen.

Werfen Sie einen Blick auf die folgende Liste von [**ADB-Befehlen**](adb-commands.md), um zu lernen, wie man adb verwendet.

## Smali

Manchmal ist es interessant, den **Anwendungscode zu ändern**, um auf **versteckte Informationen** (vielleicht gut obfuskierte Passwörter oder Flags) zuzugreifen. Dann könnte es interessant sein, die apk zu dekompilieren, den Code zu ändern und ihn neu zu kompilieren.\
[**In diesem Tutorial** können Sie **lernen, wie man eine APK dekompiliert, Smali-Code ändert und die APK** mit der neuen Funktionalität **neu kompiliert**](smali-changes.md). Dies könnte sehr nützlich sein als **Alternative für mehrere Tests während der dynamischen Analyse**, die präsentiert werden. Denken Sie daran, **diese Möglichkeit immer im Hinterkopf zu behalten**.

## Weitere interessante Tricks

- [Standort im Play Store fälschen](spoofing-your-location-in-play-store.md)
- **APK herunterladen**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- APK vom Gerät extrahieren:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fügen Sie alle Splits und Basis-APKs mit [APKEditor](https://github.com/REAndroid/APKEditor) zusammen:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Statische Analyse

Zunächst sollten Sie **einen Blick auf den Java-Code** werfen, indem Sie einen Decompiler verwenden.\
Bitte, [**lesen Sie hier, um Informationen über verschiedene verfügbare Decompiler zu finden**](apk-decompilers.md).

### Suche nach interessanten Informationen

Wenn Sie sich die **Strings** der APK ansehen, können Sie nach **Passwörtern**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API**-Schlüsseln, **Verschlüsselung**, **Bluetooth UUIDs**, **Tokens** und allem Interessanten suchen... schauen Sie sogar nach Codeausführungs-**Backdoors** oder Authentifizierungs-Backdoors (hardcodierte Admin-Anmeldeinformationen für die App).

**Firebase**

Achten Sie besonders auf **Firebase-URLs** und überprüfen Sie, ob sie schlecht konfiguriert sind. [Weitere Informationen darüber, was Firebase ist und wie man es ausnutzen kann, finden Sie hier.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Grundverständnis der Anwendung - Manifest.xml, strings.xml

Die **Untersuchung der \_Manifest.xml**_\*\* und \*\*_**strings.xml**\_\*\* Dateien kann potenzielle Sicherheitsanfälligkeiten aufdecken\*\*. Diese Dateien können mit Decompilern oder durch Umbenennen der APK-Dateierweiterung in .zip und anschließendes Entpacken darauf zugegriffen werden.

**Sicherheitsanfälligkeiten**, die aus der **Manifest.xml** identifiziert wurden, umfassen:

- **Debuggable Anwendungen**: Anwendungen, die im _Manifest.xml_ als debuggable (`debuggable="true"`) festgelegt sind, stellen ein Risiko dar, da sie Verbindungen zulassen, die zu einer Ausnutzung führen können. Für ein besseres Verständnis, wie man debuggable Anwendungen ausnutzt, verweisen Sie auf ein Tutorial zum Finden und Ausnutzen von debuggable Anwendungen auf einem Gerät.
- **Backup-Einstellungen**: Das Attribut `android:allowBackup="false"` sollte ausdrücklich für Anwendungen, die mit sensiblen Informationen umgehen, festgelegt werden, um unbefugte Datenbackups über adb zu verhindern, insbesondere wenn USB-Debugging aktiviert ist.
- **Netzwerksicherheit**: Benutzerdefinierte Netzwerksicherheitskonfigurationen (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ können Sicherheitsdetails wie Zertifikatspinning und HTTP-Verkehrseinstellungen spezifizieren. Ein Beispiel ist das Zulassen von HTTP-Verkehr für bestimmte Domains.
- **Exportierte Aktivitäten und Dienste**: Das Identifizieren exportierter Aktivitäten und Dienste im Manifest kann Komponenten hervorheben, die missbraucht werden könnten. Eine weitere Analyse während des dynamischen Testens kann aufzeigen, wie man diese Komponenten ausnutzt.
- **Content Provider und FileProviders**: Exponierte Content Provider könnten unbefugten Zugriff oder Modifikationen von Daten ermöglichen. Die Konfiguration von FileProviders sollte ebenfalls überprüft werden.
- **Broadcast-Empfänger und URL-Schemata**: Diese Komponenten könnten für Ausnutzungen verwendet werden, wobei besonderes Augenmerk darauf gelegt werden sollte, wie URL-Schemata für Eingabeverwundbarkeiten verwaltet werden.
- **SDK-Versionen**: Die Attribute `minSdkVersion`, `targetSDKVersion` und `maxSdkVersion` geben die unterstützten Android-Versionen an und heben die Bedeutung hervor, veraltete, anfällige Android-Versionen aus Sicherheitsgründen nicht zu unterstützen.

Aus der **strings.xml**-Datei können sensible Informationen wie API-Schlüssel, benutzerdefinierte Schemata und andere Entwicklernotizen entdeckt werden, was die Notwendigkeit einer sorgfältigen Überprüfung dieser Ressourcen unterstreicht.

### Tapjacking

**Tapjacking** ist ein Angriff, bei dem eine **bösartige** **Anwendung** gestartet wird und **sich über eine Opferanwendung positioniert**. Sobald sie die Opfer-App sichtbar verdeckt, ist ihre Benutzeroberfläche so gestaltet, dass sie den Benutzer dazu verleitet, mit ihr zu interagieren, während sie die Interaktion an die Opfer-App weiterleitet.\
In der Tat **blendet es den Benutzer aus, sodass er nicht weiß, dass er tatsächlich Aktionen in der Opfer-App ausführt**.

Weitere Informationen finden Sie in:

{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Eine **Aktivität**, deren **`launchMode`** auf **`singleTask`** ohne definierte `taskAffinity` gesetzt ist, ist anfällig für Task Hijacking. Das bedeutet, dass eine **Anwendung** installiert werden kann und, wenn sie vor der echten Anwendung gestartet wird, die **Aufgabe der echten Anwendung übernehmen könnte** (sodass der Benutzer mit der **bösartigen Anwendung interagiert, während er denkt, er verwendet die echte**).

Weitere Informationen finden Sie in:

{{#ref}}
android-task-hijacking.md
{{#endref}}

### Unsichere Datenspeicherung

**Interner Speicher**

In Android sind Dateien, die im **internen** Speicher **gespeichert** werden, **so konzipiert**, dass sie **ausschließlich** von der **App**, die sie **erstellt** hat, **zugänglich** sind. Diese Sicherheitsmaßnahme wird vom Android-Betriebssystem **durchgesetzt** und ist im Allgemeinen ausreichend für die Sicherheitsbedürfnisse der meisten Anwendungen. Entwickler nutzen jedoch manchmal Modi wie `MODE_WORLD_READABLE` und `MODE_WORLD_WRITABLE`, um **Dateien** zwischen verschiedenen Anwendungen **zu teilen**. Diese Modi **beschränken jedoch nicht den Zugriff** auf diese Dateien durch andere Anwendungen, einschließlich potenziell bösartiger.

1. **Statische Analyse:**
- **Stellen Sie sicher**, dass die Verwendung von `MODE_WORLD_READABLE` und `MODE_WORLD_WRITABLE` **sorgfältig überprüft** wird. Diese Modi **könnten potenziell** Dateien **unbeabsichtigt oder unbefugt zugänglich machen**.
2. **Dynamische Analyse:**
- **Überprüfen** Sie die **Berechtigungen**, die für Dateien festgelegt sind, die von der App erstellt wurden. Überprüfen Sie insbesondere, ob Dateien **so eingestellt sind, dass sie weltweit lesbar oder schreibbar sind**. Dies kann ein erhebliches Sicherheitsrisiko darstellen, da es **jeder Anwendung**, die auf dem Gerät installiert ist, unabhängig von ihrer Herkunft oder Absicht, **ermöglicht, diese Dateien zu lesen oder zu ändern**.

**Externer Speicher**

Beim Umgang mit Dateien auf **externem Speicher**, wie SD-Karten, sollten bestimmte Vorsichtsmaßnahmen getroffen werden:

1. **Zugänglichkeit**:
- Dateien auf externem Speicher sind **global lesbar und schreibbar**. Das bedeutet, dass jede Anwendung oder jeder Benutzer auf diese Dateien zugreifen kann.
2. **Sicherheitsbedenken**:
- Angesichts der einfachen Zugänglichkeit wird geraten, **keine sensiblen Informationen** auf externem Speicher zu speichern.
- Externer Speicher kann von jeder Anwendung entfernt oder zugegriffen werden, was ihn weniger sicher macht.
3. **Umgang mit Daten vom externen Speicher**:
- Führen Sie immer **Eingangsvalidierungen** für Daten durch, die vom externen Speicher abgerufen werden. Dies ist entscheidend, da die Daten aus einer nicht vertrauenswürdigen Quelle stammen.
- Das Speichern von ausführbaren Dateien oder Klassen auf externem Speicher für dynamisches Laden wird dringend abgeraten.
- Wenn Ihre Anwendung ausführbare Dateien vom externen Speicher abrufen muss, stellen Sie sicher, dass diese Dateien **signiert und kryptografisch verifiziert** sind, bevor sie dynamisch geladen werden. Dieser Schritt ist entscheidend für die Aufrechterhaltung der Sicherheitsintegrität Ihrer Anwendung.

Externer Speicher kann in `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard` **zugegriffen** werden.

> [!HINWEIS]
> Ab Android 4.4 (**API 17**) hat die SD-Karte eine Verzeichnisstruktur, die **den Zugriff einer App auf das Verzeichnis, das speziell für diese App vorgesehen ist, einschränkt**. Dies verhindert, dass bösartige Anwendungen Lese- oder Schreibzugriff auf die Dateien einer anderen App erhalten.

**Sensible Daten im Klartext gespeichert**

- **Geteilte Präferenzen**: Android ermöglicht es jeder Anwendung, XML-Dateien im Pfad `/data/data/<packagename>/shared_prefs/` einfach zu speichern, und manchmal ist es möglich, sensible Informationen im Klartext in diesem Ordner zu finden.
- **Datenbanken**: Android ermöglicht es jeder Anwendung, SQLite-Datenbanken im Pfad `/data/data/<packagename>/databases/` einfach zu speichern, und manchmal ist es möglich, sensible Informationen im Klartext in diesem Ordner zu finden.

### Gebrochene TLS

**Alle Zertifikate akzeptieren**

Aus irgendeinem Grund akzeptieren Entwickler manchmal alle Zertifikate, selbst wenn beispielsweise der Hostname nicht mit Zeilen von Code wie der folgenden übereinstimmt:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Eine gute Möglichkeit, dies zu testen, besteht darin, den Datenverkehr mit einem Proxy wie Burp zu erfassen, ohne das Burp CA-Zertifikat auf dem Gerät zu autorisieren. Außerdem können Sie mit Burp ein Zertifikat für einen anderen Hostnamen generieren und es verwenden.

### Gebrochene Kryptografie

**Schlechte Schlüsselverwaltungsprozesse**

Einige Entwickler speichern sensible Daten im lokalen Speicher und verschlüsseln sie mit einem im Code hartcodierten/vorhersehbaren Schlüssel. Dies sollte nicht geschehen, da einige Reverse-Engineering-Aktivitäten Angreifern ermöglichen könnten, die vertraulichen Informationen zu extrahieren.

**Verwendung unsicherer und/oder veralteter Algorithmen**

Entwickler sollten keine **veralteten Algorithmen** verwenden, um **Autorisierungsprüfungen** durchzuführen, **Daten zu speichern** oder **zu senden**. Einige dieser Algorithmen sind: RC4, MD4, MD5, SHA1... Wenn **Hashes** beispielsweise zum Speichern von Passwörtern verwendet werden, sollten hash-brute-force **resistente** Hashes mit Salt verwendet werden.

### Weitere Überprüfungen

- Es wird empfohlen, die **APK zu obfuskieren**, um die Reverse-Engineering-Arbeit für Angreifer zu erschweren.
- Wenn die App sensibel ist (wie Bank-Apps), sollte sie **eigene Überprüfungen durchführen, um zu sehen, ob das Mobilgerät gerootet ist**, und entsprechend handeln.
- Wenn die App sensibel ist (wie Bank-Apps), sollte sie überprüfen, ob ein **Emulator** verwendet wird.
- Wenn die App sensibel ist (wie Bank-Apps), sollte sie **ihre eigene Integrität überprüfen, bevor sie ausgeführt wird**, um zu überprüfen, ob sie modifiziert wurde.
- Verwenden Sie [**APKiD**](https://github.com/rednaga/APKiD), um zu überprüfen, welcher Compiler/Packer/Obfuskator zum Erstellen der APK verwendet wurde.

### React Native Anwendung

Lesen Sie die folgende Seite, um zu erfahren, wie Sie einfach auf den JavaScript-Code von React-Anwendungen zugreifen können:

{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin-Anwendungen

Lesen Sie die folgende Seite, um zu erfahren, wie Sie einfach auf den C#-Code von Xamarin-Anwendungen zugreifen können:

{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Anwendungen

Laut diesem [**Blogbeitrag**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) ist Superpacked ein Meta-Algorithmus, der den Inhalt einer Anwendung in eine einzelne Datei komprimiert. Der Blog spricht über die Möglichkeit, eine App zu erstellen, die diese Art von Apps dekomprimiert... und einen schnelleren Weg, der darin besteht, die **Anwendung auszuführen und die dekomprimierten Dateien vom Dateisystem zu sammeln.**

### Automatisierte statische Codeanalyse

Das Tool [**mariana-trench**](https://github.com/facebook/mariana-trench) ist in der Lage, **Schwachstellen** durch **Scannen** des **Codes** der Anwendung zu finden. Dieses Tool enthält eine Reihe von **bekannten Quellen** (die dem Tool die **Stellen** anzeigen, an denen die **Eingabe** **vom Benutzer** **kontrolliert** wird), **Senken** (die dem Tool **gefährliche** **Stellen** anzeigen, an denen bösartige Benutzereingaben Schäden verursachen könnten) und **Regeln**. Diese Regeln zeigen die **Kombination** von **Quellen-Senken**, die auf eine Schwachstelle hinweisen.

Mit diesem Wissen wird **mariana-trench den Code überprüfen und mögliche Schwachstellen darin finden**.

### Geheimnisse geleakt

Eine Anwendung kann Geheimnisse (API-Schlüssel, Passwörter, versteckte URLs, Subdomains...) enthalten, die Sie möglicherweise entdecken können. Sie könnten ein Tool wie [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) verwenden.

### Umgehung der biometrischen Authentifizierung

{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Weitere interessante Funktionen

- **Codeausführung**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **SMS senden**: `sendTextMessage, sendMultipartTestMessage`
- **Native Funktionen** deklariert als `native`: `public native, System.loadLibrary, System.load`
- [Lesen Sie dies, um zu erfahren, **wie man native Funktionen zurückverfolgt**](reversing-native-libraries.md)

### **Weitere Tricks**

{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamische Analyse

> Zunächst benötigen Sie eine Umgebung, in der Sie die Anwendung und die gesamte Umgebung (Burp CA-Zertifikat, Drozer und Frida hauptsächlich) installieren können. Daher wird ein gerootetes Gerät (emuliert oder nicht) dringend empfohlen.

### Online-Dynamische Analyse

Sie können ein **kostenloses Konto** bei: [https://appetize.io/](https://appetize.io) erstellen. Diese Plattform ermöglicht es Ihnen, APKs **hochzuladen** und **auszuführen**, sodass es nützlich ist, um zu sehen, wie sich eine APK verhält.

Sie können sogar **die Protokolle Ihrer Anwendung** im Web sehen und über **adb** verbinden.

![](<../../images/image (831).png>)

Dank der ADB-Verbindung können Sie **Drozer** und **Frida** innerhalb der Emulatoren verwenden.

### Lokale dynamische Analyse

#### Verwendung eines Emulators

- [**Android Studio**](https://developer.android.com/studio) (Sie können **x86** und **arm** Geräte erstellen, und laut [**diesem** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**neueste x86** Versionen **unterstützen ARM-Bibliotheken** ohne einen langsamen ARM-Emulator zu benötigen).
- Lernen Sie, wie Sie es auf dieser Seite einrichten:

{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Kostenlose Version:** Personal Edition, Sie müssen ein Konto erstellen. _Es wird empfohlen, die Version **MIT** _**VirtualBox** herunterzuladen, um potenzielle Fehler zu vermeiden._)
- [**Nox**](https://es.bignox.com) (Kostenlos, unterstützt jedoch kein Frida oder Drozer).

> [!NOTE]
> Denken Sie daran, dass beim Erstellen eines neuen Emulators auf einer beliebigen Plattform der Bildschirm größer ist, desto langsamer wird der Emulator ausgeführt. Wählen Sie also nach Möglichkeit kleine Bildschirme aus.

Um **Google-Dienste** (wie den App Store) in Genymotion zu installieren, müssen Sie auf die rot markierte Schaltfläche im folgenden Bild klicken:

![](<../../images/image (277).png>)

Beachten Sie auch, dass Sie in der **Konfiguration der Android-VM in Genymotion** den **Bridge-Netzwerkmodus** auswählen können (dies wird nützlich sein, wenn Sie von einer anderen VM mit den Tools auf die Android-VM zugreifen möchten).

#### Verwendung eines physischen Geräts

Sie müssen die **Debugging**-Optionen aktivieren, und es wäre gut, wenn Sie es **rooten** könnten:

1. **Einstellungen**.
2. (Ab Android 8.0) Wählen Sie **System**.
3. Wählen Sie **Über das Telefon**.
4. Drücken Sie **Build-Nummer** 7 Mal.
5. Gehen Sie zurück und Sie finden die **Entwickleroptionen**.

> Sobald Sie die Anwendung installiert haben, sollten Sie zunächst versuchen, sie zu verwenden und zu untersuchen, was sie tut, wie sie funktioniert und sich damit vertraut zu machen.\
> Ich empfehle, diese erste dynamische Analyse mit MobSF-Dynamikanalyse + pidcat durchzuführen, damit wir **lernen können, wie die Anwendung funktioniert**, während MobSF eine Menge **interessanter** **Daten** erfasst, die Sie später überprüfen können.

### Unbeabsichtigte Datenlecks

**Protokollierung**

Entwickler sollten vorsichtig sein, **Debugging-Informationen** öffentlich zugänglich zu machen, da dies zu sensiblen Datenlecks führen kann. Die Tools [**pidcat**](https://github.com/JakeWharton/pidcat) und `adb logcat` werden empfohlen, um Anwendungsprotokolle zu überwachen, um sensible Informationen zu identifizieren und zu schützen. **Pidcat** wird wegen seiner Benutzerfreundlichkeit und Lesbarkeit bevorzugt.

> [!WARNING]
> Beachten Sie, dass ab **neueren Versionen als Android 4.0** **Anwendungen nur auf ihre eigenen Protokolle zugreifen können**. Anwendungen können also nicht auf die Protokolle anderer Apps zugreifen.\
> Dennoch wird weiterhin empfohlen, **sensible Informationen nicht zu protokollieren**.

**Zwischenablage-Puffer-Caching**

Das **zwischenablagebasierte** Framework von Android ermöglicht die Copy-Paste-Funktionalität in Apps, birgt jedoch ein Risiko, da **andere Anwendungen** auf die Zwischenablage **zugreifen** können, was potenziell sensible Daten offenlegen könnte. Es ist wichtig, die **Copy/Paste**-Funktionen für sensible Abschnitte einer Anwendung, wie z. B. Kreditkartendaten, zu deaktivieren, um Datenlecks zu verhindern.

**Absturzprotokolle**

Wenn eine Anwendung **abstürzt** und **Protokolle speichert**, können diese Protokolle Angreifern helfen, insbesondere wenn die Anwendung nicht zurückverfolgt werden kann. Um dieses Risiko zu mindern, vermeiden Sie das Protokollieren bei Abstürzen, und wenn Protokolle über das Netzwerk übertragen werden müssen, stellen Sie sicher, dass sie über einen SSL-Kanal zur Sicherheit gesendet werden.

Als Pentester sollten Sie **diese Protokolle überprüfen**.

**Analysedaten, die an Dritte gesendet werden**

Anwendungen integrieren häufig Dienste wie Google Adsense, die unbeabsichtigt **sensible Daten** aufgrund unsachgemäßer Implementierung durch Entwickler **leaken** können. Um potenzielle Datenlecks zu identifizieren, ist es ratsam, den **Datenverkehr der Anwendung abzufangen** und nach sensiblen Informationen zu suchen, die an Dritte gesendet werden.

### SQLite-Datenbanken

Die meisten Anwendungen verwenden **interne SQLite-Datenbanken**, um Informationen zu speichern. Während des Pentests sollten Sie einen **Blick** auf die **Datenbanken** werfen, die erstellt wurden, die Namen der **Tabellen** und **Spalten** sowie alle **gespeicherten Daten**, da Sie **sensible Informationen** finden könnten (was eine Schwachstelle darstellen würde).\
Datenbanken sollten sich in `/data/data/the.package.name/databases` wie `/data/data/com.mwr.example.sieve/databases` befinden.

Wenn die Datenbank vertrauliche Informationen speichert und **verschlüsselt** ist, Sie jedoch das **Passwort** in der Anwendung **finden**, ist es immer noch eine **Schwachstelle**.

Zählen Sie die Tabellen mit `.tables` und zählen Sie die Spalten der Tabellen mit `.schema <table_name>`.

### Drozer (Exploiting Activities, Content Providers und Services)

Aus [Drozer-Dokumentation](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** ermöglicht es Ihnen, **die Rolle einer Android-App zu übernehmen** und mit anderen Apps zu interagieren. Es kann **alles tun, was eine installierte Anwendung tun kann**, wie die Nutzung des Inter-Process Communication (IPC)-Mechanismus von Android und die Interaktion mit dem zugrunde liegenden Betriebssystem.\
Drozer ist ein nützliches Tool, um **exportierte Aktivitäten, exportierte Dienste und Content Provider** auszunutzen, wie Sie in den folgenden Abschnitten lernen werden.

### Ausnutzen exportierter Aktivitäten

[**Lesen Sie dies, wenn Sie auffrischen möchten, was eine Android-Aktivität ist.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Denken Sie auch daran, dass der Code einer Aktivität in der **`onCreate`**-Methode beginnt.

**Autorisierungsumgehung**

Wenn eine Aktivität exportiert ist, können Sie ihren Bildschirm von einer externen App aus aufrufen. Daher könnten Sie, wenn eine Aktivität mit **sensiblen Informationen** **exportiert** ist, die **Authentifizierungsmechanismen** **umgehen**, um darauf zuzugreifen.

[**Erfahren Sie, wie Sie exportierte Aktivitäten mit Drozer ausnutzen.**](drozer-tutorial/index.html#activities)

Sie können auch eine exportierte Aktivität von adb starten:

- Paketname ist com.example.demo
- Exportierte Aktivitätsname ist com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**HINWEIS**: MobSF wird die Verwendung von _**singleTask/singleInstance**_ als `android:launchMode` in einer Aktivität als bösartig erkennen, aber aufgrund von [diesem](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) ist dies anscheinend nur in alten Versionen (API-Versionen < 21) gefährlich.

> [!HINWEIS]
> Beachten Sie, dass ein Autorisierungsumgehung nicht immer eine Schwachstelle ist; es hängt davon ab, wie die Umgehung funktioniert und welche Informationen offengelegt werden.

**Sensibler Informationsleck**

**Aktivitäten können auch Ergebnisse zurückgeben**. Wenn Sie es schaffen, eine exportierte und ungeschützte Aktivität zu finden, die die **`setResult`**-Methode aufruft und **sensible Informationen zurückgibt**, liegt ein sensibler Informationsleck vor.

#### Tapjacking

Wenn Tapjacking nicht verhindert wird, könnten Sie die exportierte Aktivität missbrauchen, um den **Benutzer unerwartete Aktionen** ausführen zu lassen. Für weitere Informationen über [**was Tapjacking ist, folgen Sie dem Link**](#tapjacking).

### Ausnutzen von Content Providern - Zugriff auf und Manipulation von sensiblen Informationen

[**Lesen Sie dies, wenn Sie auffrischen möchten, was ein Content Provider ist.**](android-applications-basics.md#content-provider)\
Content Provider werden im Grunde verwendet, um **Daten zu teilen**. Wenn eine App verfügbare Content Provider hat, können Sie möglicherweise **sensible** Daten von ihnen **extrahieren**. Es ist auch interessant, mögliche **SQL-Injection**- und **Path Traversal**-Angriffe zu testen, da sie anfällig sein könnten.

[**Erfahren Sie, wie Sie Content Provider mit Drozer ausnutzen.**](drozer-tutorial/index.html#content-providers)

### **Ausnutzen von Services**

[**Lesen Sie dies, wenn Sie auffrischen möchten, was ein Service ist.**](android-applications-basics.md#services)\
Denken Sie daran, dass die Aktionen eines Services in der Methode `onStartCommand` beginnen.

Ein Service ist im Grunde etwas, das **Daten empfangen**, sie **verarbeiten** und (oder nicht) eine Antwort **zurückgeben** kann. Wenn eine Anwendung einige Services exportiert, sollten Sie den **Code** überprüfen, um zu verstehen, was er tut, und ihn **dynamisch** testen, um vertrauliche Informationen zu extrahieren, Authentifizierungsmaßnahmen zu umgehen...\
[**Erfahren Sie, wie Sie Services mit Drozer ausnutzen.**](drozer-tutorial/index.html#services)

### **Ausnutzen von Broadcast Receivers**

[**Lesen Sie dies, wenn Sie auffrischen möchten, was ein Broadcast Receiver ist.**](android-applications-basics.md#broadcast-receivers)\
Denken Sie daran, dass die Aktionen eines Broadcast Receivers in der Methode `onReceive` beginnen.

Ein Broadcast Receiver wartet auf eine Art von Nachricht. Je nachdem, wie der Receiver die Nachricht verarbeitet, könnte er anfällig sein.\
[**Erfahren Sie, wie Sie Broadcast Receivers mit Drozer ausnutzen.**](#exploiting-broadcast-receivers)

### **Ausnutzen von Schemes / Deep Links**

Sie können manuell nach Deep Links suchen, indem Sie Tools wie MobSF oder Skripte wie [dieses](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) verwenden.\
Sie können ein deklariertes **Scheme** mit **adb** oder einem **Browser** **öffnen**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Beachten Sie, dass Sie **den Paketnamen weglassen** können und das Mobilgerät automatisch die App aufruft, die diesen Link öffnen sollte._
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code ausgeführt**

Um den **Code zu finden, der in der App ausgeführt wird**, gehe zu der Aktivität, die durch den Deeplink aufgerufen wird, und suche die Funktion **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensible Informationen**

Jedes Mal, wenn du einen Deep Link findest, überprüfe, dass **er keine sensiblen Daten (wie Passwörter) über URL-Parameter empfängt**, da jede andere Anwendung **den Deep Link nachahmen und diese Daten stehlen könnte!**

**Parameter im Pfad**

Du **musst auch überprüfen, ob ein Deep Link einen Parameter im Pfad** der URL verwendet, wie: `https://api.example.com/v1/users/{username}`. In diesem Fall kannst du eine Pfadtraversierung erzwingen, indem du auf etwas wie: `example://app/users?username=../../unwanted-endpoint%3fparam=value` zugreifst.\
Beachte, dass du, wenn du die richtigen Endpunkte innerhalb der Anwendung findest, möglicherweise eine **Open Redirect** verursachen kannst (wenn ein Teil des Pfades als Domainname verwendet wird), **Account-Übernahme** (wenn du die Benutzerdetails ohne CSRF-Token ändern kannst und der verwundbare Endpunkt die richtige Methode verwendet) und jede andere Verwundbarkeit. Mehr [Info dazu hier](http://dphoeniixx.com/2020/12/13-2/).

**Weitere Beispiele**

Ein [interessanter Bug-Bounty-Bericht](https://hackerone.com/reports/855618) über Links (_/.well-known/assetlinks.json_).

### Transport Layer Inspektion und Verifizierungsfehler

- **Zertifikate werden von Android-Anwendungen nicht immer ordnungsgemäß überprüft**. Es ist üblich, dass diese Anwendungen Warnungen ignorieren und selbstsignierte Zertifikate akzeptieren oder in einigen Fällen auf HTTP-Verbindungen zurückgreifen.
- **Verhandlungen während des SSL/TLS-Handshakes sind manchmal schwach**, da unsichere Cipher-Suiten verwendet werden. Diese Verwundbarkeit macht die Verbindung anfällig für Man-in-the-Middle (MITM)-Angriffe, die es Angreifern ermöglichen, die Daten zu entschlüsseln.
- **Leckage privater Informationen** ist ein Risiko, wenn Anwendungen über sichere Kanäle authentifizieren, aber dann über unsichere Kanäle für andere Transaktionen kommunizieren. Dieser Ansatz schützt sensible Daten, wie Sitzungscookies oder Benutzerdetails, nicht vor der Abfangung durch böswillige Akteure.

#### Zertifikatsverifizierung

Wir werden uns auf die **Zertifikatsverifizierung** konzentrieren. Die Integrität des Serverzertifikats muss überprüft werden, um die Sicherheit zu erhöhen. Dies ist entscheidend, da unsichere TLS-Konfigurationen und die Übertragung sensibler Daten über unverschlüsselte Kanäle erhebliche Risiken darstellen können. Für detaillierte Schritte zur Überprüfung von Serverzertifikaten und zur Behebung von Verwundbarkeiten bietet [**dieses Ressourcen**](https://manifestsecurity.com/android-application-security-part-10/) umfassende Anleitungen.

#### SSL-Pinning

SSL-Pinning ist eine Sicherheitsmaßnahme, bei der die Anwendung das Serverzertifikat mit einer bekannten Kopie vergleicht, die innerhalb der Anwendung selbst gespeichert ist. Diese Methode ist entscheidend, um MITM-Angriffe zu verhindern. Die Implementierung von SSL-Pinning wird für Anwendungen, die mit sensiblen Informationen umgehen, dringend empfohlen.

#### Verkehrsinpektion

Um HTTP-Verkehr zu inspizieren, ist es notwendig, das **Zertifikat des Proxy-Tools zu installieren** (z. B. Burp). Ohne die Installation dieses Zertifikats könnte der verschlüsselte Verkehr über den Proxy nicht sichtbar sein. Für eine Anleitung zur Installation eines benutzerdefinierten CA-Zertifikats, [**klicke hier**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Anwendungen, die **API Level 24 und höher** anvisieren, erfordern Änderungen an der Network Security Config, um das CA-Zertifikat des Proxys zu akzeptieren. Dieser Schritt ist entscheidend für die Inspektion von verschlüsseltem Verkehr. Für Anweisungen zur Änderung der Network Security Config, [**siehe dieses Tutorial**](make-apk-accept-ca-certificate.md).

#### Umgehung von SSL-Pinning

Wenn SSL-Pinning implementiert ist, wird es notwendig, es zu umgehen, um HTTPS-Verkehr zu inspizieren. Verschiedene Methoden stehen dafür zur Verfügung:

- Automatisch **modifiziere** die **apk**, um SSL-Pinning mit [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) zu **umgehen**. Der größte Vorteil dieser Option ist, dass du kein Root benötigst, um das SSL-Pinning zu umgehen, aber du musst die Anwendung deinstallieren und die neue installieren, und das funktioniert nicht immer.
- Du könntest **Frida** verwenden (unten besprochen), um diesen Schutz zu umgehen. Hier hast du eine Anleitung zur Verwendung von Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Du kannst auch versuchen, SSL-Pinning **automatisch zu umgehen** mit [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Du kannst auch versuchen, SSL-Pinning **automatisch zu umgehen** mit **MobSF dynamischer Analyse** (unten erklärt).
- Wenn du immer noch denkst, dass es Verkehr gibt, den du nicht erfasst, kannst du versuchen, **den Verkehr mit iptables an burp weiterzuleiten**. Lies diesen Blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Suche nach häufigen Webverwundbarkeiten

Es ist auch wichtig, nach häufigen Webverwundbarkeiten innerhalb der Anwendung zu suchen. Detaillierte Informationen zur Identifizierung und Minderung dieser Verwundbarkeiten gehen über den Rahmen dieser Zusammenfassung hinaus, werden jedoch an anderer Stelle umfassend behandelt.

### Frida

[Frida](https://www.frida.re) ist ein dynamisches Instrumentierungstool für Entwickler, Reverse-Engineers und Sicherheitsforscher.\
**Du kannst laufende Anwendungen zugreifen und Methoden zur Laufzeit hooken, um das Verhalten zu ändern, Werte zu ändern, Werte zu extrahieren, anderen Code auszuführen...**\
Wenn du Android-Anwendungen pentesten möchtest, musst du wissen, wie man Frida verwendet.

- Lerne, wie man Frida verwendet: [**Frida-Tutorial**](frida-tutorial/)
- Eine "GUI" für Aktionen mit Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection ist großartig, um die Verwendung von Frida zu automatisieren: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Du kannst einige großartige Frida-Skripte hier finden: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Versuche, Anti-Debugging / Anti-Frida-Mechanismen zu umgehen, indem du Frida wie in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) angegeben lädst (Tool [linjector](https://github.com/erfur/linjector-rs))

### **Speicher dumpen - Fridump**

Überprüfe, ob die Anwendung sensible Informationen im Speicher speichert, die sie nicht speichern sollte, wie Passwörter oder mnemonische Sätze.

Mit [**Fridump3**](https://github.com/rootbsd/fridump3) kannst du den Speicher der App dumpen mit:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Dies wird den Speicher im ./dump-Ordner ausgeben, und dort könnten Sie mit etwas wie grep:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensible Daten im Keystore**

In Android ist der Keystore der beste Ort, um sensible Daten zu speichern. Mit ausreichenden Rechten ist es jedoch immer noch **möglich, darauf zuzugreifen**. Da Anwendungen dazu neigen, hier **sensible Daten im Klartext** zu speichern, sollten die Pentests dies als Root-Benutzer überprüfen, da jemand mit physischem Zugriff auf das Gerät in der Lage sein könnte, diese Daten zu stehlen.

Selbst wenn eine App Daten im Keystore speichert, sollten die Daten verschlüsselt sein.

Um auf die Daten im Keystore zuzugreifen, können Sie dieses Frida-Skript verwenden: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Mit dem folgenden Frida-Skript könnte es möglich sein, die **Fingerabdruckauthentifizierung** zu umgehen, die Android-Anwendungen möglicherweise durchführen, um **bestimmte sensible Bereiche zu schützen:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Hintergrundbilder**

Wenn Sie eine Anwendung in den Hintergrund setzen, speichert Android einen **Schnappschuss der Anwendung**, sodass beim Wiederherstellen in den Vordergrund das Bild geladen wird, bevor die App, sodass es aussieht, als wäre die App schneller geladen worden.

Wenn dieser Schnappschuss jedoch **sensible Informationen** enthält, könnte jemand mit Zugriff auf den Schnappschuss diese **Informationen stehlen** (beachten Sie, dass Sie Root-Rechte benötigen, um darauf zuzugreifen).

Die Schnappschüsse werden normalerweise unter folgendem Pfad gespeichert: **`/data/system_ce/0/snapshots`**

Android bietet eine Möglichkeit, die **Screenshot-Erfassung zu verhindern, indem der FLAG_SECURE** Layoutparameter gesetzt wird. Durch die Verwendung dieses Flags werden die Fensterinhalte als sicher behandelt, wodurch sie nicht in Screenshots erscheinen oder auf nicht sicheren Displays angezeigt werden können.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Dieses Tool kann Ihnen helfen, verschiedene Tools während der dynamischen Analyse zu verwalten: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Entwickler erstellen häufig Proxy-Komponenten wie Aktivitäten, Dienste und Broadcast-Receiver, die diese Intents verarbeiten und an Methoden wie `startActivity(...)` oder `sendBroadcast(...)` weitergeben, was riskant sein kann.

Die Gefahr liegt darin, Angreifern zu ermöglichen, nicht exportierte App-Komponenten auszulösen oder auf sensible Content-Provider zuzugreifen, indem diese Intents fehlgeleitet werden. Ein bemerkenswertes Beispiel ist die `WebView`-Komponente, die URLs in `Intent`-Objekte über `Intent.parseUri(...)` umwandelt und sie dann ausführt, was potenziell zu bösartigen Intent-Injektionen führen kann.

### Wesentliche Erkenntnisse

- **Intent Injection** ist ähnlich wie das Open Redirect-Problem im Web.
- Exploits beinhalten das Übergeben von `Intent`-Objekten als Extras, die umgeleitet werden können, um unsichere Operationen auszuführen.
- Es kann nicht exportierte Komponenten und Content-Provider für Angreifer zugänglich machen.
- Die URL-zu-`Intent`-Umwandlung von `WebView` kann unbeabsichtigte Aktionen erleichtern.

### Android Client Side Injections und andere

Wahrscheinlich kennen Sie diese Art von Schwachstellen aus dem Web. Sie müssen besonders vorsichtig mit diesen Schwachstellen in einer Android-Anwendung sein:

- **SQL Injection:** Stellen Sie beim Umgang mit dynamischen Abfragen oder Content-Providern sicher, dass Sie parametrisierte Abfragen verwenden.
- **JavaScript Injection (XSS):** Überprüfen Sie, ob JavaScript- und Plugin-Unterstützung für alle WebViews deaktiviert ist (standardmäßig deaktiviert). [Mehr Infos hier](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews sollten keinen Zugriff auf das Dateisystem haben (standardmäßig aktiviert) - `(webview.getSettings().setAllowFileAccess(false);)`. [Mehr Infos hier](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In mehreren Fällen, wenn die Android-Anwendung die Sitzung beendet, wird das Cookie nicht widerrufen oder könnte sogar auf der Festplatte gespeichert werden.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatische Analyse

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statische Analyse**

![](<../../images/image (866).png>)

**Schwachstellenbewertung der Anwendung** mithilfe eines schönen webbasierten Frontends. Sie können auch eine dynamische Analyse durchführen (aber Sie müssen die Umgebung vorbereiten).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Beachten Sie, dass MobSF **Android**(apk)**, IOS**(ipa) **und Windows**(apx) Anwendungen analysieren kann (_Windows-Anwendungen müssen von einem MobSF analysiert werden, das auf einem Windows-Host installiert ist_).\
Wenn Sie außerdem eine **ZIP**-Datei mit dem Quellcode einer **Android**- oder **IOS**-App erstellen (gehen Sie zum Stammordner der Anwendung, wählen Sie alles aus und erstellen Sie eine ZIP-Datei), kann es diese ebenfalls analysieren.

MobSF ermöglicht auch die **Diff/Compare**-Analyse und die Integration von **VirusTotal** (Sie müssen Ihren API-Schlüssel in _MobSF/settings.py_ festlegen und aktivieren: `VT_ENABLED = TRUE` `VT_API_KEY = <Ihr API-Schlüssel>` `VT_UPLOAD = TRUE`). Sie können auch `VT_UPLOAD` auf `False` setzen, dann wird der **Hash** anstelle der Datei **hochgeladen**.

### Unterstützte dynamische Analyse mit MobSF

**MobSF** kann auch sehr hilfreich für die **dynamische Analyse** in **Android** sein, aber in diesem Fall müssen Sie MobSF und **genymotion** auf Ihrem Host installieren (eine VM oder Docker funktioniert nicht). _Hinweis: Sie müssen **zuerst eine VM in genymotion starten** und **dann MobSF.**_\
Der **MobSF-Dynamikanalysator** kann:

- **Anwendungsdaten dumpen** (URLs, Protokolle, Zwischenablage, von Ihnen erstellte Screenshots, Screenshots, die von "**Exported Activity Tester**" erstellt wurden, E-Mails, SQLite-Datenbanken, XML-Dateien und andere erstellte Dateien). All dies geschieht automatisch, außer bei den Screenshots, die Sie drücken müssen, wenn Sie einen Screenshot möchten, oder Sie müssen "**Exported Activity Tester**" drücken, um Screenshots aller exportierten Aktivitäten zu erhalten.
- **HTTPS-Verkehr erfassen**
- **Frida** verwenden, um **Laufzeit**-**informationen** zu erhalten

Ab Android **Versionen > 5** wird **automatisch Frida gestartet** und die globalen **Proxy**-Einstellungen werden festgelegt, um den Verkehr zu **erfassen**. Es wird nur der Verkehr der getesteten Anwendung erfasst.

**Frida**

Standardmäßig werden auch einige Frida-Skripte verwendet, um **SSL-Pinning**, **Root-Erkennung** und **Debugger-Erkennung** zu **umgehen** und um **interessante APIs** zu **überwachen**.\
MobSF kann auch **exportierte Aktivitäten aufrufen**, **Screenshots** davon erfassen und sie für den Bericht **speichern**.

Um den dynamischen Test zu **starten**, drücken Sie die grüne Schaltfläche: "**Start Instrumentation**". Drücken Sie "**Frida Live Logs**", um die von den Frida-Skripten generierten Protokolle zu sehen, und "**Live API Monitor**", um alle Aufrufe an gehookte Methoden, übergebene Argumente und zurückgegebene Werte zu sehen (dies wird nach dem Drücken von "Start Instrumentation" angezeigt).\
MobSF ermöglicht es Ihnen auch, Ihre eigenen **Frida-Skripte** zu laden (um die Ergebnisse Ihrer Frida-Skripte an MobSF zu senden, verwenden Sie die Funktion `send()`). Es hat auch **mehrere vorgefertigte Skripte**, die Sie laden können (Sie können weitere in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` hinzufügen), wählen Sie einfach **diese aus**, drücken Sie "**Load**" und drücken Sie "**Start Instrumentation**" (Sie können die Protokolle dieser Skripte in "**Frida Live Logs**" sehen).

![](<../../images/image (419).png>)

Darüber hinaus haben Sie einige zusätzliche Frida-Funktionalitäten:

- **Geladene Klassen auflisten**: Es werden alle geladenen Klassen ausgegeben.
- **Strings erfassen**: Es werden alle erfassten Strings während der Verwendung der Anwendung ausgegeben (sehr laut).
- **String-Vergleiche erfassen**: Könnte sehr nützlich sein. Es wird **die 2 Strings, die verglichen werden**, und ob das Ergebnis wahr oder falsch war, **anzeigen**.
- **Methoden der Klasse auflisten**: Geben Sie den Klassennamen (wie "java.io.File") ein, und es werden alle Methoden der Klasse ausgegeben.
- **Klassenmuster suchen**: Klassen nach Muster suchen.
- **Methoden der Klasse nachverfolgen**: **Verfolgen** Sie eine **ganze Klasse** (sehen Sie Eingaben und Ausgaben aller Methoden der Klasse). Denken Sie daran, dass MobSF standardmäßig mehrere interessante Android-API-Methoden nachverfolgt.

Sobald Sie das zusätzliche Modul ausgewählt haben, das Sie verwenden möchten, müssen Sie auf "**Start Instrumentation**" drücken, und Sie werden alle Ausgaben in "**Frida Live Logs**" sehen.

**Shell**

Mobsf bietet Ihnen auch eine Shell mit einigen **adb**-Befehlen, **MobSF-Befehlen** und gängigen **Shell**-**Befehlen** am unteren Ende der Seite zur dynamischen Analyse. Einige interessante Befehle:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP-Tools**

Wenn der HTTP-Verkehr erfasst wird, können Sie eine unschöne Ansicht des erfassten Verkehrs auf dem "**HTTP(S) Traffic**" unteren Bereich oder eine schönere Ansicht im "**Start HTTPTools**" grünen Bereich sehen. Von der zweiten Option aus können Sie die **erfassten Anfragen** an **Proxys** wie Burp oder Owasp ZAP **senden**.\
Um dies zu tun, _Burp einschalten -->_ _Intercept ausschalten --> in MobSB HTTPTools die Anfrage auswählen_ --> drücken Sie "**Send to Fuzzer**" --> _wählen Sie die Proxy-Adresse_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sobald Sie die dynamische Analyse mit MobSF abgeschlossen haben, können Sie auf "**Start Web API Fuzzer**" drücken, um **HTTP-Anfragen zu fuzzern** und nach Schwachstellen zu suchen.

> [!NOTE]
> Nach der Durchführung einer dynamischen Analyse mit MobSF können die Proxy-Einstellungen falsch konfiguriert sein, und Sie können sie nicht über die GUI beheben. Sie können die Proxy-Einstellungen beheben, indem Sie:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Unterstützte dynamische Analyse mit Inspeckage

Sie können das Tool von [**Inspeckage**](https://github.com/ac-pm/Inspeckage) erhalten.\
Dieses Tool verwendet einige **Hooks**, um Ihnen mitzuteilen, **was in der Anwendung passiert**, während Sie eine **dynamische Analyse** durchführen.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dies ist ein **großartiges Tool zur Durchführung statischer Analysen mit einer GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Dieses Tool ist darauf ausgelegt, nach mehreren **sicherheitsrelevanten Schwachstellen in Android-Anwendungen** zu suchen, entweder im **Quellcode** oder in **verpackten APKs**. Das Tool ist auch **in der Lage, ein "Proof-of-Concept" deploybares APK** und **ADB-Befehle** zu erstellen, um einige der gefundenen Schwachstellen auszunutzen (Exponierte Aktivitäten, Intents, Tapjacking...). Wie bei Drozer ist es nicht erforderlich, das Testgerät zu rooten.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Zeigt alle extrahierten Dateien zur einfachen Referenz an
- Dekompiliert APK-Dateien automatisch in Java- und Smali-Format
- Analysiert AndroidManifest.xml auf häufige Sicherheitsanfälligkeiten und Verhalten
- Statische Quellcodeanalyse auf häufige Sicherheitsanfälligkeiten und Verhalten
- Geräteinformationen
- und mehr
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER ist eine Befehlszeilenanwendung, die unter Windows, MacOS X und Linux verwendet werden kann und _.apk_-Dateien auf Schwachstellen analysiert. Dies geschieht durch das Dekomprimieren von APKs und das Anwenden einer Reihe von Regeln, um diese Schwachstellen zu erkennen.

Alle Regeln sind in einer `rules.json`-Datei zentriert, und jedes Unternehmen oder Tester kann eigene Regeln erstellen, um das zu analysieren, was sie benötigen.

Laden Sie die neuesten Binärdateien von der [Download-Seite](https://superanalyzer.rocks/download.html) herunter.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn ist ein **plattformübergreifendes** Tool, das Entwicklern, Bug-Bounty-Jägern und ethischen Hackern hilft, [statische Codeanalyse](https://en.wikipedia.org/wiki/Static_program_analysis) von mobilen Anwendungen durchzuführen.

Das Konzept besteht darin, dass Sie Ihre mobile Anwendungsdatei (eine .apk- oder .ipa-Datei) auf die StaCoAn-Anwendung ziehen und ablegen, und es wird Ihnen einen visuellen und tragbaren Bericht erstellen. Sie können die Einstellungen und Wortlisten anpassen, um ein individuelles Erlebnis zu erhalten.

Laden Sie [die neueste Version](https://github.com/vincentcox/StaCoAn/releases) herunter:
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework ist ein Android-Sicherheitsanalyse-System, das Entwicklern oder Hackern hilft, potenzielle Sicherheitsanfälligkeiten in Android-Anwendungen zu finden.\
[Windows-Releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** ist ein Tool, dessen Hauptziel es ist, den Benutzer über potenziell bösartiges Verhalten, das von einer Android-Anwendung entwickelt wurde, zu erkennen und zu warnen.

Die Erkennung erfolgt durch die **statische Analyse** des Dalvik-Bytecodes der Anwendung, dargestellt als **Smali**, mit der [`androguard`](https://github.com/androguard/androguard) Bibliothek.

Dieses Tool sucht nach **häufigen Verhaltensweisen von "schlechten" Anwendungen** wie: Exfiltration von Telefondaten, Abfangen von Audio-/Video-Streams, Modifikation von PIM-Daten, Ausführung beliebigen Codes...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** ist ein **M**obile **A**pplication **R**everse Engineering und **A**nalysis Framework. Es ist ein Tool, das häufig verwendete Tools für das Reverse Engineering und die Analyse von mobilen Anwendungen zusammenführt, um bei der Prüfung mobiler Anwendungen gegen die OWASP-Sicherheitsbedrohungen zu helfen. Ziel ist es, diese Aufgabe für Entwickler mobiler Anwendungen und Sicherheitsfachleute einfacher und benutzerfreundlicher zu gestalten.

Es kann:

- Java- und Smali-Code mit verschiedenen Tools extrahieren
- APKs analysieren mit: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Private Informationen aus der APK mit Regexps extrahieren.
- Das Manifest analysieren.
- Gefundene Domains analysieren mit: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) und [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APKs über [apk-deguard.com](http://www.apk-deguard.com) deobfuskieren

### Koodous

Nützlich zur Erkennung von Malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Beachten Sie, dass je nach Dienst und Konfiguration, die Sie zur Obfuskation des Codes verwenden, Geheimnisse möglicherweise obfuskiert oder nicht obfuskiert sind.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Von [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** ist ein Open-Source-Befehlszeilentool, das Java-Code verkleinert, optimiert und obfuskiert. Es kann Bytecode optimieren sowie ungenutzte Anweisungen erkennen und entfernen. ProGuard ist freie Software und wird unter der GNU General Public License, Version 2, vertrieben.

ProGuard wird als Teil des Android SDK verteilt und läuft beim Erstellen der Anwendung im Release-Modus.

### [DexGuard](https://www.guardsquare.com/dexguard)

Finden Sie eine Schritt-für-Schritt-Anleitung zur Deobfuskation der APK in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Von dieser Anleitung) Das letzte Mal, als wir überprüft haben, war der Dexguard-Betriebsmodus:

- eine Ressource als InputStream laden;
- das Ergebnis an eine Klasse weitergeben, die von FilterInputStream erbt, um es zu entschlüsseln;
- einige nutzlose Obfuskation durchführen, um dem Reverser ein paar Minuten Zeit zu stehlen;
- das entschlüsselte Ergebnis an einen ZipInputStream weitergeben, um eine DEX-Datei zu erhalten;
- schließlich die resultierende DEX als Ressource mit der Methode `loadDex` laden.

### [DeGuard](http://apk-deguard.com)

**DeGuard kehrt den Obfuskationsprozess um, der von Android-Obfuskationstools durchgeführt wird. Dies ermöglicht zahlreiche Sicherheitsanalysen, einschließlich Codeinspektion und Vorhersage von Bibliotheken.**

Sie können eine obfuskierte APK auf ihre Plattform hochladen.

### [Deobfuscate android App](https://github.com/In3tinct/deobfuscate-android-app)

Dies ist ein LLM-Tool, um potenzielle Sicherheitsanfälligkeiten in Android-Apps zu finden und den Code von Android-Apps zu deobfuskieren. Verwendet die öffentliche API von Google Gemini.

### [Simplify](https://github.com/CalebFenton/simplify)

Es ist ein **generischer Android-Deobfuskator.** Simplify **führt eine App virtuell aus**, um ihr Verhalten zu verstehen, und **versucht dann, den Code zu optimieren**, sodass er identisch funktioniert, aber für einen Menschen leichter zu verstehen ist. Jeder Optimierungstyp ist einfach und generisch, sodass es keine Rolle spielt, welcher spezifische Obfuskationstyp verwendet wird.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gibt Ihnen Informationen darüber, **wie eine APK erstellt wurde**. Es identifiziert viele **Compiler**, **Packer**, **Obfuskatoren** und andere seltsame Dinge. Es ist [_PEiD_](https://www.aldeid.com/wiki/PEiD) für Android.

### Manual

[Lesen Sie dieses Tutorial, um einige Tricks zu lernen, **wie man benutzerdefinierte Obfuskation umkehrt**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b ist eine Android-Sicherheitsvirtualmaschine, die auf ubuntu-mate basiert und die Sammlung der neuesten Frameworks, Tutorials und Labs von verschiedenen Sicherheitsgeeks und Forschern für Reverse Engineering und Malware-Analyse umfasst.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Es ist eine großartige Liste von Ressourcen
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android Schnellkurs
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
