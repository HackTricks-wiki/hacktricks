# Android Toepassings Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Toepassings Basiese beginsels

Dit word sterk aanbeveel om eers hierdie bladsy te lees om die **belangrikste dele wat verband hou met Android-sekuriteit en die gevaarlikste komponente in 'n Android-toepassing** te ken:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dit is die hoofinstrument wat jy nodig het om aan 'n Android-toestel te koppel (gesimuleer of fisies).\
**ADB** maak dit moontlik om toestelle óf oor **USB** óf oor **Netwerk** vanaf 'n rekenaar te beheer. Hierdie hulpmiddel stel in staat tot die **kopiering** van lêers in beide rigtings, die **installering** en **verwydering** van apps, die **uitvoering** van shell-opdragte, die **rugsteun** van data, die **lesing** van logs, onder andere funksies.

Kyk na die volgende lys van [**ADB Commands**](adb-commands.md) om te leer hoe om adb te gebruik.

## Smali

Soms is dit interessant om die **aansoekkode te wysig** om by **verborge inligting** te kom (miskien goed geobfuskede wagwoorde of vlae). Dan kan dit interessant wees om die apk te decompileer, die kode te wysig en dit weer te kompileer.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Dit kan baie nuttig wees as 'n **alternatief vir verskeie toetse tydens die dinamiese ontleding** wat aangebied gaan word. Hou dus **hierdie moontlikheid altyd in gedagte**.

## Ander interessante truuks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Play Integrity attestation spoofing (SafetyNet replacement)](play-integrity-attestation-bypass.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Laai APKs af**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Haal APK uit toestel:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Voeg alle splits en base apks saam met [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Aanvalle

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Gevallestudies & Kwetsbaarhede


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Statiese Analise

Eerstens, om 'n APK te analiseer moet jy **die Java code bekyk** met 'n decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Soek na interessante inligting

Deur net die **strings** van die APK te bekyk kan jy soek na **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** en enigiets interessant... kyk selfs vir code execution **backdoors** of authentication backdoors (hardcoded admin credentials in die app).

**Firebase**

Let spesiale aandag aan **firebase URLs** en kontroleer of dit verkeerd gekonfigureer is. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basiese begrip van die toepassing - Manifest.xml, strings.xml

Die **ondersoek van 'n toepassing se _Manifest.xml_ en _strings.xml_ lêers kan potensiële sekuriteitskwesbaarhede aan die lig bring**. Hierdie lêers kan met 'n decompiler verkry word of deur die APK-lêeruitbreiding na .zip te hernoem en dit dan uit te pak.

**Kwetsbaarhede** geïdentifiseer in die **Manifest.xml** sluit in:

- **Debuggable Applications**: Toepassings wat as debuggable gestel is (`debuggable="true"`) in die _Manifest.xml_ lêer vorm 'n risiko aangesien dit verbindings toelaat wat tot uitbuiting kan lei. Vir meer begrip oor hoe om debuggable applications op 'n toestel te vind en uit te buit, sien 'n tutorial oor die onderwerp.
- **Backup Settings**: Die `android:allowBackup="false"` attribuut moet eksplisiet ingestel word vir toepassings wat met sensitiewe inligting handel om ongemagtigde databackups via adb te voorkom, veral wanneer usb debugging aangeskakel is.
- **Network Security**: Pasgemaakte network security-konfigurasies (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ kan sekuriteitsbesonderhede spesifiseer soos certificate pins en HTTP traffic-instellings. 'n Voorbeeld is om HTTP-verkeer vir spesifieke domeine toe te laat.
- **Exported Activities and Services**: Die identifisering van exported activities en services in die manifest kan komponente uitlig wat misbruik kan word. Verdere analise tydens dinamiese toetsing kan aandui hoe om hierdie komponente uit te buit.
- **Content Providers and FileProviders**: Blootgestelde content providers kan ongemagtigde toegang of wysiging van data toelaat. Die konfigurasie van FileProviders moet ook noukeurig nagegaan word.
- **Broadcast Receivers and URL Schemes**: Hierdie komponente kan vir uitbuiting aangewend word, met besondere aandag aan hoe URL schemes vir invoer-kwesbaarhede hanteer word.
- **SDK Versions**: Die `minSdkVersion`, `targetSDKVersion`, en `maxSdkVersion` attributte dui die ondersteunde Android-weergawe aan, wat beklemtoon hoe belangrik dit is om nie verouderde, kwesbare Android-weergawes te ondersteun vir sekuriteitsredes nie.

Uit die **strings.xml** lêer kan sensitiewe inligting soos API keys, pasgemaakte schemas en ander ontwikkelaarnotas gevind word, wat die behoefte aan sorgvuldige hersiening van hierdie hulpbronne beklemtoon.

### Tapjacking

**Tapjacking** is 'n aanval waar 'n **kwaadwillige** **toepassing** gelanseer word en homself bo-op 'n slagoffer-toepassing posisioneer. Sodra dit sigbaar die slagoffer-app belemmer, is die gebruikerskoppelvlak so ontwerp dat dit die gebruiker mislei om daarmee te interakteer, terwyl dit die interaksie aan die slagoffer-app deurgee.\
In effek maak dit die gebruiker **blind vir die feit dat hulle eintlik aksies op die slagoffer-app uitvoer**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

'n **Activity** met die **`launchMode`** ingestel op **`singleTask` sonder enige `taskAffinity`** gedefinieer is kwesbaar vir Task Hijacking. Dit beteken dat 'n **toepassing** geïnstalleer kan word en as dit voor die regte toepassing gelanseer word, dit die taak van die regte toepassing kan kap (sodat die gebruiker met die **kwaadwillige toepassing sal interakteer en dink hy gebruik die regte een**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Onveilige datastoor

**Internal Storage**

In Android is lêers wat in **internal** storage gestoor word bedoel om uitsluitlik deur die **app** wat dit geskep het toeganklik te wees. Hierdie sekuriteitsmaatreël word deur die Android-bedryfstelsel afgedwing en is oor die algemeen voldoende vir die sekuriteitsbehoeftes van die meeste toepassings. Ontwikkelaars gebruik soms egter modusse soos `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` om lêers tussen verskillende toepassings te **deel**. Hierdie modusse **beperk egter nie toegang** tot hierdie lêers deur ander toepassings nie, insluitend potensieel kwaadwillige toepassings.

1. **Static Analysis:**
- **Kontroleer** dat die gebruik van `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` noukeurig ondersoek word. Hierdie modusse **kan lêers moontlik blootstel** aan onbedoelde of ongemagtigde toegang.
2. **Dynamic Analysis:**
- **Verifieer** die **permisse** wat op lêers geskep deur die app gestel is. Kontroleer spesifiek of enige lêers ingestel is om wêreldwyd lees- of skryfbaar te wees. Dit kan 'n beduidende sekuriteitsrisiko wees, aangesien dit enige toepassing wat op die toestel geïnstalleer is, toelaat om hierdie lêers te **lees of wysig**.

**External Storage**

Wanneer jy met lêers op **external storage** werk, soos SD-kaarte, moet sekere voorsorgmaatreëls getref word:

1. **Toeganklikheid**:
- Lêers op external storage is **globaal lees- en skryfbaar**. Dit beteken enige toepassing of gebruiker kan toegang tot hierdie lêers hê.
2. **Sekuriteitskwessies**:
- Gegewe die maklike toegang, word aanbeveel **om nie sensitiewe inligting op external storage te stoor** nie.
- Eksterne berging kan verwyder of deur enige toepassing bereik word, wat dit minder veilig maak.
3. **Hanering van data vanaf external storage**:
- Voer altyd **input validation** uit op data wat van external storage verkry word. Dit is krities aangesien die data uit 'n onbetroubare bron kom.
- Dit word sterk ontmoedig om uitvoerbare lêers of class-lêers op external storage te stoor vir dinamiese laai.
- As jou toepassing moet uitvoerbare lêers vanaf external storage laai, verseker dat hierdie lêers **signed and cryptographically verified** is voordat hulle dinamies gelaai word. Hierdie stap is noodsaaklik vir die behoud van die sekuriteitsintegriteit van jou toepassing.

External storage kan in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` geaccess word

> [!TIP]
> Vanaf Android 4.4 (**API 17**) het die SD-kaart 'n gidsstruktuur wat toegang vanaf 'n app beperk tot die gids wat spesifiek vir daardie app is. Dit voorkom dat kwaadwillige toepassings lees- of skryf toegang tot 'n ander app se lêers kry.

**Gevoelige data in duidelike teks gestoor**

- **Shared preferences**: Android laat elke toepassing toe om maklik xml-lêers in die pad `/data/data/<packagename>/shared_prefs/` te stoor en soms is dit moontlik om sensitiewe inligting in duidelike teks in daardie vouer te vind.
- **Databases**: Android laat elke toepassing toe om maklik sqlite-databasisse in die pad `/data/data/<packagename>/databases/` te stoor en soms is dit moontlik om sensitiewe inligting in duidelike teks in daardie vouer te vind.

### Gebroke TLS

**Accept All Certificates**

Om 'n of ander rede aanvaar ontwikkelaars soms alle sertifikate selfs al stem byvoorbeeld die hostname nie ooreen nie met lyne kode soos die volgende:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
'n Goeie manier om dit te toets is om te probeer die verkeer vas te vang met 'n proxy soos Burp sonder om die Burp CA binne die toestel te autoriseer. Jy kan ook met Burp 'n sertifikaat genereer vir 'n ander hostname en dit gebruik.

### Gebroke Kriptografie

**Slegte Sleutelbestuursprosesse**

Sommige ontwikkelaars stoor sensitiewe data in die plaaslike stoor en enkripteer dit met 'n sleutel wat in die code hardcoded/predictable is. Dit behoort nie gedoen te word nie aangesien reversing aanvallers kan toelaat om die vertroulike inligting uit te trek.

**Gebruik van Onveilige en/of Verouderde Algoritmes**

Ontwikkelaars behoort nie **deprecated algorithms** te gebruik om autorisasie **checks**, data te **store** of te **send** nie. Sommige van hierdie algoritmes is: RC4, MD4, MD5, SHA1... As **hashes** byvoorbeeld gebruik word om wagwoorde te stoor, moet hashes wat bestand is teen brute-force gebruik word, met salt.

### Ander kontroles

- Dit word aanbeveel om die **APK te obfuskeer** om die reverse engineer se werk vir aanvallers moeiliker te maak.
- As die app sensitief is (soos bank apps), moet dit sy **eie kontroles uitvoer om te sien of die mobiele toestel rooted is** en dienooreenkomstig optree.
- As die app sensitief is (soos bank apps), moet dit kontroleer of 'n **emulator** gebruik word.
- As die app sensitief is (soos bank apps), moet dit **sy eie integriteit kontroleer voordat dit uitgevoer word** om te kyk of dit gemodifiseer is.
- Gebruik [**APKiD**](https://github.com/rednaga/APKiD) om te kyk watter compiler/packer/obfuscator gebruik is om die APK te bou

### React Native Application

Lees die volgende blad om te leer hoe om maklik toegang tot die javascript-kode van React applications te kry:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Lees die volgende blad om te leer hoe om maklik toegang tot C#-kode van 'n xamarin applications te kry:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Volgens hierdie [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) is superpacked 'n Meta-algoritme wat die inhoud van 'n toepassing in 'n enkele lêer saamdruk. Die blog praat oor die moontlikheid om 'n app te skep wat hierdie tipe apps dekomprimeer... en 'n vinniger manier wat behels om die toepassing te **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Die hulpmiddel [**mariana-trench**](https://github.com/facebook/mariana-trench) is in staat om **vulnerabilities** te vind deur die **code** van die toepassing te **scan**. Hierdie hulpmiddel bevat 'n reeks **known sources** (wat aan die hulpmiddel aandui die **places** waar die **input** deur die gebruiker beheer word), **sinks** (wat die hulpmiddel aandui **dangerous** **places** waar kwaadwillige gebruikersinvoer skade kan veroorsaak) en **rules**. Hierdie reëls dui die **combination** van **sources-sinks** aan wat 'n kwetsbaarheid aandui.

Met hierdie kennis, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

'n Toepassing mag geheime (API keys, passwords, hidden urls, subdomains...) daarin bevat wat jy dalk kan ontdek. Jy kan 'n hulpmiddel gebruik soos [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Ander interessante funksies

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Lees dit om te leer **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamiese Analise

> Eerstens het jy 'n omgewing nodig waar jy die toepassing en al die omgewing (Burp CA cert, Drozer en Frida hoofsaaklik) kan installeer. Daarom word 'n rooted toestel (geëmuleer of nie) sterk aanbeveel.

### Online Dynamic analysis

Jy kan 'n **gratis rekening** skep by: [https://appetize.io/](https://appetize.io). Hierdie platform laat jou toe om APKs te **upload** en te **execute**, dus dit is nuttig om te sien hoe 'n apk optree.

Jy kan selfs **die logs van jou toepassing** op die web sien en via **adb** koppel.

![](<../../images/image (831).png>)

Danksy die ADB-verbinding kan jy **Drozer** en **Frida** binne die emulators gebruik.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Jy kan **x86** en **arm** toestelle skep, en volgens [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**laatste x86** weergawes **support ARM libraries** sonder om 'n stadiger arm emulator te benodig).
- Leer om dit op te stel op hierdie blad:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, jy moet 'n rekening skep. _Dit word aanbeveel om die weergawe **WITH** _ _**VirtualBox** af te laai om potensiële foute te vermy._)
- [**Nox**](https://es.bignox.com) (Gratis, maar dit ondersteun nie Frida of Drozer nie).

> [!TIP]
> Wanneer jy 'n nuwe emulator op enige platform skep, onthou dat hoe groter die skerm is, hoe stadiger sal die emulator loop. Kies dus, indien moontlik, kleiner skerms.

Om **google services** (soos AppStore) in Genymotion te **installeer** moet jy op die rooi gemerkte knoppie van die volgende beeld klik:

![](<../../images/image (277).png>)

Let ook daarop dat in die **konfigurasie van die Android VM in Genymotion** jy **Bridge Network mode** kan kies (dit sal nuttig wees as jy vanaf 'n ander VM met die hulpmiddels na die Android VM wil koppel).

#### Gebruik 'n fisiese toestel

Jy moet die **debugging**-opsies aktiveer en dit sal goed wees as jy dit kan **root**:

1. **Settings**.
2. (Vanaf Android 8.0) Kies **System**.
3. Kies **About phone**.
4. Druk **Build number** 7 keer.
5. Gaan terug en jy sal die **Developer options** vind.

> Sodra jy die toepassing geïnstalleer het, is die eerste ding wat jy moet doen om dit te probeer en ondersoek wat dit doen, hoe dit werk en gemaklik daarmee raak.\
> Ek stel voor om hierdie aanvanklike dinamiese analise met MobSF dynamic analysis + pidcat uit te voer, sodat ons kan **leer hoe die toepassing werk** terwyl MobSF baie **interesting** **data** vang wat jy later kan nagaan.

Magisk/Zygisk vinnige opmerkings (aanbeveel op Pixel-toestelle)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host

### Onbedoelde Data Leakage

**Logging**

Ontwikkelaars moet versigtig wees om **debugging information** nie openbaar te stel nie, aangesien dit tot sensitiewe data leak kan lei. Die hulpmiddels [**pidcat**](https://github.com/JakeWharton/pidcat) en `adb logcat` word aanbeveel om aansoek-logs te monitor sodat sensitiewe inligting geïdentifiseer en beskerm kan word. **Pidcat** word verkies vir sy gebruiksgemak en lesbaarheid.

> [!WARNING]
> Let daarop dat vanaf **later newer than Android 4.0**, **toepassings slegs toegang tot hul eie logs kan kry**. Toepassings kan dus nie ander apps se logs lees nie.\
> Dit is tog steeds aanbeveel om **nie sensitiewe inligting te log nie**.

**Copy/Paste Buffer Caching**

Android se **clipboard-based** raamwerk maak kopieer-plak funksionaliteit in apps moontlik, maar dit hou 'n risiko in aangesien **ander toepassings** toegang tot die clipboard kan hê en potensieel sensitiewe data kan blootstel. Dit is belangrik om copy/paste funksies vir sensitiewe gedeeltes van 'n toepassing, soos kredietkaartbesonderhede, te onaktief te maak om data leaks te voorkom.

**Crash Logs**

As 'n toepassing **crash** en logs stoor, kan hierdie logs aanvallers help, veral wanneer die toepassing nie maklik gereverse-engineer kan word nie. Om hierdie risiko te verminder, vermy om by crashes te log, en as logs oor die netwerk oorgedra moet word, sorg dat dit oor 'n SSL-kanaal gestuur word vir veiligheid.

As pentester, **probeer om na hierdie logs te kyk**.

**Analytics Data Sent To 3rd Parties**

Toepassings integreer dikwels dienste soos Google Adsense, wat deur onvanpaste implementering deur ontwikkelaars sensitiewe data kan leak. Om potensiële data leaks te identifiseer, is dit raadsaam om die toepassing se verkeer te onderskep en te kontroleer of enige sensitiewe inligting na derde partye gestuur word.

### SQLite DBs

Die meeste toepassings sal **interne SQLite databases** gebruik om inligting te stoor. Tydens die pentest kyk na die **databases** wat geskep is, die name van **tables** en **columns** en al die **data** wat gestoor is, want jy kan sensitiewe inligting vind (wat 'n kwetsbaarheid sou wees).\
Databases behoort te wees in `/data/data/the.package.name/databases` soos `/data/data/com.mwr.example.sieve/databases`

As die database vertroulike inligting stoor en **encrypted** is maar jy die **password** binne die toepassing kan **vind**, is dit steeds 'n **kwetsbaarheid**.

Lys die tables met `.tables` en lys die kolomme van die tables met `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Van [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** laat jou toe om die rol van 'n Android app aan te neem en met ander apps te interakteer. Dit kan **enige iets doen wat 'n geïnstalleerde toepassing kan doen**, soos gebruik maak van Android se Inter-Process Communication (IPC) meganisme en met die onderliggende bedryfstelsel interakteer. .\
Drozer is 'n nuttige hulpmiddel om **exported activities, exported services en Content Providers** te exploit soos jy in die volgende afdelings sal leer.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Onthou ook dat die kode van 'n activity begin in die **`onCreate`** metode.

**Authorisation bypass**

Wanneer 'n Activity exported is, kan jy sy skerm vanaf 'n eksterne app aanroep. Daarom, as 'n activity met **sensitiewe inligting** exported is, kan jy die **authentication** meganismes **bypass** om toegang daartoe te kry.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Jy kan ook 'n exported activity vanaf adb begin:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**LET WEL**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Let wel dat 'n authorisation bypass nie altyd 'n kwetsbaarheid is nie; dit hang af van hoe die bypass werk en watter inligting blootgestel word.

**Sensitiewe inligting leak**

**Aktiwiteite kan ook resultate teruggee**. As jy daarin slaag om 'n exported en onbeveiligde aktiwiteit te vind wat die **`setResult`** metode aanroep en **sensitiewe inligting teruggee**, is daar 'n sensitiewe inligting leak.

#### Tapjacking

As Tapjacking nie voorkom word nie, kan jy die exported aktiwiteit misbruik om die **gebruiker tot onverwagte aksies te laat uitvoer**. Vir meer inligting oor [**wat Tapjacking is volg die skakel**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Lees dit as jy wil opfris wat 'n Content Provider is.**](android-applications-basics.md#content-provider)\
Content providers word hoofsaaklik gebruik om **data te deel**. As 'n app beskikbare content providers het, mag jy in staat wees om **sensitiewe** data daaruit te onttrek. Dit is ook interessant om moontlike **SQL injections** en **Path Traversals** te toets aangesien dit kwesbaar kan wees.

[**Leer hoe om Content Providers met Drozer te exploiteer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Lees dit as jy wil opfris wat 'n Service is.**](android-applications-basics.md#services)\
Onthou dat die aksies van 'n Service begin in die metode `onStartCommand`.

'n Service is hoofsaaklik iets wat **data kan ontvang**, dit kan **verwerk** en 'n antwoord **teruggee** (of nie). Dus, as 'n aansoek sommige services export, moet jy die **kode** nagaan om te verstaan wat dit doen en dit **dinamies** toets om vertroulike info te onttrek, authentication measures te bypass...\
[**Leer hoe om Services met Drozer te exploiteer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Lees dit as jy wil opfris wat 'n Broadcast Receiver is.**](android-applications-basics.md#broadcast-receivers)\
Onthou dat die aksies van 'n Broadcast Receiver begin in die metode `onReceive`.

'n Broadcast Receiver sal wag vir 'n tipe boodskap. Afhangende van hoe die receiver die boodskap hanteer, kan dit kwesbaar wees.\
[**Leer hoe om Broadcast Receivers met Drozer te exploiteer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Jy kan handmatig na deep links soek, met gereedskap soos MobSF of skripte soos [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Jy kan 'n gedeclareerde **scheme** open met **adb** of 'n **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Let daarop dat jy die **pakketnaam kan weglate** en die mobiele toestel sal outomaties die app aanroep wat daardie skakel moet oopmaak._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Uitgevoerde kode**

Om die **kode te vind wat in die App uitgevoer sal word**, gaan na die activity wat deur die deeplink geroep word en soek die funksie **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitiewe inligting**

Elke keer as jy 'n deep link vind, kontroleer dat **dit nie sensitiewe data (soos wagwoorde) via URL-parameters ontvang nie**, want enige ander toepassing kan die deep link naboots en daardie data steel!

**Parameters in path**

Jy moet ook kyk of enige deep link 'n parameter binne die pad van die URL gebruik soos: `https://api.example.com/v1/users/{username}` , in daardie geval kan jy 'n path traversal afdwing deur iets te gebruik soos: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Let daarop dat as jy die korrekte endpoints binne die toepassing vind, jy moontlik 'n **Open Redirect** kan veroorsaak (as 'n deel van die pad as domeinnaam gebruik word), **account takeover** (as jy gebruikersbesonderhede kan wysig sonder 'n CSRF token en die kwesbare endpoint die korrekte metode gebruik) en enige ander vuln. Meer [meer inligting hier](http://dphoeniixx.com/2020/12/13-2/).

**Meer voorbeelde**

'n [Interessante bug bounty verslag](https://hackerone.com/reports/855618) oor links (_/.well-known/assetlinks.json_).

### Transportlaag-inspeksie en verifikasie-foute

- **Sertifikate word nie altyd behoorlik geïnspekteer nie** deur Android-toepassings. Dit is algemeen dat hierdie toepassings waarskuwings ignoreer en self-ondertekende sertifikate aanvaar of in sommige gevalle terugval na HTTP-verbindinge.
- **Onderhandelinge tydens die SSL/TLS-handshake is soms swak**, en gebruik onveilige cipher suites. Hierdie kwesbaarheid maak die verbinding vatbaar vir man-in-the-middle (MITM) aanvalle, wat aanvallers in staat stel om die data te dekodeer.
- **Lek van privaat inligting** is 'n risiko wanneer toepassings met veilige kanale autentiseer, maar dan oor nie-sekuriteitskanale kommunikeer vir ander transaksies. Hierdie benadering beskerm nie sensitiewe data, soos sessie-cookies of gebruikersbesonderhede, teen onderskepping deur kwaadwillige entiteite nie.

#### Sertifikaatverifikasie

Ons sal fokus op **sertifikaatverifikasie**. Die integriteit van die bediener se sertifikaat moet geverifieer word om sekuriteit te verbeter. Dit is noodsaaklik omdat onveilige TLS-konfigurasies en die oordrag van sensitiewe data oor onbeveiligde kanale aansienlike risiko's kan meebring. Vir gedetailleerde stappe oor die verifikasie van bedienersertifikate en die aanspreek van kwesbaarhede, bied [**hierdie hulpbron**](https://manifestsecurity.com/android-application-security-part-10/) omvattende leiding.

#### SSL Pinning

SSL Pinning is 'n sekuriteitsmaatreël waar die toepassing die bediener se sertifikaat verifieer teen 'n bekende kopie wat binne die toepassing self gestoor is. Hierdie metode is noodsaaklik om MITM-aanvalle te voorkom. Die implementering van SSL Pinning word sterk aanbeveel vir toepassings wat sensitiewe inligting hanteer.

#### Verkeerinspeksie

Om HTTP-verkeer te inspekteer, is dit nodig om die **proxy tool se sertifikaat te installeer** (bv. Burp). Sonder om hierdie sertifikaat te installeer mag gekodeerde verkeer nie deur die proxy sigbaar wees nie. Vir 'n gids oor die installering van 'n aangepaste CA-sertifikaat, [**klik hier**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Toepassings wat op **API Level 24 and above** mik, vereis wysigings aan die Network Security Config om die proxy se CA-sertifikaat te aanvaar. Hierdie stap is kritiek vir die inspeksie van gekodeerde verkeer. Vir instruksies oor die wysiging van die Network Security Config, [**verwys na hierdie tutoriaal**](make-apk-accept-ca-certificate.md).

As **Flutter** gebruik word, moet jy die instruksies op [**hierdie bladsy**](flutter.md) volg. Dit is omdat net om die sertifikaat by die store te voeg nie sal werk nie, aangesien Flutter sy eie lys geldige CAs het.

#### Statiese opsporing van SSL/TLS pinning

Voordat jy runtime bypasses probeer, karteer vinnig waar pinning in die APK afgedwing word. Statiese ontdekking help jou om hooks/patches te beplan en op die regte kodepaaie te fokus.

Tool: SSLPinDetect
- Open-source statiese-analise nutsprogram wat die APK na Smali (via apktool) dekompileer en geskikte regex-patrone van SSL/TLS pinning implementasies skandeer.
- Rapporteer die presiese lêerpad, reëlnommer, en 'n kodefragment vir elke treffers.
- Dek gewone frameworks en pasgemaakte kodepaaie: OkHttp CertificatePinner, pasgemaakte javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init met pasgemaakte TrustManagers/KeyManagers, en Network Security Config XML pins.

Installeer
- Vereistes: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Gebruik
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Voorbeeld patroonreëls (JSON)
Gebruik of brei signatures uit om proprietary/custom pinning styles op te spoor. Jy kan jou eie JSON laai en op skaal scan.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Aantekeninge en wenke
- Fast scanning on large apps via multi-threading and memory-mapped I/O; pre-compiled regex reduces overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Tipiese deteksie-teikens om daarna te triage:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp pakketverwysings
- Aangepaste TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Aangepaste SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Deklaratiewe pins in res/xml network security config en manifest verwysings
- Gebruik die ooreenstemmende lokasies om Frida hooks, static patches, of config reviews te beplan voordat jy dinamiese toetsing doen.



#### Omseiling van SSL Pinning

Wanneer SSL Pinning geïmplementeer is, word dit nodig om dit te omseil om HTTPS-verkeer te inspekteer. Verskeie metodes is beskikbaar vir hierdie doel:

- Automaties **modify** die **apk** om **bypass** SSLPinning met [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Die grootste voordeel van hierdie opsie is dat jy nie root nodig sal hê om die SSL Pinning te bypass nie, maar jy sal die toepassing moet verwyder en die nuwe een moet herinstalleer, en dit werk nie altyd nie.
- Jy kan **Frida** (bespreek hieronder) gebruik om hierdie beskerming te bypass. Hier is 'n gids om Burp+Frida+Genymotion te gebruik: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Jy kan ook probeer om **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Jy kan ook probeer om **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- As jy steeds dink daar is verkeer wat jy nie vasvang nie, kan jy probeer om die verkeer na Burp te stuur deur iptables te gebruik. Lees hierdie blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Op soek na algemene webkwetsbaarhede

Dit is belangrik om ook binne die toepassing na algemene webkwetsbaarhede te soek. Gedetaileerde inligting oor die identifisering en versagting van hierdie kwesbaarhede val buite die omvang van hierdie opsomming, maar word elders uitvoerig behandel.

### Frida

[Frida](https://www.frida.re) is 'n dinamiese instrumenterings-toolkit vir ontwikkelaars, reverse-engineers, en sekuriteitsnavorsers.\
**Jy kan toegang kry tot 'n lopende toepassing en hook methods op run time om die gedrag te verander, waardes te wysig, waardes te onttrek, of ander kode uit te voer...**\
As jy Android-toepassings wil pentest, moet jy weet hoe om Frida te gebruik.

- Leer hoe om Frida te gebruik: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" vir aksies met Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Probeer om anti-debugging / anti-frida mechanisms te bypass deur Frida te laai soos aangedui in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentasie & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Kontroleer of die toepassing sensitiewe inligting in die geheue stoor wat dit nie behoort te stoor nie, soos wagwoorde of mnemonics.

Deur [**Fridump3**](https://github.com/rootbsd/fridump3) te gebruik kan jy die geheue van die app dump met:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Dit sal die geheue in die ./dump-gids dump, en daarbinne kan jy met grep iets soos:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitiewe data in Keystore**

In Android is die Keystore die beste plek om sensitiewe data te stoor, maar met voldoende voorregte is dit steeds **moontlik om toegang daartoe te kry**. Aangesien toepassings hier geneig is om **sensitiewe data in clear text** te stoor, behoort pentests dit as root user te kontroleer, aangesien iemand met fisiese toegang tot die toestel hierdie data kan steel.

Selfs as 'n app data in die keystore gestoor het, behoort die data geënkripteer te wees.

Om toegang tot die data binne die keystore te kry, kan jy hierdie Frida script gebruik: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Met die volgende Frida script kan dit moontlik wees om **bypass fingerprint authentication** wat Android-toepassings mag uitvoer om sekere sensitiewe gebiede te beskerm, te omseil:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Agtergrondbeelde**

Wanneer jy 'n toepassing op die agtergrond plaas, stoor Android 'n **momentopname van die toepassing** sodat wanneer dit na die voorgrond herstel word dit begin om die beeld te laai voor die app, sodat dit lyk asof die app vinniger gelaai is.

As hierdie momentopname egter **gevoelige inligting** bevat, kan iemand met toegang tot die momentopname daardie inligting **steel** (let wel: jy benodig root om toegang daartoe te kry).

Die momentopnames word gewoonlik gestoor by: **`/data/system_ce/0/snapshots`**

Android bied 'n manier om die **screenshot-opname te voorkom deur die FLAG_SECURE** layout-parameter te stel. Wanneer hierdie vlag gebruik word, word die vensterinhoud as veilig behandel en verhoed dat dit in screenshots verskyn of op onveilige skerms besigtig word.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Hierdie hulpmiddel kan jou help om verskillende gereedskap tydens dinamiese ontleding te bestuur: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Ontwikkelaars skep dikwels proxy-komponente soos activities, services, en broadcast receivers wat hierdie Intents hanteer en dit aan metodes soos `startActivity(...)` of `sendBroadcast(...)` deurgee, wat gevaarlik kan wees.

Die gevaar lê daarin dat aanvallers toegelaat kan word om nie-eksporteerde app-komponente of sensitiewe content providers te aktiveer deur hierdie Intents verkeerd te stuur. 'n Noemenswaardige voorbeeld is die `WebView`-komponent wat URLs omskakel na `Intent`-objekte via `Intent.parseUri(...)` en dit dan uitvoer, wat moontlik tot kwaadwillige Intent injections kan lei.

### Essential Takeaways

- **Intent Injection** is soortgelyk aan die web se Open Redirect-kwessie.
- Eksploite behels die deurgee van `Intent`-objekte as extras, wat herlei kan word om onveilige operasies uit te voer.
- Dit kan nie-eksporteerde komponente en content providers aan aanvallers blootstel.
- `WebView` se URL-na-`Intent`-omskakeling kan onbedoelde aksies moontlik maak.

### Android Client Side Injections and others

Jy ken waarskynlik hierdie soort kwesbaarhede van die web af. Jy moet veral versigtig wees met hierdie kwesbaarhede in 'n Android-toepassing:

- **SQL Injection:** Wanneer jy met dinamiese navrae of Content-Providers werk, maak seker dat jy geparameteriseerde navrae gebruik.
- **JavaScript Injection (XSS):** Bevestig dat JavaScript- en Plugin-ondersteuning vir enige WebViews gedeaktiveer is (standaard gedeaktiveer). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews behoort toegang tot die lêerstelsel gedeaktiveer te hê (standaard geaktiveer) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In verskeie gevalle wanneer die Android-toepassing die sessie beëindig word, word die cookie nie intrekk nie of dit kan selfs na skyf geskryf word
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statiese ontleding**

![](<../../images/image (866).png>)

**Kwetsbaarheidsassessering van die toepassing** wat 'n mooi web-gebaseerde frontend gebruik. Jy kan ook dinamiese ontleding uitvoer (maar jy moet die omgewing voorberei).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Let wel dat MobSF **Android**(apk)**, IOS**(ipa) **and Windows**(apx) toepassings kan ontleed (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
As jy ook 'n **ZIP**-lêer met die bronkode van 'n **Android** of 'n **IOS** app skep (gaan na die root folder van die toepassing, kies alles en skep 'n ZIPfile), kan dit dit ook ontleed.

MobSF laat jou ook toe om **diff/Compare** analises en om **VirusTotal** te integreer (jy sal jou API sleutel in _MobSF/settings.py_ moet stoor en dit aktiveer: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Jy kan ook `VT_UPLOAD` op `False` stel, dan sal die **hash** in plaas van die lêer **upload** word.

### Assisted Dynamic analysis with MobSF

**MobSF** kan ook baie nuttig wees vir **dynamic analysis** in **Android**, maar in daardie geval sal jy MobSF en **genymotion** op jou host moet installeer (n VM of Docker sal nie werk nie). _Nota: Jy moet eers 'n VM in genymotion start en **dan MobSF.**_\
Die **MobSF dynamic analyser** kan:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, en ander geskepte lêers). Al hierdie dinge gebeur outomaties behalwe vir die screenshots — jy moet die knoppie druk wanneer jy 'n screenshot wil neem of jy moet op "**Exported Activity Tester**" druk om screenshots van al die exported activities te kry.
- Capture **HTTPS traffic**
- Use **Frida** om **runtime** **information** te verkry

From android **versions > 5**, dit sal **automatically start Frida** en globale **proxy** instellings instel om verkeer te **capture**. Dit sal slegs verkeer van die getoetste toepassing vasvang.

**Frida**

By default, sal dit ook sommige Frida Scripts gebruik om **bypass SSL pinning**, **root detection** en **debugger detection** te doen en om **monitor interesting APIs**.\
MobSF kan ook **invoke exported activities**, screenshots van hulle gryp en dit **save** vir die verslag.

Om die dinamiese toetsing te **start** druk die groen knoppie: "**Start Instrumentation**". Druk die "**Frida Live Logs**" om die logs wat deur die Frida scripts geskep is te sien en "**Live API Monitor**" om al die aanroepe na hooked methods, argumente wat deurgegee is en teruggegewe waardes te sien (dit sal verskyn nadat jy op "Start Instrumentation" gedruk het).\
MobSF laat jou ook toe om jou eie **Frida scripts** te laai (om die resultate van jou Frida scripts na MobSF te stuur gebruik die funksie `send()`). Dit het ook **several pre-written scripts** wat jy kan laai (jy kan meer byvoeg in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), kies net **hulle**, druk "**Load**" en druk "**Start Instrumentation**" (jy sal die logs van daardie scripts binne "**Frida Live Logs**" kan sien).

![](<../../images/image (419).png>)

Verder beskik jy oor sommige aanvullende Frida funksionaliteite:

- **Enumerate Loaded Classes**: Dit sal alle geladen klasse druk
- **Capture Strings**: Dit sal alle gevangen strings druk terwyl die toepassing gebruik word (baie noisy)
- **Capture String Comparisons**: Baie nuttig. Dit sal **die 2 strings wat vergelyk word** en of die resultaat True of False was wys.
- **Enumerate Class Methods**: Plaas die klasnaam (soos "java.io.File") en dit sal al die metodes van die klas druk.
- **Search Class Pattern**: Soek klasse per patroon
- **Trace Class Methods**: **Trace** 'n **hele klas** (sien insette en uitsette van al die metodes van die klas). Onthou dat standaard MobSF verskeie interessante Android Api metodes trace.

Sodra jy die hulpmodule gekies het wat jy wil gebruik, moet jy op "**Start Intrumentation**" druk en jy sal al die uitsette in "**Frida Live Logs**" sien.

**Shell**

MobSF bring ook 'n shell met sommige **adb** commands, **MobSF commands**, en algemene **shell** **commands** onderaan die dinamiese analise bladsy. Sommige interessante commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Wanneer HTTP-verkeer vasgelê word, kan jy 'n lelike oorsig van die vasgelêde verkeer sien op die "**HTTP(S) Traffic**" knoppie onderaan of 'n netter weergawe by die "**Start HTTPTools**" groen knoppie. Vanaf die tweede opsie kan jy die **send** die **captured requests** na **proxies** soos Burp of Owasp ZAP stuur.\
Om dit te doen, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sodra jy die dynamic analysis met MobSF voltooi het, kan jy op "**Start Web API Fuzzer**" druk om **fuzz http requests** te doen en na kwesbaarhede te soek.

> [!TIP]
> Na die uitvoering van 'n dynamic analysis met MobSF kan die proxy-instellings verkeerd gekonfigureer raak en sal jy dit nie vanuit die GUI kan regstel nie. Jy kan die proxy-instellings regmaak deur:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Jy kan die hulpmiddel kry by [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Hierdie hulpmiddel gebruik sommige **Hooks** om jou te wys **what is happening in the application** terwyl jy 'n **dynamic analysis** uitvoer.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dit is 'n **geweldige hulpmiddel om static analysis met 'n GUI uit te voer**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Hierdie hulpmiddel is ontwerp om na verskeie **security related Android application vulnerabilities** te soek, hetsy in **source code** of **packaged APKs**. Die hulpmiddel is ook **capable of creating a "Proof-of-Concept" deployable APK** en **ADB commands**, om sommige van die gevonde kwesbaarhede te benut (Exposed activities, intents, tapjacking...). Soos met Drozer, is daar geen behoefte om die toets-toestel te root nie.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Vertoon alle uitgepakte lêers vir maklike verwysing
- Dekompileer APK-lêers outomaties na Java- en Smali-formaat
- Analiseer AndroidManifest.xml vir algemene kwesbaarhede en gedrag
- Statiese source code-analise vir algemene kwesbaarhede en gedrag
- Toestelinligting
- en meer
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER is 'n command-line application wat in Windows, MacOS X en Linux gebruik kan word, wat _.apk_ files ontleed op soek na vulnerabilities. Dit doen dit deur APKs te dekomprimeer en 'n reeks reëls toe te pas om daardie vulnerabilities te ontdek.

Al die reëls is gesentraliseer in 'n `rules.json` file, en elke maatskappy of tester kan sy eie reëls skep om te ontleed wat hulle nodig het.

Laai die nuutste binaries af vanaf die [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn is 'n **platformonafhanklike** hulpmiddel wat ontwikkelaars, bugbounty hunters en etiese hackers help om [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) op mobiele toepassings uit te voer.

Die konsep is dat jy jou mobiele toepassingslêer (an .apk or .ipa file) in die StaCoAn-toepassing sleep en los, en dit sal 'n visuele en draagbare verslag vir jou genereer. Jy kan die instellings en wordlists aanpas om 'n aangepaste ervaring te kry.

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework is 'n stelsel vir Android-kwesbaarheidsanalise wat ontwikkelaars of hackers help om potensiële sekuriteitskwesbaarhede in Android-toepassings te vind.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** is 'n hulpmiddel met die hoofdoel om die gebruiker te help om potensiële kwaadwillige gedrag, ontwikkel deur 'n Android-toepassing, op te spoor en te waarsku.

Die opsporing word uitgevoer deur middel van die **static analysis** van die toepassing se Dalvik bytecode, voorgestel as **Smali**, met die [`androguard`](https://github.com/androguard/androguard) biblioteek.

Hierdie hulpmiddel soek na **algemene gedrag van "slegte" toepassings** soos: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is 'n **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Dit is 'n hulpmiddel wat algemeen gebruikte mobile application reverse engineering en analysis tools bymekaar sit om te help met die toetsing van mobiele toepassings teen OWASP mobile security threats. Dit het ten doel om hierdie taak makliker en vriendeliker te maak vir mobiele toepassingsontwikkelaars en sekuriteitsprofessionals.

Dit kan:

- Extraheer Java- en Smali-kode met verskeie gereedskap
- Ontleed APK's met behulp van: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Haal private inligting uit die APK met behulp van regexps.
- Ontleed die Manifest.
- Ontleed gevonde domeine met behulp van: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) en [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Nuttig om malware te detecteer: [https://koodous.com/](https://koodous.com/)

## Obfuskering/Deobfuskering van kode

Let daarop dat, afhangende van die diens en konfigurasie wat jy gebruik om die kode te obfuskeren, geheime dalk geobfuskeer sal wees of nie.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Volgens [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is 'n open source opdragreël-instrument wat Java-kode verklein, optimaliseer en obfuskereer. Dit kan bytecode optimaliseer sowel as ongebruikte instruksies opspoor en verwyder. ProGuard is gratis sagteware en word versprei onder die GNU General Public License, weergawe 2.

ProGuard word as deel van die Android SDK versprei en hardloop wanneer die toepassing in release-modus gebou word.

### [DexGuard](https://www.guardsquare.com/dexguard)

Vind 'n stap-vir-stap gids om die apk te deobfuskeren by [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Vanaf daardie gids) Laas toe ons gekyk het, was die Dexguard werkswyse:

- laai 'n resource as 'n InputStream;
- stuur die resultaat na 'n klas wat van FilterInputStream erf om dit te ontsleutel;
- doen 'n paar nuttelose obfuskering om 'n paar minute van 'n reverser te mors;
- gee die ontsleutelde resultaat aan 'n ZipInputStream om 'n DEX-lêer te kry;
- laai uiteindelik die resulterende DEX as 'n Resource met behulp van die `loadDex` metode.

### [DeGuard](http://apk-deguard.com)

**DeGuard keer die proses van obfuskering wat deur Android obfuskering-instrumente uitgevoer word om. Dit skakel baie sekuriteitsanalises in staat, insluitend kode-inspeksie en identifisering van libraries.**

Jy kan 'n geobfuskeerde APK na hul platform oplaai.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Dit is 'n LLM-instrument om enige potensiële sekuriteitskwessies in android apps te vind en android app-kode te deobfuskeren. Gebruik Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Dit is 'n **generiese android deobfuscator.** Simplify **voer 'n app virtueel uit** om sy gedrag te verstaan en **probeer dan die kode optimaliseer** sodat dit identies optree maar makliker is vir 'n mens om te verstaan. Elke tipe optimalisering is eenvoudig en generies, so dit maak nie saak watter spesifieke tipe obfuskering gebruik is nie.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gee jou inligting oor **hoe 'n APK gemaak is**. Dit identifiseer baie **compilers**, **packers**, **obfuscators**, en ander vreemde goed. Dit is [_PEiD_] vir Android.

### Manual

[Lees hierdie tutoriaal om 'n paar truuks te leer oor **hoe om aangepaste obfuskering om te keer**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is 'n Android-sekuriteits-virtuale masjien gebaseer op ubuntu-mate en sluit 'n versameling van die nuutste frameworks, tutoriaals en labs van verskillende sekuriteits-entoesiaste en navorsers vir reverse engineering en malware-analise in.

## References

- [Play Integrity API: How It Works & How to Bypass It](https://m4kr0.vercel.app/posts/play-integrity-api-how-it-works--how-to-bypass-it/) — Play Integrity API: Hoe dit werk & hoe om dit te omseil
- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Dit is 'n uitstekende lys van hulpbronne
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android vinnige kursus
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/) Android-toepassingssekuriteit
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097) — SSLPinDetect: Gevorderde SSL Pinning-detektering vir Android-sekuriteitsanalise
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools) — Bou 'n herhaalbare Android Bug Bounty-lab: Emulator vs Magisk, Burp, Frida, en Medusa
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
