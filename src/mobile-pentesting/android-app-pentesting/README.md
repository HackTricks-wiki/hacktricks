# Pentesting додатків Android

{{#include ../../banners/hacktricks-training.md}}

## Основи додатків Android

Рекомендується почати з цієї сторінки, щоб дізнатися про **найважливіші аспекти, пов'язані з безпекою Android, та найбільш небезпечні компоненти в Android-додатку**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Це основний інструмент, який потрібен для підключення до Android-пристрою (емульований або фізичний).\
**ADB** дозволяє керувати пристроями через **USB** або **Network** з комп'ютера. Ця утиліта дає змогу **копіювання** файлів у обох напрямках, **встановлення** та **видалення** додатків, **виконання** shell-команд, **резервного копіювання** даних, **читання** логів та інші функції.

Перегляньте наступний список [**ADB Commands**](adb-commands.md), щоб дізнатися, як використовувати adb.

## Smali

Іноді цікаво **змінити код додатку**, щоб отримати доступ до **прихованої інформації** (наприклад, сильно обфусковані паролі або flags). Тоді може бути цікаво декомпілювати the apk, змінити код і рекомпілювати його.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Це може бути дуже корисним як **альтернатива для деяких тестів під час dynamic analysis**, які будуть представлені. Тому завжди пам'ятайте про цю можливість.

## Інші цікаві прийоми

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Витягнути APK з пристрою:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Об'єднайте всі splits і base apks за допомогою [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Кейси та вразливості


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Статичний аналіз

По-перше, для аналізу APK слід **переглянути Java код** за допомогою декомпілятора.\
Будь ласка, [**прочитайте тут, щоб знайти інформацію про різні доступні декомпілятори**](apk-decompilers.md).

### Пошук цікавої інформації

Просто переглянувши **strings** APK, ви можете шукати **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API** keys, **encryption**, **bluetooth uuids**, **tokens** та все, що здається цікавим... шукайте навіть code execution **backdoors** або authentication backdoors (hardcoded admin credentials to the app).

**Firebase**

Зверніть особливу увагу на **firebase URLs** та перевірте, чи вони не неправильно налаштовані. [Більше інформації про те, що таке Firebase і як це експлуатувати тут.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Базове розуміння додатку - Manifest.xml, strings.xml

Огляд файлів _Manifest.xml_ і _strings.xml_ додатку може виявити потенційні вразливості безпеки. Ці файли можна отримати за допомогою декомпілятора або перейменувавши розширення файлу APK на .zip та розпакувавши його.

**Вразливості**, виявлені у **Manifest.xml**, включають:

- **Debuggable Applications**: Додатки, встановлені як debuggable (`debuggable="true"`) у файлі _Manifest.xml_, становлять ризик, оскільки дозволяють підключення, які можуть призвести до експлуатації. Для детальнішого розуміння того, як експлуатувати debuggable-додатки, зверніться до керівництва з пошуку та експлуатації debuggable-додатків на пристрої.
- **Backup Settings**: Атрибут `android:allowBackup="false"` повинен бути явно встановлений для додатків, які працюють з чутливою інформацією, щоб запобігти несанкціонованому створенню бекапів через adb, особливо коли увімкнено usb debugging.
- **Network Security**: Користувацькі конфігурації мережевої безпеки (`android:networkSecurityConfig="@xml/network_security_config"`) в _res/xml/_ можуть визначати деталі безпеки, такі як certificate pins та налаштування HTTP-трафіку. Приклад — дозволення HTTP-трафіку для конкретних доменів.
- **Exported Activities and Services**: Виявлення exported activities та services у маніфесті може вказати на компоненти, якими можна зловживати. Подальший аналіз під час динамічного тестування може показати, як експлуатувати ці компоненти.
- **Content Providers and FileProviders**: Відкриті content providers можуть дозволити несанкціонований доступ або модифікацію даних. Конфігурацію FileProviders також слід ретельно перевірити.
- **Broadcast Receivers and URL Schemes**: Ці компоненти можуть бути використані для експлуатації; зверніть особливу увагу на те, як обробляються URL schemes щодо вразливостей при прийомі вводу.
- **SDK Versions**: Атрибути `minSdkVersion`, `targetSDKVersion`, та `maxSdkVersion` вказують підтримувані версії Android, що підкреслює важливість не підтримувати застарілі, вразливі версії Android з міркувань безпеки.

З файлу **strings.xml** можна виявити чутливу інформацію, таку як API keys, custom schemas та інші нотатки розробників, що підкреслює необхідність ретельного перегляду цих ресурсів.

### Tapjacking

**Tapjacking** — це атака, коли **malicious** **application** запускається і **розміщується поверх додатку-жертви**. Коли воно візуально перекриває додаток-жертву, його інтерфейс користувача спроектовано так, щоб обдурити користувача і змусити його взаємодіяти з ним, при цьому взаємодія передається додатку-жертві.\
Внаслідок цього користувач **не бачить, що фактично виконує дії в додатку-жертві**.

Детальніше у:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Активність (**activity**) з **`launchMode`**, встановленим у **`singleTask` без визначеного `taskAffinity`**, вразлива до task Hijacking. Це означає, що шкідливий **application** може бути встановлений і, якщо його запустити перед справжнім додатком, він може **перехопити task справжнього додатку** (тобто користувач буде взаємодіяти зі **malicious application, думаючи, що використовує справжній**).

Детальніше у:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Ненадійне зберігання даних

**Внутрішнє сховище**

В Android файли, **збережені** у **внутрішньому** сховищі, **створені** так, щоб бути **доступними** виключно для **додатку**, який їх **створив**. Цей механізм безпеки **забезпечується** операційною системою Android і зазвичай достатній для потреб більшості додатків. Проте розробники іноді використовують режими на кшталт `MODE_WORLD_READABLE` і `MODE_WORLD_WRITABLE`, щоб **дозволити** спільний доступ до файлів між різними додатками. Ці режими, однак, **не обмежують доступ** до цих файлів з боку інших додатків, включно з потенційно шкідливими.

1. **Статичний аналіз:**
- **Переконайтесь**, що використання `MODE_WORLD_READABLE` та `MODE_WORLD_WRITABLE` **ретельно проаналізовано**. Ці режими **можуть потенційно піддавати** файли небажаному або несанкціонованому доступу.
2. **Динамічний аналіз:**
- **Перевірте** права доступу до файлів, створених додатком. Зокрема, **перевірте**, чи будь-які файли не встановлені як доступні для читання або запису для всіх. Це може становити серйозний ризик безпеки, оскільки дозволяє **будь-якому додатку**, встановленому на пристрої, незалежно від його походження чи намірів, **читати або змінювати** ці файли.

**Зовнішнє сховище**

Працюючи з файлами на **external storage**, наприклад SD-карті, слід дотримуватися певних застережень:

1. **Доступність**:
- Файли на external storage **загально доступні для читання і запису**. Це означає, що будь-який додаток або користувач може отримати доступ до цих файлів.
2. **Проблеми безпеки**:
- Через легкість доступу не рекомендується **зберігати чутливу інформацію** на external storage.
- External storage може бути видалене або доступне будь-якому додатку, що робить його менш безпечним.
3. **Опрацювання даних із external storage**:
- Завжди **виконуйте валідацію вводу** для даних, отриманих із external storage. Це критично, оскільки дані походять з ненадійного джерела.
- Категорично не рекомендується зберігати виконувані файли або class-файли на external storage для динамічного завантаження.
- Якщо ваш додаток все ж має отримувати виконувані файли з external storage, переконайтеся, що ці файли **підписані та криптографічно перевірені** перед динамічним завантаженням. Цей крок важливий для збереження цілісності безпеки додатку.

External storage можна **знайти** в `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Починаючи з Android 4.4 (**API 17**), SD-карта має структуру директорій, яка **обмежує доступ додатку до директорії, що призначена саме для цього додатку**. Це запобігає отриманню шкідливим додатком прав на читання або запис файлів іншого додатку.

**Чутливі дані, збережені у відкритому тексті**

- **Shared preferences**: Android дозволяє кожному додатку зручно зберігати xml-файли в шляху `/data/data/<packagename>/shared_prefs/` і іноді можна знайти чутливу інформацію у відкритому вигляді в цій теці.
- **Databases**: Android дозволяє кожному додатку зручно зберігати sqlite databases в шляху `/data/data/<packagename>/databases/` і іноді можна знайти чутливу інформацію у відкритому вигляді в цій теці.

### Broken TLS

**Accept All Certificates**

З якоїсь причини іноді розробники приймають усі сертифікати, навіть якщо, наприклад, hostname не відповідає, з рядками коду на кшталт наведеного нижче:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Неправильна криптографія

**Погане управління ключами**

Деякі розробники зберігають конфіденційні дані в локальному сховищі й шифрують їх ключем, жорстко захардкодженим/передбачуваним у коді. Так робити не слід, оскільки reversing може дозволити атаці витягти конфіденційну інформацію.

**Використання небезпечних і/або застарілих алгоритмів**

Розробники не повинні використовувати **deprecated algorithms** для виконання authorisation **checks**, зберігання або відправки даних. Деякі з цих алгоритмів: RC4, MD4, MD5, SHA1... Якщо, наприклад, для зберігання паролів використовуються **hashes**, слід застосовувати brute-force **resistant** hashes з salt.

### Інші перевірки

- Рекомендується **obfuscate the APK**, щоб ускладнити reverse engineer-ам роботу атакуючих.
- Якщо додаток чутливий (наприклад банківські додатки), він повинен виконувати власні перевірки, щоб визначити, чи mobile is rooted, і діяти відповідно.
- Якщо додаток чутливий (наприклад банківські додатки), він має перевіряти, чи використовується **emulator**.
- Якщо додаток чутливий (наприклад банківські додатки), він має перевіряти власну цілісність перед виконанням, щоб перевірити, чи не був змінений.
- Використовуйте [**APKiD**](https://github.com/rednaga/APKiD) щоб перевірити, який compiler/packer/obfuscator був використаний для збірки APK

### Додатки React Native

Прочитайте наступну сторінку, щоб дізнатися, як легко отримати доступ до javascript коду React додатків:


{{#ref}}
react-native-application.md
{{#endref}}

### Додатки Xamarin

Прочитайте наступну сторінку, щоб дізнатися, як легко отримати доступ до C# коду додатків Xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Згідно з цим [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked — це Meta algorithm, який стискає вміст додатка в один файл. У блозі йдеться про можливість створити додаток, що розпаковує такого роду додатки... і про швидший спосіб, який полягає в **виконанні додатка і зборі розпакованих файлів із файлової системи.**

### Автоматизований статичний аналіз коду

Інструмент [**mariana-trench**](https://github.com/facebook/mariana-trench) здатний знаходити **vulnerabilities** шляхом **scanning** **code** додатка. Цей інструмент містить набір **known sources** (що вказують інструменту **місця**, де **input** контролюється користувачем), **sinks** (що вказують **dangerous** **місця**, де шкідливий input користувача може завдати шкоди) та **rules**. Ці правила вказують **комбінації sources-sinks**, які позначають vulnerability.

Завдяки цьому **mariana-trench перевіряє код і знаходить можливі vulnerabilities.**

### Secrets leaked

Додаток може містити secrets (API keys, passwords, hidden urls, subdomains...) всередині, які ви можете виявити. Ви можете використати інструмент, такий як [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Інші цікаві функції

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Прочитайте це, щоб дізнатися **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Динамічний аналіз

> По‑перше, вам потрібне середовище, де можна встановити додаток і всі компоненти (Burp CA cert, Drozer і Frida головним чином). Тому настійно рекомендується rooted device (емулятор або реальний пристрій).

### Онлайн динамічний аналіз

Ви можете створити **free account** на: [https://appetize.io/](https://appetize.io/). Ця платформа дозволяє **upload** та **execute** APK, тому корисна для спостереження за поведінкою apk.

Ви навіть можете переглядати логи вашого додатку в вебі й підключатися через **adb**.

![](<../../images/image (831).png>)

Завдяки ADB-з'єднанню ви можете використовувати **Drozer** та **Frida** в емуляторах.

### Локальний динамічний аналіз

#### Використання емулятора

- [**Android Studio**](https://developer.android.com/studio) (Ви можете створювати **x86** та **arm** пристрої, і, згідно з [**this**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) **latest x86** версії **support ARM libraries** без необхідності повільного arm емулятора).
- Дізнайтеся, як його налаштувати на цій сторінці:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, потрібно створити акаунт. _Рекомендується **download** версію **WITH**_ _**VirtualBox**, щоб уникнути потенційних помилок._)
- [**Nox**](https://es.bignox.com) (Безкоштовно, але не підтримує Frida або Drozer).

> [!TIP]
> Коли створюєте новий емулятор на будь‑якій платформі, пам’ятайте: чим більший екран, тим повільніше працюватиме емулятор. Тому по можливості обирайте менші екрани.

Щоб **install google services** (наприклад AppStore) в Genymotion, потрібно натиснути на червоного марковану кнопку на зображенні:

![](<../../images/image (277).png>)

Також зверніть увагу, що в **configuration of the Android VM in Genymotion** можна вибрати **Bridge Network mode** (це буде корисно, якщо ви підключатиметесь до Android VM з іншої VM з інструментами).

#### Використання фізичного пристрою

Потрібно активувати **debugging** опції, і бажано, щоб пристрій був **root**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Після встановлення додатку перше, що слід зробити — це спробувати його, дослідити, що він робить, як працює і звикнути до нього.\
> Рекомендую виконати цю початкову динамічну перевірку з використанням MobSF dynamic analysis + pidcat, щоб ми могли **дізнатися, як працює додаток**, поки MobSF **збирає** багато **цікавих** **даних**, які ви зможете переглянути пізніше.

Короткі нотатки про Magisk/Zygisk (рекомендується на Pixel-пристроях)
- Patch boot.img з використанням додатку Magisk і прошити через fastboot для отримання systemless root
- Увімкнути Zygisk + DenyList для приховування root; розгляньте LSPosed/Shamiko для більш потужного приховування
- Зберігайте оригінальний boot.img, щоб відновитися після OTA; повторно патчіть після кожного OTA
- Для віддзеркалення екрана використовуйте scrcpy на хості

### Ненавмисні витоки даних

**Logging**

Розробникам слід бути обережними з публічним розголошенням **debugging information**, оскільки це може призвести до витоку чутливої інформації. Рекомендовано використовувати інструменти [**pidcat**](https://github.com/JakeWharton/pidcat) та `adb logcat` для моніторингу логів додатку та виявлення/захисту чутливої інформації. **Pidcat** зручніший у використанні та більш читабельний.

> [!WARNING]
> Зауважте, що починаючи з **пізніших версій, ніж Android 4.0**, **додатки можуть отримувати доступ тільки до власних логів**. Тому додатки не можуть читати логи інших додатків.\
> В будь‑якому випадку, все одно не рекомендовано логувати чутливу інформацію.

**Кеш буфера копіювання/вставки**

Android‑фреймворк на основі буфера обміну дозволяє функції copy-paste у додатках, проте є ризик, що **інші додатки** можуть отримати доступ до clipboard і, потенційно, викрити чутливі дані. Важливо вимикати функції copy/paste для чутливих секцій додатку, як-от дані кредитної картки, щоб запобігти витокам.

**Crash Logs**

Якщо додаток падає і зберігає логи, ці логи можуть допомогти атакуючим, особливо коли додаток важко відремонтувати реверсингом. Щоб зменшити ризик, уникайте логування на крашах, а якщо логи мають передаватися мережею — переконайтесь, що вони йдуть по SSL‑каналу.

Як pentester, **спробуйте подивитися ці логи**.

**Analytics Data Sent To 3rd Parties**

Додатки часто інтегрують сервіси на кшталт Google Adsense, які можуть ненавмисно **leak** чутливі дані через неправильне впровадження розробниками. Щоб виявити можливі витоки даних, рекомендовано **intercept the application's traffic** і перевірити, чи не надсилається чутлива інформація до third-party сервісів.

### SQLite DBs

Більшість додатків використовують **internal SQLite databases** для збереження інформації. Під час pentest перегляньте **databases**, імена **tables** і **columns** та всі **data**, що зберігається, оскільки ви можете знайти **sensitive information** (що буде вразливістю).\
Бази даних зазвичай знаходяться в `/data/data/the.package.name/databases`, наприклад `/data/data/com.mwr.example.sieve/databases`

Якщо база даних зберігає конфіденційну інформацію і вона **encrypted**, але ви можете **find** пароль у додатку — це все одно **vulnerability**.

Перелічте таблиці за допомогою `.tables` і перелічте схему таблиці командою `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Згідно з [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** дозволяє вам **взяти на себе роль Android app** і взаємодіяти з іншими додатками. Він може робити **все, що може робити встановлений додаток**, наприклад використовувати Android’s Inter-Process Communication (IPC) та взаємодіяти з underlying operating system. .\
Drozer — корисний інструмент для **експлуатації exported activities, exported services та Content Providers**, як ви дізнаєтесь у наступних розділах.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Також пам'ятайте, що код activity починається в методі **`onCreate`**.

**Authorisation bypass**

Коли Activity exported, ви можете викликати її екран з зовнішнього додатка. Якщо activity з **sensitive information** є **exported**, ви можете **bypass** механізми аутентифікації, щоб потрапити до неї.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Ви також можете запустити exported activity з adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**ПРИМІТКА**: MobSF визначатиме як шкідливе використання _**singleTask/singleInstance**_ як `android:launchMode` в activity, але через [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), очевидно, це небезпечно лише на старих версіях (API versions < 21).

> [!TIP]
> Зверніть увагу, що authorisation bypass не завжди є вразливістю — це залежатиме від того, як bypass працює і яка інформація розкривається.

**Sensitive information leakage**

Activities також можуть повертати результати. Якщо вам вдасться знайти exported і unprotected activity, яка викликає метод **`setResult`** і **повертає конфіденційну інформацію**, це призводить до витоку конфіденційної інформації.

#### Tapjacking

Якщо tapjacking не запобігається, ви можете зловживати exported activity, щоб змусити **користувача виконати непередбачені дії**. Для детальнішої інформації про [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Доступ та маніпулювання конфіденційною інформацією

[**Прочитайте це, якщо хочете освіжити уявлення про Content Provider.**](android-applications-basics.md#content-provider)\
Content providers здебільшого використовуються для **обміну даними**. Якщо додаток має доступні content providers, ви можете **витягти конфіденційні** дані з них. Також варто протестувати можливі **SQL injections** та **Path Traversals**, оскільки вони можуть бути вразливими.

[**Дізнайтеся, як експлуатувати Content Providers за допомогою Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Прочитайте це, якщо хочете освіжити уявлення про Service.**](android-applications-basics.md#services)\
Пам'ятайте, що дії Service починаються в методі `onStartCommand`.

Service по суті може **отримувати дані**, **обробляти** їх і **повертати** (або не повертати) відповідь. Тому, якщо додаток експортує якісь services, слід **перевірити** **код**, щоб зрозуміти, що він робить, і **тестувати** це **динамічно** для витягання конфіденційної інформації, обходу заходів авторизації тощо...\
[**Дізнайтеся, як експлуатувати Services за допомогою Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Прочитайте це, якщо хочете освіжити уявлення про Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Пам'ятайте, що дії Broadcast Receiver починаються в методі `onReceive`.

Broadcast receiver очікує певний тип повідомлення. Залежно від того, як receiver обробляє повідомлення, він може бути вразливим.\
[**Дізнайтеся, як експлуатувати Broadcast Receivers за допомогою Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Ви можете шукати deep links вручну, використовуючи інструменти на кшталт MobSF або скрипти, як-от [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Ви можете **відкрити** задекларований **scheme** за допомогою **adb** або **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Zверніть увагу, що ви можете **omit the package name**, і мобільний пристрій автоматично викличе додаток, який має відкрити це посилання._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Код, що виконується**

Щоб знайти **код, який виконуватиметься в додатку**, перейдіть до activity, викликаної deeplink, і знайдіть функцію **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Конфіденційні дані**

Кожного разу, коли ви знаходите deep link, перевіряйте, що **вона не отримує конфіденційних даних (наприклад паролів) через URL-параметри**, оскільки будь-який інший додаток може **імітувати deep link і вкрасти ці дані!**

**Параметри в path**

Ви **також повинні перевіряти, чи який-небудь deep link не використовує параметр всередині шляху** URL, наприклад: `https://api.example.com/v1/users/{username}`, у такому випадку ви можете змусити path traversal, звернувшись до чогось на кшталт: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Зверніть увагу, що якщо ви знайдете правильні endpoints всередині застосунку, ви можете викликати **Open Redirect** (якщо частина шляху використовується як домен), **account takeover** (якщо можна змінити деталі користувача без CSRF token і вразливий endpoint використовував правильний метод) та інші вразливості. Більше [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** у Android-додатках. Часто такі додатки ігнорують попередження і приймають self-signed certificates або, в деяких випадках, повертаються до використання HTTP-з’єднань.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, застосовуються ненадійні cipher suites. Ця вразливість робить з’єднання вразливим до man-in-the-middle (MITM) атак, дозволяючи зловмисникам розшифрувати дані.
- **Leakage of private information** являє собою ризик, коли додатки автентифікуються через захищені канали, але потім для інших транзакцій використовують незахищені канали. Такий підхід не захищає конфіденційні дані, наприклад session cookies або деталі користувача, від перехоплення зловмисниками.

#### Certificate Verification

Ми зосередимось на **certificate verification**. Необхідно перевіряти цілісність сертифіката сервера для підвищення безпеки. Це важливо, оскільки ненадійні TLS-конфігурації та передача конфіденційних даних по незашифрованих каналах можуть створювати серйозні ризики. Для детальних кроків щодо перевірки сертифікатів сервера та усунення вразливостей [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) надає вичерпні рекомендації.

#### SSL Pinning

SSL Pinning — це захід безпеки, коли додаток порівнює сертифікат сервера з відомою копією, збереженою всередині додатку. Цей метод є критичним для запобігання MITM-атак. Рекомендується реалізувати SSL Pinning для додатків, що оперують конфіденційною інформацією.

#### Traffic Inspection

Щоб інспектувати HTTP-трафік, необхідно **встановити сертифікат proxy tool** (наприклад, Burp). Без встановлення цього сертифіката зашифрований трафік може бути невидимим через проксі. Для інструкції зі встановлення custom CA certificate дивіться [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Додатки, що таргетять **API Level 24 and above**, потребують змін у Network Security Config, щоб прийняти CA-сертифікат проксі. Це критичний крок для інспекції зашифрованого трафіку. Для інструкцій щодо зміни Network Security Config дивіться [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Якщо використовується **Flutter**, потрібно слідувати інструкціям на [**this page**](flutter.md). Це тому, що просте додавання сертифіката в store не спрацює — Flutter має власний список валідних CA.

#### Static detection of SSL/TLS pinning

Перед спробами runtime bypasses швидко промапте, де всередині APK застосовується pinning. Статичне виявлення допомагає спланувати hooks/patches і зосередитись на потрібних кодових шляхах.

Tool: SSLPinDetect
- Open-source static-analysis utility, що декомпілює APK у Smali (через apktool) і сканує за підготовленими regex patterns реалізацій SSL/TLS pinning.
- Reports exact file path, line number, and a code snippet for each match.
- Охоплює поширені frameworks та кастомні кодові шляхи: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, та Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Використання
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Приклад правил pattern (JSON)
Використовуйте або розширюйте signatures для виявлення пропрієтарних/власних стилів pinning. Ви можете завантажити власний JSON і scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Поради та підказки
- Швидке сканування великих додатків через мультипоточність та memory-mapped I/O; попередньо скомпільовані regex зменшують накладні витрати/помилкові спрацьовування.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Типові цілі для подальшої перевірки:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Використовуйте знайдені місця відповідності для планування Frida hooks, статичних патчів або перевірки конфігурацій перед dynamic testing.



#### Обхід SSL Pinning

Коли реалізований SSL Pinning, обхід цього механізму необхідний для інспектування HTTPS-трафіку. Існують різні методи для цього:

- Автоматично **змінити** **apk** щоб **обійти** SSLPinning за допомогою [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Головна перевага цього варіанту — вам не потрібен root для обходу SSL Pinning, проте доведеться видалити застосунок і перевстановити модифікований, і це не завжди працює.
- Можна використовувати **Frida** (обговорюється нижче) щоб обійти цей захист. Ось гайду для використання Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Також можна спробувати **автоматично обійти SSL Pinning** за допомогою [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Можна також спробувати **автоматично обійти SSL Pinning** за допомогою **MobSF dynamic analysis** (пояснено нижче)
- Якщо ви все ще вважаєте, що частину трафіку не перехоплюєте, можна спробувати **перенаправити трафік до burp за допомогою iptables**. Читайте цей блог: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Пошук загальних веб-уразливостей

Також важливо шукати загальні веб-уразливості всередині додатку. Детальна інформація про ідентифікацію та пом’якшення цих уразливостей виходить за рамки цього резюме, але детально розглянута в інших джерелах.

### Frida

[Frida](https://www.frida.re) — це dynamic instrumentation toolkit для розробників, реверс-інженерів та дослідників з безпеки.\
**Ви можете отримати доступ до запущеного застосунку та hook methods під час виконання, змінювати поведінку, змінювати значення, витягувати значення, виконувати інший код...**\
Якщо ви хочете робити pentesting Android-додатків, вам потрібно вміти користуватися Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Спробуйте обійти anti-debugging / anti-frida механізми, завантаживши Frida як описано в [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (інструмент [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Перевірте, чи зберігає застосунок конфіденційну інформацію в пам’яті, що не повинен зберігати — наприклад паролі або мнемоніки.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Це вивантажить пам'ять у папку ./dump, і там ви можете виконати grep приблизно так:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Чутливі дані в Keystore**

В Android Keystore — найкраще місце для зберігання чутливих даних; однак за наявності достатніх привілеїв до нього все ще **можна отримати доступ**. Оскільки додатки схильні зберігати тут **sensitive data in clear text**, pentests повинні перевіряти це, оскільки root user або особа з фізичним доступом до пристрою може викрасти ці дані.

Навіть якщо додаток зберігав дані в keystore, вони мають бути зашифровані.

Щоб отримати доступ до даних у keystore, можна використати цей Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Використовуючи наведений Frida-скрипт, можливо здійснити **bypass fingerprint authentication**, що Android-застосунки можуть виконувати з метою **захисту певних чутливих областей:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Фонові зображення**

Коли ви відправляєте додаток у фон, Android зберігає **знімок додатка**, тож під час відновлення на передній план він починає завантажувати це зображення перед самим додатком, щоб здавалося, ніби додаток завантажився швидше.

Однак, якщо цей знімок містить **чутливу інформацію**, той, хто має доступ до знімка, може **вкрасти цю інформацію** (зауважте, що для доступу потрібен root).

Зазвичай знімки зберігаються за адресою: **`/data/system_ce/0/snapshots`**

Android надає спосіб **запобігти захопленню скриншотів шляхом встановлення параметра макета FLAG_SECURE**. Використовуючи цей флаг, вміст вікна вважається захищеним, що перешкоджає його появі у скриншотах або перегляду на незахищених дисплеях.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Аналізатор Android-застосунків**

Цей інструмент може допомогти у керуванні різними інструментами під час динамічного аналізу: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Розробники часто створюють проксі-компоненти, такі як activities, services і broadcast receivers, які обробляють ці Intents і передають їх у методи, такі як `startActivity(...)` або `sendBroadcast(...)`, що може бути ризиковано.

Небезпека полягає в тому, що дозволяється атакуючим тригерити non-exported app components або отримувати доступ до чутливих content providers, перенаправивши ці Intents. Помітний приклад — компонент `WebView`, який перетворює URL на об'єкти `Intent` за допомогою `Intent.parseUri(...)` і потім виконує їх, що може призвести до malicious Intent injections.

### Essential Takeaways

- **Intent Injection** схоже на веб-проблему Open Redirect.
- Експлойти передбачають передачу об'єктів `Intent` як extras, які можуть бути перенаправлені для виконання небезпечних операцій.
- Це може відкрити non-exported components і content providers для атакуючих.
- Конвертація URL у `Intent` у `WebView` може сприяти небажаним діям.

### Клієнтські ін'єкції в Android та інше

Ймовірно, ви знайомі з таким типом вразливостей з Web. У Android-застосунку потрібно бути особливо уважним щодо цих вразливостей:

- **SQL Injection:** При роботі з динамічними запитами або Content-Providers переконайтеся, що ви використовуєте параметризовані запити.
- **JavaScript Injection (XSS):** Переконайтеся, що підтримка JavaScript і плагінів вимкнена для всіх WebView (вимкнено за замовчуванням). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Доступ WebView до файлової системи має бути відключений (увімкнено за замовчуванням) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: У кількох випадках, коли Android-застосунок завершує сесію, cookie не відкликається або навіть може зберігатися на диску
- [**Secure Flag** у cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Автоматичний аналіз

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Статичний аналіз**

![](<../../images/image (866).png>)

**Оцінка вразливостей застосунку** з використанням зручного веб-інтерфейсу. Також можна виконувати динамічний аналіз (але потрібно підготувати середовище).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF також дозволяє виконувати **diff/Compare** аналіз і інтегрувати **VirusTotal** (вам потрібно встановити ваш API key у _MobSF/settings.py_ та увімкнути його: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Ви також можете встановити `VT_UPLOAD` в `False`, тоді **hash** буде **upload** замість файлу.

### Assisted Dynamic analysis with MobSF

**MobSF** також дуже корисний для **dynamic analysis** в **Android**, але в цьому випадку вам потрібно встановити MobSF і **genymotion** на вашому хості (VM або Docker не працюватиме). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** може:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Усе це робиться автоматично, крім знімків екрана — їх потрібно робити вручну або натиснути "**Exported Activity Tester**", щоб отримати знімки всіх exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

За замовчуванням MobSF також використовує деякі Frida Scripts щоб **bypass SSL pinning**, **root detection** та **debugger detection** і для **monitor interesting APIs**.\
MobSF також може **invoke exported activities**, робити **screenshots** цих активностей і **save** їх для звіту.

Щоб **start** dynamic testing натисніть зелену кнопку: "**Start Instrumentation**". Натисніть "**Frida Live Logs**", щоб побачити логи, згенеровані Frida scripts, та "**Live API Monitor**", щоб побачити всі виклики до hooked methods, передані аргументи та returned values (це з’явиться після натискання "Start Instrumentation").\
MobSF також дозволяє завантажувати власні **Frida scripts** (щоб відправити результати ваших Frida скриптів до MobSF використовуйте функцію `send()`). Також є **several pre-written scripts**, які можна завантажити (можна додати більше в `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), просто **select them**, натисніть "**Load**" і потім "**Start Instrumentation**" (логи цих скриптів будуть відображатися в "**Frida Live Logs**").

![](<../../images/image (419).png>)

Крім того, доступні деякі допоміжні Frida функції:

- **Enumerate Loaded Classes**: Друкує всі завантажені класи
- **Capture Strings**: Друкує всі захоплені рядки під час використання додатку (дуже шумно)
- **Capture String Comparisons**: Може бути дуже корисно. Показує дві строки, що порівнюються, і чи був результат True або False.
- **Enumerate Class Methods**: Введіть ім’я класу (наприклад "java.io.File"), і воно виведе всі методи класу.
- **Search Class Pattern**: Шукає класи за шаблоном
- **Trace Class Methods**: **Trace** весь **class** (дивиться inputs і outputs всіх методів класу). Пам’ятайте, що за замовчуванням MobSF трасує декілька цікавих Android Api methods.

Після вибору потрібного auxiliary module потрібно натиснути "**Start Intrumentation**", і всі виводи з’являться у "**Frida Live Logs**".

**Shell**

MobSF також надає shell з деякими **adb** командами, **MobSF commands**, та загальними **shell** **commands** у нижній частині сторінки dynamic analysis. Декілька цікавих команд:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP інструменти**

Коли HTTP-трафік захоплено, ви можете побачити неохайне представлення захопленого трафіку внизу в "**HTTP(S) Traffic**" або більш приємне представлення у зеленій кнопці "**Start HTTPTools**". З другого варіанту ви можете надіслати **захоплені запити** на **proxies** такі як Burp або Owasp ZAP.\
Для цього: _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> натисніть "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Після завершення dynamic analysis з MobSF ви можете натиснути на "**Start Web API Fuzzer**", щоб **fuzz http requests** і шукати вразливості.

> [!TIP]
> Після виконання dynamic analysis з MobSF налаштування proxy можуть бути неправильно сконфігуровані, і ви не зможете виправити їх через GUI. Ви можете виправити налаштування proxy, виконавши:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Цей інструмент використовує деякі **Hooks**, щоб показувати, що відбувається в додатку, поки ви виконуєте **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Цей інструмент призначений для пошуку кількох **security related Android application vulnerabilities**, як у **source code**, так і в **packaged APKs**. Інструмент також **capable of creating a "Proof-of-Concept" deployable APK** та **ADB commands**, щоб експлуатувати деякі з знайдених вразливостей (Exposed activities, intents, tapjacking...). Як і з Drozer, немає потреби root-ити тестовий пристрій.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Відображає всі витягнуті файли для зручного перегляду
- Автоматично декомпілює APK-файли в Java та Smali формати
- Аналізує AndroidManifest.xml на предмет поширених вразливостей і поведінки
- Статичний аналіз вихідного коду на предмет поширених вразливостей і поведінки
- Інформація про пристрій
- та інше
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER — це застосунок командного рядка, який можна використовувати у Windows, MacOS X та Linux; він аналізує _.apk_ файли в пошуках вразливостей. Він робить це, розпаковуючи APK та застосовуючи набір правил для виявлення цих вразливостей.

Усі правила зосереджені у файлі `rules.json`, і кожна компанія або тестувальник може створити власні правила для аналізу того, що їм потрібно.

Завантажте останні бінарні файли на [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn is a **кросплатформний** інструмент, який допомагає розробникам, bugbounty hunters та ethical hackers у проведенні [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) у мобільних додатках.

The concept is that you drag and drop your mobile application file (an .apk or .ipa file) on the StaCoAn application and it will generate a visual and portable report for you. You can tweak the settings and wordlists to get a customized experience.

Завантажити[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework — це система аналізу вразливостей для Android, яка допомагає розробникам або hackers знаходити потенційні вразливості безпеки в додатках Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** — це інструмент, основна мета якого — виявляти і попереджати користувача про потенційно шкідливу поведінку, розроблену Android-застосунком.

Виявлення здійснюється за допомогою **static analysis** Dalvik bytecode застосунку, представленого у вигляді **Smali**, з використанням бібліотеки [`androguard`](https://github.com/androguard/androguard).

Цей інструмент шукає **common behavior of "bad" applications** такі як: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** — це фреймворк для **M**obile **A**pplication **R**everse engineering and **A**nalysis. Це інструмент, який збирає разом поширені інструменти для зворотного інжинірингу та аналізу мобільних додатків, щоб допомогти в тестуванні мобільних додатків проти загроз мобільної безпеки OWASP. Його мета — зробити це завдання простішим і зручнішим для розробників мобільних додатків та фахівців з безпеки.

Фреймворк дозволяє:

- Extract Java and Smali code using different tools
- Аналізувати APK за допомогою: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Аналізувати Manifest.
- Аналізувати знайдені домени за допомогою: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) та [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com]

### Koodous

Корисно для виявлення malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Зауважте, що залежно від сервісу та конфігурації, які ви використовуєте для обфускації коду, секрети можуть бути обфусцовані або ні.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard розповсюджується як частина Android SDK і запускається при збірці додатка в режимі release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Ви можете завантажити обфускований APK на їхню платформу.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Це **generic android deobfuscator.** Simplify **virtually executes an app** щоб зрозуміти її поведінку, а потім **прагне оптимізувати код**, щоб він поводився ідентично, але був легшим для розуміння людиною. Кожен тип оптимізації простий і загальний, тому не має значення, який саме тип обфускації використовується.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD дає інформацію про **how an APK was made**. Він ідентифікує багато **compilers**, **packers**, **obfuscators**, та інші дивні речі. Це [_PEiD_](https://www.aldeid.com/wiki/PEiD) для Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b — це віртуальна машина для Android security на базі ubuntu-mate, яка включає збірку останніх фреймворків, туторіалів і лабораторій від різних ентузіастів і дослідників для reverse engineering та malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Це відмінний список ресурсів
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
