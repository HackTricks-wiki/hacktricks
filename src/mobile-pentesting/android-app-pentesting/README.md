# Android 应用程序 Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android 应用基础

强烈建议先阅读此页面，以了解与 Android 安全相关的**最重要的部分以及 Android 应用中最危险的组件**：


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

这是连接到 Android 设备（模拟或物理）所需的主要工具。\
**ADB** 允许从计算机通过 **USB** 或 **Network** 控制设备。该工具可实现双向 **复制** 文件、**安装** 和 **卸载** 应用、**执行** shell 命令、**备份** 数据、**读取** 日志等功能。

查看以下 [**ADB Commands**](adb-commands.md) 列表，了解如何使用 adb。

## Smali

有时修改应用代码以访问**隐藏信息**（比如被混淆的密码或 flag）会很有用。此时，可以反编译 apk、修改代码并重新编译。\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md)。这在将要介绍的动态分析的若干测试中可以作为有用的替代方案。然后，**始终记住这个可能性**。

## 其他有趣的技巧

- [在 Play Store 伪造你的位置信息](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [利用不安全的应用内更新机制](insecure-in-app-update-rce.md)
- [滥用 Accessibility Services（Android RAT）](accessibility-services-abuse.md)
- [通过 HCE 的 NFC/EMV 中继（Android Tap-to-Pay 滥用）](android-hce-nfc-emv-relay-attacks.md)
- **下载 APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 从设备提取 APK:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 使用 [APKEditor](https://github.com/REAndroid/APKEditor) 合并所有 splits 和 base apks：
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## 案例研究与漏洞


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## 静态分析

首先，要分析 APK，应该使用 decompiler **查看 Java 代码**。\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### 查找有价值的信息

仅查看 APK 的 **strings** 就可以搜索 **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** 以及其他有趣的内容……甚至查找代码执行的 **backdoors** 或认证 backdoors（应用中硬编码的 admin 凭据）。

**Firebase**

特别注意 **Firebase URLs** 并检查其是否配置不当。 [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 对应用的基本理解 - Manifest.xml, strings.xml

对应用的 _Manifest.xml_ 和 **_strings.xml_** 文件的检查可以揭示潜在的安全漏洞。这些文件可以通过 decompilers 获取，或将 APK 扩展名改为 .zip 然后解压。

从 **Manifest.xml** 中识别出的**漏洞**包括：

- **Debuggable Applications**: 在 _Manifest.xml_ 中设置为可调试（`debuggable="true"`）的应用存在风险，因为它们允许可能被利用的连接。有关如何利用可调试应用的更多信息，请参考关于在设备上查找和利用可调试应用的教程。
- **Backup Settings**: 对于处理敏感信息的应用，应显式设置 `android:allowBackup="false"` 属性，以防止在启用 usb debugging 时通过 adb 进行未授权的数据备份。
- **Network Security**: 自定义网络安全配置（`android:networkSecurityConfig="@xml/network_security_config"`）位于 _res/xml/_ 中，可指定诸如证书 pinning 和 HTTP 流量设置等安全细节。例如为特定域允许 HTTP 流量。
- **Exported Activities and Services**: 在 manifest 中识别导出的 activities 和 services 可以突出可能被滥用的组件。动态测试时应进一步分析以了解如何利用这些组件。
- **Content Providers and FileProviders**: 暴露的 content providers 可能允许未授权访问或修改数据。还应仔细检查 FileProviders 的配置。
- **Broadcast Receivers and URL Schemes**: 这些组件可能被用于攻击，特别注意 URL scheme 如何处理输入以防止输入相关漏洞。
- **SDK Versions**: `minSdkVersion`、`targetSDKVersion` 和 `maxSdkVersion` 属性表明支持的 Android 版本，强调不要支持已过时且存在漏洞的 Android 版本的重要性。

从 **strings.xml** 文件中，可以发现敏感信息，如 API keys、自定义 schema 和其他开发者注释，强调需要仔细审查这些资源。

### Tapjacking

**Tapjacking** 是一种攻击，其中一个 **恶意** **应用** 被启动并**定位在受害应用之上**。一旦它在视觉上遮挡了受害应用，其用户界面会以误导用户与之交互的方式设计，同时将交互传递给受害应用。\
实际上，它是在**使用户看不到自己实际上正在对受害应用执行操作**。

更多信息见：


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

如果一个 **activity** 的 **`launchMode`** 设置为 **`singleTask` 且未定义任何 `taskAffinity`**，则容易受到 Task Hijacking 的影响。这意味着，如果先安装并在真实应用之前启动了一个恶意应用，它可能**劫持真实应用的 task**（使用户在与**恶意应用交互时以为自己在使用真实应用**）。

更多信息见：


{{#ref}}
android-task-hijacking.md
{{#endref}}

### 不安全的数据存储

**Internal Storage**

在 Android 中，存储在 **internal** 存储中的文件设计为仅由**创建它们的应用**访问。该安全措施由 Android 操作系统强制执行，通常能满足大多数应用的安全需求。然而，开发者有时会使用 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 等模式来**允许**文件在不同应用之间**共享**。但这些模式**并不限制其他应用对这些文件的访问**，包括潜在的恶意应用。

1. **Static Analysis:**
- **确保**对 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 的使用进行**仔细审查**。这些模式**可能会将文件暴露给意外或未授权的访问**。
2. **Dynamic Analysis:**
- **验证**应用创建的文件的**权限**。特别是，**检查**是否有文件被设置为可被全局读取或写入。这将构成重大安全风险，因为它允许**任何已安装应用**（无论来源或意图）读取或修改这些文件。

**External Storage**

处理放在 **external storage**（如 SD 卡）上的文件时，应采取以下预防措施：

1. **可访问性**:
- external storage 上的文件是**全局可读写**的，这意味着任何应用或用户都可以访问这些文件。
2. **安全隐患**:
- 鉴于易访问性，建议**不要在 external storage 上存储敏感信息**。
- external storage 可以被移除或被任何应用访问，因此安全性较低。
3. **处理来自 external storage 的数据**:
- 始终对从 external storage 检索的数据进行**输入验证**。这是关键，因为这些数据来自不受信任的来源。
- 强烈不建议在 external storage 上存放可执行文件或 class 文件以供动态加载。
- 如果应用必须从 external storage 检索可执行文件，请确保这些文件在动态加载前已**签名并进行加密验证**。这是维护应用安全完整性的关键步骤。

External storage 可通过 /storage/emulated/0 , /sdcard , /mnt/sdcard 访问

> [!TIP]
> 从 Android 4.4（**API 17**）开始，SD 卡具有目录结构，**限制应用只能访问专门为该应用创建的目录**。这可以防止恶意应用获得对另一个应用文件的读写权限。

**以明文存储的敏感数据**

- **Shared preferences**: Android 允许每个应用轻松在路径 `/data/data/<packagename>/shared_prefs/` 下保存 xml 文件，有时可以在该文件夹中以明文发现敏感信息。
- **Databases**: Android 允许每个应用轻松在路径 `/data/data/<packagename>/databases/` 下保存 sqlite 数据库，有时可以在该文件夹中以明文发现敏感信息。

### Broken TLS

**Accept All Certificates**

出于某种原因，开发者有时会接受所有证书，即使例如 hostname 与之不匹配，也会用如下类似的代码行：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 加密缺陷

**糟糕的密钥管理流程**

一些开发者会将敏感数据保存在本地存储并用硬编码/可预测的密钥加密。这不应该这样做，因为逆向工程可能允许攻击者提取机密信息。

**使用不安全和/或已弃用的算法**

开发者不应该使用**已弃用的算法**来执行授权**检查**、**存储**或**发送**数据。这些算法包括：RC4、MD4、MD5、SHA1... 如果用**hashes**来存储密码，例如，应使用带盐并且对暴力破解有抗性的哈希算法。

### 其他检查

- 建议**混淆 APK**以增加逆向工程难度，阻碍攻击者。
- 如果应用敏感（例如 bank apps），应执行其**自身的检查以检测设备是否已 root**，并据此采取措施。
- 如果应用敏感（例如 bank apps），应检测是否在**模拟器**上运行。
- 如果应用敏感（例如 bank apps），应**在执行前检查自身完整性**以判断是否被修改。
- 使用 [**APKiD**](https://github.com/rednaga/APKiD) 来检查用于构建 APK 的 compiler/packer/obfuscator。

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

工具 [**mariana-trench**](https://github.com/facebook/mariana-trench) 能通过**扫描**应用的**代码**来发现**vulnerabilities**。该工具包含一系列的**known sources**（指示工具输入由用户控制的位置）、**sinks**（指示工具中危险的位置，恶意用户输入可能造成破坏）和**rules**。这些规则指示哪些**sources-sinks**的组合代表一个漏洞。

有了这些信息，**mariana-trench 会审查代码并找到其中可能的漏洞**。

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### 其他有趣的函数

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **其他技巧**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## 动态分析

> 首先，你需要一个可以安装应用并配置好所有环境（主要是 Burp CA cert、Drozer 和 Frida）的环境。因此，非常推荐使用已获取 root 的设备（模拟或实体）。

### 在线动态分析

你可以在此创建一个**免费账号**: [https://appetize.io/](https://appetize.io)。该平台允许你**上传**并**执行** APK，因此对观察 apk 行为很有帮助。

你甚至可以在网页上**查看应用的日志**并通过 **adb** 连接。

![](<../../images/image (831).png>)

借助 ADB 连接，你可以在模拟器内使用 **Drozer** 和 **Frida**。

### 本地动态分析

#### 使用模拟器

- [**Android Studio**](https://developer.android.com/studio)（你可以创建 **x86** 和 **arm** 设备，且根据[**这篇文章**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**较新的 x86** 版本**支持 ARM libraries**，无需使用慢速的 arm 模拟器）。
- 在此页面学习如何设置：


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **（免费版本：Personal Edition，需要注册账户。建议**下载**带有**VirtualBox**的版本以避免潜在错误。）**
- [**Nox**](https://es.bignox.com) （免费，但不支持 Frida 或 Drozer）。

> [!TIP]
> 在任何平台上创建新模拟器时请记住，屏幕越大，模拟器运行越慢。尽量选择小屏幕。

要在 Genymotion 中**安装 google services**（如 AppStore），需要点击下图中红色标记的按钮：

![](<../../images/image (277).png>)

另外，请注意在 **Genymotion 的 Android VM 配置** 中可以选择 **Bridge Network mode**（如果你需要从另一个 VM 连接到该 Android VM 并使用工具，这会很有用）。

#### 使用实体设备

你需要启用 **调试（debugging）** 选项，如果能 **root** 设备会更方便：

1. **Settings**。
2. （从 Android 8.0 起）选择 **System**。
3. 选择 **About phone**。
4. 连续按 **Build number** 7 次。
5. 返回，你会看到 **Developer options**。

> 一旦安装了应用，首先应尝试运行并调查它的行为，了解它如何工作并熟悉它。\
> 我建议使用 MobSF dynamic analysis + pidcat 执行此初始动态分析，这样在你学习应用如何工作时，MobSF 会**捕获**大量可供日后审查的**有价值数据**。

Magisk/Zygisk 快速说明（在 Pixel 设备上推荐）
- 使用 Magisk app 打补丁 boot.img 并通过 fastboot 刷入以获得 systemless root
- 启用 Zygisk + DenyList 以隐藏 root；在需要更强隐藏时可考虑 LSPosed/Shamiko
- 保留原始 boot.img 以便从 OTA 更新中恢复；每次 OTA 后重新打补丁
- 若需屏幕镜像，可在主机上使用 scrcpy

### 意外的数据泄露

**Logging**

开发者应谨慎避免公开敏感的**调试信息**，因为这可能导致敏感数据的泄露。推荐使用工具 [**pidcat**](https://github.com/JakeWharton/pidcat) 和 `adb logcat` 来监控应用日志，以识别并保护敏感信息。**Pidcat** 因其易用性和可读性而常被优先使用。

> [!WARNING]
> 注意，从 **Android 4.0 之后的版本** 起，**应用只能访问自己的日志**。因此应用无法访问其他应用的日志。\
> 无论如何，仍建议**不要在日志中记录敏感信息**。

**Copy/Paste Buffer Caching**

Android 的**基于剪贴板**的框架支持应用间的复制粘贴功能，但这也带来了风险，因为**其他 applications**可以**访问**剪贴板，可能导致敏感数据泄露。对于应用中敏感的部分（如信用卡信息），应禁止复制/粘贴功能以防止数据泄露。

**Crash Logs**

如果应用**崩溃**并**保存日志**，这些日志可能帮助攻击者，尤其是在应用难以被逆向时。为降低风险，应避免在崩溃时记录敏感日志；如果必须通过网络传输日志，确保通过 SSL 通道发送以保证安全。

作为 pentester，**尝试查看这些日志**。

**Analytics Data Sent To 3rd Parties**

应用常常集成像 Google Adsense 这样的服务，如果开发者实现不当，可能会无意中 **leak sensitive data**。为识别潜在的数据泄露，建议**拦截应用的流量**并检查是否有敏感信息被发送到第三方服务。

### SQLite DBs

大多数应用会使用**内部 SQLite 数据库**来保存信息。在进行 pentest 时，检查创建的**数据库**、**表名**和**列名**以及保存的所有**数据**，因为你可能会发现**敏感信息**（这将构成一个漏洞）。\
数据库通常位于 `/data/data/the.package.name/databases`，例如 `/data/data/com.mwr.example.sieve/databases`

如果数据库保存机密信息并且是**加密的**，但你可以在应用中**找到密码**，这仍然是一个**漏洞**。

使用 `.tables` 列出表，使用 `.schema <table_name>` 列出表的列。

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** 允许你**扮演一个 Android 应用的角色**并与其他应用交互。它可以做任何已安装应用可以做的事，例如利用 Android 的进程间通信（IPC）机制并与底层操作系统交互。\
Drozer 是一个有用的工具，可以用来**利用 exported activities、exported services 和 Content Providers**，你将在接下来的章节中学习这些内容。

### 利用 exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
还要记住，Activity 的代码通常在 **`onCreate`** 方法中开始执行。

**Authorisation bypass**

当一个 Activity 被 **exported** 时，你可以从外部应用唤起它的界面。因此，如果一个包含**敏感信息**的 activity 被 **exported**，你可能能够**绕过**认证机制来访问它。

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

你也可以从 adb 启动一个 exported activity：

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**: MobSF 会将 activity 中将 `android:launchMode` 设为 _**singleTask/singleInstance**_ 视为恶意，但根据 [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)，显然这仅在较旧版本（API 版本 < 21）时才危险。

> [!TIP]
> 注意，authorisation bypass 并不总是漏洞；是否构成漏洞取决于绕过的实现方式以及暴露了哪些信息。

**敏感信息泄露**

Activities 也可以返回结果。如果你能找到一个被导出且未受保护的 activity 调用 **`setResult`** 方法并 **返回敏感信息**，则存在敏感信息泄露。

#### Tapjacking

如果没有防止 tapjacking，你可以滥用已导出的 activity 使 **用户执行意外操作**。有关 [**what is Tapjacking follow the link**](#tapjacking) 的更多信息。

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers 基本上用于 **共享数据**。如果一个应用有可用的 content providers，你可能能够从中**提取敏感**数据。也应测试可能的 **SQL injections** 和 **Path Traversals**，因为它们可能存在漏洞。

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
记住，Service 的行为从方法 `onStartCommand` 开始。

Service 本质上是可以**接收数据**、**处理**数据并**返回**（或不返回）响应的东西。因此，如果一个应用导出了某些 services，你应当**检查**其**代码**以理解它在做什么，并**动态测试**以提取机密信息、绕过认证机制等...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
记住，Broadcast Receiver 的操作从方法 `onReceive` 开始。

Broadcast receiver 会等待某种类型的消息。取决于接收者如何处理消息，它可能存在漏洞。\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

你可以手动查找 deep links，使用像 MobSF 这样的工具或像 [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) 这样的脚本。\
你可以使用 **adb** 或 **browser** 打开已声明的 **scheme**：
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_注意你可以**省略包名**，移动设备会自动调用应该打开该链接的应用。_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**执行的代码**

为查找 **App 中将被执行的代码**，转到 deeplink 调用的 activity 并搜索函数 **`onNewIntent`**。

![](<../../images/image (436) (1) (1) (1).png>)

**敏感信息**

每次发现 deep link 时，检查它是否不会通过 URL 参数接收敏感数据（例如密码），因为任何其他应用都可能**冒充该 deep link 并窃取这些数据！**

**路径中的参数**

你**还必须检查是否有 deep link 在 URL 的路径中使用参数**，例如：`https://api.example.com/v1/users/{username}`，在这种情况下你可以通过访问类似：`example://app/users?username=../../unwanted-endpoint%3fparam=value` 来强制进行路径遍历。\
注意，如果你在应用内部找到了正确的端点，可能能够导致 **Open Redirect**（如果路径的一部分被用作域名）、**account takeover**（如果你能在没有 CSRF token 的情况下修改用户详情，且易受攻击的端点使用了正确的方法）以及其他漏洞。更多信息请见 [info about this here](http://dphoeniixx.com/2020/12/13-2/)。

**更多示例**

一个关于链接（_/.well-known/assetlinks.json_）的有趣漏洞赏金报告：[interesting bug bounty report](https://hackerone.com/reports/855618)。

### 传输层检查与验证失败

- **Certificates 并非总是被 Android 应用正确检查**。这些应用常常忽略警告并接受自签名证书，或者在某些情况下回退使用 HTTP 连接。
- **SSL/TLS 握手期间的协商有时较弱**，使用不安全的加密套件。该弱点使连接容易受到 man-in-the-middle (MITM) 攻击，允许攻击者解密数据。
- **私人信息泄露** 是一种风险，当应用使用安全通道进行身份验证但在其他事务中通过非安全通道通信时，就无法保护敏感数据（例如会话 cookie 或用户详细信息）不被恶意方拦截。

#### Certificate Verification

我们将重点关注 **certificate verification**。必须验证服务器证书的完整性以增强安全性。这一点非常关键，因为不安全的 TLS 配置和通过未加密通道传输敏感数据会带来重大风险。有关验证服务器证书和修复漏洞的详细步骤，[**this resource**](https://manifestsecurity.com/android-application-security-part-10/) 提供了全面的指导。

#### SSL Pinning

SSL Pinning 是一种安全措施，应用将服务器证书与存储在应用内部的已知副本进行比对验证。该方法对于防止 MITM 攻击至关重要。强烈建议对处理敏感信息的应用实现 SSL Pinning。

#### Traffic Inspection

要检查 HTTP 流量，必须 **安装代理工具的证书**（例如 Burp）。如果不安装该证书，通过代理可能看不到加密流量。有关安装自定义 CA 证书的指南，[**点击这里**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)。

针对 **API Level 24 及以上** 的应用需要修改 Network Security Config 以接受代理的 CA 证书。这一步对于检查加密流量至关重要。有关修改 Network Security Config 的说明，[**参考本教程**](make-apk-accept-ca-certificate.md)。

如果使用 **Flutter**，需要遵循[**此页面**](flutter.md)中的说明。因为仅将证书添加到存储中不起作用，Flutter 有其自己的有效 CA 列表。

#### Static detection of SSL/TLS pinning

在尝试运行时绕过之前，先快速映射 APK 中强制 pinning 的位置。静态发现能帮助你规划 hooks/patches 并聚焦正确的代码路径。

Tool: SSLPinDetect
- 开源静态分析工具，将 APK 反编译为 Smali（通过 apktool）并扫描预设的正则模式以识别 SSL/TLS pinning 的实现。
- 为每个匹配报告精确的文件路径、行号和代码片段。
- 覆盖常见框架和自定义代码路径：OkHttp CertificatePinner、自定义 javax.net.ssl.X509TrustManager.checkServerTrusted、使用自定义 TrustManagers/KeyManagers 的 SSLContext.init，以及 Network Security Config XML 中的 pins。

Install
- 先决条件：Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
用法
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
示例模式规则 (JSON)
使用或扩展签名来检测专有/自定义 pinning 样式。你可以加载自己的 JSON 并在大规模上扫描。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- 对大型应用进行快速扫描：使用多线程和 memory-mapped I/O；预编译的 regex 可减少开销/误报。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 典型检测目标（用于下一步分类）：
- OkHttp：CertificatePinner 用法、setCertificatePinner、okhttp3/okhttp 包引用
- 自定义 TrustManagers：javax.net.ssl.X509TrustManager、checkServerTrusted 重写
- 自定义 SSL contexts：SSLContext.getInstance + 使用自定义 managers 的 SSLContext.init
- 声明式 pins 在 res/xml 的 network security config 和 manifest 引用中
- 使用匹配到的位置在动态测试前规划 Frida hooks、静态补丁或配置审查。

#### Bypassing SSL Pinning

When SSL Pinning is implemented, bypassing it becomes necessary to inspect HTTPS traffic. Various methods are available for this purpose:

- 自动使用 [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) **modify** **apk** 以 **bypass** SSLPinning。该方法的最大优点是无需 root 即可绕过 SSL Pinning，但需要删除并重装应用，而且并非在所有情况下都有效。
- 你可以使用 **Frida**（下文有讨论）来绕过该防护。这里有一篇使用 Burp+Frida+Genymotion 的指南： https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/
- 你也可以尝试使用 [**objection**](frida-tutorial/objection-tutorial.md) **自动绕过 SSL Pinning**：`objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- 你也可以尝试使用 **MobSF dynamic analysis**（下文解释）**自动绕过 SSL Pinning**
- 如果你仍然认为有流量未被捕获，可以尝试使用 iptables 将流量转发到 burp。阅读这篇博客： https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62

#### Looking for Common Web Vulnerabilities

应当在应用内部查找常见的 Web 漏洞。关于识别和缓解这些漏洞的详细信息超出本摘要范围，但在其他地方有详尽的覆盖。

### Frida

[Frida](https://www.frida.re) 是一个为开发人员、逆向工程师和安全研究人员设计的动态插桩工具包。\
**你可以访问正在运行的应用并在运行时 hook 方法以改变行为、修改/提取值或执行不同代码...**\
如果你要对 Android 应用进行 pentest，就需要掌握 Frida 的使用。

- 学习如何使用 Frida: [**Frida tutorial**](frida-tutorial/index.html)
- 一些用于 Frida 的 "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection 非常适合自动化使用 Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- 你可以在这里找到一些优秀的 Frida 脚本: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- 尝试按此方法加载 Frida 以绕过 anti-debugging / anti-frida 机制： https://erfur.github.io/blog/dev/code-injection-without-ptrace （工具 [linjector](https://github.com/erfur/linjector-rs)）

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

检查应用是否在内存中存储了不应存放的敏感信息，例如密码或助记词。

使用 [**Fridump3**](https://github.com/rootbsd/fridump3) 可以转储应用的内存，命令为：
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
这会将内存转储到 ./dump 文件夹，然后你可以在其中使用 grep 搜索，例如：
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore 中的敏感数据**

在 Android 中，Keystore 是存储敏感数据的最佳位置，但在拥有足够权限的情况下，**仍然可能被访问**。由于应用程序往往会在此处存储 **以明文形式的敏感数据**，pentests 应以 root user 身份检查这一点，或者对设备有物理访问的人可能会窃取这些数据。

即使应用将数据存储在 Keystore 中，数据也应该被加密。

要访问 Keystore 内的数据，可以使用这个 Frida 脚本： [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

使用下面的 Frida 脚本，可能可以**bypass fingerprint authentication**，绕过 Android 应用为**保护某些敏感区域：**而执行的验证。
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **后台快照**

当你将应用置于后台时，Android 会存储应用的一个**快照**，以便当它恢复到前台时，系统先加载该图像，给人一种应用加载更快的感觉。

不过，如果该快照包含**敏感信息**，有权访问该快照的人可能会**窃取这些信息**（注意，需要 root 权限才能访问）。

这些快照通常存储在：**`/data/system_ce/0/snapshots`**

Android 提供了一种方法，**通过设置 FLAG_SECURE 布局参数来防止截图被捕获**。使用该标志后，窗口内容会被视为安全，避免出现在截图中或在非安全显示设备上被查看。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

This tool could help you managing different tools during the dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

开发者经常会创建像 activities、services 和 broadcast receivers 这样的代理组件来处理这些 Intents，并将它们传递给诸如 `startActivity(...)` 或 `sendBroadcast(...)` 之类的方法，这可能存在风险。

危险在于允许攻击者通过误导这些 Intents 来触发非导出的应用组件或访问敏感的 content providers。一个显著的例子是 `WebView` 组件通过 `Intent.parseUri(...)` 将 URL 转换为 `Intent` 对象然后执行它们，这可能导致恶意的 Intent 注入。

### Essential Takeaways

- **Intent Injection** 类似于 Web 的 Open Redirect 问题。
- 利用方式通常涉及将 `Intent` 对象作为 extras 传递，这些 Intent 可以被重定向以执行不安全的操作。
- 这可能会向攻击者暴露非导出组件和 content providers。
- `WebView` 的 URL 到 `Intent` 的转换可能促成意外的行为。

### Android Client Side Injections and others

你可能在 Web 上已经了解过这类漏洞。在 Android 应用中对此类漏洞需特别小心：

- **SQL Injection:** 在处理动态查询或 Content-Providers 时，确保使用参数化查询。
- **JavaScript Injection (XSS):** 验证任何 WebViews 的 JavaScript 和 Plugin 支持已被禁用（默认禁用）。 [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** 应禁用 WebViews 对文件系统的访问（默认启用） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 在若干情况下，当 android 应用结束会话时 cookie 未被撤销，甚至可能被保存到磁盘
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that **MobSF** can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF 还允许你对分析结果进行 **diff/Compare**，并集成 **VirusTotal**（你需要在 _MobSF/settings.py_ 中设置 API key 并启用：`VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`）。你也可以将 `VT_UPLOAD` 设为 `False`，这时会上传 **hash** 而不是文件。

### 使用 MobSF 的辅助动态分析

**MobSF** 在 **Android** 的 **dynamic analysis** 中也非常有用，但在这种情况下你需要在宿主机上安装 MobSF 和 **genymotion**（VM 或 Docker 不可行）。_Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** 可以：

- **Dump application data** (URLs、日志、剪贴板、你手动截的截图、通过 "**Exported Activity Tester**" 生成的截图、邮件、SQLite 数据库、XML 文件以及其他生成的文件)。这些内容会自动收集，唯一例外是截图：截图需要你在需要时手动按下截屏，或者按 "**Exported Activity Tester**" 来获取所有导出活动的截图。
- 捕获 **HTTPS traffic**
- 使用 **Frida** 获取 **runtime** **information**

从 android **versions > 5** 开始，它会 **automatically start Frida** 并将全局 **proxy** 设置为 **capture** 流量。它只会捕获被测试应用的流量。

**Frida**

默认情况下，它还会使用一些 Frida 脚本来 **bypass SSL pinning**、**root detection** 和 **debugger detection**，以及 **monitor interesting APIs**。\
MobSF 还可以 **invoke exported activities**，抓取它们的 **screenshots** 并将其 **save** 到报告中。

要开始动态测试，请按绿色按钮：“**Start Instrumentation**”。按 “**Frida Live Logs**” 可查看 Frida 脚本生成的日志，按 “**Live API Monitor**” 可查看对 hook 方法的所有调用、传入参数和返回值（该项在按下 "Start Instrumentation" 后可见）。\
MobSF 还允许你加载自己的 **Frida scripts**（若要把你自己的 Frida 脚本结果发送到 MobSF，请使用函数 `send()`）。它也自带 **several pre-written scripts** 可供加载（你可以在 `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` 中添加更多脚本），只需 **select them**，按 “**Load**”，然后按 “**Start Instrumentation**”（你可以在 “**Frida Live Logs**” 中看到这些脚本的日志）。

![](<../../images/image (419).png>)

此外，你还有一些辅助的 Frida 功能：

- **Enumerate Loaded Classes**：打印所有已加载的类
- **Capture Strings**：在使用应用时打印捕获到的字符串（噪音很大）
- **Capture String Comparisons**：非常有用。会 **显示被比较的两个字符串** 以及比较结果是 True 还是 False。
- **Enumerate Class Methods**：输入类名（例如 "java.io.File"），将打印该类的所有方法。
- **Search Class Pattern**：按模式搜索类
- **Trace Class Methods**：**Trace** 整个类（查看该类所有方法的输入和输出）。请记住，默认情况下 MobSF 会跟踪若干有趣的 Android API 方法。

一旦选择了要使用的辅助模块，你需要按 “**Start Intrumentation**”，你将在 “**Frida Live Logs**” 中看到所有输出。

**Shell**

MobSF 在动态分析页面底部还提供了一个 shell，包含一些 **adb** 命令、**MobSF commands** 和常用的 **shell** **commands**。一些有趣的命令：
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

当 http 流量被捕获时，你可以在“**HTTP(S) Traffic**”按钮看到原始且不友好的流量视图，或者在绿色的“**Start HTTPTools**”按钮看到更漂亮的视图。从第二个选项，你可以将 **captured requests** **send** 到像 Burp 或 Owasp ZAP 这样的代理（**proxies**）。\
操作步骤：_启动 Burp -->_ _关闭 Intercept --> 在 MobSB HTTPTools 选择请求_ --> 点击“**Send to Fuzzer**” --> _选择代理地址_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

在使用 MobSF 完成动态分析后，你可以点击“**Start Web API Fuzzer**”来对 **fuzz http requests** 进行模糊测试并查找漏洞。

> [!TIP]
> 在使用 MobSF 进行动态分析后，代理设置可能会被错误配置且无法通过 GUI 修复。你可以通过以下命令修复代理设置：
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

你可以从 [**Inspeckage**](https://github.com/ac-pm/Inspeckage) 获取该工具。\
该工具会使用一些 **Hooks**，在你执行 **dynamic analysis** 时告诉你应用中正在发生什么。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

这是一个用于带 GUI 的静态分析的优秀工具，界面友好，便于查看分析结果。 

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

该工具旨在查找多种与安全相关的 Android 应用漏洞，既可以分析 **source code**，也可以分析 **packaged APKs**。该工具还**能够创建可部署的 "Proof-of-Concept" APK** 和 **ADB commands**，以利用发现的一些漏洞（如暴露的 activities、intents、tapjacking 等）。与 Drozer 一样，测试设备无需 root。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 显示所有提取的文件，便于参考
- 自动将 APK 文件反编译为 Java 和 Smali 格式
- 分析 AndroidManifest.xml 以查找常见漏洞和行为
- 对源代码进行静态分析以查找常见漏洞和行为
- 设备信息
- 等等
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER 是一个命令行应用程序，可在 Windows、MacOS X 和 Linux 上使用，用于分析 _.apk_ 文件以查找漏洞。它通过解压 APK 并应用一系列规则来检测这些漏洞。

所有规则集中在 `rules.json` 文件中，每个公司或测试人员都可以创建自己的规则来满足分析需求。

从 [download page](https://superanalyzer.rocks/download.html) 下载最新的二进制文件。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn 是一个**跨平台**工具，帮助开发者、bugbounty hunters 和 ethical hackers 对移动应用进行 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)。

其概念是你将移动应用文件（.apk 或 .ipa 文件）拖放到 StaCoAn 应用中，它会为你生成一个可视化且可移植的报告。你可以调整设置和 wordlists 以获得自定义的体验。

下载[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework 是一个 Android 漏洞分析系统，帮助开发者或黑客发现 Android 应用中潜在的安全漏洞。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** 是一个工具，主要用于检测并提醒用户 Android 应用可能产生的潜在恶意行为。

检测通过对应用的 Dalvik 字节码（以 **Smali** 表示）进行 **static analysis**，并使用 [`androguard`](https://github.com/androguard/androguard) 库来完成。

该工具查找 **常见的“恶意”应用行为**，例如：Telephony identifiers exfiltration、Audio/video flow interception、PIM data modification、Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** 是一个 **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework。该工具整合了常用的移动应用逆向和分析工具，帮助针对 OWASP mobile security threats 对移动应用进行测试。其目标是让移动应用开发者和安全人员更容易、更友好地完成该任务。

它能够：

- 使用不同工具提取 Java 和 Smali 代码
- 使用以下工具分析 APK: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 使用正则表达式从 APK 中提取私有信息
- 分析 Manifest
- 使用以下工具分析发现的域名: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) 和 [whatweb](https://github.com/urbanadventurer/WhatWeb)
- 通过 [apk-deguard.com](http://www.apk-deguard.com) 对 APK 进行去混淆

### Koodous

用于检测 malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

请注意，根据用于混淆代码的服务和配置不同，敏感信息可能会被混淆，也可能不会被混淆。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

来自 [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** 是一个开源命令行工具，用于缩小、优化和混淆 Java 代码。它能够优化 bytecode 并检测和移除未使用的指令。ProGuard 是自由软件，依据 GNU General Public License, version 2 发布。

ProGuard 随 Android SDK 一起分发，并在以 release 模式构建应用时运行。

### [DexGuard](https://www.guardsquare.com/dexguard)

在 [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html) 可以找到对 apk 进行去混淆的分步指南。

（摘自该指南）我们上次检查时，Dexguard 的运行模式是：

- 将资源作为 InputStream 加载；
- 将结果传给继承自 FilterInputStream 的类以对其进行解密；
- 做一些无用的混淆以浪费逆向者的时间；
- 将解密后的结果传给 ZipInputStream 以获取 DEX 文件；
- 最后使用 `loadDex` 方法将生成的 DEX 作为 Resource 加载。

### [DeGuard](http://apk-deguard.com)

**DeGuard 逆转了 Android 混淆工具所执行的混淆过程。这使得包括代码检查和库识别在内的大量安全分析成为可能。**

你可以将混淆的 APK 上传到他们的平台。

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

这是一个 LLM 工具，用于发现 android apps 中的潜在安全漏洞并对 android app 代码进行去混淆。使用 Google's Gemini public API。

### [Simplify](https://github.com/CalebFenton/simplify)

它是一个 **通用的 android 去混淆器。** Simplify **虚拟执行应用** 以理解其行为，然后 **尝试优化代码**，使其在行为上与原来相同，但更易于人类理解。每种优化类型都简单且通用，因此具体使用了哪种混淆方式并不重要。

### [APKiD](https://github.com/rednaga/APKiD)

APKiD 会告诉你 **一个 APK 是如何被制作的**。它能够识别许多 **compilers**、**packers**、**obfuscators** 以及其他奇怪的东西。它是 Android 上的 [_PEiD_]。

### Manual

[阅读此教程以学习一些关于 **如何逆转自定义混淆** 的技巧](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b 是一个基于 ubuntu-mate 的 Android 安全虚拟机，包含来自不同安全研究者的最新框架、教程和用于逆向工程与 malware 分析的实验。

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 这是一个很棒的资源列表
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 快速课程
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
