# Pentesting de Aplicaciones Android

{{#include ../../banners/hacktricks-training.md}}

## Conceptos básicos de Aplicaciones Android

Es muy recomendable comenzar leyendo esta página para conocer las **partes más importantes relacionadas con la seguridad de Android y los componentes más peligrosos en una aplicación Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

This is the main tool you need to connect to an android device (emulated or physical).\
**ADB** allows to control devices either over **USB** or **Network** from a computer. This utility enables the **copying** of files in both directions, **installation** and **uninstallation** of apps, **execution** of shell commands, **backing up** of data, **reading** of logs, among other functions.

Take a look to the following list of [**Comandos ADB**](adb-commands.md) to learn how to use adb.

## Smali

A veces es interesante **modificar el código de la aplicación** para acceder a **información oculta** (por ejemplo contraseñas u otros valores bien ofuscados o flags). En ese caso, puede interesar decompilar el APK, modificar el código y recompilarlo.\
[**En este tutorial** puedes **aprender cómo decompilar un APK, modificar código Smali y recompilar el APK** con la nueva funcionalidad](smali-changes.md). Esto puede ser muy útil como **alternativa para varias pruebas durante el análisis dinámico** que se van a presentar. Entonces, **mantén siempre presente esta posibilidad**.

## Otros trucos interesantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extraer APK del dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusiona todos los splits y los base apks con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile: Ataques

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Casos de estudio & Vulnerabilidades


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Análisis estático

Primero, para analizar un APK deberías **echar un vistazo al código Java** usando un decompiler.\
Por favor, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Buscando información interesante

Con solo revisar las **strings** del APK puedes buscar **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** y cualquier cosa interesante... busca incluso **backdoors** de ejecución de código o backdoors de autenticación (credenciales admin hardcoded en la app).

**Firebase**

Presta especial atención a los **firebase URLs** y verifica si están mal configurados. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensión básica de la aplicación - Manifest.xml, strings.xml

La **examinación de los archivos _Manifest.xml_ y **_strings.xml_** de una aplicación puede revelar vulnerabilidades de seguridad potenciales**. Estos archivos pueden accederse usando decompilers o renombrando la extensión del APK a .zip y descomprimiéndolo.

Las **vulnerabilidades** identificables a partir del **Manifest.xml** incluyen:

- **Debuggable Applications**: Las aplicaciones marcadas como debuggable (`debuggable="true"`) en el _Manifest.xml_ representan un riesgo ya que permiten conexiones que pueden llevar a explotación. Para entender cómo explotar aplicaciones debuggable, consulta un tutorial sobre cómo encontrar y explotar aplicaciones debuggable en un dispositivo.
- **Backup Settings**: El atributo `android:allowBackup="false"` debe establecerse explícitamente para aplicaciones que manejan información sensible para prevenir backups no autorizados vía adb, especialmente cuando usb debugging está habilitado.
- **Network Security**: Las configuraciones de seguridad de red personalizadas (`android:networkSecurityConfig="@xml/network_security_config"`) en _res/xml/_ pueden especificar detalles como certificate pins y ajustes de tráfico HTTP. Un ejemplo es permitir tráfico HTTP para dominios específicos.
- **Exported Activities and Services**: Identificar actividades y servicios exportados en el manifest puede resaltar componentes que podrían ser mal usados. Un análisis adicional durante las pruebas dinámicas puede revelar cómo explotar estos componentes.
- **Content Providers and FileProviders**: Los content providers expuestos podrían permitir acceso o modificación no autorizada de datos. La configuración de FileProviders también debe revisarse cuidadosamente.
- **Broadcast Receivers and URL Schemes**: Estos componentes podrían aprovecharse para explotación, prestando especial atención a cómo se gestionan los URL schemes para vulnerabilidades de entrada.
- **SDK Versions**: Los atributos `minSdkVersion`, `targetSDKVersion` y `maxSdkVersion` indican las versiones de Android soportadas, subrayando la importancia de no soportar versiones antiguas y vulnerables de Android por razones de seguridad.

Desde el archivo **strings.xml**, se puede descubrir información sensible como API keys, custom schemas y otras notas de desarrollador, lo que subraya la necesidad de revisar cuidadosamente estos recursos.

### Tapjacking

**Tapjacking** es un ataque donde una **malicious** **application** se lanza y **se posiciona encima de una aplicación víctima**. Una vez que oculta visualmente la app víctima, su interfaz está diseñada para engañar al usuario y hacerle interactuar, mientras pasa la interacción a la app víctima.\
En efecto, está **cegando al usuario para que no sepa que en realidad está realizando acciones en la aplicación víctima**.

Encuentra más información en:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Una **activity** con `launchMode` establecido a **`singleTask` sin ningún `taskAffinity`** definido es vulnerable a task Hijacking. Esto significa que una **application** puede ser instalada y, si se lanza antes que la aplicación real, podría **secuestrar el task de la aplicación real** (por lo que el usuario estará interactuando con la **malicious application** pensando que está usando la original).

Más info en:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Almacenamiento de datos inseguro

**Internal Storage**

En Android, los archivos **almacenados** en **internal** storage están **diseñados** para ser **accesibles** exclusivamente por la **app** que los **creó**. Esta medida de seguridad es **impuesta** por el sistema operativo Android y suele ser adecuada para las necesidades de seguridad de la mayoría de las aplicaciones. Sin embargo, los desarrolladores a veces utilizan modos como `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` para **permitir** que los archivos sean **compartidos** entre diferentes aplicaciones. Estos modos, sin embargo, **no restringen el acceso** a estos archivos por otras aplicaciones, incluidas aplicaciones potencialmente maliciosas.

1. **Análisis Estático:**
- **Asegúrate** de que el uso de `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` sea **revisado cuidadosamente**. Estos modos **pueden exponer** archivos a **accesos no intencionados o no autorizados**.
2. **Análisis Dinámico:**
- **Verifica** los **permisos** establecidos en los archivos creados por la app. Específicamente, **comprueba** si algún archivo está **configurado como legible o escribible por todo el mundo**. Esto puede suponer un riesgo de seguridad significativo, ya que permitiría a **cualquier aplicación** instalada en el dispositivo, independientemente de su origen o intención, **leer o modificar** esos archivos.

**External Storage**

Al tratar con archivos en **external storage**, como SD Cards, se deben tomar ciertas precauciones:

1. **Accesibilidad**:
- Los archivos en external storage son **globalmente legibles y escribibles**. Esto significa que cualquier aplicación o usuario puede acceder a ellos.
2. **Preocupaciones de seguridad**:
- Dada la facilidad de acceso, se recomienda **no almacenar información sensible** en external storage.
- El external storage puede ser removido o accedido por cualquier aplicación, lo que lo hace menos seguro.
3. **Manejo de datos desde external storage**:
- Siempre **realiza validación de entrada** sobre los datos recuperados del external storage. Esto es crucial porque los datos provienen de una fuente no confiable.
- Desaconsejado almacenar ejecutables o class files en external storage para su carga dinámica.
- Si tu aplicación debe recuperar archivos ejecutables desde external storage, asegúrate de que esos archivos estén **signed y verificados criptográficamente** antes de cargarlos dinámicamente. Este paso es vital para mantener la integridad de seguridad de tu aplicación.

El external storage puede ser **accedido** en `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> A partir de Android 4.4 (**API 17**), la SD card tiene una estructura de directorios que **limita el acceso de una app al directorio que es específicamente para esa app**. Esto evita que una aplicación maliciosa obtenga acceso de lectura o escritura a los archivos de otra app.

**Datos sensibles almacenados en texto claro**

- **Shared preferences**: Android permite a cada aplicación guardar fácilmente archivos xml en la ruta `/data/data/<packagename>/shared_prefs/` y a veces es posible encontrar información sensible en texto claro en esa carpeta.
- **Databases**: Android permite a cada aplicación guardar fácilmente bases de datos sqlite en la ruta `/data/data/<packagename>/databases/` y a veces es posible encontrar información sensible en texto claro en esa carpeta.

### Broken TLS

**Accept All Certificates**

Por alguna razón, a veces los desarrolladores aceptan todos los certificados incluso si, por ejemplo, el hostname no coincide, con líneas de código como la siguiente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Una buena forma de probar esto es intentar capturar el tráfico usando algún proxy como Burp sin autorizar la CA de Burp dentro del dispositivo. También puedes generar con Burp un certificado para un hostname distinto y usarlo.

### Broken Cryptography

**Poor Key Management Processes**

Algunos desarrolladores guardan datos sensibles en el almacenamiento local y los cifran con una clave hardcoded/predictable en el código. Esto no debería hacerse, ya que algún reversing podría permitir a los atacantes extraer la información confidencial.

**Use of Insecure and/or Deprecated Algorithms**

Los desarrolladores no deberían usar **algoritmos obsoletos** para realizar **checks** de autorización, **almacenar** o **enviar** datos. Algunos de estos algoritmos son: RC4, MD4, MD5, SHA1... Si se usan **hashes** para almacenar contraseñas por ejemplo, deben emplearse hashes resistentes a brute-force con salt.

### Other checks

- Se recomienda **ofuscar el APK** para dificultar el trabajo de reverse engineering a los atacantes.
- Si la app es sensible (como aplicaciones bancarias), debería realizar sus **propias comprobaciones para detectar si el móvil está rooteado** y actuar en consecuencia.
- Si la app es sensible (como aplicaciones bancarias), debería comprobar si se está usando un **emulador**.
- Si la app es sensible (como aplicaciones bancarias), debería **verificar su propia integridad antes de ejecutarse** para comprobar si fue modificada.
- Usa [**APKiD**](https://github.com/rednaga/APKiD) para verificar qué compiler/packer/obfuscator se usó para construir el APK

### React Native Application

Lee la siguiente página para aprender cómo acceder fácilmente al código javascript de aplicaciones React:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Lee la siguiente página para aprender cómo acceder fácilmente al código C# de una aplicación xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Según este [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked es un algoritmo de Meta que comprime el contenido de una aplicación en un único fichero. El blog habla sobre la posibilidad de crear una app que descomprima este tipo de apps... y una forma más rápida que implica **ejecutar la aplicación y recopilar los ficheros descomprimidos desde el filesystem.**

### Automated Static Code Analysis

La herramienta [**mariana-trench**](https://github.com/facebook/mariana-trench) es capaz de encontrar **vulnerabilidades** mediante el **scaneo** del **código** de la aplicación. Esta herramienta contiene una serie de **fuentes conocidas** (que indican a la herramienta los **lugares** donde la **entrada** es **controlada por el usuario**), **sinks** (que indican a la herramienta **lugares peligrosos** donde una entrada maliciosa del usuario podría causar daños) y **rules**. Estas reglas indican la **combinación** de **fuentes-sinks** que señalan una vulnerabilidad.

Con este conocimiento, **mariana-trench revisará el código y encontrará posibles vulnerabilidades en él**.

### Secrets leaked

Una aplicación puede contener secretos (API keys, passwords, hidden urls, subdomains...) dentro de ella que podrías llegar a descubrir. Podrías usar una herramienta como [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

Puedes crear una **cuenta gratuita** en: [https://appetize.io/](https://appetize.io). Esta plataforma te permite **subir** y **ejecutar** APKs, por lo que es útil para ver cómo se comporta un apk.

Incluso puedes **ver los logs de tu aplicación** en la web y conectarte mediante **adb**.

![](<../../images/image (831).png>)

Gracias a la conexión ADB puedes usar **Drozer** y **Frida** dentro de los emuladores.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Puedes crear dispositivos **x86** y **arm**, y según [**esto**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) las **últimas x86** versiones **soportan librerías ARM** sin necesitar un emulador ARM lento).
- Aprende a configurarlo en esta página:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(versión gratuita:** Personal Edition, necesitas crear una cuenta. _Se recomienda **descargar** la versión **WITH** _**VirtualBox** para evitar errores potenciales._)
- [**Nox**](https://es.bignox.com) (Gratis, pero no soporta Frida ni Drozer).

> [!TIP]
> Al crear un nuevo emulador en cualquier plataforma recuerda que cuanto más grande sea la pantalla, más lento funcionará el emulador. Así que selecciona pantallas pequeñas si es posible.

Para **instalar google services** (como AppStore) en Genymotion necesitas clicar en el botón marcado en rojo de la siguiente imagen:

![](<../../images/image (277).png>)

También, fíjate que en la **configuración de la VM Android en Genymotion** puedes seleccionar **Bridge Network mode** (esto será útil si vas a conectarte a la VM Android desde una VM diferente con las herramientas).

#### Use a physical device

Necesitas activar las opciones de **debugging** y será ideal si puedes **rootearlo**:

1. **Settings**.
2. (FromAndroid 8.0) Selecciona **System**.
3. Selecciona **About phone**.
4. Pulsa **Build number** 7 veces.
5. Vuelve atrás y encontrarás **Developer options**.

> Una vez que hayas instalado la aplicación, lo primero que deberías hacer es probarla e investigar qué hace, cómo funciona y familiarizarte con ella.\
> Sugiero **realizar este análisis dinámico inicial usando MobSF dynamic analysis + pidcat**, de modo que podamos **aprender cómo funciona la aplicación** mientras MobSF **captura** una gran cantidad de **datos interesantes** que puedes revisar más tarde.

Magisk/Zygisk quick notes (recomendado en dispositivos Pixel)
- Parchea boot.img con la app Magisk y flashea vía fastboot para obtener root systemless
- Habilita Zygisk + DenyList para ocultar root; considera LSPosed/Shamiko cuando se requiera ocultación más fuerte
- Conserva el boot.img original para recuperar tras actualizaciones OTA; re-parchea después de cada OTA
- Para mirror de pantalla, usa scrcpy en el host



### Unintended Data Leakage

**Logging**

Los desarrolladores deben ser cautelosos al exponer **información de depuración** públicamente, ya que puede provocar data leaks de datos sensibles. Se recomiendan las herramientas [**pidcat**](https://github.com/JakeWharton/pidcat) y `adb logcat` para monitorizar los logs de la aplicación y detectar y proteger información sensible. **Pidcat** es preferido por su facilidad de uso y legibilidad.

> [!WARNING]
> Ten en cuenta que desde **versiones posteriores a Android 4.0**, **las aplicaciones solo pueden acceder a sus propios logs**. Así que las aplicaciones no pueden acceder a los logs de otras apps.\
> Aun así, se recomienda **no registrar información sensible**.

**Copy/Paste Buffer Caching**

El framework de **portapapeles** de Android permite la funcionalidad de copiar-pegar en las apps, pero supone un riesgo ya que **otras aplicaciones** pueden **acceder** al portapapeles, exponiendo potencialmente datos sensibles. Es crucial **deshabilitar las funciones de copiar/pegar** para secciones sensibles de una aplicación, como los datos de tarjetas de crédito, para prevenir leaks.

**Crash Logs**

Si una aplicación **crashea** y **guarda logs**, esos logs pueden ayudar a los atacantes, especialmente cuando la aplicación no puede ser reverse-engineered. Para mitigar este riesgo, evita registrar en los crashes, y si los logs deben transmitirse por la red, asegúrate de enviarlos a través de un canal SSL para seguridad.

Como pentester, **intenta revisar estos logs**.

**Analytics Data Sent To 3rd Parties**

Las aplicaciones a menudo integran servicios como Google Adsense, lo que puede inadvertidamente causar data leaks de datos sensibles debido a una implementación inadecuada por parte de los desarrolladores. Para identificar posibles leaks de datos, es aconsejable **interceptar el tráfico de la aplicación** y comprobar si se envía información sensible a servicios de terceros.

### SQLite DBs

La mayoría de las aplicaciones usarán **bases de datos SQLite internas** para guardar información. Durante el pentest revisa las **bases de datos** creadas, los nombres de **tablas** y **columnas** y todos los **datos** guardados porque podrías encontrar **información sensible** (lo cual sería una vulnerabilidad).\
Las bases de datos deberían situarse en `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`

Si la base de datos guarda información confidencial y está **encrypted** pero puedes **encontrar** la **password** dentro de la aplicación, sigue siendo una **vulnerabilidad**.

Enumera las tablas usando `.tables` y enumera las columnas de las tablas con `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** te permite **asumir el rol de una app Android** e interactuar con otras apps. Puede hacer **cualquier cosa que una aplicación instalada pueda hacer**, como utilizar el mecanismo de Inter-Process Communication (IPC) de Android e interactuar con el sistema operativo subyacente. .\
Drozer es una herramienta útil para **explotar exported activities, exported services y Content Providers** como aprenderás en las siguientes secciones.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
También recuerda que el código de una activity comienza en el método **`onCreate`**.

**Authorisation bypass**

Cuando una Activity está exportada puedes invocar su pantalla desde una app externa. Por tanto, si una activity con **información sensible** está **exported** podrías **bypassear** los **mecanismos de autenticación** para acceder a ella.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

También puedes iniciar una activity exportada desde adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Ten en cuenta que un authorisation bypass no siempre es una vulnerabilidad; dependerá de cómo funcione el bypass y de qué información se exponga.

**Filtración de información sensible**

Las Activities también pueden devolver resultados. Si consigues encontrar una activity exportada y desprotegida que llame al método **`setResult`** y **devuelva información sensible**, existe una filtración de información sensible.

#### Tapjacking

Si no se previene el Tapjacking, podrías abusar de la activity exportada para hacer que el **usuario realice acciones inesperadas**. Para más info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers are basically used to **share data**. Si una app tiene content providers disponibles, podrías ser capaz de **extraer datos sensibles** de ellos. También es interesante probar posibles **SQL injections** y **Path Traversals**, ya que podrían ser vulnerables.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Recuerda que las acciones de un Service comienzan en el método `onStartCommand`.

Un service es básicamente algo que **puede recibir datos**, **procesarlos** y **devolver** (o no) una respuesta. Entonces, si una aplicación está exportando algunos services deberías **revisar** el **código** para entender qué está haciendo y **probarlo** **dinámicamente** para extraer información confidencial, bypassing authentication measures...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Recuerda que las acciones de un Broadcast Receiver comienzan en el método `onReceive`.

Un broadcast receiver esperará un tipo de mensaje. Dependiendo de cómo el receiver maneje el mensaje, podría ser vulnerable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puedes **abrir** un declarado **scheme** usando **adb** o un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Tenga en cuenta que puede **omitir el nombre del paquete** y el dispositivo móvil llamará automáticamente la app que debería abrir ese enlace._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código ejecutado**

Para encontrar el **código que se ejecutará en la App**, ve a la activity llamada por el deeplink y busca la función **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Información sensible**

Cada vez que encuentres un deep link, comprueba que **no esté recibiendo datos sensibles (como contraseñas) vía URL parameters**, porque cualquier otra aplicación podría **hacerse pasar por el deep link y robar esos datos**.

**Parámetros en el path**

También **debes comprobar si algún deep link usa un parámetro dentro del path** de la URL como: `https://api.example.com/v1/users/{username}`, en ese caso puedes forzar un path traversal accediendo a algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Ten en cuenta que si encuentras los endpoints correctos dentro de la aplicación podrías provocar un **Open Redirect** (si parte del path se usa como nombre de dominio), **account takeover** (si puedes modificar detalles de usuarios sin CSRF token y el vuln endpoint usaba el método correcto) y cualquier otra vuln. Más [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Un [interesting bug bounty report](https://hackerone.com/reports/855618) sobre links (_/.well-known/assetlinks.json_).

### Inspección de la capa de transporte y fallos de verificación

- **Certificates are not always inspected properly** por aplicaciones Android. Es común que estas aplicaciones ignoren las advertencias y acepten self-signed certificates o, en algunos casos, vuelvan a usar conexiones HTTP.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, empleando cipher suites inseguras. Esta vulnerabilidad hace que la conexión sea susceptible a ataques man-in-the-middle (MITM), permitiendo a los atacantes descifrar los datos.
- **Filtración de información privada** es un riesgo cuando las aplicaciones se autentican usando canales seguros pero luego comunican sobre canales no seguros para otras transacciones. Este enfoque no protege datos sensibles, como session cookies o detalles de usuario, frente a la intercepción por actores maliciosos.

#### Verificación de certificados

Nos centraremos en la **verificación de certificados**. La integridad del certificado del servidor debe verificarse para mejorar la seguridad. Esto es crucial porque las configuraciones TLS inseguras y la transmisión de datos sensibles por canales no cifrados pueden suponer riesgos significativos. Para pasos detallados sobre cómo verificar certificados de servidor y abordar vulnerabilidades, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) ofrece una guía completa.

#### SSL Pinning

SSL Pinning es una medida de seguridad donde la aplicación verifica el certificado del servidor contra una copia conocida almacenada dentro de la propia aplicación. Este método es esencial para prevenir ataques MITM. Se recomienda encarecidamente implementar SSL Pinning en aplicaciones que manejen información sensible.

#### Inspección de tráfico

Para inspeccionar tráfico HTTP, es necesario **instalar el certificado de la herramienta proxy** (por ejemplo, Burp). Sin instalar este certificado, el tráfico cifrado puede no ser visible a través del proxy. Para una guía sobre cómo instalar un CA certificate personalizado, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Las aplicaciones que targetean **API Level 24 and above** requieren modificaciones en el Network Security Config para aceptar el CA certificate del proxy. Este paso es crítico para inspeccionar tráfico cifrado. Para instrucciones sobre cómo modificar el Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Si se está usando **Flutter** necesitas seguir las instrucciones en [**this page**](flutter.md). Esto se debe a que, simplemente añadir el certificado al store no funcionará ya que Flutter tiene su propia lista de CAs válidas.

#### Detección estática de SSL/TLS pinning

Antes de intentar bypasses en tiempo de ejecución, mapea rápidamente dónde se aplica el pinning en el APK. El descubrimiento estático te ayuda a planear hooks/patches y a centrarte en las rutas de código correctas.

Tool: SSLPinDetect
- Open-source static-analysis utility que decompila el APK a Smali (via apktool) y escanea patrones regex curados de implementaciones de SSL/TLS pinning.
- Reports exact file path, line number, and a code snippet for each match.
- Cubre frameworks comunes y rutas de código custom: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Ejemplo de reglas de patrones (JSON)
Usa o amplía firmas para detectar estilos propietarios/personalizados de pinning. Puedes cargar tu propio JSON y escanear a gran escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notas y consejos
- Escaneo rápido en aplicaciones grandes mediante multihilo y I/O mapeada en memoria; las regex precompiladas reducen la sobrecarga/falsos positivos.
- Colección de patrones: https://github.com/aancw/smali-sslpin-patterns
- Objetivos típicos de detección para priorizar a continuación:
- OkHttp: uso de CertificatePinner, setCertificatePinner, referencias al paquete okhttp3/okhttp
- TrustManagers personalizados: javax.net.ssl.X509TrustManager, sobrescrituras de checkServerTrusted
- Contextos SSL personalizados: SSLContext.getInstance + SSLContext.init con managers personalizados
- Pins declarativos en res/xml network security config y referencias en el manifest
- Usa las ubicaciones coincidentes para planear hooks de Frida, parches estáticos o revisiones de configuración antes del testing dinámico.



#### Evasión de SSL Pinning

Cuando se implementa SSL Pinning, evadirlo se vuelve necesario para inspeccionar el tráfico HTTPS. Existen varios métodos disponibles para este propósito:

- Automáticamente **modificar** el **apk** para **evadir** SSLPinning con [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). La principal ventaja de esta opción es que no necesitarás root para evadir SSL Pinning, pero tendrás que eliminar la aplicación e instalar la nueva, y esto no siempre funcionará.
- Puedes usar **Frida** (se discute más abajo) para evadir esta protección. Aquí tienes una guía para usar Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- También puedes intentar **evadir automáticamente SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- También puedes intentar **evadir automáticamente SSL Pinning** usando **MobSF dynamic analysis** (explicado abajo)
- Si aún crees que hay tráfico que no estás capturando, puedes intentar **reenviar el tráfico a Burp usando iptables**. Lee este blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Búsqueda de vulnerabilidades web comunes

También es importante buscar vulnerabilidades web comunes dentro de la aplicación. La información detallada sobre cómo identificarlas y mitigarlas está fuera del alcance de este resumen, pero se trata extensamente en otros recursos.

### Frida

[Frida](https://www.frida.re) es un toolkit de instrumentación dinámica para desarrolladores, reverse engineers e investigadores de seguridad.\
**Puedes acceder a la aplicación en ejecución y hookear métodos en tiempo de ejecución para cambiar el comportamiento, modificar valores, extraer valores, ejecutar código distinto...**\
Si quieres pentest aplicaciones Android necesitas saber cómo usar Frida.

- Aprende a usar Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Algunas "GUI" para acciones con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection es genial para automatizar el uso de Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puedes encontrar algunos Awesome Frida scripts aquí: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Intenta evadir mecanismos anti-debugging / anti-frida cargando Frida como se indica en [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (herramienta [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Volcado de memoria - Fridump**

Comprueba si la aplicación está almacenando información sensible en la memoria que no debería, como contraseñas o mnemónicos.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) puedes volcar la memoria de la app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Esto volcará la memoria en la carpeta ./dump, y allí podrías usar grep con algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitive data in Keystore**

En Android el Keystore es el mejor lugar para almacenar datos sensibles, sin embargo, con suficientes privilegios todavía es **posible acceder a él**. Como las aplicaciones tienden a almacenar aquí **datos sensibles en texto claro**, los pentests deben comprobarlo ya que un usuario root o alguien con acceso físico al dispositivo podría robar estos datos.

Incluso si una app almacenó datos en el Keystore, los datos deberían estar cifrados.

Para acceder a los datos dentro del keystore puedes usar este script de Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando el siguiente script de Frida podría ser posible **bypass fingerprint authentication** que las aplicaciones Android podrían implementar para **proteger ciertas áreas sensibles:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imágenes de fondo**

Cuando envías una aplicación a segundo plano, Android almacena una **instantánea de la aplicación** para que, cuando se recupere al primer plano, empiece cargando la imagen antes que la app, dando la impresión de que la aplicación se cargó más rápido.

Sin embargo, si esta instantánea contiene **información sensible**, alguien con acceso a la instantánea podría **robar esa información** (nota: se necesita root para acceder a ella).

Las instantáneas normalmente se almacenan en: **`/data/system_ce/0/snapshots`**

Android ofrece una forma de **evitar la captura de pantalla estableciendo el parámetro de layout FLAG_SECURE**. Al usar este flag, el contenido de la ventana se trata como seguro, impidiendo que aparezca en capturas de pantalla o que se muestre en displays no seguros.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Esta herramienta puede ayudarte a gestionar diferentes herramientas durante el análisis dinámico: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Los desarrolladores a menudo crean componentes proxy como activities, services y broadcast receivers que manejan estos Intents y los pasan a métodos como `startActivity(...)` o `sendBroadcast(...)`, lo cual puede ser arriesgado.

El peligro radica en permitir que atacantes desencadenen componentes de la app no exportados o accedan a content providers sensibles redirigiendo estos Intents. Un ejemplo notable es el componente `WebView` que convierte URLs en objetos `Intent` vía `Intent.parseUri(...)` y luego los ejecuta, lo que puede llevar a inyecciones maliciosas de Intent.

### Essential Takeaways

- **Intent Injection** es similar al problema Open Redirect en la web.
- Los exploits implican pasar objetos `Intent` como extras, que pueden ser redirigidos para ejecutar operaciones inseguras.
- Puede exponer componentes no exportados y content providers a atacantes.
- La conversión de URLs a `Intent` por parte de `WebView` puede facilitar acciones no deseadas.

### Android Client Side Injections and others

Probablemente conozcas este tipo de vulnerabilidades por la web. Debes tener especial cuidado con estas vulnerabilidades en una aplicación Android:

- **SQL Injection:** Cuando manejes consultas dinámicas o Content-Providers, asegúrate de usar consultas parametrizadas.
- **JavaScript Injection (XSS):** Verifica que el soporte de JavaScript y Plugin esté deshabilitado para cualquier WebViews (deshabilitado por defecto). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews deberían tener deshabilitado el acceso al sistema de archivos (habilitado por defecto) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: En varios casos, cuando la aplicación Android termina la sesión, la cookie no se revoca o incluso puede guardarse en disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análisis estático**

![](<../../images/image (866).png>)

**Evaluación de vulnerabilidades de la aplicación** usando una agradable interfaz web. También puedes realizar análisis dinámico (pero necesitas preparar el entorno).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Dynamic analysis asistido con MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From Android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Frida scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Imprimirá todas las clases cargadas
- **Capture Strings**: Imprimirá todas las cadenas capturadas mientras se usa la aplicación (muy ruidoso)
- **Capture String Comparisons**: Puede ser muy útil. Mostrará las 2 cadenas que se comparan y si el resultado fue True o False.
- **Enumerate Class Methods**: Introduce el nombre de la clase (como "java.io.File") e imprimirá todos los métodos de la clase.
- **Search Class Pattern**: Buscar clases por patrón
- **Trace Class Methods**: Traza una clase completa (ver entradas y salidas de todos los métodos de la clase). Recuerda que por defecto MobSF traza varios métodos interesantes de Android API.

Once you have selected the auxiliary module you want to use you need to press "**Start Instrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

MobSF también incluye una shell con algunos comandos **adb**, comandos **MobSF**, y comandos comunes de **shell** en la parte inferior de la página de **dynamic analysis**. Algunos comandos interesantes:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Herramientas HTTP**

Cuando se captura tráfico HTTP puedes ver una vista poco legible del tráfico capturado en el botón "**HTTP(S) Traffic**" inferior o una vista más agradable en el botón verde "**Start HTTPTools**". Desde la segunda opción, puedes **enviar** las **captured requests** a **proxies** como Burp o Owasp ZAP.\
Para ello, _arranca Burp -->_ _desactiva Intercept --> en MobSB HTTPTools selecciona la request_ --> pulsa "**Send to Fuzzer**" --> _selecciona la dirección del proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una vez que termines el análisis dinámico con MobSF puedes pulsar "**Start Web API Fuzzer**" para **fuzz http requests** y buscar vulnerabilidades.

> [!TIP]
> Después de realizar un análisis dinámico con MobSF la configuración del proxy puede quedar mal configurada y no podrás corregirla desde la GUI. Puedes arreglar la configuración del proxy ejecutando:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Análisis dinámico asistido con Inspeckage

Puedes obtener la herramienta en [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta herramienta utiliza algunos **Hooks** para informarte **de lo que está ocurriendo en la aplicación** mientras realizas un **análisis dinámico**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta es una **excelente herramienta para realizar análisis estático con una GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta herramienta está diseñada para buscar varias **vulnerabilidades relacionadas con la seguridad en aplicaciones Android**, tanto en el **source code** como en **packaged APKs**. La herramienta también es **capaz de crear un "Proof-of-Concept" deployable APK** y **ADB commands**, para explotar algunas de las vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Al igual que con Drozer, no es necesario rootear el dispositivo de prueba.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Muestra todos los archivos extraídos para referencia rápida
- Decompila automáticamente archivos APK a formato Java y Smali
- Analiza AndroidManifest.xml en busca de vulnerabilidades y comportamientos comunes
- Análisis estático del código fuente en busca de vulnerabilidades y comportamientos comunes
- Información del dispositivo
- y más
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER es una aplicación de línea de comandos que puede usarse en Windows, MacOS X y Linux, y que analiza archivos _.apk_ en busca de vulnerabilidades. Lo hace descomprimiendo los APK y aplicando una serie de reglas para detectar esas vulnerabilidades.

Todas las reglas están centralizadas en un archivo `rules.json`, y cada empresa o tester puede crear sus propias reglas para analizar lo que necesiten.

Descarga los binarios más recientes desde la [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn es una herramienta **crossplatform** que ayuda a desarrolladores, bugbounty hunters y ethical hackers a realizar [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) en aplicaciones móviles.

El concepto es que arrastres y sueltes el archivo de tu aplicación móvil (un .apk o .ipa file) en la aplicación StaCoAn y esta generará un informe visual y portátil para ti. Puedes ajustar la configuración y las wordlists para obtener una experiencia personalizada.

Descargar[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework es un sistema de análisis de vulnerabilidades para Android que ayuda a desarrolladores o hackers a encontrar posibles vulnerabilidades de seguridad en aplicaciones Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** es una herramienta cuyo objetivo principal es detectar y advertir al usuario sobre posibles comportamientos maliciosos desarrollados por una aplicación Android.

La detección se realiza mediante el **static analysis** del Dalvik bytecode de la aplicación, representado como **Smali**, utilizando la biblioteca [`androguard`](https://github.com/androguard/androguard).

Esta herramienta busca **comportamientos comunes de aplicaciones "malas"** como: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** es un framework de Ingeniería inversa y Análisis de Aplicaciones Móviles. Es una herramienta que reúne herramientas comúnmente usadas para reverse engineering y análisis de aplicaciones móviles, para ayudar a probar aplicaciones móviles frente a las amenazas de seguridad móvil de OWASP. Su objetivo es facilitar esta tarea y hacerla más accesible para desarrolladores de aplicaciones móviles y profesionales de seguridad.

Es capaz de:

- Extraer código Java y Smali usando diferentes herramientas
- Analizar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraer información privada del APK usando expresiones regulares.
- Analizar el Manifest.
- Analizar los dominios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) y [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Desofuscar APK vía [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Tenga en cuenta que, dependiendo del servicio y la configuración que use para ofuscar el código, los secretos pueden o no terminar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** es una herramienta de línea de comandos de código abierto que reduce, optimiza y ofusca código Java. Es capaz de optimizar bytecode así como detectar y eliminar instrucciones no usadas. ProGuard es software libre y se distribuye bajo la GNU General Public License, versión 2.

ProGuard se distribuye como parte del Android SDK y se ejecuta cuando se construye la aplicación en modo release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Encuentra una guía paso a paso para desofuscar el apk en [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Desde esa guía) La última vez que comprobamos, el modo de operación de Dexguard era:

- cargar un recurso como InputStream;
- pasar el resultado a una clase que hereda de FilterInputStream para descifrarlo;
- hacer alguna obfuscación inútil para hacer perder unos minutos a un reverser;
- pasar el resultado descifrado a un ZipInputStream para obtener un archivo DEX;
- finalmente cargar el DEX resultante como un Resource usando el método `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard invierte el proceso de ofuscación realizado por las herramientas de ofuscación de Android. Esto posibilita numerosos análisis de seguridad, incluyendo la inspección de código y la predicción de librerías.**

Puedes subir un APK ofuscado a su plataforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Esta es una herramienta LLM para encontrar posibles vulnerabilidades de seguridad en apps android y desofuscar el código de apps android. Usa la public API de Google Gemini.

### [Simplify](https://github.com/CalebFenton/simplify)

Es un **deobfuscador genérico para android.** Simplify **ejecuta virtualmente una app** para entender su comportamiento y luego **intenta optimizar el código** para que se comporte de manera idéntica pero sea más fácil de entender para un humano. Cada tipo de optimización es simple y genérica, por lo que no importa qué tipo específico de ofuscación se haya usado.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD te da información sobre **cómo se hizo un APK**. Identifica muchos **compiladores**, **packers**, **obfuscators**, y otras cosas raras. Es el [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b es una máquina virtual de seguridad Android basada en ubuntu-mate que incluye una colección de los últimos frameworks, tutoriales y labs de diferentes geeks e investigadores de seguridad para reverse engineering y análisis de malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Es una gran lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Curso rápido de Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
