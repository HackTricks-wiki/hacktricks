# Android Toepassings Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Toepassings Basiese

Dit word sterk aanbeveel om eers hierdie bladsy te lees om te weet oor die **belangrikste dele wat verband hou met Android-sekuriteit en die gevaarlikste komponente in 'n Android-toepassing**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dit is die hoof instrument wat jy nodig het om met 'n Android-toestel (geëmuleer of fisies) te koppel.\
**ADB** maak dit moontlik om toestelle te beheer óf via **USB** óf via **Network** vanaf 'n rekenaar. Hierdie hulpmiddel stel in staat tot die **kopiëring** van lêers in beide rigtings, die **installering** en **verwydering** van apps, die **uitvoering** van shell-opdragte, die **rugsteun** van data, die **lees** van logs, en ander funksies.

Kyk na die volgende lys van [**ADB Commands**](adb-commands.md) om te leer hoe om adb te gebruik.

## Smali

Soms is dit interessant om die **aansoekkode te wysig** om by **verborge inligting** te kom (miskien goed geobfuskede wagwoorde of flags). Dan kan dit sin maak om die apk te dekompileer, die kode te verander en dit weer te kompileer.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Dit kan baie nuttig wees as 'n **alternatief vir verskeie toetse tydens die dynamiese analise** wat aangebied gaan word. Dan, **Hou hierdie moontlikheid altyd in gedagte.**

## Ander interessante truuks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Laai APKs af**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Haal APK uit toestel:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Samesmelt alle split- en base-apks met [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Gevallestudies & Kwesbaarhede


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statiese Ontleding

Eerstens, om 'n APK te analiseer moet jy **'n blik werp op die Java-code** gebruikmakend van 'n decompiler.\
Lees asseblief [**hier vir inligting oor verskillende beskikbare decompilers**](apk-decompilers.md).

### Soek na interessante inligting

Deur net die **strings** van die APK te bekyk kan jy soek na **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** en enigiets interessant... kyk selfs vir code execution **backdoors** of authentication backdoors (hardcoded admin credentials in die app).

**Firebase**

Gee besondere aandag aan **firebase URLs** en kontroleer of dit verkeerd gekonfigureer is. [Meer inligting oor wat Firebase is en hoe om dit te misbruik vind jy hier.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basiese begrip van die toepassing - Manifest.xml, strings.xml

Die **ondersoek van 'n toepassing se _Manifest.xml_ en _strings.xml_ lêers kan potensiële sekuriteitskwesbaarhede openbaar**. Hierdie lêers kan met 'n decompiler verkry word of deur die APK-lêeruitbreiding na .zip te hernoem en dit dan uit te pak.

**Kwesbaarhede** wat uit die **Manifest.xml** geïdentifiseer kan word sluit in:

- **Debuggable Applications**: Toepassings wat as debuggable gestel is (`debuggable="true"`) in die _Manifest.xml_ lêer vorm 'n risiko aangesien hulle verbindings toelaat wat tot uitbuiting kan lei. Vir meer begrip oor hoe om debuggable applications uit te buit, verwys na 'n tutorial oor die vind en uitbuiting van debuggable applications op 'n toestel.
- **Backup Settings**: Die attribuut `android:allowBackup="false"` moet duidelik gestel word vir toepassings wat met sensitiewe inligting werk om ongemagtigde datarugsteun via adb te voorkom, veral wanneer usb debugging geaktiveer is.
- **Network Security**: Aangepaste netwerksekuriteitskonfigurasies (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ kan sekuriteitsbesonderhede soos sertifikaat-pins en HTTP-verkeerinstellings spesifiseer. 'n Voorbeeld is om HTTP-verkeer vir spesifieke domeine toe te laat.
- **Exported Activities and Services**: Die identifisering van exported activities en services in die manifest kan komponente uitlig wat misbruik kan word. Verdere ontleding tydens dinamiese toetse kan openbaar hoe om hierdie komponente uit te buit.
- **Content Providers and FileProviders**: Blootgestelde content providers kan ongemagtigde toegang of wysiging van data toelaat. Die konfigurasie van FileProviders moet ook deeglik ondersoek word.
- **Broadcast Receivers and URL Schemes**: Hierdie komponente kan gebruik word vir uitbuiting, met spesiale aandag aan hoe URL schemes bestuur word vir invoervulnerability's.
- **SDK Versions**: Die `minSdkVersion`, `targetSDKVersion`, en `maxSdkVersion` atribuutwysers dui die ondersteunde Android-weergawes aan, wat die belangrikheid beklemtoon om verouderde, kwesbare Android-weergawes nie te ondersteun nie.

Uit die **strings.xml** lêer kan sensitiewe inligting soos API keys, custom schemas, en ander ontwikkelaarsnotas gevind word, wat die noodsaaklikheid van deeglike hersiening van hierdie hulpbronne beklemtoon.

### Tapjacking

**Tapjacking** is 'n aanval waar 'n **kwaadwillige toepassing** gelanseer word en homself bo-op 'n slagoffer-toepassing posisioneer. Wanneer dit die slagoffer-app visueel bedek, is die gebruikersinterface so ontwerp om die gebruiker te mislei om daarmee te interaksie, terwyl dit die interaksie aan die slagoffer-app deurgee.\
In werklikheid is dit 'n manier om die gebruiker te verblind sodat hulle nie weet dat hulle eintlik aksies op die slagoffer-app uitvoer nie.

Vind meer inligting in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

'n **Activity** met die **`launchMode`** gestel op **`singleTask` sonder enige `taskAffinity`** gespesifiseer is kwesbaar vir Task Hijacking. Dit beteken dat 'n **toepassing** geïnstalleer kan word en as dit geskakel word voor die werklike toepassing, dit die taak van die werklike toepassing kan **inseël** (sodat die gebruiker met die **kwaadwillige toepassing sal kommunikeer terwyl hy dink hy gebruik die werklike een**).

Meer inligting in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Onveilige datastoor

**Internal Storage**

In Android word lêers wat in **internal** storage gestoor word ontwerp om uitsluitlik deur die app wat dit geskep het toeganklik te wees. Hierdie sekuriteitsmaatreël word deur die Android-bedryfstelsel afgedwing en is gewoonlik voldoende vir die sekuriteitsbehoeftes van meeste toepassings. Ontwikkelaars gebruik soms egter modi soos `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` om lêers **tussen verskillende toepassings te deel**. Hierdie modi **beperk egter nie toegang** tot hierdie lêers deur ander toepassings nie, insluitend moontlik kwaadwillige toepassings.

1. **Statiese Analise:**
- **Maak seker** dat die gebruik van `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` deeglik ondersoek word. Hierdie modi **kan lêers blootstel** aan onbedoelde of ongemagtigde toegang.
2. **Dinamiese Analise:**
- **Kontroleer** die **permitte** wat op lêers geskep deur die app gestel is. Spesifiek, **kyk of enige lêers wêreldwyd lees- of skryfbaar gestel is**. Dit kan 'n beduidende sekuriteitsrisiko inhou, aangesien dit enige toepassing op die toestel, ongeag oorsprong of bedoeling, toelaat om hierdie lêers te **lees of te wysig**.

**External Storage**

Wanneer jy met lêers op **external storage**, soos SD Cards, werk, moet sekere voorsorgmaatreëls getref word:

1. **Toeganklikheid**:
- Lêers op external storage is **global leesbaar en skryfbaar**. Dit beteken enige toepassing of gebruiker kan hierdie lêers benader.
2. **Sekuriteitskwessies**:
- Gegee die maklike toegang, is dit nie aanbeveel om sensitiewe inligting op external storage te stoor nie.
- External storage kan verwyder of deur enige toepassing bereik word, wat dit minder veilig maak.
3. **Hantering van data vanaf External Storage**:
- Voer altyd **invoer-validasie** uit op data wat van external storage verkry word. Dit is noodsaaklik omdat die data van 'n onbetroubare bron kom.
- Dit word sterk ontried om uitvoerbare of klas-lêers op external storage te stoor vir dinamiese inlaai.
- As jou toepassing executables van external storage moet laai, maak seker dat hierdie lêers **gesigned en kriptografies geverifieer** is voordat hulle dinamies gelaai word. Hierdie stap is belangrik vir die behoud van jou toepassings sekuriteitsintegriteit.

External storage kan toeganklik wees by `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Beginnend met Android 4.4 (**API 17**), het die SD-kaart 'n gidsstruktuur wat **toegang vanaf 'n app beperk tot die gids wat spesifiek vir daardie app is**. Dit voorkom dat kwaadwillige toepassings lees- of skryf toegang tot 'n ander app se lêers kry.

**Sensitiewe data in plainteks gestoor**

- **Shared preferences**: Android laat elke toepassing toe om maklik xml-lêers te stoor in die pad `/data/data/<packagename>/shared_prefs/` en soms is dit moontlik om sensitiewe inligting in plainteks in daardie vouer te vind.
- **Databases**: Android laat elke toepassing toe om maklik sqlite databases te stoor in die pad `/data/data/<packagename>/databases/` en soms is dit moontlik om sensitiewe inligting in plainteks in daardie vouer te vind.

### Gebroke TLS

**Accept All Certificates**

Om 'n of ander rede aanvaar ontwikkelaars soms alle sertifikate selfs al stem die hostname byvoorbeeld nie ooreen nie met reëls van kode soos die volgende een:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
'n Goeie manier om dit te toets is om te probeer om die verkeer vas te vang met 'n proxy soos Burp sonder om die Burp CA binne die toestel te magtig. Ook, jy kan met Burp 'n sertifikaat genereer vir 'n ander hostname en dit gebruik.

### Gebroke Kriptografie

**Slegte sleutelbestuursprosesse**

Sommige ontwikkelaars stoor sensitiewe data in die plaaslike berging en enkripteer dit met 'n sleutel wat hardcoded/voorspelbaar in die kode is. Dit behoort nie gedoen te word nie aangesien sommige reversing 'n aanvaller kan toelaat om die vertroulike inligting te onttrek.

**Gebruik van onseker en/of verouderde algoritmes**

Ontwikkelaars behoort nie **verouderde algoritmes** te gebruik om outorisasie **kontroles** uit te voer, data te **stoor** of te **stuur** nie. Sommige van hierdie algoritmes is: RC4, MD4, MD5, SHA1... As **hashes** byvoorbeeld gebruik word om wagwoorde te stoor, moet **brute-force-weerstandige** hashes saam met 'n salt gebruik word.

### Ander kontroles

- Dit word aanbeveel om die **APK te obfuskeer** om die reverse engineer se werk vir aanvallers moeiliker te maak.
- As die app sensitief is (soos bank apps), behoort dit sy **eie kontroles uit te voer om te sien of die mobiele toestel geroot is** en dienooreenkomstig op te tree.
- As die app sensitief is (soos bank apps), behoort dit te kontroleer of 'n **emulator** gebruik word.
- As die app sensitief is (soos bank apps), behoort dit **sy eie integriteit te kontroleer voor uitvoering** om na te gaan of dit gewysig is.
- Gebruik [**APKiD**](https://github.com/rednaga/APKiD) om te kontroleer watter compiler/packer/obfuscator gebruik is om die APK te bou

### React Native Application

Lees die volgende bladsy om te leer hoe om maklik toegang tot die JavaScript-kode van React-toepassings te kry:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Lees die volgende bladsy om te leer hoe om maklik toegang tot C#-kode van 'n xamarin-toepassing te kry:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Volgens hierdie [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) is superpacked 'n Meta-algoritme wat die inhoud van 'n toepassing in 'n enkele lêer saamdruk. Die blog bespreek die moontlikheid om 'n app te skep wat hierdie tipe apps dekomprimeer... en 'n vinniger manier wat behels om die **toepassing uit te voer en die gedekomprimeerde lêers van die lêerstelsel te versamel.**

### Automated Static Code Analysis

Die hulpmiddel [**mariana-trench**](https://github.com/facebook/mariana-trench) is in staat om **kwesbaarhede** te vind deur die **kode** van die toepassing te **scan**. Hierdie hulpmiddel bevat 'n reeks **known sources** (wat die tool aandui watter **plekke** die **input** deur die gebruiker beheer word), **sinks** (wat die tool aandui **gevaarlike** **plekke** waar kwaadwillige gebruikerinput skade kan veroorsaak) en **rules**. Hierdie reëls dui die **kombinasie** van **sources-sinks** aan wat 'n kwesbaarheid aandui.

Met hierdie kennis **sal mariana-trench die kode hersien en moontlike kwesbaarhede daarin vind**.

### Secrets leaked

'n Toepassing kan secrets (API keys, passwords, hidden urls, subdomains...) daarin hê wat jy moontlik kan ontdek. Jy kan 'n hulpmiddel soos [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) gebruik.

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Ander interessante funksies

- **Kode-uitvoering**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Stuur SMS'e**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** gedeclareer as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamiese Analise

> Eerstens, jy het 'n omgewing nodig waar jy die toepassing en al die omgewing (Burp CA cert, Drozer en Frida hoofsaaklik) kan installeer. Daarom word 'n rooted toestel (geëmuleer of nie) uiters aanbeveel.

### Aanlyn dinamiese analise

Jy kan 'n **gratis rekening** skep by: [https://appetize.io/](https://appetize.io). Hierdie platform laat jou toe om APKs te **upload** en **uit te voer**, wat nuttig is om te sien hoe 'n apk optree.

Jy kan selfs **die logs van jou toepassing** in die web sien en via **adb** koppel.

![](<../../images/image (831).png>)

Dankie aan die ADB-verbinding kan jy **Drozer** en **Frida** binne die emulators gebruik.

### Lokale dinamiese analise

#### Gebruik van 'n emulator

- [**Android Studio**](https://developer.android.com/studio) (Jy kan **x86** en **arm** toestelle skep, en volgens [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**laatste x86** weergawes **support ARM libraries** sonder om 'n stadige arm emulator te benodig).
- Leer om dit op te stel op hierdie bladsy:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Gratis weergawe:** Personal Edition, jy moet 'n rekening skep. _Dit word aanbeveel om die weergawe **MET**_ _**VirtualBox** af te laai om potensiële foute te vermy._)
- [**Nox**](https://es.bignox.com) (Gratis, maar dit ondersteun nie Frida of Drozer nie).

> [!TIP]
> Wanneer jy 'n nuwe emulator op enige platform skep, onthou dat hoe groter die skerm is, hoe stadiger sal die emulator loop. Kies dus, indien moontlik, klein skerms.

Om **google services** (soos AppStore) in Genymotion te **installeer** moet jy op die rooi gemerkte knoppie in die volgende beeld klik:

![](<../../images/image (277).png>)

Let ook daarop dat jy in die **konfigurasie van die Android VM in Genymotion** die **Bridge Network mode** kan kies (dit sal nuttig wees as jy van 'n ander VM met die toolle wil koppel).

#### Gebruik 'n fisiese toestel

Jy moet die **debugging** opsies aktiveer en dit sal goed wees as jy dit kan **root**:

1. **Settings**.
2. (FromAndroid 8.0) Kies **System**.
3. Kies **About phone**.
4. Druk **Build number** 7 keer.
5. Gaan terug en jy sal die **Developer options** vind.

> Sodra jy die toepassing geïnstalleer het, is die eerste ding wat jy moet doen om dit te probeer en ondersoek wat dit doen, hoe dit werk en gemaklik te raak daarmee.\
> Ek stel voor om **hierdie aanvanklike dinamiese analise met MobSF dynamic analysis + pidcat** uit te voer, sodat ons kan **leer hoe die toepassing werk** terwyl MobSF 'n hele paar **interessante** **data** vasvang wat jy later kan nagaan.

Magisk/Zygisk vinnige notas (aanbeveel op Pixel-toestelle)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Onbedoelde Data-lekkasie

**Logregistrasie**

Ontwikkelaars moet versigtig wees om **debugging-inligting** publiek bloot te stel, aangesien dit tot sensitiewe data leak kan lei. Die gereedskap [**pidcat**](https://github.com/JakeWharton/pidcat) en `adb logcat` word aanbeveel om aansoeklogs te monitor om sensitiewe inligting te identifiseer en te beskerm. **Pidcat** word verkies vir sy gebruiksgemak en leesbaarheid.

> [!WARNING]
> Let daarop dat vanaf **later newer than Android 4.0**, **applications are only able to access their own logs**. Dus kan toepassings nie ander apps se logs toegang nie.\
> Dit word tog steeds aanbeveel om **nie sensitiewe inligting te log nie**.

**Copy/Paste Buffer Caching**

Android se **clipboard-gebaseerde** raamwerk verskaf copy-paste funksionaliteit in apps, maar dit bied 'n risiko aangesien **ander toepassings** die clipboard kan **toeganklik maak**, wat potensieel sensitiewe data kan blootstel. Dit is belangrik om copy/paste funksies vir sensitiewe gedeeltes van 'n toepassing, soos kredietkaartbesonderhede, te deaktiveer om data leak te voorkom.

**Crash Logs**

As 'n toepassing **crash** en logs stoor, kan hierdie logs aanvallers help, veral wanneer die toepassing nie gerugsteek kan word nie. Om hierdie risiko te versag, moenie log by crashes nie, en as logs oor die netwerk gestuur moet word, maak seker dat dit via 'n SSL-kanaal gestuur word vir veiligheid.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Toepassings integreer dikwels dienste soos Google Adsense, wat per ongeluk sensitiewe data kan leak weens onbehoorlike implementering deur ontwikkelaars. Om potensiële data leaks te identifiseer, is dit raadsaam om die toepassing se verkeer te onderskep en te kontroleer of enige sensitiewe inligting aan derdepartye gestuur word.

### SQLite DBs

Die meeste toepassings sal **interne SQLite-databasisse** gebruik om inligting te stoor. Tydens die pentest neem 'n **kyk** na die **databasisse** wat geskep is, die name van **tabelle** en **kolomme** en al die **data** wat gestoor is omdat jy sensitiewe inligting kan vind (wat 'n kwesbaarheid sou wees).\
Databasisse behoort geleë te wees in `/data/data/the.package.name/databases` soos `/data/data/com.mwr.example.sieve/databases`

As die databasis vertroulike inligting stoor en **geënkripteer is** maar jy die **wagwoord** binne die toepassing kan **vind**, is dit steeds 'n **kwesbaarheid**.

Eunumerateer die tabelle met `.tables` en enumereer die kolomme van die tabelle deur `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Van [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** laat jou toe om die **rol van 'n Android app aan te neem** en met ander apps te interaksie. Dit kan **enige iets doen wat 'n geïnstalleerde aansoek kan doen**, soos gebruik maak van Android se Inter-Process Communication (IPC) meganisme en met die onderliggende bedryfstelsel interakteer. .\
Drozer is 'n nuttige hulpmiddel om **exported activities, exported services and Content Providers** te exploit soos jy in die volgende afdelings sal leer.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Onthou ook dat die kode van 'n activity in die **`onCreate`** metode begin.

**Outorisasie-omseiling**

Wanneer 'n Activity geëksporteer is, kan jy sy skerm van 'n eksterne app oproep. Dus, as 'n activity met **sensitiewe inligting** **geëksporteer** is, kan jy die **verifikasie** meganismes **omseil** om toegang daartoe te kry.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Jy kan ook 'n geëksporteerde activity vanaf adb begin:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF sal die gebruik van _**singleTask/singleInstance**_ as `android:launchMode` in 'n activity as kwaadwillig bespeur, maar weens [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), blyk dit slegs gevaarlik te wees op ou weergawes (API weergawes < 21).

> [!TIP]
> Let wel dat 'n authorisation bypass nie altyd 'n kwesbaarheid is nie; dit hang af van hoe die bypass werk en watter inligting blootgestel word.

**Lekkasie van sensitiewe inligting**

**Aktiwiteite kan ook resultate teruggee**. As jy 'n geëksporteerde en onbeskermde aktiwiteit vind wat die **`setResult`**-metode aanroep en **sensitiewe inligting teruggee**, is daar 'n lekkasie van sensitiewe inligting.

#### Tapjacking

Indien tapjacking nie voorkom word nie, kan jy die geëksporteerde aktiwiteit misbruik om die **gebruiker onvoorsiene aksies te laat uitvoer**. Vir meer inligting oor [**what is Tapjacking follow the link**](#tapjacking).

### Uitbuiting van Content Providers - Toegang tot en manipulasie van sensitiewe inligting

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers word hoofsaaklik gebruik om **data te deel**. As 'n app beskikbare content providers het, kan jy dalk **sensitiewe data** daaruit onttrek. Dit is ook belangrik om moontlike **SQL injections** en **Path Traversals** te toets aangesien hulle kwesbaar kan wees.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Onthou dat die aksies van 'n Service begin in die metode `onStartCommand`.

'n Service is basies iets wat **data kan ontvang**, dit kan **verwerk** en (al dan nie) 'n reaksie **teruggee**. As 'n toepassing dus sommige services eksporteer, moet jy die **kode** nagaan om te verstaan wat dit doen en dit **dinamies** toets om vertroulike inligting te onttrek en authentication-maatreëls te bypass...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Onthou dat die aksies van 'n Broadcast Receiver begin in die metode `onReceive`.

'n Broadcast Receiver sal wag vir 'n tipe boodskap. Afhangende daarvan hoe die receiver die boodskap hanteer, kan dit kwesbaar wees.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Jy kan handmatig na deep links kyk deur gereedskap soos MobSF of skripte soos [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Jy kan 'n verklaarde **scheme** oopmaak met **adb** of 'n **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Let wel dat jy die **package name** kan weglaat en die mobiele toestel sal outomaties die app oproep wat daardie skakel moet oopmaak._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

In order to find the **code that will be executed in the App**, go to the activity called by the deeplink and search the function **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Gevoelige inligting**

Elke keer as jy 'n deep link vind, kontroleer dat i**t nie sensitiewe data (soos wagwoorde) via URL-parameters ontvang nie**, want enige ander aansoek kan die **deep link naboots en daardie data steel!**

**Parameters in path**

Jy **moet ook nagaan of 'n deep link 'n parameter binne die pad gebruik** van die URL soos: `https://api.example.com/v1/users/{username}` , in daardie geval kan jy 'n path traversal afdwing deur iets soos te benader: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Let daarop dat as jy die korrekte endpoints binne die toepassing vind, jy 'n **Open Redirect** kan veroorsaak (as deel van die pad as domeinnaam gebruik word), **account takeover** (as jy gebruikersdetail kan wysig sonder 'n CSRF-token en die kwesbare endpoint die korrekte metode gebruik) en enige ander kwetsbaarheid. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

'n [interesting bug bounty report](https://hackerone.com/reports/855618) oor links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Sertifikate word nie altyd behoorlik deur Android-toepassings geïnspekteer nie.** Dit is algemeen dat hierdie toepassings waarskuwings ignoreer en self-signed certificates aanvaar of soms terugval op HTTP-verbindinge.
- **Onderhandelinge tydens die SSL/TLS-handshake is soms swak**, en gebruik onveilige cipher suites. Hierdie kwesbaarheid maak die verbinding vatbaar vir man-in-the-middle (MITM) aanvalle, wat aanvalle in staat stel om die data te ontsleutel.
- **Leakage of private information** is 'n risiko wanneer toepassings met veilige kanale autentiseer maar daarna oor nie-veilige kanale vir ander transaksies kommunikeer. Hierdie benadering beskerm nie sensitiewe data, soos session cookies of gebruikersdetails, teen onderskeping deur kwaadwilliges nie.

#### Certificate Verification

Ons fokus op **certificate verification**. Die integriteit van die bediener se sertifikaat moet geverifieer word om sekuriteit te verbeter. Dit is noodsaaklik omdat onveilige TLS-konfigurasies en die oordrag van sensitiewe data oor onversleutelde kanale beduidende risiko's kan skep. Vir gedetailleerde stappe oor die verifiëring van bedienersertifikate en die aanspreek van kwesbaarhede, verskaf [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) omvattende leiding.

#### SSL Pinning

SSL Pinning is 'n sekuriteitsmaatreël waar die toepassing die bediener se sertifikaat verifieer teen 'n bekende kopie wat binne die toepassing self gestoor is. Hierdie metode is noodsaaklik om MITM-aanvalle te voorkom. Implementering van SSL Pinning word sterk aanbeveel vir toepassings wat sensitiewe inligting hanteer.

#### Traffic Inspection

Om HTTP-verkeer te inspekteer, is dit nodig om **die proxy-tool se sertifikaat te installeer** (bv. Burp). Sonder om hierdie sertifikaat te installeer, mag versleutelde verkeer nie deur die proxy sigbaar wees nie. Vir 'n gids oor die installering van 'n pasgemaakte CA-sertifikaat, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Toepassings wat **API Level 24 and above** mik, vereis wysigings aan die Network Security Config om die proxy se CA-sertifikaat te aanvaar. Hierdie stap is kritiek vir die inspeksie van versleutelde verkeer. Vir instruksies oor die wysiging van die Network Security Config, verwys na [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

As **Flutter** gebruik word, moet jy die instruksies op [**this page**](flutter.md) volg. Dit is omdat bloot om die sertifikaat by die store te voeg nie sal werk nie aangesien Flutter sy eie lys van geldige CAs het.

#### Static detection of SSL/TLS pinning

Voordat jy runtime-bypasses probeer, maak vinnig 'n kaart van waar pinning in die APK afgedwing word. Statische ontdekking help jou om hooks/patches te beplan en fokus op die regte kodepaaie.

Tool: SSLPinDetect
- Open-source static-analysis utility wat die APK na Smali dekompileer (via apktool) en scan vir gekurarde regex-patrone van SSL/TLS pinning-implementasies.
- Rapporteer presiese lêerpad, reëlnommer, en 'n kode-snippet vir elke trefffer.
- Dek algemene raamwerke en aangepaste kodepaaie: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, en Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Gebruik
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Voorbeeld patroonreëls (JSON)
Gebruik of brei signatures uit om proprietêre/aangepaste pinning-styles op te spoor. Jy kan jou eie JSON laai en op groot skaal skandeer.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Vinnige skandering op groot apps deur multi-threading en memory-mapped I/O; vooraf-gecompileerde regex verminder overhead/vals positiewe.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Tipiese deteksiedoelwitte om volgende te triage:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Gebruik die ooreenstemmende lokasies om Frida hooks, static patches, of config reviews te beplan voordat dynamic testing.



#### Omseiling van SSL Pinning

Wanneer SSL Pinning geïmplementeer is, word dit nodig om dit te omseil om HTTPS-verkeer te inspekteer. Verskeie metodes is beskikbaar vir hierdie doel:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Die grootste voordeel van hierdie opsie is dat jy nie root sal benodig om die SSL Pinning te omseil nie, maar jy sal die toepassing moet verwyder en die nuwe een moet herinstalleer, en dit sal nie altyd werk nie.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Jy kan ook probeer om **automatically bypass SSL Pinning** met behulp van [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Jy kan ook probeer om **automatically bypass SSL Pinning** met behulp van **MobSF dynamic analysis** (explained below)
- As jy steeds dink daar is verkeer wat jy nie vasvang nie, kan jy probeer om die verkeer na burp te **forward** met behulp van iptables. Lees hierdie blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Soek na algemene web kwesbaarhede

Dit is belangrik om ook na algemene web kwesbaarhede binne die toepassing te soek. Gedetailleerde inligting oor die identifisering en versagting van hierdie kwesbaarhede val buite die omvang van hierdie samevatting, maar word elders uitgebreid behandel.

### Frida

[Frida](https://www.frida.re) is 'n dinamiese instrumentasie toolkit vir ontwikkelaars, reverse-engineers, en sekuriteitsnavorsers.\
**You can access running application and hook methods on run time to change the behaviour, change values, extract values, run different code...**\
As jy Android-toepassings wil pentest, moet jy weet hoe om Frida te gebruik.

- Leer hoe om Frida te gebruik: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is goed om die gebruik van Frida te outomatiseer: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Jy kan 'n paar Awesome Frida scripts hier vind: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Probeer om anti-debugging / anti-frida meganismes te omseil deur Frida te laai soos aangedui in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentasie & SSL pinning omseil werkvloei

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Geheue dump - Fridump**

Kontroleer of die toepassing sensitiewe inligting in die geheue stoor wat dit nie behoort te stoor nie, soos wagwoorde of mnemonics.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Dit sal die geheue in die ./dump-gids aflaai, en daar kan jy met iets soos grep deursoek:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitiewe data in Keystore**

In Android is die Keystore die beste plek om sensitiewe data te stoor, maar met genoeg voorregte is dit steeds **moontlik om daartoe toegang te kry**. Aangesien toepassings hier geneig is om **sensitiewe data in platte teks** te stoor, behoort pentests dit te ondersoek, aangesien 'n root user of iemand met fisiese toegang tot die toestel hierdie data kan steel.

Selfs as 'n app data in die keystore gestoor het, behoort die data versleuteld te wees.

Om toegang tot die data binne die keystore te kry, kan jy hierdie Frida script gebruik: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Met die volgende Frida script kan dit moontlik wees om die **bypass fingerprint authentication** wat Android-toepassings gebruik om sekere sensitiewe gebiede te beskerm, uit te voer:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Agtergrondbeelde**

Wanneer jy 'n toepassing op die agtergrond plaas, stoor Android 'n **snapshot van die toepassing**, sodat wanneer dit na die voorgrond herstel word, dit die beeld begin laai voor die app, sodat dit lyk asof die app vinniger gelaai is.

As hierdie snapshot egter **sensitiewe inligting** bevat, kan iemand met toegang tot die snapshot daardie inligting **steel** (let daarop dat jy root benodig om daartoe toegang te kry).

Die snapshots word gewoonlik gestoor by: **`/data/system_ce/0/snapshots`**

Android bied 'n manier om die **screenshot capture te voorkom deur die FLAG_SECURE layout-parameter te stel**. Deur hierdie vlag te gebruik, word die vensterinhoud as veilig beskou, wat verhoed dat dit in screenshots verskyn of op nie-beveiligde skerms besigtig word.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Hierdie instrument kan jou help om verskillende gereedskap tydens dinamiese analise te bestuur: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Ontwikkelaars skep dikwels proxy-komponente soos activities, services en broadcast receivers wat hierdie Intents hanteer en dit aan metodes soos `startActivity(...)` of `sendBroadcast(...)` deurgee, wat riskant kan wees.

Die gevaar lê daarin om aanvallers toe te laat om non-exported app-komponente te aktiveer of toegang tot sensitiewe content providers te kry deur hierdie Intents verkeerd te rig. ’n Noemenswaardige voorbeeld is die `WebView`-komponent wat URL's na `Intent`-objekte omskakel via `Intent.parseUri(...)` en dit dan uitvoer, wat moontlik kan lei tot kwaadwillige Intent-inspuitings.

### Essensiële punte

- **Intent Injection** is soortgelyk aan die web se Open Redirect-kwessie.
- Exploits behels die deurgee van `Intent`-objekte as extras, wat omgerig kan word om onveilige operasies uit te voer.
- Dit kan non-exported komponente en content providers voor aanvallers openbaar maak.
- `WebView` se URL-na-`Intent` omskakeling kan onverwagte aksies vergemaklik.

### Android Client Side Injections and others

Jy ken waarskynlik hierdie soort kwesbaarhede vanaf die web. Jy moet besondere sorg toepas met hierdie kwesbaarhede in ’n Android-toepassing:

- **SQL Injection:** Wanneer jy met dinamiese navrae of Content-Providers werk, maak seker dat jy geparameteriseerde navrae gebruik.
- **JavaScript Injection (XSS):** Verify that JavaScript and Plugin support is disabled for any WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews should have access to the file system disabled (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In verskeie gevalle, wanneer die Android-toepassing die sessie beëindig, word die cookie nie ingetrek nie of dit kan selfs na skyf gestoor word
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statiese ontleding**

![](<../../images/image (866).png>)

**Kwetsbaarheidsevaluering van die toepassing** wat ’n netjiese webgebaseerde frontend gebruik. Jy kan ook dinamiese analise doen (maar jy moet die omgewing voorberei).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Geassisteerde dinamiese analise met MobSF

**MobSF** kan ook baie nuttig wees vir **dinamiese analise** op **Android**, maar in daardie geval moet jy MobSF en **genymotion** op jou gasheer installeer (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
Die **MobSF dynamic analyser** kan:

- **Dump application data** (URLs, logs, clipboard, skermskote gemaak deur jou, skermskote gemaak deur "**Exported Activity Tester**", e-posse, SQLite databases, XML-lêers, en ander geskepte lêers). Dit gebeur alles outomaties behalwe vir die skermskote — jy moet die knoppie druk wanneer jy 'n skermskoot wil hê of jy moet "**Exported Activity Tester**" druk om skermskote van alle geëksporteerde aktiwiteite te verkry.
- Vang **HTTPS** verkeer
- Gebruik **Frida** om **runtime** **information** te verkry

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF kan ook **invoke exported activities**, neem **screenshots** daarvan en **save** dit vir die verslag.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Frida scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Dit sal al die gelaaide klasse uitdruk
- **Capture Strings**: Dit sal al die capture strings uitdruk terwyl die toepassing gebruik word (baie lawaaierig)
- **Capture String Comparisons**: Kan baie nuttig wees. Dit sal **show the 2 strings being compared** en of die resultaat True of False was.
- **Enumerate Class Methods**: Sit die klasnaam (soos "java.io.File") in en dit sal al die metodes van die klas druk.
- **Search Class Pattern**: Soek klasse per patroon
- **Trace Class Methods**: **Trace** 'n **whole class** (sien insette en uitsette van alle metodes van die klas). Onthou dat MobSF standaard verskeie interessante Android Api-metodes trace.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

MobSF bied ook 'n shell aan met sommige **adb** commands, **MobSF commands**, en algemene **shell** **commands** onderaan die dinamiese analise bladsy. Sommige interessante opdragte:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP gereedskap**

Wanneer http-verkeer vasgelê word, kan jy 'n lelike weergawe van die vasgelêde verkeer sien op "**HTTP(S) Traffic**" knop of 'n netter weergawe via die groen knop "**Start HTTPTools**". Vanaf die tweede opsie kan jy die **captured requests** na **proxies** soos Burp of Owasp ZAP stuur.  
Om dit te doen, _skakel Burp aan -->_ _skakel Intercept af --> in MobSB HTTPTools kies die request_ --> druk "**Send to Fuzzer**" --> _kies die proxy adres_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sodra jy die dynamic analysis met MobSF voltooi het, kan jy op "**Start Web API Fuzzer**" klik om **fuzz http requests** en na vulnerabilities te soek.

> [!TIP]
> Na die uitvoering van 'n dynamic analysis met MobSF kan die proxy-instellings verkeerd gekonfigureer raak en sal jy dit nie vanuit die GUI kan regstel nie. Jy kan die proxy-instellings regstel deur:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Jy kan die tool kry by [**Inspeckage**](https://github.com/ac-pm/Inspeckage).  
Hierdie tool gebruik sommige **Hooks** om jou te wys **wat in die toepassing gebeur** terwyl jy 'n **dynamic analysis** uitvoer.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dit is 'n **geweldige hulpmiddel om static analysis met 'n GUI uit te voer**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Hierdie tool is ontwerp om verskeie **security related Android application vulnerabilities** op te spoor, hetsy in **source code** of **packaged APKs**. Die tool is ook **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, om sommige van die gevonde vulnerabilities te exploit (Exposed activities, intents, tapjacking...). Soos met Drozer, is daar geen behoefte om die toets-toestel te root nie.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wys alle uitgehaalde lêers vir maklike verwysing
- Decompileer APK-lêers outomaties na Java- en Smali-formaat
- Ontleed AndroidManifest.xml vir algemene kwesbaarhede en gedrag
- Statiese bronkode-analise vir algemene kwesbaarhede en gedrag
- Toestelinligting
- en meer
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER is 'n command-line-toepassing wat op Windows, MacOS X en Linux gebruik kan word, en wat _.apk_-lêers ontleed op soek na kwesbaarhede. Dit doen dit deur APKs te dekomprimeer en 'n reeks reëls toe te pas om daardie kwesbaarhede op te spoor.

Alle reëls is in 'n `rules.json`-lêer gesentreer, en elke maatskappy of toetser kan hul eie reëls skep om te ontleed wat hulle benodig.

Laai die nuutste binaries af vanaf die [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn is 'n **crossplatform** hulpmiddel wat ontwikkelaars, bugbounty hunters en ethical hackers help om [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) op mobiele toepassings uit te voer.

Die konsep is dat jy jou mobiele toepassingslêer (n .apk of .ipa-lêer) op die StaCoAn-toepassing sleep en los, en dit sal vir jou 'n visuele en draagbare verslag genereer. Jy kan die instellings en wordlists aanpas om 'n aangepaste ervaring te kry.

Laai af[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework is 'n Android kwesbaarheids-analise stelsel wat ontwikkelaars of hackers help om potensiële sekuriteitskwesbaarhede in Android-toepassings op te spoor.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** is 'n hulpmiddel wat hoofsaaklik daarop gemik is om potensieel kwaadwillige gedrag wat deur 'n Android-toepassing ontwikkel is, op te spoor en die gebruiker daaroor te waarsku.

Die deteksie word uitgevoer deur middel van die **static analysis** van die toepassing se Dalvik bytecode, voorgestel as **Smali**, met die [`androguard`](https://github.com/androguard/androguard) biblioteek.

Hierdie hulpmiddel soek na **algemene gedrag van "slegte" toepassings** soos: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Dit is 'n instrument wat algemeen gebruikte mobile application reverse engineering- en analysis-gereedskap saamvoeg om te help met die toetsing van mobiele toepassings teen die OWASP mobile security threats. Die doel is om hierdie taak makliker en vriendeliker te maak vir mobiele toepassings-ontwikkelaars en sekuriteitsprofessionals.

Dit kan:

- Haal Java- en Smali-kode uit met verskillende gereedskap
- Ontleed APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Haal privaat inligting uit die APK met behulp van regexps.
- Ontleed die Manifest.
- Ontleed gevonde domeine using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Useful to detect malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Let wel: afhangend van die diens en konfigurasie wat jy gebruik om die kode te obfuskeer, mag geheime wel of nie obfuskeer wees nie.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is 'n open source command-line tool wat Java-kode verklein, optimaliseer en obfuskeer. Dit kan bytecode optimaliseer sowel as ongebruikte instruksies opspoor en verwyder. ProGuard is vrye sagteware en word versprei onder die GNU General Public License, version 2.

ProGuard word as deel van die Android SDK versprei en loop wanneer die toepassing in release mode gebou word.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Die laaste keer toe ons gekyk het, was die Dexguard mode of operation:

- laai 'n resource as 'n InputStream;
- voer die resultaat na 'n klas wat van FilterInputStream erf om dit te ontsleutel;
- doen 'n paar nuttelose obfuskasies om 'n paar minute van 'n reverser se tyd te mors;
- voer die ontsleutelde resultaat na 'n ZipInputStream om 'n DEX file te kry;
- laastens laai die resulterende DEX as 'n Resource using die `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Jy kan 'n obfuskeerede APK na hul platform oplaai.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gee jou inligting oor **how an APK was made**. Dit identifiseer baie **compilers**, **packers**, **obfuscators**, en ander vreemde goed. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is 'n Android security virtual machine gebaseer op ubuntu-mate en sluit 'n versameling van die nuutste framework, tutorials en labs van verskillende sekuriteits geeks en researchers vir reverse engineering en malware analysis in.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Dit is 'n goeie lys van hulpbronne
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
