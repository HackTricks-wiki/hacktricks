# Programu za Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Misingi ya Programu za Android

Inashauriwa sana kuanza kusoma ukurasa huu ili kujua kuhusu **vipengele muhimu zaidi vinavyohusiana na usalama wa Android na vipengele hatari zaidi katika programu ya Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Hii ni zana kuu unayohitaji kuunganishwa na kifaa cha Android (imeigwa au halisi).\
**ADB** inaruhusu kudhibiti vifaa kwa njia ya **USB** au kupitia **Network** kutoka kwa kompyuta. Kifaa hiki kinawezesha **kunakili** faili kwa pande zote, **kufunga** na **kuondoa** apps, **kuendesha** amri za shell, **kufanya backup** ya data, **kusoma** logs, miongoni mwa kazi nyingine.

Tazama orodha ifuatayo ya [**ADB Commands**](adb-commands.md) ili ujifunze jinsi ya kutumia adb.

## Smali

Wakati mwingine ni muhimu **kubadilisha msimbo wa programu** ili kufikia **taarifa zilizofichwa** (labda nywila zilizofichwa vizuri au flags). Kisha, inaweza kuwa ya manufaa ku-decompile APK, kubadilisha msimbo na ku-recompile tena.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Hii inaweza kuwa muhimu kama **mbadala kwa vipimo kadhaa wakati wa dynamic analysis** zitakazowasilishwa. Kwa hiyo, **kumbuka daima uwezekano huu**.

## Mbinu nyingine za kuvutia

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Chomoa APK kutoka kwenye kifaa:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Unganisha splits zote na base apks kwa kutumia [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Masomo ya Kesi & Udhaifu


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Uchambuzi wa Statiki

Kwanza kabisa, kwa kuchambua APK unapaswa **kutazama Java code** kwa kutumia decompiler.\
Tafadhali, [**soma hapa kupata taarifa kuhusu decompilers tofauti zilizopo**](apk-decompilers.md).

### Kutafuta Taarifa Zinazovutia

Kwa kuangalia tu **strings** za APK unaweza kutafuta **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** na chochote kinachovutia... hata tazama kwa ajili ya code execution **backdoors** au authentication backdoors (hardcoded admin credentials kwa app).

**Firebase**

Lipa makini kwa **firebase URLs** na angalia kama imewekwa vibaya. [Taarifa zaidi kuhusu ni nini Firebase na jinsi ya exploit hapa.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Uelewa wa msingi wa application - Manifest.xml, strings.xml

Uchunguzi wa faili za programu _Manifest.xml_ na **_strings.xml_** unaweza kufumbua udhaifu wa usalama. Faili hizi zinaweza kupatikana kwa kutumia decompilers au kwa kubadilisha extension ya faili APK kuwa .zip kisha kuizipua.

**Udahifu** unaotambulika kutoka **Manifest.xml** ni pamoja na:

- **Debuggable Applications**: Applications zilizowekwa kama debuggable (`debuggable="true"`) katika faili _Manifest.xml_ zina hatari kwa kuwa zinaruhusu connections ambazo zinaweza kusababisha exploit. Kwa ufahamu zaidi juu ya jinsi ya exploit debuggable applications, rejea tutorial juu ya kupata na ku-exploit debuggable applications kwenye kifaa.
- **Backup Settings**: `android:allowBackup="false"` inapaswa kuwekwa wazi kwa applications zinazosimamia taarifa nyeti ili kuzuia backups zisizoidhinishwa za data kupitia adb, hasa wakati usb debugging imewezeshwa.
- **Network Security**: Mipangilio maalumu ya network security (`android:networkSecurityConfig="@xml/network_security_config"`) katika _res/xml/_ inaweza kubainisha maelezo ya usalama kama certificate pins na mipangilio ya HTTP traffic. Mfano ni kuruhusu HTTP traffic kwa domains maalum.
- **Exported Activities and Services**: Kutambua exported activities na services katika manifest kunaweza kuonyesha components zinazoweza kutumiwa vibaya. Uchambuzi zaidi wakati wa testing ya dynamic unaweza kufichua jinsi ya exploit components hizi.
- **Content Providers and FileProviders**: Content providers zilizofunuliwa zinaweza kuruhusu access au modification ya data bila idhini. Usanidi wa FileProviders pia unapaswa kuchunguzwa.
- **Broadcast Receivers and URL Schemes**: Components hizi zinaweza kutumika kwa exploitation, hasa kuzingatia jinsi URL schemes zinavyosimamiwa kwa ajili ya input vulnerabilities.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, na `maxSdkVersion` zinaonyesha toleo za Android zinazotumika, zikionyesha umuhimu wa kuto-support outdated, vulnerable Android versions kwa sababu za usalama.

Kutoka kwenye faili **strings.xml**, taarifa nyeti kama API keys, custom schemas, na maelezo mengine ya developer yanaweza kupatikana, ikisisitiza umuhimu wa kupitia kwa uangalifu rasilimali hizi.

### Tapjacking

**Tapjacking** ni shambulio ambapo **malicious application** inaanzishwa na kujipanga juu ya application ya mwathiriwa. Mara inapoficha kimaso app ya mwathiriwa, interface yake ya mtumiaji imeundwa kwa njia ya kudanganya mtumiaji kuingiliana nayo, huku ikiendelea kupitisha interaction kwa app ya mwathiriwa.\
Kwa ufanisi, inamtia doa mtumiaji kujua kuwa kwa kweli anafanya vitendo kwenye app ya mwathiriwa.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity yenye `launchMode` imewekwa `singleTask` bila `taskAffinity` yoyote imeelezwa kuwa inakabiliwa na task Hijacking. Hii inamaanisha, that application inaweza kusanikishwa na ikiwa itaanzishwa kabla ya application halisi inaweza hijack task ya application halisi (kwa hivyo mtumiaji ataingiliana na **malicious application** akidhani anatumia ile halisi).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Uhifadhi wa data usio salama

**Internal Storage**

Kwenye Android, files zilizohifadhiwa kwenye internal storage zimedesignwa kupatikana pekee na app iliyozitengeneza. Kipimo hiki cha usalama kinafanywa na mfumo wa uendeshaji wa Android na kwa ujumla kinatosha kwa mahitaji ya usalama ya applications nyingi. Hata hivyo, developers wakati mwingine hutumia modes kama `MODE_WORLD_READABLE` na `MODE_WORLD_WRITABLE` kuruhusu files kushirikiwa kati ya applications tofauti. Modes hizi hazizuizi access kwa files hizo na applications nyingine, ikiwa ni pamoja na zile zinazoweza kuwa malicious.

1. **Static Analysis:**
- **Hakikisha** kuwa matumizi ya `MODE_WORLD_READABLE` na `MODE_WORLD_WRITABLE` yanachunguzwa kwa makini. Modes hizi **zinaweza kufunua** files kwa access isiyokusudiwa au isiyoidhinishwa.
2. **Dynamic Analysis:**
- **Thibitisha** permissions zilizo kwenye files zilizotengenezwa na app. Haswa, **angalia** kama kuna files zilizowekwa kuwa readable au writable kwa wote. Hii inaweza kuwa hatari kubwa ya usalama, kwani itaruhusu **application yoyote** iliyosanikishwa kwenye kifaa, bila kujali asili au nia yake, kusoma au kubadilisha files hizi.

**External Storage**

Unaposhughulika na files kwenye external storage, kama SD Cards, tahadhari fulani zinapaswa kuchukuliwa:

1. **Accessibility**:
- Files kwenye external storage ni **globally readable and writable**. Hii inamaanisha application yoyote au mtumiaji anaweza kufikia files hizi.
2. **Security Concerns**:
- Kwa kuzingatia urahisi wa upatikanaji, inashauriwa **kutoweka taarifa nyeti** kwenye external storage.
- External storage inaweza kuondolewa au kufikiwa na application yoyote, ikifanya isiwe na usalama wa kutosha.
3. **Handling Data from External Storage**:
- Daima **fanya input validation** kwa data inayopatikana kutoka external storage. Hii ni muhimu kwa sababu data inatoka kwa chanzo kisichotegemewa.
- Kuingiza executables au class files kwenye external storage kwa ajili ya dynamic loading haipendekeziwi.
- Ikiwa application yako lazima ichukue executable files kutoka external storage, hakikisha files hizi zinasainiwa na kuthibitishwa kwa cryptography kabla ya kuzindua kwa dynamically. Hatua hii ni muhimu kwa kudumisha uadilifu wa usalama wa application yako.

External storage inaweza kupatikana katika `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Kuanzia Android 4.4 (**API 17**), SD card ina muundo wa directory ambao unazuia access kutoka app hadi directory ambayo ni maalum kwa app hiyo. Hii inazuia malicious application kupata read au write access kwa files za app nyingine.

**Taarifa nyeti zilizohifadhiwa kwa clear-text**

- **Shared preferences**: Android inaruhusu kila application kuweka kwa urahisi xml files katika njia `/data/data/<packagename>/shared_prefs/` na wakati mwingine inawezekana kupata taarifa nyeti kwa clear-text katika folda hiyo.
- **Databases**: Android inaruhusu kila application kuhifadhi sqlite databases katika njia `/data/data/<packagename>/databases/` na wakati mwingine inawezekana kupata taarifa nyeti kwa clear-text katika folda hiyo.

### Broken TLS

**Accept All Certificates**

Kwa sababu fulani wakati mwingine developers hukubali certificates zote hata kama kwa mfano hostname haifai na mistari ya code kama ifuatayo:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Mchakato duni wa Usimamizi wa Funguo**

Baadhi ya developers huhifadhi data nyeti kwenye local storage na kuizificha kwa key iliyowekwa/kutabirika ndani ya code. Hii haipaswi kufanywa kwani reverse engineering inaweza kumruhusu attacker kutoa taarifa za siri.

**Matumizi ya Algorithms Yasiyo Salama na/au Zilizokataliwa**

Developers hawapaswi kutumia **deprecated algorithms** kufanya ukaguzi wa **authorisation checks**, **kuhifadhi** au **kutuma** data. Baadhi ya algorithms ni: RC4, MD4, MD5, SHA1... Ikiwa **hashes** zimetumika kuhifadhi nywila kwa mfano, inapaswa kutumika hashes ambazo zinastahimili brute-force kwa kutumia salt.

### Other checks

- It's recommended to **obfuscate the APK** to difficult the reverse engineer labour to attackers.
- If the app is sensitive (like bank apps), it should perform it's **own checks to see if the mobile is rooted** and act in consequence.
- If the app is sensitive (like bank apps), it should check if an **emulator** is being used.
- If the app is sensitive (like bank apps), it should **check it's own integrity before executing** it to check if it was modified.
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

Unahitaji kuwezesha chaguo za **debugging** na itakuwa vizuri kama utaweza kuziroot:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Wdevelopers wanapaswa kuwa waangalifu kuhusu kufichua **debugging information** hadharani, kwa kuwa inaweza kusababisha data nyeti ku-leak. Vifaa kama [**pidcat**](https://github.com/JakeWharton/pidcat) na `adb logcat` zinapendekezwa kufuatilia logs za application ili kubaini na kulinda taarifa nyeti. **Pidcat** inapendekezwa kwa urahisi wake na usomaji.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Mfumo wa Android unaotegemea **clipboard** unaruhusu utendaji wa copy-paste ndani ya apps, lakini unaweka hatari kwani **apps zingine** zinaweza **access** clipboard, na hivyo kuweza ku-expose data nyeti. Ni muhimu **kuzima** vitendo vya copy/paste kwa sehemu nyeti za app, kama maelezo ya kadi za mkopo, ili kuzuia data ku-leak.

**Crash Logs**

Kama application inakufa (crash) na **kuhifadhi logs**, logs hizi zinaweza kumsaidia attacker, hasa pale ambapo application haiwezi kureverse-engineered. Ili kupunguza hatari hii, epuka logging kwenye crash, na kama logs lazima zitumwe kwenye network, hakikisha zitatumwa kwa channel ya SSL kwa usalama.

Kama pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications mara nyingi huingiza services kama Google Adsense, ambazo kwa utekelezaji mbaya zinaweza kwa bahati mbaya **leak sensitive data**. Ili kubaini potential data leaks, inashauriwa **kuintercept traffic ya application** na kuangalia kama taarifa nyeti zinatumwa kwa third-party services.

### SQLite DBs

Most of the applications will use **internal SQLite databases** to save information. During the pentest take a **look** to the **databases** created, the names of **tables** and **columns** and all the **data** saved because you could find **sensitive information** (which would be a vulnerability).\
Databases should be located in `/data/data/the.package.name/databases` like `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Androidâ€™s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF itakutambua kama hatari matumizi ya _**singleTask/singleInstance**_ kama `android:launchMode` katika activity, lakini kutokana na [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), inaonekana hii ni hatari tu kwenye toleo la zamani (API versions < 21).

> [!TIP]
> Kumbuka kwamba authorisation bypass siyo kila wakati ni vulnerability; itategemea jinsi bypass inavyofanya kazi na ni taarifa gani zinazoonekana.

**Sensitive information leakage**

**Activities can also return results**. Ikiwa utafanikiwa kupata exported na unprotected activity inayoitisha method ya **`setResult`** na **kurudisha sensitive information**, kuna sensitive information leakage.

#### Tapjacking

If tapjacking isn't prevented, unaweza kudharau exported activity kufanya **user perform unexpected actions**. Kwa habari zaidi kuhusu [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Kufikia na kusimamia sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers kwa kawaida hutumika kushiriki data. Ikiwa app ina content providers zinapatikana unaweza kuwa na uwezo wa **extract sensitive** data kutoka kwao. Pia ni muhimu kujaribu uwezekano wa **SQL injections** na **Path Traversals** kwani zinaweza kuwa vulnerable.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Kumbuka kwamba vitendo vya Service huanza katika method `onStartCommand`.

Service kwa msingi ni kitu kinachoweza kupokea data, kuichakata na kurudisha (au la) response. Kwa hiyo, ikiwa application ina exporting services unapaswa kuangalia code ili kuelewa inafanya nini na kuipima kwa dynamically ili kutoa taarifa za siri, kupita vikwazo vya uthibitishaji...
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Kumbuka kwamba vitendo vya Broadcast Receiver huanza katika method `onReceive`.

Broadcast receiver itakuwa inasubiri aina ya ujumbe. Kulingana na jinsi receiver inavyoshughulikia ujumbe inaweza kuwa vulnerable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Unaweza kutafuta deep links manually, kwa kutumia tools kama MobSF au scripts kama [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Unaweza **open** declared **scheme** kwa kutumia **adb** au **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Tambua kwamba unaweza **kuacha jina la kifurushi** na simu ya rununu itaita moja kwa moja app inayofaa kufungua kiungo hicho._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Msimbo unaotekelezwa**

Ili kupata **msimbo utakaotekelezwa katika App**, nenda kwenye activity inayoitwa na the deeplink na tafuta function **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Taarifa nyeti**

Kila unapokutana na deep link hakikisha kwamba **haipokei data nyeti (kama passwords) kupitia vigezo vya URL**, kwa sababu programu nyingine yoyote inaweza **kuiga deep link na kuiba data hiyo!**

**Vigezo katika path**

Unapaswa pia **kuhakiki kama deep link yoyote inatumia parameter ndani ya path** ya URL kama: `https://api.example.com/v1/users/{username}` , katika hali hiyo unaweza kulazimisha path traversal kwa kufikia kitu kama: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Kumbuka kwamba ukipata endpoints sahihi ndani ya application unaweza kusababisha **Open Redirect** (ikiwa sehemu ya path inatumika kama domain name), **account takeover** (ikiwa unaweza kubadilisha maelezo ya watumiaji bila CSRF token na endpoint iliyo na udhaifu ilitumia method sahihi) na udhaifu mwingine wowote. Habari zaidi [hapa](http://dphoeniixx.com/2020/12/13-2/).

**Mifano zaidi**

Ripoti ya bug bounty yenye kuvutia: [https://hackerone.com/reports/855618](https://hackerone.com/reports/855618) kuhusu links (_/.well-known/assetlinks.json_).

### Ukaguzi wa Transport Layer na Kushindwa kwa Uthibitishaji

- **Vyeti mara nyingi havikaguliwi ipasavyo** na applications za Android. Ni kawaida kwa applications hizi kupuuza onyo na kukubali self-signed certificates au, katika baadhi ya matukio, kurudi kutumia HTTP connections.
- **Mazungumzo wakati wa SSL/TLS handshake mara nyingine huwa dhaifu**, kwa kutumia insecure cipher suites. Udhaifu huu unafanya muunganisho uwe hatarini kwa man-in-the-middle (MITM) attacks, ukiruhusu wadukuzi kufungua encryption ya data.
- **Leakage of private information** ni hatari wakati applications zinathibitisha kwa kutumia channels salama lakini kisha zinasiliana kwa channels zisizo salama kwa ajili ya miamala mingine. Njia hii inashindwa kulinda data nyeti, kama session cookies au maelezo ya watumiaji, dhidi ya kukamatwa na wahalifu.

#### Uhakiki wa vyeti

Tutatilia maanani **certificate verification**. Uadilifu wa certificate ya server lazima uthibitishwe ili kuongeza usalama. Hii ni muhimu kwa sababu TLS configurations zisizo salama na uhamishaji wa data nyeti kupitia channels zisizo encrypted vinaweza kuleta hatari kubwa. Kwa hatua za kina juu ya jinsi ya kuthibitisha server certificates na kushughulikia udhaifu, rasilimali hii [**inatoa mwanga**](https://manifestsecurity.com/android-application-security-part-10/).

#### SSL Pinning

SSL Pinning ni tahadhari ya usalama ambapo application inathibitisha certificate ya server dhidi ya nakala inayojulikana iliyohifadhiwa ndani ya application yenyewe. Mbinu hii ni muhimu kuzuia MITM attacks. Kutekeleza SSL Pinning kunashauriwa kwa nguvu kwa applications zinazosimamia taarifa nyeti.

#### Ukaguzi wa Traffic

Ili kuchambua HTTP traffic, ni lazima **usakinishe certificate ya chombo cha proxy** (mfano, Burp). Bila kusakinisha certificate hii, traffic iliyosimbwa inaweza isionewe kupitia proxy. Kwa mwongozo wa jinsi ya kusakinisha custom CA certificate, [**bofya hapa**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Applications zinazolenga **API Level 24 and above** zinahitaji mabadiliko kwenye Network Security Config ili kukubali CA certificate ya proxy. Hatua hii ni muhimu kwa kuchambua traffic iliyosimbwa. Kwa maelekezo ya jinsi ya kubadilisha Network Security Config, [**rejea mwongozo huu**](make-apk-accept-ca-certificate.md).

Ikiwa **Flutter** inatumika unahitaji kufuata maelekezo kwenye [**ukurasa huu**](flutter.md). Hii ni kwa sababu, kuongeza certificate kwenye store peke yake haitafanya kazi kwani Flutter ina orodha yake ya CAs zinazokubalika.

#### Utambuzi wa static wa SSL/TLS pinning

Kabla ya kujaribu runtime bypasses, panga haraka maeneo ambapo pinning inatekelezwa katika APK. Utambuzi wa static utakusaidia kupanga hooks/patches na kuzingatia code paths sahihi.

Tool: SSLPinDetect
- Open-source static-analysis utility inayofanya decompile ya APK hadi Smali (kupitia apktool) na kutafuta curated regex patterns za utekelezaji wa SSL/TLS pinning.
- Inaripoti path ya faili kwa usahihi, nambari ya mstari, na kipande cha code kwa kila match.
- Inafunika frameworks za kawaida na code paths za custom: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, na Network Security Config XML pins.

Sakinisha
- Masharti ya awali: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Matumizi
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Mifano ya sheria za muundo (JSON)

Tumia au panua signatures ili kugundua proprietary/custom pinning styles. Unaweza kupakia JSON yako mwenyewe na kutafuta kwa wingi.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Skanning ya haraka kwenye apps kubwa kupitia multi-threading na memory-mapped I/O; regex zilizo pre-compiled hupunguza mzigo/matokeo ya uwongo.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Malengo ya kawaida ya utambuzi kwa kuchambua ifuatayo:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Tumia maeneo yaliyolingana kupanga Frida hooks, static patches, au mapitio ya config kabla ya majaribio ya dynamic.



#### Bypassing SSL Pinning

When SSL Pinning is implemented, bypassing it becomes necessary to inspect HTTPS traffic. Various methods are available for this purpose:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Ni muhimu pia kutafuta vulnerabilities za kawaida za web ndani ya application. Maelezo ya kina juu ya utambuzi na kupunguza vulnerabilities hizi hayamo katika muhtasari huu lakini yameelezwa kwa kina mahali pengine.

### Frida

[Frida](https://www.frida.re) is a dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.\
**Unaweza kufikia application inayokimbia na ku-hook methods wakati wa runtime ili kubadilisha tabia, kubadilisha values, kutoa values, kuendesha code tofauti...**\
Kama unataka pentest Android applications ni muhimu ujue jinsi ya kutumia Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Kagua kama application inahifadhi taarifa nyeti ndani ya memory ambazo haipaswi kuhifadhi, kama passwords au mnemonics.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Hii ita-dump kumbukumbu katika folda ./dump, na hapo unaweza kutumia grep kwa kitu kama:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Taarifa nyeti katika Keystore**

Katika Android Keystore ni mahali pazuri zaidi pa kuhifadhi taarifa nyeti, hata hivyo, kwa idhini za kutosha bado ni **possible to access it**. Kwa kuwa applications mara nyingi huzihifadhi hapa **sensitive data in clear text**, pentests zinapaswa kuichunguza kwani kama root user au mtu mwenye ufikiaji wa kimwili kwa kifaa anaweza kuiba data hii.

Hata kama app imehifadhi data kwenye keystore, data inapaswa kuwa encrypted.

Ili kufikia data ndani ya keystore unaweza kutumia Frida script hii: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Kutumia Frida script ifuatayo kunaweza kuwa inawezekana **bypass fingerprint authentication** ambayo Android applications zinaweza kufanya ili **kulinda maeneo fulani nyeti:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Picha za Mandharinyuma**

Unapoiweka programu katika mandharinyuma, Android huhifadhi **snapshot ya programu** ili inaporudishwa mbele inaanza kupakia picha hiyo kabla ya app, hivyo inaonekana kama app ilipakia haraka zaidi.

Hata hivyo, ikiwa snapshot hii ina **taarifa nyeti**, mtu mwenye ufikiaji wa snapshot anaweza **kuiba taarifa hiyo** (kumbuka unahitaji root ili kuifikia).

Snapshots kawaida huhifadhiwa hapa: **`/data/system_ce/0/snapshots`**

Android inatoa njia ya **kuzuia kunakiliwa kwa screenshot kwa kuweka parameter ya layout FLAG_SECURE**. Kwa kutumia flag hii, yaliyomo kwenye dirisha yanachukuliwa kuwa salama, na kuzuia yaonekana katika screenshots au kuonekana kwenye displays zisizo salama.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Chombo hiki kinaweza kukusaidia kusimamia zana mbalimbali wakati wa dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developers mara nyingi hufanya proxy components kama activities, services, na broadcast receivers zinazoshughulikia Intents hizi na kuzipitisha kwa methods kama `startActivity(...)` au `sendBroadcast(...)`, jambo ambalo linaweza kuwa hatari.

Hatari iko kwenye kuruhusu attackers kuanzisha non-exported app components au kupata access kwa sensitive content providers kwa kupindisha Intents hizi. Mfano muhimu ni component ya `WebView` kubadilisha URLs kuwa Intent objects kupitia `Intent.parseUri(...)` na kisha kuzitekeleza, jambo ambalo linaweza kusababisha malicious Intent injections.

### Essential Takeaways

- **Intent Injection** ni sawa na tatizo la Open Redirect kwenye web.
- Exploits zinahusisha kupitisha `Intent` objects kama extras, ambazo zinaweza kualikwa upya ili kutekeleza operations zisizo salama.
- Inaweza kufichua non-exported components na content providers kwa attackers.
- Ubadilishaji wa URL kwa Intent kwenye `WebView` unaweza kuwezesha actions zisizokusudiwa.

### Android Client Side Injections and others

Labda unafahamu aina hizi za vulnerabilities kutoka Web. Lazima uwe waangalifu hasa na vulnerabilities hizi katika Android application:

- **SQL Injection:** Unaposhughulika na dynamic queries au Content-Providers hakikisha unatumia parameterized queries.
- **JavaScript Injection (XSS):** Thibitisha kwamba JavaScript na Plugin support zimezimwa kwa WebViews yoyote (zimeteuliwa kuwa disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews zinapaswa kuwa na access kwa file system zimezima (zimeteuliwa kuwa enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Katika visa kadhaa wakati android application inapomaliza session cookie haifutwi au inaweza hata kuokolewa kwenye disk
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** kwa kutumia frontend nzuri ya web. Unaweza pia kufanya dynamic analysis (lakini unahitaji kuandaa environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Note that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Pia, ikiwa utaunda faili la **ZIP** lenye source code ya app ya **Android** au **IOS** (nenda kwenye root folder ya application, chagua kila kitu na unda ZIPfile), itauweza kuchambua pia.

MobSF pia inakuwezesha kufanya **diff/Compare** ya analysis na kuunganisha **VirusTotal** (utahitaji kuweka API key yako katika _MobSF/settings.py_ na kuifanya iwe enabled: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Unaweza pia kuweka `VT_UPLOAD` kuwa `False`, basi the **hash** itapakiwa badala ya faili.

### Assisted Dynamic analysis with MobSF

**MobSF** inaweza pia kuwa msaada mkubwa kwa **dynamic analysis** kwenye **Android**, lakini katika kesi hiyo utahitaji kusanisha MobSF na **genymotion** kwenye host yako (VM au Docker haitafanya kazi). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** inaweza:

- **Dump application data** (URLs, logs, clipboard, screenshots ulizofanya mwenyewe, screenshots zilizofanywa na "**Exported Activity Tester**", emails, SQLite databases, XML files, na faili nyingine zilizoundwa). Haya yote hufanywa moja kwa moja isipokuwa screenshots, lazima ubofye wakati unataka screenshot au lazima ubofye "**Exported Activity Tester**" ili kupata screenshots za exported activities zote.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Kutoka kwenye Android **versions > 5**, itaanzisha **Frida** kiotomatiki na itaweka global **proxy** settings ili **capture** traffic. Itakamata traffic tu kutoka kwa application inayojaribiwa.

**Frida**

Kwa default, itatumia baadhi ya Frida Scripts ili **bypass SSL pinning**, **root detection** na **debugger detection** na pia **monitor interesting APIs**.\
MobSF pia inaweza **invoke exported activities**, kuchukua **screenshots** zao na **kuzi hifadhi** kwa ajili ya report.

Ili **kuanza** dynamic testing bonyeza button ya kijani: "**Start Instrumentation**". Bonyeza "**Frida Live Logs**" kuona logs zinazozalishwa na Frida scripts na "**Live API Monitor**" kuona invoke zote za hooked methods, arguments zilizotumika na returned values (hii itaonekana baada ya kubofya "Start Instrumentation").\
MobSF pia inakuwezesha kupakia Frida scripts zako mwenyewe (kutuma matokeo ya Frida scripts zako kwa MobSF tumia function `send()`). Pia ina **several pre-written scripts** ambazo unaweza kupakia (unaweza kuongeza zaidi katika `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), chagua tu, bonyeza "**Load**" na kisha "**Start Instrumentation**" (utaweza kuona logs za script hizo ndani ya "**Frida Live Logs**").

![](<../../images/image (419).png>)

Zaidi ya hayo, una baadhi ya Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Itachapisha classes zote zilizopakiwa
- **Capture Strings**: Itachapisha strings zote zinazopigwa capture wakati wa kutumia application (inatoa noise nyingi)
- **Capture String Comparisons**: Inaweza kuwa muhimu sana. Itaonyesha **strings mbili zinazolinganishwa** na kama result ilikuwa True au False.
- **Enumerate Class Methods**: Weka jina la class (kama "java.io.File") na itachapisha methods zote za class hiyo.
- **Search Class Pattern**: Tafuta classes kwa pattern
- **Trace Class Methods**: **Trace** class nzima (ona inputs na outputs za methods zote za class). Kumbuka kwamba kwa default MobSF inafuatilia baadhi ya Android Api methods zinazovutia.

Mara baada ya kuchagua module ya auxiliary unayotaka kutumia lazima ubofye "**Start Intrumentation**" na utaona outputs zote ndani ya "**Frida Live Logs**".

**Shell**

MobSF pia inakuleta shell yenye baadhi ya amri za **adb**, amri za **MobSF**, na amri za kawaida za **shell** chini ya ukurasa wa dynamic analysis. Baadhi ya amri zinazovutia:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Vifaa vya HTTP**

Wakati trafiki ya HTTP inapokamatwa unaweza kuona muonekano mbaya wa trafiki iliyokamatwa kwenye kitufe cha chini "**HTTP(S) Traffic**" au muonekano mzuri kwenye kitufe cha kijani "**Start HTTPTools**". Kutoka chaguo la pili, unaweza **kutuma** **maombi yaliyokamatwa** kwa **proxies** kama Burp au Owasp ZAP.\
Ili kufanya hivyo, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Baada ya kumaliza dynamic analysis na MobSF unaweza kubofya "**Start Web API Fuzzer**" ili **fuzz http requests** na kutafuta udhaifu.

> [!TIP]
> Baada ya kufanya dynamic analysis na MobSF mipangilio ya proxy inaweza kuwa imechafuka na hautaweza kuirekebisha kupitia GUI. Unaweza kurekebisha mipangilio ya proxy kwa kufanya:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Uchambuzi wa Dynamic Ulio kusaidiwa na Inspeckage

Unaweza kupata zana kutoka [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Zana hii itatumia baadhi ya **Hooks** kukujulisha **kinachoendelea katika application** huku ukifanya **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Hii ni **zana nzuri za kufanya static analysis kwa GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Zana hii imeundwa kutafuta udhaifu mbalimbali zinazohusiana na **security** za Android application, iwe katika **source code** au **packaged APKs**. Zana pia ina uwezo wa kuunda "Proof-of-Concept" deployable APK na **ADB commands**, ili ku-exploit baadhi ya udhaifu uliopatikana (Exposed activities, intents, tapjacking...). Kama ilivyo kwa Drozer, hakuna haja ya ku-root kifaa cha mtihani.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Inaonyesha faili zote zilizotolewa kwa rejea rahisi
- Hufanya decompile kwa faili za APK kwa njia ya otomatiki hadi muundo wa Java na Smali
- Huchambua AndroidManifest.xml kwa ajili ya udhaifu na tabia za kawaida
- Uchambuzi wa msimbo wa chanzo wa static kwa ajili ya udhaifu na tabia za kawaida
- Taarifa za kifaa
- na mengi zaidi
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER ni programu ya mstari wa amri inayoweza kutumika kwenye Windows, MacOS X na Linux, ambayo inachambua faili za _.apk_ kutafuta vulnerabilities. Inafanya hivyo kwa kuzipakua APKs na kutumia mfululizo wa kanuni kugundua vulnerabilities hizo.

Kanuni zote ziko katika faili la `rules.json`, na kila kampuni au mjaribu anaweza kuunda kanuni zao ili kuchambua wanazohitaji.

Pakua binaries za hivi karibuni kutoka kwenye [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn ni zana ya **crossplatform** inayowasaidia developers, bugbounty hunters na ethical hackers kufanya [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) kwenye mobile applications.

Mfumo ni kwamba una-vuta na kuacha faili ya programu yako ya simu (faili ya .apk au .ipa) kwenye programu ya StaCoAn na itaunda ripoti ya kuona na rahisi kubeba kwako. Unaweza kubadilisha mipangilio na wordlists ili kupata uzoefu uliobinafsishwa.

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework ni mfumo wa uchambuzi wa udhaifu wa Android unaosaidia waendelezaji au hackers kugundua udhaifu za usalama zinazoweza kuwepo katika programu za Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** ni zana ambalo lengo lake kuu ni kugundua na kuwaonya mtumiaji kuhusu tabia hatari zinazoweza kutengenezwa na programu ya Android.

Ugundaji hufanywa kwa kupitia **static analysis** ya bytecode ya programu ya Dalvik, inayowakilishwa kama **Smali**, kwa kutumia maktaba ya [`androguard`](https://github.com/androguard/androguard).

Zana hii inaangalia **tabia za kawaida za programu "mbaya"** kama: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Ni zana inayoweka pamoja zana zinazotumika mara kwa mara za mobile application reverse engineering na analysis, kusaidia katika kujaribu mobile applications dhidi ya OWASP mobile security threats. Lengo lake ni kufanya kazi hii iwe rahisi na rafiki kwa mobile application developers na security professionals.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Inayofaa kutambua malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Kumbuka kwamba, kulingana na service na configuration unayotumia kuobfuscate the code, secrets zinaweza au zisiwe obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Unaweza upload an obfuscated APK kwenye platform yao.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Hii ni zana ya LLM kutafuta potential security vulnerabilities katika android apps na deobfuscate android app code. Inatumia Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b ni Android security virtual machine inayotegemea ubuntu-mate inayojumuisha mkusanyiko wa latest framework, tutorials na labs kutoka kwa security geeks na researchers kwa ajili ya reverse engineering na malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Ni orodha nzuri ya rasilimali
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
