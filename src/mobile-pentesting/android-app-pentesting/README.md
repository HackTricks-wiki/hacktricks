# Aplicaciones Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Conceptos básicos de aplicaciones Android

Se recomienda encarecidamente comenzar leyendo esta página para conocer las **partes más importantes relacionadas con la seguridad de Android y los componentes más peligrosos en una aplicación Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta es la herramienta principal que necesitas para conectarte a un dispositivo Android (emulado o físico).\
**ADB** permite controlar dispositivos ya sea por **USB** o por **red** desde un ordenador. Esta utilidad habilita la **copia** de archivos en ambas direcciones, la **instalación** y **desinstalación** de aplicaciones, la **ejecución** de comandos de shell, la **copia de seguridad** de datos, la **lectura** de registros, entre otras funciones.

Consulta la siguiente lista de [**Comandos ADB**](adb-commands.md) para aprender a usar adb.

## Smali

A veces es interesante **modificar el código de la aplicación** para acceder a **información oculta** (por ejemplo contraseñas bien ofuscadas o flags). Entonces, puede ser útil descompilar el apk, modificar el código y recompilarlo.\
[**En este tutorial** puedes **aprender cómo descompilar un APK, modificar código Smali y recompilar el APK** con la nueva funcionalidad](smali-changes.md). Esto puede ser muy útil como **alternativa para varias pruebas durante el análisis dinámico** que se van a presentar. Entonces, **mantén siempre en mente esta posibilidad**.

## Otros trucos interesantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusiona todos los splits y los apks base con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Estudios de caso & Vulnerabilidades


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Análisis estático

Primero, para analizar un APK deberías **echar un vistazo al código Java** usando un decompiler.\
Por favor, [**lee aquí para encontrar información sobre los diferentes decompilers disponibles**](apk-decompilers.md).

### Buscando información interesante

Con solo mirar las **strings** del APK puedes buscar **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** y cualquier cosa interesante... busca incluso **backdoors** de ejecución de código o backdoors de autenticación (hardcoded admin credentials en la app).

**Firebase**

Presta especial atención a las **Firebase URLs** y verifica si está mal configurado. [Más información sobre qué es Firebase y cómo explotarlo aquí.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensión básica de la aplicación - Manifest.xml, strings.xml

El **examen de los archivos _Manifest.xml_ y **_strings.xml_** de una aplicación puede revelar potenciales vulnerabilidades de seguridad**. Estos archivos pueden ser accedidos usando decompilers o renombrando la extensión del APK a .zip y descomprimiéndolo.

**Vulnerabilidades** identificadas en el **Manifest.xml** incluyen:

- **Aplicaciones con debug habilitado**: Las aplicaciones marcadas como debuggable (`debuggable="true"`) en el _Manifest.xml_ suponen un riesgo ya que permiten conexiones que pueden llevar a explotación. Para entender mejor cómo explotar aplicaciones debuggable, consulta un tutorial sobre cómo encontrar y explotar aplicaciones debuggable en un dispositivo.
- **Backup Settings**: El atributo `android:allowBackup="false"` debería establecerse explícitamente para aplicaciones que manejan información sensible para prevenir backups no autorizados vía adb, especialmente cuando usb debugging está habilitado.
- **Network Security**: Configuraciones personalizadas de network security (`android:networkSecurityConfig="@xml/network_security_config"`) en _res/xml/_ pueden especificar detalles de seguridad como certificate pins y ajustes de tráfico HTTP. Un ejemplo es permitir tráfico HTTP para dominios específicos.
- **Exported Activities and Services**: Identificar activities y services exportados en el manifest puede resaltar componentes que podrían ser mal utilizados. Un análisis adicional durante pruebas dinámicas puede revelar cómo explotar estos componentes.
- **Content Providers and FileProviders**: Content providers expuestos podrían permitir acceso no autorizado o modificación de datos. La configuración de FileProviders también debe ser examinada.
- **Broadcast Receivers and URL Schemes**: Estos componentes podrían aprovecharse para la explotación, prestando especial atención a cómo se gestionan los URL schemes para vulnerabilidades de input.
- **SDK Versions**: Los atributos `minSdkVersion`, `targetSDKVersion`, y `maxSdkVersion` indican las versiones de Android soportadas, subrayando la importancia de no soportar versiones antiguas y vulnerables de Android por razones de seguridad.

En el archivo **strings.xml**, se pueden descubrir información sensible como API keys, custom schemas y otras notas del desarrollador, lo que subraya la necesidad de revisar cuidadosamente estos recursos.

### Tapjacking

**Tapjacking** es un ataque donde una **malicious application** se lanza y **se posiciona encima de una victim application**. Una vez que oscurece visiblemente la app víctima, su interfaz está diseñada para engañar al usuario para que interactúe con ella, mientras pasa la interacción a la victim app.\
En efecto, está **cegando al usuario para que no sepa que en realidad está realizando acciones en la app víctima**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Una **activity** con el **`launchMode`** establecido en **`singleTask` sin ningún `taskAffinity`** definido es vulnerable a Task Hijacking. Esto significa que una **application** puede ser instalada y, si se lanza antes que la aplicación real, podría **hijackear la task de la aplicación real** (por lo que el usuario estará interactuando con la **malicious application pensando que está usando la real**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Almacenamiento de datos inseguro

**Almacenamiento interno**

En Android, los archivos **almacenados** en el almacenamiento **interno** están **diseñados** para ser **accesibles** exclusivamente por la **app** que los **creó**. Esta medida de seguridad es **impuesta** por el sistema operativo Android y generalmente es adecuada para las necesidades de seguridad de la mayoría de aplicaciones. Sin embargo, los desarrolladores a veces utilizan modos como `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` para **permitir** que archivos sean **compartidos** entre diferentes aplicaciones. Aun así, estos modos **no restringen el acceso** a esos archivos por otras aplicaciones, incluidas potencialmente maliciosas.

1. **Static Analysis:**
- **Asegúrate** de que el uso de `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` sea **cuidadosamente examinado**. Estos modos **pueden exponer** archivos a **accesos no intencionados o no autorizados**.
2. **Dynamic Analysis:**
- **Verifica** los **permisos** establecidos en los archivos creados por la app. Específicamente, **comprueba** si algún archivo está **configurado como readable o writable worldwide**. Esto puede suponer un riesgo significativo de seguridad, ya que permitiría que **cualquier aplicación** instalada en el dispositivo, independientemente de su origen o intención, **lea o modifique** estos archivos.

**Almacenamiento externo**

Al tratar con archivos en **almacenamiento externo**, como SD Cards, se deben tomar ciertas precauciones:

1. **Accesibilidad**:
- Los archivos en almacenamiento externo son **globalmente legibles y escribibles**. Esto significa que cualquier aplicación o usuario puede acceder a estos archivos.
2. **Preocupaciones de seguridad**:
- Dada la facilidad de acceso, se recomienda **no almacenar información sensible** en almacenamiento externo.
- El almacenamiento externo puede ser removido o accedido por cualquier aplicación, lo que lo hace menos seguro.
3. **Manejo de datos desde almacenamiento externo**:
- Siempre **realiza validación de input** sobre los datos recuperados del almacenamiento externo. Esto es crucial porque los datos provienen de una fuente no confiable.
- No se recomienda almacenar ejecutables o class files en almacenamiento externo para carga dinámica.
- Si tu aplicación debe recuperar archivos ejecutables desde el almacenamiento externo, asegúrate de que estos archivos estén **firmados y verificados criptográficamente** antes de cargarlos dinámicamente. Este paso es vital para mantener la integridad de seguridad de tu aplicación.

El almacenamiento externo puede ser **accedido** en `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> A partir de Android 4.4 (**API 17**), la SD card tiene una estructura de directorios que **limita el acceso de una app al directorio que es específicamente para esa app**. Esto evita que una application maliciosa obtenga acceso de lectura o escritura a los archivos de otra app.

**Datos sensibles almacenados en texto claro**

- **Shared preferences**: Android permite a cada application guardar fácilmente archivos xml en la ruta `/data/data/<packagename>/shared_prefs/` y a veces es posible encontrar información sensible en texto claro en esa carpeta.
- **Databases**: Android permite a cada application guardar fácilmente bases de datos sqlite en la ruta `/data/data/<packagename>/databases/` y a veces es posible encontrar información sensible en texto claro en esa carpeta.

### TLS roto

**Accept All Certificates**

Por alguna razón, a veces los desarrolladores aceptan todos los certificados incluso si, por ejemplo, el hostname no coincide, con líneas de código como la siguiente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Criptografía rota

**Procesos deficientes de gestión de claves**

Algunos desarrolladores guardan datos sensibles en el almacenamiento local y los encriptan con una key hardcoded/predictable en el código. Esto no debería hacerse, ya que algo de reversing podría permitir a los attackers extraer la información confidencial.

**Uso de algoritmos inseguros y/o obsoletos**

Los desarrolladores no deberían usar **deprecated algorithms** para realizar **authorization checks**, **almacenar** o **enviar** datos. Algunos de estos algoritmos son: RC4, MD4, MD5, SHA1... Si se usan **hashes** para almacenar passwords por ejemplo, deberían usarse hashes resistentes a brute-force con salt.

### Otras comprobaciones

- Se recomienda **ofuscar el APK** para dificultar el trabajo de reverse engineer a los atacantes.
- Si la app es sensible (como apps bancarias), debería realizar sus **propias comprobaciones para ver si el móvil está rooted** y actuar en consecuencia.
- Si la app es sensible (como apps bancarias), debería comprobar si se está usando un **emulator**.
- Si la app es sensible (como apps bancarias), debería **comprobar su propia integridad antes de ejecutarse** para verificar si fue modificada.
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) es capaz de encontrar **vulnerabilidades** escaneando el **código** de la aplicación. Esta herramienta contiene una serie de **known sources** (que indican al tool los **lugares** donde la **entrada** está **controlada por el usuario**), **sinks** (que indican al tool los **lugares peligrosos** donde una entrada maliciosa podría causar daños) y **rules**. Estas reglas indican la **combinación** de **sources-sinks** que señalan una vulnerabilidad.

Con este conocimiento, **mariana-trench revisará el código y encontrará posibles vulnerabilidades en él**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Otras funciones interesantes

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Análisis dinámico

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Análisis dinámico en línea

Puedes crear una **cuenta gratuita** en: [https://appetize.io/](https://appetize.io). Esta plataforma permite **subir** y **ejecutar** APKs, por lo que es útil para ver cómo se comporta un apk.

Incluso puedes **ver los logs de tu aplicación** en la web y conectarte vía **adb**.

![](<../../images/image (831).png>)

Gracias a la conexión ADB puedes usar **Drozer** y **Frida** dentro de los emuladores.

### Análisis dinámico local

#### Usando un emulator

- [**Android Studio**](https://developer.android.com/studio) (Puedes crear dispositivos **x86** y **arm**, y según [**esto**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**las últimas versiones x86** supportan **ARM libraries** sin necesitar un emulator arm lento).
- Aprende a configurarlo en esta página:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versión gratuita:** Personal Edition, necesitas crear una cuenta. _Se recomienda **descargar** la versión **CON**_ _**VirtualBox** para evitar errores potenciales._)
- [**Nox**](https://es.bignox.com) (Gratis, pero no soporta Frida ni Drozer).

> [!TIP]
> Cuando crees un nuevo emulator en cualquier plataforma recuerda que cuanto más grande sea la pantalla, más lento correrá el emulator. Así que selecciona pantallas pequeñas si es posible.

Para **instalar google services** (como AppStore) en Genymotion necesitas clicar en el botón marcado en rojo de la siguiente imagen:

![](<../../images/image (277).png>)

También, nota que en la **configuración de la Android VM en Genymotion** puedes seleccionar **Bridge Network mode** (esto será útil si te vas a conectar a la Android VM desde otra VM con las herramientas).

#### Use a physical device

Necesitas activar las opciones de **debugging** y sería ideal si puedes **rootear** el dispositivo:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Una vez que hayas instalado la aplicación, lo primero que deberías hacer es probarla e investigar qué hace, cómo funciona y familiarizarte con ella.\
> Sugiero **realizar este análisis dinámico inicial usando MobSF dynamic analysis + pidcat**, así podremos **aprender cómo funciona la aplicación** mientras MobSF **captura** muchos datos **interesantes** que podrás revisar más tarde.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Los desarrolladores deben tener cuidado de no exponer información de **depuración** públicamente, ya que puede conducir a leaks de datos sensibles. Se recomiendan las herramientas [**pidcat**](https://github.com/JakeWharton/pidcat) y `adb logcat` para monitorizar los logs de la aplicación e identificar y proteger información sensible. **Pidcat** es preferido por su facilidad de uso y legibilidad.

> [!WARNING]
> Ten en cuenta que desde **versiones posteriores a Android 4.0**, **las aplicaciones solo pueden acceder a sus propios logs**. Así que las aplicaciones no pueden acceder a los logs de otras apps.\
> De todas formas, sigue siendo recomendable **no loguear información sensible**.

**Copy/Paste Buffer Caching**

El framework basado en portapapeles de Android permite la funcionalidad de copy-paste en las apps, pero presenta un riesgo ya que **otras aplicaciones** pueden **acceder** al portapapeles, exponiendo potencialmente datos sensibles. Es crucial **deshabilitar las funciones de copy/paste** para secciones sensibles de una aplicación, como datos de tarjetas de crédito, para prevenir leaks.

**Crash Logs**

Si una aplicación **crashea** y **guarda logs**, esos logs pueden ayudar a los atacantes, especialmente cuando la aplicación no puede ser reverse-engineered. Para mitigar este riesgo, evita loguear en crashes, y si los logs deben transmitirse por la red, asegúrate de enviarlos vía un canal SSL para seguridad.

Como pentester, **intenta echar un vistazo a estos logs**.

**Analytics Data Sent To 3rd Parties**

Las aplicaciones a menudo integran servicios como Google Adsense, que pueden inadvertidamente causar leaks de datos sensibles debido a una implementación incorrecta por parte de los desarrolladores. Para identificar posibles leaks, es aconsejable **interceptar el tráfico de la aplicación** y comprobar si se está enviando información sensible a servicios de terceros.

### SQLite DBs

La mayoría de las aplicaciones usarán **bases de datos SQLite internas** para guardar información. Durante el pentest echa un **vistazo** a las **bases de datos** creadas, los nombres de **tablas** y **columnas** y todos los **datos** guardados porque podrías encontrar **información sensible** (lo que sería una vulnerabilidad).\
Las bases de datos deberían estar ubicadas en `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`

Si la base de datos guarda información confidencial y está **encriptada** pero puedes **encontrar** la **contraseña** dentro de la aplicación, sigue siendo una **vulnerabilidad**.

Enumera las tablas usando `.tables` y enumera las columnas de las tablas con `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** te permite **asumir el rol de una app Android** e interactuar con otras apps. Puede hacer **cualquier cosa que una aplicación instalada pueda hacer**, como usar el mecanismo de Inter-Process Communication (IPC) de Android e interactuar con el sistema operativo subyacente. .\
Drozer es una herramienta útil para **explotar exported activities, exported services y Content Providers** como aprenderás en las siguientes secciones.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
También recuerda que el código de una activity comienza en el método **`onCreate`**.

**Authorisation bypass**

Cuando una Activity está exported puedes invocar su pantalla desde una app externa. Por lo tanto, si una activity con **información sensible** está **exported** podrías **bypassear** los mecanismos de **autenticación** para acceder a ella.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

También puedes iniciar una activity exported desde adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF detectará como malicioso el uso de _**singleTask/singleInstance**_ como `android:launchMode` en una activity, pero debido a [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), aparentemente esto solo es peligroso en versiones antiguas (versiones de API < 21).

> [!TIP]
> Ten en cuenta que un authorisation bypass no siempre es una vulnerabilidad; dependerá de cómo funciona el bypass y qué información se expone.

**Sensitive information leakage**

**Activities can also return results**. Si logras encontrar una activity exportada y sin protección que llame al método **`setResult`** y **devuelva información sensible**, hay una sensitive information leakage.

#### Tapjacking

Si Tapjacking no se previene, podrías abusar de la activity exportada para hacer que el **usuario realice acciones inesperadas**. Para más información sobre [**qué es Tapjacking sigue el enlace**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Lee esto si quieres repasar qué es un Content Provider.**](android-applications-basics.md#content-provider)\
Content providers se usan básicamente para **compartir datos**. Si una app tiene content providers disponibles, podrías ser capaz de **extraer datos sensibles** de ellos. También es interesante probar posibles **SQL injections** y **Path Traversals**, ya que podrían ser vulnerables.

[**Aprende cómo explotar Content Providers con Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Lee esto si quieres repasar qué es un Service.**](android-applications-basics.md#services)\
Recuerda que las acciones de un Service comienzan en el método `onStartCommand`.

Un Service es básicamente algo que **puede recibir datos**, **procesarlos** y **devolver** (o no) una respuesta. Por tanto, si una aplicación exporta servicios deberías **revisar** el **código** para entender qué hace y **probarlo** **dinámicamente** para extraer información confidencial, realizar un bypass a medidas de autenticación...\
[**Aprende cómo explotar Services con Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Lee esto si quieres repasar qué es un Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Recuerda que las acciones de un Broadcast Receiver empiezan en el método `onReceive`.

Un broadcast receiver estará esperando un tipo de mensaje. Dependiendo de cómo el receiver maneje el mensaje, podría ser vulnerable.\
[**Aprende cómo explotar Broadcast Receivers con Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Puedes buscar deep links manualmente, usando herramientas como MobSF o scripts como [este](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puedes **abrir** un scheme declarado usando **adb** o un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Ten en cuenta que puedes **omitir el nombre del paquete** y el móvil llamará automáticamente a la app que debería abrir ese enlace._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código ejecutado**

Para encontrar el **código que se ejecutará en la App**, ve a la activity llamada por el deeplink y busca la función **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Información sensible**

Cada vez que encuentres un deep link comprueba que **no esté recibiendo datos sensibles (como contraseñas) vía parámetros URL**, porque cualquier otra aplicación podría **hacerse pasar por el deep link y robar esos datos!**

**Parámetros en la ruta**

Debes comprobar también si algún deep link está usando un parámetro dentro de la path de la URL como: `https://api.example.com/v1/users/{username}`, en ese caso puedes forzar un path traversal accediendo a algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Ten en cuenta que si encuentras los endpoints correctos dentro de la aplicación podrías causar un **Open Redirect** (si parte de la ruta se usa como nombre de dominio), **account takeover** (si puedes modificar detalles de usuarios sin token CSRF y el endpoint vuln usó el método correcto) y cualquier otra vuln. Más [info sobre esto aquí](http://dphoeniixx.com/2020/12/13-2/).

**Más ejemplos**

Un [interesante informe de bug bounty](https://hackerone.com/reports/855618) sobre enlaces (_/.well-known/assetlinks.json_).

### Inspección de la capa de transporte y fallos de verificación

- **Los certificados no siempre son inspeccionados correctamente** por las aplicaciones Android. Es común que estas aplicaciones ignoren advertencias y acepten certificados self-signed o, en algunos casos, vuelvan a usar conexiones HTTP.
- **Las negociaciones durante el handshake SSL/TLS a veces son débiles**, empleando cipher suites inseguros. Esta vulnerabilidad hace la conexión susceptible a ataques man-in-the-middle (MITM), permitiendo a un atacante descifrar los datos.
- **Fuga de información privada** es un riesgo cuando las aplicaciones se autentican usando canales seguros pero luego comunican por canales no seguros para otras transacciones. Este enfoque no protege datos sensibles, como cookies de sesión o detalles de usuario, de ser interceptados por entidades maliciosas.

#### Verificación de certificados

Nos centraremos en la **verificación de certificados**. La integridad del certificado del servidor debe verificarse para aumentar la seguridad. Esto es crucial porque configuraciones TLS inseguras y la transmisión de datos sensibles por canales no cifrados pueden suponer riesgos significativos. Para pasos detallados sobre cómo verificar certificados del servidor y abordar vulnerabilidades, [**este recurso**](https://manifestsecurity.com/android-application-security-part-10/) ofrece una guía completa.

#### SSL Pinning

SSL Pinning es una medida de seguridad en la que la aplicación verifica el certificado del servidor frente a una copia conocida almacenada dentro de la propia aplicación. Este método es esencial para prevenir ataques man-in-the-middle (MITM). Se recomienda encarecidamente implementar SSL Pinning en aplicaciones que manejen información sensible.

#### Inspección del tráfico

Para inspeccionar tráfico HTTP es necesario **instalar el certificado de la herramienta proxy** (p. ej., Burp). Sin instalar este certificado, el tráfico cifrado podría no ser visible a través del proxy. Para una guía sobre cómo instalar un CA custom, [**haz clic aquí**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Las aplicaciones dirigidas a **API Level 24 and above** requieren modificaciones en el Network Security Config para aceptar el certificado CA del proxy. Este paso es crítico para inspeccionar tráfico cifrado. Para instrucciones sobre cómo modificar el Network Security Config, [**consulta este tutorial**](make-apk-accept-ca-certificate.md).

Si se está usando **Flutter** necesitas seguir las instrucciones en [**esta página**](flutter.md). Esto es porque, simplemente añadir el certificado al store no funcionará, ya que Flutter tiene su propia lista de CAs válidas.

#### Detección estática de SSL/TLS pinning

Antes de intentar bypasses en tiempo de ejecución, mapea rápidamente dónde se aplica el pinning en el APK. El descubrimiento estático te ayuda a planear hooks/patches y a centrarte en los code paths correctos.

Tool: SSLPinDetect
- Utilidad de análisis estático open-source que decompila el APK a Smali (vía apktool) y busca patrones regex seleccionados de implementaciones de SSL/TLS pinning.
- Informa la ruta exacta del archivo, número de línea, y un snippet de código para cada coincidencia.
- Cubre frameworks comunes y code paths personalizados: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Instalación
- Requisitos previos: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Ejemplo de reglas de patrones (JSON)
Usa o amplía signatures para detectar estilos de pinning propietarios/custom. Puedes cargar tu propio JSON y escanear a escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notas y consejos
- Escaneo rápido en apps grandes vía multihilo y memory-mapped I/O; regex pre-compiladas reducen overhead/falsos positivos.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Objetivos típicos de detección para priorizar a continuación:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins en res/xml network security config y manifest references
- Usa las ubicaciones encontradas para planear Frida hooks, parches estáticos o revisiones de config antes de pruebas dinámicas.



#### Eludir SSL Pinning

Cuando SSL Pinning está implementado, eludirlo se vuelve necesario para inspeccionar el tráfico HTTPS. Existen varios métodos disponibles para este propósito:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). La principal ventaja de esta opción es que no necesitarás root para bypass SSL Pinning, pero tendrás que eliminar la aplicación e instalar la nueva, y esto no siempre funcionará.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Buscando vulnerabilidades web comunes

También es importante buscar vulnerabilidades web comunes dentro de la aplicación. La información detallada sobre cómo identificarlas y mitigarlas queda fuera del alcance de este resumen, pero está ampliamente cubierta en otros recursos.

### Frida

[Frida](https://www.frida.re) es un toolkit de instrumentación dinámica para developers, reverse-engineers y security researchers.\
**You can access running application and hook methods on run time to change the behaviour, change values, extract values, run different code...**\
Si quieres pentestear aplicaciones Android necesitas saber cómo usar Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Volcar memoria - Fridump**

Comprueba si la aplicación está almacenando información sensible en la memoria que no debería guardar, como passwords o mnemonics.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) puedes volcar la memoria de la app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Esto volcará la memoria en la carpeta ./dump, y ahí podrías usar grep con algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Datos sensibles en Keystore**

En Android, el Keystore es el mejor lugar para almacenar datos sensibles; sin embargo, con suficientes privilegios todavía es **posible acceder a él**. Como las aplicaciones tienden a almacenar aquí **sensitive data in clear text**, los pentests deberían comprobarlo, ya que un root user o alguien con acceso físico al dispositivo podría robar estos datos.

Incluso si una app almacena datos en el Keystore, los datos deben estar cifrados.

Para acceder a los datos dentro del Keystore puedes usar este Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando el siguiente script de Frida, podría ser posible **bypass fingerprint authentication** que las aplicaciones Android podrían realizar para **proteger ciertas áreas sensibles:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imágenes de fondo**

Cuando colocas una aplicación en segundo plano, Android guarda una **instantánea de la aplicación** para que, cuando se recupere al primer plano, empiece cargando la imagen antes que la app y así parezca que la aplicación se cargó más rápido.

Sin embargo, si esta instantánea contiene **información sensible**, alguien con acceso a la instantánea podría **robar esa información** (nota: necesitas root para acceder a ella).

Las instantáneas suelen almacenarse en: **`/data/system_ce/0/snapshots`**

Android proporciona una forma de **evitar la captura de pantalla estableciendo el parámetro de layout FLAG_SECURE**. Al usar esta bandera, el contenido de la ventana se trata como seguro, evitando que aparezca en capturas de pantalla o que pueda verse en pantallas no seguras.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Esta herramienta puede ayudarte a gestionar diferentes herramientas durante el análisis dinámico: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Los desarrolladores a menudo crean componentes proxy como activities, services y broadcast receivers que manejan estos Intents y los pasan a métodos como `startActivity(...)` o `sendBroadcast(...)`, lo cual puede ser riesgoso.

El peligro radica en permitir que atacantes activen componentes de la app no exportados o accedan a content providers sensibles al redirigir estos Intents. Un ejemplo notable es el componente `WebView` que convierte URLs en objetos `Intent` vía `Intent.parseUri(...)` y luego los ejecuta, lo que puede conducir a inyecciones de Intent maliciosos.

### Essential Takeaways

- **Intent Injection** es similar al Open Redirect de la web.
- Los exploits implican pasar objetos `Intent` como extras, que pueden ser redirigidos para ejecutar operaciones inseguras.
- Puede exponer a atacantes componentes no exportados y content providers.
- La conversión de URL a `Intent` de `WebView` puede facilitar acciones no deseadas.

### Android Client Side Injections and others

Probablemente conozcas este tipo de vulnerabilidades por la Web. Debes tener especial cuidado con estas vulnerabilidades en una aplicación Android:

- **SQL Injection:** Al trabajar con consultas dinámicas o Content-Providers, asegúrate de usar consultas parametrizadas.
- **JavaScript Injection (XSS):** Verifica que el soporte de JavaScript y Plugin esté deshabilitado para cualquier WebView (deshabilitado por defecto). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Los WebViews deberían tener deshabilitado el acceso al sistema de archivos (habilitado por defecto) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: En varios casos, cuando la aplicación Android finaliza la sesión, la cookie no se revoca o incluso puede guardarse en disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análisis estático**

![](<../../images/image (866).png>)

**Evaluación de vulnerabilidades de la aplicación** usando una agradable interfaz web. También puedes realizar análisis dinámico (pero necesitas preparar el entorno).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Herramientas HTTP**

Cuando se captura tráfico HTTP puedes ver una vista fea del tráfico capturado en el botón "**HTTP(S) Traffic**" o una vista más agradable en el botón verde "**Start HTTPTools**". Desde la segunda opción, puedes **send** las **captured requests** a **proxies** como Burp o Owasp ZAP.\
Para ello, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> pulsa "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una vez termines el dynamic analysis con MobSF puedes pulsar en "**Start Web API Fuzzer**" para **fuzz http requests** y buscar vulnerabilidades.

> [!TIP]
> Después de realizar un dynamic analysis con MobSF los ajustes de proxy pueden quedar mal configurados y no podrás corregirlos desde la GUI. Puedes arreglar los ajustes de proxy ejecutando:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Puedes obtener la herramienta desde [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta herramienta usará algunos **Hooks** para informarte **qué está pasando en la aplicación** mientras realizas un **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta es una **gran herramienta para realizar static analysis con una GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta herramienta está diseñada para buscar varias **vulnerabilidades de aplicaciones Android relacionadas con la seguridad**, ya sea en **source code** o en **packaged APKs**. La herramienta también es **capable of creating a "Proof-of-Concept" deployable APK** y **ADB commands**, para explotar algunas de las vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Como con Drozer, no es necesario rootear el dispositivo de prueba.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Muestra todos los archivos extraídos para fácil consulta
- Descompila automáticamente archivos APK a Java y Smali
- Analiza AndroidManifest.xml en busca de vulnerabilidades y comportamientos comunes
- Análisis estático del código fuente en busca de vulnerabilidades y comportamientos comunes
- Información del dispositivo
- y más
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER es una aplicación de línea de comandos que puede usarse en Windows, MacOS X y Linux, que analiza archivos _.apk_ en busca de vulnerabilidades. Hace esto descomprimiendo los APKs y aplicando una serie de reglas para detectar esas vulnerabilidades.

Todas las reglas están centralizadas en un archivo `rules.json`, y cada empresa o tester puede crear sus propias reglas para analizar lo que necesiten.

Descarga los binarios más recientes desde la [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn es una herramienta **multiplataforma** que ayuda a desarrolladores, bugbounty hunters y ethical hackers a realizar [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) en aplicaciones móviles.

El concepto es que arrastras y sueltas tu archivo de aplicación móvil (un archivo .apk o .ipa) en la aplicación StaCoAn y ésta generará un informe visual y portátil para ti. Puedes ajustar los settings y wordlists para obtener una experiencia personalizada.

Descargar[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework es un sistema de análisis de vulnerabilidades para Android que ayuda a desarrolladores o hackers a encontrar posibles vulnerabilidades de seguridad en aplicaciones Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** es una herramienta cuyo objetivo principal es detectar y advertir al usuario sobre posibles comportamientos maliciosos desarrollados por una aplicación Android.

La detección se realiza mediante el **static analysis** del Dalvik bytecode de la aplicación, representado como **Smali**, usando la librería [`androguard`](https://github.com/androguard/androguard).

Esta herramienta busca **comportamiento común de aplicaciones "malas"** como: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** es un Framework de ingeniería inversa y análisis de aplicaciones móviles. Es una herramienta que agrupa herramientas comúnmente usadas para reverse engineering y análisis de aplicaciones móviles, para ayudar en las pruebas de aplicaciones móviles frente a las amenazas de seguridad móvil de OWASP. Su objetivo es hacer esta tarea más fácil y amigable para desarrolladores de aplicaciones móviles y profesionales de seguridad.

Es capaz de:

- Extraer código Java y Smali usando diferentes herramientas
- Analizar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraer información privada del APK usando regexps.
- Analizar el Manifest.
- Analizar dominios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) y [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Desofuscar APK vía [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Ten en cuenta que, dependiendo del servicio y la configuración que uses para ofuscar el código, los secretos pueden o no quedar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard se distribuye como parte del Android SDK y se ejecuta al compilar la aplicación en modo release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- cargar un recurso como un InputStream;
- pasar el resultado a una clase que hereda de FilterInputStream para descifrarlo;
- hacer alguna ofuscación inútil para hacer perder unos minutos al reverser;
- pasar el resultado descifrado a un ZipInputStream para obtener un archivo DEX;
- finalmente cargar el DEX resultante como un Resource usando el método `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Puedes subir un APK ofuscado a su plataforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD te da información sobre **cómo se hizo un APK**. Identifica muchos **compilers**, **packers**, **obfuscators**, y otras cosas raras. Es [_PEiD_] para Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b es una máquina virtual de seguridad para Android basada en ubuntu-mate que incluye la colección de los últimos frameworks, tutoriales y laboratorios de diferentes expertos e investigadores de seguridad para ingeniería inversa y análisis de malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Es una gran lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
