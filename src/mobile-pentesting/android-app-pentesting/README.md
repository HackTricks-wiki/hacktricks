# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Основи Android-додатків

Рекомендується почати з прочитання цієї сторінки, щоб дізнатися про **найважливіші частини, пов'язані з безпекою Android, та найбільш небезпечні компоненти в Android-застосунку**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Це основний інструмент, який потрібен для підключення до android-пристрою (емулятор або фізичний).\
**ADB** дозволяє керувати пристроями як через **USB**, так і через **Network** з комп'ютера. Ця утиліта дозволяє **копіювати** файли в обох напрямках, **встановлювати** та **видаляти** додатки, **виконувати** shell-команди, **створювати резервні копії** даних, **читати** логи та інші функції.

Перегляньте наступний список [**ADB Commands**](adb-commands.md), щоб дізнатися, як використовувати adb.

## Smali

Іноді цікаво **змінити код додатка**, щоб отримати доступ до **прихованої інформації** (можливо добре обфусковані паролі або flags). Тоді може бути корисно декомпілювати apk, змінити код і перекомпілювати його.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Це може бути дуже корисно як **альтернатива для кількох тестів під час dynamic analysis**, що будуть представлені. Тому **завжди майте цю можливість на увазі**.

## Інші цікаві трюки

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Об'єднати всі splits і base apks за допомогою [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Атаки на Android Enterprise та Work Profile

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Кейси та вразливості


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Статичний аналіз

Насамперед, для аналізу APK слід **переглянути Java-код** за допомогою decompiler.\
Будь ласка, [**прочитайте тут інформацію про різні доступні decompilers**](apk-decompilers.md).

### Пошук цікавої інформації

Достатньо переглянути **strings** APK, щоб шукати **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** та будь-що цікаве... шукати навіть code execution **backdoors** або authentication backdoors (жорстко закодовані admin credentials у додатку).

**Firebase**

Зверніть особливу увагу на **firebase URLs** і перевірте, чи не налаштовано його неправильно. [Більше інформації про те, що таке Firebase і як його експлуатувати тут.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Базове розуміння додатку - Manifest.xml, strings.xml

**Огляд файлів _Manifest.xml_ та _strings.xml_ додатку може виявити потенційні вразливості**. До цих файлів можна отримати доступ за допомогою decompilers або перейменувавши розширення APK на .zip і розпакувавши його.

**Вразливості**, які можна ідентифікувати з **Manifest.xml**:

- **Debuggable Applications**: Додатки, позначені як debuggable (`debuggable="true"`) у _Manifest.xml_, становлять ризик, оскільки дозволяють підключення, які можуть призвести до експлуатації. Для подальшого розуміння того, як експлуатувати debuggable додатки, зверніться до навчального посібника з пошуку та експлуатації debuggable додатків на пристрої.
- **Backup Settings**: Атрибут `android:allowBackup="false"` повинен бути явно встановлений для додатків, що працюють з чутливою інформацією, щоб запобігти несанкціонованому резервному копіюванню даних через adb, особливо коли usb debugging увімкнено.
- **Network Security**: Користувацькі конфігурації мережевої безпеки (`android:networkSecurityConfig="@xml/network_security_config"`) у _res/xml/_ можуть вказувати деталі безпеки, такі як certificate pins та налаштування HTTP traffic. Наприклад, дозволення HTTP traffic для певних доменів.
- **Exported Activities and Services**: Ідентифікація exported activities та services у manifest може виявити компоненти, якими можуть зловживати. Подальший аналіз під час dynamic testing може показати, як експлуатувати ці компоненти.
- **Content Providers and FileProviders**: Відкриті content providers можуть дозволити несанкціонований доступ або модифікацію даних. Конфігурацію FileProviders також слід ретельно перевірити.
- **Broadcast Receivers and URL Schemes**: Ці компоненти можуть бути використані для експлуатації, зверніть особливу увагу на те, як URL schemes обробляються з огляду на вразливості при прийомі вводу.
- **SDK Versions**: Атрибути `minSdkVersion`, `targetSDKVersion` та `maxSdkVersion` вказують підтримувані версії Android, підкреслюючи важливість непідтримування застарілих, вразливих версій Android з міркувань безпеки.

З файлу **strings.xml** можна знайти чутливу інформацію, таку як API keys, custom schemas та інші нотатки розробника, що підкреслює необхідність ретельного перегляду цих ресурсів.

### Tapjacking

**Tapjacking** — це атака, коли **зловмисний додаток** запускається і **розміщується поверх цільового додатку**. Коли він візуально затемнює цільовий додаток, його інтерфейс розроблений таким чином, щоб обманом змусити користувача взаємодіяти з ним, при цьому передаючи взаємодію цільовому додатку.\
Фактично, це **затемнює користувача, не дозволяючи йому зрозуміти, що він насправді виконує дії в цільовому додатку**.

Більше інформації у:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity з `launchMode`, встановленим на `singleTask` без вказаного `taskAffinity`, вразлива до task Hijacking. Це означає, що додаток може бути встановлений і, якщо його запустити раніше за реальний додаток, він може **поглинути task реального додатку** (тому користувач взаємодіятиме зі **зловмисним додатком, думаючи, що він використовує реальний**).

Більше інформації у:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

В Android файли, що зберігаються в **internal storage**, спроєктовані так, щоб бути доступними виключно для додатку, який їх створив. Цей захід безпеки застосовується операційною системою Android і зазвичай є достатнім для потреб більшості додатків. Проте іноді розробники використовують режими такі як `MODE_WORLD_READABLE` та `MODE_WORLD_WRITABLE`, щоб **дозволити** файлам **бути спільно доступними** між різними додатками. Ці режими **не обмежують доступ** до цих файлів іншими додатками, включно з потенційно зловмисними.

1. **Статичний аналіз:**
- **Переконайтеся**, що використання `MODE_WORLD_READABLE` та `MODE_WORLD_WRITABLE` ретельно перевірено. Ці режими **можуть піддавати** файли небажаному або несанкціонованому доступу.
2. **Динамічний аналіз:**
- **Перевірте** права доступу, встановлені на файлах, створених додатком. Зокрема, **перевірте**, чи будь-які файли **налаштовано як readable або writable worldwide**. Це може становити значний ризик безпеки, оскільки дозволило б **будь-якому додатку**, встановленому на пристрої, незалежно від походження чи намірів, **читати або змінювати** ці файли.

**External Storage**

При роботі з файлами на **external storage**, наприклад SD Cards, слід дотримуватися певних запобіжних заходів:

1. **Доступність**:
- Файли на external storage є **загальнодоступними для читання та запису**. Це означає, що будь-який додаток або користувач може отримати доступ до цих файлів.
2. **Проблеми безпеки**:
- Через легкість доступу не рекомендується **зберігати чутливу інформацію** на external storage.
- External storage може бути видалений або до нього може отримати доступ будь-який додаток, що робить його менш захищеним.
3. **Обробка даних з External Storage**:
- Завжди **виконуйте валідацію вводу** для даних, отриманих з external storage. Це критично, оскільки дані походять з неперевіреного джерела.
- Не рекомендується зберігати виконувані файли або class-файли на external storage для динамічного завантаження.
- Якщо ваш додаток повинен отримувати виконувані файли з external storage, переконайтеся, що ці файли **підписані та криптографічно перевірені**, перш ніж їх динамічно завантажувати. Цей крок є важливим для збереження цілісності безпеки додатку.

External storage можна **доступитися** в /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Починаючи з Android 4.4 (**API 17**), SD card має структуру директорій, яка **обмежує доступ додатку до директорії, яка спеціально призначена для цього додатку**. Це запобігає тому, щоб зловмисний додаток отримав права читання або запису файлів іншого додатку.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android дозволяє кожному додатку легко зберігати xml файли в шляху `/data/data/<packagename>/shared_prefs/` і іноді в цій папці можна знайти чутливу інформацію у відкритому тексті.
- **Databases**: Android дозволяє кожному додатку легко зберігати sqlite databases у шляху `/data/data/<packagename>/databases/` і іноді в цій папці можна знайти чутливу інформацію у відкритому тексті.

### Broken TLS

**Accept All Certificates**

З якоїсь причини інколи розробники приймають всі certificates навіть якщо, наприклад, hostname не відповідає, за допомогою рядків коду, подібних до наведених нижче:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Ненадійна криптографія

**Недостатні процеси управління ключами**

Деякі розробники зберігають чутливі дані в локальному сховищі і шифрують їх ключем, який жорстко захардкоджений/predictable в коді. Так робити не слід, оскільки зворотний інжиніринг може дозволити зловмисникам витягти конфіденційну інформацію.

**Використання небезпечних і/або застарілих алгоритмів**

Розробникам не слід використовувати **deprecated algorithms** для виконання авторизаційних **checks**, **store** або **send** даних. Деякі з цих алгоритмів: RC4, MD4, MD5, SHA1... Якщо **hashes** використовуються для збереження паролів, наприклад, слід використовувати стійкі до перебору алгоритми з сольовою захистом.

### Інші перевірки

- Рекомендується **обфускувати the APK**, щоб ускладнити роботу реверс-інженерів/атакуючих.
- Якщо додаток є чутливим (наприклад, банківські додатки), він повинен виконувати **власні перевірки на root** пристрою і діяти відповідно.
- Якщо додаток є чутливим (наприклад, банківські додатки), він повинен перевіряти, чи використовується **емулятор**.
- Якщо додаток є чутливим (наприклад, банківські додатки), він повинен **перевіряти власну цілісність перед виконанням**, щоб встановити, чи був він змінений.
- Використовуйте [**APKiD**](https://github.com/rednaga/APKiD) щоб перевірити, який compiler/packer/obfuscator було використано для збірки APK

### React Native Application

Прочитайте наступну сторінку, щоб дізнатися, як легко отримати доступ до javascript коду React додатків:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Прочитайте наступну сторінку, щоб дізнатися, як легко отримати доступ до C# коду xamarin додатків:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Згідно з цим [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/), superpacked — це Meta алгоритм, який стискає вміст додатку в один файл. Блог описує можливість створення додатку, який розпаковує такого роду apps... та швидший спосіб, який полягає у **виконанні додатку та зборі розпакованих файлів з файлової системи.**

### Automated Static Code Analysis

Інструмент [**mariana-trench**](https://github.com/facebook/mariana-trench) здатний знаходити **vulnerabilities** шляхом **scanning** **code** додатку. Цей інструмент містить ряд **known sources** (що вказують інструменту **місця**, де **input** **контролюється користувачем**), **sinks** (що вказують інструменту **небезпечні** **місця**, де зловмисний ввід користувача може завдати шкоди) та **rules**. Ці правила визначають **комбінації** **sources-sinks**, що вказують на вразливість.

Маючи ці знання, **mariana-trench перевірить код і знайде можливі вразливості в ньому**.

### Витік секретів

Додаток може містити секрети (API keys, паролі, приховані url, піддомени...) всередині себе, які ви можете виявити. Ви можете використовувати інструмент, такий як [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Обхід біометричної автентифікації


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Інші цікаві функції

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Інші трюки**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Динамічний аналіз

> По-перше, вам потрібне середовище, де ви зможете встановити додаток і все оточення (Burp CA cert, Drozer і Frida головним чином). Тому настійно рекомендовано використовувати root-пристрій (емулятор або реальний).

### Онлайн динамічний аналіз

Ви можете створити **free account** на: [https://appetize.io/](https://appetize.io). Ця платформа дозволяє **upload** та **execute** APK, тому корисно подивитися, як apk поводиться.

Ви навіть можете **see the logs of your application** на вебі та підключитися через **adb**.

![](<../../images/image (831).png>)

Завдяки ADB з’єднанню ви можете використовувати **Drozer** та **Frida** всередині емуляторів.

### Локальний динамічний аналіз

#### Використання емулятора

- [**Android Studio**](https://developer.android.com/studio) (Ви можете створювати **x86** та **arm** пристрої, і згідно з [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** версії **підтримують ARM libraries** без необхідності повільного arm емулятора).
- Навчіться налаштовувати його на цій сторінці:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, потрібно зареєструвати акаунт. _Рекомендується **download** версію **WITH**_ _**VirtualBox** щоб уникнути потенційних помилок._)
- [**Nox**](https://es.bignox.com) (Безкоштовно, але не підтримує Frida або Drozer).

> [!TIP]
> Коли створюєте новий емулятор на будь-якій платформі, пам’ятайте, що чим більший екран, тим повільніше буде працювати емулятор. Тому за можливості обирайте менші екрани.

Щоб **install google services** (наприклад AppStore) в Genymotion потрібно натиснути на червону позначену кнопку на наступному зображенні:

![](<../../images/image (277).png>)

Також зверніть увагу, що в **конфігурації Android VM в Genymotion** ви можете вибрати **Bridge Network mode** (це буде корисно, якщо ви будете підключатися до Android VM з іншої VM з інструментами).

#### Використання фізичного пристрою

Потрібно активувати **debugging** опції, і бажано, щоб пристрій був **root**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Після встановлення додатку перше, що вам слід зробити — це спробувати його і дослідити, що він робить, як працює і відчути себе в ньому комфортно.\
> Рекомендую **виконати цей початковий динамічний аналіз за допомогою MobSF dynamic analysis + pidcat**, так ми зможемо **вивчити, як працює додаток**, поки MobSF **збирає** купу **цікавих** **даних**, які ви зможете переглянути пізніше.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Ненавмисний витік даних

**Логування**

Розробникам слід бути обережними з публічним розголошенням **debugging information**, оскільки це може призвести до витоку чутливих даних. Рекомендуються інструменти [**pidcat**](https://github.com/JakeWharton/pidcat) та `adb logcat` для моніторингу логів додатків, щоб ідентифікувати і захистити чутливу інформацію. **Pidcat** надається перевага за простоту використання та читабельність.

> [!WARNING]
> Зауважте, що з **версій новіших за Android 4.0**, **додатки можуть отримувати доступ лише до власних логів**. Тому додатки не можуть отримувати логи інших додатків.\
> В будь-якому разі, все одно рекомендовано **не логувати чутливу інформацію**.

**Кеш буфера копіювання/вставки**

Clipboard-based фреймворк Android дозволяє функціональність копіювання/вставки в додатках, проте становить ризик, оскільки **інші додатки** можуть **доступатися** до буфера обміну, потенційно розкриваючи чутливі дані. Важливо **відключити функції copy/paste** для чутливих секцій додатку, наприклад даних кредитних карт, щоб запобігти data leak.

**Crash Logs**

Якщо додаток **падає** і **зберігає логи**, ці логи можуть допомогти зловмисникам, особливо коли додаток неможливо зворотно інженірити. Щоб зменшити цей ризик, уникайте логування при крашах, а якщо логи потрібно відправляти по мережі, переконайтесь, що вони передаються через SSL-канал.

Як pentester, **спробуйте переглянути ці логи**.

**Аналітика, що відправляється третім сторонам**

Додатки часто інтегрують сервіси типу Google Adsense, які можуть ненавмисно **leak** чутливі дані через неправильну реалізацію розробниками. Щоб виявити потенційні витоки даних, доцільно **перехопити трафік додатку** та перевірити, чи не надсилається чутлива інформація на сторонні сервіси.

### SQLite DBs

Більшість додатків використовують **internal SQLite databases** для збереження інформації. Під час pentest перегляньте **бази даних**, що створені, імена **tables** та **columns** і всі **збережені дані**, оскільки ви можете знайти **чутливу інформацію** (що буде вразливістю).\
Бази даних повинні знаходитися в `/data/data/the.package.name/databases` наприклад `/data/data/com.mwr.example.sieve/databases`

Якщо база даних зберігає конфіденційну інформацію і **зашифрована**, але ви можете **знайти** пароль всередині додатку, це все одно є **вразливістю**.

Перелічте таблиці за допомогою `.tables` і перелічте колонки таблиць через `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

З [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** дозволяє вам **прийняти роль Android app** і взаємодіяти з іншими додатками. Він може робити **все, що може робити встановлений додаток**, наприклад використовувати Android’s Inter-Process Communication (IPC) механізм і взаємодіяти з underlying operating system. .\
Drozer — корисний інструмент для **експлуатації exported activities, exported services та Content Providers**, як ви дізнаєтесь у наступних розділах.

### Експлуатація exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Також пам’ятайте, що код activity починається в методі **`onCreate`**.

**Обхід авторизації**

Коли Activity експортується, ви можете викликати її екран з зовнішнього додатку. Отже, якщо activity з **чутливою інформацією** є **exported**, ви могли б **bypass** **authentication** механізми **щоб отримати до неї доступ.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Ви також можете запустити exported activity з adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**ПРИМІТКА**: MobSF виявлятиме як шкідливе використання _**singleTask/singleInstance**_ як `android:launchMode` в активності, але через [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), очевидно це небезпечно лише на старих версіях (API versions < 21).

> [!TIP]
> Зверніть увагу, що an authorisation bypass не завжди є вразливістю — це залежить від того, як bypass працює і яка інформація стає доступною.

**Витік конфіденційної інформації**

**Activities can also return results**. Якщо вам вдасться знайти експортовану та незахищену activity, яка викликає метод **`setResult`** і **повертає конфіденційну інформацію**, відбувається витік конфіденційної інформації.

#### Tapjacking

Якщо Tapjacking не запобігнуто, ви можете зловживати експортованою activity, щоб змусити **користувача виконувати небажані дії**. Для детальнішої інформації про [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers в основному використовуються для обміну даними. Якщо додаток має доступні content providers, ви можете витягти з них конфіденційні дані. Також варто протестувати можливі **SQL injections** та **Path Traversals**, оскільки вони можуть бути вразливими.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Пам'ятайте, що дії Service починаються в методі `onStartCommand`.

Сервіс — це, по суті, те, що **може отримувати дані**, **обробляти** їх і **повертати** (або ні) відповідь. Тому, якщо застосунок експортує сервіси, слід **перевірити** **код**, щоб зрозуміти, що він робить, та **динамічно протестувати** його для витягання конфіденційної інформації, обходу заходів аутентифікації...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Пам'ятайте, що дії Broadcast Receiver починаються в методі `onReceive`.

Broadcast receiver очікує певний тип повідомлення. В залежності від того, як receiver обробляє повідомлення, він може бути вразливим.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Ви можете шукати deep links вручну, використовуючи інструменти на зразок MobSF або скрипти типу [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Ви можете **відкрити** задекларований **scheme** за допомогою **adb** або **браузера**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Зверніть увагу, що ви можете **не вказувати назву пакету**, і мобільний пристрій автоматично викличе додаток, який має відкрити це посилання._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

Щоб знайти **код, який буде виконано в App**, перейдіть до activity, яку викликає deeplink, і знайдіть функцію **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

Кожного разу, коли ви знаходите deep link, перевіряйте, що він **не отримує чутливі дані (наприклад паролі) через параметри URL**, бо будь-який інший застосунок може **вдавати deep link і вкрасти ці дані!**

**Parameters in path**

Ви **також повинні перевірити, чи який-небудь deep link не використовує параметр всередині шляху** URL, наприклад: `https://api.example.com/v1/users/{username}` , у такому випадку ви можете примусити path traversal, звернувшись до чогось на кшталт: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Зверніть увагу, що якщо ви знайдете правильні endpoints всередині застосунку, ви можете спричинити **Open Redirect** (якщо частина шляху використовується як домен), **account takeover** (якщо можна змінювати деталі користувачів без CSRF token і вразливий endpoint використовував правильний метод) та інші вразливості. Більше [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** Android-застосунками. Часто такі застосунки ігнорують попередження і приймають self-signed certificates або, в деяких випадках, повертаються до використання HTTP-з’єднань.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, застосовуючи небезпечні cipher suites. Ця вразливість робить з’єднання вразливим до man-in-the-middle (MITM) атак, дозволяючи зловмисникам декодувати дані.
- Leakage of private information є ризиком, коли застосунки аутентифікуються за допомогою захищених каналів, але потім для інших транзакцій використовують незахищені канали. Такий підхід не захищає чутливі дані, наприклад session cookies або відомості про користувача, від перехоплення зловмисниками.

#### Certificate Verification

Ми зосередимося на **certificate verification**. Необхідно перевіряти цілісність сертифіката сервера для посилення безпеки. Це критично, оскільки небезпечні TLS-конфігурації та передача чутливих даних по незашифрованих каналах можуть становити значну загрозу. Для детальних кроків щодо перевірки сертифікатів сервера та усунення вразливостей [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) надає вичерпні інструкції.

#### SSL Pinning

SSL Pinning — це міра безпеки, коли застосунок перевіряє сертифікат сервера проти відомої копії, збереженої безпосередньо в застосунку. Цей метод є важливим для запобігання MITM-атакам. Рекомендовано реалізовувати SSL Pinning для застосунків, які обробляють чутливу інформацію.

#### Traffic Inspection

Щоб інспектувати HTTP-трафік, необхідно **встановити сертифікат proxy tool** (наприклад, Burp). Без встановлення цього сертифіката зашифрований трафік може бути невидимим через proxy. Для інструкції зі встановлення custom CA certificate [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Застосунки, які таргетять **API Level 24 and above**, вимагають модифікацій Network Security Config, щоб прийняти CA certificate проксі. Цей крок є критичним для інспекції зашифрованого трафіку. Для інструкцій щодо модифікації Network Security Config [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Якщо використовується **Flutter**, потрібно виконати інструкції на [**this page**](flutter.md). Це тому, що просте додавання сертифіката у сховище не спрацює — Flutter має власний список дійсних CA.

#### Static detection of SSL/TLS pinning

Перш ніж намагатися runtime bypasses, швидко промапте, де pinning застосовується в APK. Static discovery допоможе спланувати hooks/patches і зосередитися на потрібних шляхах виконання коду.

Tool: SSLPinDetect
- Open-source static-analysis utility, що декомпілює APK до Smali (через apktool) і сканує за куратованими regex patterns реалізацій SSL/TLS pinning.
- Звітує точний file path, line number та snippet коду для кожного збігу.
- Покриває поширені frameworks та кастомні code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, та Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Використання
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Приклади правил патернів (JSON)
Використовуйте або розширюйте signatures для виявлення власницьких/кастомних стилів pinning. Ви можете завантажити власний JSON і сканувати у великому масштабі.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Нотатки та поради
- Fast scanning on large apps via multi-threading and memory-mapped I/O; pre-compiled regex reduces overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Типові цілі для подальшого аналізу:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Використовуйте знайдені місця для планування Frida hooks, static patches або перегляду конфігурацій перед динамічним тестуванням.



#### Обхід SSL Pinning

Коли реалізовано SSL Pinning, його потрібно обійти для інспекції HTTPS трафіку. Існує кілька методів для цього:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Пошук поширених web вразливостей

Варто також шукати поширені web вразливості всередині додатку. Детальна інформація щодо ідентифікації та пом’якшення цих вразливостей виходить за межі цього конспекту, але широко висвітлюється в інших джерелах.

### Frida

[Frida](https://www.frida.re) is a dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.\
**You can access running application and hook methods on run time to change the behaviour, change values, extract values, run different code...**\
If you want to pentest Android applications you need to know how to use Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning — процес обходу

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Знімок пам'яті - Fridump**

Перевірте, чи додаток не зберігає в пам'яті конфіденційну інформацію, яку не повинен зберігати, наприклад паролі або мнемонічні фрази.

Використовуючи [**Fridump3**](https://github.com/rootbsd/fridump3) ви можете зняти пам'ять додатка за допомогою:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Це зробить dump пам'яті у папку ./dump, і там ви можете виконати grep приблизно так:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Чутливі дані в Keystore**

В Android Keystore — найкраще місце для зберігання чутливих даних, однак при достатніх привілеях до нього **можна отримати доступ**. Оскільки додатки часто зберігають тут **чутливі дані in clear text**, під час pentests слід перевіряти це, оскільки користувач з root або особа з фізичним доступом до пристрою можуть викрасти ці дані.

Навіть якщо додаток зберіг дані в Keystore, ці дані мають бути зашифровані.

Щоб отримати доступ до даних всередині Keystore, можна використати цей Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Використовуючи наступний Frida script, можливо **bypass fingerprint authentication**, яке виконують Android-застосунки, щоб **захистити певні чутливі розділи:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Фонові зображення**

Коли ви переводите додаток у фон, Android зберігає **snapshot of the application**, тож коли його повертають на передній план, система спочатку завантажує це зображення перед самим додатком, щоб здавалося, ніби додаток завантажився швидше.

Однак, якщо цей snapshot містить **чутливу інформацію**, людина з доступом до snapshot може **викрасти цю інформацію** (зверніть увагу, для доступу потрібен root).

Snapshots зазвичай зберігаються тут: **`/data/system_ce/0/snapshots`**

Android надає спосіб запобігти захопленню screenshot, встановивши параметр FLAG_SECURE для layout. Використовуючи цей прапорець, вміст вікна позначається як захищений, що запобігає його появі у screenshots або перегляду на незахищених дисплеях.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Цей інструмент може допомогти вам керувати різними інструментами під час динамічного аналізу: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Розробники часто створюють proxy-компоненти, такі як activities, services, і broadcast receivers, які обробляють ці Intents і передають їх у методи на кшталт `startActivity(...)` або `sendBroadcast(...)`, що може бути ризиковано.

Небезпека полягає в тому, що атака дозволяє зловмисникам викликати non-exported компоненти додатка або отримати доступ до чутливих content providers, перенаправивши ці Intents. Яскравий приклад — компонент `WebView`, який конвертує URL у `Intent` об’єкти через `Intent.parseUri(...)` і потім виконує їх, що може призвести до malicious Intent injections.

### Essential Takeaways

- **Intent Injection** is similar to web's Open Redirect issue.
- Exploits involve passing `Intent` objects as extras, which can be redirected to execute unsafe operations.
- It can expose non-exported components and content providers to attackers.
- `WebView`’s URL to `Intent` conversion can facilitate unintended actions.

### Android Client Side Injections and others

Мабуть, ви знаєте про такий тип вразливостей з Web. Потрібно бути особливо обережним з цими вразливостями в Android-додатку:

- **SQL Injection:** При роботі з динамічними запитами або Content-Providers переконайтеся, що ви використовуєте параметризовані запити.
- **JavaScript Injection (XSS):** Переконайтеся, що підтримка JavaScript і Plugin вимкнена для будь-яких WebViews (вимкнено за замовчуванням). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews повинні мати відключений доступ до файлової системи (включений за замовчуванням) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: У деяких випадках після завершення сесії android-додаток не скасовує cookie або воно може бути навіть збережене на диск
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** за допомогою зручного web-based frontend. Ви також можете виконати dynamic analysis (але потрібно підготувати середовище).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Асистований динамічний аналіз за допомогою MobSF

**MobSF** також може бути дуже корисним для **динамічного аналізу** на **Android**, але в цьому випадку вам потрібно встановити MobSF та **genymotion** на ваш хост (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
Динамічний аналізатор MobSF може:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP інструменти**

Коли HTTP-трафік захоплено, ви можете побачити негарний вигляд захопленого трафіку на кнопці "**HTTP(S) Traffic**" внизу або приємніший вигляд у зеленій кнопці "**Start HTTPTools**". З другої опції можна **відправити** **захоплені запити** на **проксі** на кшталт Burp або Owasp ZAP.\  
Для цього: _увімкніть Burp -->_ _вимкніть Intercept --> в MobSB HTTPTools оберіть запит_ --> натисніть "**Send to Fuzzer**" --> _виберіть адресу проксі_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Після завершення динамічного аналізу з MobSF ви можете натиснути "**Start Web API Fuzzer**", щоб **fuzz http requests** і шукати вразливості.

> [!TIP]
> Після виконання динамічного аналізу з MobSF налаштування проксі можуть бути некоректними, і ви не зможете виправити їх через GUI. Ви можете виправити налаштування проксі, виконавши:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Асистований динамічний аналіз з Inspeckage

Отримати інструмент можна з [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\  
Цей інструмент використовує деякі **Hooks**, щоб показати вам, **що відбувається в додатку** під час виконання **динамічного аналізу**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Це чудовий інструмент для виконання статичного аналізу з GUI

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Цей інструмент призначений для пошуку кількох **пов’язаних із безпекою вразливостей Android-додатків**, як у **вихідному коді**, так і в **упакованих APK**. Інструмент також **здатний створювати "Proof-of-Concept" deployable APK** та **ADB commands**, щоб експлуатувати деякі знайдені вразливості (Exposed activities, intents, tapjacking...). Як і у випадку з Drozer, немає потреби отримувати root на тестовому пристрої.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Показує всі вилучені файли для зручного перегляду
- Автоматично декомпілює APK-файли у формат Java та Smali
- Аналізує AndroidManifest.xml на наявність поширених вразливостей та поведінки
- Статичний аналіз вихідного коду на наявність поширених вразливостей та поведінки
- Інформація про пристрій
- та багато іншого
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER — це консольний додаток, який можна використовувати у Windows, MacOS X та Linux, і який аналізує _.apk_ файли для пошуку вразливостей. Він робить це, розпаковуючи APKs та застосовуючи низку правил для виявлення цих вразливостей.

Усі правила зосереджені у файлі `rules.json`, і кожна компанія або тестер може створити власні правила для аналізу того, що їм потрібно.

Завантажте останні бінарні файли зі [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn — це **кросплатформний** інструмент, який допомагає розробникам, bugbounty hunters та ethical hackers виконувати [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) мобільних додатків.

Ідея полягає в тому, що ви перетягуєте файл вашого мобільного додатка (файл .apk або .ipa) в застосунок StaCoAn, і він згенерує для вас візуальний та портативний звіт. Ви можете налаштувати параметри та wordlists, щоб отримати персоналізований досвід.

Завантажити[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework — це система аналізу вразливостей Android, яка допомагає розробникам або hackers знаходити потенційні вразливості безпеки в Android-додатках.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** — інструмент, основна мета якого — виявляти та попереджати користувача про потенційно шкідливі поведінки, реалізовані Android-застосунком.

Виявлення виконується за допомогою **static analysis** байткоду Dalvik додатка, представленого як **Smali**, з використанням бібліотеки [`androguard`](https://github.com/androguard/androguard).

Цей інструмент шукає **поширені поведінки «шкідливих» застосунків**, такі як: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Це інструмент, який об’єднує поширені інструменти для mobile application reverse engineering and analysis, щоб допомогти тестувати мобільні додатки щодо OWASP mobile security threats. Його мета — зробити це завдання простішим і більш дружнім для розробників мобільних додатків та спеціалістів з безпеки.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Корисний для виявлення malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Зауважте, що залежно від сервісу та конфігурації, яку ви використовуєте для obfuscate коду, секрети можуть бути як обфусковані, так і ні.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard розповсюджується як частина Android SDK і запускається при збірці додатку в release режимі.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Ви можете завантажити obfuscated APK на їхню платформу.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Прочитайте цей підручник, щоб дізнатися деякі прийоми щодо **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Це чудовий список ресурсів
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
