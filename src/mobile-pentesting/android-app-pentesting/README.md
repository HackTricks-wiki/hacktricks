# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

이 페이지를 먼저 읽어 Android 보안 및 Android 애플리케이션에서 가장 위험한 구성요소와 관련된 **가장 중요한 부분들**에 대해 파악하는 것을 강력히 권장합니다:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

이 도구는 에뮬레이터나 실제 Android 기기에 연결할 때 주로 사용하는 주요 도구입니다.  
**ADB**는 컴퓨터에서 **USB** 또는 **Network**를 통해 기기를 제어할 수 있게 해줍니다. 이 유틸리티는 파일의 양방향 **복사**, 앱의 **설치** 및 **제거**, shell commands의 **실행**, 데이터 **백업**, 로그 **읽기** 등 다양한 기능을 제공합니다.

adb 사용법을 배우려면 다음 [**ADB Commands**](adb-commands.md) 목록을 살펴보세요.

## Smali

때때로 **애플리케이션 코드를 수정**하여 **숨겨진 정보**(예: 잘 난독화된 비밀번호나 플래그)에 접근하는 것이 흥미로울 수 있습니다. 이 경우 apk를 디컴파일하고 코드를 수정한 다음 다시 컴파일하는 것이 유용할 수 있습니다. [**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). 이는 동적 분석 중 여러 테스트에 대한 **대안**으로 매우 유용할 수 있으니, 항상 이 가능성을 염두에 두세요.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 디바이스에서 APK 추출:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 모든 splits 및 base apks를 [APKEditor](https://github.com/REAndroid/APKEditor)로 병합:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## 사례 연구 및 취약점


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## 정적 분석

무엇보다도, APK를 분석할 때는 디컴파일러를 사용하여 **Java code**를 살펴봐야 합니다.\
[**다양한 사용 가능한 decompilers에 대한 정보를 보려면 여기 읽어보세요**](apk-decompilers.md).

### 흥미로운 정보 찾기

APK의 **strings**를 살펴보면 **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** 등 흥미로운 항목들을 검색할 수 있습니다. 코드 실행 **backdoors**나 인증 backdoors(앱에 하드코딩된 admin credentials)도 찾아보세요.

**Firebase**

**firebase URLs**에 특히 주의하고 잘못 구성되어 있는지 확인하세요. [Firebase가 무엇이고 이를 어떻게 악용하는지에 대한 자세한 정보는 여기를 참조하세요.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 애플리케이션 기본 이해 - Manifest.xml, strings.xml

애플리케이션의 _Manifest.xml_ 및 **_strings.xml_** 파일을 조사하면 잠재적 보안 취약점을 발견할 수 있습니다. 이러한 파일들은 디컴파일러를 사용하거나 APK 파일 확장자를 .zip으로 변경한 후 압축을 풀어 접근할 수 있습니다.

Manifest.xml에서 식별되는 취약점에는 다음이 포함됩니다:

- **Debuggable Applications**: _Manifest.xml_ 파일에 `debuggable="true"`로 설정된 애플리케이션은 연결을 허용하여 악용될 수 있으므로 위험합니다. debuggable 애플리케이션을 찾고 악용하는 방법에 대해서는 관련 튜토리얼을 참조하세요.
- **Backup Settings**: 민감한 정보를 다루는 애플리케이션의 경우 `android:allowBackup="false"` 속성을 명시적으로 설정하여 usb debugging이 활성화된 경우 adb를 통한 무단 데이터 백업을 방지해야 합니다.
- **Network Security**: _res/xml/_의 사용자 정의 네트워크 보안 설정(`android:networkSecurityConfig="@xml/network_security_config"`)은 certificate pinning이나 HTTP 트래픽 설정과 같은 보안 세부사항을 지정할 수 있습니다. 예로 특정 도메인에 대해 HTTP 트래픽을 허용하는 설정이 있습니다.
- **Exported Activities and Services**: 매니페스트에서 exported된 activity 및 service를 식별하면 오용될 수 있는 컴포넌트를 파악할 수 있습니다. 동적 테스트 중 추가 분석을 통해 이러한 컴포넌트를 악용하는 방법을 밝힐 수 있습니다.
- **Content Providers and FileProviders**: 노출된 content provider는 무단 접근이나 데이터 변경을 허용할 수 있습니다. FileProviders의 구성도 면밀히 검토해야 합니다.
- **Broadcast Receivers and URL Schemes**: 이러한 컴포넌트는 악용에 사용될 수 있으며, 특히 URL 스킴이 입력 취약성에 대해 어떻게 관리되는지 주의해야 합니다.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, 및 `maxSdkVersion` 속성은 지원되는 Android 버전을 나타내며, 보안상의 이유로 오래된 취약한 Android 버전을 지원하지 않는 것이 중요함을 보여줍니다.

**strings.xml** 파일에서는 API keys, custom schemas 및 기타 개발자 메모와 같은 민감한 정보가 발견될 수 있으므로 이러한 리소스를 주의 깊게 검토해야 합니다.

### Tapjacking

Tapjacking은 악성 애플리케이션이 실행되어 피해자 애플리케이션 위에 자신을 배치하는 공격입니다. 일단 피해자 앱을 시각적으로 가리면, 악성 앱의 UI는 사용자가 그것과 상호작용하도록 속이도록 설계되며, 동시에 그 상호작용을 피해자 앱으로 전달합니다. 결과적으로 사용자는 실제로 피해자 앱에서 동작을 수행하고 있다는 사실을 알지 못하게 됩니다.

자세한 정보는 다음을 참조하세요:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode`가 `singleTask`로 설정되어 있고 `taskAffinity`가 정의되어 있지 않은 activity는 task Hijacking에 취약합니다. 즉, 악성 application을 설치하고 실제 application보다 먼저 실행하면 실제 애플리케이션의 task를 가로챌 수 있으므로(사용자는 실제 애플리케이션을 사용한다고 생각하면서 악성 application과 상호작용하게 됩니다).

추가 정보:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### 불안정한 데이터 저장

Internal Storage

Android에서 internal storage에 저장된 파일은 이를 생성한 app만 접근하도록 설계되어 있습니다. 이 보안 조치는 Android 운영체제에 의해 강제되며 대부분의 애플리케이션 보안 요구에 대해 일반적으로 충분합니다. 그러나 개발자가 `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`과 같은 모드를 사용하여 파일을 서로 다른 애플리케이션 간에 공유하도록 허용하는 경우가 있습니다. 이러한 모드는 잠재적으로 악성 앱을 포함한 다른 애플리케이션의 파일 접근을 제한하지 않습니다.

1. **정적 분석:**
- `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`의 사용을 **면밀히 검토**하세요. 이러한 모드는 파일을 의도하지 않거나 무단 접근에 **노출시킬 수 있습니다**.
2. **동적 분석:**
- 앱이 생성한 파일에 설정된 **permissions**를 **확인**하세요. 특히 어떤 파일이 전역적으로 읽기 또는 쓰기가 가능하도록 설정되어 있는지 **확인**해야 합니다. 이는 장치에 설치된 **어떤 application**이라도 출처나 의도와 상관없이 해당 파일을 읽거나 수정할 수 있게 하여 심각한 보안 위험을 초래할 수 있습니다.

External Storage

SD 카드와 같은 **external storage**의 파일을 다룰 때는 다음과 같은 주의사항이 필요합니다:

1. 접근성:
- 외부 저장소의 파일은 **전역적으로 읽기 및 쓰기 가능**합니다. 즉, 어떤 application이나 사용자도 이 파일들에 접근할 수 있습니다.
2. 보안 문제:
- 접근이 용이하기 때문에 **민감한 정보를 외부 저장소에 저장하지 않는 것**을 권장합니다.
- 외부 저장소는 제거될 수 있고 어떤 application도 접근할 수 있어 덜 안전합니다.
3. 외부 저장소에서 가져온 데이터 처리:
- 외부 저장소에서 가져온 데이터에 대해 항상 **입력 검증(input validation)**을 수행하세요. 이는 해당 데이터가 신뢰할 수 없는 출처에서 온 것이기 때문에 매우 중요합니다.
- 외부 저장소에 실행 파일이나 class 파일을 두고 동적으로 로드하는 것은 강력히 권장되지 않습니다.
- 애플리케이션이 외부 저장소에서 실행 파일을 가져와야 하는 경우, 이러한 파일이 동적으로 로드되기 전에 **서명되고 암호학적으로 검증**되었는지 확인하세요. 이 단계는 애플리케이션의 보안 무결성을 유지하는 데 필수적입니다.

외부 저장소는 `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard`에서 접근할 수 있습니다.

> [!TIP]
> Android 4.4(**API 17**)부터 SD 카드는 앱별 디렉터리로의 접근을 제한하는 디렉터리 구조를 가지게 됩니다. 이는 악성 application이 다른 앱의 파일에 대한 읽기 또는 쓰기 접근을 획득하는 것을 방지합니다.

**암호화되지 않은(평문)으로 저장된 민감한 데이터**

- **Shared preferences**: Android는 각 애플리케이션이 `/data/data/<packagename>/shared_prefs/` 경로에 xml 파일을 쉽게 저장할 수 있도록 허용하며, 때때로 해당 폴더에서 평문으로 된 민감한 정보를 찾을 수 있습니다.
- **Databases**: Android는 각 애플리케이션이 `/data/data/<packagename>/databases/` 경로에 sqlite 데이터베이스를 쉽게 저장할 수 있도록 허용하며, 때때로 해당 폴더에서 평문으로 된 민감한 정보를 찾을 수 있습니다.

### Broken TLS

**Accept All Certificates**

어떤 이유로 개발자들이 호스트명이 일치하지 않더라도 모든 인증서를 수락하는 경우가 있습니다. 예를 들어 다음과 같은 코드 라인으로:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 취약한 암호화

**열악한 키 관리 프로세스**

일부 개발자는 민감한 데이터를 로컬 스토리지에 저장하고 코드에 하드코딩되었거나 예측 가능한 키로 암호화합니다. 이는 리버스엔지니어링(reversing)으로 공격자가 기밀 정보를 추출할 수 있으므로 해서는 안 됩니다.

**안전하지 않거나/또는 더 이상 사용되지 않는 알고리즘의 사용**

개발자는 권한 검사(authorisation checks), 데이터 저장(store) 또는 전송(send)에 **deprecated algorithms**를 사용해서는 안 됩니다. 이런 알고리즘에는 RC4, MD4, MD5, SHA1 등이 있습니다. 예를 들어 비밀번호 저장에 **hashes**를 사용한다면, salt와 함께 브루트포스에 강한 해시 알고리즘을 사용해야 합니다.

### 기타 점검사항

- 공격자의 리버스 엔지니어링 작업을 어렵게 하기 위해 **obfuscate the APK** 하는 것이 권장됩니다.
- 앱이 민감한 성격(예: 은행 앱)이라면 모바일이 루팅되었는지에 대해 자체적으로 검사하고 그에 따라 동작해야 합니다.
- 앱이 민감한 성격(예: 은행 앱)이라면 **emulator** 사용 여부를 검사해야 합니다.
- 앱이 민감한 성격(예: 은행 앱)이라면 실행하기 전에 **자기 무결성(self integrity)** 을 검사하여 수정되었는지 확인해야 합니다.
- 어떤 컴파일러/패커/난독화 도구로 APK가 빌드되었는지 확인하려면 [**APKiD**](https://github.com/rednaga/APKiD)를 사용하세요

### React Native Application

다음 페이지를 읽어 React 애플리케이션의 JavaScript 코드를 쉽게 접근하는 방법을 확인하세요:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

다음 페이지를 읽어 Xamarin 애플리케이션의 C# 코드에 쉽게 접근하는 방법을 확인하세요:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

이 [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)에 따르면 superpacked는 애플리케이션의 콘텐츠를 하나의 파일로 압축하는 Meta 알고리즘입니다. 블로그는 이러한 종류의 앱을 압축 해제하는 앱을 만드는 가능성에 대해 이야기하고 있으며... 더 빠른 방법으로는 **애플리케이션을 실행하고 파일시스템에서 압축 해제된 파일을 수집(execute the application and gather the decompressed files from the filesystem.)**하는 방법이 있습니다.

### Automated Static Code Analysis

도구 [**mariana-trench**](https://github.com/facebook/mariana-trench)는 애플리케이션의 **코드**를 **스캔**하여 **취약점(vulnerabilities)** 을 찾을 수 있습니다. 이 도구는 **known sources**(도구에 **입력(input)** 이 **사용자에 의해 제어되는 위치**를 알려주는 것), **sinks**(악의적 사용자 입력이 피해를 줄 수 있는 **위험한 위치**) 및 **rules**의 집합을 포함합니다. 이 규칙들은 취약점을 나타내는 **sources-sinks**의 **조합**을 지시합니다.

이 지식을 바탕으로 **mariana-trench는 코드를 검토하여 가능한 취약점을 찾아냅니다.**

### Secrets leaked

애플리케이션에는 API 키, 비밀번호, 숨겨진 URL, 서브도메인 등과 같은 비밀이 포함되어 있을 수 있으며 이를 발견할 수 있습니다. 예를 들어 [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) 같은 도구를 사용할 수 있습니다.

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### 기타 흥미로운 기능

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## 동적 분석

> 우선, 애플리케이션과 관련 환경(Burp CA cert, Drozer 및 Frida 등)을 설치할 수 있는 환경이 필요합니다. 따라서 루팅된 디바이스(에뮬레이터든 아니든)가 강력히 권장됩니다.

### 온라인 동적 분석

다음에서 **무료 계정**을 생성할 수 있습니다: [https://appetize.io/](https://appetize.io/). 이 플랫폼은 APK를 **업로드**하고 **실행**할 수 있게 해주므로 APK가 어떻게 동작하는지 확인하는 데 유용합니다.

웹에서 애플리케이션의 로그를 확인하고 **adb**를 통해 연결할 수도 있습니다.

![](<../../images/image (831).png>)

ADB 연결 덕분에 에뮬레이터 안에서 **Drozer**와 **Frida**를 사용할 수 있습니다.

### 로컬 동적 분석

#### 에뮬레이터 사용

- [**Android Studio**](https://developer.android.com/studio) (x86 및 arm 디바이스를 생성할 수 있으며, [**이 글**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)에 따르면 최신 x86 버전은 느린 ARM 에뮬레이터 없이도 ARM 라이브러리를 지원합니다).
- 설정 방법은 다음 페이지에서 확인하세요:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(무료 버전:** Personal Edition, 계정 생성 필요. _가능한 오류를 피하려면 VirtualBox가 포함된 버전을 **WITH** 다운로드하는 것이 권장됩니다._)
- [**Nox**](https://es.bignox.com) (무료지만 Frida나 Drozer는 지원하지 않습니다).

> [!TIP]
> 새 에뮬레이터를 만들 때 화면이 클수록 에뮬레이터가 더 느려집니다. 가능하면 작은 화면을 선택하세요.

Genymotion에 **google services**(예: AppStore)를 설치하려면 다음 이미지에서 빨간 표시된 버튼을 클릭해야 합니다:

![](<../../images/image (277).png>)

또한 **Genymotion의 Android VM 구성(configuration of the Android VM in Genymotion)**에서 **Bridge Network mode**를 선택할 수 있음을 확인하세요(다른 VM에서 도구로 Android VM에 연결할 경우 유용합니다).

#### 물리적 디바이스 사용

**debugging** 옵션을 활성화해야 하며 루팅(root)하면 더 좋습니다:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> 애플리케이션을 설치한 후 가장 먼저 해야 할 일은 앱을 직접 실행해 무엇을 하는지, 어떻게 동작하는지 조사하여 익숙해지는 것입니다.\
> 저는 MobSF dynamic analysis + pidcat을 사용한 초기 동적 분석을 수행할 것을 제안합니다. 이렇게 하면 애플리케이션이 어떻게 동작하는지 배우는 동시에 MobSF가 나중에 검토할 수 있는 많은 흥미로운 데이터를 캡처합니다.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### 의도치 않은 데이터 leak

**로깅**

개발자는 **디버깅 정보(debugging information)** 를 공개적으로 노출하지 않도록 주의해야 합니다. 이는 민감한 데이터가 leak될 수 있기 때문입니다. 애플리케이션 로그를 모니터링하여 민감한 정보를 식별하고 보호하기 위해 [**pidcat**](https://github.com/JakeWharton/pidcat) 및 `adb logcat` 도구를 권장합니다. **Pidcat**은 사용 편의성과 가독성 때문에 선호됩니다.

> [!WARNING]
> Android 4.0 이후 버전부터 **애플리케이션은 자신의 로그만 접근할 수 있습니다**. 따라서 앱은 다른 앱의 로그를 접근할 수 없습니다.\
> 그럼에도 불구하고 민감한 정보를 로그에 남기지 않는 것이 권장됩니다.

**복사/붙여넣기 버퍼 캐싱**

Android의 **클립보드 기반** 프레임워크는 앱 간 복사-붙여넣기 기능을 제공하지만 **다른 애플리케이션**이 클립보드에 접근할 수 있어 민감한 데이터가 노출될 위험이 있습니다. 신용카드 정보 같은 민감한 섹션에 대해서는 복사/붙여넣기 기능을 비활성화하는 것이 중요합니다.

**크래시 로그**

애플리케이션이 **크래시**하고 로그를 저장하면, 해당 로그는 특히 애플리케이션을 리버스엔지니어링할 수 없는 경우 공격자에게 도움이 될 수 있습니다. 이를 완화하려면 크래시 시 로그를 남기지 말고, 로그를 네트워크로 전송해야 한다면 반드시 SSL 채널을 통해 전송하세요.

펜테스터(pentester)로서 **이 로그들을 확인해 보세요**.

**제3자에게 전송되는 분석 데이터**

애플리케이션은 종종 Google Adsense와 같은 서비스를 통합하며, 개발자의 잘못된 구현으로 인해 민감한 데이터가 의도치 않게 leak될 수 있습니다. 데이터 유출 가능성을 식별하려면 애플리케이션의 트래픽을 가로채어 제3자에게 전송되는 민감한 정보가 있는지 확인하는 것이 좋습니다.

### SQLite DBs

대부분의 애플리케이션은 정보를 저장하기 위해 **내부 SQLite 데이터베이스**를 사용합니다. 펜테스트 중에는 생성된 **데이터베이스**, **테이블** 및 **컬럼** 이름과 저장된 모든 **데이터**를 확인하세요. 민감한 정보를 발견할 수 있으며 이는 취약점이 됩니다.\
데이터베이스는 `/data/data/the.package.name/databases`에 위치해야 하며 예시는 `/data/data/com.mwr.example.sieve/databases` 입니다.

데이터베이스가 기밀 정보를 저장하고 있고 **암호화되어(encrypted)** 있더라도 애플리케이션 내에서 **암호(password)** 를 찾을 수 있다면 여전히 **취약점**입니다.

`.tables`로 테이블을 열거하고 `.schema <table_name>`으로 테이블의 컬럼을 확인하세요.

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer**를 사용하면 **Android 앱의 역할을 맡아** 다른 앱과 상호작용할 수 있습니다. 설치된 애플리케이션이 할 수 있는 모든 작업—Android의 Inter-Process Communication(IPC) 메커니즘을 이용하거나 기본 운영체제와 상호작용하는 것—을 수행할 수 있습니다. .\
Drozer는 **exported activities, exported services 및 Content Providers**를 **익스플로잇**하는 데 유용한 도구입니다. 다음 섹션에서 이를 배우게 될 것입니다.

### Exported Activities 익스플로잇

[**Android Activity가 무엇인지 복습하고 싶다면 이것을 읽으세요.**](android-applications-basics.md#launcher-activity-and-other-activities)\
또한 액티비티의 코드는 **`onCreate`** 메서드에서 시작된다는 것을 기억하세요.

**권한/인증 우회(Authorisation bypass)**

Activity가 exported되어 있으면 외부 앱에서 그 화면을 호출할 수 있습니다. 따라서 **민감한 정보를 포함한 액티비티가 exported되어 있다면**, 인증 메커니즘을 **bypass**하여 접근할 수 있습니다.

[**Drozer로 exported activities를 익스플로잇하는 방법을 배우세요.**](drozer-tutorial/index.html#activities)

다음과 같이 adb에서 exported activity를 시작할 수도 있습니다:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**참고**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Note that an authorisation bypass is not always a vulnerability, it would depend on how the bypass works and which information is exposed.

**Sensitive information leakage**

**액티비티는 결과를 반환할 수도 있습니다**. export되어 있고 보호되지 않은 액티비티가 **`setResult`** 메서드를 호출하며 **민감한 정보를 반환**한다면, sensitive information leakage가 발생합니다.

#### Tapjacking

Tapjacking이 방지되지 않는다면, export된 액티비티를 악용하여 **사용자가 예상치 못한 동작을 수행하도록** 만들 수 있습니다. 자세한 내용은 [**what is Tapjacking follow the link**](#tapjacking)를 참조하세요.

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers는 기본적으로 **데이터 공유**에 사용됩니다. 앱에 사용 가능한 content providers가 있다면 그들로부터 **민감한 데이터를 추출**할 수 있을지도 모릅니다. 또한 **SQL injections** 및 **Path Traversals** 가능성을 테스트해보는 것도 흥미로운데, 취약할 수 있기 때문입니다.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Service의 동작은 `onStartCommand` 메서드에서 시작한다는 것을 기억하세요.

Service는 기본적으로 데이터를 **수신**하고 이를 **처리**하며 (응답을) **반환**(또는 반환하지 않음)할 수 있는 구성요소입니다. 따라서 애플리케이션이 일부 서비스를 export하고 있다면 해당 서비스가 무엇을 하는지 이해하기 위해 **코드**를 **확인**하고 기밀 정보를 추출하거나 인증 우회 등을 위해 **동적**으로 **테스트**해야 합니다.\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Broadcast Receiver의 동작은 `onReceive` 메서드에서 시작한다는 것을 기억하세요.

브로드캐스트 리시버는 특정 유형의 메시지를 기다립니다. 리시버가 메시지를 처리하는 방식에 따라 취약해질 수 있습니다.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

딥링크를 수동으로 찾을 수도 있고, MobSF 같은 도구나 [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) 같은 스크립트를 사용할 수도 있습니다.\
선언된 scheme은 adb 또는 브라우저로 열 수 있습니다:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_참고로 **패키지 이름을 생략할 수 있으며** 모바일이 해당 링크를 열 앱을 자동으로 호출합니다._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**앱에서 실행될 코드**

앱에서 **실행될 코드**를 찾으려면 deeplink에 의해 호출되는 activity로 이동하여 함수 **`onNewIntent`**를 검색하세요.

![](<../../images/image (436) (1) (1) (1).png>)

**민감한 정보**

deep link를 찾을 때마다 해당 deep link가 **URL 매개변수를 통해 민감한 데이터(예: 비밀번호)를 받지 않는지** 확인하세요. 다른 어떤 애플리케이션도 **deep link를 사칭하여 그 데이터를 훔칠 수 있습니다!**

**경로 파라미터**

You **must check also if any deep link is using a parameter inside the path** of the URL like: `https://api.example.com/v1/users/{username}` , in that case you can force a path traversal accessing something like: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note that if you find the correct endpoints inside the application you may be able to cause a **Open Redirect** (if part of the path is used as domain name), **account takeover** (if you can modify users details without CSRF token and the vuln endpoint used the correct method) and any other vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**추가 예시**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### 전송 계층 검사 및 검증 실패

- **인증서가 항상 제대로 검사되는 것은 아니다** Android 애플리케이션에서는 경고를 무시하고 자체 서명 인증서를 수락하거나, 경우에 따라 HTTP 연결로 되돌아가는 일이 흔합니다.
- **SSL/TLS 핸드셰이크 동안의 협상이 때때로 약하다**, 취약한 암호 모음을 사용합니다. 이 취약점은 MITM(man-in-the-middle) 공격에 노출되어 공격자가 데이터를 복호화할 수 있게 만듭니다.
- **Leakage of private information**는 애플리케이션이 보안 채널로 인증을 수행한 뒤 다른 트랜잭션에서 비보안 채널로 통신할 때 위험합니다. 이러한 접근 방식은 세션 쿠키나 사용자 정보와 같은 민감한 데이터를 악의적인 주체가 가로챌 수 있도록 합니다.

#### 인증서 검증

우리는 **인증서 검증**에 중점을 둡니다. 보안을 강화하려면 서버 인증서의 무결성을 검증해야 합니다. 이는 불안전한 TLS 구성과 암호화되지 않은 채널을 통한 민감한 데이터 전송이 심각한 위험을 초래할 수 있기 때문에 매우 중요합니다. 서버 인증서를 검증하고 취약점을 해결하는 자세한 단계는 [**this resource**](https://manifestsecurity.com/android-application-security-part-10/)에서 포괄적으로 안내합니다.

#### SSL Pinning

SSL Pinning은 애플리케이션이 서버의 인증서를 애플리케이션 내부에 저장된 알려진 사본과 대조하여 검증하는 보안 수단입니다. 이 방법은 MITM 공격을 방지하는 데 필수적입니다. 민감한 정보를 다루는 애플리케이션에는 SSL Pinning 구현을 강력히 권장합니다.

#### 트래픽 검사

HTTP 트래픽을 검사하려면 프록시 도구의 인증서(예: Burp)를 **설치해야** 합니다. 이 인증서를 설치하지 않으면 암호화된 트래픽이 프록시를 통해 보이지 않을 수 있습니다. 커스텀 CA 인증서 설치 가이드는 [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)를 참조하세요.

**API Level 24 and above**를 타깃으로 하는 애플리케이션은 프록시의 CA 인증서를 수락하도록 Network Security Config를 수정해야 합니다. 이 단계는 암호화된 트래픽을 검사하는 데 중요합니다. Network Security Config 수정 방법은 [**refer to this tutorial**](make-apk-accept-ca-certificate.md)를 참조하세요.

If **Flutter**가 사용되는 경우 [**this page**](flutter.md)의 지침을 따라야 합니다. 단순히 인증서를 스토어에 추가하는 것만으로는 작동하지 않으며, Flutter는 자체적인 유효 CA 목록을 가지고 있기 때문입니다.

#### SSL/TLS pinning의 정적 탐지

런타임 우회 시도를 하기 전에 APK에서 pinning이 적용된 위치를 빠르게 매핑하세요. 정적 탐지는 훅/패치 계획을 세우고 올바른 코드 경로에 집중하는 데 도움이 됩니다.

Tool: SSLPinDetect
- 오픈소스 정적 분석 유틸리티로 APK를 Smali( via apktool )로 디컴파일하고 SSL/TLS pinning 구현에 대한 선별된 정규식 패턴을 스캔합니다.
- 각 일치 항목에 대해 정확한 파일 경로, 라인 번호 및 코드 스니펫을 보고합니다.
- 일반적인 프레임워크 및 커스텀 코드 경로를 포괄합니다: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

설치
- 필수 요건: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
사용법
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
예시 패턴 규칙 (JSON)
signatures를 사용하거나 확장하여 독점/커스텀 pinning 스타일을 탐지하세요. 자신의 JSON을 불러와 대규모로 스캔할 수 있습니다.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- 대형 앱을 빠르게 스캔하려면 멀티스레딩과 메모리 매핑 I/O를 사용하세요; 사전 컴파일된 regex는 오버헤드와 false positives를 줄여줍니다.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 다음으로 분류할 일반적인 탐지 대상:
- OkHttp: CertificatePinner 사용, setCertificatePinner, okhttp3/okhttp 패키지 참조
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted 오버라이드
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init 와 커스텀 매니저
- Declarative pins in res/xml network security config 및 manifest 참조
- 일치한 위치를 활용해 Frida hooks, static 패치 또는 설정 검토를 계획한 뒤 동적 테스트를 진행하세요.



#### SSL Pinning 우회

SSL Pinning이 구현된 경우 HTTPS 트래픽을 검사하기 위해 이를 우회해야 합니다. 이를 위한 다양한 방법이 있습니다:

- 자동으로 [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)을 사용해 **apk**를 **수정**하여 **SSLPinning**을 **우회**할 수 있습니다. 이 방법의 가장 큰 장점은 SSL Pinning을 우회하기 위해 root가 필요 없다는 점이지만, 애플리케이션을 삭제하고 새로 설치해야 하며 항상 동작하지는 않습니다.
- 아래에서 설명하는 **Frida**를 사용해 이 보호를 우회할 수 있습니다. Burp+Frida+Genymotion을 사용하는 가이드는 다음을 참고하세요: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- **자동으로 SSL Pinning을 우회**하려면 [**objection**](frida-tutorial/objection-tutorial.md)**:** 를 사용해 보세요: `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **자동으로 SSL Pinning을 우회**하려면 **MobSF dynamic analysis**(아래 설명 참조)를 시도할 수도 있습니다.
- 여전히 캡처하지 못하는 트래픽이 있다고 생각되면 **iptables를 사용해 트래픽을 Burp로 포워딩**해 보세요. 블로그를 읽어보세요: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 일반적인 Web 취약점 찾기

애플리케이션 내에서 흔히 발생하는 Web 취약점도 반드시 검색해야 합니다. 이러한 취약점을 식별하고 완화하는 방법에 대한 자세한 내용은 이 요약의 범위를 벗어나지만 다른 곳에 광범위하게 설명되어 있습니다.

### Frida

[Frida](https://www.frida.re) 는 개발자, 리버스 엔지니어, 보안 연구원을 위한 dynamic instrumentation toolkit입니다.\
**실행 중인 애플리케이션에 접근해 런타임에 메서드를 hook하여 동작을 변경하거나 값 변경/추출, 다른 코드를 실행할 수 있습니다.**\
Android 애플리케이션을 pentest하려면 Frida 사용법을 알아야 합니다.

- Frida 사용법 배우기: [**Frida tutorial**](frida-tutorial/index.html)
- Frida 작업용 일부 "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection은 Frida 사용 자동화에 유용합니다: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- 몇 가지 Frida 스크립트 모음은 여기에서 찾을 수 있습니다: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace)에 설명된 대로 Frida를 로드해 anti-debugging / anti-frida 메커니즘을 우회해 보세요 (도구 [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **메모리 덤프 - Fridump**

애플리케이션이 비밀번호나 니모닉 같은 저장해서는 안 되는 민감한 정보를 메모리에 저장하고 있는지 확인하세요.

[**Fridump3**](https://github.com/rootbsd/fridump3)를 사용하면 앱의 메모리를 다음과 같이 덤프할 수 있습니다:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
이것은 ./dump 폴더에 메모리를 덤프하며, 그 안에서 다음과 같이 grep할 수 있습니다:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore의 민감한 데이터**

Android에서 Keystore는 민감한 데이터를 저장하기에 가장 좋은 장소입니다. 그러나 충분한 권한이 있으면 여전히 **접근할 수 있습니다**. 애플리케이션은 여기서 **평문으로 민감한 데이터를** 저장하는 경향이 있으므로, pentests는 root user로 검사를 수행해야 하며 장치에 물리적으로 접근할 수 있는 사람이 이 데이터를 훔칠 수 있습니다.

앱이 keystore에 데이터를 저장하더라도, 해당 데이터는 암호화되어야 합니다.

keystore 내부의 데이터에 접근하려면 다음 Frida script를 사용할 수 있습니다: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

다음 Frida 스크립트를 사용하면 Android 애플리케이션이 특정 민감한 영역을 보호하기 위해 수행하는 **bypass fingerprint authentication**을 우회할 수 있습니다:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **백그라운드 이미지**

애플리케이션을 백그라운드로 보낼 때, Android는 **애플리케이션의 스냅샷**을 저장합니다. 포그라운드로 복원될 때 앱 자체가 로드되기 전에 이미지를 먼저 불러와 앱이 더 빨리 로드된 것처럼 보이게 합니다.

하지만 이 스냅샷에 **민감한 정보**가 포함되어 있다면, 스냅샷에 접근할 수 있는 사람이 해당 정보를 **탈취할 수 있습니다** (접근하려면 root가 필요하다는 점에 유의하세요).

스냅샷은 보통 다음 경로에 저장됩니다: **`/data/system_ce/0/snapshots`**

Android는 **FLAG_SECURE 레이아웃 파라미터를 설정하여 스크린샷 캡처를 방지**하는 방법을 제공합니다. 이 플래그를 사용하면 윈도우의 내용이 보안 처리되어 스크린샷에 나타나거나 비보안 디스플레이에서 표시되는 것을 방지합니다.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

이 도구는 dynamic analysis 중 여러 도구를 관리하는 데 도움이 됩니다: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

개발자들은 종종 Intent를 처리하고 `startActivity(...)`나 `sendBroadcast(...)` 같은 메서드로 전달하는 proxy 컴포넌트(액티비티, 서비스, 브로드캐스트 리시버 등)를 만듭니다. 이는 위험할 수 있습니다.

공격자가 이러한 Intent를 잘못 유도하여 non-exported 앱 컴포넌트를 호출하거나 민감한 content providers에 접근할 수 있게 되는 것이 위험의 핵심입니다. 예를 들어 `WebView`가 URL을 `Intent` 객체로 변환하기 위해 `Intent.parseUri(...)`를 사용하고 이를 실행하면, 악의적인 Intent injection이 발생할 수 있습니다.

### Essential Takeaways

- **Intent Injection**은 웹의 Open Redirect 문제와 유사합니다.
- 공격은 `Intent` 객체를 extras로 전달해 리디렉션시켜 안전하지 않은 동작을 실행하게 만드는 방식으로 이뤄집니다.
- non-exported 컴포넌트와 content providers를 공격자에게 노출시킬 수 있습니다.
- `WebView`의 URL → `Intent` 변환은 의도치 않은 동작을 촉발할 수 있습니다.

### Android Client Side Injections and others

아마 웹에서 이런 종류의 취약점을 접해보셨을 겁니다. Android 애플리케이션에서는 특히 다음 취약점들에 주의해야 합니다:

- **SQL Injection:** dynamic 쿼리나 Content-Providers를 다룰 때는 parameterized queries를 사용했는지 확인하세요.
- **JavaScript Injection (XSS):** 모든 WebViews에 대해 JavaScript 및 Plugin 지원이 비활성화되어 있는지 확인하세요(기본적으로 비활성). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews가 파일 시스템에 접근하지 못하도록 해야 합니다(기본적으로 허용됨) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 많은 경우 Android 애플리케이션에서 세션을 종료해도 쿠키가 취소되지 않거나 디스크에 저장될 수 있습니다.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application**을 웹 기반 프런트엔드로 보기 좋게 수행합니다. dynamic analysis도 수행할 수 있으나 환경을 미리 준비해야 합니다.
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### MobSF를 이용한 보조 동적 분석

**MobSF**는 Android의 **dynamic analysis**에 매우 유용할 수 있지만, 이 경우 호스트에 MobSF와 **genymotion**을 설치해야 합니다 (VM이나 Docker에서는 동작하지 않습니다). _참고: 먼저 genymotion에서 **VM을 시작**한 다음 **MobSF를 시작**해야 합니다._\
**MobSF dynamic analyser**는 다음을 수행할 수 있습니다:

- **Dump application data** (URLs, 로그, 클립보드, 사용자가 찍은 스크린샷, "**Exported Activity Tester**"가 찍은 스크린샷, 이메일, SQLite 데이터베이스, XML 파일 및 기타 생성된 파일). 이들 중 스크린샷을 제외한 모든 항목은 자동으로 수집됩니다. 스크린샷은 직접 촬영할 때만 저장되며, 모든 exported activities의 스크린샷을 얻으려면 "**Exported Activity Tester**"를 눌러야 합니다.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

android **versions > 5**부터는 **Frida를 자동으로 시작**하고 전체 **proxy** 설정을 하여 트래픽을 **capture**합니다. 테스트 대상 애플리케이션의 트래픽만 캡처합니다.

**Frida**

기본적으로 몇몇 Frida Scripts를 사용하여 **SSL pinning**, **root detection**, **debugger detection**을 우회하고 흥미로운 API를 **monitor**합니다.\
MobSF는 **invoke exported activities**를 실행하고 해당 활동들의 **screenshots**를 캡처하여 보고서에 **save**할 수도 있습니다.

동적 테스트를 **start**하려면 초록색 버튼인: "**Start Instrumentation**"을 누르세요. Frida 스크립트가 생성한 로그를 보려면 "**Frida Live Logs**"를 누르고, 훅된 메서드의 호출, 전달된 인수 및 반환 값을 보려면 "**Live API Monitor**"를 누르세요(이는 "Start Instrumentation"을 누른 후 표시됩니다).\
MobSF는 또한 사용자 정의 **Frida scripts**를 로드할 수 있습니다 (Frida scripts의 결과를 MobSF로 전송하려면 `send()` 함수를 사용하세요). 여러 **사전 작성된 스크립트**도 로드할 수 있으며 (`MobSF/DynamicAnalyzer/tools/frida_scripts/others/`에 추가 가능), 스크립트를 **선택**한 뒤 "**Load**"를 누르고 "**Start Instrumentation**"을 누르면 해당 스크립트의 로그를 "**Frida Live Logs**"에서 확인할 수 있습니다.

![](<../../images/image (419).png>)

또한 몇 가지 보조 Frida 기능이 있습니다:

- **Enumerate Loaded Classes**: 로드된 모든 클래스를 출력합니다.
- **Capture Strings**: 애플리케이션 사용 중 캡처되는 모든 문자열을 출력합니다 (매우 많은 출력).
- **Capture String Comparisons**: 매우 유용할 수 있습니다. 비교되는 두 문자열을 보여주고 결과가 True인지 False인지 표시합니다.
- **Enumerate Class Methods**: 클래스 이름(예: "java.io.File")을 입력하면 해당 클래스의 모든 메서드를 출력합니다.
- **Search Class Pattern**: 패턴으로 클래스를 검색합니다.
- **Trace Class Methods**: 클래스 전체를 **Trace**합니다 (해당 클래스의 모든 메서드 입력과 출력 확인). 기본적으로 MobSF는 여러 흥미로운 Android Api 메서드를 trace합니다.

원하는 보조 모듈을 선택한 후 "**Start Intrumentation**"을 눌러야 하며 모든 출력은 "**Frida Live Logs**"에서 확인할 수 있습니다.

**Shell**

MobSF는 동적 분석 페이지 하단에 몇 가지 **adb** 명령, **MobSF commands**, 그리고 일반적인 **shell** **commands**를 포함한 셸을 제공합니다. 일부 흥미로운 명령:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 도구**

HTTP 트래픽을 캡처하면 "**HTTP(S) Traffic**" 버튼 하단에서 캡처된 트래픽의 거친 뷰를 보거나 "**Start HTTPTools**" 녹색 버튼에서 더 보기 좋은 뷰를 볼 수 있습니다. 두 번째 옵션에서는 캡처된 요청을 Burp나 Owasp ZAP 같은 proxies로 **보낼** 수 있습니다.\
이를 위해, _Burp를 켜고 -->_ _Intercept를 끈 다음 --> MobSB HTTPTools에서 요청을 선택_ --> "**Send to Fuzzer**"를 누르고 --> _프록시 주소를 선택_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF로 동적 분석을 마치면 "**Start Web API Fuzzer**"를 눌러 http 요청을 **fuzz**하여 취약점을 찾아볼 수 있습니다.

> [!TIP]
> MobSF로 동적 분석을 수행한 후 프록시 설정이 잘못 구성되어 GUI에서 수정할 수 없게 될 수 있습니다. 프록시 설정은 다음 명령으로 수정할 수 있습니다:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

도구는 [**Inspeckage**](https://github.com/ac-pm/Inspeckage)에서 얻을 수 있습니다.\
이 도구는 몇몇 **Hooks**를 사용하여 동적 분석을 수행하는 동안 애플리케이션에서 **무슨 일이 일어나는지** 알려줍니다.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

GUI로 정적 분석을 수행하기에 **훌륭한 도구**입니다

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

이 도구는 소스 코드나 패키지된 APK에서 여러 **보안 관련 Android 애플리케이션 취약점**을 찾도록 설계되었습니다. 또한 이 도구는 발견된 일부 취약점(Exposed activities, intents, tapjacking...)을 악용하기 위한 "Proof-of-Concept" 배포 가능한 APK와 **ADB commands**를 생성할 수 있습니다. Drozer와 마찬가지로 테스트 디바이스를 루팅할 필요가 없습니다.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 참조하기 쉽도록 추출된 모든 파일을 표시
- APK 파일을 자동으로 Java 및 Smali 형식으로 디컴파일
- AndroidManifest.xml을 분석하여 일반적인 취약점과 동작 식별
- 정적 소스 코드 분석을 통해 일반적인 취약점과 동작 검사
- 기기 정보
- 그 외 다양한 기능
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER는 Windows, MacOS X 및 Linux에서 사용할 수 있는 명령줄 애플리케이션으로, 취약점을 찾기 위해 _.apk_ 파일을 분석합니다. 이 프로그램은 APKs를 압축 해제하고 일련의 규칙을 적용하여 이러한 취약점을 탐지합니다.

All rules are centered in a `rules.json` file, and each company or tester could create its own rules to analyze what they need.

최신 바이너리는 [download page](https://superanalyzer.rocks/download.html)에서 다운로드하세요.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn은 모바일 애플리케이션에서 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)를 수행하는 developers, bugbounty hunters and ethical hackers를 돕는 **crossplatform** 도구입니다.

개념은 모바일 애플리케이션 파일(.apk 또는 .ipa 파일)을 StaCoAn 애플리케이션에 드래그 앤 드롭하면 시각적이고 포터블한 보고서를 생성해 준다는 것입니다. 설정과 워드리스트를 조정하여 맞춤형 경험을 얻을 수 있습니다.

다운로드[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework는 개발자나 hackers가 Android 애플리케이션에서 잠재적인 보안 취약점을 찾도록 돕는 Android 취약점 분석 시스템입니다.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**는 Android 애플리케이션이 개발한 잠재적 악성 동작을 탐지하고 사용자에게 경고하는 것을 주요 목적으로 하는 도구입니다.

탐지는 애플리케이션의 Dalvik 바이트코드를 **Smali**로 표현한 것을 [`androguard`](https://github.com/androguard/androguard) 라이브러리를 사용한 **static analysis**로 수행됩니다.

이 도구는 **"bad" 애플리케이션의 일반적인 동작**을 탐지하며, 예로 Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution 등이 있습니다...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA**는 **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework입니다. 이 도구는 일반적으로 사용되는 모바일 애플리케이션 reverse engineering 및 analysis 도구들을 모아 OWASP 모바일 보안 위협에 대해 모바일 애플리케이션을 테스트하는 것을 돕습니다. 목적은 모바일 애플리케이션 개발자와 보안 전문가들이 이 작업을 더 쉽고 친근하게 수행할 수 있도록 하는 것입니다.

다음 기능을 제공합니다:

- 다양한 도구를 사용하여 Java 및 Smali 코드를 추출합니다
- 다음을 사용하여 APK를 분석합니다: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- regexps를 사용하여 APK에서 private 정보를 추출합니다.
- Manifest를 분석합니다.
- 발견된 도메인을 다음으로 분석합니다: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) 및 [whatweb](https://github.com/urbanadventurer/WhatWeb)
- [apk-deguard.com]을 통해 APK의 deobfuscation을 수행합니다

### Koodous

malware 탐지에 유용: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

사용하는 서비스와 구성에 따라 코드를 obfuscate할 때 비밀(Secrets)이 obfuscated된 상태로 남을 수도 있고 아닐 수도 있다는 점을 유의하세요.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard**는 Java 코드를 축소(shrink), 최적화(optimize)하고 obfuscate하는 오픈 소스 명령줄 도구입니다. 바이트코드를 최적화하고 사용되지 않는 명령을 탐지 및 제거할 수 있습니다. ProGuard는 자유 소프트웨어이며 GNU General Public License, version 2 하에 배포됩니다.

ProGuard는 Android SDK의 일부로 배포되며, 애플리케이션을 release 모드로 빌드할 때 실행됩니다.

### [DexGuard](https://www.guardsquare.com/dexguard)

APK의 deobfuscate에 대한 단계별 가이드는 [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)에서 확인할 수 있습니다.

(해당 가이드에 따르면) 마지막으로 확인했을 때, Dexguard의 동작 방식은 다음과 같았습니다:

- 리소스를 InputStream으로 로드합니다;
- 결과를 FilterInputStream을 상속한 클래스에 전달하여 이를 decrypt합니다;
- 리버서의 시간을 낭비하기 위해 몇 분 정도 소모되는 쓸모없는 obfuscation을 수행합니다;
- 복호화된 결과를 ZipInputStream에 전달하여 DEX 파일을 얻습니다;
- 마지막으로 `loadDex` 메서드를 사용하여 결과 DEX를 Resource로 로드합니다.

### [DeGuard](http://apk-deguard.com)

**DeGuard는 Android obfuscation 도구가 수행한 obfuscation 과정을 역으로 수행합니다. 이를 통해 코드 검사 및 라이브러리 예측을 포함한 다양한 보안 분석이 가능해집니다.**

obfuscated APK를 해당 플랫폼에 업로드할 수 있습니다.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

이는 generic android deobfuscator입니다. Simplify는 앱을 virtually executes하여 동작을 이해한 다음, 사람이 이해하기 쉽게 동작은 동일하게 유지하면서 코드를 최적화하려고 시도합니다. 각 최적화 유형은 단순하고 일반적이므로 어떤 특정한 obfuscation 유형이 사용되었는지는 중요하지 않습니다.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD는 APK가 어떻게 만들어졌는지에 대한 정보를 제공합니다. 많은 compilers, packers, obfuscators 및 기타 이상한 요소들을 식별합니다. Android용 [_PEiD_](https://www.aldeid.com/wiki/PEiD)와 같습니다.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b는 ubuntu-mate 기반의 Android 보안 가상 머신으로, 최신 프레임워크, 튜토리얼 및 reverse engineering과 malware analysis를 위한 다양한 연구자 및 보안 애호가들의 실습 자료를 포함합니다.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 훌륭한 자료 목록입니다
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 빠른 강좌
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
