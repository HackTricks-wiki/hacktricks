# Aplicações Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Conceitos Básicos de Aplicações Android

Recomenda-se fortemente começar lendo esta página para conhecer as **partes mais importantes relacionadas à segurança Android e os componentes mais perigosos em uma aplicação Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta é a ferramenta principal que você precisa para conectar-se a um dispositivo Android (emulado ou físico).\
**ADB** permite controlar dispositivos seja por **USB** ou **Network** a partir de um computador. Esta utilidade possibilita a **cópia** de arquivos em ambas as direções, a **instalação** e **desinstalação** de apps, a **execução** de comandos shell, o **backup** de dados, a **leitura** de logs, entre outras funções.

Dê uma olhada na lista a seguir de [**ADB Commands**](adb-commands.md) para aprender como usar o adb.

## Smali

Às vezes é interessante **modificar o código da aplicação** para acessar **informações ocultas** (talvez senhas bem ofuscadas ou flags). Então, pode ser interessante descompilar o apk, modificar o código e recompilar.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Isto pode ser muito útil como uma **alternativa para vários testes durante a análise dinâmica** que serão apresentados. Então, **mantenha sempre em mente essa possibilidade**.

## Outros truques interessantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Play Integrity attestation spoofing (SafetyNet replacement)](play-integrity-attestation-bypass.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Baixar APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extrair APK do dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Mescle todos os splits e APKs base com [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Estudos de Caso & Vulnerabilidades


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Análise Estática

Antes de mais nada, para analisar um APK você deve **dar uma olhada no código Java** usando um decompiler.\
Por favor, [**leia aqui para encontrar informações sobre diferentes decompilers disponíveis**](apk-decompilers.md).

### Procurando por informação interessante

Apenas olhando as **strings** do APK você pode procurar por **senhas**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** e qualquer coisa interessante... procure até por backdoors de execução de código ou backdoors de autenticação (credenciais admin hardcoded no app).

**Firebase**

Preste atenção especial às **Firebase URLs** e verifique se estão mal configuradas. [Mais informações sobre o que é Firebase e como explorá-lo aqui.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Entendimento básico da aplicação - Manifest.xml, strings.xml

A **examinação do _Manifest.xml_ e dos arquivos **_strings.xml_** de uma aplicação pode revelar potenciais vulnerabilidades de segurança**. Esses arquivos podem ser acessados usando decompilers ou renomeando a extensão do APK para .zip e então descompactando-o.

**Vulnerabilidades** identificáveis a partir do **Manifest.xml** incluem:

- **Debuggable Applications**: Aplicações definidas como debuggable (`debuggable="true"`) no _Manifest.xml_ representam um risco pois permitem conexões que podem levar à exploração. Para entender melhor como explorar aplicações debuggable, consulte um tutorial sobre como encontrar e explorar aplicações debuggable em um dispositivo.
- **Backup Settings**: O atributo `android:allowBackup="false"` deve ser explicitamente definido para aplicações que lidam com informação sensível para prevenir backups não autorizados via adb, especialmente quando usb debugging está habilitado.
- **Network Security**: Configurações de network security customizadas (`android:networkSecurityConfig="@xml/network_security_config"`) em _res/xml/_ podem especificar detalhes de segurança como certificate pins e configurações de tráfego HTTP. Um exemplo é permitir HTTP para domínios específicos.
- **Exported Activities and Services**: Identificar activities e services exportados no manifest pode evidenciar componentes que podem ser mal utilizados. Uma análise mais aprofundada durante testes dinâmicos pode revelar como explorar esses componentes.
- **Content Providers and FileProviders**: Content providers expostos podem permitir acesso ou modificação não autorizada de dados. A configuração de FileProviders também deve ser escrutinada.
- **Broadcast Receivers and URL Schemes**: Esses componentes podem ser aproveitados para exploração, com atenção particular a como URL schemes são gerenciados quanto a vulnerabilidades de input.
- **SDK Versions**: Os atributos `minSdkVersion`, `targetSDKVersion` e `maxSdkVersion` indicam as versões Android suportadas, destacando a importância de não suportar versões antigas e vulneráveis do Android por razões de segurança.

Do arquivo **strings.xml**, informações sensíveis como API keys, schemas customizados e outras notas de desenvolvedor podem ser descobertas, reforçando a necessidade de revisão cuidadosa desses recursos.

### Tapjacking

**Tapjacking** é um ataque onde uma **malicious** **application** é iniciada e **se posiciona sobre uma aplicação vítima**. Uma vez que obscurece visivelmente o app vítima, sua interface é desenhada de forma a enganar o usuário para interagir com ela, enquanto repassa a interação para o app vítima.\
Na prática, é **cegar o usuário para que ele não saiba que está realmente executando ações no app vítima**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Uma **activity** com o **`launchMode`** definido como **`singleTask` sem qualquer `taskAffinity`** é vulnerável a Task Hijacking. Isso significa que uma **application** pode ser instalada e, se iniciada antes da aplicação real, pode **hijackear a task da aplicação real** (fazendo com que o usuário interaja com a **malicious application achando que está usando a real**).

Mais info em:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

No Android, arquivos **armazenados** em **internal** storage são **projetados** para serem **acessíveis** exclusivamente pelo **app** que os **criou**. Essa medida de segurança é **imposta** pelo sistema operacional Android e geralmente é adequada para as necessidades de segurança da maioria das aplicações. Contudo, desenvolvedores às vezes utilizam modos como `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` para **permitir** que arquivos sejam **compartilhados** entre diferentes aplicações. Porém, esses modos **não restringem o acesso** a esses arquivos por outras aplicações, incluindo potenciais maliciosas.

1. **Static Analysis:**
- **Verifique** cuidadosamente o uso de `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE`. Esses modos **podem expor potencialmente** arquivos a **acesso não intencional ou não autorizado**.
2. **Dynamic Analysis:**
- **Confirme** as **permissões** definidas nos arquivos criados pelo app. Especificamente, **verifique** se algum arquivo está **configurado como legível ou gravável mundialmente**. Isso pode representar um risco significativo de segurança, pois permitiria que **qualquer aplicação** instalada no dispositivo, independentemente de sua origem ou intenção, **leia ou modifique** esses arquivos.

**External Storage**

Ao lidar com arquivos em **external storage**, como SD Cards, certas precauções devem ser tomadas:

1. **Acessibilidade**:
- Arquivos em external storage são **globalmente legíveis e graváveis**. Isso significa que qualquer aplicação ou usuário pode acessar esses arquivos.
2. **Preocupações de Segurança**:
- Dada a facilidade de acesso, é aconselhável **não armazenar informação sensível** em external storage.
- External storage pode ser removido ou acessado por qualquer aplicação, tornando-o menos seguro.
3. **Tratando Dados vindos de External Storage**:
- Sempre **faça validação de input** nos dados recuperados de external storage. Isso é crucial porque os dados vêm de uma fonte não confiável.
- Armazenar executáveis ou arquivos .class em external storage para carregamento dinâmico é fortemente desaconselhado.
- Se sua aplicação precisa recuperar arquivos executáveis de external storage, assegure que esses arquivos estejam **assinados e verificados criptograficamente** antes de serem carregados dinamicamente. Esse passo é vital para manter a integridade de segurança da sua aplicação.

External storage pode ser **acessado** em `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Dados sensíveis armazenados em texto claro**

- **Shared preferences**: Android permite que cada aplicação salve facilmente arquivos xml no caminho `/data/data/<packagename>/shared_prefs/` e às vezes é possível encontrar informação sensível em texto claro nessa pasta.
- **Databases**: Android permite que cada aplicação salve facilmente bancos sqlite no caminho `/data/data/<packagename>/databases/` e às vezes é possível encontrar informação sensível em texto claro nessa pasta.

### Broken TLS

**Accept All Certificates**

Por alguma razão, às vezes desenvolvedores aceitam todos os certificados mesmo se, por exemplo, o hostname não corresponde, com linhas de código como a seguinte:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Uma boa forma de testar isso é tentar capturar o tráfego usando um proxy como Burp sem autorizar o Burp CA dentro do dispositivo. Além disso, você pode gerar com o Burp um certificado para um hostname diferente e usá‑lo.

### Broken Cryptography

**Poor Key Management Processes**

Alguns desenvolvedores salvam dados sensíveis no armazenamento local e os criptografam com uma chave hardcoded/preditiva no código. Isso não deve ser feito, pois algum reversing poderia permitir que atacantes extraiam as informações confidenciais.

**Use of Insecure and/or Deprecated Algorithms**

Desenvolvedores não devem usar algoritmos obsoletos para realizar verificações de autorização, armazenar ou enviar dados. Alguns desses algoritmos são: RC4, MD4, MD5, SHA1... Se hashes são usados para armazenar senhas, por exemplo, devem ser usados hashes resistentes a brute-force com salt.

### Other checks

- É recomendado **obfuscar o APK** para dificultar o trabalho de reverse engineer para os atacantes.
- Se o app for sensível (como apps bancários), ele deve realizar suas **próprias verificações para ver se o mobile está rooted** e agir em consequência.
- Se o app for sensível (como apps bancários), ele deve verificar se um **emulator** está sendo usado.
- Se o app for sensível (como apps bancários), ele deve **verificar sua própria integridade antes de executar** para checar se foi modificado.
- Use [**APKiD**](https://github.com/rednaga/APKiD) para checar qual compiler/packer/obfuscator foi usado para construir o APK

### React Native Application

Leia a página a seguir para aprender como acessar facilmente o código javascript de aplicações React:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Leia a página a seguir para aprender como acessar facilmente o código C# de aplicações xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

A ferramenta [**mariana-trench**](https://github.com/facebook/mariana-trench) é capaz de encontrar **vulnerabilities** ao **scanning** do **code** da aplicação. Esta ferramenta contém uma série de **known sources** (que indica para a ferramenta os **lugares** onde o **input** é **controlado pelo usuário**), **sinks** (que indica para a ferramenta **lugares perigosos** onde input malicioso poderia causar danos) e **rules**. Essas rules indicam a **combinação** de **sources-sinks** que sinaliza uma vulnerabilidade.

Com esse conhecimento, **mariana-trench revisará o código e encontrará possíveis vulnerabilities nele**.

### Secrets leaked

Uma aplicação pode conter segredos (API keys, passwords, hidden urls, subdomains...) dentro dela que você pode conseguir descobrir. Você poderia usar uma ferramenta como [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> Primeiro de tudo, você precisa de um ambiente onde possa instalar a aplicação e todo o ambiente (Burp CA cert, Drozer and Frida principalmente). Portanto, um dispositivo rooted (emulado ou não) é fortemente recomendado.

### Online Dynamic analysis

Você pode criar uma **free account** em: [https://appetize.io/](https://appetize.io). Esta plataforma permite que você **upload** e **execute** APKs, então é útil para ver como um apk está se comportando.

Você pode até **ver os logs da sua aplicação** na web e conectar via **adb**.

![](<../../images/image (831).png>)

Graças à conexão ADB você pode usar **Drozer** e **Frida** dentro dos emuladores.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Você pode criar dispositivos **x86** e **arm**, e de acordo com [**this**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**as versões mais recentes x86** suportam **ARM libraries** sem precisar de um emulador arm lento).
- Aprenda a configurá‑lo nesta página:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versão gratuita:** Personal Edition, você precisa criar uma conta. _É recomendado **download** da versão **WITH** _**VirtualBox** para evitar erros potenciais._)
- [**Nox**](https://es.bignox.com) (Gratuito, mas não suporta Frida ou Drozer).

> [!TIP]
> Ao criar um novo emulador em qualquer plataforma, lembre‑se de que quanto maior a tela, mais lento o emulador irá rodar. Então selecione telas pequenas se possível.

Para **instalar google services** (como AppStore) no Genymotion você precisa clicar no botão marcado em vermelho da imagem a seguir:

![](<../../images/image (277).png>)

Além disso, note que na **configuração da Android VM no Genymotion** você pode selecionar **Bridge Network mode** (isso será útil se você for conectar na Android VM a partir de uma VM diferente com as ferramentas).

#### Use a physical device

Você precisa ativar as opções de **debugging** e é recomendável que você possa **root**‑á‑lo:

1. **Configurações**.
2. (A partir do Android 8.0) Selecione **Sistema**.
3. Selecione **Sobre o telefone**.
4. Pressione **Build number** 7 vezes.
5. Volte e você encontrará as **Opções de desenvolvedor**.

> Uma vez que você instalou a aplicação, a primeira coisa que deve fazer é testá‑la e investigar o que ela faz, como funciona e se familiarizar com ela.\
> Sugiro **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, assim poderemos **aprender como a aplicação funciona** enquanto o MobSF **captura** muitos dados **interessantes** que você pode revisar depois.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Desenvolvedores devem ter cuidado ao expor informações de debugging publicamente, pois isso pode levar a vazamentos de dados sensíveis. As ferramentas [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` são recomendadas para monitorar os logs da aplicação e identificar/proteger informações sensíveis. **Pidcat** é preferido pela sua facilidade de uso e legibilidade.

> [!WARNING]
> Note que a partir de versões posteriores ao Android 4.0, **aplicações só conseguem acessar seus próprios logs**. Então aplicações não conseguem acessar os logs de outras apps.\
> De qualquer forma, ainda é recomendado **não logar informações sensíveis**.

**Copy/Paste Buffer Caching**

O framework baseado em **clipboard** do Android habilita a funcionalidade de copiar/colar em apps, mas representa um risco, já que **outras aplicações** podem **acessar** o clipboard, potencialmente expondo dados sensíveis. É crucial **desabilitar funções de copiar/colar** para seções sensíveis de uma aplicação, como dados de cartão de crédito, para prevenir vazamentos.

**Crash Logs**

Se uma aplicação **crasha** e **salva logs**, esses logs podem ajudar atacantes, especialmente quando a aplicação não pode ser reverse‑engineered. Para mitigar esse risco, evite logar em crashes e, se os logs precisarem ser transmitidos pela rede, assegure que sejam enviados via um canal SSL para segurança.

Como pentester, **tente dar uma olhada nesses logs**.

**Analytics Data Sent To 3rd Parties**

Aplicações frequentemente integram serviços como Google Adsense, que podem inadvertidamente **leak sensitive data** devido a implementações incorretas pelos desenvolvedores. Para identificar potenciais vazamentos de dados, é recomendável **interceptar o tráfego da aplicação** e checar por qualquer informação sensível sendo enviada a serviços de terceiros.

### SQLite DBs

A maioria das aplicações usa **bancos de dados SQLite internos** para salvar informações. Durante o pentest, dê uma **olhada** nos **databases** criados, nos nomes das **tables** e **columns** e em todos os **dados** salvos, pois você pode encontrar **informações sensíveis** (o que seria uma vulnerabilidade).\
Os bancos de dados devem estar localizados em `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`

Se o database estiver salvando informações confidenciais e estiver **criptografado** mas você conseguir **encontrar** a **senha** dentro da aplicação, ainda assim é uma **vulnerability**.

Enumere as tables usando `.tables` e enumere as colunas das tabelas com `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is a useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Note que an authorisation bypass nem sempre é uma vulnerabilidade; depende de como o bypass funciona e quais informações são expostas.

**Vazamento de informações sensíveis**

**Activities can also return results**. Se você conseguir encontrar uma activity exportada e desprotegida que chame o método **`setResult`** e **retorne informação sensível**, há um vazamento de informações sensíveis.

#### Tapjacking

Se o tapjacking não for prevenido, você pode abusar da activity exportada para fazer o **usuário executar ações inesperadas**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers are basically used to **share data**. If an app has available content providers you may be able to **extract sensitive** data from them. It also interesting to test possible **SQL injections** and **Path Traversals** as they could be vulnerable.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Lembre-se que as ações de um Service começam no método `onStartCommand`.

As service is basically something that **can receive data**, **process** it and **returns** (or not) a response. Então, se uma aplicação está exportando alguns services, você deve **check** o **code** para entender o que ele está fazendo e **test** it **dynamically** para extrair informações confidenciais, contornar medidas de autenticação...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Lembre-se que as ações de um Broadcast Receiver começam no método `onReceive`.

Um broadcast receiver vai ficar esperando por um tipo de mensagem. Dependendo de como o receiver lida com a mensagem, ele pode ser vulnerável.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Você pode **open** um declarado **scheme** usando **adb** ou um **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Observe que você pode **omitir o nome do pacote** e o dispositivo móvel chamará automaticamente o aplicativo que deve abrir esse link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código executado**

Para encontrar o **código que será executado no App**, vá para a activity chamada pelo deep link e procure a função **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informação sensível**

Sempre que encontrar um deep link verifique se **ele não está recebendo dados sensíveis (como senhas) via parâmetros de URL**, porque qualquer outra aplicação poderia **imitar o deep link e roubar esses dados!**

**Parâmetros no path**

Você **deve também verificar se algum deep link está usando um parâmetro dentro do path** da URL como: `https://api.example.com/v1/users/{username}` , nesse caso você pode forçar um path traversal acessando algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note que se você encontrar os endpoints corretos dentro da aplicação, pode ser capaz de causar um **Open Redirect** (se parte do path for usada como nome de domínio), **account takeover** (se você puder modificar detalhes de usuários sem CSRF token e o vuln endpoint usar o método correto) e qualquer outra vuln. Mais [info sobre isso aqui](http://dphoeniixx.com/2020/12/13-2/).

**Mais exemplos**

Um [relatório de bug bounty interessante](https://hackerone.com/reports/855618) sobre links (_/.well-known/assetlinks.json_).

### Inspeção da Camada de Transporte e Falhas de Verificação

- **Certificados nem sempre são verificados corretamente** por aplicações Android. É comum que essas aplicações ignorem avisos e aceitem certificados self-signed ou, em alguns casos, revertam para conexões HTTP.
- **Negociações durante o handshake SSL/TLS às vezes são fracas**, empregando cipher suites inseguros. Essa vulnerabilidade torna a conexão suscetível a ataques man-in-the-middle (MITM), permitindo que atacantes decifrem os dados.
- **Vazamento de informações privadas** é um risco quando aplicações autenticam usando canais seguros mas depois comunicam por canais não seguros para outras transações. Essa abordagem não protege dados sensíveis, como cookies de sessão ou detalhes de usuários, contra interceptação por agentes maliciosos.

#### Verificação de Certificado

Vamos focar na **verificação de certificados**. A integridade do certificado do servidor deve ser verificada para aumentar a segurança. Isso é crucial porque configurações TLS inseguras e a transmissão de dados sensíveis por canais não criptografados podem representar riscos significativos. Para passos detalhados sobre verificação de certificados do servidor e mitigação de vulnerabilidades, [**este recurso**](https://manifestsecurity.com/android-application-security-part-10/) fornece orientação abrangente.

#### SSL Pinning

SSL Pinning é uma medida de segurança onde a aplicação verifica o certificado do servidor contra uma cópia conhecida armazenada dentro da própria aplicação. Esse método é essencial para prevenir ataques MITM. A implementação de SSL Pinning é fortemente recomendada para aplicações que lidam com informações sensíveis.

#### Inspeção de Tráfego

Para inspecionar tráfego HTTP, é necessário **instalar o certificado da ferramenta proxy** (ex.: Burp). Sem instalar esse certificado, o tráfego criptografado pode não ficar visível através do proxy. Para um guia sobre como instalar um certificado CA customizado, [**clique aqui**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplicações com target **API Level 24 and above** requerem modificações no Network Security Config para aceitar o certificado CA do proxy. Essa etapa é crítica para inspecionar tráfego criptografado. Para instruções sobre como modificar o Network Security Config, [**consulte este tutorial**](make-apk-accept-ca-certificate.md).

Se **Flutter** estiver sendo usado, você precisa seguir as instruções em [**esta página**](flutter.md). Isso porque simplesmente adicionar o certificado ao store não funcionará, já que o Flutter tem sua própria lista de CAs válidas.

#### Detecção estática de SSL/TLS pinning

Antes de tentar bypasses em runtime, mapeie rapidamente onde o pinning é aplicado no APK. A descoberta estática ajuda a planejar hooks/patches e a focar nos caminhos de código corretos.

Tool: SSLPinDetect
- Utilitário open-source de análise estática que decompila o APK para Smali (via apktool) e procura por padrões regex curados de implementações de SSL/TLS pinning.
- Reporta o caminho exato do arquivo, número da linha e um trecho de código para cada correspondência.
- Cobre frameworks comuns e caminhos de código customizados: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init com TrustManagers/KeyManagers customizados, e pins no Network Security Config XML.

Instalação
- Pré-requisitos: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemplo de regras de padrões (JSON)
Use ou estenda signatures para detectar estilos de pinning proprietários/personalizados. Você pode carregar seu próprio JSON e escanear em larga escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notas e dicas
- Varredura rápida em apps grandes via multi-threading e I/O mapeado em memória; regex pré-compiladas reduzem sobrecarga/falsos positivos.
- Coleção de padrões: https://github.com/aancw/smali-sslpin-patterns
- Alvos típicos de detecção para triagem a seguir:
- OkHttp: uso de CertificatePinner, setCertificatePinner, referências ao pacote okhttp3/okhttp
- TrustManagers personalizados: javax.net.ssl.X509TrustManager, sobrescritas de checkServerTrusted
- Contextos SSL personalizados: SSLContext.getInstance + SSLContext.init com gerenciadores personalizados
- Pins declarativos em res/xml network security config e referências no manifest
- Use os locais correspondentes para planejar Frida hooks, patches estáticos, ou revisões de configuração antes dos testes dinâmicos.



#### Bypassing SSL Pinning

Quando SSL Pinning está implementado, contorná-lo torna-se necessário para inspecionar o tráfego HTTPS. Vários métodos estão disponíveis para isso:

- Modifique automaticamente o **apk** para **contornar** o SSLPinning com [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). A principal vantagem dessa opção é que você não precisará de root para contornar o SSL Pinning, mas será necessário remover o aplicativo e reinstalar a nova versão, e isso nem sempre funciona.
- Você pode usar **Frida** (discutido abaixo) para contornar essa proteção. Aqui está um guia para usar Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Você também pode tentar **contornar automaticamente o SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Você também pode tentar **contornar automaticamente o SSL Pinning** usando **MobSF dynamic analysis** (explicado abaixo)
- Se ainda achar que há tráfego que você não está capturando, pode tentar **encaminhar o tráfego para o burp usando iptables**. Leia este blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Procurando vulnerabilidades web comuns

É importante também procurar por vulnerabilidades web comuns dentro do aplicativo. Informações detalhadas sobre identificação e mitigação dessas vulnerabilidades estão além do escopo deste resumo, mas são amplamente abordadas em outros lugares.

### Frida

[Frida](https://www.frida.re) é um toolkit de instrumentação dinâmica para desenvolvedores, analistas de engenharia reversa, e pesquisadores de segurança.\
**Você pode acessar a aplicação em execução e hook métodos em tempo de execução para mudar o comportamento, alterar valores, extrair valores, executar código diferente...**\
Se você quer pentest aplicações Android você precisa saber como usar Frida.

- Aprenda a usar o Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Algumas "GUI" para ações com Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection é ótimo para automatizar o uso do Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Você pode encontrar alguns scripts Awesome para Frida aqui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Tente contornar mecanismos anti-debugging / anti-frida carregando o Frida como indicado em [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (ferramenta [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump de memória - Fridump**

Verifique se a aplicação está armazenando informações sensíveis na memória que não deveria, como senhas ou mnemonics.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) você pode fazer dump da memória do app com:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Isso fará o dump da memória na pasta ./dump, e ali você pode usar grep com algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dados sensíveis no Keystore**

Em Android o Keystore é o melhor lugar para armazenar dados sensíveis, no entanto, com privilégios suficientes ainda é **possível acessá-lo**. Como as aplicações tendem a armazenar aqui **dados sensíveis em texto claro**, os pentests devem verificar isso, pois um usuário root ou alguém com acesso físico ao dispositivo poderia roubar esses dados.

Mesmo que um app armazene dados no Keystore, esses dados devem estar criptografados.

Para acessar os dados dentro do Keystore você pode usar este script Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando o seguinte script Frida, pode ser possível **bypass fingerprint authentication** que aplicativos Android podem estar executando para **proteger certas áreas sensíveis:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imagens de Fundo**

Quando você coloca um aplicativo em segundo plano, o Android armazena um **snapshot da aplicação** para que, quando for trazido ao primeiro plano, ele comece carregando a imagem antes do app, fazendo parecer que o app foi carregado mais rápido.

No entanto, se esse snapshot contiver **informações sensíveis**, alguém com acesso ao snapshot pode **roubar essas informações** (observe que é preciso root para acessá-lo).

Os snapshots costumam ser armazenados em: **`/data/system_ce/0/snapshots`**

O Android fornece uma forma de **impedir a captura de tela definindo o parâmetro de layout FLAG_SECURE**. Ao usar essa flag, o conteúdo da janela é tratado como seguro, evitando que apareça em capturas de tela ou seja exibido em displays não seguros.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Esta ferramenta pode ajudá-lo a gerenciar diferentes ferramentas durante a análise dinâmica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Desenvolvedores frequentemente criam proxy components like activities, services, and broadcast receivers que lidam com esses Intents e os passam para métodos como `startActivity(...)` ou `sendBroadcast(...)`, o que pode ser arriscado.

O perigo está em permitir que atacantes acionem non-exported app components ou acessem sensitive content providers ao redirecionar indevidamente esses Intents. Um exemplo notável é o componente `WebView` converter URLs em objetos `Intent` via `Intent.parseUri(...)` e então executá-los, potencialmente levando a malicious Intent injections.

### Essential Takeaways

- **Intent Injection** is similar to web's Open Redirect issue.
- Exploits envolvem passar objetos `Intent` como extras, que podem ser redirecionados para executar operações inseguras.
- Pode expor non-exported components e content providers a atacantes.
- A conversão de URL para `Intent` do `WebView` pode facilitar ações não intencionais.

### Android Client Side Injections and others

Provavelmente você conhece esse tipo de vulnerabilidades da Web. Você deve ter cuidado especial com essas vulnerabilidades em uma aplicação Android:

- **SQL Injection:** Ao lidar com consultas dinâmicas ou Content-Providers, garanta que esteja usando consultas parametrizadas.
- **JavaScript Injection (XSS):** Verifique se o suporte a JavaScript e Plugin está desabilitado para quaisquer WebViews (desabilitado por padrão). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews devem ter acesso ao sistema de arquivos desabilitado (habilitado por padrão) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Em vários casos, quando o aplicativo Android encerra a sessão, o cookie não é revogado ou pode até ser salvo no disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** usando uma agradável interface web. Você também pode realizar dynamic analysis (mas precisa preparar o ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Observe que o MobSF pode analisar **Android**(apk)**, IOS**(ipa) **e Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Além disso, se você criar um arquivo **ZIP** com o código-fonte de um app **Android** ou **IOS** (vá para a pasta raiz da aplicação, selecione tudo e crie um ZIPfile), ele também poderá analisá-lo.

MobSF também permite fazer **diff/Compare** de análises e integrar o **VirusTotal** (você precisará definir sua API key em _MobSF/settings.py_ e habilitá-la: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Você também pode definir `VT_UPLOAD` como `False`, então o **hash** será **upload** em vez do arquivo.

### Assisted Dynamic analysis with MobSF

**MobSF** também pode ser muito útil para **dynamic analysis** em **Android**, mas nesse caso você precisará instalar o MobSF e o **genymotion** no seu host (uma VM ou Docker não funcionarão). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
O **MobSF dynamic analyser** pode:

- **Dump application data** (URLs, logs, clipboard, screenshots feitos por você, screenshots feitos pelo "**Exported Activity Tester**", emails, SQLite databases, XML files, e outros arquivos criados). Tudo isso é feito automaticamente, exceto pelas screenshots — você precisa pressionar quando quiser uma screenshot ou pressionar "**Exported Activity Tester**" para obter screenshots de todas as atividades exportadas.
- Capture **HTTPS traffic**
- Use **Frida** para obter **runtime** **information**

A partir de versões do **Android** > 5, ele **automaticamente iniciará o Frida** e ajustará as configurações de **proxy** globais para **capturar** o tráfego. Ele irá capturar apenas o tráfego do aplicativo testado.

**Frida**

Por padrão, ele também usa alguns Frida Scripts para **bypass SSL pinning**, **root detection** e **debugger detection** e para **monitorar APIs interessantes**.\
MobSF também pode **invoke exported activities**, capturar **screenshots** delas e **salvá-las** para o relatório.

Para **iniciar** o teste dinâmico pressione o botão verde: "**Start Instrumentation**". Pressione "**Frida Live Logs**" para ver os logs gerados pelos Frida scripts e "**Live API Monitor**" para ver todas as invocações para métodos hookados, argumentos passados e valores retornados (isso aparecerá após pressionar "Start Instrumentation").\
MobSF também permite carregar seus próprios **Frida scripts** (para enviar os resultados dos seus Frida scripts para o MobSF use a função `send()`). Ele também tem **vários scripts pré-escritos** que você pode carregar (você pode adicionar mais em `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), basta **selecioná-los**, pressionar "**Load**" e pressionar "**Start Instrumentation**" (você poderá ver os logs desses scripts dentro de "**Frida Live Logs**").

![](<../../images/image (419).png>)

Além disso, você tem algumas funcionalidades auxiliares do Frida:

- **Enumerate Loaded Classes**: Irá imprimir todas as classes carregadas
- **Capture Strings**: Irá imprimir todas as strings capturadas enquanto usa o aplicativo (muito ruidoso)
- **Capture String Comparisons**: Pode ser muito útil. Irá **mostrar as 2 strings sendo comparadas** e se o resultado foi True ou False.
- **Enumerate Class Methods**: Informe o nome da classe (como "java.io.File") e ele imprimirá todos os métodos da classe.
- **Search Class Pattern**: Procura classes por padrão/padrão de busca
- **Trace Class Methods**: **Trace** uma **classe inteira** (veja inputs e outputs de todos os métodos da classe). Lembre-se que por padrão o MobSF traça vários métodos interessantes da Android API.

Uma vez que você selecionou o módulo auxiliar que deseja usar, você precisa pressionar "**Start Intrumentation**" e verá todas as saídas em "**Frida Live Logs**".

**Shell**

MobSF também traz um shell com alguns comandos **adb**, **MobSF commands**, e comandos comuns de **shell** na parte inferior da página de dynamic analysis. Alguns comandos interessantes:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Ferramentas HTTP**

Quando o tráfego http é capturado você pode ver uma visão feia do tráfego capturado no botão inferior "**HTTP(S) Traffic**" ou uma visão mais agradável no botão verde "**Start HTTPTools**". Pela segunda opção, você pode **enviar** as **requisições capturadas** para **proxies** como Burp ou Owasp ZAP.\
Para isso, _ligue o Burp -->_ _desative o Intercept --> no MobSB HTTPTools selecione a requisição_ --> pressione "**Send to Fuzzer**" --> _selecione o endereço do proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Depois de finalizar a análise dinâmica com MobSF você pode pressionar "**Start Web API Fuzzer**" para **fuzz http requests** e procurar por vulnerabilidades.

> [!TIP]
> Depois de executar uma análise dinâmica com MobSF as configurações de proxy podem ficar mal configuradas e você não conseguirá corrigi-las pela GUI. Você pode corrigir as configurações de proxy fazendo:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Análise Dinâmica Assistida com Inspeckage

Você pode obter a ferramenta em [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta ferramenta irá usar alguns **Hooks** para te informar **o que está acontecendo na aplicação** enquanto você realiza uma **análise dinâmica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta é uma **ótima ferramenta para realizar análise estática com uma GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta ferramenta foi projetada para buscar diversas **vulnerabilidades de segurança em aplicações Android**, tanto no **código-fonte** quanto em **APKs empacotados**. A ferramenta também é **capaz de criar um APK implantável "Proof-of-Concept"** e comandos ADB, para explorar algumas das vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Como no caso do Drozer, não é necessário fazer root no dispositivo de teste.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Exibe todos os arquivos extraídos para referência rápida
- Descompila automaticamente arquivos APK para os formatos Java e Smali
- Analisa o AndroidManifest.xml em busca de vulnerabilidades e comportamentos comuns
- Análise estática do código-fonte em busca de vulnerabilidades e comportamentos comuns
- Informações do dispositivo
- e mais
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER é uma aplicação de linha de comando que pode ser usada em Windows, MacOS X e Linux, que analisa arquivos _.apk_ em busca de vulnerabilidades. Ele faz isso descompactando APKs e aplicando uma série de regras para detectar essas vulnerabilidades.

Todas as regras estão concentradas em um arquivo `rules.json`, e cada empresa ou testador pode criar suas próprias regras para analisar o que precisar.

Faça o download dos binários mais recentes na [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn é uma ferramenta **multiplataforma** que auxilia desenvolvedores, bugbounty hunters e ethical hackers na realização de [análise estática de código](https://en.wikipedia.org/wiki/Static_program_analysis) em aplicações móveis.

O conceito é que você arraste e solte o arquivo da sua aplicação móvel (um arquivo .apk ou .ipa) na aplicação StaCoAn e ela irá gerar um relatório visual e portátil para você. Você pode ajustar as configurações e wordlists para obter uma experiência personalizada.

Baixar[ última release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework é um sistema de análise de vulnerabilidades para Android que ajuda desenvolvedores ou hackers a encontrar potenciais vulnerabilidades de segurança em aplicações Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** é uma ferramenta cujo objetivo principal é detectar e alertar o usuário sobre potenciais comportamentos maliciosos desenvolvidos por uma aplicação Android.

A detecção é realizada através da **static analysis** do Dalvik bytecode da aplicação, representado como **Smali**, usando a biblioteca [`androguard`](https://github.com/androguard/androguard).

Esta ferramenta procura por **comportamentos comuns de aplicações "maliciosas"** como: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** é um framework de engenharia reversa e análise de aplicações móveis. É uma ferramenta que reúne ferramentas comumente usadas para engenharia reversa e análise de aplicações mobile, para auxiliar nos testes de aplicações móveis contra as ameaças de segurança mobile do OWASP. Seu objetivo é tornar essa tarefa mais fácil e amigável para desenvolvedores de aplicações móveis e profissionais de segurança.

É capaz de:

- Extrair código Java e Smali usando diferentes ferramentas
- Analisar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extrair informações privadas do APK usando regexps.
- Analisar o Manifest.
- Analisar domínios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscar APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Ofuscação/Deofuscação de código

Observe que, dependendo do serviço e da configuração que você usa para ofuscar o código, segredos podem ou não acabar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** é um software de código aberto de linha de comando que reduz, otimiza e ofusca código Java. É capaz de otimizar bytecode, assim como detectar e remover instruções não usadas. ProGuard é software livre e é distribuído sob a GNU General Public License, versão 2.

ProGuard é distribuído como parte do Android SDK e é executado quando a aplicação é construída em modo release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Encontre um guia passo a passo para deobfuscar o apk em [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Da última vez que verificamos, o modo de operação do Dexguard era:

- carregar um recurso como um InputStream;
- alimentar o resultado para uma classe que herda de FilterInputStream para descriptografá-lo;
- fazer alguma obfuscação inútil para desperdiçar alguns minutos do tempo de um reverser;
- alimentar o resultado descriptografado em um ZipInputStream para obter um arquivo DEX;
- finalmente carregar o DEX resultante como um Resource usando o método `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverte o processo de ofuscação realizado por ferramentas de ofuscação Android. Isso possibilita inúmeras análises de segurança, incluindo inspeção de código e identificação de bibliotecas.**

Você pode enviar um APK ofuscado para a plataforma deles.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

É um deobfuscator android genérico. Simplify executa praticamente uma app para entender seu comportamento e então tenta otimizar o código para que se comporte de forma idêntica, mas seja mais fácil para um humano entender. Cada tipo de otimização é simples e genérico, então não importa qual tipo específico de ofuscação foi usado.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD fornece informações sobre **how an APK was made**. Identifica muitos **compilers**, **packers**, **obfuscators**, e outras coisas estranhas. É o [_PEiD_] para Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Laboratórios

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b é uma máquina virtual de segurança Android baseada em ubuntu-mate que inclui uma coleção dos frameworks, tutoriais e labs mais recentes de diferentes entusiastas e pesquisadores de segurança para reverse engineering e malware analysis.

## Referências

- [Play Integrity API: How It Works & How to Bypass It](https://m4kr0.vercel.app/posts/play-integrity-api-how-it-works--how-to-bypass-it/)
- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) É uma ótima lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
