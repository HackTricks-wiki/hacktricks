# Android Uygulamaları Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Uygulamaları Temelleri

It's highly recommended to start reading this page to know about the **most important parts related to Android security and the most dangerous components in an Android application**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Bu, emüle edilmiş veya fiziksel bir android cihaza bağlanmak için ihtiyaç duyduğunuz ana araçtır.\
**ADB**, bir bilgisayardan cihazları ya **USB** ya da **Network** üzerinden kontrol etmeye olanak sağlar. Bu yardımcı araç, dosyaların her iki yönde de **kopyalanmasını**, uygulamaların **yüklenmesini** ve **kaldırılmasını**, shell komutlarının **çalıştırılmasını**, verilerin **yedeklenmesini**, logların **okunmasını** ve diğer işlevleri mümkün kılar.

Take a look to the following list of [**ADB Commands**](adb-commands.md) to learn how to use adb.

## Smali

Bazen uygulama kodunu **değiştirip** gizli bilgilere (ör. iyi şekilde obfuskated edilmiş parolalar veya flag'ler) erişmek ilginç olabilir. Bu durumda apk'yı decompile edip, kodu değiştirip tekrar derlemek ilginç olabilir.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Bu, dinamik analiz sırasında yapılacak çeşitli testler için çok faydalı bir alternatif olabilir. Bu olasılığı her zaman aklınızda bulundurun.

## Diğer ilginç hileler

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **APK İndirme**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Cihazdan APK çıkarma:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Tüm split ve base APK'ları [APKEditor](https://github.com/REAndroid/APKEditor) ile birleştirin:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Vaka Çalışmaları & Zayıflıklar


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statik Analiz

Öncelikle, bir APK'yı analiz etmek için bir decompiler kullanarak **Java koduna göz atmalısınız**.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### İlginç Bilgiler Arama

Sadece APK'nin **strings**'ine bakarak **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** ve ilginç diğer her şeyi arayabilirsiniz... hatta kod yürütme **backdoors** veya authentication backdoors (hardcoded admin credentials to the app) için bakın.

**Firebase**

Özellikle **firebase URLs**'e dikkat edin ve yanlış yapılandırılmış olup olmadığını kontrol edin. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Uygulamayı Temel Olarak Anlama - Manifest.xml, strings.xml

Bir uygulamanın _Manifest.xml_ ve **_strings.xml_** dosyalarının incelenmesi potansiyel güvenlik zayıflıklarını ortaya çıkarabilir. Bu dosyalara decompiler kullanarak veya APK dosya uzantısını .zip olarak değiştirip açarak erişilebilir.

Manifest.xml'den tespit edilebilecek zayıflıklar şunlardır:

- **Hata Ayıklamaya Açık Uygulamalar**: _Manifest.xml_ dosyasında `debuggable="true"` olarak ayarlanmış uygulamalar risk taşır çünkü bağlantılara izin vererek istismara yol açabilir. Debuggable uygulamaların cihazda bulunup istismar edilmesi hakkında daha fazla bilgi için bir eğitim kaynağına bakın.
- **Backup Ayarları**: Hassas bilgi işleyen uygulamalar için `android:allowBackup="false"` özniteliğinin açıkça ayarlanması gerekir; aksi halde usb debugging etkin iken adb üzerinden yetkisiz veri yedeklemelerine izin verilebilir.
- **Network Security**: _res/xml/_ içindeki özel network security konfigürasyonları (`android:networkSecurityConfig="@xml/network_security_config"`) sertifika pinleri ve HTTP trafiği ayarları gibi güvenlik detaylarını belirtebilir. Örneğin belirli domainler için HTTP trafiğine izin verilmesi gibi.
- **Exported Activities and Services**: Manifest içindeki exported aktiviteler ve servislerin tespit edilmesi, kötüye kullanılabilecek bileşenleri ortaya çıkarabilir. Dinamik testler sırasında bu bileşenlerin nasıl istismar edilebileceği daha detaylı analizle anlaşılabilir.
- **Content Providers ve FileProviders**: Açığa çıkan content provider'lar yetkisiz erişim veya veri değiştirmeye izin verebilir. FileProviders yapılandırması da dikkatle incelenmelidir.
- **Broadcast Receivers ve URL Schemes**: Bu bileşenler giriş zafiyetleri açısından kullanılabilir; özellikle URL şemalarının nasıl yönetildiğine dikkat edilmelidir.
- **SDK Versiyonları**: `minSdkVersion`, `targetSDKVersion` ve `maxSdkVersion` öznitelikleri desteklenen Android versiyonlarını gösterir; güvenlik açısından eski ve zafiyetli Android sürümlerini desteklememenin önemi burada ortaya çıkar.

**strings.xml** dosyasından API keys, custom schemas ve diğer geliştirici notları gibi hassas bilgiler bulunabilir; bu kaynakların dikkatle incelenmesi önemlidir.

### Tapjacking

**Tapjacking**, kötü amaçlı bir **application**'ın başlatılıp **kurban uygulamanın üzerine konumlanmasıyla** yapılan bir saldırıdır. Kurban uygulamayı görsel olarak engellediğinde, kötü uygulamanın kullanıcı arayüzü kullanıcıyı etkileşimde bulunmaya kandıracak şekilde tasarlanır ve etkileşim kurban uygulamaya iletilir.\
Sonuç olarak, kullanıcı aslında kurban uygulama üzerinde işlem yaptığını fark etmeyecek şekilde **körleştirilir**.

Daha fazla bilgi için bakın:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode`'u **`singleTask`** olarak ayarlanmış ve herhangi bir `taskAffinity` tanımlanmamış bir **activity**, task Hijacking'e karşı savunmasızdır. Bu, başka bir **application** kurulup gerçek uygulamadan önce başlatıldığında **gerçek uygulamanın task'ını ele geçirebileceği** anlamına gelir (yani kullanıcı gerçek uygulamayı kullanıyor sanırken **kötü amaçlı uygulama ile etkileşimde bulunacaktır**).

Detaylar için:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Güvensiz veri depolama

**Internal Storage**

Android'de internal storage'da **stored** edilen dosyalar, onları oluşturan **app** tarafından erişilebilir olacak şekilde tasarlanmıştır. Bu güvenlik önlemi Android işletim sistemi tarafından uygulanır ve çoğu uygulamanın güvenlik ihtiyaçları için genelde yeterlidir. Ancak geliştiriciler bazen dosyaların farklı uygulamalar arasında paylaşılmasına izin vermek için `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` gibi modları kullanır. Bu modlar, bu dosyalara diğer uygulamalar (potansiyel olarak kötü amaçlı olanlar dahil) tarafından erişimi kısıtlamaz.

1. **Static Analysis:**
- `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` kullanımının **dikkatle incelenmesini** sağlayın. Bu modlar dosyaların **istemeden veya yetkisiz şekilde erişime** açılmasına neden olabilir.
2. **Dynamic Analysis:**
- Uygulama tarafından oluşturulan dosyaların **izinlerini** doğrulayın. Özellikle herhangi bir dosyanın **dünya tarafından okunabilir veya yazılabilir** olarak ayarlanıp ayarlanmadığını kontrol edin. Bu, cihazda yüklü herhangi bir uygulamanın, kaynağı veya amacı ne olursa olsun, bu dosyaları **okuyup değiştirmesine** izin verebileceği için ciddi bir güvenlik riski oluşturur.

**External Storage**

SD Kart gibi **external storage** üzerindeki dosyalarla uğraşırken şu önlemler alınmalıdır:

1. **Erişilebilirlik**:
- External storage üzerindeki dosyalar **global olarak okunabilir ve yazılabilir**dir. Bu, herhangi bir uygulama veya kullanıcının bu dosyalara erişebileceği anlamına gelir.
2. **Güvenlik Endişeleri**:
- Erişimin kolay olması nedeniyle, hassas bilgileri external storage'da saklamamak önerilir.
- External storage çıkarılabilir veya herhangi bir uygulama tarafından erişilebilir olduğundan daha az güvenlidir.
3. **External Storage'dan Gelen Verilerin İşlenmesi**:
- External storage'dan alınan veriler üzerinde her zaman **input validation** yapın. Bu kritik öneme sahiptir çünkü veriler güvensiz bir kaynaktan gelmektedir.
- External storage'da bulunan yürütülebilir veya class dosyalarının dinamik olarak yüklenmesi şiddetle önerilmez.
- Uygulamanız external storage'dan yürütülebilir dosyalar almak zorundaysa, bu dosyaların dinamik olarak yüklenmeden önce **imzalanmış ve kriptografik olarak doğrulanmış** olmasını sağlayın. Bu adım uygulamanızın güvenlik bütünlüğünü korumak için esastır.

External storage şu yollarla **erişilebilir**: /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Android 4.4 (**API 17**) ile başlayarak, SD kartta bir dizin yapısı vardır ve bu yapı **bir uygulamanın yalnızca o uygulamaya özel dizine erişimini sınırlayacak şekilde** düzenlenmiştir. Bu, kötü amaçlı uygulamaların başka bir uygulamanın dosyalarına okuma veya yazma erişimi kazanmasını engeller.

**Clear-text olarak saklanan hassas veriler**

- **Shared preferences**: Android her uygulamanın `/data/data/<packagename>/shared_prefs/` yolunda kolayca xml dosyaları kaydetmesine izin verir ve bazen bu klasörde açık metin olarak hassas bilgiler bulunabilir.
- **Databases**: Android her uygulamanın `/data/data/<packagename>/databases/` yolunda sqlite veritabanları kaydetmesine izin verir ve bazen bu klasörde açık metin olarak hassas bilgiler bulunabilir.

### Broken TLS

**Accept All Certificates**

Bazı nedenlerden dolayı geliştiriciler bazen tüm sertifikaları kabul eder; örneğin hostname uyuşmaması olsa bile aşağıdaki gibi kod satırlarıyla:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Kırık Kriptografi

**Zayıf Anahtar Yönetimi Süreçleri**

Bazı geliştiriciler hassas verileri yerel depolamada saklar ve bunları kod içinde hardcoded/predictable bir anahtar ile şifreler. Bu yapılmamalıdır çünkü bazı reversing işlemleri saldırganların gizli bilgileri çıkarmasına izin verebilir.

**Güvensiz ve/veya Kullanımdan Kaldırılmış Algoritmaların Kullanımı**

Geliştiriciler yetkilendirme **kontrolleri** yapmak, veriyi **depola**mak veya **göndermek** için **deprecated algorithms** kullanmamalıdır. Bu algoritmalardan bazıları: RC4, MD4, MD5, SHA1... Örneğin parolaları saklamak için **hashes** kullanılıyorsa, salt ile birlikte brute-force **resistant** olan hashler kullanılmalıdır.

### Diğer kontroller

- APK'yı obfuscate etmek önerilir; bu, reverse engineer'ların işini zorlaştırır.
- Uygulama hassassa (ör. banka uygulamaları) kendi **kontrollerini yapmalı, mobilin rooted olup olmadığını kontrol etmeli** ve buna göre hareket etmelidir.
- Uygulama hassassa (ör. banka uygulamaları) bir **emulator** kullanılıp kullanılmadığını kontrol etmelidir.
- Uygulama hassassa (ör. banka uygulamaları) **çalıştırmadan önce kendi bütünlüğünü kontrol etmeli** ve değiştirilip değiştirilmediğini kontrol etmelidir.
- Hangi compiler/packer/obfuscator kullanılarak APK inşa edilmiş kontrol etmek için [**APKiD**](https://github.com/rednaga/APKiD) kullanın

### React Native Application

React uygulamalarının javascript koduna nasıl kolayca erişileceğini öğrenmek için aşağıdaki sayfayı okuyun:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Xamarin uygulamalarının C# koduna nasıl kolayca erişileceğini öğrenmek için aşağıdaki sayfayı okuyun:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Bu [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) göre superpacked, bir uygulamanın içeriğini tek bir dosyaya sıkıştıran bir Meta algoritmasıdır. Blog, bu tür uygulamaları açan bir uygulama oluşturma olasılığından bahsediyor... ve daha hızlı bir yol olarak **uygulamayı çalıştırıp dosya sisteminden açılmış dosyaları toplama** yönteminden söz ediyor.

### Automated Static Code Analysis

[**mariana-trench**](https://github.com/facebook/mariana-trench) aracı, uygulamanın **kodunu** **scanning** yaparak **vulnerabilities** bulabilir. Bu araç, araca **input**'un **kullanıcı tarafından kontrol edildiği yerleri** gösteren bir dizi **known sources**, araca kötü niyetli kullanıcı girdisinin zarara yol açabileceği **dangerous places**'ları gösteren **sinks** ve **rules** içerir. Bu kurallar, bir vulnerability'yi gösteren **sources-sinks** kombinasyonlarını belirtir.

Bu bilgiyle, **mariana-trench kodu inceleyip mümkün olan zafiyetleri bulacaktır**.

### Secrets leaked

Bir uygulama içinde keşfedebileceğiniz gizli bilgiler (API keys, parolalar, gizli url'ler, subdomain'ler...) olabilir. Örneğin şu aracı kullanabilirsiniz: [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Diğer ilginç fonksiyonlar

- **Kod yürütme**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **SMS gönderme**: `sendTextMessage, sendMultipartTestMessage`
- **Native fonksiyonlar** `native` olarak tanımlı: `public native, System.loadLibrary, System.load`
- [Bunu okuyun: **native fonksiyonları nasıl reverse edeceğinizi öğrenin**](reversing-native-libraries.md)

### **Diğer püf noktaları**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamik Analiz

> Öncelikle, uygulamayı ve tüm ortamı (Burp CA cert, Drozer ve Frida başta olmak üzere) kurabileceğiniz bir ortama ihtiyacınız var. Bu nedenle, rootlu bir cihaz (emulated veya değil) kesinlikle önerilir.

### Çevrimiçi Dinamik analiz

Şu platformda **ücretsiz hesap** oluşturabilirsiniz: [https://appetize.io/](https://appetize.io/). Bu platform APK yükleyip çalıştırmanıza izin verir; bu, bir apk'nın nasıl davrandığını görmek için faydalıdır.

Hatta web üzerinden **uygulamanızın loglarını görebilir** ve **adb** ile bağlanabilirsiniz.

![](<../../images/image (831).png>)

ADB bağlantısı sayesinde emülatör içinde **Drozer** ve **Frida** kullanabilirsiniz.

### Yerel Dinamik Analiz

#### Bir emulator kullanarak

- [**Android Studio**](https://developer.android.com/studio) (**x86** ve **arm** cihazlar oluşturabilirsiniz; ve [**bu**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**kaynağa göre** en güncel x86 sürümleri **ARM kütüphanelerini** yavaş bir arm emulator'a ihtiyaç duymadan desteklemektedir).
- Bunun nasıl kurulacağını bu sayfada öğrenin:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Ücretsiz sürüm:** Personal Edition, bir hesap oluşturmanız gerekir. _Potansiyel hatalardan kaçınmak için VirtualBox _**ILE**_ gelen sürümü **indirmek** önerilir._)
- [**Nox**](https://es.bignox.com) (Ücretsiz, ancak Frida veya Drozer'i desteklemiyor).

> [!TIP]
> Yeni bir emulator oluştururken ekran ne kadar büyükse emulator o kadar yavaş çalışır. Mümkünse küçük ekranları seçin.

Genymotion'da **google services** (ör. AppStore gibi) **kurmak** için aşağıdaki görüntüde kırmızı ile işaretlenmiş butona tıklamanız gerekir:

![](<../../images/image (277).png>)

Ayrıca, **Genymotion içindeki Android VM yapılandırmasında** **Bridge Network mode** seçebileceğinizi unutmayın (bu, Android VM'ye başka bir VM'den araçlarla bağlanacaksanız faydalı olacaktır).

#### Fiziksel bir cihaz kullanma

Geliştirici seçeneklerini etkinleştirmeniz gerekir ve mümkünse cihazı **root** yapmanız iyi olur:

1. **Ayarlar**.
2. (FromAndroid 8.0) **System** seçin.
3. **About phone** seçin.
4. **Build number** üzerine 7 kez basın.
5. Geri gidin ve **Developer options**'ı bulacaksınız.

> Uygulamayı yükledikten sonra yapmanız gereken ilk şey, uygulamayı denemek, ne yaptığını ve nasıl çalıştığını araştırmak ve ona alışmaktır.\
> İlk dinamik analiz aşamasını MobSF dynamic analysis + pidcat kullanarak yapmanızı öneririm; böylece uygulamanın nasıl çalıştığını öğrenirken MobSF daha sonra inceleyebileceğiniz birçok ilginç veriyi capture edecektir.

### Unintended Data Leakage

**Logging**

Geliştiriciler, **debugging information**'ı kamuya açık hale getirmede dikkatli olmalıdır, çünkü bu sensitive data leaks'lara yol açabilir. Uygulama loglarını izlemek ve hassas bilgileri tespit etmek için [**pidcat**](https://github.com/JakeWharton/pidcat) ve `adb logcat` araçları önerilir. **Pidcat**, kullanımı ve okunabilirliği açısından tercih edilir.

> [!WARNING]
> Android 4.0'dan daha yeni sürümlerden itibaren, **uygulamalar yalnızca kendi loglarına erişebilir**. Yani uygulamalar diğer uygulamaların loglarına erişemez.\
> Yine de hassas bilgileri **loglamamak** önerilir.

**Copy/Paste Buffer Caching**

Android'in **clipboard-based** framework'ü uygulamalarda kopyala-yapıştır işlevselliği sağlar, ancak **diğer uygulamalar** panoya erişebileceği için bir risk oluşturur ve hassas verilerin açığa çıkmasına neden olabilir. Kredi kartı bilgileri gibi hassas bölümler için kopyala/yapıştır fonksiyonlarını devre dışı bırakmak önemlidir.

**Crash Logs**

Bir uygulama **crash** yapar ve logları kaydederse, özellikle uygulama tersine mühendislikle çözülemiyorsa, bu loglar saldırganlara yardımcı olabilir. Bu riski azaltmak için crash durumlarında loglama yapmaktan kaçının; loglar ağ üzerinden gönderilecekse güvenlik için SSL kanalı kullanıldığından emin olun.

Pentester olarak, **bu loglara bakmayı deneyin**.

**Analytics Data Sent To 3rd Parties**

Uygulamalar sıklıkla Google Adsense gibi servisleri entegre eder; geliştiricilerin hatalı uygulaması nedeniyle bu servisler hassas verileri istemeden **leak** edebilir. Potansiyel veri sızıntılarını tespit etmek için uygulamanın trafiğini intercept edip üçüncü taraf servislere hassas bilgi gönderilip gönderilmediğini kontrol etmek önerilir.

### SQLite DBs

Çoğu uygulama bilgi saklamak için **internal SQLite databases** kullanır. Pentest sırasında oluşturulan **databaseları**, **tabloların** ve **sütunların** adlarını ve kaydedilen tüm **verileri** inceleyin; çünkü hassas bilgi (bu bir güvenlik açığı olur) bulabilirsiniz.\
Veritabanları genelde `/data/data/the.package.name/databases` altında yer alır, örneğin `/data/data/com.mwr.example.sieve/databases`

Eğer veritabanı gizli bilgileri kaydediyor ve **encrypted** ise fakat parolayı uygulama içinde **bulabiliyorsanız**, bu hâlâ bir **güvenlik açığı**'dır.

Tabloları listelemek için `.tables` komutunu, tablolardaki sütunları listelemek için `.schema <table_name>` komutunu kullanın.

### Drozer (Exploit Activities, Content Providers and Services)

Drozer Docs'a göre: **Drozer** size bir Android uygulamasının rolünü üstlenme ve diğer uygulamalarla etkileşimde bulunma imkanı verir. Yüklü bir uygulamanın yapabileceği her şeyi yapabilir; örneğin Android’in Inter-Process Communication (IPC) mekanizmasını kullanabilir ve altta yatan işletim sistemi ile etkileşime girebilir. .\
Drozer, exported activities, exported services ve Content Providers'ı **exploit** etmek için kullanışlı bir araçtır; bunu sonraki bölümlerde öğreneceksiniz.

### Exploiting exported Activities

[**Android Activity nedir, tazelemek isterseniz bunu okuyun.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ayrıca unutmayın ki bir activity'nin kodu **`onCreate`** metodunda başlar.

**Authorisation bypass**

Bir Activity exported olduğunda ekranını harici bir uygulamadan çağırabilirsiniz. Bu yüzden, eğer hassas bilgi içeren bir activity exported ise, kimlik doğrulama mekanizmalarını **bypass** ederek ona erişebilirsiniz.

[**Drozer ile exported activities'i nasıl istismar edeceğinizi öğrenin.**](drozer-tutorial/index.html#activities)

Ayrıca bir exported activity'yi adb üzerinden başlatabilirsiniz:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOT**: MobSF bir activity'de _**singleTask/singleInstance**_ kullanımını `android:launchMode` olarak kötü amaçlı olarak tespit edecektir, fakat [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) nedeniyle, görünüşe göre bu sadece eski sürümlerde (API versions < 21) tehlikelidir.

> [!TIP]
> Bir authorisation bypass her zaman bir vulnerability değildir; bunun nasıl çalıştığına ve hangi bilgilerin açığa çıktığına bağlıdır.

**Sensitive information leakage**

**Activities can also return results**. Eğer exported ve korumasız bir activity içinde **`setResult`** metodunu çağıran ve **hassas bilgi** döndüren bir durum bulursanız, sensitive information leakage söz konusudur.

#### Tapjacking

Eğer Tapjacking engellenmemişse, exported activity'yi kötüye kullanarak **kullanıcının beklenmeyen işlemler gerçekleştirmesini** sağlayabilirsiniz. Daha fazla bilgi için [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers temel olarak **veri paylaşımı** için kullanılır. Eğer bir uygulamanın erişilebilir content providers'ı varsa, bunlardan **hassas veriler** çekebilirsiniz. Ayrıca olası **SQL injections** ve **Path Traversals**'ı test etmek ilginçtir çünkü bunlar zayıf olabilir.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Bir Service'in eylemlerinin `onStartCommand` metodunda başladığını unutmayın.

Service temelde **veri alabilen**, **işleyebilen** ve **döndürebilen** (veya döndürmeyen) bir bileşendir. Dolayısıyla, bir uygulama bazı Service'leri export ediyorsa ne yaptığını anlamak için **kodu kontrol etmeli** ve gizli bilgileri çıkarmak, kimlik doğrulama önlemlerini bypass etmek gibi amaçlarla **dinamik** olarak **test** etmelisiniz...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Bir Broadcast Receiver'ın eylemlerinin `onReceive` metodunda başladığını unutmayın.

Bir broadcast receiver belirli bir tür mesajı bekler. Alıcının mesajı nasıl işlediğine bağlı olarak zafiyetli olabilir.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Deep linkleri manuel olarak arayabilirsiniz; MobSF gibi araçlar veya [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) gibi scriptler kullanabilirsiniz.\
Declare edilmiş bir **scheme**'i **adb** veya bir **browser** ile **açabilirsiniz**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Paket adını **atlayabilirsiniz** ve mobil cihaz o bağlantıyı açması gereken uygulamayı otomatik olarak çağıracaktır._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Yürütülen kod**

Uygulamada **yürütülecek kodu** bulmak için deeplink tarafından çağrılan activity'ye gidin ve **`onNewIntent`** fonksiyonunu arayın.

![](<../../images/image (436) (1) (1) (1).png>)

**Hassas bilgi**

Her seferinde bir deep link bulduğunuzda, **URL parametreleri aracılığıyla (örn. şifreler) hassas veri almadığından** emin olun, çünkü başka herhangi bir uygulama **deep link'i taklit ederek bu verileri çalabilir!**

**Path içindeki parametreler**

Ayrıca **herhangi bir deep link'in URL path'i içinde bir parametre kullanıp kullanmadığını da kontrol etmelisiniz**, örneğin: `https://api.example.com/v1/users/{username}` . Bu durumda path traversal zorlayarak şu şekilde erişim sağlayabilirsiniz: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Doğru endpoint'leri uygulama içinde bulursanız, path'in bir kısmı domain adı olarak kullanılıyorsa **Open Redirect** (Açık Yönlendirme), CSRF token olmadan kullanıcı detaylarını değiştirip hedef endpoint doğru HTTP metodunu kullanıyorsa **account takeover** ve diğer çeşitli zafiyetleri tetikleyebilirsiniz. Bu konuda daha fazla [bilgi için buraya bakın](http://dphoeniixx.com/2020/12/13-2/).

**Daha fazla örnek**

İlginç bir bug bounty raporu: [https://hackerone.com/reports/855618](https://hackerone.com/reports/855618) (links, _/.well-known/assetlinks.json_ hakkında).

### Taşıma Katmanı İncelemesi ve Doğrulama Hataları

- **Sertifikalar Android uygulamaları tarafından her zaman düzgün şekilde incelenmez.** Bu uygulamaların self-signed sertifikaları kabul etmesi veya bazı durumlarda HTTP bağlantılarına geri dönmesi yaygındır.
- **SSL/TLS handshake sırasında yapılan müzakereler bazen zayıftır**, güvensiz cipher suite'ler kullanılabilir. Bu zafiyet bağlantıyı man-in-the-middle (MITM) saldırılarına karşı savunmasız bırakır ve saldırganların veriyi deşifre etmesine olanak tanır.
- **Özel bilgilerin leak olması** riski, uygulamalar güvenli kanallarla kimlik doğrulaması yapıp sonraki işlemler için güvensiz kanallar üzerinden iletişim kurduğunda ortaya çıkar. Bu yaklaşım, session cookie'leri veya kullanıcı bilgileri gibi hassas verileri kötü niyetli kişilerin ele geçirmesine karşı koruyamaz.

#### Sertifika Doğrulama

Sertifika doğrulamasına odaklanacağız. Sunucunun sertifikasının bütünlüğü doğrulanmalıdır; bu güvenliği artırmak için kritiktir. Zayıf TLS konfigürasyonları ve hassas verinin şifrelenmemiş kanallarda iletilmesi ciddi riskler doğurabilir. Sunucu sertifikalarını doğrulama ve zafiyetleri ele alma adımları için [**bu kaynak**](https://manifestsecurity.com/android-application-security-part-10/) kapsamlı rehberlik sağlar.

#### SSL Pinning

SSL Pinning, uygulamanın sunucunun sertifikasını uygulama içinde saklanan bilinen bir kopyaya karşı doğruladığı bir güvenlik önlemidir. Bu yöntem MITM saldırılarını önlemek için kritiktir. Hassas bilgi işleyen uygulamalar için SSL Pinning uygulanması şiddetle tavsiye edilir.

#### Trafik İncelemesi

HTTP trafiğini incelemek için proxy aracının sertifikasını yüklemeniz gerekir (örn. Burp). Bu sertifikayı yüklemeden şifreli trafik proxy üzerinden görülemeyebilir. Özel bir CA sertifikasının nasıl kurulacağına dair rehber için [**buraya tıklayın**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

**API Level 24 ve üzerini hedefleyen** uygulamalar, proxy'nin CA sertifikasını kabul etmek için Network Security Config üzerinde değişiklikler gerektirir. Şifreli trafiği incelemek için Network Security Config'i nasıl değiştireceğinize dair yönergeler için [**bu eğitime bakın**](make-apk-accept-ca-certificate.md).

Eğer **Flutter** kullanılıyorsa, [**bu sayfadaki**](flutter.md) talimatları izlemelisiniz. Sadece sertifikayı store'a eklemek işe yaramaz çünkü Flutter'ın kendi geçerli CA listesi vardır.

#### SSL/TLS pinning'in statik tespiti

Runtime bypass denemeden önce, pinning'in APK içinde nerelerde uygulandığını hızlıca haritalayın. Statik keşif, hook/patch planlamanıza yardımcı olur ve doğru kod yollarına odaklanmanızı sağlar.

Tool: SSLPinDetect
- APK'yı Smali'ye decompile etmek (apktool aracılığıyla) ve SSL/TLS pinning implementasyonlarına ait küratörlü regex pattern'lerini taramak için açık kaynaklı statik-analiz aracı.
- Her eşleşme için tam dosya yolu, satır numarası ve bir kod snippet'i raporlar.
- Yaygın framework'leri ve custom kod yollarını kapsar: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init ile custom TrustManagers/KeyManagers, ve Network Security Config XML pinleri.

Kurulum
- Gereksinimler: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Kullanım
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Örnek desen kuralları (JSON)
Proprietary/custom pinning stillerini tespit etmek için signatures kullanın veya genişletin. Kendi JSON'unuzu yükleyebilir ve ölçekli olarak scan edebilirsiniz.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notlar ve ipuçları
- Büyük uygulamalarda hızlı tarama için multi-threading ve memory-mapped I/O kullanın; önceden derlenmiş regex, yükü/yanlış pozitifleri azaltır.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Sonraki önceliklendirme için tipik tespit hedefleri:
- OkHttp: CertificatePinner kullanımı, setCertificatePinner, okhttp3/okhttp paket referansları
- Özel TrustManager'lar: javax.net.ssl.X509TrustManager, checkServerTrusted override'ları
- Özel SSL context'leri: SSLContext.getInstance + SSLContext.init özel manager'larla
- res/xml içindeki declarative pin'ler (network security config) ve manifest referansları
- Eşleşen konumları dinamik testlerden önce Frida hook'ları, statik yamalar veya konfigürasyon incelemelerini planlamak için kullanın.



#### SSL Pinning'i Atlatma

SSL Pinning uygulandığında, HTTPS trafiğini incelemek için bunu atlatmak gerekir. Bu amaçla çeşitli yöntemler mevcuttur:

- Otomatik olarak **apk**'yı **değiştirip** SSLPinning'i **atlatmak** için [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) kullanın. Bu seçeneğin en büyük avantajı, SSL Pinning'i atlatmak için root gerekmemesi; ancak uygulamayı silip yeniden yüklemeniz gerekir ve bu her zaman işe yaramayabilir.
- Bu korumayı atlamak için **Frida** (aşağıda anlatılıyor) kullanabilirsiniz. Burp+Frida+Genymotion kullanımı için rehber: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- [**objection**](frida-tutorial/objection-tutorial.md) kullanarak **otomatik olarak SSL Pinning'i atmaya** da çalışabilirsiniz:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dynamic analysis** (aşağıda açıklanıyor) kullanarak **otomatik olarak SSL Pinning atlama**yı da deneyebilirsiniz
- Eğer hala yakalayamadığınız trafik olduğunu düşünüyorsanız, trafiği iptables kullanarak burp'a yönlendirmeyi deneyebilirsiniz. Bu blogu okuyun: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Yaygın Web Zafiyetlerini Arama

Uygulama içinde yaygın web zafiyetlerini aramak da önemlidir. Bu zafiyetleri tespit etme ve hafifletme konusundaki ayrıntılı bilgiler bu özetin kapsamı dışında ancak başka yerlerde genişçe ele alınmıştır.

### Frida

[Frida](https://www.frida.re) geliştiriciler, tersine mühendislik yapanlar ve güvenlik araştırmacıları için dinamik bir enstrümantasyon araç setidir.\
**Çalışan uygulamaya erişip runtime'da method'ları hook'layarak davranışı değiştirebilir, değerleri değiştirebilir, değerleri çıkarabilir veya farklı kod çalıştırabilirsiniz...**\
Android uygulamalarını pentest etmek istiyorsanız Frida'yı nasıl kullanacağınızı bilmelisiniz.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Frida ile işlemler için bazı "GUI"ler: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection, Frida kullanımını otomatikleştirmek için harikadır: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Bazı Awesome Frida script'lerini burada bulabilirsiniz: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Frida'yı ptrace olmadan yükleyerek anti-debugging / anti-frida mekanizmalarını atlatmayı deneyin; rehber: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Belleği Dökme - Fridump**

Uygulamanın, parola veya mnemonikler gibi saklamaması gereken hassas bilgileri bellekte saklayıp saklamadığını kontrol edin.

[**Fridump3**](https://github.com/rootbsd/fridump3) kullanarak uygulamanın belleğini şu şekilde dökebilirsiniz:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Bu, belleği ./dump klasörüne dökecektir; orada şu gibi bir komutla grep yapabilirsiniz:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore'daki hassas veriler**

Android'de Keystore hassas verileri saklamak için en iyi yerdir, ancak yeterli ayrıcalıklarla hâlâ **erişmek mümkün**. Uygulamalar burada genellikle **düz metin halinde hassas veriler** saklama eğiliminde olduğundan pentests bunu root kullanıcı olarak veya cihaza fiziksel erişimi olan birisinin bu verileri çalabilmesi ihtimaline karşı kontrol etmelidir.

Bir uygulama Keystore'a data kaydetmiş olsa bile, data şifrelenmiş olmalıdır.

Keystore içindeki dataya erişmek için bu Frida script'ini kullanabilirsiniz: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Aşağıdaki Frida script'ini kullanarak, Android uygulamalarının belirli hassas alanları korumak için gerçekleştirebileceği **bypass fingerprint authentication** işlemini atlatmak mümkün olabilir:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Arka Plan Görüntüleri**

Bir uygulamayı arka plana attığınızda, Android uygulamanın **snapshot'ını** depolar; böylece uygulama tekrar öne getirildiğinde, uygulama yüklenmeden önce bu görüntüyü yüklemeye başlar ve uygulamanın daha hızlı açıldığı izlenimini verir.

Ancak bu **snapshot** hassas bilgi içeriyorsa, snapshot'a erişimi olan biri bu bilgileri **çalabilir** (erişim için root gerektiğini unutmayın).

Snapshot'lar genellikle şu dizinde saklanır: **`/data/system_ce/0/snapshots`**

Android, düzen parametresi olarak **FLAG_SECURE ayarlanarak screenshot alınmasını engelleme** imkanı sağlar. Bu flag kullanıldığında, pencere içeriği güvenli olarak işaretlenir; böylece ekran görüntülerinde görünmesi veya güvensiz ekranlarda görüntülenmesi engellenir.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Bu araç, dynamic analysis sırasında farklı araçları yönetmenize yardımcı olabilir: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Geliştiriciler sıklıkla bu Intents'leri işleyip `startActivity(...)` veya `sendBroadcast(...)` gibi yöntemlere ileten activities, services ve broadcast receivers gibi proxy bileşenler oluştururlar; bu durum riskli olabilir.

Tehlike, saldırganların bu Intents'leri yanlış yönlendirerek non-exported uygulama bileşenlerini tetiklemesine veya hassas content providers'a erişmesine izin verilmesindedir. Önemli bir örnek, `WebView` bileşeninin URL'leri `Intent.parseUri(...)` ile Intent nesnelerine dönüştürmesi ve ardından bunları çalıştırmasıdır; bu durum kötü amaçlı Intent enjeksiyonlarına yol açabilir.

### Essential Takeaways

- **Intent Injection** web'deki Open Redirect sorununa benzer.
- Exploits, `Intent` nesnelerini extras olarak geçirip bunların unsafe işlemleri gerçekleştirmek için yönlendirilmesini içerir.
- Bu, non-exported bileşenleri ve content providers'ı saldırganlara açabilir.
- `WebView`'in URL'den `Intent`e dönüşümü istenmeyen eylemleri kolaylaştırabilir.

### Android Client Side Injections and others

Muhtemelen bu tür zafiyetleri Web'den biliyorsunuzdur. Bir Android uygulamasında bu zafiyetlere özellikle dikkat etmelisiniz:

- **SQL Injection:** dynamic sorgular veya Content-Providers ile çalışırken parameterized queries kullandığınızdan emin olun.
- **JavaScript Injection (XSS):** Herhangi bir WebView için JavaScript ve Plugin desteğinin devre dışı olduğundan emin olun (varsayılan olarak devre dışı). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebView'lerin dosya sistemine erişimi devre dışı olmalıdır (varsayılan olarak etkin) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Birçok durumda, Android uygulama oturumu kapattığında cookie iptal edilmez veya diske bile kaydedilebilir.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSF'nin **Android**(apk)**, IOS**(ipa) **and Windows**(apx) uygulamalarını analiz edebildiğini unutmayın (_Windows uygulamaları, bir Windows host'a kurulu bir MobSF'den analiz edilmelidir_).\
Ayrıca, bir **Android** veya bir **IOS** uygulamasının kaynak koduyla bir **ZIP** dosyası oluşturursanız (uygulamanın kök klasörüne gidin, her şeyi seçin ve bir ZIP dosyası oluşturun), MobSF bunu da analiz edebilecektir.

MobSF ayrıca analizleri **diff/Compare** etmenize ve **VirusTotal** ile entegre olmanıza izin verir (API anahtarınızı _MobSF/settings.py_ içinde ayarlamanız ve etkinleştirmeniz gerekir: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). `VT_UPLOAD`'ı `False` olarak ayarlayabilirsiniz; bu durumda dosya yerine **hash** yüklenecektir.

### MobSF ile Yardımlı Dinamik Analiz

**MobSF**, **Android** için **dynamic analysis** sırasında da çok faydalı olabilir, ancak bu durumda host'unuza MobSF ve **genymotion** kurmanız gerekir (VM veya Docker işe yaramaz). _Not: Önce **genymotion**'da bir VM başlatmalı ve **sonra MobSF**'yi çalıştırmalısınız._\
**MobSF dynamic analyser** şunları yapabilir:

- **Dump application data** (URL'ler, loglar, clipboard, sizin aldığınız ekran görüntüleri, "**Exported Activity Tester**" tarafından alınan ekran görüntüleri, e-postalar, SQLite veritabanları, XML dosyaları ve oluşturulan diğer dosyalar). Ekran görüntüleri hariç bunların tümü otomatik olarak yapılır; ekran görüntüsü almak istediğinizde butona basmanız gerekir veya tüm exported activity'lerin ekran görüntülerini almak için "**Exported Activity Tester**" a basmalısınız.
- **HTTPS traffic**'i yakalar
- **Frida** kullanarak **runtime** **information** elde eder

Android **versions > 5** sürümlerinden itibaren, otomatik olarak **Frida**'yı başlatır ve trafiği yakalamak için global **proxy** ayarlarını yapar. Yalnızca test edilen uygulamanın trafiğini yakalar.

Frida

Varsayılan olarak bazı Frida Scripts'leri kullanarak **bypass SSL pinning**, **root detection** ve **debugger detection** ile başa çıkar ve ilginç API'leri **monitor** eder.\
MobSF ayrıca **invoke exported activities**'i çağırabilir, bunların **screenshots**'larını alabilir ve rapor için **save** edebilir.

Dinamik testi başlatmak için yeşil düğmeye: "**Start Instrumentation**" basın. Frida script'leri tarafından oluşturulan logları görmek için "**Frida Live Logs**" ve hooked metodlara yapılan tüm çağrıları, geçirilen argümanları ve döndürülen değerleri görmek için "**Live API Monitor**" a basın (bu, "**Start Instrumentation**" a bastıktan sonra görünecektir).\
MobSF ayrıca kendi **Frida scripts**'lerinizi yüklemenize olanak tanır (Frida script'lerinizin sonuçlarını MobSF'ye göndermek için `send()` fonksiyonunu kullanın). Yükleyebileceğiniz **several pre-written scripts** de mevcuttur (daha fazlasını `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` dizinine ekleyebilirsiniz), onları **select** edin, "**Load**" a ve ardından "**Start Instrumentation**" a basın (bu script'lerin loglarını "**Frida Live Logs**" içinde görebileceksiniz).

![](<../../images/image (419).png>)

Ayrıca bazı yardımcı Frida fonksiyonaliteleri vardır:

- **Enumerate Loaded Classes**: Yüklenen tüm sınıfları yazdırır
- **Capture Strings**: Uygulamayı kullanırken yakalanan tüm stringleri yazdırır (çok gürültülü)
- **Capture String Comparisons**: Çok faydalı olabilir. **Karşılaştırılan 2 string'i gösterir** ve sonucun True mu False mı olduğunu belirtir.
- **Enumerate Class Methods**: Sınıf adını girin (ör. "java.io.File") ve sınıfın tüm methodlarını yazdırır.
- **Search Class Pattern**: Desene göre sınıfları arar
- **Trace Class Methods**: Bir **sınıfı Trace eder** (sınıftaki tüm metodların giriş ve çıkışlarını görür). Varsayılan olarak MobSF birkaç ilginç Android API metodunu trace eder.

Kullanmak istediğiniz yardımcı modülü seçtikten sonra "**Start Instrumentation**" a basmanız gerekir ve tüm çıktıları "**Frida Live Logs**" içinde göreceksiniz.

Shell

MobSF ayrıca dynamic analysis sayfasının altında bazı **adb** komutları, **MobSF commands** ve yaygın **shell** **commands** içeren bir shell sunar. Bazı ilginç komutlar:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP araçları**

HTTP trafiği yakalandığında, yakalanan trafiğin çirkin bir görünümünü "**HTTP(S) Traffic**" butonunda veya daha güzel bir görünümünü "**Start HTTPTools**" yeşil butonunda görebilirsiniz. İkinci seçenekten, **yakalanan istekleri** Burp veya Owasp ZAP gibi **proxies**'e **send** edebilirsiniz.\
Bunu yapmak için, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF ile dinamik analizi bitirdikten sonra "**Start Web API Fuzzer**" tuşuna basıp **fuzz http requests** yaparak zafiyet arayabilirsiniz.

> [!TIP]
> MobSF ile dinamik analiz yaptıktan sonra proxy ayarları yanlış yapılandırılmış olabilir ve GUI üzerinden düzeltemeyebilirsiniz. Proxy ayarlarını şu komut ile düzeltebilirsiniz:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Bu araç, dinamik analiz yaparken uygulamada **neler olduğuna** dair bilgi vermek için bazı **Hooks** kullanır.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Bu, GUI ile **statik analiz yapmak için harika bir araçtır**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Bu araç, hem **source code** içinde hem de **packaged APKs** içinde çeşitli **security related Android application vulnerabilities** aramak için tasarlanmıştır. Araç ayrıca bazı bulunan zafiyetleri (Exposed activities, intents, tapjacking...) sömürmek için **"Proof-of-Concept" deployable APK** ve **ADB commands** oluşturma yeteneğine sahiptir. Drozer ile olduğu gibi, test cihazını root etmenize gerek yoktur.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Kolay referans için çıkarılan tüm dosyaları görüntüler
- APK dosyalarını otomatik olarak Java ve Smali formatına decompile eder
- AndroidManifest.xml'ü yaygın zafiyetler ve davranışlar için analiz eder
- Yaygın zafiyetler ve davranışlar için statik kaynak kodu analizi
- Cihaz bilgileri
- ve daha fazlası
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER, Windows, MacOS X ve Linux'ta kullanılabilen bir komut satırı uygulamasıdır; _.apk_ dosyalarını vulnerabilities açısından analiz eder. Bunu APK'leri dekomprese ederek ve söz konusu vulnerabilities'i tespit etmek için bir dizi kural uygulayarak yapar.

Tüm kurallar `rules.json` dosyasında toplanmıştır; her şirket veya test uzmanı ihtiyaçlarına göre kendi kurallarını oluşturabilir.

En son ikili dosyaları [download page](https://superanalyzer.rocks/download.html) üzerinden indirin.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn, mobil uygulamalarda [static code analysis] yapan geliştiricilere, bugbounty hunters ve ethical hackers'a yardımcı olan bir **crossplatform** araçtır.

Konsept şu: mobil uygulama dosyanızı (.apk veya .ipa dosyası) StaCoAn uygulamasına sürükleyip bırakırsınız ve uygulama sizin için görsel ve taşınabilir bir rapor oluşturur. Ayarları ve wordlists'i değiştirerek özelleştirilmiş bir deneyim elde edebilirsiniz.

İndir[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework, geliştiricilerin veya hackers'ın Android uygulamalarındaki potansiyel güvenlik açıklarını bulmalarına yardımcı olan bir Android zafiyet analiz sistemidir.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** Android uygulamaları tarafından geliştirilen potansiyel kötü amaçlı davranışları tespit edip kullanıcıyı uyarmayı amaçlayan bir araçtır.

Tespit, uygulamanın Dalvik bytecode'unda temsil edilen **Smali** üzerinden yapılan **static analysis** ile [`androguard`](https://github.com/androguard/androguard) kütüphanesi kullanılarak gerçekleştirilir.

Bu araç, **"kötü" uygulamaların ortak davranışları** gibi şunları arar: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Mobil uygulamaların OWASP mobile security tehditlerine karşı test edilmesine yardımcı olmak için yaygın kullanılan mobile application reverse engineering and analysis araçlarını bir araya getiren bir araçtır. Amacı bu görevi mobil uygulama geliştiricileri ve güvenlik profesyonelleri için daha kolay ve kullanıcı dostu hale getirmektir.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Malware tespit etmek için faydalı: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Note that depending the service and configuration you use to obfuscate the code. Secrets may or may not ended obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

You can upload an obfuscated APK to their platform.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Harika bir kaynak listesi
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android hızlı kurs
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
