# Android Uygulamaları Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Uygulamaları Temelleri

Bu sayfayı okumaya başlamanız şiddetle tavsiye edilir; çünkü burada **Android güvenliği ile ilgili en önemli bölümler ve bir Android uygulamasındaki en tehlikeli bileşenler** hakkında bilgi bulacaksınız:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Bu, bir android cihaza (emulated or physical) bağlanmak için ihtiyaç duyduğunuz ana araçtır.\
**ADB** bilgisayardan **USB** veya **Network** üzerinden cihazları kontrol etmeyi sağlar. Bu yardımcı program, iki yönlü dosya **kopyalama**, uygulamaların **kurulumu** ve **kaldırılması**, shell komutlarının **çalıştırılması**, verilerin **yedeklenmesi**, logların **okunması** gibi işlevleri sağlar.

adb kullanmayı öğrenmek için aşağıdaki [**ADB Commands**](adb-commands.md) listesine göz atın.

## Smali

Bazen **uygulama kodunu değiştirmek**, **gizli bilgilere** (örneğin iyi obfusk edilmiş şifreler veya flag'ler) erişmek için ilginç olabilir. Bu durumda, apk'yı decompile etmek, kodu değiştirmek ve tekrar derlemek ilginç olabilir.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Bu, sunulacak dinamik analiz sırasında yapılacak çeşitli testler için bir **alternatif** olarak çok faydalı olabilir. O yüzden, **bu olasılığı her zaman aklınızda bulundurun**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **APK'leri İndir**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Cihazdan APK çıkarma:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Tüm splits ve base apks'leri [APKEditor](https://github.com/REAndroid/APKEditor) ile birleştirin:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Vaka İncelemeleri & Zafiyetler


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statik Analiz

Her şeyden önce, bir APK'yı analiz etmek için **Java code**'a bir decompiler kullanarak bakmalısınız.\
Lütfen, [**read here to find information about different available decompilers**](apk-decompilers.md).

### İlginç Bilgiler

APK'nin **strings**'ine bakarak **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** ve diğer ilginç şeyleri arayabilirsiniz... hatta code execution **backdoors** veya authentication backdoors (hardcoded admin credentials to the app) için kontrol edin.

**Firebase**

**Firebase URL**'lerine özellikle dikkat edin ve kötü yapılandırılıp yapılandırılmadığını kontrol edin. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Uygulamayı temel düzeyde anlama - Manifest.xml, strings.xml

Bir uygulamanın _Manifest.xml_ ve _strings.xml_ dosyalarının incelenmesi potansiyel güvenlik zafiyetlerini ortaya çıkarabilir. Bu dosyalara decompiler kullanarak veya APK dosya uzantısını .zip yapıp açarak erişilebilir.

**Manifest.xml**'den tespit edilebilecek zafiyetler şunlardır:

- **Debuggable Applications**: _Manifest.xml_ dosyasında debuggable olarak ayarlanmış (`debuggable="true"`) uygulamalar bağlantılara izin vererek exploitation'a açık olabilir. Debuggable uygulamaların bir cihazda nasıl bulunup exploit edileceğine dair bir rehbere bakın.
- **Backup Settings**: Hassas bilgi işleyen uygulamalar için `android:allowBackup="false"` niteliğinin açıkça ayarlanması gerekir; aksi takdirde usb debugging etkin olduğunda adb üzerinden yetkisiz veri yedeklemelerine izin verilebilir.
- **Network Security**: _res/xml/_ içindeki özel network security konfigürasyonları (`android:networkSecurityConfig="@xml/network_security_config"`) sertifika pinleri ve HTTP trafiği ayarları gibi güvenlik detaylarını belirtebilir. Örneğin belirli domainler için HTTP trafiğine izin verilebilir.
- **Exported Activities and Services**: Manifest içindeki exported activity ve service'lerin belirlenmesi, kötüye kullanılabilecek bileşenleri ortaya çıkarabilir. Dynamic testler sırasında bu bileşenlerin nasıl exploit edilebileceği daha fazla analizle anlaşılabilir.
- **Content Providers and FileProviders**: Açık bırakılmış content provider'lar yetkisiz erişim veya veri değişikliğine izin verebilir. FileProvider konfigürasyonları da dikkatle incelenmelidir.
- **Broadcast Receivers and URL Schemes**: Bu bileşenler exploitation için kullanılabilir; özellikle URL şemalarının giriş doğrulaması açısından nasıl yönetildiğine dikkat edilmelidir.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion` ve `maxSdkVersion` öznitelikleri desteklenen Android sürümlerini gösterir; eski ve zafiyetli Android sürümlerine destek verilmemesi güvenlik açısından önemlidir.

**strings.xml** dosyasından API anahtarları, custom schemas ve diğer geliştirici notları gibi hassas bilgiler keşfedilebilir; bu kaynakların dikkatle incelenmesi gerektiğini vurgular.

### Tapjacking

**Tapjacking**; kötü amaçlı bir uygulamanın başlatılıp **hedef uygulamanın üstüne yerleştiği** bir saldırıdır. Hedef uygulamayı görünür şekilde örtüp, kötü amaçlı uygulamanın arayüzü kullanıcıyı etkileşime geçmeye kandıracak şekilde tasarlanır; aynı zamanda bu etkileşim hedef uygulamaya iletilir.\
Sonuç olarak, kullanıcıya aslında hedef uygulamada işlem yaptığı gösterilmez ve kullanıcı "kör" bırakılır.

Detaylı bilgiye bakın:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode` değeri `singleTask` olarak ayarlanmış ve herhangi bir `taskAffinity` tanımlanmamış bir **activity**, task Hijacking'e açıktır. Bu durumda kötü amaçlı bir uygulama yüklendiğinde ve gerçek uygulamadan önce başlatıldığında **gerçek uygulamanın task'ını ele geçirebilir** (kullanıcı gerçek uygulamayı kullandığını düşünerek kötü amaçlı uygulama ile etkileşime girecektir).

Daha fazla bilgi:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android'de internal storage'da **saklanan** dosyalar onları oluşturan uygulama tarafından **yalnızca erişilebilir** olacak şekilde tasarlanmıştır. Bu güvenlik önlemi Android işletim sistemi tarafından uygulanır ve çoğu uygulamanın güvenlik ihtiyaçları için genellikle yeterlidir. Ancak geliştiriciler bazen `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` gibi modları kullanarak dosyaların farklı uygulamalar arasında paylaşılmasına izin verir. Bu modlar, bu dosyalara diğer uygulamalar (potansiyel olarak kötü amaçlı olanlar da dahil) tarafından erişimi kısıtlamaz.

1. **Statik Analiz:**
- `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` kullanımının dikkatlice incelenmesini sağlayın. Bu modlar dosyaların istenmeyen veya yetkisiz erişime maruz kalmasına yol açabilir.
2. **Dinamik Analiz:**
- Uygulama tarafından oluşturulan dosyaların üzerindeki izinleri doğrulayın. Özellikle herhangi bir dosyanın worldwide okunabilir veya yazılabilir olarak ayarlanıp ayarlanmadığını kontrol edin. Bu, cihaza yüklenmiş herhangi bir uygulamanın, kaynağı veya amacı ne olursa olsun, bu dosyaları okuyup değiştirmesine izin verebileceği için ciddi bir güvenlik riski oluşturur.

**External Storage**

SD Card gibi **external storage** üzerindeki dosyalarla uğraşırken aşağıdaki önlemler alınmalıdır:

1. **Erişilebilirlik**:
- External storage'daki dosyalar global olarak okunabilir ve yazılabilir. Yani herhangi bir uygulama veya kullanıcı bu dosyalara erişebilir.
2. **Güvenlik Endişeleri**:
- Bu kolay erişim nedeniyle hassas bilgileri external storage'da saklamamak önerilir.
- External storage çıkarılabilir veya herhangi bir uygulama tarafından erişilebilir olduğundan daha az güvenlidir.
3. **External Storage'dan Gelen Verilerin İşlenmesi**:
- External storage'dan alınan veriler üzerinde her zaman input validation yapın. Bu önemlidir çünkü veriler güvensiz bir kaynaktan gelmektedir.
- Executable veya class dosyalarını dinamik yükleme için external storage'a koymak şiddetle tavsiye edilmez.
- Uygulamanız external storage'dan executable dosyaları almak zorundaysa, bu dosyaların dinamik olarak yüklenmeden önce imzalanmış ve kriptografik olarak doğrulanmış olduğunu garanti edin. Bu adım uygulamanızın güvenlik bütünlüğü için kritik öneme sahiptir.

External storage şu yollardan erişilebilir: /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Android 4.4 (**API 17**) ile başlayarak, SD kartın bir dizin yapısı vardır ve bu yapı **bir uygulamanın sadece o uygulamaya özel dizine erişimini sınırlar**. Bu, kötü amaçlı bir uygulamanın başka bir uygulamanın dosyalarına okuma veya yazma erişimi elde etmesini engeller.

**Açık metin halinde saklanan hassas veriler**

- **Shared preferences**: Android her uygulamanın kolayca xml dosyaları `/data/data/<packagename>/shared_prefs/` yoluna kaydetmesine izin verir ve bazen bu klasörde açık metin halinde hassas bilgiler bulunabilir.
- **Databases**: Android her uygulamanın kolayca sqlite veritabanlarını `/data/data/<packagename>/databases/` yoluna kaydetmesine izin verir ve bazen bu klasörde açık metin halinde hassas bilgiler bulunabilir.

### Broken TLS

**Accept All Certificates**

Bazı nedenlerden dolayı geliştiriciler bazen hostname eşleşmesi gibi durumlar sağlanmasa bile tüm sertifikaları kabul ederler; örneğin aşağıdaki gibi kod satırlarıyla:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Bunu test etmenin iyi bir yolu, cihaz içinde Burp CA'ya yetki vermeden Burp gibi bir proxy kullanarak trafiği yakalamaya çalışmaktır. Ayrıca, Burp ile farklı bir hostname için bir sertifika oluşturup kullanabilirsiniz.

### Kırık Kriptografi

**Zayıf Anahtar Yönetimi Süreçleri**

Bazı geliştiriciler hassas verileri yerel depolamada saklar ve bunları koda gömülü/öngörülebilir bir anahtarla şifreler. Bu yapılmamalıdır; çünkü tersine mühendislik saldırganların gizli bilgileri çıkarmasına izin verebilir.

**Güvensiz ve/veya Kullanımdan Kaldırılmış Algoritmaların Kullanımı**

Geliştiriciler yetkilendirme **kontrolleri** yapmak, veriyi **saklamak** veya **göndermek** için **kullanımdan kaldırılmış algoritmaları** kullanmamalıdır. Bu algoritmalardan bazıları: RC4, MD4, MD5, SHA1... Örneğin şifreleri saklamak için **hash'ler** kullanılıyorsa, tuz (salt) ile birlikte brute-force'a dayanıklı hash'ler kullanılmalıdır.

### Diğer kontroller

- APK'nin obfuscate edilmesi, tersine mühendislik işini saldırganlar için zorlaştırmak açısından önerilir.
- Eğer uygulama hassassa (ör. banka uygulamaları), cihazın **rootlu** olup olmadığını kontrol eden kendi kontrollerini yapmalı ve buna göre davranmalıdır.
- Eğer uygulama hassassa (ör. banka uygulamaları), bir **emülatör** kullanılıp kullanılmadığını kontrol etmelidir.
- Eğer uygulama hassassa (ör. banka uygulamaları), çalıştırmadan önce kendi bütünlüğünü kontrol ederek değiştirilip değiştirilmediğini doğrulamalıdır.
- Hangi compiler/packer/obfuscator kullanılarak APK'nin oluşturulduğunu kontrol etmek için [**APKiD**](https://github.com/rednaga/APKiD) kullanın

### React Native Application

React uygulamalarının javascript koduna nasıl kolay erişileceğini öğrenmek için aşağıdaki sayfayı okuyun:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Bir Xamarin uygulamasının C# koduna nasıl kolay erişileceğini öğrenmek için aşağıdaki sayfayı okuyun:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Bu [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)'a göre superpacked, bir uygulamanın içeriğini tek bir dosyaya sıkıştıran bir Meta algoritmadır. Blog, bu tür uygulamaları açan bir uygulama oluşturma imkanından bahseder... ve daha hızlı bir yol olarak uygulamayı **çalıştırıp dosya sisteminden dekomprese edilmiş dosyaları toplamak** yönteminden söz eder.

### Automated Static Code Analysis

[**mariana-trench**](https://github.com/facebook/mariana-trench) aracı, uygulamanın **kodunu** **tarayarak** **zayıflıkları** bulma yeteneğine sahiptir. Bu araç, **bilinen kaynaklar**ı (tool'a **input**'un **kullanıcı tarafından kontrol edildiği** yerleri gösterir), **sinks**leri (kötü amaçlı kullanıcı girdisinin zarar verebileceği **tehlikeli** yerleri tool'a gösterir) ve **kurallar**ı içerir. Bu kurallar, bir zafiyeti gösteren **source-sink** kombinasyonlarını belirtir.

Bu bilgiyle, **mariana-trench kodu gözden geçirerek olası zafiyetleri bulacaktır**.

### Secrets leaked

Bir uygulama içinde keşfedebileceğiniz gizli bilgiler (API anahtarları, parolalar, gizli url'ler, subdomain'ler...) bulunabilir. [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) gibi bir araç kullanabilirsiniz

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Diğer ilginç fonksiyonlar

- **Kod yürütme**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **SMS gönderme**: `sendTextMessage, sendMultipartTestMessage`
- **Native fonksiyonlar** declared as `native`: `public native, System.loadLibrary, System.load`
- [Bunu okuyun ve **native fonksiyonların nasıl tersine çevrileceğini öğrenin**](reversing-native-libraries.md)
- JNI aracılığıyla bellek içi native kod yürütme (indirilen shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Diğer hileler**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamik Analiz

> Öncelikle uygulamayı ve gerekli tüm bileşenleri (özellikle Burp CA sertifikası, Drozer ve Frida) yükleyebileceğiniz bir ortama ihtiyacınız var. Bu yüzden rootlu bir cihaz (emüle edilmiş ya da değil) şiddetle önerilir.

### Online Dynamic analysis

Şu adreste **ücretsiz hesap** oluşturabilirsiniz: [https://appetize.io/](https://appetize.io). Bu platform APK'leri **yüklemenize** ve **çalıştırmanıza** izin verdiği için bir APK'nin nasıl davrandığını görmek açısından faydalıdır.

Uygulamanızın **loglarını** web üzerinde görebilir ve **adb** ile bağlanabilirsiniz.

![](<../../images/image (831).png>)

ADB bağlantısı sayesinde emülatörler içinde **Drozer** ve **Frida** kullanabilirsiniz.

### Local Dynamic Analysis

#### Emülatör kullanımı

- [**Android Studio**](https://developer.android.com/studio) ( **x86** ve **arm** cihazlar oluşturabilirsiniz ve [**bu**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)'ya göre en son x86 sürümleri ARM kütüphanelerini yavaş bir arm emülatöre ihtiyaç duymadan destekler).
- Ayarlamayı bu sayfada öğrenin:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Ücretsiz sürüm:** Personal Edition, bir hesap oluşturmanız gerekir. _Olası hatalardan kaçınmak için **VirtualBox İLE** olan sürümü **indirmeniz** önerilir._)
- [**Nox**](https://es.bignox.com) (Ücretsiz, ancak Frida veya Drozer'ı desteklemez).

> [!TIP]
> Yeni bir emülatör oluştururken ekran ne kadar büyükse emülatör o kadar yavaş çalışır. Mümkünse küçük ekranlar seçin.

Genymotion'da **Google hizmetlerini** (ör. Play Store) kurmak için aşağıdaki resimde kırmızı ile işaretlenmiş butona tıklamanız gerekir:

![](<../../images/image (277).png>)

Ayrıca, Genymotion'daki **Android VM yapılandırmasında** **Bridge Network mode** seçebileceğinizi unutmayın (bu, araçların bulunduğu farklı bir VM'den Android VM'e bağlanacaksanız faydalı olacaktır).

#### Fiziksel cihaz kullanımı

Önce **hata ayıklama (debugging)** seçeneklerini etkinleştirmeniz gerekir ve cihazı **root** yapabiliyorsanız bu faydalı olacaktır:

1. **Ayarlar**.
2. (Android 8.0 ve sonrası) **Sistem**'i seçin.
3. **Telefon hakkında (About phone)**'u seçin.
4. **Build number** üzerine 7 kez basın.
5. Geri dönün ve **Developer options**'ı bulacaksınız.

> Uygulamayı yükledikten sonra ilk yapmanız gereken onu çalıştırıp ne yaptığını, nasıl çalıştığını araştırmak ve alışmaktır. Bu ilk dinamik analizi **MobSF dynamic analysis + pidcat** kullanarak yapmanızı öneririm; böylece MobSF birçok ilginç veriyi yakalarken uygulamanın nasıl çalıştığını öğrenebileceğiz.

Magisk/Zygisk hızlı notlar (özellikle Pixel cihazlarda önerilir)
- systemless root almak için Magisk uygulaması ile boot.img'i patch'leyin ve fastboot ile flashlayın
- Root gizlemek için Zygisk + DenyList'i etkinleştirin; daha güçlü gizleme gerektiğinde LSPosed/Shamiko düşünün
- OTA güncellemelerinden kurtulmak için orijinal boot.img'i saklayın; her OTA'dan sonra yeniden patch'leyin
- Ekran yansıtma için host üzerinde scrcpy kullanın



### Unintended Data Leakage

**Logging**

Geliştiriciler **debugging bilgilerini** herkese açık şekilde ifşa etmeye dikkat etmelidir; çünkü bu hassas verilerin leak olmasına yol açabilir. Uygulama loglarını izleyip hassas bilgileri tespit etmek ve korumak için [**pidcat**](https://github.com/JakeWharton/pidcat) ve `adb logcat` araçları önerilir. **Pidcat**, kullanım kolaylığı ve okunabilirliği nedeniyle tercih edilir.

> [!WARNING]
> Android 4.0'dan sonraki sürümlerden itibaren **uygulamalar yalnızca kendi loglarına erişebilir**. Bu yüzden uygulamalar diğer uygulamaların loglarına erişemez.\
> Yine de, hassas bilgileri **loglamamak** hâlâ önerilir.

**Kopyala/Yapıştır Panosu**

Android'in **panoya dayalı** framework'ü uygulamalarda kopyala-yapıştır işlevi sağlar, ancak **diğer uygulamalar** panoya **erişebildiği** için bu bir risktir; potansiyel olarak hassas verileri leak edebilir. Kredi kartı bilgileri gibi hassas bölümler için kopyala/yapıştır fonksiyonlarını devre dışı bırakmak önemlidir.

**Çökme Logları**

Eğer bir uygulama **çöküyor** ve **log kaydediyorsa**, bu loglar özellikle uygulama tersine mühendisliğe uğrayamıyorsa saldırganlara yardımcı olabilir. Bu riski azaltmak için çökme durumlarında log tutmaktan kaçının ve loglar ağ üzerinden gönderilecekse güvenlik için SSL kanalı ile gönderildiğinden emin olun.

Bir pentester olarak, **bu loglara göz atmayı deneyin**.

**Analitik Verilerin 3. Taraflara Gönderilmesi**

Uygulamalar genellikle Google Adsense gibi servisleri entegre eder; geliştiricilerin hatalı uygulamaları nedeniyle bu servisler istemeden hassas verileri leak edebilir. Olası veri leak'lerini tespit etmek için uygulamanın trafiğini intercept edip üçüncü taraf hizmetlere gönderilen hassas bilgiler olup olmadığını kontrol etmek önerilir.

### SQLite DB'leri

Çoğu uygulama bilgileri saklamak için **internal SQLite veritabanları** kullanır. Pentest sırasında oluşturulmuş **veritabanlarına**, **tabloların** ve **sütunların** adlarına ve saklanan **tüm verilere** bakın; çünkü **hassas bilgiler** (ve bu bir zafiyet olur) bulabilirsiniz.\
Veritabanları genellikle `/data/data/the.package.name/databases` gibi bir konumda olmalıdır; örn `/data/data/com.mwr.example.sieve/databases`

Eğer veritabanı gizli bilgileri kaydediyor ve **şifreliyse** fakat uygulamanın içinde **parolayı** bulabiliyorsanız bu hâlâ bir **zafiyettir**.

Tabloları `.tables` ile listeleyin ve tabloların sütunlarını `.schema <table_name>` ile listeleyin.

### Drozer (Exploit Activities, Content Providers and Services)

Drozer Docs'a göre: **Drozer**, size bir Android uygulamasının rolünü üstlenme ve diğer uygulamalarla etkileşimde bulunma imkanı verir. Yüklü bir uygulamanın yapabileceği **her şeyi** yapabilir; örneğin Android’in Inter-Process Communication (IPC) mekanizmasını kullanmak ve alttaki işletim sistemi ile etkileşime geçmek gibi.\
Drozer, sonraki bölümlerde öğreneceğiniz gibi **export edilmiş aktiviteleri, export edilmiş servisleri ve Content Provider'ları exploit etmek** için kullanışlı bir araçtır.

### Export Edilen Activity'leri Exploit Etme

[**Android Activity'nin ne olduğunu hatırlamak isterseniz bunu okuyun.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ayrıca, bir activity'nin kodunun **`onCreate`** metodunda başladığını unutmayın.

**Authorisation bypass**

Bir Activity export edilmişse ekranını harici bir uygulamadan çağırabilirsiniz. Bu nedenle, hassas bilgi içeren bir activity export edilmişse, ona erişmek için **kimlik doğrulama** mekanizmalarını **bypass** edebilirsiniz.

[**Export edilmiş activity'leri Drozer ile nasıl exploit edeceğinizi öğrenin.**](drozer-tutorial/index.html#activities)

Ayrıca adb ile export edilmiş bir activity'i başlatabilirsiniz:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Yetkilendirme bypass'ı her zaman bir zafiyet değildir; bypass'ın nasıl çalıştığına ve hangi bilgilerin ifşa edildiğine bağlıdır.

**Hassas bilgi sızıntısı**

**Activities can also return results**. Eğer exported ve korunmasız bir activity bulup `setResult` metodunu çağırıp **hassas bilgi döndürdüğünü** tespit ederseniz, bu bir hassas bilgi sızıntısıdır.

#### Tapjacking

Eğer Tapjacking önlenmemişse, exported activity'yi suistimal ederek **kullanıcının beklenmedik eylemler gerçekleştirmesini** sağlayabilirsiniz. Daha fazla bilgi için [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers temel olarak **veri paylaşımı** için kullanılır. Eğer bir uygulamanın kullanılabilir content providers'ı varsa bunlardan **hassas veri** çıkarabilirsiniz. Ayrıca mümkün olan **SQL injections** ve **Path Traversals**'ı test etmek ilginçtir çünkü bunlar zafiyetli olabilir.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Unutmayın ki bir Service'in işlemleri `onStartCommand` metodunda başlar.

Service temel olarak **veri alabilen**, **işleyebilen** ve **(isteğe bağlı) cevap döndürebilen** bir yapıdır. Bu yüzden eğer bir uygulama bazı services export ediyorsa, ne yaptığını anlamak için **kodu** incelemeli ve gizli bilgileri çıkarmak, yetkilendirme önlemlerini bypass etmek için dinamik olarak **test** etmelisiniz.\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Unutmayın ki bir Broadcast Receiver'ın işlemleri `onReceive` metodunda başlar.

Bir broadcast receiver belirli bir tür mesajı bekler. Alıcının mesajı nasıl işlediğine bağlı olarak zafiyetli olabilir.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Deep links'i elle arayabilirsiniz; MobSF gibi araçlar veya [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) gibi script'ler kullanarak.\
Declare edilmiş bir **scheme**'i **adb** veya bir **browser** ile açabilirsiniz:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Paket adını **belirtmeyebileceğinizi** unutmayın; cihaz, o bağlantıyı açması gereken uygulamayı otomatik olarak çağıracaktır._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Çalıştırılan kod**

Uygulamada çalıştırılacak **kodu** bulmak için, deeplink tarafından çağrılan activity'ye gidin ve **`onNewIntent`** fonksiyonunu arayın.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

Her deep link bulduğunuzda, **URL parametreleri aracılığıyla hassas veri (ör. şifreler) almadığından emin olun**, çünkü herhangi bir uygulama **deep link'i taklit edip bu verileri çalabilir!**

**Parameters in path**

URL'nin path kısmında parametre kullanıp kullanmadığını da **mutlaka kontrol etmelisiniz**, örneğin: `https://api.example.com/v1/users/{username}` , bu durumda path traversal zorlayarak şuna benzer bir erişim yapabilirsiniz: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note that if you find the correct endpoints inside the application you may be able to cause a **Open Redirect** (if part of the path is used as domain name), **account takeover** (if you can modify users details without CSRF token and the vuln endpoint used the correct method) and any other vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Bağlantılar hakkında bir [interesting bug bounty report](https://hackerone.com/reports/855618) (_/.well-known/assetlinks.json_).

### Taşıma Katmanı İncelemesi ve Doğrulama Hataları

- **Certificates are not always inspected properly** by Android applications. It's common for these applications to overlook warnings and accept self-signed certificates or, in some instances, revert to using HTTP connections.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, employing insecure cipher suites. This vulnerability makes the connection susceptible to man-in-the-middle (MITM) attacks, allowing attackers to decrypt the data.
- **Leakage of private information** is a risk when applications authenticate using secure channels but then communicate over non-secure channels for other transactions. This approach fails to protect sensitive data, such as session cookies or user details, from interception by malicious entities.

#### Certificate Verification

We will focus on **certificate verification**. Sunucunun sertifikasının bütünlüğü güvenliği artırmak için doğrulanmalıdır. Bu önemlidir çünkü zayıf TLS konfigürasyonları ve hassas verilerin şifrelenmemiş kanallar üzerinden iletilmesi ciddi riskler oluşturabilir. Sunucu sertifikalarının doğrulanması ve zafiyetlerin giderilmesine dair detaylı adımlar için, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) kapsamlı rehberlik sağlar.

#### SSL Pinning

SSL Pinning, uygulamanın sunucunun sertifikasını uygulama içinde saklanan bilinen bir kopyayla doğruladığı bir güvenlik önlemidir. Bu yöntem MITM saldırılarını önlemek için elzemdir. Hassas bilgi işleyen uygulamalar için SSL Pinning uygulanması şiddetle tavsiye edilir.

#### Traffic Inspection

HTTP trafiğini incelemek için, **proxy aracının sertifikasını yüklemeniz** gerekir (ör. Burp). Bu sertifika yüklenmeden, şifrelenmiş trafik proxy üzerinden görünmeyebilir. Custom CA sertifikası yükleme rehberi için [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

API Level 24 ve üzerini hedefleyen uygulamalar, proxy'nin CA sertifikasını kabul etmesi için Network Security Config üzerinde değişiklikler gerektirir. Bu adım şifrelenmiş trafiği incelemek için kritiktir. Network Security Config'i değiştirme talimatları için [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). This is becasue, just adding the certificate into the store won't work as Flutter has its own list of valid CAs.

#### Static detection of SSL/TLS pinning

Runtime bypasslara girişmeden önce, APK içinde pinning'in nerede uygulandığını hızlıca haritalayın. Statik keşif, hooks/patches planlamanıza ve doğru kod yollarına odaklanmanıza yardımcı olur.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Kullanım
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Örnek desen kuralları (JSON)
İmzaları kullanarak veya genişleterek özgü/özelleştirilmiş pinning stillerini tespit edin. Kendi JSON'unuzu yükleyebilir ve geniş ölçekte tarama yapabilirsiniz.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Büyük uygulamalarda çoklu iş parçacığı ve memory-mapped I/O ile hızlı tarama; ön-derlenmiş regex'ler overhead/false positive'i azaltır.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Sonraki önceliklendirme için tipik tespit hedefleri:
- OkHttp: CertificatePinner kullanımı, setCertificatePinner, okhttp3/okhttp paket referansları
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted override'ları
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init ile custom manager'lar
- Declarative pins in res/xml network security config ve manifest referansları
- Eşleşen konumları Frida hook'ları, statik yamalar veya yapılandırma incelemeleri planlamak için dinamik testlerden önce kullanın.



#### SSL Pinning'i Aşma

SSL Pinning uygulandığında HTTPS trafiğini incelemek için bunu aşmak gerekir. Bu amaçla çeşitli yöntemler mevcuttur:

- APK'yı otomatik olarak **değiştirip** SSLPinning'i **bypass** etmek için [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) kullanın. Bu seçeneğin en büyük avantajı, SSL Pinning'i bypass etmek için root gerekmemesi, ancak uygulamayı silip yeni olanı yeniden yüklemeniz gerekeceği ve her zaman çalışmayabileceğidir.
- Bu korumayı aşmak için **Frida** (aşağıda tartışılıyor) kullanabilirsiniz. Burp+Frida+Genymotion kullanımı için kılavuz: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- [**objection**](frida-tutorial/objection-tutorial.md) kullanarak SSL Pinning'i **otomatik olarak bypass** etmeyi de deneyebilirsiniz:**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dynamic analysis** kullanarak SSL Pinning'i **otomatik olarak bypass** etmeyi de deneyebilirsiniz (aşağıda açıklanıyor)
- Hâlâ yakalayamadığınız trafik olduğunu düşünüyorsanız trafiği iptables kullanarak burp'a yönlendirmeyi deneyebilirsiniz. Bu blogu okuyun: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Yaygın Web Zafiyetlerini Arama

Uygulama içinde yaygın web zafiyetlerini aramak da önemlidir. Bu zafiyetleri tespit etme ve hafifletme hakkında ayrıntılı bilgi bu özetin kapsamı dışındadır ancak başka yerlerde kapsamlı olarak ele alınmıştır.

### Frida

[Frida](https://www.frida.re) geliştiriciler, tersine mühendisler ve güvenlik araştırmacıları için bir dinamik enstrümantasyon toolkit'idir.\
**Çalışan uygulamaya erişip çalışma zamanında yöntemleri hook'layarak davranışı değiştirebilir, değerleri değiştirebilir, değerleri çıkarabilir, farklı kod çalıştırabilirsiniz...**\
Android uygulamalarını pentest etmek istiyorsanız Frida'yı nasıl kullanacağınızı bilmelisiniz.

- Frida'yı nasıl kullanacağınızı öğrenin: [**Frida tutorial**](frida-tutorial/index.html)
- Frida ile yapılacak işlemler için bazı "GUI"ler: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection, Frida kullanımını otomatikleştirmek için harikadır: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Bazı harika Frida script'lerini burada bulabilirsiniz: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Anti-debugging / anti-frida mekanizmalarını atlamak için Frida'yı aşağıda belirtildiği gibi yüklemeyi deneyin: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Uygulamanın parola veya mnemonic gibi saklamaması gereken hassas bilgileri bellekte tutup tutmadığını kontrol edin.

[**Fridump3**](https://github.com/rootbsd/fridump3) kullanarak uygulamanın belleğini şu şekilde dökebilirsiniz:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Bu, belleği ./dump klasörüne dökecek ve orada şöyle bir grep kullanabilirsiniz:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore içindeki hassas veriler**

Android'de Keystore hassas verileri saklamak için en iyi yerdir, ancak yeterli ayrıcalıkla yine de ona **erişmek mümkün**. Uygulamalar genellikle burada **açık metin halinde hassas veriler** depolamaya meyillidir; bu yüzden pentests bunu kontrol etmelidir, çünkü root user veya cihaza fiziksel erişimi olan biri bu verileri çalabilir.

Bir uygulama verileri Keystore'da saklasa bile, veriler şifrelenmiş olmalıdır.

Keystore içindeki verilere erişmek için bu Frida script'ini kullanabilirsiniz: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Aşağıdaki Frida script'ini kullanarak, Android uygulamalarının belirli **hassas alanları korumak** amacıyla uygulamış olabileceği **bypass fingerprint authentication** işlemi mümkün olabilir:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Arka Plan Görüntüleri**

Bir uygulamayı arka plana attığınızda, Android uygulamanın bir **anlık görüntüsünü** saklar; böylece uygulama ön plana geri getirildiğinde uygulama yüklenmeden önce bu görüntüyü yüklemeye başlar ve uygulama daha hızlı açılmış gibi görünür.

Ancak bu anlık görüntü **hassas bilgi** içeriyorsa, anlık görüntüye erişimi olan biri bu bilgiyi **çalabilir** (erişim için root gerektiğini unutmayın).

Anlık görüntüler genellikle şu konumda saklanır: **`/data/system_ce/0/snapshots`**

Android, **FLAG_SECURE ayarlanarak ekran görüntüsü alınmasını engelleyen** bir layout parametresi sağlar. Bu flag kullanıldığında, pencere içeriği güvenli olarak işaretlenir; böylece ekran görüntülerinde görünmesi veya güvenli olmayan ekranlarda görüntülenmesi engellenir.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Bu araç, dynamic analysis sırasında farklı araçları yönetmenize yardımcı olabilir: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Geliştiriciler genellikle bu Intent'leri işleyen ve `startActivity(...)` veya `sendBroadcast(...)` gibi yöntemlere ileten activities, services ve broadcast receivers gibi proxy bileşenler oluşturur; bu durum riskli olabilir.

Tehlike, saldırganların bu Intent'leri yanlış yönlendirerek non-exported uygulama bileşenlerini tetiklemesine veya hassas content providers'a erişmesine izin verilmesindedir. Örnek olarak, `WebView` bileşeninin URL'leri `Intent` objelerine `Intent.parseUri(...)` aracılığıyla dönüştürüp sonra çalıştırması, potansiyel olarak kötü niyetli Intent enjeksiyonlarına yol açabilir.

### Temel Çıkarımlar

- **Intent Injection**, web'deki Open Redirect sorununa benzer.
- Exploit'ler, `Intent` objelerini extras olarak geçirmeyi ve bunların unsafe işlemleri çalıştırmak üzere yönlendirilmesini içerir.
- Bu, non-exported bileşenleri ve content providers'ı saldırganlara açabilir.
- `WebView`'in URL'den `Intent` dönüşümü istenmeyen işlemleri kolaylaştırabilir.

### Android Client Side Injections and others

Muhtemelen bu tür zafiyetleri web'den biliyorsunuzdur. Bir Android uygulamasında bu zafiyetlere özellikle dikkat etmelisiniz:

- **SQL Injection:** dynamic sorgular veya Content-Providers ile çalışırken parameterized queries kullandığınızdan emin olun.
- **JavaScript Injection (XSS):** Herhangi bir WebView için JavaScript ve Plugin desteğinin devre dışı olduğundan emin olun (varsayılan olarak devre dışı). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebView'lerin dosya sistemine erişimi kapalı olmalıdır (varsayılan olarak açık) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies:** Bazı durumlarda Android uygulaması oturumu kapattığında cookie iptal edilmiyor ya da diske kaydediliyor olabilir.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Otomatik Analiz

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statik analiz**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Dikkat: MobSF **Android**(apk)**, IOS**(ipa) **and Windows**(apx) uygulamalarını analiz edebilir (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Ayrıca, eğer bir **Android** veya bir **IOS** uygulamasının kaynak koduyla bir **ZIP** dosyası (uygulamanın kök klasörüne gidin, her şeyi seçin ve bir ZIPfile oluşturun) oluşturursanız, bunu da analiz edebilecektir.

MobSF ayrıca analizleri **diff/Compare** etmenize ve **VirusTotal** ile entegrasyon sağlamanıza izin verir (API anahtarınızı _MobSF/settings.py_ içinde ayarlamanız ve etkinleştirmeniz gerekir: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). `VT_UPLOAD`'u `False` olarak ayarlayabilirsiniz, bu durumda dosya yerine **hash** **upload** edilecektir.

### MobSF ile Yardımlı Dinamik analiz

**MobSF**, **Android** için **dinamik analiz**de de çok yardımcı olabilir; ancak bu durumda hostunuza MobSF ve **genymotion** kurmanız gerekir (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** şunları yapabilir:

- **Dump application data** (URL'ler, loglar, clipboard, sizin aldığınız ekran görüntüleri, "**Exported Activity Tester**" tarafından alınan ekran görüntüleri, e-postalar, SQLite veritabanları, XML dosyaları ve diğer oluşturulan dosyalar). Bunların hepsi otomatik yapılır; sadece ekran görüntüleri için ekran görüntüsü almak istediğinizde butona basmanız veya tüm exported activity'lerin ekran görüntülerini almak için "**Exported Activity Tester**"e basmanız gerekir.
- **Capture HTTPS traffic**
- **Frida** kullanarak **runtime** **information** elde etmek

Android **versions > 5**'ten itibaren, **Frida'yı otomatik başlatır** ve trafiği **capture** etmek için global **proxy** ayarlarını yapar. Sadece test edilen uygulamanın trafiğini yakalar.

**Frida**

Varsayılan olarak, bazı Frida Scripts'leri SSL pinning'i **bypass**, **root detection** ve **debugger detection**'ı atlatmak ve ilginç API'leri **monitor** etmek için kullanır.\
MobSF ayrıca **invoke exported activities** yapabilir, bunların **screenshots**larını alabilir ve rapor için **save** edebilir.

Dinamik testi **başlatmak** için yeşil butona basın: "**Start Instrumentation**". Frida script'lerinin ürettiği logları görmek için "**Frida Live Logs**" a, hooklanmış metodlara yapılan tüm çağrıları, geçirilen argümanları ve dönen değerleri görmek için "**Live API Monitor**"a basın (bu, "Start Instrumentation" a bastıktan sonra görünecektir).\
MobSF ayrıca kendi **Frida scripts**lerinizi yüklemenize izin verir (Frida script'lerinizin sonuçlarını MobSF'ye göndermek için `send()` fonksiyonunu kullanın). Ayrıca yükleyebileceğiniz **several pre-written scripts** bulunur (daha fazlasını `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` içine ekleyebilirsiniz), bunları **select** edip "**Load**"a ve ardından "**Start Instrumentation**"a basın (bu script'lerin loglarını "**Frida Live Logs**" içinde göreceksiniz).

![](<../../images/image (419).png>)

Ayrıca bazı Ek Frida fonksiyonları mevcuttur:

- **Enumerate Loaded Classes**: Yüklenen tüm sınıfları yazdırır
- **Capture Strings**: Uygulamayı kullanırken yakalanan tüm stringleri yazdırır (çok gürültülü)
- **Capture String Comparisons**: Çok kullanışlı olabilir. Karşılaştırılan 2 stringi gösterir ve sonucun True mı False mı olduğunu belirtir.
- **Enumerate Class Methods**: Sınıf adını girin (ör. "java.io.File") ve sınıfın tüm metodlarını yazdırır.
- **Search Class Pattern**: Desene göre sınıfları arar
- **Trace Class Methods**: Bir sınıfın tamamını **Trace** eder (sınıftaki tüm metodların giriş ve çıkışlarını görür). Varsayılan olarak MobSF birkaç ilginç Android Api metodunu trace eder.

İstediğiniz yardımcı modülü seçtikten sonra "**Start Intrumentation**" a basmanız gerekir ve tüm çıktıları "**Frida Live Logs**" içinde göreceksiniz.

**Shell**

MobSF ayrıca dynamic analysis sayfasının altında bazı **adb** komutları, **MobSF commands**, ve yaygın **shell** **commands** içeren bir shell sağlar. Bazı ilginç komutlar:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP araçları**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" buton or a nicer view in "**Start HTTPTools**" green buton. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage ile Destekli Dinamik Analiz

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
This tool with use some **Hooks** to let you know **what is happening in the application** while you perform a **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Kolay referans için çıkarılan tüm dosyaları gösterir
- APK dosyalarını otomatik olarak Java ve Smali formatına decompile eder
- AndroidManifest.xml'ü yaygın vulnerabilities ve davranışlar açısından analiz eder
- Statik kaynak kod analizi ile yaygın vulnerabilities ve davranışları tespit eder
- Cihaz bilgileri
- ve daha fazlası
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER, Windows, MacOS X ve Linux'ta kullanılabilen bir komut satırı uygulamasıdır; _.apk_ dosyalarını güvenlik açıkları aramak için analiz eder. Bunu APK'ları açıp, bu güvenlik açıklarını tespit etmek için bir dizi kural uygulayarak yapar.

Tüm kurallar `rules.json` dosyasında toplanmıştır ve her şirket veya test uzmanı ihtiyaçlarına göre kendi kurallarını oluşturabilir.

En son ikili dosyaları [download page](https://superanalyzer.rocks/download.html) üzerinden indirin.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn, mobil uygulamalarda [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) yapan geliştiricilere, bugbounty hunters ve ethical hackers'a yardımcı olan bir **crossplatform** araçtır.

Konsept şu: mobil uygulama dosyanızı (.apk veya .ipa dosyası) StaCoAn uygulamasına sürükleyip bırakırsınız ve sizin için görsel ve taşınabilir bir rapor oluşturur. Ayarları ve wordlists'i değiştirerek özelleştirilmiş bir deneyim elde edebilirsiniz.

İndir [ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework, geliştiricilerin veya hackers'ın Android uygulamalarındaki potansiyel güvenlik açıklarını bulmasına yardımcı olan bir Android güvenlik açığı analiz sistemidir.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**, bir Android uygulamasının geliştirdiği potansiyel kötü amaçlı davranışları tespit etmek ve kullanıcıyı uyarmak amacıyla oluşturulmuş bir araçtır.

Tespit, uygulamanın Dalvik bytecode'unun **Smali** olarak temsil edilen **static analysis** ile [`androguard`](https://github.com/androguard/androguard) kütüphanesi kullanılarak gerçekleştirilir.

Bu araç, **kötü uygulamaların ortak davranışları** gibi şunları arar: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Bu, yaygın olarak kullanılan mobil uygulama reverse engineering ve analysis araçlarını bir araya getiren bir araçtır; OWASP mobile security tehditlerine karşı mobil uygulamaları test etmeye yardımcı olur. Amacı, bu görevi mobil uygulama geliştiricileri ve güvenlik profesyonelleri için daha kolay ve kullanıcı dostu hale getirmektir.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Useful to detect malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Note that depending the service and configuration you use to obfuscate the code. Secrets may or may not ended obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

You can upload an obfuscated APK to their platform.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Harika bir kaynak listesi
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
