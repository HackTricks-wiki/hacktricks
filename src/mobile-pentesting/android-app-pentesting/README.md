# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android-Anwendungsgrundlagen

Es wird dringend empfohlen, diese Seite zuerst zu lesen, um die **wichtigsten Teile in Bezug auf Android-Sicherheit und die gefährlichsten Komponenten in einer Android-Anwendung** kennenzulernen:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dies ist das Hauptwerkzeug, das du brauchst, um eine Android-Gerät (emuliert oder physisch) zu verbinden.\
**ADB** erlaubt die Steuerung von Geräten entweder über **USB** oder **Netzwerk** von einem Computer aus. Dieses Utility ermöglicht das **Kopieren** von Dateien in beide Richtungen, die **Installation** und **Deinstallation** von Apps, die **Ausführung** von Shell-Befehlen, das **Sichern** von Daten, das **Lesen** von Logs, sowie weitere Funktionen.

Sieh dir die folgende Liste von [**ADB Commands**](adb-commands.md) an, um zu lernen, wie man adb benutzt.

## Smali

Manchmal ist es interessant, den **Anwendungscode zu modifizieren**, um auf **versteckte Informationen** zuzugreifen (vielleicht stark obfuskierte Passwörter oder flags). Dann kann es sinnvoll sein, die apk zu dekompilieren, den Code zu ändern und sie wieder zu kompilieren.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Das kann sehr nützlich sein als **Alternative für verschiedene Tests während der dynamischen Analyse**, die weiter unten vorgestellt werden. Behalte diese Möglichkeit also **immer im Hinterkopf**.

## Weitere interessante Tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Alle Splits und base apks mit [APKEditor](https://github.com/REAndroid/APKEditor) zusammenführen:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Fallstudien & Schwachstellen


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statische Analyse

Zuerst solltest du zur Analyse einer APK den Java-Code mit einem decompiler betrachten.\
Bitte, [**lies hier, um Informationen über verschiedene verfügbare decompiler zu finden**](apk-decompilers.md).

### Nach interessanten Informationen suchen

Schon durch das einfache Betrachten der **strings** der APK kannst du nach **Passwörtern**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API-Keys**, **Verschlüsselungsangaben**, **Bluetooth-UUIDs**, **Tokens** und allem anderen Interessanten suchen... achte auch auf Code-Ausführungs-Backdoors oder Authentifizierungs-Backdoors (hartkodierte Admin-Zugangsdaten in der App).

**Firebase**

Achte besonders auf **Firebase URLs** und prüfe, ob sie falsch konfiguriert sind. [Mehr Informationen darüber, was Firebase ist und wie man es ausnutzen kann, findest du hier.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Grundlegendes Verständnis der Anwendung - Manifest.xml, strings.xml

Die **Untersuchung der _Manifest.xml_ und der **_strings.xml_** einer Anwendung kann potenzielle Sicherheitslücken offenbaren**. Auf diese Dateien kann mit Decompilern zugegriffen werden oder indem man die APK-Endung in .zip ändert und sie entpackt.

**Aus der _Manifest.xml_ identifizierbare Schwachstellen** umfassen:

- **Debuggable Applications**: Anwendungen, die im _Manifest.xml_ als debuggable (`debuggable="true"`) gesetzt sind, stellen ein Risiko dar, da sie Verbindungen erlauben, die zu Ausnutzung führen können. Für ein besseres Verständnis, wie man debuggable Applications auf einem Gerät findet und ausnutzt, siehe entsprechende Tutorials.
- **Backup Settings**: Das Attribut `android:allowBackup="false"` sollte explizit für Anwendungen gesetzt werden, die mit sensiblen Informationen umgehen, um unautorisierte Daten-Backups via adb zu verhindern, insbesondere wenn USB-Debugging aktiviert ist.
- **Network Security**: Eigene Netzwerk-Sicherheitskonfigurationen (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ können Sicherheitsdetails wie Certificate Pins und HTTP-Traffic-Einstellungen spezifizieren. Ein Beispiel ist das Zulassen von HTTP-Traffic für bestimmte Domains.
- **Exported Activities and Services**: Das Identifizieren exportierter Activities und Services im Manifest kann Komponenten hervorheben, die missbraucht werden könnten. Weitere Analysen während des dynamischen Testens können zeigen, wie diese Komponenten ausgenutzt werden können.
- **Content Providers and FileProviders**: Offen exponierte Content Providers könnten unbefugten Zugriff oder Manipulation von Daten erlauben. Die Konfiguration von FileProviders sollte ebenfalls überprüft werden.
- **Broadcast Receivers and URL Schemes**: Diese Komponenten könnten für Exploits genutzt werden, wobei besonderes Augenmerk darauf gelegt werden sollte, wie URL-Schemes auf Eingaben reagieren.
- **SDK Versions**: Die Attribute `minSdkVersion`, `targetSDKVersion` und `maxSdkVersion` geben die unterstützten Android-Versionen an und unterstreichen die Wichtigkeit, veraltete, verwundbare Android-Versionen nicht zu unterstützen.

Aus der **strings.xml** können sensible Informationen wie API-Keys, Custom Schemas und andere Entwicklerhinweise entdeckt werden, was die Notwendigkeit einer sorgfältigen Überprüfung dieser Ressourcen unterstreicht.

### Tapjacking

**Tapjacking** ist ein Angriff, bei dem eine **bösartige Anwendung** gestartet wird und **sich über einer Opfer-Anwendung positioniert**. Sobald sie die Opfer-App sichtbar überdeckt, ist ihre Benutzeroberfläche so gestaltet, dass der Benutzer getäuscht wird, mit ihr zu interagieren, während die Interaktion an die Opfer-App weitergereicht wird.\
Effektiv wird der Benutzer **davon abgehalten zu wissen, dass er tatsächlich Aktionen in der Opfer-App ausführt**.

Weitere Informationen findest du in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Eine **Activity** mit dem **`launchMode`** auf **`singleTask`** gesetzt ohne definierte **`taskAffinity`** ist für Task Hijacking anfällig. Das bedeutet, dass eine **Anwendung** installiert werden kann und, wenn sie vor der echten Anwendung gestartet wird, **die Task der echten Anwendung kapern** könnte (so dass der Benutzer mit der **bösartigen Anwendung interagiert und glaubt, die echte App zu nutzen**).

Mehr Infos in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Unsichere Datenspeicherung

**Interner Speicher**

In Android sind Dateien, die im **internen Speicher** abgelegt werden, so ausgelegt, dass sie ausschließlich von der App, die sie erstellt hat, zugänglich sind. Diese Sicherheitsmaßnahme wird vom Android-Betriebssystem durchgesetzt und ist für die meisten Anwendungen ausreichend. Entwickler nutzen jedoch manchmal Modi wie `MODE_WORLD_READABLE` und `MODE_WORLD_WRITABLE`, um Dateien zwischen verschiedenen Anwendungen zu teilen. Diese Modi **beschränken jedoch nicht** den Zugriff durch andere Anwendungen, einschließlich potenziell bösartiger Apps.

1. **Statische Analyse:**
- **Stelle sicher**, dass die Verwendung von `MODE_WORLD_READABLE` und `MODE_WORLD_WRITABLE` **sorgfältig geprüft** wird. Diese Modi **können Dateien für unbeabsichtigten oder unautorisierten Zugriff öffnen**.
2. **Dynamische Analyse:**
- **Überprüfe** die **Berechtigungen** von Dateien, die von der App erstellt wurden. Insbesondere **prüfe**, ob Dateien so gesetzt sind, dass sie weltweit lesbar oder beschreibbar sind. Dies kann ein erhebliches Sicherheitsrisiko darstellen, da es **jeder Anwendung** auf dem Gerät, unabhängig von Herkunft oder Absicht, erlauben würde, diese Dateien zu **lesen oder zu verändern**.

**Externer Speicher**

Beim Umgang mit Dateien auf **externem Speicher**, wie SD-Karten, sollten bestimmte Vorsichtsmaßnahmen getroffen werden:

1. **Zugänglichkeit**:
- Dateien auf externem Speicher sind **global les- und schreibbar**. Das bedeutet, jede Anwendung oder jeder Benutzer kann auf diese Dateien zugreifen.
2. **Sicherheitsbedenken**:
- Aufgrund des einfachen Zugriffs wird empfohlen, **keine sensiblen Informationen** auf externem Speicher zu speichern.
- Externer Speicher kann entfernt werden oder von jeder Anwendung ausgelesen werden, was ihn weniger sicher macht.
3. **Umgang mit Daten vom externen Speicher**:
- Führe immer **Input-Validierung** auf Daten durch, die vom externen Speicher stammen. Das ist entscheidend, da die Daten aus einer nicht vertrauenswürdigen Quelle kommen.
- Das Ablegen von ausführbaren Dateien oder class-Dateien auf externem Speicher zum dynamischen Laden wird dringend abgeraten.
- Wenn deine Anwendung unbedingt ausführbare Dateien vom externen Speicher laden muss, stelle sicher, dass diese Dateien **signiert und kryptografisch verifiziert** werden, bevor sie dynamisch geladen werden. Dieser Schritt ist entscheidend für die Sicherheit der Anwendung.

External storage kann unter /storage/emulated/0 , /sdcard , /mnt/sdcard erreicht werden

> [!TIP]
> Beginnend mit Android 4.4 (**API 17**) hat die SD-Karte eine Verzeichnisstruktur, die den Zugriff einer App auf das Verzeichnis einschränkt, das speziell für diese App vorgesehen ist. Das verhindert, dass eine bösartige Anwendung Lese- oder Schreibzugriff auf die Dateien einer anderen App erhält.

**Sensitive Daten im Klartext**

- **Shared preferences**: Android erlaubt jeder Anwendung, XML-Dateien im Pfad /data/data/<packagename>/shared_prefs/ zu speichern, und manchmal findet man in diesem Ordner sensible Informationen im Klartext.
- **Databases**: Android erlaubt jeder Anwendung, sqlite-Datenbanken im Pfad /data/data/<packagename>/databases/ zu speichern, und manchmal findet man in diesem Ordner sensible Informationen im Klartext.

### Broken TLS

**Accept All Certificates**

Aus irgendeinem Grund akzeptieren Entwickler manchmal alle Zertifikate, selbst wenn z. B. der Hostname nicht übereinstimmt, mit Codezeilen wie der folgenden:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Eine gute Möglichkeit, dies zu testen, besteht darin, zu versuchen, den Traffic mit einem Proxy wie Burp abzufangen, ohne die Burp CA im Gerät zu autorisieren. Außerdem können Sie mit Burp ein Zertifikat für einen anderen hostname erzeugen und verwenden.

### Unsichere Kryptographie

**Schlechte Schlüsselverwaltungsprozesse**

Manche Entwickler speichern sensitive Daten im lokalen Speicher und verschlüsseln sie mit einem im Code hardcodierten/vorhersehbaren Schlüssel. Das sollte nicht gemacht werden, da Reverse-Engineering Angreifern erlauben könnte, die vertraulichen Informationen zu extrahieren.

**Verwendung unsicherer und/oder veralteter Algorithmen**

Entwickler sollten keine **deprecated algorithms** verwenden, um authorisation **checks** durchzuführen, Daten zu **store** oder **send**. Einige dieser Algorithmen sind: RC4, MD4, MD5, SHA1... Wenn **hashes** z. B. verwendet werden, um Passwörter zu speichern, sollten brute-force-resistente **hashes** mit Salt verwendet werden.

### Weitere Prüfungen

- Es wird empfohlen, die APK zu obfuskieren, um die Arbeit des Reverse Engineers für Angreifer zu erschweren.
- Wenn die App sensibel ist (wie Banking-Apps), sollte sie eigene Prüfungen durchführen, um festzustellen, ob das Gerät gerootet ist, und entsprechend handeln.
- Wenn die App sensibel ist (wie Banking-Apps), sollte sie prüfen, ob ein **emulator** verwendet wird.
- Wenn die App sensibel ist (wie Banking-Apps), sollte sie ihre Integrität prüfen, bevor sie ausgeführt wird, um festzustellen, ob sie verändert wurde.
- Verwenden Sie [**APKiD**](https://github.com/rednaga/APKiD), um zu prüfen, welcher compiler/packer/obfuscator zum Erstellen der APK verwendet wurde

### React Native Application

Lies die folgende Seite, um zu erfahren, wie man einfach auf javascript code von React-Anwendungen zugreift:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Lies die folgende Seite, um zu erfahren, wie man einfach auf C# code einer Xamarin-Anwendung zugreift:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked ist ein Meta-Algorithmus, der den Inhalt einer Anwendung in eine einzelne Datei komprimiert. Der Blog beschreibt die Möglichkeit, eine App zu erstellen, die solche Apps dekomprimiert... und einen schnelleren Weg, der darin besteht, die Anwendung auszuführen und die dekomprimierten Dateien vom Dateisystem zu sammeln.

### Automatisierte statische Code-Analyse

Das Tool [**mariana-trench**](https://github.com/facebook/mariana-trench) ist in der Lage, **vulnerabilities** zu finden, indem es den **code** der Anwendung **scans**. Dieses Tool enthält eine Reihe von **known sources** (die dem Tool die **places** anzeigen, wo der **input** vom Benutzer kontrolliert wird), **sinks** (die dem Tool **dangerous** **places** anzeigen, wo bösartige Benutzereingaben Schaden anrichten könnten) und **rules**. Diese **rules** geben die **combination** von **sources-sinks** an, die auf eine **vulnerability** hinweist.

Mit diesem Wissen wird **mariana-trench** den **code** überprüfen und mögliche **vulnerabilities** darin finden.

### Secrets leaked

Eine Anwendung kann Secrets (API keys, Passwörter, versteckte urls, Subdomains...) enthalten, die Sie möglicherweise entdecken können. Sie könnten ein Tool wie [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) verwenden.

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Weitere interessante Funktionen

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamische Analyse

> Zuerst benötigen Sie eine Umgebung, in der Sie die Anwendung und alle erforderlichen Komponenten (Burp CA cert, Drozer und Frida hauptsächlich) installieren können. Daher wird ein gerootetes Gerät (emuliert oder nicht) dringend empfohlen.

### Online Dynamic analysis

Sie können einen kostenlosen Account unter: [https://appetize.io/](https://appetize.io) erstellen. Diese Plattform erlaubt es, APKs hochzuladen und auszuführen, sodass sie nützlich ist, um zu sehen, wie sich eine APK verhält.

Sie können sogar die Logs Ihrer Anwendung im Web sehen und sich über **adb** verbinden.

![](<../../images/image (831).png>)

Dank der ADB-Verbindung können Sie **Drozer** und **Frida** innerhalb der Emulatoren verwenden.

### Lokale dynamische Analyse

#### Verwendung eines Emulators

- [**Android Studio**](https://developer.android.com/studio) (Sie können **x86** und **arm** Geräte erstellen, und laut [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) unterstützen die neuesten **x86** Versionen **ARM libraries** ohne einen langsamen ARM-Emulator).
- Lernen Sie, wie man es auf dieser Seite einrichtet:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, Sie müssen ein Konto erstellen. _Es wird empfohlen, die Version **MIT** _**VirtualBox**_ herunterzuladen, um mögliche Fehler zu vermeiden._)
- [**Nox**](https://es.bignox.com) (Kostenlos, unterstützt jedoch Frida oder Drozer nicht).

> [!TIP]
> Beim Erstellen eines neuen Emulators auf jeder Plattform gilt: Je größer der Bildschirm ist, desto langsamer läuft der Emulator. Wählen Sie daher nach Möglichkeit kleine Bildschirme.

Um Google Services (wie AppStore) in Genymotion zu installieren, müssen Sie auf die im folgenden Bild rot markierte Schaltfläche klicken:

![](<../../images/image (277).png>)

Beachten Sie außerdem, dass Sie in der **Konfiguration der Android VM in Genymotion** den **Bridge Network mode** auswählen können (das ist nützlich, wenn Sie sich von einer anderen VM mit den Tools mit der Android-VM verbinden wollen).

#### Verwendung eines physischen Geräts

Sie müssen die **debugging**-Optionen aktivieren und es wäre gut, wenn Sie es **rooten** könnten:

1. **Einstellungen**.
2. (Ab Android 8.0) Wählen Sie **System**.
3. Wählen Sie **Über das Telefon**.
4. Drücken Sie **Build number** 7-mal.
5. Gehen Sie zurück und Sie finden die **Entwickleroptionen**.

> Sobald Sie die Anwendung installiert haben, sollten Sie sie zunächst ausprobieren und untersuchen, was sie tut, wie sie funktioniert und sich mit ihr vertraut machen.\
> Ich empfehle, diese anfängliche dynamische Analyse mit MobSF dynamic analysis + pidcat durchzuführen, damit wir lernen können, wie die Anwendung funktioniert, während MobSF viele interessante Daten erfasst, die Sie später prüfen können.

### Unintended Data Leakage

**Logging**

Entwickler sollten vorsichtig sein, debug-Informationen öffentlich preiszugeben, da dies zu sensiblen Daten leaks führen kann. Die Tools [**pidcat**](https://github.com/JakeWharton/pidcat) und `adb logcat` werden empfohlen, um die Anwendungs-Logs zu überwachen, sensible Informationen zu identifizieren und zu schützen. **Pidcat** wird wegen seiner Benutzerfreundlichkeit und Lesbarkeit bevorzugt.

> [!WARNING]
> Beachten Sie, dass ab neueren Versionen als Android 4.0 **Anwendungen nur auf ihre eigenen Logs zugreifen können**. Anwendungen können also nicht auf die Logs anderer Apps zugreifen.\
> Trotzdem wird empfohlen, keine sensitiven Informationen zu loggen.

**Copy/Paste Buffer Caching**

Das clipboard-basierte Framework von Android ermöglicht Copy-Paste-Funktionalität in Apps, birgt jedoch ein Risiko, da **andere applications** auf die Zwischenablage zugreifen können und so sensitive Daten exponiert werden können. Es ist wichtig, Copy/Paste-Funktionen für sensitive Bereiche einer Anwendung, wie Kreditkartendetails, zu deaktivieren, um data leaks zu vermeiden.

**Crash Logs**

Wenn eine Anwendung abstürzt und Logs speichert, können diese Logs Angreifern helfen, insbesondere wenn die Anwendung nicht reverse-engineered werden kann. Um dieses Risiko zu mindern, vermeiden Sie das Logging bei Abstürzen, und falls Logs über das Netzwerk gesendet werden müssen, stellen Sie sicher, dass sie über einen SSL-Kanal übertragen werden.

Als pentester, versuchen Sie, einen Blick auf diese Logs zu werfen.

**Analytics Data Sent To 3rd Parties**

Anwendungen integrieren oft Dienste wie Google Adsense, die aufgrund unsachgemäßer Implementierung durch Entwickler versehentlich sensitive data leak können. Um potenzielle data leaks zu identifizieren, ist es ratsam, den Traffic der Anwendung abzufangen und zu prüfen, ob sensible Informationen an Third-Party-Services gesendet werden.

### SQLite DBs

Die meisten Anwendungen verwenden interne SQLite-Datenbanken, um Informationen zu speichern. Während des pentest werfen Sie einen Blick auf die erstellten Datenbanken, die Namen der Tabellen und Spalten und alle gespeicherten Daten, da Sie sensitive Informationen finden könnten (was eine Vulnerability wäre).\
Datenbanken sollten sich in /data/data/the.package.name/databases befinden, z. B. /data/data/com.mwr.example.sieve/databases

Wenn die Datenbank vertrauliche Informationen speichert und verschlüsselt ist, Sie aber das Passwort in der Anwendung finden können, ist das immer noch eine Vulnerability.

Listen Sie die Tabellen mit `.tables` auf und listen Sie die Spalten der Tabellen mit `.schema <table_name>` auf.

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** erlaubt es Ihnen, **die Rolle einer Android app anzunehmen** und mit anderen Apps zu interagieren. Es kann **alles tun, was eine installierte Anwendung tun kann**, wie z. B. Androids Inter-Process Communication (IPC) nutzen und mit dem darunterliegenden Betriebssystem interagieren.\
Drozer ist ein nützliches Tool, um **exported activities, exported services und Content Providers zu exploit-en**, wie Sie in den folgenden Abschnitten lernen werden.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Außerdem denken Sie daran, dass der Code einer Activity in der **`onCreate`**-Methode beginnt.

**Authorisation bypass**

Wenn eine Activity exportiert ist, können Sie ihren Screen von einer externen App aufrufen. Daher könnten Sie, wenn eine Activity mit **sensitive information** **exported** ist, die **authentication**-Mechanismen **bypassen**, um darauf zuzugreifen.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Sie können eine exportierte Activity auch über adb starten:

- PackageName ist com.example.demo
- Exported ActivityName ist com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Beachte, dass ein authorisation bypass nicht immer eine vulnerability ist; es hängt davon ab, wie der bypass funktioniert und welche Informationen offengelegt werden.

**Sensitive information leakage**

**Activities can also return results**. Wenn es dir gelingt, eine exportierte und ungeschützte Activity zu finden, die die Methode **`setResult`** aufruft und **sensitive information** zurückgibt, liegt eine sensitive information leakage vor.

#### Tapjacking

Wenn Tapjacking nicht verhindert wird, könntest du die exportierte Activity missbrauchen, um den **Benutzer unerwartete Aktionen ausführen zu lassen**. Für mehr Infos zu [**was Tapjacking ist, folge dem Link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers werden im Wesentlichen verwendet, um **Daten zu teilen**. Wenn eine App Content Providers bereitstellt, kannst du möglicherweise **sensitive** Daten daraus **extrahieren**. Es ist auch sinnvoll, mögliche **SQL injections** und **Path Traversals** zu testen, da diese verwundbar sein könnten.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Denke daran, dass die Aktionen eines Service in der Methode `onStartCommand` beginnen.

Ein Service ist im Grunde etwas, das **Daten empfangen**, sie **verarbeiten** und (oder nicht) eine Antwort **zurückgeben** kann. Wenn eine Anwendung also Services exportiert, solltest du den **Code** prüfen, um zu verstehen, was er tut, und ihn **dynamisch** testen, um vertrauliche Informationen zu extrahieren, Authentifizierungsmaßnahmen zu umgehen...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Denke daran, dass die Aktionen eines Broadcast Receiver in der Methode `onReceive` starten.

Ein Broadcast Receiver wartet auf einen Nachrichtentyp. Je nachdem, wie der Receiver die Nachricht verarbeitet, kann er verwundbar sein.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Du kannst nach deep links manuell suchen, mit Tools wie MobSF oder Skripten wie [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Du kannst ein deklariertes **scheme** mit **adb** oder einem **browser** **öffnen**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Beachte, dass du den **Paketnamen weglassen** kannst und das Mobilgerät automatisch die App aufruft, die diesen Link öffnen soll._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Ausgeführter Code**

Um den **Code zu finden, der in der App ausgeführt wird**, gehe zu der activity, die vom deeplink aufgerufen wird, und suche nach der Funktion **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

Jedes Mal, wenn du einen deep link findest, überprüfe, dass er **keine sensiblen Daten (wie Passwörter) über URL-Parameter empfängt**, da jede andere Anwendung den deep link **imitieren und diese Daten stehlen könnte!**

**Parameters in path**

Du **musst außerdem prüfen, ob ein deep link einen Parameter im Pfad** der URL verwendet, wie z. B.: `https://api.example.com/v1/users/{username}` , in diesem Fall kannst du einen path traversal erzwingen, indem du etwas wie `example://app/users?username=../../unwanted-endpoint%3fparam=value` aufrufst.\
Beachte, dass du, wenn du die korrekten Endpoints in der Anwendung findest, möglicherweise ein **Open Redirect** (wenn ein Teil des Pfads als Domainname verwendet wird), eine **account takeover** (wenn du Benutzerdaten ohne CSRF-Token ändern kannst und das verwundbare Endpoint die richtige Methode verwendet) oder andere vuln auslösen kannst. Mehr [Info dazu hier](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Ein [interessanter bug bounty report](https://hackerone.com/reports/855618) über Links (_/.well-known/assetlinks.json_).

### Transport Layer-Inspektion und Verifikationsfehler

- **Certificates are not always inspected properly** von Android-Anwendungen. Häufig übersehen diese Anwendungen Warnungen und akzeptieren self-signed certificates oder fallen in manchen Fällen auf HTTP-Verbindungen zurück.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, indem unsichere cipher suites verwendet werden. Diese Schwachstelle macht die Verbindung anfällig für man-in-the-middle (MITM)-Angriffe, wodurch Angreifer die Daten entschlüsseln können.
- **Leakage of private information** ist ein Risiko, wenn Anwendungen sich über sichere Kanäle authentifizieren, aber anschließend für andere Transaktionen über unsichere Kanäle kommunizieren. Dadurch werden sensitive Daten wie session cookies oder Benutzerdetails nicht vor Abfangung durch bösartige Akteure geschützt.

#### Certificate Verification

Wir konzentrieren uns auf die **Zertifikatsprüfung**. Die Integrität des Serverzertifikats muss überprüft werden, um die Sicherheit zu erhöhen. Das ist entscheidend, da unsichere TLS-Konfigurationen und die Übertragung sensibler Daten über unverschlüsselte Kanäle erhebliche Risiken darstellen können. Für detaillierte Schritte zur Überprüfung von Serverzertifikaten und zur Behebung von Schwachstellen bietet [**diese Ressource**](https://manifestsecurity.com/android-application-security-part-10/) umfassende Anleitungen.

#### SSL Pinning

SSL Pinning ist eine Sicherheitsmaßnahme, bei der die Anwendung das Serverzertifikat gegen eine bekannte Kopie überprüft, die innerhalb der Anwendung gespeichert ist. Diese Methode ist essentiell zur Verhinderung von MITM-Angriffen. Die Implementierung von SSL Pinning wird dringend empfohlen für Anwendungen, die mit sensiblen Informationen umgehen.

#### Traffic Inspection

Um HTTP-Traffic zu inspizieren, ist es notwendig, das **Zertifikat des Proxy-Tools zu installieren** (z. B. Burp). Ohne die Installation dieses Zertifikats ist verschlüsselter Traffic unter Umständen nicht über den Proxy sichtbar. Eine Anleitung zum Installieren eines benutzerdefinierten CA-Zertifikats findest du [**hier**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Apps, die **API Level 24 and above** anvisieren, benötigen Änderungen an der Network Security Config, damit das CA-Zertifikat des Proxys akzeptiert wird. Dieser Schritt ist entscheidend, um verschlüsselten Traffic zu inspizieren. Anweisungen zum Ändern der Network Security Config findest du in [**diesem Tutorial**](make-apk-accept-ca-certificate.md).

Wenn **Flutter** verwendet wird, musst du den Anweisungen auf [**dieser Seite**](flutter.md) folgen. Denn das bloße Hinzufügen des Zertifikats zum Store reicht nicht aus, da Flutter eine eigene Liste gültiger CAs verwendet.

#### Statische Erkennung von SSL/TLS-Pinning

Bevor du Runtime-Bypässe versuchst, kartiere schnell, wo Pinning im APK erzwungen wird. Statische Erkennung hilft dir, Hooks/Patches zu planen und dich auf die richtigen Codepfade zu konzentrieren.

Tool: SSLPinDetect
- Open-Source-Tool zur statischen Analyse, das das APK zu Smali (via apktool) dekompiliert und nach kuratierten regex-Mustern für SSL/TLS-Pinning-Implementierungen sucht.
- Meldet den exakten Dateipfad, die Zeilennummer und einen Codeausschnitt für jeden Treffer.
- Deckt gängige Frameworks und benutzerdefinierte Codepfade ab: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init mit custom TrustManagers/KeyManagers und Network Security Config XML pins.

Installation
- Voraussetzungen: Python >= 3.8, Java in PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Verwendung
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Beispiel-Pattern-Regeln (JSON)
Verwende oder erweitere Signaturen, um proprietary/custom pinning styles zu erkennen. Du kannst dein eigenes JSON laden und im großen Maßstab scannen.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Hinweise und Tipps
- Schnelles Scannen großer Apps über multi-threading und memory-mapped I/O; vorkompilierte regex reduziert Overhead/Fehlalarme.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typische Erkennungsziele für die weitere Triage:
- OkHttp: CertificatePinner Verwendung, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init mit custom managers
- Declarative pins in res/xml network security config und Manifest-Referenzen
- Verwende die gefundenen Stellen, um Frida hooks, statische Patches oder Konfigurationsprüfungen vor dynamischen Tests zu planen.



#### Umgehen von SSL Pinning

Wenn SSL Pinning implementiert ist, wird das Umgehen davon nötig, um HTTPS-Traffic zu inspizieren. Dafür stehen verschiedene Methoden zur Verfügung:

- Automatisch die **apk** **modifizieren**, um SSLPinning mit [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) zu **bypassen**. Der größte Vorteil dieser Option ist, dass du kein root brauchst, um das SSL Pinning zu umgehen, aber du musst die Anwendung löschen und die neue Version installieren — das funktioniert nicht immer.
- Du kannst **Frida** (unten beschrieben) verwenden, um diesen Schutz zu umgehen. Hier ist eine Anleitung für Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Du kannst versuchen, SSL Pinning **automatisch zu umgehen** mit [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Du kannst auch versuchen, SSL Pinning **automatisch zu umgehen** mit **MobSF dynamic analysis** (weiter unten erklärt)
- Wenn du immer noch denkst, dass Traffic nicht erfasst wird, kannst du versuchen, den Traffic mit iptables an Burp weiterzuleiten. Lies diesen Blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Nach häufigen Web-Schwachstellen suchen

Es ist wichtig, auch innerhalb der Anwendung nach gängigen Web-Schwachstellen zu suchen. Detaillierte Informationen zur Identifikation und Behebung dieser Schwachstellen liegen außerhalb dieses Überblicks, werden aber an anderer Stelle ausführlich behandelt.

### Frida

[Frida](https://www.frida.re) ist ein dynamisches Instrumentierungs-Toolkit für Entwickler, Reverse-Engineers und Security-Researcher.\
**Du kannst auf laufende Anwendungen zugreifen und Methoden zur Laufzeit hooken, um Verhalten zu ändern, Werte zu verändern/extrahieren, anderen Code auszuführen...**\
Wenn du Android-Anwendungen pentest möchtest, musst du wissen, wie man Frida benutzt.

- Lerne Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Einige "GUI"-Tools für Aktionen mit Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection ist ideal, um den Einsatz von Frida zu automatisieren: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Du findest einige Awesome Frida scripts hier: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Versuche, anti-debugging / anti-frida Mechanismen zu umgehen, indem du Frida wie in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) lädst (Tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass Ablauf

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Speicher auslesen - Fridump**

Prüfe, ob die Anwendung sensitive Informationen im Speicher ablegt, die dort nicht sein sollten, wie Passwörter oder mnemonics.

Mit [**Fridump3**](https://github.com/rootbsd/fridump3) kannst du den Speicher der App dumpen mit:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Das erzeugt einen Speicher-Dump im Ordner ./dump; dort kannst du dann mit etwas wie folgendem grep suchen:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensible Daten im Keystore**

Auf Android ist der Keystore der beste Ort, um sensible Daten zu speichern, jedoch ist es mit genügend Berechtigungen immer noch **möglich, darauf zuzugreifen**. Da Anwendungen dazu neigen, hier **sensible Daten im Klartext** zu speichern, sollten pentests dies als root user prüfen, da jemand mit physischem Zugriff auf das Gerät diese Daten stehlen könnte.

Selbst wenn eine App Daten im Keystore speichert, sollten diese Daten verschlüsselt sein.

Um auf die Daten im Keystore zuzugreifen, kann man dieses Frida script verwenden: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Mit dem folgenden Frida-Script könnte es möglich sein, die von Android-Anwendungen möglicherweise durchgeführte **bypass fingerprint authentication** zu umgehen, mit der bestimmte sensible Bereiche geschützt werden:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Hintergrundbilder**

Wenn du eine Anwendung in den Hintergrund schickst, speichert Android einen **snapshot der Anwendung**, sodass beim Wiederherstellen in den Vordergrund zuerst das Bild geladen wird, bevor die App startet — dadurch wirkt die App, als wäre sie schneller geladen.

Enthält dieser **snapshot** jedoch **sensible Informationen**, könnte jemand mit Zugriff auf den snapshot diese **stehlen** (Hinweis: zum Zugriff wird root benötigt).

Die snapshots werden normalerweise gespeichert unter: **`/data/system_ce/0/snapshots`**

Android bietet eine Möglichkeit, die **Erfassung von screenshots zu verhindern, indem man das Layout-Parameter FLAG_SECURE setzt**. Durch die Verwendung dieses Flags werden die Fensterinhalte als sicher behandelt und verhindert, dass sie in screenshots erscheinen oder auf nicht-sicheren Displays angezeigt werden.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Dieses Tool kann Ihnen helfen, verschiedene Tools während der dynamic analysis zu verwalten: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Entwickler erstellen oft Proxy-Komponenten wie activities, services und broadcast receivers, die diese Intents verarbeiten und an Methoden wie `startActivity(...)` oder `sendBroadcast(...)` weiterreichen, was riskant sein kann.

Die Gefahr besteht darin, Angreifern zu erlauben, non-exported App-Komponenten oder sensible content providers zu triggern, indem diese Intents fehlgeleitet werden. Ein bekanntes Beispiel ist die `WebView`-Komponente, die URLs mittels `Intent.parseUri(...)` in `Intent`-Objekte umwandelt und diese dann ausführt, was zu bösartigen Intent-Injections führen kann.

### Essential Takeaways

- **Intent Injection** is similar to web's Open Redirect issue.
- Exploits involve passing `Intent` objects as extras, which can be redirected to execute unsafe operations.
- It can expose non-exported components and content providers to attackers.
- `WebView`’s URL to `Intent` conversion can facilitate unintended actions.

### Android Client Side Injections and others

Wahrscheinlich kennen Sie diese Art von Schwachstellen aus dem Web. Sie müssen bei diesen Schwachstellen in einer Android-Anwendung besonders vorsichtig sein:

- **SQL Injection:** Beim Umgang mit dynamischen Queries oder Content-Providers stellen Sie sicher, dass Sie parameterisierte Abfragen verwenden.
- **JavaScript Injection (XSS):** Vergewissern Sie sich, dass JavaScript- und Plugin-Unterstützung für alle WebViews deaktiviert ist (standardmäßig deaktiviert). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews sollten keinen Zugriff auf das Dateisystem haben (standardmäßig aktiv) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies:** In mehreren Fällen wird beim Beenden der Session der Cookie nicht widerrufen oder sogar auf der Festplatte gespeichert.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** mithilfe eines ansprechenden webbasierten Frontends. Sie können auch dynamic analysis durchführen (dazu muss die Umgebung vorbereitet werden).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP-Tools**

Wenn HTTP-Traffic erfasst wird, kannst du eine grobe Ansicht des erfassten Traffics unten bei "**HTTP(S) Traffic**" sehen oder eine schönere Ansicht über den grünen Button "**Start HTTPTools**". Über die zweite Option kannst du die **captured requests** an **proxies** wie Burp oder Owasp ZAP senden.\
Um das zu tun, _Burp einschalten -->_ _Intercept ausschalten --> in MobSB HTTPTools die Anfrage auswählen_ --> auf "**Send to Fuzzer**" drücken --> _die Proxy-Adresse auswählen_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sobald du die dynamische Analyse mit MobSF beendet hast, kannst du auf "**Start Web API Fuzzer**" drücken, um **fuzz http requests** und nach Schwachstellen zu suchen.

> [!TIP]
> Nach einer dynamischen Analyse mit MobSF können die Proxy-Einstellungen fehlkonfiguriert sein und sich nicht über die GUI beheben lassen. Du kannst die Proxy-Einstellungen wie folgt zurücksetzen:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Du kannst das Tool von [**Inspeckage**](https://github.com/ac-pm/Inspeckage) beziehen.\
Dieses Tool verwendet einige **Hooks**, um dir während einer **dynamic analysis** mitzuteilen, **was in der Anwendung passiert**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dies ist ein **ausgezeichnetes Tool, um statische Analyse mit einer GUI durchzuführen**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Dieses Tool ist dafür ausgelegt, nach verschiedenen **security related Android application vulnerabilities** zu suchen, sowohl im **source code** als auch in **packaged APKs**. Das Tool ist außerdem in der Lage, ein deploybares "**Proof-of-Concept**" APK und **ADB commands** zu erstellen, um einige der gefundenen Schwachstellen auszunutzen (Exposed activities, intents, tapjacking...). Wie bei Drozer ist es nicht notwendig, das Testgerät zu rooten.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Zeigt alle extrahierten Dateien zur einfachen Referenz an
- Dekompiliert automatisch APK-Dateien in Java- und Smali-Format
- Analysiert AndroidManifest.xml auf häufige Schwachstellen und Verhalten
- Statische Source-Code-Analyse auf häufige Schwachstellen und Verhalten
- Geräteinfo
- und mehr
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER ist eine Kommandozeilenanwendung, die unter Windows, MacOS X und Linux verwendet werden kann und _.apk_ Dateien nach Schwachstellen durchsucht. Sie macht dies, indem sie APKs entpackt und eine Reihe von Regeln anwendet, um diese Schwachstellen zu erkennen.

Alle Regeln sind in einer `rules.json` Datei zentralisiert, und jedes Unternehmen oder jeder Tester kann eigene Regeln erstellen, um das zu analysieren, was sie benötigen.

Lade die neuesten Binärdateien von der [download page](https://superanalyzer.rocks/download.html) herunter
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn ist ein **plattformübergreifendes** Tool, das Entwicklern, bugbounty hunters und ethical hackers bei der Durchführung von [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) an mobilen Anwendungen hilft.

Das Konzept ist, dass Sie Ihre mobile Anwendungsdatei (eine .apk- oder .ipa-Datei) per Drag & Drop auf die StaCoAn-Anwendung ziehen; sie erzeugt dann einen visuellen und portablen Bericht für Sie. Sie können die Einstellungen und wordlists anpassen, um ein individuelles Erlebnis zu erhalten.

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework ist ein Android vulnerability analysis system, das Entwicklern oder hackers hilft, potenzielle security vulnerabilities in Android applications zu finden.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** ist ein Tool, dessen Hauptziel es ist, den Benutzer vor potenziell bösartigen Verhaltensweisen einer Android-Anwendung zu erkennen und zu warnen.

Die Erkennung erfolgt durch die **statische Analyse** des Dalvik-Bytecodes der Anwendung, dargestellt als **Smali**, mithilfe der Bibliothek [`androguard`](https://github.com/androguard/androguard).

Dieses Tool sucht nach **häufigem Verhalten von "bösen" Anwendungen** wie: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** ist ein Framework für Reverse-Engineering und Analyse von mobilen Anwendungen. Es ist ein Tool, das gängig verwendete Tools für Reverse-Engineering und Analyse mobiler Anwendungen zusammenführt, um bei Tests von mobilen Anwendungen gegen die OWASP mobile security threats zu unterstützen. Ziel ist es, diese Aufgabe für mobile Anwendungsentwickler und Sicherheitsexperten einfacher und benutzerfreundlicher zu machen.

Es kann:

- Java- und Smali-Code mit verschiedenen Tools extrahieren
- APKs analysieren mit: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Private Informationen aus dem APK mit Regexps extrahieren.
- Das Manifest analysieren.
- Gefundene Domains analysieren mit: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) und [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APKs über [apk-deguard.com](http://www.apk-deguard.com) deobfuskieren

### Koodous

Nützlich zur Erkennung von Malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Beachte, dass abhängig vom Dienst und der Konfiguration, die du zur Obfuskierung verwendest, Secrets möglicherweise obfuskiert sind oder nicht.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** ist ein Open-Source-Kommandozeilen-Tool, das Java-Code schrumpft, optimiert und obfuskiert. Es kann Bytecode optimieren sowie ungenutzte Instruktionen erkennen und entfernen. ProGuard ist freie Software und wird unter der GNU General Public License, Version 2, verteilt.

ProGuard wird als Teil des Android SDK verteilt und läuft beim Erstellen der Anwendung im Release-Modus.

### [DexGuard](https://www.guardsquare.com/dexguard)

Finde eine Schritt-für-Schritt-Anleitung zum Deobfuskieren der apk unter [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Aus diesem Guide) Beim letzten Mal, als wir nachgesehen haben, war der Betriebsmodus von Dexguard:

- eine Ressource als InputStream laden;
- das Ergebnis an eine Klasse weitergeben, die von FilterInputStream erbt, um es zu entschlüsseln;
- einige nutzlose Obfuskationen durchführen, um ein paar Minuten eines Reversers zu verschwenden;
- das entschlüsselte Ergebnis an einen ZipInputStream geben, um eine DEX-Datei zu erhalten;
- schließlich die resultierende DEX als Resource mit der Methode `loadDex` laden.

### [DeGuard](http://apk-deguard.com)

**DeGuard kehrt den von Android-Obfuskationstools durchgeführten Obfuskierungsprozess um. Das ermöglicht zahlreiche Sicherheitsanalysen, einschließlich Code-Inspektion und Erkennung verwendeter Libraries.**

Sie können eine obfuskierte APK auf deren Plattform hochladen.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Dies ist ein LLM-Tool, um potenzielle Sicherheitslücken in Android-Apps zu finden und den Code von Android-Apps zu deobfuskieren. Verwendet die öffentliche Google Gemini API.

### [Simplify](https://github.com/CalebFenton/simplify)

Es ist ein **generischer Android-Deobfuscator.** Simplify **führt eine App virtuell aus**, um ihr Verhalten zu verstehen, und **versucht dann, den Code zu optimieren**, sodass er sich identisch verhält, aber für Menschen leichter verständlich ist. Jeder Optimierungstyp ist einfach und generisch, daher spielt es keine Rolle, welche spezifische Art der Obfuskation verwendet wurde.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gibt Informationen darüber, **wie ein APK hergestellt wurde**. Es identifiziert viele **compiler**, **packers**, **obfuscators** und andere seltsame Dinge. Es ist [_PEiD_](https://www.aldeid.com/wiki/PEiD) für Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b ist eine Android-Sicherheits-VM basierend auf ubuntu-mate und enthält eine Sammlung der neuesten Frameworks, Tutorials und Labs von verschiedenen Security-Enthusiasten und Forschern für Reverse Engineering und Malware-Analyse.

## Referenzen

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Es ist eine großartige Liste von Ressourcen
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android Quick Course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Noch auszuprobieren

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
