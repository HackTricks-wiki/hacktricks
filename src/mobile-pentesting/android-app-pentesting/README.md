# Pentesting de Aplicações Android

{{#include ../../banners/hacktricks-training.md}}

## Conceitos Básicos de Aplicações Android

É altamente recomendável começar por ler esta página para conhecer as **partes mais importantes relacionadas à segurança do Android e os componentes mais perigosos em uma aplicação Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta é a ferramenta principal que você precisa para conectar-se a um dispositivo Android (emulado ou físico).\
**ADB** permite controlar dispositivos tanto via **USB** quanto via **Network** a partir de um computador. Esta utilidade possibilita o **copiamento** de arquivos em ambas direções, a **instalação** e **desinstalação** de apps, a **execução** de comandos shell, o **backup** de dados, a **leitura** de logs, entre outras funções.

Veja a seguinte lista de [**ADB Commands**](adb-commands.md) para aprender a usar o adb.

## Smali

Por vezes é interessante **modificar o código da aplicação** para acessar **informações escondidas** (talvez senhas bem ofuscadas ou flags). Nesse caso, pode ser interessante decompilar o apk, modificar o código e recompilar o apk.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Isto pode ser muito útil como uma **alternativa para vários testes durante o dynamic analysis** que serão apresentados. Portanto, **tenha sempre em mente essa possibilidade**.

## Outras dicas interessantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extrair APK do dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Mescle todos os splits e apks base com [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Estudos de Caso & Vulnerabilidades


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Análise Estática

First of all, for analysing an APK you should **take a look to the to the Java code** using a decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Procurando informações interessantes

Apenas dando uma olhada nas **strings** do APK você pode procurar por **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** e qualquer coisa interessante... procure até por **backdoors** de execução de código ou backdoors de autenticação (credenciais admin hardcoded no app).

**Firebase**

Preste atenção especial às **firebase URLs** e verifique se está mal configurado. [Mais informação sobre o que é Firebase e como explorá-lo aqui.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Entendimento básico da aplicação - Manifest.xml, strings.xml

A **examinação dos arquivos _Manifest.xml_ e _strings.xml_ de uma aplicação pode revelar potenciais vulnerabilidades de segurança**. Esses arquivos podem ser acessados usando decompiladores ou renomeando a extensão do APK para .zip e descompactando-o.

**Vulnerabilidades** identificadas a partir do **Manifest.xml** incluem:

- **Debuggable Applications**: Aplicações marcadas como debuggable (`debuggable="true"`) no _Manifest.xml_ representam um risco, pois permitem conexões que podem levar à exploração. Para entender melhor como explorar aplicações debuggable, consulte um tutorial sobre como encontrar e explorar aplicações debuggable em um dispositivo.
- **Backup Settings**: O atributo `android:allowBackup="false"` deve ser explicitamente definido para aplicações que lidam com informações sensíveis para evitar backups não autorizados via adb, especialmente quando usb debugging está ativado.
- **Network Security**: Configurações de network security customizadas (`android:networkSecurityConfig="@xml/network_security_config"`) em _res/xml/_ podem especificar detalhes de segurança como certificate pins e configurações de tráfego HTTP. Um exemplo é permitir tráfego HTTP para domínios específicos.
- **Exported Activities and Services**: Identificar activities e services exportados no manifest pode destacar componentes que podem ser mal utilizados. Análises adicionais durante testes dinâmicos podem revelar como explorar esses componentes.
- **Content Providers and FileProviders**: Content providers expostos podem permitir acesso ou modificação não autorizada de dados. A configuração de FileProviders também deve ser examinada.
- **Broadcast Receivers and URL Schemes**: Esses componentes podem ser aproveitados para exploração, com atenção particular a como os URL schemes são gerenciados para vulnerabilidades de input.
- **SDK Versions**: Os atributos `minSdkVersion`, `targetSDKVersion` e `maxSdkVersion` indicam as versões do Android suportadas, destacando a importância de não suportar versões antigas e vulneráveis do Android por razões de segurança.

A partir do arquivo **strings.xml**, informações sensíveis como API keys, custom schemas e outras notas de desenvolvedor podem ser descobertas, ressaltando a necessidade de revisão cuidadosa desses recursos.

### Tapjacking

**Tapjacking** é um ataque onde uma **malicious application** é iniciada e **se posiciona por cima de uma aplicação vítima**. Uma vez que obscurece visivelmente o app vítima, sua interface é desenhada de forma a enganar o usuário para interagir com ela, enquanto repassa a interação para o app vítima.\
Na prática, é **cegar o usuário para que ele não saiba que na verdade está executando ações no app vítima**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Uma **activity** com o **`launchMode`** definido como **`singleTask` sem nenhum `taskAffinity`** definido é vulnerável a Task Hijacking. Isso significa que uma **application** pode ser instalada e, se for lançada antes da aplicação real, poderia **hijack the task of the real application** (portanto o usuário estará interagindo com a **malicious application pensando que está usando a aplicação real**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

No Android, arquivos **armazenados** em **internal** storage são **projetados** para serem **acessíveis** exclusivamente pelo **app** que os **criou**. Essa medida de segurança é **aplicada** pelo sistema operacional Android e geralmente é adequada para as necessidades de segurança da maioria das aplicações. No entanto, desenvolvedores às vezes utilizam modos como `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` para **permitir** que arquivos sejam **compartilhados** entre diferentes aplicações. Ainda assim, esses modos **não restringem o acesso** a esses arquivos por outras aplicações, incluindo possivelmente maliciosas.

1. **Static Analysis:**
- **Verifique** cuidadosamente o uso de `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE`. Esses modos **podem expor** arquivos a **acesso não intencional ou não autorizado**.
2. **Dynamic Analysis:**
- **Confirme** as **permissões** definidas em arquivos criados pelo app. Especificamente, **verifique** se algum arquivo está **definido como legível ou gravável mundialmente**. Isso pode representar um risco significativo de segurança, pois permitiria que **qualquer aplicação** instalada no dispositivo, independentemente de sua origem ou intenção, **leia ou modifique** esses arquivos.

**External Storage**

Ao lidar com arquivos em **external storage**, como SD Cards, certas precauções devem ser tomadas:

1. **Acessibilidade**:
- Arquivos em external storage são **globalmente legíveis e graváveis**. Isso significa que qualquer aplicação ou usuário pode acessar esses arquivos.
2. **Preocupações de Segurança**:
- Dada a facilidade de acesso, é aconselhável **não armazenar informações sensíveis** em external storage.
- External storage pode ser removido ou acessado por qualquer aplicação, tornando-o menos seguro.
3. **Tratamento de Dados vindos de External Storage**:
- Sempre **faça validação de input** em dados recuperados de external storage. Isso é crucial porque os dados vêm de uma fonte não confiável.
- Armazenar executáveis ou arquivos .class em external storage para carregamento dinâmico é fortemente desaconselhado.
- Se sua aplicação precisa recuperar arquivos executáveis de external storage, certifique-se de que esses arquivos estejam **assinados e verificados criptograficamente** antes de serem carregados dinamicamente. Essa etapa é vital para manter a integridade de segurança da sua aplicação.

External storage pode ser **acessado** em `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> A partir do Android 4.4 (**API 17**), o cartão SD possui uma estrutura de diretórios que **limita o acesso de um app ao diretório que é especificamente daquele app**. Isso evita que uma malicious application obtenha acesso de leitura ou escrita aos arquivos de outro app.

**Sensitive data stored in clear-text**

- **Shared preferences**: O Android permite que cada aplicação salve facilmente arquivos xml no caminho `/data/data/<packagename>/shared_prefs/` e às vezes é possível encontrar informações sensíveis em clear-text nessa pasta.
- **Databases**: O Android permite que cada aplicação salve facilmente bancos sqlite no caminho `/data/data/<packagename>/databases/` e às vezes é possível encontrar informações sensíveis em clear-text nessa pasta.

### Broken TLS

**Accept All Certificates**

Por algum motivo, às vezes desenvolvedores aceitam todos os certificados mesmo se, por exemplo, o hostname não corresponder, com linhas de código como a seguinte:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Criptografia quebrada

**Poor Key Management Processes**

Alguns desenvolvedores salvam dados sensíveis no armazenamento local e os encriptam com uma chave hardcoded/predictable no código. Isso não deveria ser feito, pois algum reversing poderia permitir que atacantes extraiam a informação confidencial.

**Use of Insecure and/or Deprecated Algorithms**

Desenvolvedores não deveriam usar **deprecated algorithms** para realizar **authorisation checks**, **store** ou **send** dados. Alguns desses algoritmos são: RC4, MD4, MD5, SHA1... Se **hashes** forem usados para armazenar senhas por exemplo, hashes brute-force **resistant** deveriam ser usados com salt.

### Outras verificações

- É recomendado **obfuscar o APK** para dificultar o trabalho de reverse engineering dos atacantes.
- Se o app for sensível (como apps bancários), ele deveria executar suas **próprias verificações para ver se o mobile está rootado** e agir em consequência.
- Se o app for sensível (como apps bancários), ele deveria checar se um **emulador** está sendo usado.
- Se o app for sensível (como apps bancários), ele deveria **verificar sua própria integridade antes de executar** para checar se foi modificado.
- Use [**APKiD**](https://github.com/rednaga/APKiD) para verificar qual compiler/packer/obfuscator foi usado para construir o APK

### React Native Application

Leia a seguinte página para aprender como acessar facilmente o código javascript de aplicações React:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Leia a página seguinte para aprender como acessar facilmente o código C# de aplicações Xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

A ferramenta [**mariana-trench**](https://github.com/facebook/mariana-trench) é capaz de encontrar **vulnerabilities** ao **scan** do **code** da aplicação. Essa ferramenta contém uma série de **known sources** (que indica ao tool os **lugares** onde o **input** é **controlled by the user**), **sinks** (que indica ao tool **dangerous** **places** onde input malicioso do usuário poderia causar danos) e **rules**. Essas rules indicam a **combination** de **sources-sinks** que indicam uma vulnerability.

Com esse conhecimento, **mariana-trench vai revisar o código e encontrar possíveis vulnerabilities nele**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Outras funções interessantes

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declaradas como `native`: `public native, System.loadLibrary, System.load`
- [Leia isto para aprender **como reverter native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Análise Dinâmica

> Primeiro, você precisa de um ambiente onde possa instalar a aplicação e todo o ambiente (Burp CA cert, Drozer and Frida mainly). Portanto, um dispositivo rootado (emulado ou não) é extremamente recomendado.

### Análise dinâmica online

Você pode criar uma **conta gratuita** em: [https://appetize.io/](https://appetize.io). Essa plataforma permite **upload** e **execução** de APKs, então é útil para ver como um apk está se comportando.

Você pode até **ver os logs da sua aplicação** na web e conectar via **adb**.

![](<../../images/image (831).png>)

Graças à conexão ADB você pode usar **Drozer** e **Frida** dentro dos emuladores.

### Análise dinâmica local

#### Usando um emulador

- [**Android Studio**](https://developer.android.com/studio) (Você pode criar dispositivos **x86** e **arm**, e de acordo com [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Aprenda a configurá-lo nesta página:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versão gratuita:** Personal Edition, é necessário criar uma conta. _É recomendado **download** da versão **WITH** _**VirtualBox** para evitar potenciais erros._)
- [**Nox**](https://es.bignox.com) (Gratuito, mas não suporta Frida ou Drozer).

> [!TIP]
> Ao criar um novo emulador em qualquer plataforma lembre-se que quanto maior a tela, mais lento o emulador irá rodar. Então selecione telas pequenas se possível.

Para **instalar google services** (como AppStore) no Genymotion você precisa clicar no botão marcado em vermelho da imagem seguinte:

![](<../../images/image (277).png>)

Além disso, note que na **configuração da VM Android no Genymotion** você pode selecionar **Bridge Network mode** (isso será útil se você for conectar à VM Android a partir de uma VM diferente com as ferramentas).

#### Use um dispositivo físico

Você precisa ativar as opções de **debugging** e seria bom se você puder **rootear**:

1. **Settings**.
2. (FromAndroid 8.0) Selecione **System**.
3. Selecione **About phone**.
4. Pressione **Build number** 7 vezes.
5. Volte e você encontrará as **Developer options**.

> Uma vez que você tenha instalado a aplicação, a primeira coisa que deveria fazer é testá-la e investigar o que ela faz, como funciona e ficar confortável com ela.\
> Sugiro **realizar essa análise dinâmica inicial usando MobSF dynamic analysis + pidcat**, assim seremos capazes de **aprender como a aplicação funciona** enquanto o MobSF **captura** muitos **dados interessantes** que você pode revisar mais tarde.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Vazamento não intencional de dados

**Logging**

Desenvolvedores devem ter cautela ao expor **debugging information** publicamente, pois isso pode levar a sensitive data leaks. As ferramentas [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` são recomendadas para monitorar logs da aplicação e identificar/proteger informações sensíveis. **Pidcat** é preferida por sua facilidade de uso e legibilidade.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

O framework **clipboard-based** do Android permite a funcionalidade de copiar/colar em apps, contudo apresenta risco já que **outras aplicações** podem **access** o clipboard, expondo potencialmente dados sensíveis. É crucial **desabilitar funções de copy/paste** para seções sensíveis da aplicação, como detalhes de cartão de crédito, para prevenir data leaks.

**Crash Logs**

Se uma aplicação **crasha** e **salva logs**, esses logs podem ajudar atacantes, particularmente quando a aplicação não pode ser reverse-engineered. Para mitigar esse risco, evite logar em crashes e, se logs precisarem ser transmitidos pela rede, garanta que sejam enviados via canal SSL para segurança.

Como pentester, **tente dar uma olhada nesses logs**.

**Analytics Data Sent To 3rd Parties**

Aplicações frequentemente integram serviços como Google Adsense, que podem inadvertidamente **leak sensitive data** devido à implementação imprópria por desenvolvedores. Para identificar possíveis vazamentos, é aconselhável **interceptar o tráfego da aplicação** e checar por qualquer informação sensível sendo enviada para serviços de terceiros.

### SQLite DBs

A maioria das aplicações irá usar **internal SQLite databases** para salvar informação. Durante o pentest dê uma **olhada** nos **databases** criados, nos nomes de **tables** e **columns** e em todos os **dados** salvos pois você pode encontrar **informação sensível** (o que seria uma vulnerability).\
Databases devem estar localizados em `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`

Se o database está salvando informação confidencial e está **encrypted b**ut você pode **find** a **password** dentro da aplicação, isso ainda é uma **vulnerability**.

Enumere as tabelas usando `.tables` e enumere as colunas das tabelas usando `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** permite que você **assuma o papel de um app Android** e interaja com outros apps. Ele pode fazer **anything that an installed application can do**, como fazer uso do Android’s Inter-Process Communication (IPC) mechanism e interagir com o sistema operacional subjacente. .\
Drozer é uma ferramenta útil para **explorar exported activities, exported services and Content Providers** como você aprenderá nas seções seguintes.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Lembre-se também que o código de uma activity começa no método **`onCreate`**.

**Authorisation bypass**

Quando uma Activity é exportada você pode invocar sua tela a partir de um app externo. Portanto, se uma activity com **informação sensível** está **exported** você poderia **bypass** os mecanismos de **authentication** **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Você também pode iniciar uma activity exportada via adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF vai detectar como malicioso o uso de _**singleTask/singleInstance**_ como `android:launchMode` em uma activity, mas devido a [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), aparentemente isso é perigoso apenas em versões antigas (API versions < 21).

> [!TIP]
> Note que um bypass de autorização nem sempre é uma vulnerabilidade; depende de como o bypass funciona e qual informação é exposta.

**Sensitive information leakage**

**Activities também podem retornar resultados**. Se conseguir encontrar uma activity exportada e desprotegida que chama o método **`setResult`** e **retorna informações sensíveis**, há uma sensitive information leakage.

#### Tapjacking

Se o Tapjacking não for prevenido, você pode abusar da activity exportada para fazer o **usuário executar ações inesperadas**. Para mais informações sobre [**o que é Tapjacking — siga o link**](#tapjacking).

### Explorando Content Providers - Acessando e manipulando informações sensíveis

[**Leia isto se quiser relembrar o que é um Content Provider.**](android-applications-basics.md#content-provider)\
Content providers são basicamente usados para **compartilhar dados**. Se um app possui content providers disponíveis, você pode ser capaz de **extrair dados sensíveis** deles. Também é interessante testar possíveis **SQL injections** e **Path Traversals**, pois podem ser vulneráveis.

[**Aprenda como explorar Content Providers com Drozer.**](drozer-tutorial/index.html#content-providers)

### **Explorando Services**

[**Leia isto se quiser relembrar o que é um Service.**](android-applications-basics.md#services)\
Lembre que as ações de um Service começam no método `onStartCommand`.

Um Service é basicamente algo que **pode receber dados**, **processá-los** e **retornar** (ou não) uma resposta. Logo, se um aplicativo estiver exportando alguns services você deve **verificar** o **código** para entender o que ele está fazendo e **testá-lo** **dinamicamente** para extrair informações confidenciais, burlar medidas de autenticação...\
[**Aprenda como explorar Services com Drozer.**](drozer-tutorial/index.html#services)

### **Explorando Broadcast Receivers**

[**Leia isto se quiser relembrar o que é um Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Lembre que as ações de um Broadcast Receiver começam no método `onReceive`.

Um broadcast receiver ficará esperando por um tipo de mensagem. Dependendo de como o receiver lida com a mensagem, ele pode ser vulnerável.\
[**Aprenda como explorar Broadcast Receivers com Drozer.**](#exploiting-broadcast-receivers)

### **Explorando Schemes / Deep links**

Você pode procurar por deep links manualmente, usando ferramentas como MobSF ou scripts como [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Você pode **abrir** um **scheme** declarado usando **adb** ou um **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Observe que você pode **omitir o nome do pacote** e o dispositivo móvel chamará automaticamente o app que deve abrir esse link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código executado**

Para encontrar o **código que será executado no App**, vá para a activity chamada pelo deeplink e procure a função **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informação sensível**

Sempre que encontrar um deeplink verifique que **ele não está recebendo dados sensíveis (como senhas) via parâmetros de URL**, porque qualquer outra aplicação poderia **se passar pelo deeplink e roubar esses dados!**

**Parâmetros no path**

Você **deve também verificar se algum deeplink está usando um parâmetro dentro do path** da URL como: `https://api.example.com/v1/users/{username}`, nesse caso você pode forçar um path traversal acessando algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Note que se você encontrar os endpoints corretos dentro da aplicação você pode ser capaz de causar um **Open Redirect** (se parte do path for usada como domain name), **account takeover** (se você conseguir modificar os detalhes dos usuários sem token CSRF e o vuln endpoint usar o método correto) e qualquer outra vuln. Mais [info sobre isso aqui](http://dphoeniixx.com/2020/12/13-2/).

**Mais exemplos**

Um [interesting bug bounty report](https://hackerone.com/reports/855618) sobre links (_/.well-known/assetlinks.json_).

### Inspeção da Camada de Transporte e Falhas de Verificação

- **Certificates are not always inspected properly** by Android applications. It's common for these applications to overlook warnings and accept self-signed certificates or, in some instances, revert to using HTTP connections.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, employing insecure cipher suites. This vulnerability makes the connection susceptible to man-in-the-middle (MITM) attacks, allowing attackers to decrypt the data.
- **Leakage of private information** is a risk when applications authenticate using secure channels but then communicate over non-secure channels for other transactions. This approach fails to protect sensitive data, such as session cookies or user details, from interception by malicious entities.

#### Verificação de Certificado

Vamos focar na **verificação de certificados**. A integridade do certificado do servidor deve ser verificada para aumentar a segurança. Isso é crucial porque configurações TLS inseguras e a transmissão de dados sensíveis por canais não criptografados podem representar riscos significativos. Para passos detalhados sobre verificar certificados de servidor e tratar vulnerabilidades, [**este recurso**](https://manifestsecurity.com/android-application-security-part-10/) fornece orientação abrangente.

#### SSL Pinning

SSL Pinning é uma medida de segurança onde a aplicação verifica o certificado do servidor contra uma cópia conhecida armazenada dentro da própria aplicação. Esse método é essencial para prevenir ataques MITM. Recomenda-se fortemente implementar SSL Pinning em aplicações que lidam com informações sensíveis.

#### Inspeção de Tráfego

Para inspecionar o tráfego HTTP, é necessário **instalar o certificado da ferramenta proxy** (por exemplo, Burp). Sem instalar esse certificado, o tráfego criptografado pode não ser visível através do proxy. Para um guia sobre como instalar um certificado CA customizado, [**clique aqui**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplicações targeting **API Level 24 and above** requerem modificações no Network Security Config para aceitar o certificado CA do proxy. Este passo é crítico para inspecionar tráfego criptografado. Para instruções sobre modificar o Network Security Config, [**consulte este tutorial**](make-apk-accept-ca-certificate.md).

Se **Flutter** estiver sendo usado você precisa seguir as instruções em [**esta página**](flutter.md). Isso porque apenas adicionar o certificado ao store não funcionará, já que o Flutter tem sua própria lista de CAs válidas.

#### Detecção estática de SSL/TLS pinning

Antes de tentar bypasses em runtime, mapeie rapidamente onde o pinning é aplicado no APK. A descoberta estática ajuda a planejar hooks/patches e focar nos caminhos de código corretos.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemplo de regras de padrão (JSON)
Use ou estenda as signatures para detectar estilos proprietários/custom de pinning. Você pode carregar seu próprio JSON e realizar scan em larga escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notas e dicas
- Escaneamento rápido em apps grandes via multi-threading e I/O mapeado em memória; regex pré-compilado reduz overhead/falsos positivos.
- Coleção de padrões: https://github.com/aancw/smali-sslpin-patterns
- Alvos típicos de detecção para triagem a seguir:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- TrustManagers personalizados: javax.net.ssl.X509TrustManager, overrides de checkServerTrusted
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init com managers personalizados
- Pins declarativos em res/xml network security config e referências no manifest
- Use as localizações correspondentes para planejar Frida hooks, patches estáticos ou revisões de configuração antes do teste dinâmico.



#### Contornando SSL Pinning

Quando SSL Pinning está implementado, contorná-lo torna-se necessário para inspecionar o tráfego HTTPS. Vários métodos estão disponíveis para esse fim:

- Modifique automaticamente o **apk** para **contornar** SSLPinning com [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). A maior vantagem desta opção é que você não precisará de root para contornar o SSL Pinning, mas será necessário apagar o aplicativo e reinstalar o novo, e isso nem sempre funciona.
- Você pode usar **Frida** (discutido abaixo) para contornar essa proteção. Aqui está um guia para usar Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Você também pode tentar **contornar automaticamente o SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Você também pode tentar **contornar automaticamente o SSL Pinning** usando **MobSF dynamic analysis** (explicado abaixo)
- Se você ainda achar que há tráfego que não está capturando, pode tentar **encaminhar o tráfego para o burp usando iptables**. Leia este blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Procurando por Vulnerabilidades Web Comuns

Também é importante procurar por vulnerabilidades web comuns dentro do aplicativo. Informações detalhadas sobre identificação e mitigação dessas vulnerabilidades estão além do escopo deste resumo, mas são amplamente abordadas em outros recursos.

### Frida

[Frida](https://www.frida.re) é um toolkit de instrumentação dinâmica para desenvolvedores, engenheiros de reverso e pesquisadores de segurança.\
**Você pode acessar a aplicação em execução e hookar métodos em tempo de execução para alterar o comportamento, mudar valores, extrair valores, executar código diferente...**\
Se você quer fazer pentest em aplicações Android, precisa saber usar o Frida.

- Aprenda a usar o Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Algumas "GUI" para ações com Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection é ótimo para automatizar o uso do Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Você pode encontrar alguns scripts Awesome do Frida aqui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Tente contornar mecanismos anti-debugging / anti-frida carregando o Frida conforme indicado em [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (ferramenta [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & fluxo de bypass de SSL pinning

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump de memória - Fridump**

Verifique se o aplicativo está armazenando informações sensíveis na memória que não deveria, como senhas ou frases mnemônicas.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) você pode fazer dump da memória do app com:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Isso irá dump a memória na pasta ./dump, e aí você pode grep com algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dados sensíveis no Keystore**

No Android o Keystore é o melhor lugar para armazenar dados sensíveis; no entanto, com privilégios suficientes ainda é **possível acessá-lo**. Como aplicações tendem a armazenar aqui **dados sensíveis em texto claro**, os pentests devem verificar isso, pois um root user ou alguém com acesso físico ao dispositivo poderia roubar esses dados.

Mesmo que um app armazene dados no keystore, os dados devem estar criptografados.

Para acessar os dados dentro do keystore você pode usar este Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando o seguinte Frida script, pode ser possível **bypass fingerprint authentication** que aplicativos Android podem estar realizando para **proteger certas áreas sensíveis:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imagens de Fundo**

Quando você coloca um aplicativo em segundo plano, o Android armazena um **instantâneo da aplicação** para que, quando ele for recuperado para o foreground, comece carregando a imagem antes do app, fazendo com que pareça que o aplicativo foi carregado mais rápido.

No entanto, se esse instantâneo contiver **informações sensíveis**, alguém com acesso ao instantâneo pode **roubar essa informação** (observe que você precisa de root para acessá-lo).

Os instantâneos geralmente são armazenados em: **`/data/system_ce/0/snapshots`**

O Android fornece uma maneira de **impedir a captura de screenshot definindo o parâmetro de layout FLAG_SECURE**. Ao usar essa flag, o conteúdo da janela é tratado como seguro, impedindo que apareça em screenshots ou que seja exibido em displays não seguros.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Esta ferramenta pode ajudar a gerenciar diferentes ferramentas durante a análise dinâmica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Desenvolvedores frequentemente criam componentes proxy como activities, services e broadcast receivers que manipulam esses Intents e os passam para métodos como `startActivity(...)` ou `sendBroadcast(...)`, o que pode ser arriscado.

O perigo está em permitir que atacantes acionem componentes da app não-exportados ou acessem content providers sensíveis ao desviar esses Intents. Um exemplo notável é o componente `WebView` converter URLs em objetos `Intent` via `Intent.parseUri(...)` e então executá-los, potencialmente levando a injeções maliciosas de Intent.

### Essential Takeaways

- **Intent Injection** é similar ao problema de Open Redirect na web.
- Exploits envolvem passar objetos `Intent` como extras, que podem ser redirecionados para executar operações inseguras.
- Pode expor componentes não-exportados e content providers aos atacantes.
- A conversão de URLs para `Intent` do `WebView` pode facilitar ações não intencionais.

### Injeções do Lado do Cliente no Android e outros

Provavelmente você conhece esse tipo de vulnerabilidade da Web. É preciso ter cuidado especial com essas vulnerabilidades em uma aplicação Android:

- **SQL Injection:** Ao lidar com queries dinâmicas ou Content-Providers, garanta o uso de queries parametrizadas.
- **JavaScript Injection (XSS):** Verifique se o suporte a JavaScript e Plugins está desabilitado para quaisquer WebViews (desabilitado por padrão). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Os WebViews devem ter o acesso ao sistema de arquivos desabilitado (habilitado por padrão) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Em vários casos, quando a aplicação Android finaliza a sessão, o cookie não é revogado ou pode até ser salvo em disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Análise Automática

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análise estática**

![](<../../images/image (866).png>)

**Avaliação de vulnerabilidades da aplicação** usando uma interface web agradável. Você também pode realizar análise dinâmica (mas precisa preparar o ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Frida scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Ferramentas HTTP**

Quando o tráfego HTTP é capturado você pode ver uma visão feia do tráfego capturado no botão "**HTTP(S) Traffic**" ou uma visão mais agradável no botão verde "**Start HTTPTools**". A partir da segunda opção, você pode **enviar** as **requisições capturadas** para **proxies** como Burp ou Owasp ZAP.\
Para isso, _ligue o Burp -->_ _desative o Intercept --> no MobSB HTTPTools selecione a request_ --> pressione "**Send to Fuzzer**" --> _selecione o endereço do proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Uma vez que você termine a análise dinâmica com MobSF você pode pressionar "**Start Web API Fuzzer**" para **fuzz http requests** e procurar por vulnerabilidades.

> [!TIP]
> Após realizar uma análise dinâmica com MobSF as configurações do proxy podem ficar mal configuradas e você não conseguirá corrigir isso pela GUI. Você pode corrigir as configurações do proxy fazendo:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Você pode obter a ferramenta em [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Essa ferramenta usa alguns **Hooks** para informar **o que está acontecendo na aplicação** enquanto você realiza uma **análise dinâmica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta é uma **ótima ferramenta para realizar análise estática com uma GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Essa ferramenta foi projetada para procurar várias **vulnerabilidades relacionadas à segurança em aplicações Android**, seja em **código-fonte** ou em **APKs empacotados**. A ferramenta também é **capaz de criar um APK "Proof-of-Concept" deployable** e **ADB commands**, para explorar algumas das vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Assim como com Drozer, não há necessidade de root no dispositivo de teste.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Exibe todos os arquivos extraídos para referência rápida
- Descompila automaticamente arquivos APK para os formatos Java e Smali
- Analisa AndroidManifest.xml em busca de vulnerabilidades e comportamentos comuns
- Análise estática de código-fonte para vulnerabilidades e comportamentos comuns
- Informações do dispositivo
- e mais
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER é uma aplicação de linha de comando que pode ser usada em Windows, MacOS X e Linux, que analisa _.apk_ files em busca de vulnerabilidades. Faz isso descomprimindo APKs e aplicando uma série de regras para detectar essas vulnerabilidades.

Todas as regras estão centralizadas em um arquivo `rules.json`, e cada empresa ou tester pode criar suas próprias regras para analisar o que for necessário.

Faça o download dos binários mais recentes na [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn é uma ferramenta **multiplataforma** que auxilia desenvolvedores, bugbounty hunters e ethical hackers na realização de [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) em aplicações móveis.

O conceito é que você arraste e solte o arquivo da sua aplicação móvel (um arquivo .apk ou .ipa) na aplicação StaCoAn e ela irá gerar um relatório visual e portátil para você. Você pode ajustar as configurações e wordlists para obter uma experiência personalizada.

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework é um sistema de análise de vulnerabilidades em Android que ajuda desenvolvedores ou hackers a encontrar potenciais vulnerabilidades de segurança em aplicações Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** é uma ferramenta cujo principal objetivo é detectar e alertar o usuário sobre potenciais comportamentos maliciosos desenvolvidos por uma aplicação Android.

A detecção é realizada com a **static analysis** do bytecode Dalvik da aplicação, representado como **Smali**, com a biblioteca [`androguard`](https://github.com/androguard/androguard).

Esta ferramenta procura por **comportamentos comuns de "bad" applications** como: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** é uma estrutura de **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. É uma ferramenta que reúne ferramentas comumente usadas para mobile application reverse engineering e análise, para auxiliar nos testes de aplicações móveis contra as ameaças de segurança mobile do OWASP. Seu objetivo é tornar essa tarefa mais fácil e amigável para desenvolvedores de aplicações móveis e profissionais de segurança.

Ela é capaz de:

- Extrair código Java e Smali usando diferentes ferramentas
- Analisar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extrair informações privadas do APK usando regexps.
- Analisar o Manifest.
- Analisar domínios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Desofuscar APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Ofuscação/Desofuscação de código

Note que, dependendo do serviço e da configuração usados para ofuscar o código, segredos podem ou não ficar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

O ProGuard é distribuído como parte do Android SDK e é executado ao construir a aplicação em modo release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Da última vez que verificamos, o modo de operação do Dexguard era:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverte o processo de ofuscação realizado por ferramentas de ofuscação Android. Isso permite diversas análises de segurança, incluindo inspeção de código e identificação de bibliotecas.**

Você pode enviar um APK ofuscado para a plataforma deles.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Esta é uma ferramenta LLM para encontrar potenciais vulnerabilidades de segurança em Android apps e desofuscar o código de apps Android. Usa a Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

É um **desofuscador android genérico.** Simplify **executa virtualmente um app** para entender seu comportamento e então **tenta otimizar o código** para que ele se comporte de forma idêntica, mas seja mais fácil para um humano entender. Cada tipo de otimização é simples e genérico, então não importa qual tipo específico de ofuscação foi usado.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD fornece informações sobre **how an APK was made**. Identifica muitos **compilers**, **packers**, **obfuscators**, e outras coisas estranhas. É o [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

Leia este tutorial para aprender alguns truques sobre **como reverter ofuscação customizada** {#ref}manual-deobfuscation.md{#endref}

## Laboratórios

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b é uma máquina virtual de segurança Android baseada em ubuntu-mate que inclui a coleção dos frameworks mais recentes, tutoriais e labs de diferentes geeks e pesquisadores de segurança para reverse engineering e análise de malware.

## Referências

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) É uma ótima lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Curso rápido de Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Ainda por tentar

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
