# Android Uygulamaları Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

Bu sayfayı okumaya başlamanız şiddetle tavsiye edilir; çünkü burada **Android güvenliği ile ilgili en önemli bölümler ve bir Android uygulamasındaki en tehlikeli bileşenler** hakkında bilgi bulacaksınız:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Bu, bir android cihaza (emüle edilmiş veya fiziksel) bağlanmak için ihtiyaç duyduğunuz ana araçtır.\
**ADB** bilgisayardan **USB** veya **Network** üzerinden cihazları kontrol etmeye olanak tanır. Bu yardımcı program, dosyaların her iki yönde **kopyalanması**, uygulamaların **yüklenmesi** ve **kaldırılması**, shell komutlarının **çalıştırılması**, verilerin **yedeklenmesi**, logların **okunması** ve diğer işlevleri sağlar.

adb'yi nasıl kullanacağınızı öğrenmek için aşağıdaki [**ADB Commands**](adb-commands.md) listesine bakın.

## Smali

Bazen **uygulama kodunu değiştirmek**, gizli bilgilere (ör. iyi obfuske edilmiş parolalar veya flags) erişmek için ilginç olabilir. Bu durumda, apk'yi decompile edip kodu değiştirmek ve tekrar derlemek ilginç olabilir.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Bu, sunulacak dinamik analiz sırasında gerçekleştirilecek çeşitli testler için bir **alternatif** olarak çok faydalı olabilir. Bu olasılığı **her zaman aklınızda bulundurun**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Play Integrity attestation spoofing (SafetyNet replacement)](play-integrity-attestation-bypass.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Tüm split ve base APK'ları [APKEditor](https://github.com/REAndroid/APKEditor) ile birleştir:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Static Analysis

Öncelikle, bir APK'yı analiz etmek için bir decompiler kullanarak **Java koduna bakmalısınız**.\
Lütfen, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Looking for interesting Info

Sadece APK'nin **strings**'ine bakarak **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** ve ilginç herhangi bir şeyi arayabilirsiniz... hatta kod çalıştırma **backdoors** veya kimlik doğrulama backdoor'larına (uygulamaya gömülü admin kimlik bilgileri) bakın.

**Firebase**

Firebase URL'lerine özellikle dikkat edin ve kötü yapılandırılmış olup olmadığını kontrol edin. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

**Bir uygulamanın _Manifest.xml_ ve _strings.xml_ dosyalarının incelenmesi potansiyel güvenlik açıklarını ortaya çıkarabilir**. Bu dosyalara decompiler kullanarak ya da APK dosya uzantısını .zip olarak değiştirip açarak erişilebilir.

**Vulnerabilities** identified from the **Manifest.xml** include:

- **Debuggable Applications**: Manifest.xml dosyasında `debuggable="true"` olarak ayarlanmış uygulamalar risk taşır çünkü bağlantılara izin verir ve bu durum sömürülemeye yol açabilir. Cihaz üzerinde debuggable uygulamaların nasıl bulunup sömürülebileceğine dair bir eğitime bakın.
- **Backup Settings**: Hassas bilgilerle çalışan uygulamalar için `android:allowBackup="false"` özniteliğinin açıkça ayarlanması gerekir; aksi halde özellikle usb debugging etkinse adb üzerinden yetkisiz yedeklemelere izin verilebilir.
- **Network Security**: res/xml/ içinde tanımlı özel ağ güvenlik konfigürasyonları (`android:networkSecurityConfig="@xml/network_security_config"`) sertifika pinleri ve HTTP trafiği ayarları gibi güvenlik detaylarını belirtebilir. Örneğin belirli domain'ler için HTTP trafiğine izin verilebilir.
- **Exported Activities and Services**: Manifest içinde exported olarak tanımlanmış activity ve service'lerin tespiti, kötüye kullanılabilecek bileşenleri ortaya çıkarabilir. Dinamik testler sırasında bu bileşenlerin nasıl sömürülebileceği daha detaylı analizle görülebilir.
- **Content Providers and FileProviders**: Açıkta kalan content provider'lar yetkisiz erişim veya veri değişikliğine izin verebilir. FileProvider yapılandırması da dikkatle incelenmelidir.
- **Broadcast Receivers and URL Schemes**: Bu bileşenler, URL scheme'lerin nasıl yönetildiğine özellikle dikkat edilerek input zafiyetleri için kullanılabilir.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion` ve `maxSdkVersion` öznitelikleri desteklenen Android sürümlerini gösterir; eski ve zafiyetli Android sürümlerine destek vermemek güvenlik açısından önemlidir.

**strings.xml** dosyasından API anahtarları, özel şemalar ve diğer geliştirici notları gibi hassas bilgiler keşfedilebilir; bu kaynakların dikkatle incelenmesi gerektiğini gösterir.

### Tapjacking

**Tapjacking**, kötü amaçlı bir **application**'ın başlatılarak **hedef uygulamanın** üstüne yerleştiği bir saldırıdır. Hedef uygulamayı görünür şekilde örttükten sonra, kullanıcıyı kandıracak şekilde tasarlanmış bir kullanıcı arayüzü sunar; aynı anda etkileşimi hedef uygulamaya iletir.\
Sonuç olarak, kullanıcı aslında hedef uygulama üzerinde işlem yaptığını fark etmez.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Bir **activity**'nin **`launchMode`** değeri **`singleTask`** olarak ayarlandığında ve herhangi bir `taskAffinity` tanımlanmamışsa task Hijacking'e karşı savunmasızdır. Bu, kötü amaçlı bir **application** kurulup gerçek uygulamadan önce başlatılırsa gerçek uygulamanın task'ını **hijack edebileceği** (yani kullanıcı gerçek uygulamayı kullandığını sanırken kötü amaçlı uygulama ile etkileşimde bulunacağı) anlamına gelir.

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android'te, internal storage'da **saklanan** dosyalar, onları oluşturan **uygulama tarafından yalnızca erişilebilir** olacak şekilde tasarlanmıştır. Bu güvenlik önlemi Android işletim sistemi tarafından uygulanır ve çoğu uygulamanın güvenlik ihtiyaçları için genellikle yeterlidir. Ancak geliştiriciler bazen dosyaların farklı uygulamalar arasında paylaşılmasına izin vermek için `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` gibi modları kullanır. Bu modlar dosyalara diğer uygulamalar, potansiyel olarak kötü amaçlı olanlar dahil, erişimini kısıtlamaz.

1. **Static Analysis:**
- `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` kullanımının dikkatlice incelendiğinden emin olun. Bu modlar dosyaların **istem dışı veya yetkisiz erişime** maruz kalmasına yol açabilir.
2. **Dynamic Analysis:**
- Uygulama tarafından oluşturulan dosyalara atanmış izinleri doğrulayın. Özellikle herhangi bir dosyanın dünya tarafından okunabilir veya yazılabilir olarak ayarlanıp ayarlanmadığını **kontrol edin**. Bu, cihazda yüklü herhangi bir uygulamanın bu dosyaları okumaya veya değiştirmeye izin vererek ciddi bir güvenlik riski oluşturabilir.

**External Storage**

SD Kart gibi **external storage** üzerindeki dosyalarla işlem yaparken şu önlemler alınmalıdır:

1. **Accessibility**:
- External storage üzerindeki dosyalar **genel olarak okunabilir ve yazılabilir**dir. Yani herhangi bir uygulama veya kullanıcı bu dosyalara erişebilir.
2. **Security Concerns**:
- Erişimin kolay olması nedeniyle hassas bilgileri external storage'da saklamamak önerilir.
- External storage çıkarılabilir veya herhangi bir uygulama tarafından erişilebilir olduğundan daha az güvenlidir.
3. **Handling Data from External Storage**:
- External storage'dan alınan veriler üzerinde her zaman **girdi doğrulaması** yapın. Çünkü bu veriler güvenilmeyen bir kaynaktan gelmektedir.
- External storage'da saklanan executable veya class dosyalarını dinamik olarak yüklemek şiddetle tavsiye edilmez.
- Uygulamanız external storage'dan executable dosyaları almak zorundaysa, bu dosyaların dinamik olarak yüklenmeden önce **imzalanmış ve kriptografik olarak doğrulanmış** olduğundan emin olun. Bu adım uygulamanızın güvenlik bütünlüğü için hayati önemdedir.

External storage şu yollarla **erişilebilir**: /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Android 4.4 (**API 17**) ile başlayan sürümlerde SD kartın bir dizin yapısı vardır ve bu yapı **bir uygulamanın yalnızca o uygulamaya özel klasöre erişimini kısıtlar**. Bu, kötü amaçlı uygulamaların başka bir uygulamanın dosyalarına okuma veya yazma erişimi kazanmasını engeller.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android her uygulamanın `/data/data/<packagename>/shared_prefs/` yolunda kolayca xml dosyaları kaydetmesine izin verir ve bazen bu klasörde açık metin olarak hassas bilgiler bulunabilir.
- **Databases**: Android her uygulamanın `/data/data/<packagename>/databases/` yolunda sqlite veritabanları kaydetmesine izin verir ve bazen bu klasörde açık metin olarak hassas bilgiler bulunabilir.

### Broken TLS

**Accept All Certificates**

Bazı nedenlerle geliştiriciler bazen tüm sertifikaları kabul ederler; örneğin hostname eşleşmesi bile sağlamasa aşağıdaki gibi kod satırlarıyla bunu yapabilirler:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Kırık Kriptografi

**Zayıf Anahtar Yönetim Süreçleri**

Bazı geliştiriciler hassas verileri yerel depolamada saklayıp, kod içinde sabitlenmiş/öngörülebilir bir anahtar ile şifreliyor. Bu yapılmamalıdır; çünkü yapılan tersine mühendislik saldırganların gizli bilgileri çıkarmasına izin verebilir.

**Güvenli Olmayan ve/veya Kullanımdan Kaldırılmış Algoritmaların Kullanımı**

Geliştiriciler yetkilendirme **kontrolleri** yapmak, veriyi **saklamak** veya **göndermek** için **kullanımdan kaldırılmış algoritmaları** kullanmamalıdır. Bu algoritmalardan bazıları: RC4, MD4, MD5, SHA1... Örneğin parolaları saklamak için **hashler** kullanılıyorsa, salt ile birlikte **brute-force**'a dayanıklı hashler kullanılmalıdır.

### Diğer kontroller

- APK'yı **obfuscate** ederek tersine mühendislik işini saldırganlar için zorlaştırmak önerilir.
- Uygulama hassassa (ör. banka uygulamaları), cihazın **rootlu** olup olmadığını kontrol eden kendi kontrollerini yapmalı ve buna göre davranmalıdır.
- Uygulama hassassa (ör. banka uygulamaları), bir **emulator** kullanılıp kullanılmadığını kontrol etmelidir.
- Uygulama hassassa (ör. banka uygulamaları), çalıştırmadan önce kendi bütünlüğünü **kontrol etmeli**; değiştirilip değiştirilmediğini kontrol etmelidir.
- Hangi compiler/packer/obfuscator'ın APK'yı oluşturmak için kullanıldığını kontrol etmek üzere [**APKiD**](https://github.com/rednaga/APKiD) kullanın

### React Native Uygulaması

React uygulamalarının javascript kodlarına nasıl kolayca erişileceğini öğrenmek için aşağıdaki sayfayı okuyun:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Uygulamaları

Bir Xamarin uygulamasının C# kodlarına nasıl kolayca erişileceğini öğrenmek için aşağıdaki sayfayı okuyun:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Uygulamalar

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **çalıştırıp dosya sisteminden açılmış dosyaları toplama.**

### Otomatik Statik Kod Analizi

[**mariana-trench**](https://github.com/facebook/mariana-trench) aracı, uygulamanın **kodunu tarayarak** **zafiyetleri** bulabilir. Bu araç, bir dizi **known sources** (aracın kullanıcı tarafından kontrol edilen **input**’ların olduğu **yerleri** bildirir), **sinks** (kötü amaçlı kullanıcı girdisinin zarar verebileceği tehlikeli **yerleri** bildirir) ve **kurallar** içerir. Bu kurallar, bir zafiyeti belirten **sources-sinks** kombinasyonlarını tanımlar.

Bu bilgilerle, **mariana-trench kodu inceleyip olası zafiyetleri bulacaktır**.

### Secrets leaked

Bir uygulama içinde API anahtarları, parolalar, gizli URL'ler, subdomain'ler vb. gibi keşfedebileceğiniz secrets bulunabilir. Bunun için [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) gibi bir araç kullanabilirsiniz

### Biyometrik Kimlik Doğrulamayı Atlatma


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Diğer ilginç fonksiyonlar

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Bu kaynağı okuyun: **native fonksiyonları tersine mühendislik ile nasıl çözümleyeceğinizi öğrenin**](reversing-native-libraries.md)
- JNI aracılığıyla bellek içi native kod yürütme (indirilen shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Diğer hileler**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dinamik Analiz

> Öncelikle, uygulamayı ve gerekli ortamı (Burp CA sertifikası, Drozer ve Frida başta olmak üzere) kurabileceğiniz bir ortama ihtiyacınız var. Bu nedenle, köklü (rooted) bir cihaz (emüle edilmiş veya değil) şiddetle tavsiye edilir.

### Çevrimiçi Dinamik analiz

[https://appetize.io/](https://appetize.io/) adresinde **ücretsiz bir hesap** oluşturabilirsiniz. Bu platform APK yüklemeye ve çalıştırmaya izin verdiği için, bir APK'nın nasıl davrandığını görmek için işe yarar.

Ayrıca uygulamanızın loglarını web üzerinden görebilir ve **adb** ile bağlanabilirsiniz.

![](<../../images/image (831).png>)

ADB bağlantısı sayesinde emülatörler içinde **Drozer** ve **Frida** kullanabilirsiniz.

### Yerel Dinamik Analiz

#### Emülatör kullanarak

- [**Android Studio**](https://developer.android.com/studio) (x86 ve arm cihazlar oluşturabilirsiniz; ve [**bu** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**son x86** sürümleri **ARM kütüphanelerini** yavaş ARM emülatöre ihtiyaç duymadan destekler).
- Kurulumunu bu sayfada öğrenin:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Ücretsiz sürüm:** Personal Edition, bir hesap oluşturmanız gerekir. _Hataları önlemek için VirtualBox ile birlikte OLAN_ sürümü **indirmek** önerilir._)
- [**Nox**](https://es.bignox.com) (Ücretsiz, fakat Frida veya Drozer desteklemez).

> [!TIP]
> Herhangi bir platformda yeni bir emülatör oluştururken ekran ne kadar büyükse emülatör o kadar yavaş çalışır. Mümkünse küçük ekranlar seçin.

Genymotion içinde Google servislerini (ör. AppStore) **kurmak** için aşağıdaki görüntüde kırmızı işaretli butona tıklamanız gerekir:

![](<../../images/image (277).png>)

Ayrıca, **Genymotion'daki Android VM yapılandırmasında** **Bridge Network mode** seçeneğini işaretleyebilirsiniz (farklı bir VM'den Android VM'ye araçlarla bağlanacaksanız bu faydalı olacaktır).

#### Fiziksel bir cihaz kullanma

Geliştirici seçeneklerini etkinleştirmeniz gerekir ve cihazı **root** yapabiliyorsanız bu iyi olur:

1. **Settings**.
2. (Android 8.0 ve üstü) **System** seçin.
3. **About phone** seçin.
4. **Build number** üzerine 7 kez basın.
5. Geri gidin ve **Developer options**'ı bulacaksınız.

> Uygulamayı yükledikten sonra ilk yapmanız gereken şey onu çalıştırıp ne yaptığını, nasıl çalıştığını incelemek ve uygulamaya alışmaktır.\
> Bu ilk dinamik analizi MobSF dynamic analysis + pidcat kullanarak yapmanızı öneririm; böylece uygulamanın nasıl çalıştığını öğrenirken MobSF birçok ilginç veriyi yakalar ve daha sonra inceleyebilirsiniz.

Magisk/Zygisk kısa notlar (Pixel cihazlarda önerilir)
- systemless root elde etmek için Magisk uygulamasıyla boot.img'i patchleyin ve fastboot ile flash edin
- Zygisk + DenyList'i etkinleştirerek root gizlemeyi sağlayın; daha güçlü gizleme gerektiğinde LSPosed/Shamiko düşünün
- OTA güncellemelerinden kurtulmak için orijinal boot.img'i saklayın; her OTA sonrası yeniden patchleyin
- Ekran yansıtma için host üzerinde scrcpy kullanın



### İstenmeyen Veri Sızıntısı

**Logging**

Geliştiriciler, **debugging bilgilerini** açıkta bırakma konusunda dikkatli olmalıdır; çünkü bu hassas verilerin leak olmasına yol açabilir. Uygulama loglarını izlemek ve hassas bilgileri tespit etmek için [**pidcat**](https://github.com/JakeWharton/pidcat) ve `adb logcat` araçları önerilir. **Pidcat**, kullanım kolaylığı ve okunabilirliği nedeniyle tercih edilir.

> [!WARNING]
> **Android 4.0'dan itibaren**, **uygulamalar sadece kendi loglarına erişebilir**. Yani uygulamalar diğer uygulamaların loglarına erişemez.\
> Her halükârda, hassas bilgileri loglamamak hâlâ önerilir.

**Kopyala/Yapıştır Tamponu (Clipboard) Önbelleklemesi**

Android'in **clipboard-based** çerçevesi uygulamalarda kopyala-yapıştır işlevselliği sağlar, ancak başka **uygulamaların** panoya erişebilmesi nedeniyle risk taşır; bu durum hassas verilerin leak olmasına neden olabilir. Kredi kartı bilgileri gibi hassas bölümler için kopyala/yapıştır işlevlerini devre dışı bırakmak önemlidir.

**Crash Logları**

Bir uygulama **crash** yapıp logları kaydederse, özellikle uygulamanın tersine mühendisliği mümkün olmadığında, bu loglar saldırganlara yardımcı olabilir. Bu riski azaltmak için crash durumunda log tutmaktan kaçının ve eğer loglar ağ üzerinden gönderilecekse SSL kanalı ile gönderildiğinden emin olun.

Pentester olarak, **bu loglara göz atmaya** çalışın.

**3rd Taraflara Gönderilen Analytics Verileri**

Uygulamalar genellikle Google Adsense gibi servisleri entegre eder; yanlış implementasyon geliştiriciler tarafından hassas verilerin kazara 3rd taraflara leak olmasına yol açabilir. Olası veri sızıntılarını tespit etmek için uygulamanın trafiğini intercept edip üçüncü taraf servislere hassas bilgi gönderilip gönderilmediğini kontrol edin.

### SQLite DB'leri

Çoğu uygulama bilgi kaydetmek için **internal SQLite veritabanları** kullanır. Pentest sırasında oluşturulan **veritabanlarına**, **tablo** ve **sütun** isimlerine ve kaydedilen tüm **verilere** bakın; çünkü hassas bilgi bulabilirsiniz (bu bir zafiyettir).\
Veritabanları genellikle `/data/data/the.package.name/databases` örneğin `/data/data/com.mwr.example.sieve/databases` dizininde bulunur.

Eğer veritabanı gizli bilgileri şifreliyorsa ve şifre uygulama içinde bulunabiliyorsa bu hâlâ bir **zafiyettir**.

Tabloları `.tables` ile listeleyin ve tabloların sütunlarını görmek için `.schema <table_name>` komutunu kullanın.

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer, export edilmiş activities, export edilmiş services ve Content Provider'ları **exploit etmek** için kullanışlı bir araçtır; bunu sonraki bölümlerde öğreneceksiniz.

### Exported Activity'leri Exploit Etme

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ayrıca unutmayın ki bir activity'nin kodu **`onCreate`** metodunda başlar.

**Yetkilendirme atlatma**

Bir Activity export edilmişse, ekranını dış bir uygulamadan çağırabilirsiniz. Bu nedenle, **hassas bilgi** içeren bir activity export edilmişse, **authentication** mekanizmalarını **bypass** ederek ona erişebilirsiniz.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Ayrıca adb üzerinden export edilmiş bir activity başlatabilirsiniz:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOT**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Authorisation bypass'un her zaman bir vulnerability olmadığına dikkat edin; bunun nasıl çalıştığına ve hangi bilgilerin açığa çıktığına bağlıdır.

**Hassas bilgi sızıntısı**

**Activities ayrıca sonuç döndürebilir**. Eğer export edilmiş ve korunmasız bir activity içinde **`setResult`** metodunu çağıran ve **hassas bilgi** döndüren bir durum bulursanız, bu bir hassas bilgi sızıntısıdır.

#### Tapjacking

Eğer Tapjacking önlenmemişse, exported activity'yi suistimal ederek **kullanıcının beklenmeyen işlemler yapmasını** sağlayabilirsiniz. Daha fazla bilgi için [**Tapjacking nedir, linke bakın**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Content Provider'ın ne olduğunu tazelemek isterseniz bunu okuyun.**](android-applications-basics.md#content-provider)\
Content providers temelde **veri paylaşmak** için kullanılır. Eğer bir uygulamanın erişilebilir content providers'ı varsa, onlardan **hassas veri** çıkarabilirsiniz. Ayrıca olası **SQL injections** ve **Path Traversals**'ı test etmek ilginçtir çünkü bunlar vulnerable olabilir.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Service'in ne olduğunu tazelemek isterseniz bunu okuyun.**](android-applications-basics.md#services)\
Service'in eylemlerinin `onStartCommand` metodunda başladığını unutmayın.

Service temelde **veri alabilen**, **işleyebilen** ve **(veya) bir yanıt döndürebilen** bir bileşendir. Bu nedenle, eğer bir uygulama bazı services ihraç ediyorsa, ne yaptığını anlamak için **kodu** incelemeli ve gizli bilgileri çıkarmak, kimlik doğrulama önlemlerini aşmak için dinamik olarak **test** etmelisiniz...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Broadcast Receiver'ın ne olduğunu tazelemek isterseniz bunu okuyun.**](android-applications-basics.md#broadcast-receivers)\
Broadcast Receiver'ın eylemlerinin `onReceive` metodunda başladığını unutmayın.

Bir broadcast receiver belirli bir tür mesajı bekliyor olacaktır. Alıcının mesajı nasıl işlediğine bağlı olarak zayıf olabilir.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Deep link'leri manuel olarak MobSF gibi araçlar veya [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) gibi script'ler kullanarak arayabilirsiniz.\
Deklar edilmiş bir **scheme**'i **adb** veya bir **tarayıcı** kullanarak **açabilirsiniz**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Paket adını **belirtmeyebileceğinizi** ve mobilin o bağlantıyı açması gereken uygulamayı otomatik olarak çağıracağını unutmayın._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Çalıştırılan kod**

Uygulamada çalıştırılacak **kodu** bulmak için, deeplink tarafından çağrılan activity'e gidin ve **`onNewIntent`** fonksiyonunu arayın.

![](<../../images/image (436) (1) (1) (1).png>)

**Hassas bilgi**

Her deep link bulduğunuzda, URL parametreleri aracılığıyla (ör. parolalar) hassas veri almadığını i**nceleyin**, çünkü başka bir uygulama **deep link'i taklit edip o verileri çalabilir!**

**URL yolundaki parametreler**

Ayrıca herhangi bir deep link'in URL yolunun içinde parametre kullanıp kullanmadığını da **kontrol etmelisiniz**; örneğin: `https://api.example.com/v1/users/{username}`. Bu durumda şu şekilde bir path traversal zorlayabilirsiniz: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Uygulama içinde doğru endpoint'leri bulursanız bir **Open Redirect** (path'in bir kısmı domain adı olarak kullanılıyorsa), **account takeover** (kullanıcı detaylarını CSRF token olmadan değiştirebiliyorsanız ve vuln endpoint doğru yöntemi kullanıyorsa) ve diğer zafiyetleri tetikleyebilirsiniz. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Taşıma Katmanı İncelemesi ve Doğrulama Hataları

- **Sertifikalar her zaman düzgün şekilde incelenmez** Android uygulamaları tarafından. Bu uygulamaların uyarıları göz ardı edip self-signed sertifikaları kabul etmesi ya da bazı durumlarda HTTP bağlantılarına geri dönmesi yaygındır.
- **SSL/TLS handshake sırasında yapılan müzakereler bazen zayıftır**, güvensiz cipher suite'ler kullanılıyor olabilir. Bu zafiyet bağlantıyı man-in-the-middle (MITM) saldırılarına karşı savunmasız bırakır ve saldırganların veriyi deşifre etmesine imkan sağlar.
- **Leakage of private information** riski, uygulamalar güvenli kanallarla kimlik doğrulaması yapıp diğer işlemler için güvenli olmayan kanallar üzerinden iletişim kurduğunda ortaya çıkar. Bu yaklaşım, session cookies veya kullanıcı bilgileri gibi hassas verileri kötü niyetli tarafların yakalamasından koruyamaz.

#### Certificate Verification

Biz **certificate verification** üzerine odaklanacağız. Sunucunun sertifikasının bütünlüğü güvenliği artırmak için doğrulanmalıdır. Güvensiz TLS yapılandırmaları ve hassas verinin şifrelenmemiş kanallardan gönderilmesi ciddi riskler doğurabilir. Sunucu sertifikalarını doğrulama ve zafiyetleri ele alma adımları için, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) kapsamlı rehberlik sağlar.

#### SSL Pinning

SSL Pinning, uygulamanın sunucunun sertifikasını uygulama içinde depolanmış bilinen bir kopyaya karşı doğruladığı bir güvenlik önlemidir. Bu yöntem MITM saldırılarını önlemek için önemlidir. Hassas bilgi işleyen uygulamalara SSL Pinning uygulanması kuvvetle tavsiye edilir.

#### Traffic Inspection

HTTP trafiğini incelemek için proxy aracının sertifikasını (ör. Burp) **yüklemeniz gerekir**. Bu sertifika yüklenmeden şifreli trafik proxy üzerinden görünmeyebilir. Özel bir CA sertifikasının nasıl yükleneceğine dair rehber için, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

**API Level 24 and above** hedefleyen uygulamalar, proxy'nin CA sertifikasını kabul etmek için Network Security Config'te değişiklik yapılmasını gerektirir. Bu adım şifreli trafiği incelemek için kritiktir. Network Security Config'i değiştirme talimatları için, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Eğer **Flutter** kullanılıyorsa, [**this page**](flutter.md) içindeki talimatları takip etmeniz gerekir. Çünkü sertifikayı sadece store'a eklemek yeterli olmayacaktır; Flutter'ın kendine ait geçerli CA listesi bulunmaktadır.

#### Static detection of SSL/TLS pinning

Runtime bypass denemeden önce, pinning'in APK içinde nerede uygulandığını hızlıca haritalayın. Statik keşif, hook/patch planlamanıza yardımcı olur ve doğru kod yollarına odaklanmanızı sağlar.

Tool: SSLPinDetect
- Açık kaynaklı statik analiz aracı; APK'yı Smali'ye decompile eder (apktool üzerinden) ve SSL/TLS pinning implementasyonlarına ait özenle seçilmiş regex pattern'leri tarar.
- Her eşleşme için tam dosya yolu, satır numarası ve bir kod snippet'i raporlar.
- Yaygın framework'leri ve özel kod yollarını kapsar: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init ile custom TrustManagers/KeyManagers, ve Network Security Config XML pinleri.

Kurulum
- Gereksinimler: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Kullanım
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Örnek pattern kuralları (JSON)
Proprietary/custom pinning stillerini tespit etmek için signatures kullanın veya genişletin. Kendi JSON'unuzu yükleyip ölçekli olarak scan edebilirsiniz.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notlar ve ipuçları
- Büyük uygulamalarda çoklu iş parçacığı ve memory-mapped I/O ile hızlı tarama; önceden derlenmiş regex, overhead'i/false positive'leri azaltır.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Sonraki önceliklendirme için tipik tespit hedefleri:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- res/xml içindeki deklaratif pinler (network security config) ve manifest referansları
- Eşleşen konumları, dinamik testlerden önce Frida hook'ları, statik yamalar veya konfigürasyon incelemeleri planlamak için kullanın.



#### SSL Pinning'i Atlatma

SSL Pinning uygulandığında, HTTPS trafiğini incelemek için bunu atlatmak gerekebilir. Bu amaçla çeşitli yöntemler mevcuttur:

- [**apk-mitm**](https://github.com/shroudedcode/apk-mitm) ile **apk**'yı otomatik olarak **değiştirip** SSLPinning'i **atlatabilirsiniz**. Bu seçeneğin en büyük avantajı, SSL Pinning'i atlatmak için root gerekmemesi, ancak uygulamayı silip yeniden yüklemeniz gerekecek olmasıdır ve her zaman işe yaramayabilir.
- Bu korumayı atlatmak için aşağıda tartışılan **Frida**'yı kullanabilirsiniz. Burp+Frida+Genymotion kullanımı için bir rehber: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- [**objection**](frida-tutorial/objection-tutorial.md) kullanarak SSL Pinning'i **otomatik olarak atlatmayı** da deneyebilirsiniz:**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dynamic analysis** kullanarak SSL Pinning'i **otomatik olarak atlatmayı** da deneyebilirsiniz (aşağıda açıklanmıştır)
- Hâlâ yakalamadığınızı düşündüğünüz trafik varsa, trafiği iptables kullanarak burp'a **yönlendirmeyi** deneyebilirsiniz. Bu blogu okuyun: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Yaygın Web Zafiyetlerini Arama

Uygulama içinde yaygın web zafiyetlerini de aramak önemlidir. Bu zafiyetleri tespit etme ve hafifletme hakkında detaylı bilgi bu özetin kapsamı dışında olup başka kaynaklarda geniş şekilde ele alınmıştır.

### Frida

[Frida](https://www.frida.re) geliştiriciler, reverse-engineer'lar ve güvenlik araştırmacıları için dinamik bir enstrümantasyon aracıdır.\
**Çalışan uygulamaya erişip çalışma zamanında metotları hooklayarak davranışı değiştirebilir, değerleri değiştirebilir, değerleri çıkarabilir, farklı kod çalıştırabilirsiniz...**\
Android uygulamalarını pentest etmek istiyorsanız Frida'yı nasıl kullanacağınızı bilmelisiniz.

- Frida nasıl kullanılır öğrenin: [**Frida tutorial**](frida-tutorial/index.html)
- Frida ile işlemler için bazı "GUI" araçları: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection, Frida kullanımını otomatikleştirmek için harika: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Bazı harika Frida script'lerini şurada bulabilirsiniz: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Frida yükleyerek anti-debugging / anti-frida mekanizmalarını atlatmayı deneyin; örnek: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning atlatma iş akışı

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Bellek Dökümü - Fridump**

Uygulamanın, parola veya mnemonic gibi saklamaması gereken hassas bilgileri bellek içinde tutup tutmadığını kontrol edin.

[**Fridump3**](https://github.com/rootbsd/fridump3) kullanarak uygulamanın belleğini şu şekilde dökebilirsiniz:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Bu, belleği ./dump klasörüne dökecek ve orada şu gibi bir şeyle grep yapabilirsiniz:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore'daki hassas veriler**

Android'de Keystore, hassas verileri depolamak için en iyi yerdir; ancak yeterli ayrıcalığa sahip olunduğunda **hala erişilebilirdir**. Uygulamalar burada **düz metin halinde hassas veriler** depolama eğiliminde olduğundan, pentests bunu kontrol etmelidir; çünkü root user veya cihaza fiziksel erişimi olan biri bu verileri çalabilir.

Bir uygulama keystore'da veri depolasa bile, veriler şifrelenmiş olmalıdır.

Keystore içindeki verilere erişmek için bu Frida script'ini kullanabilirsiniz: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Aşağıdaki Frida script'i kullanılarak, Android uygulamalarının belirli hassas alanları korumak için uygulayabileceği **bypass fingerprint authentication** işlemini atlamak mümkün olabilir:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Arka Plan Görüntüleri**

Bir uygulamayı arka plana attığınızda, Android uygulamanın **anlık görüntüsünü** saklar; böylece uygulama ön plana geri getirildiğinde, uygulama yüklenmeden önce görüntüyü yüklemeye başlar ve uygulama daha hızlı yüklenmiş gibi görünür.

Ancak, eğer bu **anlık görüntü** **hassas bilgiler** içeriyorsa, anlık görüntüye erişimi olan biri bu bilgileri **çalabilir** (erişim için root gerekir).

Anlık görüntüler genellikle şu konumda saklanır: **`/data/system_ce/0/snapshots`**

Android, FLAG_SECURE layout parametresini ayarlayarak **screenshot capture'ını önlemeye** yarayan bir mekanizma sunar. Bu flag kullanıldığında, pencere içeriği güvenli olarak işaretlenir; böylece içerik screenshot'larda görünmez veya güvenli olmayan ekranlarda görüntülenemez.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Uygulama Analizörü**

Bu araç dinamik analiz sırasında farklı araçları yönetmenize yardımcı olabilir: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Geliştiriciler genellikle bu Intent'leri işleyen ve `startActivity(...)` veya `sendBroadcast(...)` gibi yöntemlere ileten activities, services ve broadcast receivers gibi proxy bileşenler oluşturur; bu riskli olabilir.

Tehlike, saldırganların bu Intent'leri yanlış yönlendirerek non-exported app bileşenlerini tetiklemesine veya hassas content providers'a erişmesine izin verilmesinde yatar. Önemli bir örnek, `WebView` bileşeninin URL'leri `Intent.parseUri(...)` ile `Intent` nesnelerine dönüştürmesi ve sonra bunları çalıştırmasıdır; bu, potansiyel olarak kötü niyetli Intent injection'larına yol açabilir.

### Temel Çıkarımlar

- **Intent Injection** web'deki Open Redirect sorununa benzer.
- Sömürüler, `Intent` nesnelerinin extras olarak geçirilmesini içerir; bu, tehlikeli işlemleri gerçekleştirmek için yönlendirilebilir.
- Bu, non-exported bileşenleri ve content providers'ı saldırganlara maruz bırakabilir.
- `WebView`'in URL'den `Intent`'e dönüşümü istenmeyen eylemlere olanak sağlayabilir.

### Android Client Side Injections ve diğerleri

Muhtemelen bu tür zaafiyetleri Web'den biliyorsunuzdur. Bir Android uygulamasında bu zaafiyetlere özellikle dikkat etmelisiniz:

- **SQL Injection:** Dinamik sorgular veya Content-Providers ile uğraşırken parameterized queries kullandığınızdan emin olun.
- **JavaScript Injection (XSS):** Herhangi bir WebView için JavaScript ve Plugin desteğinin devre dışı olduğundan emin olun (varsayılan olarak devre dışı). [Daha fazla bilgi için](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebView'lerin dosya sistemine erişiminin devre dışı olması gerekir (varsayılan olarak etkin) - `(webview.getSettings().setAllowFileAccess(false);)`. [Daha fazla bilgi için](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Birçok durumda Android uygulaması oturumu sonlandırdığında cookie iptal edilmez veya hatta diske kaydedilebilir.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Otomatik Analiz

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statik analiz**

![](<../../images/image (866).png>)

**Uygulamanın zafiyet değerlendirmesini** güzel bir web tabanlı frontend kullanarak yapar. Ayrıca dinamik analiz de gerçekleştirebilirsiniz (ancak ortamı hazırlamanız gerekir).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### MobSF ile Yardımlı Dinamik analiz

**MobSF** ayrıca **Android** için **dynamic analysis** konusunda da çok yardımcı olabilir, fakat bu durumda MobSF ve **genymotion**'ı host'unuza kurmanız gerekir (VM veya Docker çalışmayacaktır). _Not: Önce **genymotion**'da bir VM'i başlatmanız ve **sonra MobSF**'yi başlatmanız gerekir._\
**MobSF dynamic analyser** şunları yapabilir:

- **Dump application data** (URLs, logs, clipboard, sizin aldığınız ekran görüntüleri, "**Exported Activity Tester**" tarafından alınan ekran görüntüleri, e-postalar, SQLite veritabanları, XML dosyaları ve diğer oluşturulan dosyalar). Bunların tamamı ekran görüntüleri hariç otomatik olarak yapılır; ekran görüntüsü almak istediğinizde butona basmanız gerekir veya tüm exported aktivitelerin ekran görüntülerini elde etmek için "**Exported Activity Tester**"e basmanız gerekir.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Android **versions > 5**'ten itibaren, **Frida** otomatik olarak başlatılır ve trafiği yakalamak için global **proxy** ayarları yapılır. Yalnızca test edilen uygulamanın trafiği yakalanır.

**Frida**

Varsayılan olarak bazı Frida Scripts'leri **bypass SSL pinning**, **root detection** ve **debugger detection** işlemlerini gerçekleştirmek ve ilginç API'leri **monitor** etmek için kullanılır.\
MobSF ayrıca **invoke exported activities** yapabilir, bunların **screenshots**'larını alabilir ve rapor için **save** edebilir.

Dinamik testi **başlatmak** için yeşil butona: "**Start Instrumentation**" basın. Frida script'leri tarafından oluşturulan logları görmek için "**Frida Live Logs**" a, hooklanmış metodlara yapılan tüm çağrıları, geçirilen argümanları ve döndürülen değerleri görmek için "**Live API Monitor**"a basın (bu, "Start Instrumentation" a bastıktan sonra görünecektir).\
MobSF ayrıca kendi **Frida scripts**'lerinizi yüklemenize izin verir (Frida script'lerinizin sonuçlarını MobSF'ye göndermek için `send()` fonksiyonunu kullanın). Ayrıca yükleyebileceğiniz **several pre-written scripts** içerir (daha fazlasını `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` içine ekleyebilirsiniz), sadece **seçin**, "**Load**" a basın ve "**Start Instrumentation**" a basın (o script'lerin loglarını "**Frida Live Logs**" içinde görebileceksiniz).

![](<../../images/image (419).png>)

Ayrıca bazı yardımcı Frida işlevleri mevcuttur:

- **Enumerate Loaded Classes**: Yüklü tüm sınıfları yazdırır
- **Capture Strings**: Uygulamayı kullanırken yakalanan tüm stringleri yazdırır (çok gürültülü)
- **Capture String Comparisons**: Çok kullanışlı olabilir. Karşılaştırılan 2 stringi gösterir ve sonucun True mu False mu olduğunu belirtir.
- **Enumerate Class Methods**: Sınıf adını (ör. "java.io.File") girin ve sınıfın tüm metodlarını yazdırır.
- **Search Class Pattern**: Desene göre sınıfları arar
- **Trace Class Methods**: Bir sınıfın tamamını **Trace** eder (sınıfın tüm metodlarının girdi ve çıktılarını görün). Varsayılan olarak MobSF birkaç ilginç Android Api metodunu trace eder.

Kullanmak istediğiniz yardımcı modülü seçtikten sonra "**Start Intrumentation**" a basmanız gerekir ve tüm çıktıları "**Frida Live Logs**" içinde göreceksiniz.

**Shell**

MobSF ayrıca dynamic analysis sayfasının alt kısmında bazı **adb** komutları, **MobSF commands** ve yaygın **shell commands** içeren bir shell sağlar. Bazı ilginç komutlar:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

HTTP trafiği yakalandığında, yakalanan trafiğin çirkin bir görünümünü "**HTTP(S) Traffic**" butonunda veya daha iyi bir görünümünü "**Start HTTPTools**" yeşil butonunda görebilirsiniz. İkinci seçenekten, yakalanan istekleri Burp veya Owasp ZAP gibi **proxies**'lere **send** edebilirsiniz.\
Bunu yapmak için, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF ile dinamik analizi bitirdikten sonra "**Start Web API Fuzzer**" a basarak **fuzz http requests** yapabilir ve zafiyetlere bakabilirsiniz.

> [!TIP]
> MobSF ile dinamik analiz yaptıktan sonra proxy ayarları yanlış yapılandırılmış olabilir ve GUI üzerinden düzeltemeyebilirsiniz. Proxy ayarlarını şu şekilde düzeltebilirsiniz:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Aracı [**Inspeckage**](https://github.com/ac-pm/Inspeckage) adresinden edinebilirsiniz.\
Bu araç, dinamik analiz yaparken uygulamada **what is happening in the application** bilgisini vermek için bazı **Hooks** kullanır.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Bu, GUI ile **static analysis** yapmak için harika bir araçtır

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Bu araç, **security related Android application vulnerabilities** için hem **source code**'da hem de **packaged APKs** içinde arama yapmak üzere tasarlanmıştır. Araç ayrıca bulunan bazı zafiyetleri (Exposed activities, intents, tapjacking...) istismar etmek için deploy edilebilir bir "Proof-of-Concept" APK ve **ADB commands** oluşturma kabiliyetine sahiptir. Drozer'da olduğu gibi, test cihazını rootlamaya gerek yoktur.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Kolay referans için tüm çıkarılan dosyaları gösterir
- APK dosyalarını otomatik olarak Java ve Smali formatına decompile eder
- AndroidManifest.xml'i yaygın zayıflıklar ve davranışlar için analiz eder
- Yaygın zayıflıklar ve davranışlar için statik kaynak kod analizi
- Cihaz bilgileri
- ve daha fazlası
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER, Windows, MacOS X ve Linux'ta kullanılabilen bir komut satırı uygulamasıdır; _.apk_ dosyalarını güvenlik açıkları aramak için analiz eder. Bu, APK'ları açıp bu güvenlik açıklarını tespit etmek için bir dizi kural uygulayarak yapılır.

Tüm kurallar `rules.json` dosyasında toplanmıştır ve her şirket veya test uzmanı ihtiyaçlarına göre kendi kurallarını oluşturabilir.

En son binaries dosyalarını [download page](https://superanalyzer.rocks/download.html) üzerinden indirin.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn, mobil uygulamalarda [statik kod analizi](https://en.wikipedia.org/wiki/Static_program_analysis) gerçekleştiren geliştiriciler, bugbounty hunters ve ethical hackers için yardımcı olan bir **çok platformlu** araçtır.

Kavram şu: mobil uygulama dosyanızı (.apk veya .ipa dosyası) StaCoAn uygulamasına sürükleyip bırakırsınız ve uygulama sizin için görsel ve taşınabilir bir rapor oluşturur. Ayarları ve wordlists'i değiştirerek özelleştirilmiş bir deneyim elde edebilirsiniz.

İndir[ en son sürüm](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework, geliştiriciler ve hackers için Android uygulamalarındaki potansiyel güvenlik açıklarını bulmaya yardımcı olan bir Android zafiyet analiz sistemidir.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** bir araçtır; temel amacı bir Android uygulaması tarafından geliştirilebilecek potansiyel kötü niyetli davranışları tespit etmek ve kullanıcıyı uyarmaktır.

Tespit, uygulamanın Dalvik bytecode'unun **Smali** şeklinde temsil edilen halinin [`androguard`](https://github.com/androguard/androguard) kütüphanesi ile yapılan **static analysis** ile gerçekleştirilir.

Bu araç **"kötü" uygulamaların yaygın davranışlarını** şu örnekler gibi arar: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Bu araç, yaygın olarak kullanılan mobil uygulama reverse engineering ve analysis araçlarını bir araya getirerek mobil uygulamaları OWASP mobile security threats'e karşı test etmede yardımcı olur. Amacı, bu görevi mobil uygulama geliştiricileri ve güvenlik profesyonelleri için daha kolay ve daha kullanıcı dostu hale getirmektir.

It is able to:

- Farklı araçlar kullanarak Java ve Smali kodunu çıkarır
- APK'leri şu araçlarla analiz eder: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- APK'den regexps kullanarak özel bilgileri çıkarır.
- Manifest'i analiz eder.
- Bulunan domainleri şu araçlarla analiz eder: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) ve [whatweb](https://github.com/urbanadventurer/WhatWeb)
- APK'yi [apk-deguard.com](http://www.apk-deguard.com) üzerinden deobfuscate eder

### Koodous

Malware tespit etmek için faydalı: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Kodu obfuscate etmek için kullandığınız servis ve yapılandırmaya bağlı olarak, Secrets obfuscated durumda kalabilir veya kalmayabilir.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Bytecode'u optimize edebilir ve kullanılmayan talimatları tespit edip kaldırabilir. ProGuard özgür bir yazılımdır ve GNU General Public License, version 2 altında dağıtılır.

ProGuard, Android SDK'nın bir parçası olarak dağıtılır ve uygulama release modunda derlenirken çalışır.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- bir resource'u InputStream olarak yüklemek;
- sonucu decrypt etmek için FilterInputStream'ten türeyen bir sınıfa vermek;
- bir reverser'ın birkaç dakikasını boşa harcamak için bazı gereksiz obfuskasyonlar yapmak;
- decrypted sonucu bir ZipInputStream'e verip bir DEX dosyası elde etmek;
- son olarak ortaya çıkan DEX'i `loadDex` metodu ile bir Resource olarak yüklemek.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Obfuscated bir APK'yı platformlarına yükleyebilirsiniz.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b, ubuntu-mate tabanlı bir Android security virtual machine'dir; reverse engineering ve malware analysis için farklı güvenlik meraklıları ve araştırmacıların en son framework, tutorials ve labs koleksiyonunu içerir.

## References

- [Play Integrity API: How It Works & How to Bypass It](https://m4kr0.vercel.app/posts/play-integrity-api-how-it-works--how-to-bypass-it/)
- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) It is a great list of resources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
