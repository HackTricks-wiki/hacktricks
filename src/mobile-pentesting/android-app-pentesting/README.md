# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications Basics

यह पेज पढ़ना अत्यधिक अनुशंसित है ताकि आप **Android सुरक्षा से संबंधित सबसे महत्वपूर्ण भाग और किसी Android application में मौजूद सबसे खतरनाक कंपोनेंट्स** के बारे में जान सकें:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

यह उस मुख्य उपकरण है जिसकी आपको किसी Android device (emulated or physical) से कनेक्ट करने के लिए आवश्यकता होती है.\
**ADB** आपको कंप्यूटर से **USB** या **Network** के माध्यम से डिवाइस नियंत्रित करने की अनुमति देता है। यह यूटिलिटी दोनों दिशाओं में फ़ाइलों की **copying**, apps के **installation** और **uninstallation**, shell commands का **execution**, डेटा का **backing up**, लॉग्स का **reading**, और अन्य कार्यों की सुविधा देता है।

ADB उपयोग करने का तरीका जानने के लिए निम्नलिखित सूची [**ADB Commands**](adb-commands.md) देखें।

## Smali

कभी-कभी यह उपयोगी होता है कि आप **application code को modify करें** ताकि **hidden information** (शायद अच्छी तरह obfuscated passwords या flags) तक पहुँच सकें। फिर, APK को decompile करना, कोड modify करना और उसे फिर से recompile करना रोचक हो सकता है.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). यह dynamic analysis के दौरान किए जाने वाले कई परीक्षणों के लिए एक **alternative for several tests during the dynamic analysis** के रूप में बहुत उपयोगी हो सकता है। इसलिए, इस संभावना को **हमेशा ध्यान में रखें**।

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- डिवाइस से APK निकालें:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- सभी splits और base apks को [APKEditor](https://github.com/REAndroid/APKEditor) के साथ मर्ज करें:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## केस स्टडीज़ और कमजोरियाँ


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

सबसे पहले, एक APK का विश्लेषण करते समय आपको decompiler का उपयोग करके **Java code** को देखना चाहिए।\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### दिलचस्प जानकारी की तलाश

APK की **strings** को देखकर आप **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** और किसी भी रोचक चीज़ की खोज कर सकते हैं... कोड निष्पादन के लिए कोई **backdoors** या authentication backdoors (app में hardcoded admin credentials) भी खोजें।

**Firebase**

विशेष ध्यान दें **firebase URLs** पर और जाँचें कि क्या यह गलत तरीके से configured है। [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

किसी एप्लिकेशन की _Manifest.xml_ और _strings.xml_ फ़ाइलों की **जाँच संभावित सुरक्षा कमजोरियाँ उजागर कर सकती है**। इन फ़ाइलों तक decompilers का उपयोग कर के या APK का file extension .zip में बदलकर और फिर unzip करके पहुँचा जा सकता है।

**Manifest.xml** से पहचानी जाने वाली कमजोरियाँ शामिल हैं:

- **Debuggable Applications**: ऐसे Applications जो _Manifest.xml_ में `debuggable="true"` के रूप में सेट हैं जोखिम पैदा करते हैं क्योंकि ये कनेक्शन्स की अनुमति देते हैं जो exploitation की ओर ले जा सकते हैं। debuggable applications को ढूँढने और exploit करने के बारे में समझने के लिए एक tutorial देखें।
- **Backup Settings**: संवेदनशील जानकारी संभालने वाले applications के लिए `android:allowBackup="false"` attribute को स्पष्ट रूप से सेट किया जाना चाहिए ताकि adb के माध्यम से अनधिकृत डेटा backups को रोका जा सके, खासकर जब usb debugging सक्षम हो।
- **Network Security**: कस्टम network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) जो _res/xml/_ में होते हैं certificate pins और HTTP traffic सेटिंग्स जैसी सुरक्षा जानकारी निर्दिष्ट कर सकते हैं। एक उदाहरण विशिष्ट डोमेनों के लिए HTTP traffic की अनुमति देना है।
- **Exported Activities and Services**: Manifest में exported activities और services की पहचान ऐसे कम्पोनेंट्स को उजागर कर सकती है जिन्हें गलत तरीके से misuse किया जा सकता है। dynamic testing के दौरान आगे की जांच यह बतायेगी कि इन कम्पोनेंट्स को कैसे exploit किया जा सकता है।
- **Content Providers and FileProviders**: एक्सपोज़्ड content providers अनधिकृत पहुँच या डेटा में संशोधन की अनुमति दे सकते हैं। FileProviders की configuration भी ध्यान से जाँची जानी चाहिए।
- **Broadcast Receivers and URL Schemes**: ये कम्पोनेंट्स exploitation के लिए उपयोग किए जा सकते हैं, विशेष ध्यान URL schemes के प्रबंधन पर रखें ताकि input vulnerabilities न हों।
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, और `maxSdkVersion` attributes यह बताती हैं कि कौन से Android versions समर्थित हैं, और यह दर्शाता है कि सुरक्षा कारणों से पुराने, vulnerable Android versions का समर्थन न करना क्यों महत्वपूर्ण है।

**strings.xml** फ़ाइल से संवेदनशील जानकारी जैसे API keys, custom schemas, और अन्य developer notes मिल सकती हैं, जो इन resources की सावधानीपूर्वक समीक्षा की आवश्यकता को रेखांकित करता है।

### Tapjacking

Tapjacking एक ऐसा हमला है जहाँ एक malicious application लॉन्च की जाती है और victim application के ऊपर खुद को position कर लेती है। जब यह victim app को दृश्य रूप से अस्पष्ट कर देती है, तो इसका user interface इस तरह डिज़ाइन किया जाता है कि यूज़र को इसके साथ interact करने में धोखा दिया जाए, जबकि यह interaction victim app को pass कर देती है।\
प्रभावतः यह यूज़र को अंधा कर देता है कि वे वास्तव में victim app पर कार्य कर रहे हैं।

अधिक जानकारी के लिए देखें:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

एक activity जिसका `launchMode` `singleTask` पर सेट है और किसी भी `taskAffinity` को परिभाषित नहीं किया गया है वह task Hijacking के लिए vulnerable होती है। इसका मतलब है कि एक malicious application इंस्टॉल की जा सकती है और यदि उसे असली application से पहले लॉन्च किया गया तो यह असली application के task को hijack कर सकती है (तो यूज़र यह सोचकर malicious application के साथ interact करेगा कि वह असली एप का उपयोग कर रहा है)।

अधिक जानकारी के लिए देखें:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### असुरक्षित डेटा स्टोरेज

**Internal Storage**

Android में, आंतरिक storage में संग्रहीत फ़ाइलें सामान्यतः उन्हीं apps द्वारा पहुँच योग्य होने के लिए डिज़ाइन की गई हैं जिन्होंने उन्हें बनाया है। यह सुरक्षा उपाय Android operating system द्वारा लागू किया जाता है और अधिकांश एप्लिकेशन की सुरक्षा आवश्यकताओं के लिए पर्याप्त होता है। फिर भी, डेवलपर कभी-कभी `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` जैसे मोड का उपयोग करते हैं ताकि फ़ाइलें विभिन्न applications के बीच साझा की जा सकें। ये मोड अन्य applications, जिनमें संभावित रूप से malicious ones भी शामिल हैं, के लिए इन फ़ाइलों तक unrestricted access की अनुमति दे सकते हैं।

1. **Static Analysis:**
- **सुनिश्चित करें** कि `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` के उपयोग की **सावधानीपूर्वक जांच** की गयी हो। ये मोड फ़ाइलों को **अनचाही या अनधिकृत पहुँच** के लिए उजागर कर सकते हैं।
2. **Dynamic Analysis:**
- ऐप द्वारा बनाई गई फ़ाइलों पर सेट किए गए **permissions** की **जाँच** करें। विशेष रूप से, देखें कि क्या कोई फ़ाइलें worldwide readable या writable के रूप में सेट की गई हैं। यह एक गंभीर सुरक्षा जोखिम हो सकता है, क्योंकि इससे किसी भी installed application को, उसके स्रोत या इरादे की परवाह किए बिना, इन फ़ाइलों को **read या modify** करने की अनुमति मिल जाएगी।

**External Storage**

SD Cards जैसे external storage पर फ़ाइलों के साथ काम करते समय कुछ सावधानियाँ बरतनी चाहिए:

1. **Accessibility**:
- External storage पर फ़ाइलें **global रूप से readable और writable** होती हैं। इसका अर्थ है किसी भी application या यूज़र द्वारा इन फ़ाइलों तक पहुँच संभव है।
2. **Security Concerns**:
- इस आसान पहुँच के कारण, संवेदनशील जानकारी को external storage पर स्टोर नहीं करना चाहिए।
- External storage को हटाया जा सकता है या किसी भी application द्वारा एक्सेस किया जा सकता है, जिससे यह कम सुरक्षित हो जाता है।
3. **Handling Data from External Storage**:
- External storage से प्राप्त डेटा पर हमेशा **input validation** करें। यह महत्वपूर्ण है क्योंकि यह डेटा एक untrusted स्रोत से आता है।
- External storage पर executables या class files को dynamic loading के लिए स्टोर करना सख्त तौर पर discouraged है।
- यदि आपका application external storage से executable files प्राप्त करता है, तो सुनिश्चित करें कि ये फाइलें **signed और cryptographically verified** हों इससे पहले कि उन्हें dynamically load किया जाए। यह कदम आपके application की सुरक्षा एकता बनाए रखने के लिए आवश्यक है।

External storage का access `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` में किया जा सकता है

> [!TIP]
> Android 4.4 (**API 17**) से शुरू होकर, SD card में एक directory संरचना है जो किसी app के लिए विशेष रूप से उस app के directory तक ही पहुँच को सीमित करती है। यह एक malicious application को किसी अन्य app की फ़ाइलों तक read या write access प्राप्त करने से रोकता है।

**Sensitive data stored in clear-text**

- **Shared preferences**: Android प्रत्येक application को `/data/data/<packagename>/shared_prefs/` पथ में आसानी से xml फ़ाइलें सहेजने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।
- **Databases**: Android प्रत्येक application को `/data/data/<packagename>/databases/` पथ में आसानी से sqlite databases सहेजने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।

### Broken TLS

Accept All Certificates

कई बार डेवलपर्स किसी कारणवश सभी certificates को स्वीकार कर लेते हैं भले ही उदाहरण के लिए hostname मैच न करता हो, इसके लिए कोड की लाइनों जैसे निम्न का उपयोग किया जाता है:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

कुछ डेवलपर संवेदनशील डेटा को local storage में सेव करते हैं और इसे कोड में hardcoded/predictable key से encrypt करते हैं। ऐसा नहीं करना चाहिए क्योंकि कुछ reversing तकनीकें attackers को confidential जानकारी निकालने में सक्षम बना सकती हैं।

**Use of Insecure and/or Deprecated Algorithms**

डेवलपर्स को authorization checks, data को store या send करने के लिए **deprecated algorithms** का उपयोग नहीं करना चाहिए। इनमे कुछ algorithms हैं: RC4, MD4, MD5, SHA1... यदि पासवर्ड स्टोर करने के लिए **hashes** का उपयोग किया जा रहा है, तो salt के साथ brute-force **resistant** hashes का उपयोग होना चाहिए।

### Other checks

- यह सलाह दी जाती है कि **APK को obfuscate** किया जाए ताकि reverse engineer करने में attackers की मेहनत मुश्किल हो।
- यदि ऐप sensitive है (जैसे bank apps), तो उसे अपने **खुद के checks to see if the mobile is rooted** करने चाहिए और उसके अनुसार व्यवहार करना चाहिए।
- यदि ऐप sensitive है (जैसे bank apps), तो उसे जाँचना चाहिए कि क्या कोई **emulator** उपयोग में है।
- यदि ऐप sensitive है (जैसे bank apps), तो उसे **execute करने से पहले अपनी integrity check** करनी चाहिए ताकि पता चले कि क्या इसे modify किया गया है।
- Use [**APKiD**](https://github.com/rednaga/APKiD) यह चेक करने के लिए कि किस compiler/packer/obfuscator का उपयोग करके APK बनाया गया है

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

एक application में secrets (API keys, passwords, hidden urls, subdomains...) हो सकते हैं जिन्हें आप खोज सकते हैं। आप ऐसे टूल का उपयोग कर सकते हैं जैसे [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

आपको **debugging** options को activate करना होगा और अच्छा होगा अगर आप इसे **root** कर सकें:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

डेवलपर्स को सार्वजनिक रूप से **debugging information** उजागर करने में सावधान रहना चाहिए, क्योंकि इससे sensitive data का leak हो सकता है। application logs की निगरानी करने के लिए tools [**pidcat**](https://github.com/JakeWharton/pidcat) और `adb logcat` की सलाह दी जाती है ताकि संवेदनशील जानकारी की पहचान की जा सके और उसे सुरक्षित किया जा सके। **Pidcat** अपनी आसान उपयोगिता और readability के कारण पसंद किया जाता है।

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android का **clipboard-based** framework apps में copy-paste functionality सक्षम करता है, पर यह जोखिम भी पैदा करता है क्योंकि **other applications** clipboard को access कर सकती हैं, जिससे संवेदनशील डेटा उजागर हो सकता है। इसलिए application के sensitive हिस्सों (जैसे credit card details) के लिए copy/paste functions को disable करना महत्वपूर्ण है ताकि data leak रोका जा सके।

**Crash Logs**

यदि कोई application **crashes** करता है और logs save करता है, तो ये logs attackers की मदद कर सकते हैं, खासकर जब application को reverse-engineer नहीं किया जा सकता। इस जोखिम को कम करने के लिए, crash पर logging से बचें, और यदि logs को network पर भेजना जरूरी है तो उन्हें SSL चैनल के जरिए भेजें।

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications अक्सर Google Adsense जैसे services integrate करते हैं, जो developers की improper implementation के कारण संवेदनशील डेटा को inadvertently **leak** कर सकते हैं। संभावित data leaks की पहचान के लिए, यह सलाह दी जाती है कि आप application's traffic को intercept करें और किसी भी sensitive information की third-party services को भेजी जा रही हो तो जांचें।

### SQLite DBs

अधिकतर applications internal SQLite databases का उपयोग करके information save करते हैं। Pentest के दौरान बनाए गए **databases**, **tables** और **columns** के नामों और उनमें saved सभी **data** को देखना चाहिए क्योंकि आप वहां से **sensitive information** (जो vulnerability होगी) पा सकते हैं।\
Databases को `/data/data/the.package.name/databases` में locate किया जाना चाहिए जैसे `/data/data/com.mwr.example.sieve/databases`

यदि database confidential information save कर रहा है और **encrypted** है पर आप application के अंदर **password** ढूँढ सकते हैं तो यह फिर भी एक **vulnerability** है।

.tables का उपयोग करके tables को enumerate करें और `.schema <table_name>` चलाकर tables के columns enumerate करें

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> ध्यान दें कि एक authorisation bypass हमेशा एक vulnerability नहीं होता; यह इस पर निर्भर करेगा कि bypass कैसे काम करता है और कौन-सी जानकारी exposed होती है।

**संवेदनशील जानकारी leakage**

**Activities भी परिणाम वापस कर सकती हैं**। यदि आप कोई exported और unprotected activity ढूंढते हैं जो **`setResult`** method कॉल कर रही हो और **संवेदनशील जानकारी return कर रही हो**, तो यह एक संवेदनशील जानकारी leakage है।

#### Tapjacking

यदि Tapjacking रोका न गया हो, तो आप exported activity का दुरुपयोग करके **user को अनपेक्षित actions करने के लिए प्रेरित कर सकते हैं**। अधिक जानकारी के लिए [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers मूल रूप से डेटा **share** करने के लिए उपयोग होते हैं। यदि किसी app में content providers उपलब्ध हैं तो आप उनसे संवेदनशील डेटा **extract** कर सकते हैं। साथ ही यह दिलचस्प होगा संभवतः **SQL injections** और **Path Traversals** को टेस्ट करना क्योंकि वे vulnerable हो सकते हैं।

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
ध्यान रखें कि Service की actions method `onStartCommand` में शुरू होती हैं।

Service मूल रूप से ऐसा component है जो **data receive** कर सकता है, उसे **process** करता है और (या नहीं) response **return** कर सकता है। इसलिए, यदि कोई application कुछ services export कर रही है तो आपको **code** जांचना चाहिए यह समझने के लिए कि यह क्या कर रहा है और इसे **dynamically** टेस्ट करना चाहिए ताकि confidential जानकारी निकाली जा सके, authentication measures bypass किए जा सकें...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
ध्यान रखें कि Broadcast Receiver के actions method `onReceive` में शुरू होते हैं।

एक broadcast receiver किसी प्रकार के message की प्रतीक्षा करेगा। यह इस पर निर्भर करेगा कि receiver उस message को कैसे handle करता है कि वह vulnerable हो सकता है।\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

आप deep links को manually खोज सकते हैं, MobSF जैसे tools या [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) जैसी scripts का उपयोग करके।\
आप किसी declared **scheme** को **adb** या एक **browser** का उपयोग करके **open** कर सकते हैं:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_ध्यान दें कि आप **पैकेज नाम छोड़ सकते हैं** और मोबाइल अपने आप उस ऐप को कॉल करेगा जो उस लिंक को खोलना चाहिए।_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

In order to find the **code that will be executed in the App**, go to the activity called by the deeplink and search the function **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**संवेदनशील जानकारी**

Every time you find a deep link check that i**t's not receiving sensitive data (like passwords) via URL parameters**, because any other application could **impersonate the deep link and steal that data!**

**Parameters in path**

You **must check also if any deep link is using a parameter inside the path** of the URL like: `https://api.example.com/v1/users/{username}` , in that case you can force a path traversal accessing something like: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note that if you find the correct endpoints inside the application you may be able to cause a **Open Redirect** (if part of the path is used as domain name), **account takeover** (if you can modify users details without CSRF token and the vuln endpoint used the correct method) and any other vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. It's common for these applications to overlook warnings and accept self-signed certificates or, in some instances, revert to using HTTP connections.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, employing insecure cipher suites. This vulnerability makes the connection susceptible to man-in-the-middle (MITM) attacks, allowing attackers to decrypt the data.
- Leakage of private information is a risk when applications authenticate using secure channels but then communicate over non-secure channels for other transactions. इस तरह का व्यवहार sensitive data, जैसे session cookies या user details, को malicious entities द्वारा इंटरसेप्ट होने से सुरक्षित नहीं रखता।

#### Certificate Verification

हम **certificate verification** पर ध्यान देंगे। सर्वर के certificate की integrity को verify करना सुरक्षा बढ़ाने के लिए आवश्यक है। यह महत्वपूर्ण है क्योंकि insecure TLS configurations और संवेदनशील डेटा का unencrypted चैनलों पर ट्रांसमिशन गंभीर जोखिम उत्पन्न कर सकता है। सर्वर certificates की verification और vulnerabilities को ठीक करने के विस्तृत चरणों के लिए, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) व्यापक मार्गदर्शन देता है।

#### SSL Pinning

SSL Pinning एक सुरक्षा उपाय है जहाँ application सर्वर के certificate की तुलना application में संग्रहित ज्ञात कॉपी के साथ करती है। यह तरीका MITM attacks को रोकने के लिए आवश्यक है। संवेदनशील जानकारी संभालने वाली applications के लिए SSL Pinning लागू करना दृढ़तापूर्वक अनुशंसित है।

#### Traffic Inspection

HTTP ट्रैफिक inspect करने के लिए, proxy tool का certificate (उदा. Burp) **install** करना ज़रूरी है। इस certificate को install किए बिना, encrypted ट्रैफिक proxy के माध्यम से दिखाई नहीं दे सकता। custom CA certificate install करने के गाइड के लिए, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine) देखें।

Applications targeting **API Level 24 and above** को Network Security Config में बदलाव करने की आवश्यकता होती है ताकि वे proxy के CA certificate को accept करें। encrypted ट्रैफिक inspect करने के लिए यह कदम महत्वपूर्ण है। Network Security Config बदलने के निर्देशों के लिए, [**refer to this tutorial**](make-apk-accept-ca-certificate.md) देखें।

यदि **Flutter** उपयोग किया जा रहा है तो आपको [**this page**](flutter.md) में दिए निर्देशों का पालन करना होगा। ऐसा इसलिए है क्योंकि केवल certificate को store में जोड़ने से काम नहीं चलेगा क्योंकि Flutter की अपनी valid CAs की सूची होती है।

#### Static detection of SSL/TLS pinning

runtime bypasses का प्रयास करने से पहले जल्दी से मैप करें कि APK में pinning कहाँ enforce हो रहा है। static discovery आपको hooks/patches की योजना बनाने और सही कोड पाथ्स पर ध्यान केंद्रित करने में मदद करता है।

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
उपयोग
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
उदाहरण पैटर्न नियम (JSON)

signatures का उपयोग करें या उन्हें बढ़ाएँ ताकि proprietary/custom pinning styles का पता लगाया जा सके। आप अपना JSON लोड करके बड़े पैमाने पर स्कैन कर सकते हैं।
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- बड़े ऐप्स पर तेज़ स्कैनिंग के लिए multi-threading और memory-mapped I/O का उपयोग करें; pre-compiled regex overhead/false positives कम करता है।
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- अगले ट्रायेज के लिए सामान्य detection targets:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config और manifest references
- मैच हुई लोकेशन्स का उपयोग Frida hooks, static patches, या config reviews की योजना बनाने के लिए करें, जिससे dynamic testing से पहले काम आसान हो।

#### Bypassing SSL Pinning

जब SSL Pinning लागू होता है, तो HTTPS ट्रैफ़िक का निरीक्षण करने के लिए इसे bypass करना आवश्यक हो जाता है। इसके लिए कई तरीके उपलब्ध हैं:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). इस विकल्प का सबसे बड़ा फायदा यह है कि आपको SSL Pinning bypass करने के लिए root की ज़रूरत नहीं पड़ेगी, लेकिन आपको एप्लिकेशन को डिलीट करके नया इंस्टॉल करना होगा, और यह हर बार काम नहीं करेगा।
- आप इस प्रोटेक्शन को bypass करने के लिए **Frida** (नीचे चर्चा की गई) का उपयोग कर सकते हैं। Burp+Frida+Genymotion उपयोग करने का गाइड यहाँ है: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- आप [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"` का उपयोग करके SSL Pinning को automatically bypass करने की कोशिश भी कर सकते हैं।
- आप **MobSF dynamic analysis** (नीचे समझाया गया) का उपयोग करके भी SSL Pinning को automatically bypass करने का प्रयास कर सकते हैं।
- अगर आपको लगता है कि कुछ ट्रैफ़िक आप पकड़ नहीं पा रहे हैं तो आप ट्रैफ़िक को burp पर forward करने के लिए iptables का उपयोग कर सकते हैं। इस ब्लॉग को पढ़ें: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

एप्लिकेशन के अंदर सामान्य वेब कमजोरियों की तलाश भी महत्वपूर्ण है। इन कमजोरियों की पहचान और उनका निवारण करने के विस्तृत विवरण इस सारांश के दायरे से बाहर है, लेकिन अन्यत्र व्यापक रूप से कवर किया गया है।

### Frida

[Frida](https://www.frida.re) developers, reverse-engineers, और security researchers के लिए एक dynamic instrumentation toolkit है.\
**आप running application तक पहुँच सकते हैं और रन-टाइम पर methods को hook करके व्यवहार बदल सकते हैं, values बदल सकते हैं, values extract कर सकते हैं, अलग code चला सकते हैं...**\
अगर आप Android applications को pentest करना चाहते हैं तो आपको Frida का उपयोग करना आना चाहिए।

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Frida के साथ actions के लिए कुछ "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection Frida के उपयोग को automate करने के लिए अच्छा है: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- कुछ Awesome Frida scripts यहाँ मिल सकते हैं: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- anti-debugging / anti-frida mechanisms को bypass करने की कोशिश करें, Frida को वैसा लोड करके जैसा यहाँ बताया गया है: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

जाँचें कि क्या एप्लिकेशन मेमोरी के अंदर संवेदनशील जानकारी स्टोर कर रहा है जिसे उसे स्टोर नहीं करना चाहिए, जैसे passwords या mnemonics।

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
यह ./dump फ़ोल्डर में memory dump करेगा, और वहां आप कुछ इस तरह grep कर सकते हैं:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore में संवेदनशील डेटा**

Android में Keystore संवेदनशील डेटा स्टोर करने के लिए सबसे अच्छा स्थान है, हालांकि पर्याप्त privileges होने पर इसमें अभी भी **इस तक पहुँच संभव है**।

कई एप्लिकेशन यहाँ **स्पष्ट टेक्स्ट में संवेदनशील डेटा** स्टोर करने की प्रवृत्ति रखते हैं, इसलिए pentests को इसे चेक करना चाहिए क्योंकि root user या किसी के पास physical access होने पर वे यह डेटा चुरा सकते हैं।

भले ही कोई app keystore में डेटा स्टोर करे, डेटा एन्क्रिप्टेड होना चाहिए।

keystore के अंदर के डेटा तक पहुँचने के लिए आप यह Frida script उपयोग कर सकते हैं: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

निम्नलिखित Frida स्क्रिप्ट का उपयोग करके संभवतः Android एप्लिकेशन द्वारा **bypass fingerprint authentication** को लागू करके **कुछ संवेदनशील क्षेत्रों की रक्षा** के लिए किए जा रहे उपायों को दरकिनार किया जा सकता है:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **पृष्ठभूमि छवियाँ**

जब आप किसी application को background में डालते हैं, Android एक **snapshot of the application** स्टोर करता है ताकि जब इसे foreground में लौटाया जाए तो यह app के बजाय पहले image लोड करना शुरू कर दे और ऐसा लगे कि ऐप तेज़ी से लोड हुआ।

हालाँकि, यदि यह **snapshot** में **संवेदनशील जानकारी** होती है, तो snapshot तक पहुँच रखने वाला कोई व्यक्ति उस जानकारी को चुरा सकता है (ध्यान दें कि इसे एक्सेस करने के लिए आपको root की आवश्यकता होती है)।

Snapshots आमतौर पर यहाँ स्टोर होते हैं: **`/data/system_ce/0/snapshots`**

Android एक तरीका प्रदान करता है कि **FLAG_SECURE** layout parameter सेट करके screenshot capture को रोका जा सके। इस flag का इस्तेमाल करने पर, window की सामग्री को secure माना जाता है, जिससे यह screenshots में दिखाई देने या गैर‑सुरक्षित displays पर दिखने से रोका जाता है।
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

यह टूल डायनामिक विश्लेषण के दौरान विभिन्न tools को मैनेज करने में मदद कर सकता है: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developers अक्सर activities, services, और broadcast receivers जैसे proxy components बनाते हैं जो इन Intents को हैंडल करते हैं और उन्हें `startActivity(...)` या `sendBroadcast(...)` जैसी methods को पास कर देते हैं, जो जोखिमपूर्ण हो सकता है।

खतरा तब होता है जब attackers इन Intents को misdirect करके non-exported app components को trigger कर पाते हैं या sensitive content providers तक पहुँच बना लेते हैं। एक प्रमुख उदाहरण `WebView` component है जो URLs को `Intent.parseUri(...)` के ज़रिये `Intent` objects में बदलता है और उन्हें execute करता है, जिससे malicious Intent injections संभव हो सकते हैं।

### Essential Takeaways

- **Intent Injection** web के Open Redirect issue जैसा है।
- Exploits में `Intent` objects को extras के रूप में पास करना शामिल है, जिन्हें redirect करके unsafe operations execute किए जा सकते हैं।
- यह non-exported components और content providers को attackers के लिए उजागर कर सकता है।
- `WebView` की URL से `Intent` conversion अनिच्छित क्रियाओं को आसान बना सकती है।

### Android Client Side Injections and others

संभवतः आप Web से इस तरह की vulnerabilities को जानते होंगे। Android application में इन vulnerabilities के साथ विशेष सावधानी बरतनी चाहिए:

- **SQL Injection:** जब dynamic queries या Content-Providers से काम कर रहे हों तो सुनिश्चित करें कि आप parameterized queries का उपयोग कर रहे हैं।
- **JavaScript Injection (XSS):** सुनिश्चित करें कि किसी भी WebViews के लिए JavaScript और Plugin support disabled हो (default में disabled)। [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews का file system access disabled होना चाहिए (default में enabled) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: कई मामलों में जब Android application session समाप्त करता है, cookie revoke नहीं होती या disk पर भी save हो सकती है
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** एक आकर्षक web-based frontend के माध्यम से करता है। आप dynamic analysis भी कर सकते हैं (पर आपको environment तैयार करना होगा)।
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** Android में **dynamic analysis** के लिए भी बहुत उपयोगी हो सकता है, लेकिन उस मामले में आपको अपने होस्ट पर MobSF और **genymotion** इंस्टॉल करने की आवश्यकता होगी (VM या Docker काम नहीं करेगा)। _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** निम्न कर सकता है:

- **Dump application data**: (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files)। ये सब ऑटोमैटिकली किया जाता है सिवाय screenshots के — screenshots के लिए आपको तब प्रेस करना होगा जब आप screenshot लेना चाहें या "**Exported Activity Tester**" दबाकर सभी exported activities के screenshots हासिल कर सकते हैं।
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

android के **versions > 5** से, यह **automatically start Frida** करेगा और ट्रैफ़िक capture करने के लिए global **proxy** settings सेट कर देगा। यह केवल टेस्ट किए जा रहे application का ट्रैफ़िक ही capture करेगा।

**Frida**

डिफ़ॉल्ट रूप से, यह कुछ Frida Scripts भी उपयोग करेगा ताकि **SSL pinning** को bypass किया जा सके, **root detection** और **debugger detection** को बायपास किया जा सके और **interesting APIs** की निगरानी की जा सके।\
MobSF exported activities को invoke भी कर सकता है, उनके **screenshots** ले सकता है और रिपोर्ट के लिए उन्हें **save** कर सकता है।

डायनामिक टेस्ट शुरू करने के लिए हरे बटन पर प्रेस करें: "**Start Instrumentation**". "**Frida Live Logs**" दबाकर आप Frida scripts द्वारा जनरेट किए गए logs देख सकते हैं और "**Live API Monitor**" दबाकर आप hooked methods के सभी invocation, पास किए गए arguments और returned values देख सकते हैं (यह "Start Instrumentation" दबाने के बाद दिखाई देगा)।\
MobSF आपको अपने खुद के **Frida scripts** लोड करने की भी अनुमति देता है (अपने Frida scripts के परिणाम MobSF को भेजने के लिए `send()` function का उपयोग करें)। इसके साथ कई pre-written scripts भी आते हैं जिन्हें आप लोड कर सकते हैं (आप और जोड़ सकते हैं `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` में), बस उन्हें **select** करें, "**Load**" दबाएं और "**Start Instrumentation**" दबाएं (आप उन scripts के logs "**Frida Live Logs**" के अंदर देख पाएंगे)।

![](<../../images/image (419).png>)

इसके अलावा, कुछ Auxiliary Frida सुविधाएं भी हैं:

- **Enumerate Loaded Classes**: यह सभी loaded classes को print करेगा
- **Capture Strings**: एप्लिकेशन उपयोग करते समय सभी captured strings को print करेगा (बहुत noisy)
- **Capture String Comparisons**: बहुत उपयोगी हो सकता है। यह **show the 2 strings being compared** करेगा और बताएगा कि result True था या False।
- **Enumerate Class Methods**: क्लास का नाम डालें (जैसे "java.io.File") और यह उस क्लास के सभी methods print करेगा।
- **Search Class Pattern**: pattern से classes खोजें
- **Trace Class Methods**: किसी पूरी क्लास को **Trace** करें (क्लास के सभी methods के inputs और outputs देखें)। ध्यान रखें कि डिफ़ॉल्ट रूप से MobSF कई दिलचस्प Android Api methods को trace करता है।

एक बार जब आप वह auxiliary module चुन लें जिसे आप उपयोग करना चाहते हैं, तो आपको "**Start Intrumentation**" दबाना होगा और आप सभी outputs "**Frida Live Logs**" में देखेंगे।

**Shell**

MobSF आपको dynamic analysis पेज के नीचे कुछ **adb** commands, **MobSF commands**, और सामान्य **shell commands** के साथ एक shell भी देता है। कुछ दिलचस्प commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

जब http ट्रैफ़िक कैप्चर होता है तो आप कैप्चर किए गए ट्रैफ़िक का एक खराब व्यू "**HTTP(S) Traffic**" बॉटम पर देख सकते हैं या "**Start HTTPTools**" हरे बटन में एक बेहतर व्यू। दूसरी विकल्प से, आप **send** करके **captured requests** को **proxies** जैसे Burp या Owasp ZAP में भेज सकते हैं.\
ऐसा करने के लिए, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> दबाएँ "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF के साथ dynamic analysis समाप्त करने के बाद आप "**Start Web API Fuzzer**" दबाकर **fuzz http requests** करके कमजोरियों की खोज कर सकते हैं।

> [!TIP]
> MobSF के साथ dynamic analysis करने के बाद proxy सेटिंग्स ग़लत हो सकती हैं और आप उन्हें GUI से ठीक नहीं कर पाएँगे। आप प्रॉक्सी सेटिंग्स को इस कमांड से ठीक कर सकते हैं:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

आप यह टूल [**Inspeckage**](https://github.com/ac-pm/Inspeckage) से प्राप्त कर सकते हैं।\
यह टूल कुछ **Hooks** का उपयोग करता है ताकि जब आप **dynamic analysis** कर रहे हों तो यह आपको बताये **what is happening in the application**।

### [Yaazhini](https://www.vegabird.com/yaazhini/)

यह एक **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

यह टूल कई प्रकार की **security related Android application vulnerabilities** खोजने के लिए डिज़ाइन किया गया है, चाहे वो **source code** में हों या **packaged APKs** में। यह टूल कुछ मिली कमजोरियों का इस्तेमाल करने के लिए **capable of creating a "Proof-of-Concept" deployable APK** और **ADB commands** भी बना सकता है (Exposed activities, intents, tapjacking...). Drozer की तरह, टेस्ट डिवाइस को root करने की आवश्यकता नहीं है।
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- सभी निकाली गई फ़ाइलों को आसान संदर्भ के लिए दिखाता है
- APK files को स्वतः Java और Smali फ़ॉर्मेट में decompile करता है
- AndroidManifest.xml का विश्लेषण सामान्य vulnerabilities और व्यवहार के लिए
- Static source code analysis सामान्य vulnerabilities और व्यवहार के लिए
- डिवाइस जानकारी
- और भी बहुत कुछ
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER एक command-line application है जिसे Windows, MacOS X और Linux पर इस्तेमाल किया जा सकता है, जो _.apk_ फ़ाइलों का vulnerabilities की तलाश में विश्लेषण करता है। यह APKs को decompress करके और नियमों की एक श्रृंखला लागू करके उन vulnerabilities का पता लगाता है।

सभी rules `rules.json` फ़ाइल में केंद्रीकृत हैं, और हर कंपनी या tester अपनी ज़रूरत के अनुसार विश्लेषण के लिए अपने नियम बना सकता है।

Latest binaries डाउनलोड करने के लिए [download page](https://superanalyzer.rocks/download.html) देखें
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn एक **crossplatform** टूल है जो developers, bugbounty hunters और ethical hackers को मोबाइल applications पर [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) करने में मदद करता है।

विचार यह है कि आप अपना मोबाइल application फ़ाइल (.apk या .ipa फ़ाइल) StaCoAn application पर drag and drop करें और यह आपके लिए एक visual और portable रिपोर्ट तैयार करेगा। आप settings और wordlists को tweak करके एक customized अनुभव प्राप्त कर सकते हैं।

डाउनलोड[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework एक Android vulnerability analysis system है जो developers या hackers को Android applications में संभावित security vulnerabilities खोजने में मदद करता है.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** एक ऐसा टूल है जिसका मुख्य उद्देश्य Android application द्वारा विकसित संभावित हानिकारक व्यवहारों का पता लगाना और उपयोगकर्ता को चेतावनी देना है।

पता लगाने की प्रक्रिया एप्लिकेशन के Dalvik bytecode का **static analysis** करके की जाती है, जो **Smali** के रूप में प्रदर्शित होता है, और इसके लिये [`androguard`](https://github.com/androguard/androguard) लाइब्रेरी का उपयोग किया जाता है।

यह टूल **common behavior of "bad" applications** जैसी गतिविधियों को खोजता है, जैसे: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** एक **M**obile **A**pplication **R**everse engineering और **A**nalysis Framework है। यह उन सामान्य रूप से उपयोग किए जाने वाले mobile application reverse engineering और analysis tools को एक साथ जोड़ने वाला एक टूल है, ताकि OWASP mobile security threats के खिलाफ mobile applications का परीक्षण करने में मदद मिल सके। इसका उद्देश्य mobile application developers और security professionals के लिए यह कार्य आसान और उपयोगकर्ता-अनुकूल बनाना है।

यह सक्षम है:

- विभिन्न टूल्स का उपयोग करके Java और Smali कोड निकालने के लिए
- APKs का विश्लेषण करने के लिए: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- regexps का उपयोग करके APK से private जानकारी निकालने के लिए।
- Manifest का विश्लेषण करने के लिए।
- मिले हुए domains का विश्लेषण करने के लिए: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) और [whatweb](https://github.com/urbanadventurer/WhatWeb)
- [apk-deguard.com](http://www.apk-deguard.com) के माध्यम से APK को deobfuscate करने के लिए

### Koodous

मैलवेयर का पता लगाने के लिए उपयोगी: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

ध्यान दें कि आप जो सेवा और कॉन्फ़िगरेशन उपयोग करते हैं उसके आधार पर कोड को obfuscate करते समय Secrets obfuscated हो भी सकते हैं या नहीं भी।

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** एक open source कमांड-लाइन टूल है जो Java कोड को shrink, optimize और obfuscate करता है। यह bytecode को optimize करने के साथ-साथ उपयोग न होने वाले निर्देशों का पता लगाकर उन्हें हटा भी सकता है। ProGuard free software है और GNU General Public License, version 2 के तहत वितरित किया जाता है।

ProGuard Android SDK के हिस्से के रूप में वितरित होता है और application को release mode में build करते समय चलाया जाता है।

### [DexGuard](https://www.guardsquare.com/dexguard)

APk को deobfuscate करने के लिए step-by-step guide देखें: [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(उस गाइड से) आखिरी बार जब हमने देखा था, Dexguard का mode of operation इस प्रकार था:

- किसी resource को InputStream के रूप में load करें;
- decrypted करने के लिए परिणाम को FilterInputStream से inheriting करने वाली किसी class को feed करें;
- reverer के समय बर्बाद करने के लिए कुछ बेकार obfuscation करें;
- decrypted परिणाम को ZipInputStream को feed करें ताकि DEX फ़ाइल मिले;
- अंत में `loadDex` method का उपयोग करके resulting DEX को एक Resource के रूप में load करें।

### [DeGuard](http://apk-deguard.com)

**DeGuard उन Android obfuscation tools द्वारा किए गए obfuscation की प्रक्रिया को उलट देता है। इससे कई सुरक्षा विश्लेषण संभव होते हैं, जिनमें code inspection और libraries का अनुमान लगाना शामिल है।**

आप obfuscated APK को उनके प्लेटफ़ॉर्म पर upload कर सकते हैं।

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

यह android apps में किसी भी संभावित सुरक्षा कमजोरियों का पता लगाने और android app code को deobfuscate करने के लिए एक LLM टूल है। Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

यह एक **generic android deobfuscator** है। Simplify **किसी ऐप को virtually execute करता है** ताकि उसके व्यवहार को समझा जा सके और फिर **कोड को optimize करने की कोशिश करता है** ताकि उसका व्यवहार समान रहे लेकिन इंसान के लिए समझना आसान हो। प्रत्येक optimization प्रकार सरल और generic है, इसलिए यह मायने नहीं रखता कि किस प्रकार का obfuscation उपयोग किया गया है।

### [APKiD](https://github.com/rednaga/APKiD)

APKiD आपको यह जानकारी देता है कि **एक APK कैसे बनाया गया था**। यह कई **compilers**, **packers**, **obfuscators**, और अन्य अजीब चीज़ों की पहचान करता है। यह Android के लिए [_PEiD_](https://www.aldeid.com/wiki/PEiD) जैसा है।

### Manual

[इस tutorial को पढ़ें ताकि आप सीख सकें कि custom obfuscation को reverse करने के कुछ tricks कैसे किए जाते हैं](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b एक Android security virtual machine है जो ubuntu-mate पर आधारित है और इसमें reverse engineering और malware analysis के लिए नवीनतम framework, tutorials और labs का संग्रह शामिल है, जो विभिन्न security geeks और researchers द्वारा प्रदान किये गए हैं।

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) यह resources की एक शानदार सूची है
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
