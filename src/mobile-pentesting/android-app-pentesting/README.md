# Pentesting aplikacji Androidowych

{{#include ../../banners/hacktricks-training.md}}

## Podstawy aplikacji Androidowych

Zaleca się rozpoczęcie od przeczytania tej strony, aby poznać **najważniejsze elementy związane z bezpieczeństwem Androida oraz najniebezpieczniejsze komponenty aplikacji Androidowych**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

To główne narzędzie potrzebne do połączenia z urządzeniem z Androidem (emulowanym lub fizycznym).\
**ADB** pozwala kontrolować urządzenia zarówno przez **USB**, jak i **Network** z komputera. To narzędzie umożliwia **kopiowanie** plików w obu kierunkach, **instalację** i **odinstalację** aplikacji, **wykonywanie** poleceń shell, **tworzenie kopii zapasowych** danych, **odczytywanie** logów oraz inne funkcje.

Sprawdź następującą listę [**ADB Commands**](adb-commands.md), aby dowiedzieć się, jak używać adb.

## Smali

Czasami warto **zmodyfikować kod aplikacji**, aby uzyskać dostęp do **ukrytych informacji** (np. mocno zamaskowanych haseł lub flag). W takim przypadku może być interesujące zdekompilować APK, zmodyfikować kod i skompilować go ponownie.\
[**W tym tutorialu** możesz **nauczyć się, jak zdekompilować APK, zmodyfikować kod Smali i ponownie skompilować APK** z nową funkcjonalnością](smali-changes.md). To może być bardzo przydatne jako **alternatywa dla kilku testów podczas analizy dynamicznej**, które zostaną przedstawione. Dlatego **zawsze miej na uwadze tę możliwość**.

## Inne ciekawe triki

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Wyodrębnianie APK z urządzenia:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Scal wszystkie splits i base apks za pomocą [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Studia przypadków i podatności


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Analiza statyczna

Przede wszystkim, analizując APK powinieneś **przejrzeć kod Java** przy użyciu dekompilera.\
Proszę, [**przeczytaj tutaj, aby znaleźć informacje o dostępnych dekompilatorach**](apk-decompilers.md).

### Szukanie interesujących informacji

Już samo spojrzenie na **strings** w APK pozwala wyszukać **hasła**, **URL** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** i wszystko interesujące... szukaj nawet kodu wykonawczego — **backdoors** lub backdoorów uwierzytelniania (twardo zakodowane poświadczenia administratora w aplikacji).

**Firebase**

Zwróć szczególną uwagę na **firebase URLs** i sprawdź, czy są źle skonfigurowane. [Więcej informacji o tym, czym jest Firebase i jak to wykorzystać znajdziesz tutaj.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Podstawowe zrozumienie aplikacji - Manifest.xml, strings.xml

Badanie plików aplikacji _Manifest.xml_ oraz **_strings.xml_** może ujawnić potencjalne podatności bezpieczeństwa. Pliki te można uzyskać za pomocą dekompilatorów lub przez zmianę rozszerzenia pliku APK na .zip i rozpakowanie go.

**Podatności** zidentyfikowane na podstawie **Manifest.xml** obejmują:

- **Aplikacje z włączonym debugowaniem**: Aplikacje ustawione jako `debuggable="true"` w _Manifest.xml_ stwarzają ryzyko, ponieważ pozwalają na połączenia, które mogą doprowadzić do eksploatacji. Aby lepiej zrozumieć jak wykorzystywać aplikacje z włączonym debugowaniem, odwołaj się do tutoriala dotyczącego wyszukiwania i wykorzystywania takich aplikacji na urządzeniu.
- **Ustawienia kopii zapasowej**: Atrybut `android:allowBackup="false"` powinien być jawnie ustawiony dla aplikacji przetwarzających wrażliwe informacje, aby zapobiec nieautoryzowanym backupom danych przez adb, zwłaszcza gdy włączone jest usb debugging.
- **Bezpieczeństwo sieci**: Niestandardowe konfiguracje network security (`android:networkSecurityConfig="@xml/network_security_config"`) w _res/xml/_ mogą określać szczegóły bezpieczeństwa, takie jak certificate pins i ustawienia ruchu HTTP. Przykładem może być zezwolenie na ruch HTTP dla określonych domen.
- **Exported Activities and Services**: Identyfikacja eksportowanych activities i services w manifeście może ujawnić komponenty, które mogą być nadużyte. Dalsza analiza podczas testów dynamicznych może pokazać, jak je zaatakować.
- **Content Providers i FileProviders**: Eksponowane content providers mogą umożliwić nieautoryzowany dostęp lub modyfikację danych. Konfiguracja FileProviders również powinna być dokładnie sprawdzona.
- **Broadcast Receivers i schematy URL**: Te komponenty mogą być wykorzystane do ataku, ze szczególnym uwzględnieniem sposobu obsługi schematów URL pod kątem podatności na wprowadzenie danych.
- **Wersje SDK**: Atrybuty `minSdkVersion`, `targetSDKVersion` i `maxSdkVersion` wskazują wspierane wersje Androida, podkreślając znaczenie niewspierania przestarzałych, podatnych wersji Androida ze względów bezpieczeństwa.

Z pliku **strings.xml** można odkryć wrażliwe informacje, takie jak klucze API, custom schemas i inne uwagi deweloperskie, co podkreśla potrzebę dokładnego przeglądu tych zasobów.

### Tapjacking

**Tapjacking** to atak, w którym **złośliwa aplikacja** jest uruchamiana i **pozycjonuje się nad aplikacją ofiary**. Gdy zasłoni widocznie aplikację ofiary, jej interfejs użytkownika jest zaprojektowany tak, aby oszukać użytkownika i zmusić go do interakcji, podczas gdy faktyczna interakcja jest przekazywana do aplikacji ofiary.\
W efekcie **oszukuje się użytkownika, ukrywając fakt, że w rzeczywistości wykonuje działania w aplikacji ofiary**.

Znajdź więcej informacji w:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity z ustawionym **`launchMode`** na **`singleTask` bez zdefiniowanego `taskAffinity`** jest podatna na Task Hijacking. Oznacza to, że jeśli zainstalowana zostanie złośliwa aplikacja i uruchomiona przed prawdziwą aplikacją, może **przejąć task prawdziwej aplikacji** (użytkownik będzie wchodził w interakcję ze **złośliwą aplikacją, myśląc, że używa oryginalnej**).

Więcej informacji w:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Niepewne przechowywanie danych

**Internal Storage**

W Androidzie pliki **przechowywane** w **internal** storage są **zaprojektowane** tak, aby były dostępne wyłącznie dla aplikacji, która je utworzyła. Ten mechanizm bezpieczeństwa jest **egzekwowany** przez system Android i zazwyczaj wystarcza dla potrzeb większości aplikacji. Jednak deweloperzy czasem używają trybów takich jak `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE`, aby **umożliwić** udostępnianie plików między różnymi aplikacjami. Te tryby **nie ograniczają dostępu** do tych plików przez inne aplikacje, w tym potencjalnie złośliwe.

1. **Static Analysis:**
- **Upewnij się**, że użycie `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` jest **dokładnie sprawdzone**. Te tryby **mogą potencjalnie ujawnić** pliki niezamierzonemu lub nieautoryzowanemu dostępowi.
2. **Dynamic Analysis:**
- **Zweryfikuj** **uprawnienia** ustawione na plikach tworzonych przez aplikację. W szczególności **sprawdź**, czy któreś pliki są **ustawione jako czytelne lub zapisywalne dla wszystkich**. To może stanowić poważne ryzyko bezpieczeństwa, ponieważ pozwoli **dowolnej aplikacji** zainstalowanej na urządzeniu, niezależnie od jej pochodzenia czy zamiaru, **odczytać lub zmodyfikować** te pliki.

**External Storage**

W przypadku plików na **external storage**, takich jak SD Card, należy zachować ostrożność:

1. **Dostępność**:
- Pliki na external storage są **globalnie czytelne i zapisywalne**. Oznacza to, że dowolna aplikacja lub użytkownik może mieć do nich dostęp.
2. **Obawy bezpieczeństwa**:
- Ze względu na łatwość dostępu, zaleca się **nie przechowywać informacji wrażliwych** na external storage.
- External storage można usunąć lub uzyskać do niego dostęp przez dowolną aplikację, co czyni go mniej bezpiecznym.
3. **Obsługa danych z External Storage**:
- Zawsze **przeprowadzaj walidację wejścia** na danych pobieranych z external storage. Jest to kluczowe, ponieważ dane pochodzą ze źródła nieznanego/zewnętrznego.
- Przechowywanie plików wykonywalnych lub klas na external storage do dynamicznego ładowania jest zdecydowanie odradzane.
- Jeśli aplikacja musi pobierać pliki wykonywalne z external storage, upewnij się, że są one **signed i cryptographically verified** przed ich dynamicznym załadowaniem. Ten krok jest niezbędny do utrzymania integralności bezpieczeństwa aplikacji.

External storage można **dostępować** w /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Począwszy od Android 4.4 (**API 17**), struktura katalogów na karcie SD **ogranicza dostęp aplikacji do katalogu przeznaczonego specjalnie dla tej aplikacji**. Zapobiega to uzyskaniu przez złośliwą aplikację dostępu do odczytu lub zapisu plików innej aplikacji.

**Wrażliwe dane przechowywane w postaci jawnej**

- **Shared preferences**: Android pozwala każdej aplikacji na łatwe zapisywanie plików xml w ścieżce `/data/data/<packagename>/shared_prefs/` i czasami można znaleźć w tym folderze wrażliwe informacje w postaci jawnej.
- **Databases**: Android pozwala każdej aplikacji na łatwe zapisywanie baz sqlite w ścieżce `/data/data/<packagename>/databases/` i czasami można znaleźć w tym folderze wrażliwe informacje w postaci jawnej.

### Broken TLS

**Accept All Certificates**

Z jakiegoś powodu deweloperzy czasami akceptują wszystkie certyfikaty nawet jeśli, na przykład, hostname nie pasuje — z użyciem fragmentów kodu takich jak poniższy:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Błędna kryptografia

**Słabe procesy zarządzania kluczami**

Niektórzy deweloperzy zapisują dane wrażliwe w lokalnym magazynie i szyfrują je kluczem zakodowanym na stałe / przewidywalnym w kodzie. Nie powinno się tego robić, ponieważ reversing może pozwolić atakującym na wyodrębnienie informacji poufnych.

**Użycie niebezpiecznych i/lub przestarzałych algorytmów**

Deweloperzy nie powinni używać **deprecated algorithms** do wykonywania kontroli autoryzacji, przechowywania lub wysyłania danych. Niektóre z tych algorytmów to: RC4, MD4, MD5, SHA1... Jeśli **hashes** są używane do przechowywania haseł, powinny to być hashe odporne na brute-force z zastosowaniem salt.

### Inne kontrole

- It's recommended to **obfuscate the APK** to difficult the reverse engineer labour to attackers.
- Jeśli aplikacja jest wrażliwa (np. bank apps), powinna przeprowadzać własne sprawdzenia, aby ustalić, czy urządzenie jest rooted i odpowiednio reagować.
- Jeśli aplikacja jest wrażliwa (np. bank apps), powinna sprawdzać, czy używany jest **emulator**.
- Jeśli aplikacja jest wrażliwa (np. bank apps), powinna **sprawdzić swoją integralność przed uruchomieniem**, aby ustalić, czy została zmodyfikowana.
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### Aplikacja React Native

Przeczytaj następującą stronę, aby dowiedzieć się, jak łatwo uzyskać dostęp do kodu javascript aplikacji React:


{{#ref}}
react-native-application.md
{{#endref}}

### Aplikacje Xamarin

Przeczytaj następującą stronę, aby dowiedzieć się, jak łatwo uzyskać dostęp do kodu C# aplikacji xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Zautomatyzowana statyczna analiza kodu

Narzędzie [**mariana-trench**](https://github.com/facebook/mariana-trench) potrafi znaleźć **vulnerabilities** poprzez **scanning** **code** aplikacji. To narzędzie zawiera zbiór **known sources** (które wskazują narzędziu **places** gdzie **input** jest **controlled by the user**), **sinks** (które wskazują narzędziu **dangerous** **places** gdzie złośliwy input użytkownika może wyrządzić szkody) oraz **rules**. Zasady te wskazują **combination** **sources-sinks** które sygnalizują podatność.

Dzięki temu **mariana-trench przeanalizuje kod i znajdzie możliwe podatności**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Inne interesujące funkcje

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analiza dynamiczna

> Przede wszystkim potrzebujesz środowiska, w którym możesz zainstalować aplikację i całe środowisko (Burp CA cert, Drozer i Frida głównie). Dlatego urządzenie z rootem (emulowane lub nie) jest zdecydowanie zalecane.

### Analiza dynamiczna online

Możesz założyć **darmowe konto** na: [https://appetize.io/](https://appetize.io). Ta platforma pozwala **upload** i **execute** APK, więc jest przydatna do sprawdzenia, jak apk się zachowuje.

Możesz nawet **zobaczyć logi swojej aplikacji** w przeglądarce i połączyć się przez **adb**.

![](<../../images/image (831).png>)

Dzięki połączeniu ADB możesz używać **Drozer** i **Frida** wewnątrz emulatorów.

### Lokalna analiza dynamiczna

#### Korzystanie z emulatora

- [**Android Studio**](https://developer.android.com/studio) (Możesz tworzyć urządzenia **x86** i **arm**, i zgodnie z [**tym**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) **najnowsze wersje x86** obsługują **ARM libraries** bez potrzeby używania wolnego emulatora arm).
- Naucz się, jak to skonfigurować na tej stronie:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) (wersja darmowa: Personal Edition, wymagane założenie konta. Zaleca się pobranie wersji z **VirtualBox**, aby uniknąć potencjalnych błędów.)
- [**Nox**](https://es.bignox.com) (darmowy, ale nie obsługuje Frida ani Drozer).

> [!TIP]
> Przy tworzeniu nowego emulatora na dowolnej platformie pamiętaj, że im większy ekran, tym wolniej będzie działał emulator. Dlatego wybieraj małe ekrany, jeśli to możliwe.

Aby **zainstalować google services** (np. AppStore) w Genymotion musisz kliknąć przycisk zaznaczony na czerwono na poniższym obrazku:

![](<../../images/image (277).png>)

Zwróć też uwagę, że w **konfiguracji Android VM w Genymotion** możesz wybrać **Bridge Network mode** (to będzie przydatne, jeśli będziesz łączyć się z Android VM z innej VM z narzędziami).

#### Użycie urządzenia fizycznego

Musisz aktywować opcje **debugowania**, a dobrze byłoby, jeśli możesz je **root**:

1. **Ustawienia**.
2. (Od Androida 8.0) Wybierz **System**.
3. Wybierz **About phone**.
4. Naciśnij **Build number** 7 razy.
5. Wróć i znajdziesz **Developer options**.

> Po zainstalowaniu aplikacji pierwszą rzeczą, którą powinieneś zrobić, jest jej wypróbowanie, sprawdzenie, co robi, jak działa i oswojenie się z nią.\
> Sugeruję **wykonać tę początkową analizę dynamiczną używając MobSF dynamic analysis + pidcat**, dzięki czemu będziemy mogli **dowiedzieć się, jak aplikacja działa**, podczas gdy MobSF **przechwyci** dużo **interesujących** **danych**, które możesz przejrzeć później.

Magisk/Zygisk szybkie notatki (zalecane na urządzeniach Pixel)
- Patchuj boot.img za pomocą aplikacji Magisk i flashuj przez fastboot, aby uzyskać systemless root
- Włącz Zygisk + DenyList do ukrywania roota; rozważ LSPosed/Shamiko, gdy wymagane jest silniejsze ukrywanie
- Zachowaj oryginalny boot.img, aby móc odzyskać po aktualizacjach OTA; ponownie patcheuj po każdej OTA
- Do mirrorowania ekranu użyj scrcpy na hoście

### Unintended Data Leakage

**Logging**

Deweloperzy powinni być ostrożni z ujawnianiem **debugging information** publicznie, ponieważ może to prowadzić do wrażliwych danych leaks. Narzędzia [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` są zalecane do monitorowania logów aplikacji w celu identyfikacji i ochrony poufnych informacji. **Pidcat** jest preferowany ze względu na łatwość użycia i czytelność.

> [!WARNING]
> Zauważ, że od **wersji nowszych niż Android 4.0**, **aplikacje mogą uzyskiwać dostęp tylko do własnych logów**. Więc aplikacje nie mogą uzyskać dostępu do logów innych aplikacji.\
> Niemniej jednak nadal zaleca się **nie logować wrażliwych informacji**.

**Copy/Paste Buffer Caching**

Androidowy framework oparty na **clipboard** umożliwia funkcję kopiuj-wklej w aplikacjach, jednak stwarza ryzyko, ponieważ **inne aplikacje** mogą **dostępować** do schowka, potencjalnie ujawniając sensitive data. Kluczowe jest **wyłączenie funkcji kopiuj/wklej** w wrażliwych sekcjach aplikacji, takich jak dane karty kredytowej, aby zapobiec data leaks.

**Crash Logs**

Jeżeli aplikacja **crashes** i **zapisuje logi**, te logi mogą pomóc atakującym, szczególnie gdy aplikacja nie może być reverse-engineered. Aby zminimalizować to ryzyko, unikaj logowania przy awariach, a jeśli logi muszą być przesłane przez sieć, upewnij się, że są wysyłane przez kanał SSL.

Jako pentester, **spróbuj rzucić okiem na te logi**.

**Analytics Data Sent To 3rd Parties**

Aplikacje często integrują usługi takie jak Google Adsense, które mogą niezamierzenie **leak sensitive data** z powodu nieprawidłowej implementacji przez deweloperów. Aby zidentyfikować potencjalne data leaks, zaleca się **przechwycić ruch aplikacji** i sprawdzić, czy jakiekolwiek wrażliwe informacje są wysyłane do usług third-party.

### SQLite DBs

Większość aplikacji używa **internal SQLite databases** do zapisywania informacji. Podczas pentest przejrzyj **databases** utworzone, nazwy **tables** i **columns** oraz wszystkie zapisane **data**, ponieważ możesz znaleźć **sensitive information** (co byłoby podatnością).\
Bazy danych powinny znajdować się w `/data/data/the.package.name/databases` jak `/data/data/com.mwr.example.sieve/databases`

Jeśli baza danych zapisuje poufne informacje i jest **encrypted** ale możesz **find** **password** wewnątrz aplikacji, to wciąż jest to **vulnerability**.

Wylistuj tabele używając `.tables` i wypisz kolumny tabel wykonując `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Pamiętaj też, że kod aktywności zaczyna się w metodzie **`onCreate`**.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF będzie traktować jako złośliwe użycie _**singleTask/singleInstance**_ jako `android:launchMode` w activity, ale zgodnie z [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), najwyraźniej jest to niebezpieczne tylko w starych wersjach (API versions < 21).

> [!TIP]
> Należy pamiętać, że an authorisation bypass nie zawsze jest podatnością — zależy to od sposobu działania bypassu i jakie informacje są ujawniane.

**Sensitive information leakage**

**Aktywności mogą też zwracać wyniki.** Jeśli uda Ci się znaleźć eksportowaną i niezabezpieczoną activity, która wywołuje metodę **`setResult`** i **zwraca poufne informacje**, dochodzi do sensitive information leakage.

#### Tapjacking

Jeśli Tapjacking nie jest zatrzymany, możesz wykorzystać eksportowaną activity, aby zmusić **użytkownika do wykonania nieoczekiwanych działań**. Po więcej informacji o [**czym jest Tapjacking, zobacz link**](#tapjacking).

### Exploiting Content Providers - Uzyskiwanie i manipulowanie poufnymi informacjami

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Content Provider.**](android-applications-basics.md#content-provider)\
Content providers służą zasadniczo do **udostępniania danych**. Jeśli aplikacja ma dostępne content providers, możesz być w stanie **wyodrębnić poufne** dane z nich. Warto też testować możliwe **SQL injections** i **Path Traversals**, ponieważ mogą być podatne.

[**Dowiedz się, jak exploit Content Providers przy użyciu Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Service.**](android-applications-basics.md#services)\
Pamiętaj, że działania Service zaczynają się w metodzie `onStartCommand`.

Service to w zasadzie coś, co **może otrzymywać dane**, **przetwarzać** je i **zwracać** (lub nie) odpowiedź. Jeśli aplikacja eksportuje jakieś services, powinieneś **sprawdzić** **kod**, aby zrozumieć, co robi, i **testować** go **dynamicznie** w celu wydobycia informacji poufnych, obejścia mechanizmów uwierzytelniania itp.\
[**Dowiedz się, jak exploit Services przy użyciu Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Pamiętaj, że działania Broadcast Receiver zaczynają się w metodzie `onReceive`.

Broadcast receiver będzie oczekiwać na określony typ wiadomości. W zależności od tego, jak receiver obsługuje wiadomość, może być podatny.\
[**Dowiedz się, jak exploit Broadcast Receivers przy użyciu Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Możesz wyszukać deep links ręcznie, używając narzędzi takich jak MobSF lub skryptów typu [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Możesz **otworzyć** zadeklarowany **scheme** używając **adb** lub **przeglądarki**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Zauważ, że możesz **pominąć nazwę pakietu** i urządzenie mobilne automatycznie wywoła aplikację, która powinna otworzyć ten link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod wykonywany**

Aby znaleźć **kod, który zostanie wykonany w aplikacji**, przejdź do activity wywoływanej przez deeplink i wyszukaj funkcję **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Wrażliwe dane**

Za każdym razem, gdy znajdziesz deep link, sprawdź, czy **nie otrzymuje wrażliwych danych (np. haseł) przez parametry URL**, ponieważ każda inna aplikacja mogłaby **podszyć się pod deep link i ukraść te dane!**

**Parametry w ścieżce**

Musisz również sprawdzić, czy którykolwiek deep link używa parametru wewnątrz ścieżki URL, np.: `https://api.example.com/v1/users/{username}` , w takim przypadku możesz wymusić path traversal, uzyskując dostęp do czegoś takiego: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Zauważ, że jeśli znajdziesz odpowiednie endpointy w aplikacji, możesz być w stanie wywołać **Open Redirect** (jeśli część ścieżki jest użyta jako nazwa domeny), **account takeover** (jeśli możesz zmodyfikować dane użytkowników bez tokena CSRF i podatny endpoint używał odpowiedniej metody) i inne podatności. Więcej informacji [tutaj](http://dphoeniixx.com/2020/12/13-2/).

**Więcej przykładów**

Interesujący raport bug bounty dotyczący linków (_/.well-known/assetlinks.json_): [Interesujący raport bug bounty](https://hackerone.com/reports/855618).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** przez aplikacje Android. Często aplikacje pomijają ostrzeżenia i akceptują certyfikaty self-signed lub w niektórych przypadkach wracają do używania połączeń HTTP.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, wykorzystując niebezpieczne zestawy szyfrów. Ta podatność naraża połączenie na ataki man-in-the-middle (MITM), umożliwiając atakującym odszyfrowanie danych.
- **Leakage of private information** stanowi ryzyko, gdy aplikacje uwierzytelniają się przy użyciu bezpiecznych kanałów, a następnie komunikują się przez niezabezpieczone kanały dla innych transakcji. Takie podejście nie chroni wrażliwych danych, takich jak session cookies czy dane użytkownika, przed przechwyceniem przez podmioty złośliwe.

#### Certificate Verification

Skupimy się na **weryfikacji certyfikatu**. Integralność certyfikatu serwera musi być weryfikowana, aby zwiększyć bezpieczeństwo. Jest to kluczowe, ponieważ niebezpieczne konfiguracje TLS oraz przesyłanie wrażliwych danych przez niezabezpieczone kanały mogą stanowić poważne ryzyko. Dla szczegółowych kroków dotyczących weryfikacji certyfikatów serwera i usuwania podatności, [**to źródło**](https://manifestsecurity.com/android-application-security-part-10/) zawiera obszerny przewodnik.

#### SSL Pinning

SSL Pinning to mechanizm bezpieczeństwa, w którym aplikacja weryfikuje certyfikat serwera względem znanej kopii przechowywanej w samej aplikacji. Ta metoda jest istotna dla zapobiegania atakom man-in-the-middle (MITM). Implementacja SSL Pinning jest gorąco zalecana dla aplikacji przetwarzających dane wrażliwe.

#### Traffic Inspection

Aby inspekcjonować ruch HTTP, konieczne jest **zainstalowanie certyfikatu narzędzia proxy** (np. Burp). Bez zainstalowania tego certyfikatu szyfrowany ruch może nie być widoczny przez proxy. Instrukcję instalacji niestandardowego certyfikatu CA znajdziesz [**tutaj**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacje celujące w **API Level 24 and above** wymagają modyfikacji Network Security Config, aby zaakceptować certyfikat CA proxy. Ten krok jest kluczowy dla inspekcji szyfrowanego ruchu. Instrukcje dotyczące modyfikacji Network Security Config znajdziesz w [**tym tutorialu**](make-apk-accept-ca-certificate.md).

Jeśli użyto **Flutter**, musisz postępować zgodnie z instrukcjami na [**tej stronie**](flutter.md). Wynika to z faktu, że samo dodanie certyfikatu do magazynu nie wystarczy, ponieważ Flutter ma własną listę zaufanych CA.

#### Static detection of SSL/TLS pinning

Zanim spróbujesz obejść mechanizmy w czasie wykonywania, szybko zmapuj miejsca, w których pinning jest egzekwowany w APK. Wykrywanie statyczne pomaga zaplanować hooki/łatki i skupić się na właściwych ścieżkach kodu.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Instalacja
- Wymagania wstępne: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Użycie
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Przykładowe reguły wzorców (JSON)
Użyj lub rozszerz sygnatur, aby wykrywać proprietarne/niestandardowe style pinning. Możesz załadować własny plik JSON i skanować na dużą skalę.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notatki i wskazówki
- Szybkie skanowanie dużych aplikacji przez multi-threading i memory-mapped I/O; pre-kompilowane regexy zmniejszają narzut / false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typowe cele detekcji do dalszej triage:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Wykorzystaj dopasowane lokalizacje do zaplanowania Frida hooks, statycznych patchy lub przeglądu konfiguracji przed testami dynamicznymi.



#### Omijanie SSL Pinning

Gdy SSL Pinning jest zaimplementowany, konieczne bywa jego obejście, aby inspekcjonować ruch HTTPS. Dostępne są różne metody:

- Automatycznie **zmodyfikuj** **apk**, aby **obejść** SSLPinning za pomocą [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Największą zaletą tej opcji jest to, że nie będziesz potrzebować roota, aby obejść SSL Pinning, ale będziesz musiał usunąć aplikację i zainstalować nową wersję, i nie zawsze to zadziała.
- Możesz użyć **Frida** (omówionej poniżej) aby obejść tę ochronę. Tutaj masz przewodnik użycia Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Możesz także spróbować **automatycznie obejść SSL Pinning** używając [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Możesz też spróbować **automatycznie obejść SSL Pinning** używając **MobSF dynamic analysis** (opisane poniżej)
- Jeśli nadal uważasz, że istnieje ruch, którego nie przechwytujesz, możesz spróbować **przekierować ruch do burpa używając iptables**. Przeczytaj ten wpis: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Szukanie typowych podatności webowych

Ważne jest także poszukiwanie typowych podatności webowych w aplikacji. Szczegółowe informacje na temat identyfikacji i łagodzenia tych podatności wykraczają poza zakres tego streszczenia, ale są szeroko omówione gdzie indziej.

### Frida

[Frida](https://www.frida.re) to zestaw narzędzi do dynamicznej instrumentacji dla programistów, reverse-engineerów i badaczy bezpieczeństwa.\
**Możesz uzyskać dostęp do działającej aplikacji i hookować metody w czasie działania, aby zmieniać zachowanie, modyfikować wartości, wydobywać dane, uruchamiać inny kod...**\
Jeśli chcesz pentestować aplikacje Android, musisz umieć korzystać z Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Spróbuj obejść mechanizmy anti-debugging / anti-frida ładując Frida, jak wskazano w [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (narzędzie [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Zrzut pamięci - Fridump**

Sprawdź, czy aplikacja nie przechowuje w pamięci informacji wrażliwych, których nie powinna przechowywać, takich jak hasła czy mnemoniki.

Używając [**Fridump3**](https://github.com/rootbsd/fridump3) możesz zrzucić pamięć aplikacji poleceniem:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
To zrzuci pamięć do katalogu ./dump, a tam możesz użyć grep z czymś takim:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Wrażliwe dane w Keystore**

W Androidzie Keystore to najlepsze miejsce do przechowywania wrażliwych danych, jednak przy wystarczających uprawnieniach nadal jest **możliwe uzyskanie do niego dostępu**. Ponieważ aplikacje często przechowują tutaj **wrażliwe dane w postaci jawnej**, pentests powinny to sprawdzać jako root user — osoba z fizycznym dostępem do urządzenia mogłaby je przejąć.

Nawet jeśli aplikacja przechowuje data w Keystore, dane powinny być zaszyfrowane.

Aby uzyskać dostęp do danych wewnątrz Keystore, możesz użyć tego skryptu Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Używając poniższego skryptu Frida możliwe jest **bypass fingerprint authentication**, które aplikacje Android mogą stosować w celu **zabezpieczenia niektórych wrażliwych obszarów:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Obrazy w tle**

Gdy umieścisz aplikację w tle, Android zapisuje **zrzut aplikacji**, dzięki czemu po przywróceniu jej na pierwszy plan najpierw ładuje obraz, co sprawia, że aplikacja wydaje się uruchamiać szybciej.

Jednak jeśli ten zrzut zawiera **poufne informacje**, osoba mająca dostęp do zrzutu może **ukraść te dane** (uwaga: dostęp wymaga root).

Zrzuty są zwykle przechowywane pod ścieżką: **`/data/system_ce/0/snapshots`**

Android udostępnia sposób na **zablokowanie wykonywania zrzutów ekranu przez ustawienie parametru layoutu FLAG_SECURE**. Używając tej flagi, zawartość okna jest traktowana jako bezpieczna, co zapobiega jej pojawianiu się na zrzutach ekranu oraz wyświetlaniu na niezaufanych ekranach.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

To narzędzie może pomóc w zarządzaniu różnymi narzędziami podczas dynamicznej analizy: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Deweloperzy często tworzą komponenty pośredniczące takie jak activities, services i broadcast receivers, które obsługują te Intents i przekazują je do metod takich jak `startActivity(...)` lub `sendBroadcast(...)`, co może być ryzykowne.

Niebezpieczeństwo polega na umożliwieniu atakującym wywołania nieeksportowanych komponentów aplikacji lub uzyskania dostępu do wrażliwych content providers przez przekierowanie tych Intents. Dobrym przykładem jest komponent `WebView`, który konwertuje URL-e na obiekty `Intent` za pomocą `Intent.parseUri(...)`, a następnie je wykonuje, co może prowadzić do złośliwych Intent injections.

### Essential Takeaways

- **Intent Injection** jest podobny do webowej podatności Open Redirect.
- Eksploity polegają na przekazywaniu obiektów `Intent` jako extras, które mogą być przekierowane do wykonywania niebezpiecznych operacji.
- Może ujawnić nieeksportowane komponenty i content providers atakującym.
- Konwersja URL do `Intent` przez `WebView` może ułatwić niezamierzone działania.

### Android Client Side Injections and others

Prawdopodobnie znasz tego typu podatności z Weba. Musisz być szczególnie ostrożny z tymi podatnościami w aplikacji Android:

- **SQL Injection:** W przypadku dynamicznych zapytań lub Content-Providers upewnij się, że używasz zapytań parametryzowanych.
- **JavaScript Injection (XSS):** Upewnij się, że wsparcie dla JavaScript i Pluginów jest wyłączone dla wszystkich WebViews (domyślnie wyłączone). [Więcej informacji](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews powinny mieć wyłączony dostęp do systemu plików (domyślnie włączony) - `(webview.getSettings().setAllowFileAccess(false);)`. [Więcej informacji](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: W wielu przypadkach, gdy aplikacja Android kończy sesję, cookie nie jest unieważniane lub może być nawet zapisane na dysku.
- [**Secure Flag** w cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Analiza automatyczna

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analiza statyczna**

![](<../../images/image (866).png>)

**Ocena podatności aplikacji** przy użyciu ładnego webowego frontendu. Możesz także przeprowadzić dynamiczną analizę (ale musisz przygotować środowisko).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Narzędzia HTTP**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSF HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
This tool with use some **Hooks** to let you know **what is happening in the application** while you perform a **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

This is a **great tool to perform static analysis with a GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

This tool is designed to look for several **security related Android application vulnerabilities**, either in **source code** or **packaged APKs**. The tool is also **capable of creating a "Proof-of-Concept" deployable APK** and **ADB commands**, to exploit some of the found vulnerabilities (Exposed activities, intents, tapjacking...). As with Drozer, there is no need to root the test device.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wyświetla wszystkie wyodrębnione pliki do szybkiego wglądu
- Automatycznie dekompiluje pliki APK do formatu Java i Smali
- Analizuje AndroidManifest.xml pod kątem common vulnerabilities and behavior
- Statyczna analiza kodu źródłowego pod kątem common vulnerabilities and behavior
- Informacje o urządzeniu
- i więcej
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER jest aplikacją uruchamianą z wiersza poleceń, którą można używać w Windows, MacOS X i Linux, analizującą pliki _.apk_ w poszukiwaniu podatności. Robi to poprzez dekompresję APK i zastosowanie zestawu reguł do wykrywania tych podatności.

Wszystkie reguły są zgromadzone w pliku `rules.json`, a każda firma lub tester może stworzyć własne reguły do analizy tego, czego potrzebują.

Pobierz najnowsze binaria ze strony [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn to **wieloplatformowe** narzędzie, które wspomaga programistów, bugbounty hunters and ethical hackers w przeprowadzaniu [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) aplikacji mobilnych.

Koncepcja polega na tym, że przeciągasz i upuszczasz plik swojej aplikacji mobilnej (plik .apk lub .ipa) na aplikację StaCoAn, a ona wygeneruje dla Ciebie wizualny i przenośny raport. Możesz dostosować ustawienia i wordlists, aby uzyskać spersonalizowane doświadczenie.

Pobierz[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework jest systemem analizy podatności Androida, który pomaga deweloperom lub hakerom znaleźć potencjalne luki bezpieczeństwa w aplikacjach Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** to narzędzie, którego głównym celem jest wykrywanie i ostrzeganie użytkownika o potencjalnie złośliwych zachowaniach rozwijanych przez aplikację Android.

Wykrywanie odbywa się poprzez **static analysis** kodu bajtowego Dalvik aplikacji, reprezentowanego jako **Smali**, przy użyciu biblioteki [`androguard`](https://github.com/androguard/androguard).

Narzędzie poszukuje **common behavior of "bad" applications** takich jak: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Jest to narzędzie łączące powszechnie używane mobile application reverse engineering and analysis tools, aby wspomóc testowanie aplikacji mobilnych przeciwko OWASP mobile security threats. Jego celem jest ułatwienie tej pracy i uczynienie jej bardziej przyjazną dla deweloperów aplikacji mobilnych oraz specjalistów ds. bezpieczeństwa.

It is able to:

- Wyodrębnia kod Java i Smali za pomocą różnych narzędzi
- Analizuje APKi przy użyciu: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Wydobywa private information z APK za pomocą regexps.
- Analizuje Manifest.
- Analizuje znalezione domeny przy użyciu: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskacja APK poprzez [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Przydatne do wykrywania malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Zauważ, że w zależności od serwisu i konfiguracji użytej do obfuskacji kodu, sekrety mogą, ale nie muszą pozostać obfuskowane.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Potrafi optymalizować bytecode oraz wykrywać i usuwać nieużywane instrukcje. ProGuard jest wolnym oprogramowaniem i jest rozpowszechniany na licencji GNU General Public License, wersja 2.

ProGuard jest dystrybuowany jako część Android SDK i działa podczas budowania aplikacji w trybie release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Znajdź przewodnik krok po kroku jak zdeobfuskować apk: [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Z tego przewodnika) Ostatnio, kiedy sprawdzaliśmy, tryb działania Dexguard był:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard odwraca proces obfuskacji wykonywany przez narzędzia do obfuskacji Android. To umożliwia liczne analizy bezpieczeństwa, w tym inspekcję kodu i identyfikację bibliotek.**

Możesz przesłać obfuskowane APK na ich platformę.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

To narzędzie LLM do znajdowania potencjalnych luk bezpieczeństwa w aplikacjach Android i deobfuskacji kodu aplikacji Android. Używa publicznego API Google Gemini.

### [Simplify](https://github.com/CalebFenton/simplify)

To **generic android deobfuscator.** Simplify **virtually executes an app** aby zrozumieć jej zachowanie, a następnie **tries to optimize the code** tak, by zachowywał się identycznie, ale był łatwiejszy do zrozumienia przez człowieka. Każdy typ optymalizacji jest prosty i uniwersalny, więc nie ma znaczenia, jaki konkretny rodzaj obfuskacji został użyty.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD daje informacje o tym **how an APK was made**. Identyfikuje wiele **compilers**, **packers**, **obfuscators** i innych dziwnych rzeczy. To [_PEiD_](https://www.aldeid.com/wiki/PEiD) dla Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b to wirtualna maszyna do bezpieczeństwa Android oparta na ubuntu-mate, zawierająca zbiór najnowszych frameworków, tutoriali i laboratoriów od różnych entuzjastów bezpieczeństwa i badaczy do reverse engineering i analizy malware.

## Referencje

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To świetna lista zasobów
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Szybki kurs Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Do wypróbowania

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
