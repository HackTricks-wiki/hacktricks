# Android 应用程序 Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android 应用基础

强烈建议先阅读此页面，以了解与 Android 安全 相关的**最重要的部分以及 Android 应用中最危险的组件**：


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

这是连接 Android 设备（模拟或物理设备）所需的主要工具。\
**ADB** 允许从计算机通过 **USB** 或 **网络** 控制设备。该实用程序能够执行双向的 **复制** 文件、应用的 **安装** 和 **卸载**、执行 shell 命令、**备份** 数据、**读取** 日志等功能。

查看下面的 [**ADB Commands**](adb-commands.md) 列表以学习如何使用 adb。

## Smali

有时为了访问**隐藏信息**（例如高度混淆的密码或 flags），修改应用代码是有意义的。此时，可能需要反编译 apk、修改代码并重新编译它。\
[**在本教程中**，你可以**学习如何反编译 APK、修改 Smali 代码并重新编译带有新功能的 APK**](smali-changes.md)。在将要介绍的动态分析中，这作为若干测试的**替代方案**会非常有用。请**始终牢记这一可能性**。

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 使用 [APKEditor](https://github.com/REAndroid/APKEditor) 合并所有 splits 和 base apks:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## 案例研究与漏洞


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## 静态分析

首先，在分析 APK 时，你应该使用反编译器**查看 Java 代码**。\
请，[**在此阅读以找到有关不同可用反编译器的信息**](apk-decompilers.md)。

### 查找有趣的信息

仅仅查看 APK 的 **strings** 就可以搜索 **passwords**、**URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep))、**api** keys、**encryption**、**bluetooth uuids**、**tokens** 以及任何有价值的信息……甚至查找代码执行的 **backdoors** 或身份验证后门（应用中硬编码的管理员凭据）。

**Firebase**

特别注意 **firebase URLs** 并检查其是否配置错误。[更多关于 Firebase 是什么以及如何利用它的信息请见此处。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 应用的基本理解 - Manifest.xml, strings.xml

**检查应用的 _Manifest.xml_ 和 **_strings.xml_** 文件可以揭示潜在的安全漏洞**。这些文件可以通过反编译器访问，或者通过将 APK 的文件扩展名重命名为 .zip 然后解压来获取。

从 **Manifest.xml** 中识别的 **漏洞** 包括：

- **Debuggable Applications**：在 _Manifest.xml_ 中设置为 debuggable（`debuggable="true"`）的应用存在风险，因为它们允许连接，可能导致被利用。有关如何在设备上查找并利用 debuggable 应用的更多信息，请参阅相关教程。
- **Backup Settings**：对于处理敏感信息的应用，应明确设置 `android:allowBackup="false"` 属性，以防止通过 adb 进行未经授权的数据备份，尤其是在启用 usb debugging 时。
- **Network Security**：自定义网络安全配置（`android:networkSecurityConfig="@xml/network_security_config"`）位于 _res/xml/_，可以指定证书 pin 和 HTTP 流量设置。例如，可以为特定域名允许 HTTP 流量。
- **Exported Activities and Services**：在 manifest 中识别 exported 的 activities 和 services 可以突出可能被滥用的组件。在动态测试期间进一步分析可以揭示如何利用这些组件。
- **Content Providers and FileProviders**：暴露的 content providers 可能允许未授权访问或修改数据。FileProviders 的配置也应仔细审查。
- **Broadcast Receivers and URL Schemes**：这些组件可能被利用进行攻击，需要特别关注 URL scheme 的处理以防止输入类漏洞。
- **SDK Versions**：`minSdkVersion`、`targetSDKVersion` 和 `maxSdkVersion` 属性指示支持的 Android 版本，强调不应支持过时且存在已知漏洞的 Android 版本的重要性。

从 **strings.xml** 文件中，可以发现诸如 API keys、自定义 schema 以及其他开发者注释等敏感信息，强调了仔细审查这些资源的必要性。

### Tapjacking

**Tapjacking** 是一种攻击，其中一个 **malicious** **application** 被启动并**定位在受害应用之上**。一旦它在视觉上遮挡住受害应用，其用户界面会被设计成欺骗用户与之交互，同时将交互传递给受害应用。\
实际上，它是**使用户无法察觉他们实际上是在对受害应用执行操作**。

更多信息请见：


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

具有 `launchMode` 设置为 **`singleTask` 且未定义任何 `taskAffinity`** 的 **activity** 易受 Task Hijacking 攻击。这意味着，如果在真实应用之前安装并启动了一个应用，它可能**劫持真实应用的 task**（因此用户会与 **malicious application** 交互，但以为自己在使用真实应用）。

更多信息见：


{{#ref}}
android-task-hijacking.md
{{#endref}}

### 不安全的数据存储

**Internal Storage**

在 Android 中，存储在 **internal** 存储中的文件被设计为仅由**创建它们的 app** 访问。该安全措施由 Android 操作系统强制执行，通常足以满足大多数应用的安全需求。然而，开发者有时会使用诸如 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 的模式来**允许**文件在不同应用之间**共享**。但这些模式**不会限制其他应用（包括潜在的恶意应用）对这些文件的访问**。

1. **静态分析：**
- **确保**对 `MODE_WORLD_READABLE` 和 `MODE_WORLD_WRITABLE` 的使用进行**仔细审查**。这些模式**可能会将**文件暴露给**未预期或未授权的访问**。
2. **动态分析：**
- **验证**应用创建的文件的 **permissions**。具体来说，**检查**是否有任何文件被设置为对全局可读或可写。这可能构成重大安全风险，因为这会允许**设备上安装的任何应用**，无论其来源或意图如何，**读取或修改**这些文件。

**External Storage**

处理位于 **external storage**（例如 SD 卡）上的文件时，应采取以下预防措施：

1. **可访问性**：
- external storage 上的文件是**全局可读可写**的。这意味着任何应用或用户都可以访问这些文件。
2. **安全问题**：
- 鉴于访问的容易性，建议**不要在 external storage 上存储敏感信息**。
- external storage 可以被移除或被任何应用访问，因此它的安全性较低。
3. **处理来自 External Storage 的数据**：
- 始终对从 external storage 检索的数据进行**输入验证**。这是至关重要的，因为这些数据来源不可信。
- 强烈不建议在 external storage 上存储可执行文件或 class 文件以便动态加载。
- 如果应用必须从 external storage 检索可执行文件，请确保这些文件在动态加载之前已**签名并进行加密验证**。这一步对于维护应用的安全完整性是必要的。

External storage 的访问路径包括 `/storage/emulated/0`、`/sdcard`、`/mnt/sdcard`

> [!TIP]
> 从 Android 4.4（**API 17**）开始，SD 卡具有目录结构，**将应用的访问限制在专门为该应用指定的目录内**。这可防止恶意应用获取对其他应用文件的读或写权限。

**以明文存储的敏感数据**

- **Shared preferences**：Android 允许每个应用轻松在路径 `/data/data/<packagename>/shared_prefs/` 中保存 xml 文件，有时可以在该文件夹中以明文找到敏感信息。
- **Databases**：Android 允许每个应用轻松在路径 `/data/data/<packagename>/databases/` 中保存 sqlite 数据库，有时可以在该文件夹中以明文找到敏感信息。

### Broken TLS

**Accept All Certificates**

出于某些原因，开发者有时会接受所有证书，即使例如 hostname 不匹配，也会通过如下代码行：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 加密缺陷

**不良的密钥管理流程**

有些开发者将敏感数据保存在本地存储，并使用在代码中硬编码/可预测的 key 加密。这不应该这样做，因为逆向可能允许攻击者提取机密信息。

**使用不安全和/或已弃用的算法**

开发者不应该使用 **deprecated algorithms** 来执行授权 **checks**、**store** 或 **send** 数据。这些算法包括：RC4、MD4、MD5、SHA1 等。如果使用 **hashes** 来存储密码，例如，应使用抗暴力破解的 **hashes** 并配合 salt。

### 其他检查

- 建议对 **APK** 进行混淆，以增加逆向工程的难度。
- 如果应用是敏感的（如银行类应用），应进行其**自身的检查以判断手机是否已 rooted**并据此采取措施。
- 如果应用是敏感的（如银行类应用），应检查是否在使用 **emulator**。
- 如果应用是敏感的（如银行类应用），应**在执行前检查自身完整性**以确认是否被修改。
- 使用 [**APKiD**](https://github.com/rednaga/APKiD) 来检查构建 APK 时使用了哪个 compiler/packer/obfuscator

### React Native Application

阅读以下页面以学习如何轻松访问 React 应用的 javascript 代码：


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

阅读以下页面以学习如何轻松访问 Xamarin 应用的 C# 代码：


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### 自动化静态代码分析

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources**（指示工具那些由用户控制输入的位置）、**sinks**（指示工具那些可能因恶意用户输入而造成损害的危险位置）和 **rules**。这些规则指示哪些 **sources-sinks** 组合表示存在漏洞。

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **代码执行**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **发送 SMS**: `sendTextMessage, sendMultipartTestMessage`
- **声明为 `native` 的本地函数**: `public native, System.loadLibrary, System.load`
- [阅读此文以了解 **如何逆向本地函数**](reversing-native-libraries.md)
- 通过 JNI 在内存中执行本地代码（下载 shellcode → mmap/mprotect → 调用）：

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **其他技巧**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## 动态分析

> 首先，你需要一个可以安装应用及其所有环境（主要是 Burp CA 证书、Drozer 和 Frida）的环境。因此，强烈建议使用已 rooted 的设备（可模拟也可真实）。

### 在线动态分析

你可以在: [https://appetize.io/](https://appetize.io) 创建一个 **free account**。该平台允许你 **upload** 并 **execute** APKs，因此便于观察 APK 的行为。

你甚至可以在网页上 **查看应用的日志** 并通过 **adb** 连接。

![](<../../images/image (831).png>)

借助 ADB 连接，你可以在模拟器内使用 **Drozer** 和 **Frida**。

### 本地动态分析

#### 使用模拟器

- [**Android Studio**](https://developer.android.com/studio)（你可以创建 **x86** 和 **arm** 设备，而且根据 [**this**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) 最新 **x86** 版本 **支持 ARM libraries**，无需使用缓慢的 arm 模拟器）。
- 在此页面学习如何设置：


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition，需要创建账号。_建议 **download** 带有 **VirtualBox** 的版本以避免潜在错误._)
- [**Nox**](https://es.bignox.com)（免费，但不支持 Frida 或 Drozer）。

> [!TIP]
> 在任何平台创建新模拟器时请记住，屏幕越大，模拟器运行越慢。因此尽可能选择较小的屏幕。

要在 Genymotion 中 **install google services**（比如 AppStore），需要点击下图中标红的按钮：

![](<../../images/image (277).png>)

此外，请注意在 Genymotion 的 **Android VM 配置** 中可以选择 **Bridge Network mode**（当你需要从另一个带工具的 VM 连接到 Android VM 时会很有用）。

#### 使用真实设备

你需要启用 **debugging** 选项，如果能 **root** 设备会更好：

1. **Settings**。
2. （在 Android 8.0 及以上）选择 **System**。
3. 选择 **About phone**。
4. 连续按 **Build number** 7 次。
5. 返回即可看到 **Developer options**。

> 一旦安装了应用，首先应尝试使用它并调查它的行为、工作方式并熟悉它。\
> 我建议使用 MobSF dynamic analysis + pidcat 来**执行这一步初始动态分析**，这样我们可以在 MobSF **捕获** 大量可供稍后审查的**有趣** **数据**时**了解应用如何工作**。

Magisk/Zygisk 快速提醒（建议在 Pixel 设备上）
- 使用 Magisk app patch boot.img 并通过 fastboot flash 以获得 systemless root
- 启用 Zygisk + DenyList 以隐藏 root；在需要更强隐藏时可考虑 LSPosed/Shamiko
- 保留原始 boot.img 以便从 OTA 恢复；每次 OTA 后重新 patch
- 若要屏幕镜像，在 host 上使用 scrcpy

### 意外数据泄露

**日志记录**

开发者应谨慎避免公开 **debugging information**，因为这可能导致敏感数据泄露。推荐使用 [**pidcat**](https://github.com/JakeWharton/pidcat) 和 `adb logcat` 来监控应用日志，以识别并保护敏感信息。**Pidcat** 因其易用性和可读性而更受青睐。

> [!WARNING]
> 请注意，从 **Android 4.0 之后的版本** 起，**应用仅能访问其自身的日志**。所以应用无法访问其他应用的日志。\
> 无论如何，仍建议**不要记录敏感信息**。

**剪贴板缓存**

Android 的 **基于剪贴板的** 框架支持应用内的复制/粘贴功能，但存在风险，因为**其他应用**可以**访问**剪贴板，可能暴露敏感数据。对于应用中敏感的部分（例如信用卡信息），必须**禁用复制/粘贴**功能以防止数据泄露。

**崩溃日志**

如果应用 **crashes** 并 **保存日志**，这些日志可能会帮助攻击者，尤其是在应用无法被逆向工程时。为降低此风险，避免在崩溃时记录日志；如果必须通过网络传输日志，请确保通过 SSL 通道发送以保证安全。

作为 pentester，**尝试查看这些日志**。

**发送给第三方的 Analytics 数据**

应用经常集成像 Google Adsense 之类的服务，不当实现可能会无意中 **泄露敏感数据**。为识别潜在的数据泄露，建议**拦截应用的流量**并检查是否有敏感信息发送到第三方服务。

### SQLite DBs

大多数应用会使用 **internal SQLite databases** 来保存信息。在 pentest 期间，查看创建的 **databases**、**tables** 和 **columns** 的名称以及所有保存的数据，因为你可能会发现 **敏感信息**（这将构成一个漏洞）。\
数据库应位于 `/data/data/the.package.name/databases`，例如 `/data/data/com.mwr.example.sieve/databases`

如果数据库保存机密信息并且已被 **加密**，但你能在应用中**找到**用于解密的 **password**，这仍然是一个 **漏洞**。

使用 `.tables` 枚举表，使用 `.schema <table_name>` 枚举表的列

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### 利用 exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
还要记住，activity 的代码从 **`onCreate`** 方法开始。

**授权绕过**

当一个 Activity 被 exported 时，你可以从外部应用调用其界面。因此，如果一个包含 **敏感信息** 的 activity 被 **exported**，你可能能够 **绕过** **authentication** 机制 **访问它**。

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

你也可以通过 adb 启动一个 exported activity：

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**：MobSF 会将在 activity 中将 `android:launchMode` 设置为 _**singleTask/singleInstance**_ 识别为恶意，但根据 [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)，显然这仅在旧版本（API versions < 21）上危险。

> [!TIP]
> 请注意，authorisation bypass 并不总是一个漏洞，这取决于 bypass 的工作方式以及暴露了哪些信息。

**敏感信息泄露**

**Activities 也可以返回结果**。如果你能找到一个 exported 且未受保护的 activity 调用了 **`setResult`** 方法并**返回敏感信息**，则存在敏感信息泄露。

#### Tapjacking

如果未阻止 Tapjacking，你可能滥用导出的 activity 使 **用户执行意外操作**。有关更多信息，请参见 [**what is Tapjacking follow the link**](#tapjacking)。

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers 基本上用于 **共享数据**。如果一个应用暴露了 content providers，你可能能够从中 **提取敏感** 数据。还应测试可能存在的 **SQL injections** 和 **Path Traversals**，因为它们可能存在漏洞。

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
记住 Service 的动作从方法 `onStartCommand` 开始。

Service 基本上是可以 **接收数据**、**处理** 并（或不）**返回** 响应的东西。因此，如果应用导出了某些 services，你应该 **检查** **代码** 以了解其行为，并**动态测试**以提取机密信息、bypassing authentication measures...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
记住 Broadcast Receiver 的动作从方法 `onReceive` 开始。

Broadcast receiver 会等待某种类型的消息。取决于接收器如何处理消息，它可能存在漏洞。\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

你可以手动查找 deep links，使用像 MobSF 这样的工具或像 [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) 这样的脚本。\
你可以使用 **adb** 或 **browser** 打开已声明的 **scheme**：
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_请注意，你可以**omit the package name**，移动设备会自动调用用于打开该链接的应用。_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**代码执行**

In order to find the **将在 App 中执行的代码**, go to the activity called by the deeplink and search the function **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**敏感信息**

每次发现 deep link 时，检查 **它没有通过 URL 参数接收敏感数据（like passwords）**，因为任何其他应用都可能 **impersonate the deep link and steal that data!**

**路径中的参数**

You **must check also if any deep link is using a parameter inside the path** of the URL like: `https://api.example.com/v1/users/{username}` , in that case you can force a path traversal accessing something like: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note that if you find the correct endpoints inside the application you may be able to cause a **Open Redirect** (if part of the path is used as domain name), **account takeover** (if you can modify users details without CSRF token and the vuln endpoint used the correct method) and any other vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**更多示例**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### 传输层检查和验证失败

- **证书并非总是被 Android 应用正确检查**。这些应用常常忽略警告并接受自签名证书，或在某些情况下回退使用 HTTP 连接。
- **SSL/TLS 握手期间的协商有时很弱**，使用不安全的密码套件。这一漏洞使连接容易受到 man-in-the-middle (MITM) 攻击，允许攻击者解密数据。
- **私有信息泄露** 是一个风险，当应用使用安全通道进行认证，但随后在其他事务中通过非安全通道通信。这种做法无法保护敏感数据，例如 session cookies 或用户详情，免于被恶意方截获。

#### 证书验证

We will focus on **证书验证**。必须验证服务器证书的完整性以提高安全性。这一点很重要，因为不安全的 TLS 配置和通过未加密通道传输敏感数据会带来重大风险。关于验证服务器证书和修复漏洞的详细步骤，[**此资源**](https://manifestsecurity.com/android-application-security-part-10/) 提供了全面的指导。

#### SSL Pinning

SSL Pinning 是一种安全措施，应用将服务器证书与存储在应用内部的已知副本进行比对。该方法对于防止 MITM 攻击至关重要。强烈建议在处理敏感信息的应用中实施 SSL Pinning。

#### 流量检查

To inspect HTTP traffic, it's necessary to **install the proxy tool's certificate** (e.g., Burp). Without installing this certificate, encrypted traffic might not be visible through the proxy. For a guide on installing a custom CA certificate, [**此处**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Applications targeting **API Level 24 and above** require modifications to the Network Security Config to accept the proxy's CA certificate. This step is critical for inspecting encrypted traffic. For instructions on modifying the Network Security Config, [**参见此教程**](make-apk-accept-ca-certificate.md).

If **Flutter** is being used you need to to follow the instructions in [**此页面**](flutter.md). This is becasue, just adding the certificate into the store won't work as Flutter has its own list of valid CAs.

#### SSL/TLS pinning 的静态检测

Before attempting runtime bypasses, quickly map where pinning is enforced in the APK. Static discovery helps you plan hooks/patches and focus on the right code paths.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
用法
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
示例模式规则（JSON）
使用或扩展 signatures 来检测专有/自定义 pinning 样式。你可以加载你自己的 JSON 并进行大规模扫描。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- 针对大型应用使用 multi-threading 和 memory-mapped I/O 进行快速扫描；预编译的 regex 可减少开销/误报。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 接下来用于分类（triage）的典型检测目标：
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- 使用匹配到的位置来在动态测试前规划 Frida hooks、静态补丁或配置审查。



#### 绕过 SSL Pinning

当实现了 SSL Pinning 时，为了检查 HTTPS 流量，需要绕过它。为此有多种方法：

- 自动 **modify** the **apk** 来 **bypass** SSLPinning，使用 [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)。这个选项的最大优点是你不需要 root 来绕过 SSL Pinning，但你需要删除应用并重新安装新的 apk，而且这并不总是有效。
- 你可以使用 **Frida**（下面会讨论）来绕过该保护。这里有一篇使用 Burp+Frida+Genymotion 的指南： [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- 你也可以尝试使用 [**objection**](frida-tutorial/objection-tutorial.md)**:** 自动绕过 SSL Pinning：`objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- 你也可以尝试使用 **MobSF dynamic analysis** 自动绕过 SSL Pinning（下文有解释）
- 如果你仍然认为有流量没有被捕获，可以尝试使用 iptables 将流量转发到 burp。阅读这篇博客： [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 查找常见 Web 漏洞

同样重要的是在应用内搜索常见的 web 漏洞。识别和缓解这些漏洞的详细信息超出本摘要范围，但在其他地方有详尽的覆盖。

### Frida

[Frida](https://www.frida.re) 是一个面向开发者、逆向工程师和安全研究人员的动态插桩工具包。\
**你可以在运行时访问运行中的应用并 hook 方法以改变行为、修改值、提取值、执行不同的代码...**\
如果你想对 Android 应用进行 pentest，你需要知道如何使用 Frida。

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- 尝试按照 [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) 中所示的方式加载 Frida 来绕过 anti-debugging / anti-frida 机制（工具 [linjector](https://github.com/erfur/linjector-rs)）

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

检查应用是否在内存中存储了不应该存储的敏感信息，例如密码或助记词。

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
这将把内存转储到 ./dump 文件夹，然后你可以在其中用类似下面的命令进行 grep：
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore 中的敏感数据**

在 Android 中，Keystore 是存放敏感数据的最佳位置，然而在拥有足够权限的情况下仍然可以访问它。

由于应用往往会在此处以明文存储敏感数据，pentests 应以 root user 身份检查这一点，否则具有设备物理访问权限的人可能会窃取这些数据。

即使应用将数据存储在 Keystore 中，这些数据也应被加密。

要访问 Keystore 中的数据，可以使用这个 Frida 脚本： [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

使用下面的 Frida 脚本，可能可以 **bypass fingerprint authentication**，从而绕过 Android 应用为**保护某些敏感区域：**所执行的认证。
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **后台快照**

当你将应用置于后台时，Android 会保存应用的 **应用的快照**，因此在恢复到前台时，它会先加载该图像，再加载应用本身，从而看起来应用启动得更快。

然而，如果该 **敏感信息** 包含在快照中，有权限访问该快照的人可能会 **窃取这些信息**（注意你需要 root 权限才能访问）。

快照通常存储在： **`/data/system_ce/0/snapshots`**

Android 提供了一种通过设置 **通过设置 FLAG_SECURE 来防止截屏** 的方法。使用该 flag 时，窗口内容会被视为安全，从而防止其出现在截屏中或在非安全显示器上被查看。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

这个工具可以帮助你在动态分析期间管理不同的工具： [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

开发者常常创建像 activities、services 和 broadcast receivers 这样的代理组件来处理这些 Intents，并将它们传递给诸如 `startActivity(...)` 或 `sendBroadcast(...)` 之类的方法，这可能很危险。

危险在于允许攻击者通过误导这些 Intents 来触发未导出的 app 组件或访问敏感的 content providers。一个显著的例子是 `WebView` 组件通过 `Intent.parseUri(...)` 将 URLs 转换为 `Intent` 对象然后执行它们，这可能导致恶意的 Intent 注入。

### Essential Takeaways

- **Intent Injection** 类似于 web 的 Open Redirect 问题。
- 利用通常涉及将 `Intent` 对象作为 extras 传递，这些 Intent 可能被重定向去执行不安全的操作。
- 它可能使非导出组件和 content providers 暴露给攻击者。
- `WebView` 将 URL 转换为 `Intent` 的行为可能促成非预期的动作。

### Android Client Side Injections and others

这些漏洞你可能在 Web 中已经见过。在 Android 应用中对这些漏洞要特别小心：

- **SQL Injection:** 在处理动态查询或 Content-Providers 时，确保使用参数化查询。
- **JavaScript Injection (XSS):** 确认任何 WebViews 的 JavaScript 和 Plugin 支持被禁用（默认禁用）。 [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews 应禁用对文件系统的访问（默认启用） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 在若干情况下，当 Android 应用结束会话时，cookie 未被撤销，甚至可能被保存到磁盘
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** 使用一个漂亮的基于 web 的前端进行。你也可以执行动态分析（但是需要准备环境）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### 使用 MobSF 的辅助动态分析

**MobSF** 在 **Android** 的 **dynamic analysis** 上也非常有用，但在这种情况下你需要在宿主机上安装 MobSF 和 **genymotion**（虚拟机或 Docker 不可行）。_Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, 日志, 剪贴板, 你手动截的屏幕截图, screenshots made by "**Exported Activity Tester**", 邮件, SQLite 数据库, XML 文件, 以及其他创建的文件)。除截图外，其他都会自动完成；截图需要你在想截屏时按下（按钮），或者按 "**Exported Activity Tester**" 以获取所有 exported activities 的截图。
- Capture **HTTPS traffic**
- Use **Frida** to obtain **运行时 信息**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: 它会打印所有已加载的类
- **Capture Strings**: 它会在使用应用时打印所有被捕获的字符串（非常嘈杂）
- **Capture String Comparisons**: 可能非常有用。它会**显示被比较的两个字符串**以及比较结果是 True 还是 False。
- **Enumerate Class Methods**: 输入类名（例如 "java.io.File"），它会打印该类的所有方法。
- **Search Class Pattern**: 按模式搜索类
- **Trace Class Methods**: **Trace** 整个类（查看该类所有方法的输入和输出）。记住默认情况下 MobSF 会追踪若干有趣的 Android Api 方法。

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 工具**

当 http 流量被捕获时，你可以在“**HTTP(S) Traffic**”底部看到捕获流量的原始视图，或在绿色的“**Start HTTPTools**”按钮中看到更友好的视图。从第二个选项，你可以将 **captured requests** 发送到像 Burp 或 Owasp ZAP 这样的 **proxies**。\
要做到这一点，_power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> 按下“**Send to Fuzzer**” --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

完成 MobSF 的动态分析后，你可以点击“**Start Web API Fuzzer**”对 **http requests** 进行 **fuzz**，以查找漏洞。

> [!TIP]
> 在使用 MobSF 执行动态分析后，代理设置可能会被错误配置，并且你无法通过 GUI 修复它们。你可以通过运行以下命令修复代理设置：
>
> ```
> adb shell settings put global http_proxy :0
> ```

### 使用 Inspeckage 的辅助动态分析

你可以从 [**Inspeckage**](https://github.com/ac-pm/Inspeckage) 获取该工具。\
该工具将使用一些 **Hooks**，以便在你执行 **dynamic analysis** 时让你了解 **what is happening in the application**。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

这是一个用于通过 GUI 执行 **static analysis** 的优秀工具

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

该工具旨在查找若干 **security related Android application vulnerabilities**，既可在 **source code** 中查找，也可在 **packaged APKs** 中查找。该工具还**capable of creating a "Proof-of-Concept" deployable APK** 和 **ADB commands**，用于利用部分已发现的漏洞（Exposed activities、intents、tapjacking...）。与 Drozer 一样，无需对测试设备进行 root。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 显示所有提取的文件以便参考
- 自动将 APK 文件反编译为 Java 和 Smali 格式
- 分析 AndroidManifest.xml 以查找常见漏洞和行为
- 静态源代码分析以查找常见漏洞和行为
- 设备信息
- 以及更多
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER 是一款命令行应用，可在 Windows、MacOS X 和 Linux 上使用，用于分析 _.apk_ 文件以查找漏洞。它通过解压 APKs 并应用一系列规则来检测这些漏洞。

所有规则都集中在 `rules.json` 文件中，每个公司或测试人员都可以创建自己的规则来分析他们需要的内容。

从 [download page](https://superanalyzer.rocks/download.html) 下载最新的二进制文件。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn 是一个 **跨平台** 的工具，帮助开发者、漏洞赏金猎人和白帽黑客对移动应用执行 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)。

其工作原理是将移动应用文件（.apk 或 .ipa 文件）拖放到 StaCoAn 应用上，它会为你生成一个可视化且便于携带的报告。你可以调整设置和词表以获得定制化体验。

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework 是一个 Android 漏洞分析系统，帮助开发者或 hackers 发现 Android 应用中的潜在安全漏洞。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** 是一个工具，主要用于检测并警告用户 Android 应用可能具有的潜在恶意行为。

检测通过对应用的 Dalvik bytecode（以 **Smali** 表示）进行 **static analysis**，并使用 [`androguard`](https://github.com/androguard/androguard) 库来完成。

该工具会查找 **common behavior of "bad" applications**，例如：Telephony identifiers exfiltration、Audio/video flow interception、PIM data modification、Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. 它将常用的移动应用逆向与分析工具整合在一起，帮助针对 OWASP mobile security threats 测试移动应用。其目标是让这项工作对移动应用开发者和安全人员更简单、更友好。

它能够：

- 使用不同工具提取 Java 和 Smali 代码
- 使用以下工具分析 APK: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- 使用 regexp 提取 APK 中的私有信息
- 分析 Manifest
- 使用以下工具分析发现的域名: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) 和 [whatweb](https://github.com/urbanadventurer/WhatWeb)
- 通过 [apk-deguard.com](http://www.apk-deguard.com) 去混淆 APK

### Koodous

用于检测恶意软件： [https://koodous.com/](https://koodous.com/)

## 混淆 / 去混淆 代码

请注意，根据你用来混淆代码的服务和配置，Secrets 可能会被混淆，也可能不会被混淆。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

摘自 [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** 是一个开源命令行工具，用于缩减、优化并混淆 Java 代码。它能够优化字节码，并检测和删除未使用的指令。ProGuard 是自由软件，根据 GNU General Public License 第2版发布。

ProGuard 随 Android SDK 一起分发，并在以 release 模式构建应用时运行。

### [DexGuard](https://www.guardsquare.com/dexguard)

在 [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html) 可以找到一份逐步指南来去混淆 apk。

（摘自该指南）我们上次检查时，Dexguard 的运行模式是：

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard 逆转了 Android 混淆工具执行的混淆过程。这支持大量的安全分析，包括代码检查和库预测。**

你可以将被混淆的 APK 上传到他们的平台。

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

这是一个使用 LLM 来发现 android 应用中潜在安全漏洞并去混淆 android 应用代码的工具。使用 Google's Gemini public API。

### [Simplify](https://github.com/CalebFenton/simplify)

这是一个 **通用的 android 去混淆器。** Simplify **通过虚拟执行应用** 来理解其行为，然后 **尝试优化代码**，使其在行为上保持一致但更易于人类理解。每种优化类型都简单且通用，因此具体使用了何种混淆方法并不重要。

### [APKiD](https://github.com/rednaga/APKiD)

APKiD 会告诉你 **一个 APK 是如何被构建的**。它能识别许多 **compilers**, **packers**, **obfuscators** 以及其他奇怪的东西。它是 Android 领域的 [_PEiD_](https://www.aldeid.com/wiki/PEiD)。

### Manual

[阅读本教程以学习一些关于 **如何逆向自定义混淆** 的技巧](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b 是基于 ubuntu-mate 的 Android 安全虚拟机，包含来自不同安全研究者和逆向/恶意软件分析爱好者的最新框架、教程和实验集合。

## 参考资料

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) — 一个很棒的资源列表
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 快速课程
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
