# Android アプリケーション Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android アプリケーションの基本

このページを最初に読むことを強くお勧めします。ここでは、**Android セキュリティに関連する最も重要な部分と、Android アプリケーション内で最も危険なコンポーネント**について説明しています：


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

これは、エミュレータまたは実機の Android デバイスに接続するために必要な主要なツールです。\
**ADB** は、コンピュータから **USB** または **ネットワーク** 経由でデバイスを制御することを可能にします。このユーティリティは、ファイルの双方向での **コピー**、アプリの **インストール** と **アンインストール**、**シェルコマンド** の実行、データの **バックアップ**、ログの **読み取り**、その他の機能を提供します。

adb の使い方を学ぶには、次の [**ADB Commands**](adb-commands.md) の一覧を参照してください。

## Smali

場合によっては、隠された情報（高度に難読化されたパスワードやフラグなど）にアクセスするために、アプリケーションのコードを**変更する**ことが有用です。その場合、apk をデコンパイルしてコードを修正し、再コンパイルすることが考えられます。\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md)。これは、後で示す動的解析中のいくつかのテストに対する**代替手段**として非常に有用です。したがって、常にこの可能性を念頭に置いてください。

## その他の興味深いトリック

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- すべての splits と base apks を [APKEditor](https://github.com/REAndroid/APKEditor) でマージする:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## ケーススタディ & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

まず、APKを解析する際は、decompilerを使ってJavaコードを確認してください。\
[**異なる利用可能なデコンパイラに関する情報はここを参照してください**](apk-decompilers.md)。

### Looking for interesting Info

APKの**strings**を見ただけでも、**passwords**、**URLs**（[https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)）、**api**キー、**encryption**、**bluetooth uuids**、**tokens**など興味深いものを探せます。コード実行の**backdoors**や認証backdoors（アプリにハードコードされた管理者資格情報）も探してください。

**Firebase**

FirebaseのURLに特に注意し、誤設定がないか確認してください。[Firebaseとは何か、またそれをどのように悪用するかの詳細はこちら。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

アプリケーションの**_Manifest.xml_ と **_strings.xml_** ファイルの確認により、潜在的なセキュリティ脆弱性が明らかになることがあります。これらのファイルはdecompilerでアクセスするか、APKの拡張子を .zip に変更して解凍することで取得できます。

**Manifest.xml** から特定できる**脆弱性**には以下が含まれます:

- **Debuggable Applications**: _Manifest.xml_で`debuggable="true"`に設定されているアプリは、接続を許してしまい、悪用されるリスクがあります。デバッガブルなアプリの発見と悪用方法についてはデバイス上でのチュートリアルを参照してください。
- **Backup Settings**: 機密情報を扱うアプリでは、adb経由の不正なデータバックアップを防ぐために`android:allowBackup="false"`を明示的に設定するべきです（特にUSBデバッグが有効な場合）。
- **Network Security**: _res/xml/_ 内のカスタム network security 設定 (`android:networkSecurityConfig="@xml/network_security_config"`) は、証明書ピンやHTTPトラフィックの設定などのセキュリティ詳細を指定できます。例として特定ドメインに対してHTTPトラフィックを許可する設定などがあります。
- **Exported Activities and Services**: マニフェスト内でexportedになっているactivityやserviceを特定することで、悪用されうるコンポーネントを明らかにできます。動的テスト中のさらなる解析により、これらのコンポーネントの悪用方法が判明することがあります。
- **Content Providers and FileProviders**: 公開されたcontent providerはデータへの不正アクセスや改ざんを許す可能性があります。FileProviderの設定も注意深く確認してください。
- **Broadcast Receivers and URL Schemes**: これらのコンポーネントは悪用に使われる可能性があり、特にURLスキームの処理が入力に対して脆弱でないか注意が必要です。
- **SDK Versions**: `minSdkVersion`、`targetSDKVersion`、`maxSdkVersion` はサポートされるAndroidバージョンを示します。古く脆弱なAndroidバージョンをサポートしないことが重要です。

**strings.xml** からは、APIキー、カスタムスキーマ、開発者メモなどの機密情報が見つかることがあり、これらのリソースは慎重にレビューする必要があります。

### Tapjacking

Tapjackingは、**malicious**な**application**が起動して被害者のアプリの上に自らを**配置する**攻撃です。被害者アプリを視覚的に覆い隠すと、そのユーザーインターフェースはユーザーを騙して操作させるように設計され、同時にその操作を被害者アプリに渡します。\
結果として、ユーザーは実際には被害者アプリ上で操作をしていることに気づかずに行動してしまいます。

詳しくは以下を参照してください:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode` が `singleTask` に設定され、かつ `taskAffinity` が定義されていない **activity** は task Hijacking に対して脆弱です。これは、悪意のある**application**をインストールしてそれを本来のアプリより先に起動すると、本物のアプリのタスクを**乗っ取る（hijack）**可能性があることを意味します（その結果、ユーザーは**悪意あるアプリを本物だと誤認して操作してしまいます**）。

詳細は以下を参照してください:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Androidでは、Internalストレージに**保存された**ファイルはそれを**作成したアプリだけがアクセスできる**よう設計されています。このセキュリティはOSによって強制され、多くのアプリにとって十分です。しかし、開発者が `MODE_WORLD_READABLE` や `MODE_WORLD_WRITABLE` といったモードを使用してアプリ間でファイルを共有する場合があります。これらのモードは他のアプリ、場合によっては悪意あるアプリによるファイルへのアクセスを**制限しません**。

1. **Static Analysis:**
- `MODE_WORLD_READABLE` や `MODE_WORLD_WRITABLE` の使用がないかを**注意深く確認**してください。これらのモードはファイルを**意図しない、または不正なアクセスに晒す**可能性があります。
2. **Dynamic Analysis:**
- アプリが作成したファイルの**権限**を確認してください。特に、ファイルが世界中で読み取りや書き込み可能に設定されていないかを**チェック**します。これは重大なセキュリティリスクとなり、インストールされている**どのアプリ**でも当該ファイルを読み書きできてしまう可能性があります。

**External Storage**

SDカードのような**external storage**上のファイルを扱う際には、以下の点に注意してください:

1. **Accessibility**:
- external storage上のファイルは**グローバルに読み書き可能**です。つまり、任意のアプリやユーザーがアクセスできます。
2. **Security Concerns**:
- アクセスしやすいため、機密情報をexternal storageに保存しないことが推奨されます。
- external storageは取り外されたり任意のアプリからアクセスされたりするため、セキュリティが低くなります。
3. **Handling Data from External Storage**:
- external storageから取得したデータは常に**入力検証**を行ってください。外部ソースから来たデータは信頼できないため特に重要です。
- external storage上に実行可能ファイルやクラスファイルを置き、動的ロードすることは強く非推奨です。
- もしどうしてもexternal storageから実行ファイルを取得して動的にロードする必要がある場合は、それらのファイルが**署名され暗号的に検証されている**ことを確認してからロードしてください。これはアプリのセキュリティ整合性を維持するために重要です。

External storageは `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` で**アクセス**できます。

> [!TIP]
> Android 4.4（**API 17**）以降、SDカードにはアプリごとのディレクトリ構造が導入され、アプリはそのアプリ専用のディレクトリにのみアクセスが制限されます。これにより、悪意あるアプリが別アプリのファイルに読み書きアクセスすることを防げます。

**Sensitive data stored in clear-text**

- **Shared preferences**: Androidでは各アプリが `/data/data/<packagename>/shared_prefs/` に簡単にxmlファイルを保存できますが、そのフォルダ内に平文の機密情報が見つかることがあります。
- **Databases**: Androidでは各アプリが `/data/data/<packagename>/databases/` にsqliteデータベースを簡単に保存できますが、そのフォルダ内に平文の機密情報が見つかることがあります。

### Broken TLS

**Accept All Certificates**

なぜか開発者が、例えばホスト名が一致しない場合でもすべての証明書を受け入れてしまうことがあります。例えば以下のようなコード行で:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### 脆弱な暗号

**Poor Key Management Processes**

一部の開発者は機密データをローカルストレージに保存し、コード内にハードコード／予測可能なキーで暗号化しています。リバースエンジニアリングにより攻撃者が機密情報を抽出できる可能性があるため、これは避けるべきです。

**Use of Insecure and/or Deprecated Algorithms**

開発者は認可チェック、データの保存や送信に**deprecated algorithms**を使用すべきではありません。これらのアルゴリズムには RC4, MD4, MD5, SHA1... などがあります。例えばパスワードの保存に**hashes**を使用する場合は、salt を用いた**brute-force**耐性のあるハッシュを使うべきです。

### その他のチェック

- 攻撃者のリバースエンジニアリング作業を難しくするために、**APK を難読化すること**を推奨します。
- アプリが機密性の高いものである場合（銀行アプリ等）、モバイルが**rooted**かどうかを**自身で検査**し、それに応じて動作するべきです。
- アプリが機密性の高いものである場合（銀行アプリ等）、**エミュレータ**が使われているかどうかを確認するべきです。
- アプリが機密性の高いものである場合（銀行アプリ等）、**実行前に自身の整合性をチェックして改変されていないか確認する**べきです。
- ビルドにどのコンパイラ／パッカー／難読化ツールが使われたか確認するには [**APKiD**](https://github.com/rednaga/APKiD) を使ってください

### React Native アプリケーション

React アプリケーションの javascript コードへ簡単にアクセスする方法を学ぶには次のページを読んでください：


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Xamarin アプリケーションの C# コードへ簡単にアクセスする方法を学ぶには次のページを読んでください：


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

ツール [**mariana-trench**](https://github.com/facebook/mariana-trench) はアプリケーションの**コード**を**スキャン**して**脆弱性**を検出することができます。このツールはツールに対して**known sources**（ユーザが制御する**入力**が存在する**場所**を示す）、**sinks**（悪意ある入力がダメージを与え得る**危険な場所**を示す）、および **rules** を含みます。これらのルールは脆弱性を示す **sources-sinks** の**組み合わせ**を示します。

これらにより、**mariana-trench はコードを解析して可能性のある脆弱性を検出します**。

### Secrets leaked

アプリケーション内には secrets（API keys, passwords, hidden urls, subdomains...）が含まれている場合があり、発見できる可能性があります。例えば次のようなツールを使用できます: [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## 動的解析

> まず第一に、アプリをインストールでき、必要な環境（Burp CA cert, Drozer, Frida など）を整えられる環境が必要です。したがって、rooted デバイス（エミュレートされているかどうかは問わない）が強く推奨されます。

### オンライン動的解析

[https://appetize.io/](https://appetize.io/) に**無料アカウント**を作成できます。このプラットフォームは APK を**アップロード**して**実行**できるため、APK の挙動を確認するのに便利です。

ウェブ上でアプリのログを**閲覧**したり、**adb** 経由で接続することもできます。

![](<../../images/image (831).png>)

ADB 接続のおかげで、エミュレータ内で **Drozer** や **Frida** を使用できます。

### ローカル動的解析

#### エミュレータを使用する場合

- [**Android Studio**](https://developer.android.com/studio)（**x86** と **arm** のデバイスを作成できます。および [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**最新の x86** バージョンは **ARM ライブラリをサポート**しており、遅い arm エミュレータは不要です）。
- セットアップ方法は次のページを参照してください：


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition、アカウント作成が必要です。_潜在的なエラーを避けるために_ **VirtualBox 同梱版** を**ダウンロード**することを推奨します。_)
- [**Nox**](https://es.bignox.com)（無料ですが、Frida や Drozer をサポートしていません）。

> [!TIP]
> どのプラットフォームで新しいエミュレータを作成する場合でも、画面サイズが大きいほどエミュレータの動作は遅くなります。可能なら小さい画面を選んでください。

Genymotion に Google サービス（Play Store など）をインストールするには、次の画像の赤いマークのボタンをクリックする必要があります：

![](<../../images/image (277).png>)

また、**Genymotion の Android VM の設定**で **Bridge Network mode** を選択できることに注意してください（別の VM からツールで Android VM に接続する場合に有用です）。

#### 実機を使用する場合

デバッグオプションを有効にする必要があり、可能であれば **root** しておくとよいでしょう:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> アプリをインストールしたら、まずはアプリを実行して何をするか、どのように動作するかを調べ、慣れてください。\
> 最初の動的解析は MobSF dynamic analysis + pidcat を使って行うことをお勧めします。これにより MobSF が後で確認できる多くの興味深いデータを**キャプチャ**している間に、アプリの動作を学ぶことができます。

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### 意図しないデータ漏洩

**Logging**

開発者は**デバッグ情報**を公開しないよう注意するべきです。これは機密データの漏洩につながる可能性があります。アプリケーションのログを監視して機密情報の保護を確認するには、ツール [**pidcat**](https://github.com/JakeWharton/pidcat) と `adb logcat` の使用を推奨します。**Pidcat** は使いやすさと読みやすさから好まれます。

> [!WARNING]
> Android 4.0 より**新しいバージョンからは**、**アプリケーションは自身のログにのみアクセス可能**です。したがってアプリは他のアプリのログにアクセスできません。\
> それでも、機密情報をログに出力しないことを強く推奨します。

**Copy/Paste Buffer Caching**

Android の **clipboard ベースの**フレームワークはアプリ間でのコピー＆ペースト機能を提供しますが、**他のアプリ**がクリップボードにアクセスできるため、機密データが露出するリスクがあります。クレジットカード情報など機密性の高い箇所ではコピー／ペースト機能を無効にすることが重要です。

**Crash Logs**

アプリが **クラッシュ**してログを保存する場合、これらのログはリバースできないアプリに対して攻撃者に情報を提供する可能性があります。このリスクを軽減するため、クラッシュ時にログを出力しないようにし、ネットワーク経由でログを送信する必要がある場合は必ず SSL チャネルで送信してください。

pentester として、**これらのログを確認する**ことを試みてください。

**Analytics Data Sent To 3rd Parties**

多くのアプリは Google Adsense のようなサービスを統合しており、開発者の不適切な実装により機密データが**漏洩**する可能性があります。サードパーティに送信されるデータを検出するには、アプリのトラフィックをインターセプトして機密情報が送信されていないか確認することを推奨します。

### SQLite DBs

ほとんどのアプリは情報を保存するために**内部の SQLite データベース**を使用します。pentest の際は作成されている**データベース**、**テーブル名**や**カラム名**、保存されている**データ**を確認してください。そこに機密情報が含まれていると脆弱性になります。\
データベースは通常 `/data/data/the.package.name/databases` にあります。例: `/data/data/com.mwr.example.sieve/databases`

もしデータベースが機密情報を保存しており**暗号化されている**が、その**パスワードをアプリ内で見つけられる**場合、それは依然として**脆弱性**です。

テーブル一覧は `.tables` で、テーブルのカラムは `.schema <table_name>` で列挙します。

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
また、Activity のコードは **`onCreate`** メソッドから開始することを忘れないでください。

**Authorisation bypass**

Activity が exported になっていると、外部アプリからその画面を呼び出すことができます。したがって、**機密情報を表示する Activity が exported になっている場合は、認証を**バイパス**してアクセスされる可能性**があります。

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

また、adb から exported activity を起動することも可能です:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> 認可バイパスが必ずしも脆弱性であるとは限らないことに注意してください。バイパスの仕組みやどの情報が露出するかによって判断が変わります。

**機密情報の漏洩**

**Activities can also return results**. エクスポートされ保護されていない activity を見つけ、**`setResult`** メソッドを呼び出して **機密情報を返している** 場合、機密情報の漏洩があります。

#### Tapjacking

Tapjacking が防止されていない場合、エクスポートされた activity を悪用して **ユーザに予期しない操作をさせる** ことができます。Tapjacking の詳細については [**what is Tapjacking follow the link**](#tapjacking) を参照してください。

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers は基本的に **データを共有** するために使われます。アプリに利用可能な content providers がある場合、そこから **機密データを抽出** できる可能性があります。また、**SQL injections** や **Path Traversals** の脆弱性がないかテストすることも重要です。

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Service の処理は `onStartCommand` メソッドで開始されることを覚えておいてください。

Service は基本的にデータを **受け取り**、**処理** し、（場合によっては）レスポンスを **返す** ものです。したがって、アプリがいくつかの services をエクスポートしている場合は、何をしているかを理解するために **コードを確認** し、機密情報の抽出や認証回避などを目的に **動的にテスト** するべきです。\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Broadcast Receiver の処理は `onReceive` メソッドで開始されることを覚えておいてください。

Broadcast receiver は特定のタイプのメッセージを待ち受けます。受信したメッセージの処理方法によっては脆弱になる可能性があります。\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

deep links は手動で探すこともでき、MobSF のようなツールや [このスクリプト](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) のようなものを使えます。\
宣言された scheme は **adb** やブラウザで **open** できます:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_パッケージ名を**省略できることに注意してください**。モバイル端末はそのリンクを開くアプリを自動的に呼び出します。_
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**実行されるコード**

アプリで**実行されるコード**を見つけるには、deeplink により呼び出される Activity に移動して、関数 **`onNewIntent`** を探してください。

![](<../../images/image (436) (1) (1) (1).png>)

**機密情報**

deep link を見つけたら毎回、その deep link が URL パラメータ経由で機密データ（例えばパスワード）を受け取っていないか確認してください。さもないと他のアプリが deep link をなりすましてそのデータを盗む可能性があります！

**パス内のパラメータ**

URL のパス内にパラメータを使っている deep link がないかも確認する必要があります。例えば: `https://api.example.com/v1/users/{username}` のような場合、`example://app/users?username=../../unwanted-endpoint%3fparam=value` のようにアクセスして path traversal を強制できることがあります。\
アプリ内で正しいエンドポイントを見つけられれば、パスの一部がドメイン名として使われている場合に **Open Redirect** を引き起こしたり、CSRF token なしでユーザ詳細を変更できる場合には **account takeover** を発生させたり、その他の脆弱性を誘発できる可能性があります。詳しくは [info about this here](http://dphoeniixx.com/2020/12/13-2/)。

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. アプリが警告を無視して self-signed certificates を受け入れたり、場合によっては HTTP 接続に戻すことがよくあります。
- **Negotiations during the SSL/TLS handshake are sometimes weak**, employing insecure cipher suites. この脆弱性により接続が man-in-the-middle (MITM) 攻撃に対して脆弱になり、攻撃者がデータを復号できる可能性があります。
- **Leakage of private information** は、アプリが secure channels で認証を行いながら、他のやり取りを non-secure channels で行う場合にリスクとなります。この方法ではセッション cookie やユーザ情報といった機密データが悪意ある第三者に傍受されるのを防げません。

#### Certificate Verification

ここでは **証明書の検証** に焦点を当てます。サーバの証明書の整合性を検証することはセキュリティを高めるために重要です。安全でない TLS 設定や暗号化されていないチャネルでの機密データ送信は重大なリスクを引き起こす可能性があります。サーバ証明書の検証方法や脆弱性対処の詳細手順については [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) を参照してください。

#### SSL Pinning

#### SSL Pinning

SSL Pinning は、アプリがサーバ証明書をアプリ内に保持された既知のコピーと照合して検証するセキュリティ対策です。この手法は MITM 攻撃を防ぐために不可欠です。機密情報を扱うアプリには SSL Pinning の実装を強く推奨します。

#### Traffic Inspection

HTTP トラフィックを検査するには、proxy tool の証明書（例: Burp）を**インストールする必要があります**。この証明書をインストールしていないと、暗号化されたトラフィックはプロキシ経由で見えないことがあります。カスタム CA 証明書のインストール方法については [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine) を参照してください。

API Level 24 以上をターゲットにしているアプリは、プロキシの CA 証明書を受け入れるために Network Security Config の変更が必要です。この手順は暗号化トラフィックの検査において重要です。Network Security Config の変更方法については [**refer to this tutorial**](make-apk-accept-ca-certificate.md) を参照してください。

もし **Flutter** を使用している場合は [**this page**](flutter.md) の指示に従う必要があります。単に証明書をストアに追加するだけでは機能しないことがあり、Flutter は独自の有効な CA リストを持っているためです。

#### Static detection of SSL/TLS pinning

ランタイムでのバイパスを試みる前に、APK 内でどこに pinning が適用されているかを素早くマップしてください。静的検出は hooks/patches を計画し、適切なコードパスに集中するのに役立ちます。

Tool: SSLPinDetect
- オープンソースの静的解析ユーティリティ。APK を Smali にデコンパイル（apktool 経由）し、SSL/TLS pinning 実装のためにキュレーションされた正規表現パターンをスキャンします。
- 各マッチについて正確なファイルパス、行番号、コードスニペットを報告します。
- 一般的なフレームワークやカスタムコードパスをカバーします: OkHttp CertificatePinner、custom javax.net.ssl.X509TrustManager.checkServerTrusted、SSLContext.init with custom TrustManagers/KeyManagers、そして Network Security Config XML pins。

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
使い方
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
例のパターンルール（JSON）
署名を使用または拡張して、独自/カスタムの pinning スタイルを検出します。独自の JSON を読み込み、大規模にスキャンできます。
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- 大規模アプリを高速にスキャンするには、マルチスレッドとメモリマップドI/Oを利用；事前コンパイル済みの正規表現はオーバーヘッド／誤検知を減らす。
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 次にトリアージすべき典型的な検出対象：
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- 一致した箇所を使って、動的テスト前にFrida hooks、静的パッチ、または設定レビューを計画する。



#### SSL Pinningのバイパス

SSL Pinningが実装されている場合、HTTPSトラフィックを解析するためにこれをバイパスする必要が出てきます。目的のために利用できる方法はいくつかあります：

- 自動的に**apk**を**modify**してSSLPinningを**bypass**するには[**apk-mitm**](https://github.com/shroudedcode/apk-mitm)を使う。最大の利点は、SSLPinningをバイパスするのにrootが不要な点だが、アプリを削除して新しいものを再インストールする必要があり、常に動作するわけではない。
- この保護をバイパスするために**Frida**（下記参照）を使うこともできる。Burp+Frida+Genymotionを使うガイドはこちら: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- また、[**objection**](frida-tutorial/objection-tutorial.md)を使って**自動的にSSL Pinningをバイパス**することも試せる： `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dynamic analysis**を使ってSSL Pinningを**自動的にバイパス**することも試せる（下記参照）
- それでも取得できていないトラフィックがあると思う場合は、iptablesを使ってトラフィックをburpに転送することを試せる。こちらの記事を参照: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 一般的なWeb脆弱性の探索

アプリ内で一般的なWeb脆弱性を検索することも重要です。これらの脆弱性の特定と緩和に関する詳細はこの要約の範囲を超えますが、他の資料で詳しく扱われています。

### Frida

[Frida](https://www.frida.re)は開発者、リバースエンジニア、セキュリティ研究者向けの動的インストルメンテーションツールキットです。\
**実行中のアプリにアクセスしてランタイムでメソッドをhookし、挙動を変更したり値を変更・抽出したり、別のコードを実行したりできます。**\
AndroidアプリをpentestするならFridaの使い方を知る必要があります。

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- anti-debugging / anti-fridaメカニズムを回避するため、Fridaを[https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace)に示されているようにロードすることを試してみてください（ツール [linjector](https://github.com/erfur/linjector-rs)）

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **メモリダンプ - Fridump**

アプリがパスワードやニーモニックなど、本来メモリに保存すべきでない機密情報をメモリ内に保持していないか確認してください。

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
これによりメモリが ./dump フォルダにダンプされ、そこでは次のようなコマンドで grep できます:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore内の機密データ**

AndroidではKeystoreが機密データを保存する最適な場所ですが、十分な権限があればそれに**アクセスすることが可能**です。アプリケーションはここに**平文で機密データを保存する**傾向があるため、pentestsはroot userやデバイスに物理的にアクセスできる者がこのデータを盗める可能性があることを考慮して確認すべきです。

アプリがKeystoreにデータを保存する場合でも、そのデータは暗号化されているべきです。

Keystore内のデータにアクセスするには、次のFridaスクリプトを使用できます: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

以下のFridaスクリプトを使用すると、Androidアプリが特定の機密領域を保護するために実行している可能性のある**bypass fingerprint authentication**を回避できる場合があります:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **バックグラウンド画像**

アプリケーションをバックグラウンドに移すと、Androidは**アプリケーションのスナップショット**を保存します。フォアグラウンドに復帰した際に、アプリ本体より先にその画像を読み込むことで、アプリがより速く読み込まれたように見せます。

しかし、このスナップショットに**機密情報**が含まれている場合、スナップショットにアクセスできる誰かがその情報を**窃取する**可能性があります（アクセスにはrootが必要である点に注意）。

スナップショットは通常次の場所に保存されます: **`/data/system_ce/0/snapshots`**

Androidは**FLAG_SECUREを設定することでスクリーンショットの取得を防ぐ**方法を提供します。  
このフラグを使用すると、ウィンドウの内容はセキュアとして扱われ、スクリーンショットや非セキュアなディスプレイで表示されることを防ぎます。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

このツールは、動的解析中に複数のツールを管理するのに役立ちます: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

開発者はしばしば、これらのIntentsを処理して `startActivity(...)` や `sendBroadcast(...)` のようなメソッドに渡す、activities、services、broadcast receivers のようなプロキシコンポーネントを作成しますが、これはリスクを伴います。

危険なのは、攻撃者がこれらのIntentsを誤誘導することで、non-exportedなアプリコンポーネントをトリガーしたり、機密性の高いcontent providersへアクセスさせたりできる点です。顕著な例として、`WebView` コンポーネントが `Intent.parseUri(...)` を介してURLを `Intent` オブジェクトに変換し、それを実行してしまうことで、悪意あるIntent注入を許してしまう可能性があります。

### Essential Takeaways

- **Intent Injection** はウェブの Open Redirect 問題に似ています。
- 悪用は `Intent` オブジェクトを extras として渡し、それがリダイレクトされて安全でない操作を実行させることを含みます。
- non-exported コンポーネントや content providers を攻撃者に露出させる可能性があります。
- `WebView` の URL → `Intent` 変換が意図しない動作を引き起こすことがあります。

### Android Client Side Injections and others

こういった種類の脆弱性はウェブで見聞きしていると思います。Android アプリケーションでは特に以下の脆弱性に注意する必要があります:

- **SQL Injection:** 動的クエリや Content-Providers を扱う場合は、パラメータ化されたクエリを使用していることを確認してください。
- **JavaScript Injection (XSS):** いかなる WebViews に対しても JavaScript と Plugin サポートが無効になっていることを確認してください（デフォルトでは無効）。[More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews はファイルシステムへのアクセスを無効にしておくべきです（デフォルトでは有効） - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies:** 多くの場合、Android アプリがセッションを終了しても cookie が取り消されない、あるいはディスクに保存されることがあります。
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**アプリケーションの脆弱性評価** を、見やすいウェブベースのフロントエンドで行えます。dynamic analysis も実行可能ですが（環境の準備が必要です）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** can also be very helpful for **dynamic analysis** in **Android**, but in that case you will need to install MobSF and **genymotion** in your host (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** can:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTPツール**

HTTPトラフィックがキャプチャされると、"**HTTP(S) Traffic**" ボタンで見づらいビューを、または "**Start HTTPTools**" の緑色のボタンでより見やすいビューを確認できます。後者のオプションから、キャプチャしたリクエストを Burp や Owasp ZAP のような **proxies** に **send** することができます。\
その手順は、_power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> 押下 "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

MobSF で dynamic analysis を終えたら、"**Start Web API Fuzzer**" を押して **fuzz http requests** を実行し、脆弱性を探すことができます。

> [!TIP]
> MobSF で dynamic analysis を実行した後、プロキシ設定が誤って構成され、GUI から修正できない場合があります。プロキシ設定は以下で修正できます:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckageによる支援付き動的解析

ツールは [**Inspeckage**](https://github.com/ac-pm/Inspeckage) から入手できます。\
このツールはいくつかの **Hooks** を使って、dynamic analysis を行っている間にアプリケーション内で **what is happening in the application** を通知してくれます。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

GUIで**static analysis**を行うための優れたツールです。

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

このツールは、**security related Android application vulnerabilities** を、**source code** または **packaged APKs** のいずれかで検出するよう設計されています。ツールはまた、発見された脆弱性（Exposed activities, intents, tapjacking...）の一部を悪用するための **"Proof-of-Concept" deployable APK** や **ADB commands** を生成することも可能です。Drozer と同様に、テストデバイスを root にする必要はありません。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 抽出されたすべてのファイルを表示し、参照を容易にします
- APKファイルを自動的にデコンパイルして、JavaとSmali形式で出力します
- AndroidManifest.xmlを解析して、一般的な脆弱性や挙動を検出します
- 静的ソースコード解析で一般的な脆弱性や挙動を検出します
- デバイス情報
- その他
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPERはWindows、MacOS X、Linuxで使用できるコマンドラインアプリケーションで、_.apk_ファイルを解析して脆弱性を探します。これはAPKを展開し、一連のルールを適用して脆弱性を検出することで行われます。

すべてのルールは`rules.json`ファイルにまとめられており、各企業やテスターは必要に応じて独自のルールを作成できます。

最新のバイナリは[download page](https://superanalyzer.rocks/download.html)からダウンロードしてください。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn はモバイルアプリケーションの [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) を行う開発者、bugbounty hunters、ethical hackers を支援する **crossplatform** ツールです。

使い方は、モバイルアプリのファイル（.apk または .ipa）を StaCoAn アプリにドラッグ＆ドロップすると、視覚的で持ち運び可能なレポートを生成する、というものです。設定や wordlists を調整してカスタマイズされた結果を得ることができます。

ダウンロード[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework は Android の脆弱性解析システムで、開発者やhackersが Android アプリケーションの潜在的なセキュリティ脆弱性を発見するのを支援します。\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** は、Android アプリケーションによって開発される潜在的な悪意ある振る舞いを検出し、ユーザーに警告することを主な目的としたツールです。

検出は、アプリケーションの Dalvik bytecode を **Smali** として表現したものに対する **static analysis** を、[`androguard`](https://github.com/androguard/androguard) ライブラリを用いて行います。

このツールは、**common behavior of "bad" applications** のような以下を探します: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. モバイルアプリケーションのリバースエンジニアリングと解析で一般的に使われるツールをまとめたツールで、OWASP の mobile セキュリティ脅威に対するモバイルアプリのテストを支援します。目的は、この作業をモバイルアプリ開発者やセキュリティ担当者にとってより簡単で扱いやすくすることです。

次のことができます:

- さまざまなツールを使用して Java と Smali のコードを抽出する
- APK を解析する（使用ツール: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)）
- 正規表現を使って APK からプライベート情報を抽出する
- Manifest を解析する
- 発見したドメインを解析する（使用ツール: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh), [whatweb](https://github.com/urbanadventurer/WhatWeb)）
- [apk-deguard.com] を介して APK の deobfuscate を行う

### Koodous

マルウェア検出に便利: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

使用するサービスや設定によっては、シークレットが難読化されたままになる場合とならない場合があります。

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.

ProGuard は Android SDK の一部として配布され、アプリを release モードでビルドするときに実行されます。

### [DexGuard](https://www.guardsquare.com/dexguard)

詳しい手順は次のガイドを参照してください: [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

（そのガイドによると）最後に確認した時点での Dexguard の動作モードは次の通りでした:

- リソースを InputStream として読み込む
- FilterInputStream を継承したクラスに結果を渡して復号する
- リバースエンジニアの時間を稼ぐための無意味な難読化を行う
- ZipInputStream に復号結果を渡して DEX ファイルを取り出す
- 最後に `loadDex` メソッドを使って得られた DEX を Resource としてロードする

### [DeGuard](http://apk-deguard.com)

**DeGuard は Android の難読化ツールによって行われた難読化のプロセスを逆にします。これにより、コードの検査やライブラリの推定など、さまざまなセキュリティ解析が可能になります。**

難読化された APK を彼らのプラットフォームにアップロードできます。

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

これは、android アプリの潜在的なセキュリティ脆弱性を見つけ、android アプリのコードを deobfuscate するための LLM ツールです。Google の Gemini public API を使用します。

### [Simplify](https://github.com/CalebFenton/simplify)

これは汎用の android deobfuscator です。Simplify はアプリを「仮想実行」して挙動を理解し、その後コードを最適化して人間が理解しやすく、かつ挙動は同一になるようにします。各最適化は単純で汎用的なので、使われている具体的な難読化の種類は問われません。

### [APKiD](https://github.com/rednaga/APKiD)

APKiD は APK がどのように作られたかについての情報を提供します。多くのコンパイラ、パッカー、オブフuscator、その他の変わったものを識別します。Android 向けの [_PEiD_](https://www.aldeid.com/wiki/PEiD) のようなものです。

### Manual

[このチュートリアルを読んで、カスタム難読化をリバースするためのいくつかのトリックを学んでください](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b は ubuntu-mate ベースの Android セキュリティ向け仮想マシンで、リバースエンジニアリングやマルウェア解析のための最新フレームワーク、チュートリアル、ラボを収集して含んでいます。

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) — 素晴らしいリソースの一覧です
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) — Android クイックコース
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
