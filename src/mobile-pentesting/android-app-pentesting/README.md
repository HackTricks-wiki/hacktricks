# Android एप्लिकेशन Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android एप्लिकेशन बेसिक्स

इस पृष्ठ को पढ़ना अत्यधिक अनुशंसित है ताकि आप **Android सुरक्षा से संबंधित सबसे महत्वपूर्ण भाग और किसी Android एप्लिकेशन में मौजूद सबसे खतरनाक कम्पोनेंट्स** के बारे में जान सकें:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

यह मुख्य टूल है जिसकी आपको किसी Android डिवाइस (emulated या physical) से कनेक्ट करने के लिए आवश्यकता होती है.\
**ADB** आपको कंप्यूटर से **USB** या **Network** के जरिए devices को नियंत्रित करने देता है। यह utility दोनों दिशाओं में फाइलों की **copying**, apps की **installation** और **uninstallation**, shell commands का **execution**, डेटा का **backing up**, लॉग्स का **reading**, और अन्य कार्यों की अनुमति देता है।

नीचे दी गई [**ADB Commands**](adb-commands.md) सूची देखें ताकि आप adb का उपयोग कैसे करना है सीख सकें।

## Smali

कभी-कभी **application code को modify करना** दिलचस्प होता है ताकि **hidden information** (शायद अच्छी तरह obfuscated passwords या flags) तक पहुँच सके। फिर, APK को decompile करके, कोड modify कर के और फिर उसे recompile करना उपयोगी हो सकता है.\
[**In this tutorial** आप सीख सकते हैं कि कैसे एक APK को decompile किया जाए, Smali code को modify किया जाए और नई functionality के साथ APK को recompile किया जाए](smali-changes.md). यह dynamic analysis के दौरान किए जाने वाले कई परीक्षणों के लिए एक **alternative** के रूप में बहुत उपयोगी हो सकता है। इसलिए, इस संभावना को हमेशा ध्यान में रखें।

## अन्य रोचक तरकीबें

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **APK डाउनलोड**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- डिवाइस से APK निकालें:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- सभी splits और base apks को [APKEditor](https://github.com/REAndroid/APKEditor) के साथ मर्ज करें:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## केस स्टडीज़ और कमजोरियाँ


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## स्थैतिक विश्लेषण

सबसे पहले, किसी APK का विश्लेषण करने के लिए आपको **decompiler का उपयोग करके Java code को देखना चाहिए**.\
कृपया, [**यहाँ पढ़ें ताकि उपलब्ध अलग-अलग decompilers के बारे में जानकारी मिल सके**](apk-decompilers.md).

### रोचक जानकारी की तलाश

APK की **strings** को देखकर आप **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** और अन्य रोचक चीज़ें ढूँढ सकते हैं... कोड execution के लिए बने हुए **backdoors** या authentication backdoors (app में हार्डकोडेड admin credentials) भी देखें।

**Firebase**

विशेष ध्यान दें **firebase URLs** पर और जांचें कि यह गलत कॉन्फ़िगर तो नहीं है। [Firebase क्या है और इसे कैसे exploit किया जा सकता है इसके बारे में अधिक जानकारी यहाँ है।](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### एप्लिकेशन की बुनियादी समझ - Manifest.xml, strings.xml

किसी एप्लिकेशन की _Manifest.xml_ और _strings.xml_ फ़ाइलों की **जांच संभावित सुरक्षा कमजोरियों का पता लगा सकती है**। इन फ़ाइलों तक decompiler का उपयोग करके या APK की file extension को .zip में बदलकर और फिर unzip करके पहुँचाया जा सकता है।

**Manifest.xml** से पहचानी गई कमजोरियाँ शामिल हैं:

- **Debuggable Applications**: Manifest.xml में debuggable (`debuggable="true"`) के रूप में सेट एप्लिकेशन जोखिम पैदा करते हैं क्योंकि वे ऐसे कनेक्शन अनुमति देते हैं जो exploitation का कारण बन सकते हैं। debuggable applications को device पर ढूँढने और exploit करने के तरीके के लिए संबंधित tutorial देखें।
- **Backup Settings**: संवेदनशील जानकारी संभालने वाले एप्लिकेशन के लिए `android:allowBackup="false"` attribute को स्पष्ट रूप से सेट किया जाना चाहिए ताकि adb के माध्यम से अनधिकृत data backups रोके जा सकें, खासकर जब usb debugging enabled हो।
- **Network Security**: _res/xml/_ में custom network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) certificate pins और HTTP traffic सेटिंग्स जैसी security details निर्दिष्ट कर सकती हैं। एक उदाहरण विशिष्ट डोमेन्स के लिए HTTP traffic की अनुमति देना है।
- **Exported Activities and Services**: Manifest में exported activities और services की पहचान ऐसे components को उजागर कर सकती है जिन्हें misuse किया जा सकता है। dynamic testing के दौरान और विश्लेषण यह दिखा सकता है कि इन components का exploit कैसे किया जा सकता है।
- **Content Providers and FileProviders**: खुले हुए content providers अनधिकृत access या data modification की अनुमति दे सकते हैं। FileProviders की configuration की भी सावधानीपूर्वक जाँच की जानी चाहिए।
- **Broadcast Receivers and URL Schemes**: ये components exploitation के लिए उपयोग किए जा सकते हैं, विशेष रूप से यह ध्यान देकर कि URL schemes input vulnerabilities के लिए कैसे संभाले जा रहे हैं।
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, और `maxSdkVersion` attributes supported Android versions को दर्शाते हैं, और सुरक्षा कारणों से outdated या vulnerable Android versions को support न करने का महत्व रेखांकित करते हैं।

_strings.xml_ फ़ाइल से, संवेदनशील जानकारी जैसे कि API keys, custom schemas, और अन्य developer notes मिल सकते हैं, जो इन resources की सावधानीपूर्वक समीक्षा की आवश्यकता को दर्शाता है।

### Tapjacking

**Tapjacking** एक attack है जिसमें एक **malicious** **application** लॉन्च की जाती है और **victim application के ऊपर अपने आप को रखती है**। जब यह victim app को दृश्य रूप से ढाँक देता है, तो इसका user interface इस तरह डिज़ाइन किया जाता है कि उपयोगकर्ता को इसका interaction करने के लिए धोखा दिया जा सके, जबकि यह interaction victim app को पास कर रहा होता है।\
प्रभाव रूप में, यह उपयोगकर्ता को अंधा कर देता है जिससे वे नहीं जान पाते कि वे वास्तव में victim app पर ही actions कर रहे हैं।

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

एक **activity** जिसकी **`launchMode`** **`singleTask`** पर सेट है और कोई `taskAffinity` परिभाषित नहीं है, वह task Hijacking के प्रति कमजोर होती है। इसका मतलब यह है कि एक **application** इंस्टॉल की जा सकती है और यदि वास्तव में application से पहले लॉन्च की जाती है तो यह वास्तविक application के task को **hijack** कर सकती है (इस तरह उपयोगकर्ता **malicious application से interact कर रहा होगा यह सोचते हुए कि वह वास्तविक app उपयोग कर रहा है**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### असुरक्षित डेटा स्टोरेज

Internal Storage

Android में, आंतरिक storage में **stored** फ़ाइलें उसी **app** द्वारा पहुँच योग्य होने के लिए **designed** होती हैं जिसने उन्हें बनाया था। यह security measure Android operating system द्वारा **enforced** किया जाता है और अधिकांश applications की security ज़रूरतों के लिए सामान्यतः पर्याप्त होता है। हालांकि, developers कभी-कभी `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` जैसे modes का उपयोग फ़ाइलों को विभिन्न applications के बीच **share** करने की अनुमति देने के लिए करते हैं। फिर भी, ये modes इन फ़ाइलों तक अन्य applications, जिनमें संभावित रूप से malicious apps भी शामिल हैं, द्वारा access को **restrict** नहीं करते।

1. **Static Analysis:**
- **सुनिश्चित करें** कि `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` के उपयोग की **सावधानीपूर्वक जाँच** की जाए। ये modes फ़ाइलों को **अनपेक्षित या अनधिकृत पहुँच** के लिए उजागर कर सकते हैं।
2. **Dynamic Analysis:**
- एप द्वारा बनाए गए फ़ाइलों पर सेट permissions की **पुष्टि करें**। विशेष रूप से जाँच करें कि क्या कोई फ़ाइलें **पूरी दुनिया के लिए readable या writable** सेट की गई हैं। यह गंभीर सुरक्षा जोखिम पैदा कर सकता है, क्योंकि इससे डिवाइस पर इंस्टॉल कोई भी application, उसकी उत्पत्ति या इरादे की परवाह किए बिना, इन फ़ाइलों को **read या modify** कर सकेगा।

External Storage

जब आप **external storage** (जैसे SD Cards) पर फ़ाइलों के साथ काम कर रहे हों, तो कुछ सावधानियाँ बरतनी चाहिए:

1. **Accessibility**:
- external storage पर फ़ाइलें **global रूप से readable और writable** होती हैं। इसका मतलब है कि कोई भी application या user इन फ़ाइलों तक पहुँचा सकता है।
2. **Security Concerns**:
- पहुँच की आसानी के कारण, external storage पर **sensitive information स्टोर न करने** की सलाह दी जाती है।
- external storage को हटाया जा सकता है या कोई भी application द्वारा access किया जा सकता है, जिससे यह कम सुरक्षित बन जाता है।
3. **Handling Data from External Storage**:
- external storage से प्राप्त data पर हमेशा **input validation करें**। यह महत्वपूर्ण है क्योंकि यह डेटा अनविश्वसनीय स्रोत से आता है।
- dynamic loading के लिए executables या class files को external storage पर स्टोर करना सख्त तौर पर निरुत्साहित किया जाता है।
- यदि आपका application external storage से executable files प्राप्त करना अनिवार्य है, तो सुनिश्चित करें कि ये फ़ाइलें dynamic load करने से पहले **signed और cryptographically verified** हों। यह चरण आपके application की security integrity बनाए रखने के लिए आवश्यक है।

External storage को `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` में **access** किया जा सकता है

> [!TIP]
> Android 4.4 (**API 17**) से शुरू होकर, SD card में ऐसा directory structure है जो **किसी app को केवल उसके लिए विशिष्ट directory तक ही access सीमित करता है**। इससे malicious application को किसी अन्य app की फ़ाइलों तक read या write access प्राप्त करने से रोका जाता है।

### Clear-text में स्टोर संवेदनशील डेटा

- **Shared preferences**: Android प्रत्येक application को आसानी से xml फाइलें पथ `/data/data/<packagename>/shared_prefs/` में save करने की अनुमति देता है और कभी-कभी उस फोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।
- **Databases**: Android प्रत्येक application को आसानी से sqlite databases पथ `/data/data/<packagename>/databases/` में save करने की अनुमति देता है और कभी-कभी उस फोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।

### Broken TLS

**Accept All Certificates**

कुछ कारणों से कभी-कभी developers सभी certificates को स्वीकार कर लेते हैं भले ही, उदाहरण के लिए, hostname मैच न करे, जैसा कि नीचे दिए गए code lines में दिखता है:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### खराब क्रिप्टोग्राफी

**खराब कुंजी प्रबंधन प्रक्रियाएँ**

कुछ developers संवेदनशील डाटा को local storage में सेव कर देते हैं और इसे कोड में hardcoded/पूर्वानुमेय key से encrypt कर देते हैं। ऐसा नहीं करना चाहिए क्योंकि कुछ reversing करने पर attackers confidential information extract कर सकते हैं।

**असुरक्षित और/या deprecated एल्गोरिदम का उपयोग**

Developers को authorisation **checks**, **store** या **send** करने के लिए **deprecated algorithms** का उपयोग नहीं करना चाहिए। इन एल्गोरिदम में से कुछ हैं: RC4, MD4, MD5, SHA1... यदि पासवर्ड स्टोर करने के लिए **hashes** का उपयोग किया जा रहा है, तो salt के साथ brute-force **resistant** hashes का उपयोग होना चाहिए।

### अन्य चेक

- It's recommended to **obfuscate the APK** to difficult the reverse engineer labour to attackers.
- यदि ऐप संवेदनशील है (जैसे bank apps), तो उसे अपने **स्वयं के चेक यह देखने के लिए कि मोबाइल rooted है** करने चाहिए और तदनुसार कार्य करना चाहिए।
- यदि ऐप संवेदनशील है (जैसे bank apps), तो उसे जांचना चाहिए कि किसी **emulator** का उपयोग तो नहीं हो रहा है।
- यदि ऐप संवेदनशील है (जैसे bank apps), तो उसे **execute करने से पहले अपनी integrity की जाँच** करनी चाहिए ताकि यह पता चल सके कि उसे modify किया गया है या नहीं।
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### अन्य दिलचस्प फ़ंक्शन

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## डायनामिक एनालिसिस

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Developers should be cautious of exposing **debugging information** publicly, as it can lead to sensitive data leaks. The tools [**pidcat**](https://github.com/JakeWharton/pidcat) and `adb logcat` are recommended for monitoring application logs to identify and protect sensitive information. **Pidcat** is favored for its ease of use and readability.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android's **clipboard-based** framework enables copy-paste functionality in apps, yet poses a risk as **other applications** can **access** the clipboard, potentially exposing sensitive data. It's crucial to **disable copy/paste** functions for sensitive sections of an application, like credit card details, to prevent data leaks.

**Crash Logs**

If an application **crashes** and **saves logs**, these logs can assist attackers, particularly when the application cannot be reverse-engineered. To mitigate this risk, avoid logging on crashes, and if logs must be transmitted over the network, ensure they are sent via an SSL channel for security.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications often integrate services like Google Adsense, which can inadvertently **leak sensitive data** due to improper implementation by developers. To identify potential data leaks, it's advisable to **intercept the application's traffic** and check for any sensitive information being sent to third-party services.

### SQLite DBs

Most of the applications will use **internal SQLite databases** to save information. During the pentest take a **look** to the **databases** created, the names of **tables** and **columns** and all the **data** saved because you could find **sensitive information** (which would be a vulnerability).\
Databases should be located in `/data/data/the.package.name/databases` like `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF किसी activity में `android:launchMode` के रूप में _**singleTask/singleInstance**_ के उपयोग को malicious के रूप में पहचानता है, लेकिन [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) के कारण, स्पष्ट रूप से यह केवल पुराने वर्शन (API versions < 21) पर ही खतरनाक है।

> [!TIP]
> ध्यान दें कि एक authorisation bypass हमेशा vulnerability नहीं होता, यह इस बात पर निर्भर करेगा कि bypass कैसे काम करता है और कौन सी जानकारी उजागर होती है।

**संवेदनशील जानकारी रिसाव**

**Activities भी परिणाम लौट सकती हैं।** यदि आप कोई exported और unprotected activity ढूँढते हैं जो **`setResult`** method को कॉल कर रही है और **संवेदनशील जानकारी return कर रही है**, तो यह संवेदनशील जानकारी का रिसाव है।

#### Tapjacking

यदि tapjacking रोका न गया हो, तो आप exported activity का दुरुपयोग करके **user को अप्रत्याशित क्रियाएँ करने के लिए मजबूर कर सकते हैं**। For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers मूलतः **data साझा करने** के लिए उपयोग किए जाते हैं। यदि किसी app में available content providers हैं तो आप उनसे **संवेदनशील डेटा निकाल** सकते हैं। इसके अलावा संभावित **SQL injections** और **Path Traversals** का परीक्षण करना भी दिलचस्प है क्योंकि वे vulnerable हो सकते हैं।

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
याद रखें कि Service की क्रियाएँ method `onStartCommand` में शुरू होती हैं।

Service मूलतः ऐसा component है जो **data प्राप्त कर सकता है**, उसे **process** करता है और (या नहीं) एक response **return** करता है। इसलिए, यदि कोई application कुछ services export कर रही है तो आपको यह समझने के लिए **code** की जाँच करनी चाहिए कि यह क्या कर रहा है और confidential info निकालने, authentication measures bypass करने... के लिए इसे **dynamically** **test** करना चाहिए।\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
याद रखें कि Broadcast Receiver की क्रियाएँ method `onReceive` में शुरू होती हैं।

एक broadcast receiver किसी प्रकार के message का इंतज़ार करेगा। यह इस बात पर निर्भर करता है कि receiver message को कैसे handle करता है — यह vulnerable हो सकता है।\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

आप deep links को मैन्युअली खोज सकते हैं, MobSF जैसे tools या scripts जैसे [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) का उपयोग करके।\
आप किसी घोषित **scheme** को **adb** या किसी **browser** की मदद से खोल सकते हैं:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_ध्यान दें कि आप **पैकेज नाम छोड़ सकते हैं** और मोबाइल स्वचालित रूप से उस ऐप को कॉल करेगा जो उस लिंक को खोलना चाहिए._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**निष्पादित कोड**

ऐप में **निष्पादित होने वाले कोड** को खोजने के लिए, उस activity में जाएँ जिसे deeplink कॉल करता है और फ़ंक्शन **`onNewIntent`** खोजें।

![](<../../images/image (436) (1) (1) (1).png>)

**सेंसिटिव जानकारी**

हर बार जब आप कोई deep link पाते हैं तो जाँचें कि **यह URL पैरामीटर्स के माध्यम से sensitive data (जैसे passwords) प्राप्त तो नहीं कर रहा है**, क्योंकि कोई भी अन्य application उस deep link की नक़ल कर सकता है और वह data चुरा सकता है!

**पाथ में पैरामीटर्स**

आपको यह भी जांचना **ज़रूरी** है कि क्या कोई deep link URL के path के अंदर parameter का उपयोग कर रहा है, जैसे: `https://api.example.com/v1/users/{username}` , ऐसे मामले में आप path traversal जबरदस्ती कर सकते हैं जैसे: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
ध्यान दें कि यदि आप application के अंदर सही endpoints पाते हैं तो आप **Open Redirect** (यदि path का हिस्सा domain नाम के तौर पर उपयोग हो रहा हो), **account takeover** (यदि आप users के डिटेल्स को CSRF token के बिना बदल सकते हैं और vuln endpoint ने सही method का उपयोग किया हो) और अन्य किसी भी vuln का कारण बन सकते हैं। अधिक जानकारी के लिए [**यहाँ जानकारी**](http://dphoeniixx.com/2020/12/13-2/) देखें।

**और उदाहरण**

एक [दिलचस्प bug bounty रिपोर्ट](https://hackerone.com/reports/855618) links के बारे में (_/.well-known/assetlinks.json_)।

### Transport Layer Inspection and Verification Failures

- **सर्टिफिकेट्स हमेशा ठीक से जाँच नहीं किए जाते** Android applications द्वारा। अक्सर ये ऐप्स warnings को अनदेखा कर देते हैं और self-signed certificates स्वीकार कर लेते हैं या कुछ मामलों में HTTP connections पर लौट आते हैं।
- **SSL/TLS handshake के दौरान negotiations कभी-कभी कमजोर होती हैं**, और insecure cipher suites का उपयोग किया जाता है। यह कमजोरी connection को man-in-the-middle (MITM) हमलों के प्रति संवेदनशील बनाती है, जिससे attackers डेटा डिक्रिप्ट कर सकते हैं।
- **Leakage of private information** एक जोखिम है जब applications secure channels का उपयोग करके authenticate करती हैं पर अन्य transactions के लिए non-secure channels पर communicate करती हैं। यह तरीका sensitive data, जैसे session cookies या user details, को malicious entities द्वारा interception से सुरक्षित रखने में विफल रहता है।

#### Certificate Verification

हम **certificate verification** पर ध्यान देंगे। सर्वर के सर्टिफिकेट की integrity को सत्यापित करना सुरक्षा बढ़ाने के लिए आवश्यक है। यह महत्वपूर्ण है क्योंकि असुरक्षित TLS कॉन्फ़िगरेशन और अनएन्क्रिप्टेड चैनलों पर sensitive डेटा का ट्रांसमिशन गंभीर जोखिम पैदा कर सकता है। सर्वर सर्टिफिकेट्स को सत्यापित करने और कमजोरियों को संबोधित करने के विस्तृत चरणों के लिए, [**यह resource**](https://manifestsecurity.com/android-application-security-part-10/) समग्र मार्गदर्शन प्रदान करता है।

#### SSL Pinning

SSL Pinning एक सुरक्षा उपाय है जहाँ एप्लिकेशन सर्वर के सर्टिफिकेट की तुलना एप्लिकेशन के अंदर संग्रहित ज्ञात कॉपी से करता है। यह तरीका MITM हमलों को रोकने के लिए आवश्यक है। संवेदनशील जानकारी संभालने वाली एप्लिकेशन के लिए SSL Pinning लागू करने की सलाह दी जाती है।

#### Traffic Inspection

HTTP ट्रैफ़िक का निरीक्षण करने के लिए, प्रॉक्सी टूल का सर्टिफिकेट इंस्टॉल करना आवश्यक है (उदाहरण: Burp)। यह सर्टिफिकेट इंस्टॉल किए बिना, एन्क्रिप्टेड ट्रैफ़िक प्रॉक्सी के माध्यम से दिखाई नहीं दे सकता। कस्टम CA सर्टिफिकेट इंस्टॉल करने के निर्देशों के लिए, [**यहाँ क्लिक करें**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)।

जो applications **API Level 24 and above** को target करती हैं उन्हें प्रॉक्सी के CA सर्टिफिकेट को स्वीकार करने के लिए Network Security Config में संशोधन करने की आवश्यकता होती है। एन्क्रिप्टेड ट्रैफ़िक का निरीक्षण करने के लिए यह कदम महत्वपूर्ण है। Network Security Config में संशोधन करने के निर्देशों के लिए, [**इस ट्यूटोरियल**](make-apk-accept-ca-certificate.md) को देखें।

यदि **Flutter** उपयोग में है तो आपको [**इस पेज**](flutter.md) के निर्देशों का पालन करना होगा। ऐसा इसलिए है क्योंकि केवल certificate को store में जोड़ने से काम नहीं चलेगा क्योंकि Flutter के पास अपने वैध CAs की सूची होती है।

#### Static detection of SSL/TLS pinning

Runtime bypasses का प्रयास करने से पहले, तेज़ी से मैप करें कि APK में कहाँ pinning लागू किया गया है। Static discovery आपको hooks/patches की योजना बनाने और सही code paths पर ध्यान केंद्रित करने में मदद करती है।

Tool: SSLPinDetect
- Open-source static-analysis utility जो APK को Smali (apktool के माध्यम से) में decompile करके SSL/TLS pinning implementations के curated regex patterns के लिए स्कैन करता है।
- प्रत्येक मैच के लिए सटीक file path, line number, और कोड स्निपेट रिपोर्ट करता है।
- सामान्य frameworks और custom code paths को कवर करता है: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, और Network Security Config XML pins।

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
उपयोग
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
उदाहरण पैटर्न नियम (JSON)

signatures का उपयोग या विस्तार करें ताकि proprietary/custom pinning styles का पता चल सके। आप अपना JSON लोड कर सकते हैं और बड़े पैमाने पर scan कर सकते हैं।
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- बड़े ऐप्स पर तेज़ स्कैनिंग के लिए multi-threading और memory-mapped I/O का उपयोग करें; pre-compiled regex overhead/false positives कम करता है।
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- अगली प्राथमिकता में triage करने के लिए सामान्य detection targets:
- OkHttp: CertificatePinner उपयोग, setCertificatePinner, okhttp3/okhttp package रेफरेंस
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config और manifest रेफरेंस
- मैच हुई लोकेशनों का उपयोग Frida hooks, static patches, या config reviews की योजना बनाने के लिए करें, dynamic testing से पहले।



#### SSL Pinning को बायपास करना

जब SSL Pinning लागू किया गया हो, तो HTTPS ट्रैफ़िक का निरीक्षण करने के लिए इसे बायपास करना आवश्यक हो जाता है। इस उद्देश्य के लिए विभिन्न तरीके उपलब्ध हैं:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). इस विकल्प का मुख्य फ़ायदा यह है कि आपको SSL Pinning बायपास करने के लिए root की आवश्यकता नहीं होगी, लेकिन आपको एप्लिकेशन को डिलीट करके नया इंस्टॉल करना पड़ेगा, और यह हमेशा काम नहीं करेगा।
- आप इस सुरक्षा को बायपास करने के लिए **Frida** (नीचे चर्चा की गई) का उपयोग कर सकते हैं। यहाँ Burp+Frida+Genymotion का उपयोग करने का एक गाइड है: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- आप [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"` का उपयोग करके SSL Pinning को **automatically bypass** करने की भी कोशिश कर सकते हैं।
- आप **MobSF dynamic analysis** (नीचे समझाया गया) का उपयोग करके भी SSL Pinning को **automatically bypass** करने की कोशिश कर सकते हैं।
- अगर आपको अभी भी लगता है कि कुछ ट्रैफ़िक कैप्चर नहीं हो रहा है तो आप ट्रैफ़िक को burp पर forward करने के लिए **iptables** का उपयोग कर सकते हैं। इस ब्लॉग को पढ़ें: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### आम Web कमजोरियों की तलाश

ऐप्लिकेशन के भीतर सामान्य वेब कमजोरियों की भी खोज करना महत्वपूर्ण है। इन कमजोरियों की पहचान और निवारण के विस्तृत विवरण इस सारांश के दायरे से बाहर हैं लेकिन कहीं और विस्तार से कवर किए गए हैं।

### Frida

[Frida](https://www.frida.re) developers, reverse-engineers, और security researchers के लिए एक dynamic instrumentation toolkit है.\
**आप running application तक पहुँच कर run time पर methods को hook करके व्यवहार बदल सकते हैं, मान बदल सकते हैं, वैल्यूज़ extract कर सकते हैं, अलग कोड चला सकते हैं...**\
अगर आप Android applications का pentest करना चाहते हैं तो आपको Frida का उपयोग करना आना चाहिए।

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Frida के साथ क्रियाओं के लिए कुछ "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection Frida के उपयोग को automate करने के लिए बढ़िया है: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- कुछ Awesome Frida scripts यहाँ मिलेंगी: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- anti-debugging / anti-frida mechanisms को bypass करने की कोशिश करें जैसे कि Frida को load करना बताया गया है: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

जाँचें कि क्या application memory के अंदर संवेदनशील जानकारी स्टोर कर रहा है जो उसे नहीं रखना चाहिए, जैसे कि passwords या mnemonics।

Using [**Fridump3**](https://github.com/rootbsd/fridump3) आप ऐप की memory को dump कर सकते हैं:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
यह ./dump फ़ोल्डर में मेमोरी dump कर देगा, और वहाँ आप कुछ इस तरह grep कर सकते हैं:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore में संवेदनशील डेटा**

Android में Keystore संवेदनशील डेटा संग्रहीत करने के लिए सबसे अच्छा स्थान है, हालांकि पर्याप्त अनुमतियाँ होने पर इसे फिर भी **उस तक पहुँच संभव है**।

क्योंकि ऐप्लिकेशन अक्सर यहाँ **साफ़ टेक्स्ट में संवेदनशील डेटा** स्टोर करते हैं, इसलिए pentests को इसे root user के रूप में जांचना चाहिए वरना डिवाइस तक भौतिक पहुँच रखने वाला कोई व्यक्ति यह डेटा चुरा सकता है।

भले ही किसी ऐप ने keystore में data स्टोर किया हो, वह डेटा encrypted होना चाहिए।

To access the data inside the keystore you could use this Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

निम्नलिखित Frida script का उपयोग करके यह संभव हो सकता है कि Android applications द्वारा किए जा रहे **bypass fingerprint authentication** को **कुछ संवेदनशील क्षेत्रों की रक्षा करने के लिए:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **बैकग्राउंड इमेजेस**

जब आप किसी application को background में डालते हैं, Android एप्लिकेशन का एक **एप्लिकेशन का स्नैपशॉट** स्टोर कर लेता है ताकि जब उसे foreground में वापस लाया जाए तो ऐप के पहले इमेज को लोड कर दिया जाए और ऐसा लगे कि ऐप तेज़ी से लोड हुआ।

हालाँकि, यदि यह स्नैपशॉट किसी में **संवेदनशील जानकारी** होती है, तो स्नैपशॉट तक पहुँच रखने वाला कोई भी व्यक्ति उस जानकारी को **चुरा सकता है** (ध्यान दें कि इसे एक्सेस करने के लिए आपको root की आवश्यकता होती है)।

Snapshots आम तौर पर यहाँ स्टोर होते हैं: **`/data/system_ce/0/snapshots`**

Android एक तरीका प्रदान करता है जिससे आप **FLAG_SECURE सेट करके स्क्रीनशॉट कैप्चर रोक सकते हैं** layout parameter. इस flag का उपयोग करने पर window contents को secure माना जाता है, जिससे वे स्क्रीनशॉट्स में दिखाई देने या non-secure displays पर देखे जाने से रोके जाते हैं।
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

यह टूल डायनामिक विश्लेषण के दौरान विभिन्न टूल्स को प्रबंधित करने में मदद कर सकता है: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

डिवेलपर्स अक्सर proxy components जैसे activities, services, और broadcast receivers बनाते हैं जो इन Intents को हैंडल करते हैं और इन्हें `startActivity(...)` या `sendBroadcast(...)` जैसे methods को पास कर देते हैं, जो जोखिम भरा हो सकता है।

खतरा इस बात में है कि attackers को इन Intents को गलत दिशा में भेजकर non-exported app components trigger करने या sensitive content providers तक पहुंचने की अनुमति मिल सकती है। एक प्रमुख उदाहरण `WebView` component है जो URLs को `Intent` objects में `Intent.parseUri(...)` के माध्यम से बदल देता है और फिर उन्हें execute करता है, जिससे malicious Intent injections हो सकते हैं।

### आवश्यक निष्कर्ष

- **Intent Injection** वेब के Open Redirect issue के समान है।
- Exploits में `Intent` objects को extras के रूप में पास करना शामिल है, जिन्हें redirect करके unsafe operations execute कराने के लिए उपयोग किया जा सकता है।
- यह non-exported components और content providers को attackers के लिए expose कर सकता है।
- `WebView` की URL से `Intent` में conversion अनचाहे actions को संभव बना सकती है।

### Android Client Side Injections and others

संभवतः आप वेब से इस तरह की vulnerabilities के बारे में जानते होंगे। Android application में इन vulnerabilities के साथ खास सावधानी बरतनी चाहिए:

- **SQL Injection:** जब dynamic queries या Content-Providers के साथ काम कर रहे हों तो सुनिश्चित करें कि आप parameterized queries का उपयोग कर रहे हैं।
- **JavaScript Injection (XSS):** किसी भी WebViews के लिए JavaScript और Plugin support disabled है यह सत्यापित करें (डिफ़ॉल्ट रूप से disabled)। [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews का file system access disabled होना चाहिए (डिफ़ॉल्ट रूप से enabled) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: कई मामलों में जब the android application session समाप्त होती है तो cookie revoke नहीं होती या यह disk पर भी saved हो सकती है
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## स्वचालित विश्लेषण

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** वेब-आधारित सुंदर frontend का उपयोग करके। आप dynamic analysis भी कर सकते हैं (पर आपको environment तैयार करना होगा)।
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

MobSF Android में dynamic analysis के लिए भी काफी मददगार हो सकता है, लेकिन उस केस में आपको अपने host पर MobSF और genymotion install करना होगा (VM या Docker काम नहीं करेंगे). _नोट: आपको **पहले genymotion में एक VM start करना होगा** और **फिर MobSF.**_\  
The **MobSF dynamic analyser** कर सकता है:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). ये सब अपने आप किया जाता है सिवाय screenshots के — स्क्रीनशॉट लेने के लिए आपको मैन्युअली बटन दबाना होगा या सभी exported activities के स्क्रीनशॉट पाने के लिए आपको "**Exported Activity Tester**" दबाना होगा।
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: यह सभी loaded classes को print करेगा
- **Capture Strings**: यह application के उपयोग के दौरान सभी captured strings को print करेगा (बहुत noisy)
- **Capture String Comparisons**: बहुत उपयोगी हो सकता है। यह **दिखाएगा कि किन 2 strings की तुलना की जा रही है** और परिणाम True या False था या नहीं।
- **Enumerate Class Methods**: class नाम डालें (जैसे "java.io.File") और यह class के सभी methods को print करेगा।
- **Search Class Pattern**: pattern से classes खोजें
- **Trace Class Methods**: किसी पूरे class को **Trace** करें (class के सभी methods के inputs और outputs देखें). याद रखें कि default में MobSF कई दिलचस्प Android Api methods को trace करता है।

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

MobSF आपको dynamic analysis पेज के निचले हिस्से में कुछ **adb** commands, **MobSF commands**, और सामान्य **shell** **commands** के साथ एक shell भी देता है. कुछ दिलचस्प commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP टूल्स**

जब HTTP ट्रैफ़िक कैप्चर होता है, तो आप कैप्चर किए गए ट्रैफ़िक को "**HTTP(S) Traffic**" बटन पर एक खराब व्यू में देख सकते हैं या "**Start HTTPTools**" हरे बटन पर एक बेहतर व्यू में देख सकते हैं। दूसरे विकल्प से, आप **captured requests** को Burp या Owasp ZAP जैसे **proxies** पर **send** कर सकते हैं.\
ऐसा करने के लिए, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF के साथ dynamic analysis समाप्त करने के बाद आप "**Start Web API Fuzzer**" दबाकर **fuzz http requests** कर सकते हैं और vulnerabilities की तलाश कर सकते हैं।

> [!TIP]
> MobSF के साथ dynamic analysis करने के बाद proxy settings misconfigured हो सकती हैं और आप इन्हें GUI से ठीक नहीं कर पाएंगे। आप proxy settings को ठीक करने के लिए यह कमांड चला सकते हैं:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

आप टूल [**Inspeckage**](https://github.com/ac-pm/Inspeckage) से प्राप्त कर सकते हैं.\
यह टूल कुछ **Hooks** का उपयोग करता है ताकि जब आप **dynamic analysis** कर रहे हों तो यह आपको एप्लिकेशन में क्या हो रहा है बताने में मदद करे।

### [Yaazhini](https://www.vegabird.com/yaazhini/)

यह **GUI के साथ static analysis करने के लिए एक शानदार टूल** है

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

यह टूल कई प्रकार की **security related Android application vulnerabilities** खोजने के लिए डिज़ाइन किया गया है, चाहे वे **source code** में हों या **packaged APKs** में। यह टूल **capable of creating a "Proof-of-Concept" deployable APK** और **ADB commands** भी बना सकता है, ताकि कुछ मिली हुई vulnerabilities (Exposed activities, intents, tapjacking...) का exploit किया जा सके। Drozer की तरह, टेस्ट डिवाइस को root करने की आवश्यकता नहीं है।
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- संदर्भ के लिए सभी निकाली गई फ़ाइलें दिखाता है
- APK files को स्वचालित रूप से Java और Smali फॉर्मेट में decompile करता है
- AndroidManifest.xml को सामान्य कमजोरियों और व्यवहार के लिए विश्लेषण करता है
- सामान्य कमजोरियों और व्यवहार के लिए स्थैतिक स्रोत कोड विश्लेषण
- डिवाइस जानकारी
- और भी बहुत कुछ
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER एक command-line application है जिसे Windows, MacOS X और Linux पर उपयोग किया जा सकता है, जो _.apk_ फ़ाइलों का विश्लेषण करके vulnerabilities की तलाश करता है। यह APKs को डीकंप्रेस करके और उन vulnerabilities का पता लगाने के लिए नियमों की एक श्रृंखला लागू करके ऐसा करता है।

सभी नियम `rules.json` फ़ाइल में केंद्रित हैं, और प्रत्येक कंपनी या टेस्टर अपनी ज़रूरत के अनुसार विश्लेषण करने के लिए अपने नियम बना सकते हैं।

नवीनतम बाइनरी [download page](https://superanalyzer.rocks/download.html) से डाउनलोड करें
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn एक **crossplatform** टूल है जो डेवलपर्स, bugbounty hunters और ethical hackers को मोबाइल एप्लिकेशनों पर [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) करने में मदद करता है।

विचार यह है कि आप अपनी मोबाइल एप्लिकेशन फ़ाइल (.apk या .ipa फ़ाइल) को StaCoAn एप्लिकेशन पर ड्रैग और ड्रॉप करें और यह आपके लिए एक visual और portable रिपोर्ट जेनरेट करेगा। आप settings और wordlists को समायोजित करके एक customized अनुभव प्राप्त कर सकते हैं।

डाउनलोड[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework एक Android vulnerability analysis सिस्टम है जो developers या hackers को Android applications में संभावित security vulnerabilities खोजने में मदद करता है।\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** एक टूल है जिसका मुख्य उद्देश्य Android application द्वारा विकसित संभावित malicious व्यवहारों का पता लगाना और उपयोगकर्ता को चेतावनी देना है।

डिटेक्शन application के Dalvik bytecode, जो कि **Smali** के रूप में प्रतिनिधित्व किया गया है, की **static analysis** के माध्यम से [`androguard`](https://github.com/androguard/androguard) लाइब्रेरी के साथ किया जाता है।

यह टूल **common behavior of "bad" applications** जैसी चीज़ों की तलाश करता है, जैसे: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. यह एक ऐसा टूल है जो commonly used mobile application reverse engineering और analysis tools को एक साथ जोड़ता है, ताकि OWASP mobile security threats के खिलाफ mobile applications का परीक्षण करने में मदद मिल सके। इसका उद्देश्य mobile application developers और security professionals के लिए इस कार्य को आसान और अधिक उपयोगकर्ता के अनुकूल बनाना है।

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Useful to detect malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

ध्यान दें कि जिस service और configuration का आप उपयोग करते हैं कोड obfuscate करने के लिए, उसके आधार पर Secrets obfuscated हो सकते हैं या नहीं भी। 

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. यह bytecode को optimize करने के साथ-साथ unused instructions का पता लगाकर उन्हें हटा भी सकता है। ProGuard free software है और GNU General Public License, version 2 के अंतर्गत वितरित होता है।

ProGuard Android SDK के हिस्से के रूप में वितरित होता है और release mode में application build करते समय चलता है।

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

DeGuard उन Android obfuscation tools द्वारा किए गए obfuscation प्रक्रिया को reverse करता है। यह कई security analyses को सक्षम बनाता है, जिनमें code inspection और libraries का अनुमान लगाना शामिल है। आप एक obfuscated APK को उनके platform पर upload कर सकते हैं।

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify practically ऐप को virtually execute करके उसके व्यवहार को समझता है और फिर code को optimize करने की कोशिश करता है ताकि इसका व्यवहार बिल्कुल वही रहे पर इंसान के लिए समझना आसान हो। हर optimization type सरल और generic है, इसलिए यह मायने नहीं रखता कि किस specific type की obfuscation इस्तेमाल की गई थी।

### [APKiD](https://github.com/rednaga/APKiD)

APKiD आपको जानकारी देता है कि किसी APK को कैसे बनाया गया था। यह कई compilers, packers, obfuscators, और अन्य अजीब चीज़ों की पहचान करता है। यह Android के लिए [_PEiD_](https://www.aldeid.com/wiki/PEiD) जैसा है।

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b एक Android security virtual machine है जो ubuntu-mate पर आधारित है और इसमें latest framework, tutorials और labs का संग्रह शामिल है, जो विभिन्न security geeks और researchers द्वारा reverse engineering और malware analysis के लिए प्रदान किए गए हैं।

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) यह resources की एक शानदार सूची है
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
