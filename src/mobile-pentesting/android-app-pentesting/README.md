# Applicazioni Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Fondamenti delle Applicazioni Android

È fortemente consigliato iniziare leggendo questa pagina per conoscere le **parti più importanti relative alla sicurezza Android e i componenti più pericolosi in un'applicazione Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Questo è lo strumento principale necessario per connettersi a un dispositivo Android (emulato o fisico).\
**ADB** permette di controllare dispositivi sia tramite **USB** che tramite **Network** da un computer. Questa utility consente la **copia** di file in entrambe le direzioni, l'**installazione** e la **disinstallazione** di app, l'**esecuzione** di comandi shell, il **backup** dei dati, la **lettura** dei log, tra le altre funzioni.

Dai un'occhiata alla seguente lista di [**ADB Commands**](adb-commands.md) per imparare come usare adb.

## Smali

A volte è utile **modificare il codice dell'applicazione** per accedere a **informazioni nascoste** (ad esempio password fortemente offuscate o flag). In tal caso, può essere interessante decompilare l'apk, modificare il codice e ricompilarlo.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Questo può essere molto utile come **alternativa per diversi test durante l'analisi dinamica** che verranno presentati. Quindi, **tieni sempre presente questa possibilità**.

## Altri trucchi interessanti

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (accesso privilegiato non-root basato su ADB)](shizuku-privileged-api.md)
- [Sfruttare meccanismi di In-App Update insicuri](insecure-in-app-update-rce.md)
- [Abuso di Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (abuso Android Tap-to-Pay)](android-hce-nfc-emv-relay-attacks.md)
- **Scarica APK**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Estrai APK dal dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Unisci tutti gli split e gli APK base con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Casi di studio e vulnerabilità


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

Prima di tutto, per analizzare un APK dovresti **dare un'occhiata al codice Java** usando un decompiler.\
Per favore, [**leggi qui per trovare informazioni sui diversi decompilatori disponibili**](apk-decompilers.md).

### Ricerca di informazioni interessanti

Bastando osservare le **strings** dell'APK puoi cercare **password**, **URL** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API keys**, **crittografia**, **bluetooth uuids**, **tokens** e qualsiasi cosa interessante... cerca anche eventuali **backdoors** per esecuzione di codice o backdoor di autenticazione (credenziali admin hardcoded nell'app).

**Firebase**

Presta particolare attenzione alle **Firebase URLs** e verifica se è mal configurato. [Ulteriori informazioni su cos'è Firebase e come sfruttarlo qui.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Nozioni di base sull'applicazione - Manifest.xml, strings.xml

L'**esame dei file _Manifest.xml_ e _strings.xml_ di un'applicazione può rivelare potenziali vulnerabilità di sicurezza**. Questi file possono essere accessi tramite decompiler o rinominando l'estensione del file APK in .zip e poi estraendolo.

Le **vulnerabilità** identificate dal **Manifest.xml** includono:

- **Debuggable Applications**: Le applicazioni impostate come debuggable (`debuggable="true"`) nel file _Manifest.xml_ rappresentano un rischio perché consentono connessioni che possono portare a sfruttamento. Per capire meglio come sfruttare applicazioni debuggable, consulta un tutorial su come trovare e sfruttare applicazioni debuggable su un dispositivo.
- **Backup Settings**: L'attributo `android:allowBackup="false"` dovrebbe essere impostato esplicitamente per le applicazioni che gestiscono informazioni sensibili per prevenire backup non autorizzati dei dati tramite adb, specialmente quando usb debugging è abilitato.
- **Network Security**: Le configurazioni personalizzate di network security (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ possono specificare dettagli di sicurezza come certificate pins e impostazioni per il traffico HTTP. Un esempio è permettere traffico HTTP per domini specifici.
- **Exported Activities and Services**: Identificare attività e servizi esportati nel manifest può evidenziare componenti che potrebbero essere abusati. Un'analisi più approfondita durante i test dinamici può rivelare come sfruttare questi componenti.
- **Content Providers and FileProviders**: Content provider esposti potrebbero permettere accesso o modifica non autorizzata dei dati. Anche la configurazione dei FileProviders va esaminata attentamente.
- **Broadcast Receivers and URL Schemes**: Questi componenti potrebbero essere sfruttati per attacchi, prestando particolare attenzione a come gli URL schemes gestiscono l'input.
- **SDK Versions**: Gli attributi `minSdkVersion`, `targetSDKVersion`, e `maxSdkVersion` indicano le versioni Android supportate, sottolineando l'importanza di non supportare versioni Android obsolete e vulnerabili per ragioni di sicurezza.

Dal file **strings.xml** si possono scoprire informazioni sensibili come API keys, schemi custom e altre note degli sviluppatori, il che sottolinea la necessità di una revisione accurata di queste risorse.

### Tapjacking

**Tapjacking** è un attacco in cui una **malicious** **application** viene lanciata e **si posiziona sopra un'applicazione vittima**. Una volta che oscura visivamente l'app vittima, la sua interfaccia utente è progettata in modo da ingannare l'utente facendogli interagire con essa, mentre l'interazione viene passata all'app vittima.\
Di fatto, sta **accecando l'utente facendogli ignorare che in realtà sta eseguendo azioni sull'app vittima**.

Trova più informazioni in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Un'**activity** con il **`launchMode`** impostato su **`singleTask` senza alcun `taskAffinity`** definito è vulnerabile al task Hijacking. Questo significa che un'**application** può essere installata e se lanciata prima della reale applicazione potrebbe **hijackare il task della vera applicazione** (così l'utente interagirà con la **malicious application pensando di usare quella reale**).

Maggiori info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Archiviazione dati insicura

**Internal Storage**

In Android, i file **memorizzati** nella **internal** storage sono **progettati** per essere accessibili esclusivamente dall'**app** che li ha **creati**. Questa misura di sicurezza è **imposta** dal sistema operativo Android ed è generalmente adeguata per le esigenze di sicurezza della maggior parte delle applicazioni. Tuttavia, gli sviluppatori a volte utilizzano modalità come `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` per **permettere** che file siano **condivisi** fra diverse applicazioni. Queste modalità **non limitano l'accesso** a questi file da altre applicazioni, incluse quelle potenzialmente malevoli.

1. **Static Analysis:**
- **Verifica** che l'uso di `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` sia **scrutinato con attenzione**. Queste modalità **possono potenzialmente esporre** file ad **accessi non intenzionati o non autorizzati**.
2. **Dynamic Analysis:**
- **Controlla** i **permessi** impostati sui file creati dall'app. In particolare, **verifica** se alcuni file sono **impostati come leggibili o scrivibili a livello mondiale**. Questo può rappresentare un rischio significativo per la sicurezza, poiché permetterebbe a **qualsiasi applicazione** installata sul dispositivo, indipendentemente dall'origine o dall'intento, di **leggere o modificare** tali file.

**External Storage**

Quando si lavora con file su **external storage**, come le SD Card, dovrebbero essere prese alcune precauzioni:

1. **Accessibilità**:
- I file su external storage sono **globalmente leggibili e scrivibili**. Questo significa che qualsiasi applicazione o utente può accedere a questi file.
2. **Problemi di sicurezza**:
- Data la facilità di accesso, è consigliato **non memorizzare informazioni sensibili** su external storage.
- L'external storage può essere rimosso o accessibile da qualsiasi applicazione, rendendolo meno sicuro.
3. **Gestione dei dati provenienti da External Storage**:
- Esegui sempre **validazione degli input** sui dati recuperati dall'external storage. Questo è fondamentale perché i dati provengono da una fonte non attendibile.
- È fortemente sconsigliato memorizzare eseguibili o file di class su external storage per il caricamento dinamico.
- Se la tua applicazione deve recuperare file eseguibili dall'external storage, assicurati che questi file siano **firmati e verificati crittograficamente** prima di essere caricati dinamicamente. Questo passaggio è vitale per mantenere l'integrità di sicurezza della tua applicazione.

L'external storage può essere **accessed** in /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> A partire da Android 4.4 (**API 17**), la SD card ha una struttura di directory che **limita l'accesso da un'app alla directory specifica per quell'app**. Questo impedisce a applicazioni malevoli di ottenere accesso in lettura o scrittura ai file di un'altra app.

**Dati sensibili memorizzati in chiaro**

- **Shared preferences**: Android permette a ogni applicazione di salvare facilmente file xml nel percorso `/data/data/<packagename>/shared_prefs/` e a volte è possibile trovare informazioni sensibili in chiaro in quella cartella.
- **Databases**: Android permette a ogni applicazione di salvare facilmente database sqlite nel percorso `/data/data/<packagename>/databases/` e a volte è possibile trovare informazioni sensibili in chiaro in quella cartella.

### Broken TLS

**Accept All Certificates**

Per qualche motivo a volte gli sviluppatori accettano tutti i certificati anche se, per esempio, l'hostname non corrisponde, con righe di codice come la seguente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Un buon modo per testare questo è provare a catturare il traffico usando un proxy come Burp senza autorizzare Burp CA sul dispositivo. Inoltre, puoi generare con Burp un certificato per un hostname diverso e usarlo.

### Crittografia debole

**Processi di gestione delle chiavi inadeguati**

Alcuni sviluppatori salvano dati sensibili nello storage locale e li cifrano con una chiave hardcoded/predicibile nel codice. Questo non dovrebbe essere fatto perché del reversing potrebbe permettere agli attaccanti di estrarre le informazioni riservate.

**Uso di algoritmi insicuri e/o deprecati**

Gli sviluppatori non dovrebbero usare **algoritmi deprecati** per eseguire controlli di **autorizzazione**, **memorizzare** o **inviare** dati. Alcuni di questi algoritmi sono: RC4, MD4, MD5, SHA1... Se vengono usati **hash** per memorizzare password per esempio, dovrebbero essere usati algoritmi **resistenti** al brute-force con salt.

### Altri controlli

- Si raccomanda di **offuscare l'APK** per rendere più difficile il lavoro di reverse engineering agli attaccanti.
- Se l'app è sensibile (come bank apps), dovrebbe eseguire i propri controlli per verificare se il mobile è **rooted** e agire di conseguenza.
- Se l'app è sensibile (come bank apps), dovrebbe verificare se è in uso un **emulator**.
- Se l'app è sensibile (come bank apps), dovrebbe **controllare la propria integrità prima di eseguirla** per verificare se è stata modificata.
- Usa [**APKiD**](https://github.com/rednaga/APKiD) per verificare quale compiler/packer/obfuscator è stato usato per costruire l'APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

Lo strumento [**mariana-trench**](https://github.com/facebook/mariana-trench) è in grado di trovare **vulnerabilities** scansionando il **code** dell'applicazione. Questo tool contiene una serie di **known sources** (che indicano al tool i **posti** dove l'**input** è **controllato dall'utente**), **sinks** (che indicano i **posti pericolosi** dove un input malevolo dell'utente potrebbe causare danni) e **rules**. Queste regole indicano la **combinazione** di **sources-sinks** che segnala una vulnerability.

Con queste informazioni, **mariana-trench esaminerà il codice e troverà possibili vulnerabilità al suo interno**.

### Segreti leaked

Un'applicazione può contenere segreti (API keys, password, url nascosti, sottodomini...) al suo interno che potresti essere in grado di scoprire. Puoi usare uno strumento come [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Altre funzioni interessanti

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** dichiarate come `native`: `public native, System.loadLibrary, System.load`
- [Leggi questo per imparare **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analisi dinamica

> Prima di tutto, hai bisogno di un ambiente dove poter installare l'applicazione e tutta la configurazione (Burp CA cert, Drozer e Frida principalmente). Perciò, un dispositivo rooted (emulato o no) è fortemente raccomandato.

### Analisi dinamica online

Puoi creare un **account gratuito** su: [https://appetize.io/](https://appetize.io). Questa piattaforma ti permette di **caricare** ed **eseguire** APK, quindi è utile per vedere come si comporta un apk.

Puoi persino **vedere i log della tua applicazione** nel web e connetterti tramite **adb**.

![](<../../images/image (831).png>)

Grazie alla connessione ADB puoi usare **Drozer** e **Frida** all'interno degli emulatori.

### Analisi dinamica locale

#### Usare un emulator

- [**Android Studio**](https://developer.android.com/studio) (Puoi creare dispositivi **x86** e **arm**, e secondo [**questo**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**le versioni x86 più recenti** supportano **librerie ARM** senza bisogno di un lento emulator arm).
- Impara come configurarlo in questa pagina:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(versione gratuita:** Personal Edition, è necessario creare un account. _È consigliato **scaricare** la versione **CON**_ _**VirtualBox** per evitare potenziali errori._)
- [**Nox**](https://es.bignox.com) (Gratuito, ma non supporta Frida o Drozer).

> [!TIP]
> Quando crei un nuovo emulator su qualsiasi piattaforma ricorda che più grande è lo schermo, più lento girerà l'emulatore. Quindi seleziona schermi piccoli se possibile.

Per **installare google services** (come AppStore) in Genymotion devi cliccare sul pulsante evidenziato in rosso nell'immagine seguente:

![](<../../images/image (277).png>)

Inoltre, nota che nella **configurazione della VM Android in Genymotion** puoi selezionare la modalità **Bridge Network** (questo sarà utile se ti connetterai alla VM Android da una VM differente con gli strumenti).

#### Usare un dispositivo fisico

Devi attivare le opzioni di **debugging** e sarebbe consigliabile se puoi **rootarlo**:

1. **Impostazioni**.
2. (Da Android 8.0) Seleziona **Sistema**.
3. Seleziona **Informazioni sul telefono**.
4. Premi **Numero build** 7 volte.
5. Torna indietro e troverai le **Opzioni sviluppatore**.

> Una volta installata l'applicazione, la prima cosa da fare è provarla e investigare cosa fa, come funziona e prendere confidenza con essa.\
> Suggerisco di **eseguire questa analisi dinamica iniziale usando MobSF dynamic analysis + pidcat**, così saremo in grado di **imparare come funziona l'applicazione** mentre MobSF **cattura** molti **dati interessanti** che potrai rivedere in seguito.

Note rapide Magisk/Zygisk (raccomandate sui dispositivi Pixel)
- Patch del boot.img con l'app Magisk e flash tramite fastboot per ottenere root systemless
- Abilita Zygisk + DenyList per nascondere il root; considera LSPosed/Shamiko quando è richiesto un nascondimento più forte
- Conserva il boot.img originale per recuperare dagli aggiornamenti OTA; ripatcha dopo ogni OTA
- Per il mirroring dello schermo, usa scrcpy sul host



### Unintended Data Leakage

**Logging**

Gli sviluppatori dovrebbero fare attenzione a non esporre pubblicamente informazioni di **debugging**, poiché possono portare a leak di dati sensibili. Gli strumenti [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` sono raccomandati per monitorare i log dell'applicazione e identificare e proteggere informazioni sensibili. **Pidcat** è preferito per la sua facilità d'uso e leggibilità.

> [!WARNING]
> Nota che da **versioni successive a Android 4.0**, **le applicazioni possono accedere solo ai propri log**. Quindi le app non possono accedere ai log di altre app.\
> Comunque, è sempre raccomandato di **non loggare informazioni sensibili**.

**Copy/Paste Buffer Caching**

Il framework basato su **clipboard** di Android abilita la funzionalità copia-incolla nelle app, ma comporta un rischio poiché **altre applicazioni** possono **accedere** alla clipboard, esponendo potenzialmente dati sensibili. È cruciale **disabilitare le funzioni di copia/incolla** per sezioni sensibili di un'applicazione, come i dettagli delle carte di credito, per prevenire leak di dati.

**Crash Logs**

Se un'applicazione **crasha** e **salva log**, questi log possono aiutare gli attaccanti, specialmente quando l'app non può essere reverse-engineerata. Per mitigare questo rischio, evita di loggare durante i crash, e se i log devono essere trasmessi in rete, assicurati che vengano inviati tramite un canale SSL per sicurezza.

Come pentester, **prova a dare un'occhiata a questi log**.

**Analytics Data Sent To 3rd Parties**

Le applicazioni spesso integrano servizi come Google Adsense, che possono involontariamente **leak sensitive data** a causa di implementazioni errate da parte degli sviluppatori. Per identificare potenziali leak di dati, è consigliabile **intercettare il traffico dell'applicazione** e verificare se informazioni sensibili vengono inviate a servizi di terze parti.

### SQLite DBs

La maggior parte delle applicazioni utilizzerà **internal SQLite databases** per salvare informazioni. Durante il pentest dai un'occhiata ai **database** creati, i nomi delle **tabelle** e delle **colonne** e a tutti i **dati** salvati perché potresti trovare **informazioni sensibili** (che costituirebbero una vulnerability).\
I database dovrebbero trovarsi in `/data/data/the.package.name/databases` come `/data/data/com.mwr.example.sieve/databases`

Se il database salva informazioni riservate ed è **encrypted** ma puoi **trovare** la **password** all'interno dell'applicazione è comunque una **vulnerability**.

Enumera le tabelle usando `.tables` e enumera le colonne delle tabelle con `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** permette di **assumere il ruolo di un'app Android** e interagire con altre app. Può fare **qualsiasi cosa che un'app installata può fare**, come usare il meccanismo di Inter-Process Communication (IPC) di Android e interagire con il sistema operativo sottostante. .\
Drozer è uno strumento utile per **exploit exported activities, exported services and Content Providers** come imparerai nelle sezioni seguenti.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ricorda inoltre che il codice di un activity inizia nel metodo **`onCreate`**.

**Authorisation bypass**

Quando un Activity è exported puoi invocare la sua schermata da un'app esterna. Pertanto, se un activity con **informazioni sensibili** è **exported** potresti **bypassare** i meccanismi di autenticazione per accedervi.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Puoi anche avviare un exported activity da adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Nota che un authorisation bypass non è sempre una vulnerabilità: dipende da come funziona il bypass e quali informazioni vengono esposte.

**Sensitive information leakage**

**Activities can also return results**. Se riesci a trovare un'activity exported e non protetta che chiama il metodo **`setResult`** e **restituisce informazioni sensibili**, si verifica una sensitive information leakage.

#### Tapjacking

If tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers sono fondamentalmente usati per **condividere dati**. Se un'app ha content providers disponibili potresti essere in grado di **estrarre dati sensibili** da essi. È inoltre interessante testare possibili **SQL injections** e **Path Traversals** in quanto potrebbero essere vulnerabili.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Ricorda che le azioni di un Service iniziano nel metodo `onStartCommand`.

Un service è fondamentalmente qualcosa che **può ricevere dati**, **processarli** e **restituire** (o meno) una risposta. Quindi, se un'app sta exportando alcuni services dovresti **controllare** il **code** per capire cosa fa e **testarlo** **dinamicamente** per estrarre info riservate, bypassare misure di autenticazione...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Ricorda che le azioni di un Broadcast Receiver iniziano nel metodo `onReceive`.

Un Broadcast Receiver rimane in attesa di un tipo di messaggio. A seconda di come il receiver gestisce il messaggio, potrebbe essere vulnerabile.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Puoi cercare deep links manualmente, usando tool come MobSF o script come [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puoi **open** uno **scheme** dichiarato usando **adb** o un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Nota che puoi **omettere il package name** e il dispositivo mobile chiamerà automaticamente l'app che dovrebbe aprire quel link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Codice eseguito**

Per trovare il **codice che verrà eseguito nell'App**, vai all'activity chiamata dal deeplink e cerca la funzione **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informazioni sensibili**

Ogni volta che trovi un deep link verifica che **non stia ricevendo dati sensibili (come password) tramite parametri URL**, perché qualsiasi altra applicazione potrebbe **impersonare il deep link e rubare quei dati!**

**Parametri nel path**

Devi controllare anche se qualche deep link usa un parametro all'interno del path dell'URL come: `https://api.example.com/v1/users/{username}` , in tal caso puoi forzare un path traversal accedendo a qualcosa come: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Nota che se trovi gli endpoint corretti all'interno dell'applicazione potresti essere in grado di causare un **Open Redirect** (se parte del path viene usata come nome di dominio), **account takeover** (se puoi modificare i dettagli degli utenti senza CSRF token e l'endpoint vuln usa il metodo corretto) e qualsiasi altra vuln. Maggiori [info su questo qui](http://dphoeniixx.com/2020/12/13-2/).

**Altri esempi**

Un [interessante bug bounty report](https://hackerone.com/reports/855618) su links (_/.well-known/assetlinks.json_).

### Ispezione del Transport Layer e problemi di verifica

- **I certificati non vengono sempre ispezionati correttamente** dalle applicazioni Android. È comune che queste applicazioni ignorino gli avvisi e accettino certificati self-signed o, in alcuni casi, tornino a usare connessioni HTTP.
- **Le negoziazioni durante l'handshake SSL/TLS sono talvolta deboli**, impiegando suite di cifratura insicure. Questa vulnerabilità rende la connessione suscettibile ad attacchi man-in-the-middle (MITM), permettendo agli attacker di decrittare i dati.
- **Leakage of private information** è un rischio quando le applicazioni si autenticano usando canali sicuri ma poi comunicano su canali non sicuri per altre transazioni. Questo approccio non protegge i dati sensibili, come cookie di sessione o dettagli degli utenti, dall'intercettazione da parte di entità malevole.

#### Verifica del certificato

Ci concentreremo sulla **verifica dei certificati**. L'integrità del certificato del server deve essere verificata per migliorare la sicurezza. Questo è cruciale perché configurazioni TLS insicure e la trasmissione di dati sensibili su canali non cifrati possono comportare rischi significativi. Per passaggi dettagliati sulla verifica dei certificati server e sulla risoluzione delle vulnerabilità, [**questa risorsa**](https://manifestsecurity.com/android-application-security-part-10/) fornisce una guida completa.

#### SSL Pinning

SSL Pinning è una misura di sicurezza in cui l'applicazione verifica il certificato del server confrontandolo con una copia nota memorizzata nell'app stessa. Questo metodo è essenziale per prevenire attacchi MITM. Implementare SSL Pinning è fortemente raccomandato per applicazioni che gestiscono informazioni sensibili.

#### Ispezione del traffico

Per ispezionare il traffico HTTP, è necessario **installare il certificato dello strumento proxy** (es. Burp). Senza installare questo certificato, il traffico cifrato potrebbe non essere visibile tramite il proxy. Per una guida sull'installazione di un certificato CA custom, [**clicca qui**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Le applicazioni che targettizzano **API Level 24 and above** richiedono modifiche al Network Security Config per accettare il certificato CA del proxy. Questo passaggio è critico per ispezionare il traffico cifrato. Per istruzioni sulla modifica del Network Security Config, [**consulta questo tutorial**](make-apk-accept-ca-certificate.md).

Se viene usato **Flutter**, è necessario seguire le istruzioni in [**questa pagina**](flutter.md). Questo perché, aggiungere semplicemente il certificato nello store non funzionerà in quanto Flutter ha la propria lista di CA valide.

#### Rilevamento statico dello SSL/TLS pinning

Prima di tentare bypass a runtime, mappa rapidamente dove il pinning è applicato nell'APK. La scoperta statica ti aiuta a pianificare hooks/patches e a concentrarti sui giusti code paths.

Tool: SSLPinDetect
- Utility open-source di static-analysis che decompila l'APK in Smali (via apktool) e scansiona per pattern regex curati di implementazioni di SSL/TLS pinning.
- Riporta il file path esatto, il numero di linea e uno snippet di codice per ogni match.
- Copre framework comuni e code paths custom: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init con custom TrustManagers/KeyManagers, e Network Security Config XML pins.

Install
- Prerequisiti: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Esempi di regole di pattern (JSON)
Usa o estendi le signatures per rilevare stili di pinning proprietari/custom. Puoi caricare il tuo JSON e scansionare su larga scala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes e consigli
- Scansione veloce su app di grandi dimensioni tramite multi-threading e memory-mapped I/O; regex precompilate riducono overhead/falsi positivi.
- Raccolta di pattern: https://github.com/aancw/smali-sslpin-patterns
- Tipici obiettivi di rilevamento da analizzare dopo:
- OkHttp: uso di CertificatePinner, setCertificatePinner, riferimenti al package okhttp3/okhttp
- TrustManagers personalizzati: javax.net.ssl.X509TrustManager, override di checkServerTrusted
- Contesti SSL personalizzati: SSLContext.getInstance + SSLContext.init con manager personalizzati
- Pin dichiarativi in res/xml network security config e riferimenti nel manifest
- Usa le posizioni corrispondenti per pianificare Frida hooks, patch statici o revisioni della config prima dei test dinamici.



#### Bypassare SSL Pinning

Quando SSL Pinning è implementato, bypassarlo diventa necessario per ispezionare il traffico HTTPS. Sono disponibili vari metodi per questo scopo:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Il principale vantaggio di questa opzione è che non servirà root per bypassare lo SSL Pinning, ma dovrai eliminare l'applicazione e reinstallare quella nuova, e non sempre funzionerà.
- Puoi usare **Frida** (discusso sotto) per bypassare questa protezione. Qui trovi una guida per usare Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Puoi anche provare a **bypassare automaticamente SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Puoi anche provare a **bypassare automaticamente SSL Pinning** usando **MobSF dynamic analysis** (spiegato sotto)
- Se pensi ancora che ci sia traffico che non stai catturando puoi provare a **inoltrare il traffico a Burp usando iptables**. Leggi questo blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Ricerca di vulnerabilità web comuni

È importante cercare anche vulnerabilità web comuni all'interno dell'applicazione. Informazioni dettagliate sull'identificazione e la mitigazione di queste vulnerabilità sono oltre lo scopo di questo sommario ma vengono trattate estensivamente altrove.

### Frida

[Frida](https://www.frida.re) è un toolkit di instrumentazione dinamica per sviluppatori, reverse-engineer e ricercatori della sicurezza.\
**Puoi accedere all'applicazione in esecuzione e hookare i metodi a runtime per cambiare il comportamento, modificare valori, estrarre valori, eseguire codice diverso...**\
Se vuoi pentest applicazioni Android devi sapere come usare Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Alcune "GUI" per azioni con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection è ottimo per automatizzare l'uso di Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puoi trovare alcuni Awesome Frida scripts qui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Prova a bypassare meccanismi anti-debugging / anti-frida caricando Frida come indicato in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump della memoria - Fridump**

Verifica se l'applicazione sta memorizzando informazioni sensibili nella memoria che non dovrebbe memorizzare, come password o mnemonici.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) puoi fare il dump della memoria dell'app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Questo effettuerà il dump della memoria nella cartella ./dump, e lì potresti usare grep con qualcosa del tipo:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dati sensibili nel Keystore**

Su Android il Keystore è il posto migliore per memorizzare dati sensibili, tuttavia, con sufficienti privilegi è ancora **possibile accedervi**. Poiché le applicazioni tendono a memorizzare qui **dati sensibili in chiaro**, i pentests dovrebbero verificarne la presenza, poiché un root user o qualcuno con accesso fisico al dispositivo potrebbe riuscire a rubare questi dati.

Anche se un'app memorizzasse dati nel keystore, i dati dovrebbero essere cifrati.

Per accedere ai dati all'interno del keystore puoi usare questo Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando il seguente Frida script potrebbe essere possibile **bypass fingerprint authentication** che le applicazioni Android eseguono per **proteggere alcune aree sensibili:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Immagini in background**

Quando mandi un'applicazione in background, Android memorizza una **snapshot of the application** così quando viene riportata in primo piano inizia a caricare l'immagine prima dell'app, in modo che sembri che l'app sia stata caricata più velocemente.

Tuttavia, se questa snapshot contiene **informazioni sensibili**, qualcuno con accesso alla snapshot potrebbe **rubare quelle informazioni** (nota che è necessario avere root per accedervi).

Gli snapshot sono solitamente memorizzati in: **`/data/system_ce/0/snapshots`**

Android fornisce un modo per **impedire la cattura di screenshot impostando il parametro di layout FLAG_SECURE**. Usando questo flag, il contenuto della finestra viene trattato come sicuro, impedendone la comparsa negli screenshot o la visualizzazione su display non sicuri.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

This tool could help you managing different tools during the dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Gli sviluppatori spesso creano componenti proxy come activities, services e broadcast receivers che gestiscono questi Intent e li passano a metodi come `startActivity(...)` o `sendBroadcast(...)`, il che può essere rischioso.

Il pericolo risiede nel permettere ad un attaccante di attivare componenti non-exported dell'app o di accedere a content providers sensibili deviando questi Intent. Un esempio notevole è il componente `WebView` che converte le URL in oggetti `Intent` tramite `Intent.parseUri(...)` e poi li esegue, potenzialmente portando a malicious Intent injections.

### Essential Takeaways

- **Intent Injection** è simile al problema Open Redirect del web.
- Gli exploit implicano il passaggio di oggetti `Intent` come extras, che possono essere reindirizzati per eseguire operazioni non sicure.
- Può esporre componenti non-exported e content providers agli attaccanti.
- La conversione da URL a `Intent` di `WebView` può facilitare azioni non intenzionate.

### Android Client Side Injections and others

Probabilmente conosci questo tipo di vulnerabilità dal Web. Devi prestare particolare attenzione a queste vulnerabilità in un'app Android:

- **SQL Injection:** When dealing with dynamic queries or Content-Providers ensure you are using parameterized queries.
- **JavaScript Injection (XSS):** Verify that JavaScript and Plugin support is disabled for any WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews should have access to the file system disabled (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In diversi casi quando l'app Android termina la sessione il cookie non viene revocato o può essere addirittura salvato su disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analisi statica**

![](<../../images/image (866).png>)

**Valutazione delle vulnerabilità dell'applicazione** usando una comoda interfaccia web. Puoi anche eseguire analisi dinamica (ma devi preparare l'ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Nota che MobSF può analizzare **Android**(apk), **IOS**(ipa) e **Windows**(apx) applicazioni (_Le applicazioni Windows devono essere analizzate da un'istanza di MobSF installata su un host Windows_).\
Inoltre, se crei un file **ZIP** con il codice sorgente di un'app **Android** o **IOS** (vai nella cartella root dell'applicazione, seleziona tutto e crea un file ZIP), sarà in grado di analizzarlo.

MobSF permette anche di fare il **diff/Compare** delle analisi e di integrare **VirusTotal** (dovrai impostare la tua API key in _MobSF/settings.py_ e abilitarla: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Puoi anche impostare `VT_UPLOAD` a `False`, in tal caso verrà caricato l'**hash** invece del file.

### Analisi dinamica assistita con MobSF

**MobSF** può essere molto utile anche per l'**analisi dinamica** su **Android**, ma in questo caso dovrai installare MobSF e **genymotion** sull'host (una VM o Docker non funzioneranno). _Nota: Devi **avviare prima una VM in genymotion** e **poi MobSF.**_\
Il **MobSF dynamic analyser** può:

- **Dump application data** (URL, log, clipboard, screenshot fatti da te, screenshot fatti da "**Exported Activity Tester**", email, database SQLite, file XML e altri file creati). Tutto questo viene fatto automaticamente eccetto per gli screenshot: devi premere quando vuoi uno screenshot oppure premere "**Exported Activity Tester**" per ottenere gli screenshot di tutte le attività esportate.
- Catturare **HTTPS traffic**
- Usare **Frida** per ottenere **informazioni runtime**

Per le versioni **Android > 5**, avvierà **automaticamente Frida** e imposterà le impostazioni di **proxy** globali per **catturare** il traffico. Catturerà solo il traffico dell'applicazione testata.

**Frida**

Di default, utilizzerà anche alcuni Frida Scripts per **bypass SSL pinning**, **root detection** e **debugger detection** e per **monitorare API interessanti**.\
MobSF può anche **invoke exported activities**, catturare **screenshots** di esse e **salvarle** per il report.

Per **start** del testing dinamico premi il pulsante verde: "**Start Instrumentation**". Premi "**Frida Live Logs**" per vedere i log generati dagli script Frida e "**Live API Monitor**" per vedere tutte le invocazioni ai metodi hookati, gli argomenti passati e i valori restituiti (questo apparirà dopo aver premuto "Start Instrumentation").\
MobSF permette anche di caricare i propri **Frida scripts** (per inviare i risultati dei tuoi Frida scripts a MobSF usa la funzione `send()`). Ha anche **diversi script pre-scritti** che puoi caricare (puoi aggiungerne altri in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), selezionali, premi "**Load**" e premi "**Start Instrumentation**" (potrai vedere i log di quegli script dentro "**Frida Live Logs**").

![](<../../images/image (419).png>)

Inoltre, hai alcune funzionalità ausiliarie di Frida:

- **Enumerate Loaded Classes**: stamperà tutte le classi caricate
- **Capture Strings**: stamperà tutte le stringhe catturate durante l'uso dell'applicazione (molto rumoroso)
- **Capture String Comparisons**: può essere molto utile. Mostrerà **le 2 stringhe confrontate** e se il risultato è True o False.
- **Enumerate Class Methods**: Inserisci il nome della classe (es. "java.io.File") e stamperà tutti i metodi della classe.
- **Search Class Pattern**: cerca classi tramite pattern
- **Trace Class Methods**: **Trace** una **classe intera** (mostra input e output di tutti i metodi della classe). Ricorda che di default MobSF traccia diversi metodi interessanti delle Android API.

Una volta selezionato il modulo ausiliario che vuoi usare devi premere "**Start Intrumentation**" e vedrai tutti gli output in "**Frida Live Logs**".

**Shell**

MobSF offre anche una shell con alcuni comandi **adb**, **MobSF commands**, e comuni comandi di **shell** nella parte inferiore della pagina di analisi dinamica. Alcuni comandi interessanti:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Quando il traffico http viene catturato puoi vedere una vista brutta del traffico catturato nel pulsante "**HTTP(S) Traffic**" in basso o una vista più gradevole nel pulsante verde "**Start HTTPTools**". Dalla seconda opzione, puoi **inviare** le **richieste catturate** a **proxies** come Burp o Owasp ZAP.\
To do so, _accendi Burp -->_ _disattiva Intercept --> in MobSB HTTPTools seleziona la richiesta_ --> premi "**Send to Fuzzer**" --> _seleziona l'indirizzo del proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una volta terminata l'analisi dinamica con MobSF puoi premere "**Start Web API Fuzzer**" per **fuzz http requests** e cercare vulnerabilità.

> [!TIP]
> Dopo aver eseguito un'analisi dinamica con MobSF le impostazioni del proxy possono essere misconfigure e potresti non essere in grado di correggerle dall'interfaccia GUI. Puoi correggere le impostazioni del proxy eseguendo:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Puoi ottenere lo strumento da [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Questo strumento usa alcuni **Hooks** per farti capire **cosa sta succedendo nell'applicazione** mentre esegui un'**analisi dinamica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Questo è un **ottimo tool per eseguire analisi statica con una GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Questo strumento è progettato per cercare diverse **vulnerabilità delle applicazioni Android legate alla sicurezza**, sia nel **source code** che negli **packaged APKs**. Lo strumento è anche **capace di creare un "Proof-of-Concept" deployable APK** e **ADB commands**, per sfruttare alcune delle vulnerabilità trovate (Exposed activities, intents, tapjacking...). Come con Drozer, non è necessario effettuare il root del dispositivo di test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Mostra tutti i file estratti per un facile riferimento
- Decompila automaticamente i file APK nel formato Java e Smali
- Analizza AndroidManifest.xml per vulnerabilità e comportamenti comuni
- Analisi statica del codice sorgente per vulnerabilità e comportamenti comuni
- Informazioni dispositivo
- e altro
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER è un'applicazione a riga di comando che può essere usata in Windows, MacOS X e Linux, che analizza i file _.apk_ alla ricerca di vulnerabilità. Lo fa decomprimendo gli APK e applicando una serie di regole per rilevarle.

Tutte le regole sono centralizzate in un file `rules.json`, e ogni azienda o tester può creare le proprie regole per analizzare ciò di cui ha bisogno.

Scarica i binari più recenti dalla [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn è uno strumento **multipiattaforma** che aiuta gli sviluppatori, bugbounty hunters e ethical hackers a eseguire [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) su applicazioni mobili.

Il concetto è che trascini e rilasci il file della tua applicazione mobile (un file .apk o .ipa) sull'applicazione StaCoAn e questa genererà per te un report visivo e portatile. Puoi modificare le impostazioni e le wordlists per ottenere un'esperienza personalizzata.

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework è un sistema di analisi delle vulnerability per Android che aiuta sviluppatori o hackers a trovare potenziali vulnerability nelle applicazioni Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** è uno strumento il cui obiettivo principale è rilevare e avvertire l'utente riguardo a potenziali comportamenti malevoli sviluppati da un'applicazione Android.

La rilevazione viene effettuata mediante la **static analysis** del Dalvik bytecode dell'applicazione, rappresentato come **Smali**, con la libreria [`androguard`](https://github.com/androguard/androguard).

Questo strumento cerca **comportamenti comuni di applicazioni "maligne"** come: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** è un framework per il reverse engineering e l'analisi di applicazioni mobile. È uno strumento che mette insieme strumenti comunemente usati per il reverse engineering e l'analisi di mobile application, per aiutare nei test delle applicazioni mobile contro le minacce di sicurezza mobile OWASP. Il suo obiettivo è rendere questo compito più semplice e amichevole per gli sviluppatori di applicazioni mobile e i professionisti della sicurezza.

È in grado di:

- Estrarre codice Java e Smali usando diversi strumenti
- Analizzare APK utilizzando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Estrarre informazioni private dall'APK usando regexps.
- Analizzare il Manifest.
- Analizzare i domini trovati usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) e [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscare APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile per rilevare malware: [https://koodous.com/](https://koodous.com/)

## Offuscamento/Deoffuscamento del codice

Nota che, a seconda del servizio e della configurazione usati per offuscare il codice, i segreti possono o non possono risultare offuscati.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Da [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** è uno strumento open source da riga di comando che riduce, ottimizza e offusca codice Java. È in grado di ottimizzare il bytecode e di rilevare e rimuovere istruzioni non usate. ProGuard è software libero e viene distribuito sotto la GNU General Public License, versione 2.

ProGuard è distribuito come parte dell'Android SDK e viene eseguito durante la build dell'applicazione in modalità release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Trova una guida passo-passo per deoffuscare l'apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Dalla guida) L'ultima volta che abbiamo controllato, la modalità di funzionamento di Dexguard era:

- caricare una risorsa come un InputStream;
- passare il risultato a una classe che eredita da FilterInputStream per decriptarlo;
- eseguire qualche inutile offuscamento per far perdere qualche minuto a un reverser;
- passare il risultato decriptato a un ZipInputStream per ottenere un file DEX;
- infine caricare il DEX risultante come Resource usando il metodo `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard inverte il processo di offuscamento eseguito dagli strumenti di offuscamento Android. Questo abilita numerose analisi di sicurezza, inclusa l'ispezione del codice e l'identificazione delle librerie.**

Puoi caricare un APK offuscato sulla loro piattaforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Questo è uno strumento LLM per trovare potenziali vulnerabilità di sicurezza nelle app android e deoffuscare il codice delle app android. Usa l'API pubblica Gemini di Google.

### [Simplify](https://github.com/CalebFenton/simplify)

È un **deoffuscatore android generico.** Simplify **esegue virtualmente un'app** per comprenderne il comportamento e poi **cerca di ottimizzare il codice** in modo che si comporti in modo identico ma sia più facile da comprendere per un umano. Ogni tipo di ottimizzazione è semplice e generico, quindi non importa quale specifico tipo di offuscamento venga usato.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD ti dà informazioni su **come è stato creato un APK**. Identifica molti **compilers**, **packers**, **obfuscators**, e altre cose strane. È [_PEiD_](https://www.aldeid.com/wiki/PEiD) per Android.

### Manuale

[Leggi questo tutorial per imparare alcuni trucchi su **come eseguire il reverse di offuscamenti personalizzati**](manual-deobfuscation.md)

## Laboratori

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b è una virtual machine per la sicurezza Android basata su ubuntu-mate che include una raccolta degli ultimi framework, tutorial e lab provenienti da diversi security geeks e ricercatori per il reverse engineering e l'analisi di malware.

## Riferimenti

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) È un'ottima lista di risorse
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Corso rapido di Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
