# Programu za Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Misingi ya Programu za Android

Inashauriwa sana kuanza kusoma ukurasa huu ili kujue kuhusu **sehemu muhimu zaidi zinazohusiana na usalama wa Android na vipengele hatari zaidi katika programu ya Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Hii ni zana kuu unayohitaji kuunganisha na kifaa cha Android (kilichoiga au cha kimwili).\
**ADB** inaruhusu kudhibiti vifaa kupitia **USB** au **mtandao** kutoka kwa kompyuta. Huduma hii inafanya iwezekane **kunakili** faili kwa pande zote mbili, **kusakinisha** na **kuondoa** apps, **kutekeleza** amri za shell, **kutengeneza nakala (backup)** za data, **kusoma** logi, pamoja na kazi nyingine.

Tazama orodha ifuatayo ya [**ADB Commands**](adb-commands.md) ili kujifunza jinsi ya kutumia adb.

## Smali

Wakati mwingine ni vyema **kubadilisha msimbo wa programu** ili kupata **taarifa zilizofichwa** (labda nywila zilizofichwa vizuri au flagi). Kisha, inaweza kuwa muhimu ku-decompile apk, kubadilisha msimbo na ku-recompile tena.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Hii inaweza kuwa muhimu kama **mbadala kwa vipimo kadhaa wakati wa uchambuzi wa dynamic** utakaowasilishwa. Basi, **kumbuka kila wakati uwezekano huu**.

## Mbinu nyingine za kuvutia

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Toa APK kutoka kifaa:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Unganisha splits zote na base apks kwa kutumia [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Mifano ya Kesi na Udhaifu


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Uchambuzi wa Statiki

Kwanza kabisa, kwa kuchambua APK unapaswa **kutazama msimbo wa Java** kwa kutumia decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Kutafuta Taarifa Zinazovutia

Kwa kuangalia tu **strings** za APK unaweza kutafuta **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** na chochote kinachovutia... angalia hata kwa code execution **backdoors** au authentication backdoors (hardcoded admin credentials kwa app).

**Firebase**

Lipa kipaumbele maalum kwa **firebase URLs** na angalia ikiwa imekonfiguriwa vibaya. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Uelewa wa Msingi wa programu - Manifest.xml, strings.xml

Ukaguzi wa faili za programu _Manifest.xml_ na _strings.xml_ unaweza kubaini udhaifu wa usalama. Faili hizi zinaweza kupatikana kwa kutumia decompilers au kwa kubadilisha extension ya faili ya APK kuwa .zip kisha kuizipisha.

Udhaifu unaobainika kutoka Manifest.xml ni pamoja na:

- **Maombi yanayoweza ku-debug (Debuggable Applications)**: Maombi yaliyowekwa kama `debuggable="true"` katika _Manifest.xml_ yanaweza kuwapo kwa hatari kwa sababu yanaruhusu muunganisho ambao unaweza kusababisha exploitation. Kwa uelewa zaidi kuhusu jinsi ya ku-exploit applications zilizo set kama debuggable, angalia tutorial za kutafuta na ku-exploit applications debuggable kwenye kifaa.
- **Mipangilio ya Backup**: Attribute `android:allowBackup="false"` inapaswa kuwekwa wazi kwa applications zinazoendesha habari nyeti ili kuzuia backups zisizoidhinishwa za data kupitia adb, hasa wakati usb debugging imewezeshwa.
- **Network Security**: Custom network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) katika _res/xml/_ zinaweza kubainisha maelezo ya usalama kama certificate pins na mipangilio ya HTTP traffic. Mfano ni kuruhusu HTTP traffic kwa domain maalum.
- **Exported Activities and Services**: Kutambua exported activities na services katika manifest kunaweza kuonyesha components ambazo zinaweza kutumika vibaya. Uchambuzi zaidi wakati wa dynamic testing unaweza kubaini jinsi ya ku-exploit components hizi.
- **Content Providers and FileProviders**: Content providers zilizo wazi zinaweza kuruhusu upatikanaji usioidhinishwa au marekebisho ya data. Muundo wa FileProviders pia unapaswa kuchunguzwa.
- **Broadcast Receivers and URL Schemes**: Components hizi zinaweza kutumika kwa exploitation, hasa kwa kuzingatia jinsi URL schemes zinavyosimamiwa kwa ajili ya udhaifu wa input.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, na `maxSdkVersion` zinaonyesha matoleo ya Android yanayotumika, zikibainisha umuhimu wa kutojisikia kwa matoleo ya Android yasiyokuwa salama kwa sababu za usalama.

Kutoka kwa faili ya **strings.xml**, habari nyeti kama API keys, custom schemas, na maelezo mengine ya developer zinaweza kugunduliwa, ikisisitiza haja ya kupitia rasilimali hizi kwa uangalifu.

### Tapjacking

Tapjacking ni attack ambapo malicious application inazinduliwa na kujipanga juu ya victim application. Mara inapofunika kwa muonekano victim app, user interface yake imeundwa kwa njia ya kumdanganya mtumiaji kuingiliana nayo, wakati inapipitisha interaction hiyo kwa victim app.\
Kwa vitendo, inamficha mtumiaji kutoka kujua kwamba kwa kweli anatekeleza vitendo kwenye victim app.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Activity yenye `launchMode` iliyowekwa kwa `singleTask` bila `taskAffinity` yoyote iliyotajwa ni nyeti kwa task Hijacking. Hii inamaanisha kwamba application inaweza kusanikishwa na ikiwa itazinduliwa kabla ya application halisi inaweza hijack task ya application halisi (hivyo mtumiaji atakuwa akishirikiana na malicious application akidhani anatumia ile halisi).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Katika Android, faili zilizohifadhiwa katika internal storage zimeundwa zilipwe kupatikana kikamilifu na app iliyozizalisha. Hatua hii ya usalama inatekelezwa na mfumo wa uendeshaji wa Android na kwa kawaida ni ya kutosha kwa mahitaji ya usalama ya applications nyingi. Hata hivyo, developers wakati mwingine hutumia mode kama `MODE_WORLD_READABLE` na `MODE_WORLD_WRITABLE` kuruhusu faili kushirikiwa kati ya applications tofauti. Mode hizi hazizuizi upatikanaji wa faili hizi na applications nyingine, pamoja na zile ambazo zinaweza kuwa malicious.

1. **Uchambuzi wa Statiki:**
- **Hakikisha** kwamba matumizi ya `MODE_WORLD_READABLE` na `MODE_WORLD_WRITABLE` yamechunguzwa kwa uangalifu. Mode hizi **zinaweza kuonyesha** faili kwa **upatikanaji usiotarajiwa au usioidhinishwa**.
2. **Uchambuzi wa Dinamiki:**
- **Thibitisha** **permissions** zilizowekwa kwenye faili zilizoundwa na app. Hasa, **kagua** kama kuna faili zilizowekwa kuwa **zinazosomwa au zinaandikwa na kila mtu**. Hii inaweza kuleta hatari kubwa ya usalama, kwani itamruhusu **application yoyote** iliyowekwa kwenye kifaa, bila kujali chanzo au nia yake, **kusoma au kubadilisha** faili hizi.

**External Storage**

Unaposhughulika na faili kwenye external storage, kama SD Cards, tahadhari zifuatazo zinapaswa kuchukuliwa:

1. **Upatikanaji**:
- Faili kwenye external storage ni **zinazosomwa na kuandikwa kwa ulimwengu mzima**. Hii inamaanisha application yoyote au mtumiaji anaweza kufikia faili hizi.
2. **Masuala ya Usalama**:
- Kwa kuzingatia urahisi wa upatikanaji, inashauriwa **kutoihifadhi habari nyeti** kwenye external storage.
- External storage inaweza kuondolewa au kufikiwa na application yoyote, ikifanya isiwe salama.
3. **Kushughulikia Data kutoka External Storage**:
- Daima **fanya validation ya input** kwa data inayopelekwa kutoka external storage. Hii ni muhimu kwa sababu data hiyo inatokana na chanzo kisichoaminika.
- Kuhifadhi executable au class files kwenye external storage kwa ajili ya dynamic loading inaachwa kwa hatari kubwa.
- Ikiwa application yako lazima ipate faili za executable kutoka external storage, hakikisha faili hizi zimesainiwa na kuthibitishwa kihasabu kabla ya kuzichukua kwa dynamic. Hatua hii ni muhimu kwa kudumisha uadilifu wa usalama wa application yako.

External storage inaweza kufikika katika `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Kuanzia Android 4.4 (**API 17**), SD card ina muundo wa directories ambao unapunguza upatikanaji kutoka kwa app hadi directory iliyobuniwa kwa ajili ya app hiyo pekee. Hii inazuia malicious application kupata upatikanaji wa kusoma au kuandika faili za app nyingine.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android inaruhusu kila application kuhifadhi kwa urahisi faili za xml katika njia `/data/data/<packagename>/shared_prefs/` na wakati mwingine inawezekana kupata taarifa nyeti kwa clear-text katika folda hiyo.
- **Databases**: Android inaruhusu kila application kuhifadhi kwa urahisi sqlite databases katika njia `/data/data/<packagename>/databases/` na wakati mwingine inawezekana kupata taarifa nyeti kwa clear-text katika folda hiyo.

### Broken TLS

**Accept All Certificates**

Kwa sababu fulani, wakati mwingine developers wanakubali certificates zote hata kama kwa mfano hostname haifanani, kwa mistari ya code kama ifuatayo:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Kriptografia Imevunjika

**Mchakato Duni wa Usimamizi wa Vifunguo**

Baadhi ya watengenezaji huhifadhi data nyeti kwenye storage ya ndani na kuiweka kwa encrypto na key iliyowekwa ndani/kutabirika ndani ya code. Hii haipaswi kufanywa kwa sababu reversing inaweza kumruhusu mshambuliaji kutoa taarifa za siri.

**Matumizi ya Algorithms Yasiyo Salama na/au Yaliyopitwa na Wakati**

Watengenezaji hawapaswi kutumia **deprecated algorithms** kufanya **checks** za uthibitishaji, **store** au **kutuma** data. Baadhi ya algorithms hizi ni: RC4, MD4, MD5, SHA1... Ikiwa **hashes** zinatumiwa kuhifadhi nywila kwa mfano, inapaswa kutumika hashes zenye uwezo wa kupinga brute-force pamoja na salt.

### Mambo mengine ya kukagua

- Inashauriwa **kupotosha APK** ili kuleta ugumu kwa reverse engineer.
- Ikiwa app ni nyeti (kama apps za benki), inapaswa kufanya **mithili zake ya kukagua kama simu ime-root** na kuchukua hatua zinazofaa.
- Ikiwa app ni nyeti (kama apps za benki), inapaswa kukagua kama **emulator** inatumika.
- Ikiwa app ni nyeti (kama apps za benki), inapaswa **kukagua uadilifu wake kabla ya kuitekeleza** ili kuona ikiwa imebadilishwa.
- Tumia [**APKiD**](https://github.com/rednaga/APKiD) ili kukagua compiler/packer/obfuscator iliyotumika kujenga APK

### React Native Application

Soma ukurasa ufuatao kujifunza jinsi ya kupata kwa urahisi javascript code ya React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Soma ukurasa ufuatao kujifunza jinsi ya kupata kwa urahisi C# code ya xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Kulingana na hii [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked ni algorithm ya Meta inayoshinikiza yaliyomo ya application ndani ya faili moja. Blogu inazungumzia kuhusu uwezekano wa kuunda app inayo-decompress aina hizi za apps... na njia ya haraka ambayo inahusisha **kufanya execute application na kukusanya files zilizodecompressed kutoka kwenye filesystem.**

### Automated Static Code Analysis

Tool [**mariana-trench**](https://github.com/facebook/mariana-trench) inaweza kupata **vulnerabilities** kwa **kuscan** **code** ya application. Tool hii ina orodha ya **known sources** (zinazoelezea kwa tool **maeneo** ambapo **input** inadhibitiwa na mtumiaji), **sinks** (zinazoelezea kwa tool **maeneo hatari** ambapo input ya mtumiaji mbaya inaweza kusababisha uharibifu) na **rules**. Rules hizi zinaelezea **mchanganyiko** wa **sources-sinks** unaoashiria vulnerability.

Kwa uelewa huu, **mariana-trench itapitia code na kupata uwezekano wa vulnerabilities ndani yake**.

### Secrets leaked

Application inaweza kuwa na secrets (API keys, passwords, hidden urls, subdomains...) ndani yake ambazo unaweza kugundua. Unaweza kutumia tool kama [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> Kwanza kabisa, unahitaji mazingira ambapo unaweza kusanidi application na mazingira yote (Burp CA cert, Drozer na Frida hasa). Kwa hivyo, kifaa kilichoroot-ikiwa (emulated au sio) kinapendekezwa sana.

### Online Dynamic analysis

Unaweza kuunda **akaunti ya bure** katika: [https://appetize.io/](https://appetize.io). Jukwaa hili linakuwezesha **kupakia** na **kufanya execute** APKs, hivyo ni muhimu kuona jinsi apk inavyotenda.

Unaweza hata **kuona logs za application yako** kwenye wavuti na kuunganishwa kupitia **adb**.

![](<../../images/image (831).png>)

Shukrani kwa muunganisho wa ADB unaweza kutumia **Drozer** na **Frida** ndani ya emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Unaweza kuunda vifaa **x86** na **arm**, na kulingana na [**hii** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**matoleo ya hivi karibuni ya x86** yanaunga mkono **ARM libraries** bila hitaji la emulator ya arm iliyokuwa polepole).
- Jifunze kuiseti kupitia ukurasa huu:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(toleo la bure:** Personal Edition, unahitaji kuunda akaunti. _Inapendekezwa **kushusha** toleo **LENYE**_ _**VirtualBox** ili kuepuka makosa ya uwezekano._)
- [**Nox**](https://es.bignox.com) (Bure, lakini haiku-support Frida au Drozer).

> [!TIP]
> Unapounda emulator mpya kwenye jukwaa lolote kumbuka kuwa skrini kubwa inafanya emulator kuwa polepole zaidi. Hivyo chagua skrini ndogo inapowezekana.

Ili **kusakinisha google services** (kama AppStore) kwenye Genymotion unahitaji kubofya kitufe kilicho alama nyekundu kwenye picha ifuatayo:

![](<../../images/image (277).png>)

Pia, kumbuka kwamba kwenye **mipangilio ya Android VM katika Genymotion** unaweza kuchagua **Bridge Network mode** (hii itakuwa muhimu ikiwa utakuwa unajiunganisha na Android VM kutoka VM tofauti yenye tools).

#### Use a physical device

Unahitaji kuamilisha chaguo za **debugging** na itakuwa vizuri kama unaweza kui-**root**:

1. **Settings**.
2. (FromAndroid 8.0) Chagua **System**.
3. Chagua **About phone**.
4. Bonyeza **Build number** mara 7.
5. Rudi nyuma na utapata **Developer options**.

> Mara baada ya kusakinisha application, jambo la kwanza unalopaswa kufanya ni kuijaribu na kuchunguza inafanya nini, jinsi inavyofanya kazi na kujisikia mwenyewe nayo.\
> Ninapendekeza **kutekeleza uchambuzi huu wa awali wa dynamic kwa kutumia MobSF dynamic analysis + pidcat**, ili tuweze **kujifunza jinsi application inavyofanya kazi** wakati MobSF inavyokamata data nyingi **zinazovutia** utakazoweza kuzipitia baadaye.

### Unintended Data Leakage

**Logging**

Watengenezaji wanapaswa kuwa waangalifu kuhusu kufichua **maelezo ya debugging** hadharani, kwani inaweza kusababisha sensitive data leak. Tools [**pidcat**](https://github.com/JakeWharton/pidcat) na `adb logcat` zinapendekezwa kwa kufuatilia application logs ili kubaini na kulinda taarifa nyeti. **Pidcat** inapendelewa kwa urahisi wake wa matumizi na uwazi wa kusoma.

> [!WARNING]
> Kumbuka kwamba tangu **toleo lililozidi Android 4.0**, **applications zinaweza kufikia tu logs zao wenyewe**. Hivyo applications hawawezi kufikia logs za apps nyingine.\
> Hata hivyo, bado inashauriwa **kuto-log maelezo nyeti**.

**Copy/Paste Buffer Caching**

Mfumo wa **clipboard-based** wa Android unawezesha kazi ya copy-paste katika apps, lakini una hatari kwa sababu **applications nyingine** zinaweza **kupata** clipboard, ambayo inaweza kufichua data nyeti. Ni muhimu **kuzima kazi za copy/paste** kwa sehemu nyeti za application, kama taarifa za kadi za mkopo, ili kuzuia data leak.

**Crash Logs**

Ikiwa application **inaanguka** na **kuhifadhi logs**, logs hizi zinaweza kumsaidia mshambuliaji, hasa wakati application haiwezi ku-reverse-engineer. Ili kupunguza hatari hii, epuka ku-log kwenye crashes, na kama logs lazima zitumwe kupitia mtandao, hakikisha zinatumwa kupitia channel ya SSL kwa usalama.

Kama pentester, **jaribu kuangalia logs hizi**.

**Analytics Data Sent To 3rd Parties**

Applications mara nyingi hujumuisha huduma kama Google Adsense, ambazo zinaweza kwa bahati mbaya kusababisha data nyeti leak kutokana na utekelezaji mbaya wa watengenezaji. Ili kubaini leak za data, inashauriwa **kuchukua traffic ya application** na kuangalia kama kuna taarifa nyeti zinazotumwa kwa huduma za third-party.

### SQLite DBs

Wengi wa applications watatumia **internal SQLite databases** kuhifadhi taarifa. Wakati wa pentest angalia **databases** zilizoundwa, majina ya **tables** na **columns** na data zote zilizo hifadhiwa kwa sababu unaweza kupata **taarifa nyeti** (ambayo itakuwa vulnerability).\
Databases zinapaswa kuwa ziko katika `/data/data/the.package.name/databases` kama `/data/data/com.mwr.example.sieve/databases`

Ikiwa database inahifadhi taarifa za siri na ime-**encrypted** lakini unaweza **kupata** **password** ndani ya application, bado ni **vulnerability**.

Orodhesha tables kwa kutumia `.tables` na orodhesha columns za tables kwa kufanya `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** inakuwezesha **kuchukua nafasi ya Android app** na kuingiliana na apps nyingine. Inaweza kufanya **kila kitu ambacho application iliyosakinishwa inaweza kufanya**, kama kutumia mekanisma ya Inter-Process Communication (IPC) ya Android na kuingiliana na operating system ya msingi. .\
Drozer ni tool muhimu ya **kufanya exploit kwa exported activities, exported services na Content Providers** kama utakavyojifunza katika sehemu zifuatazo.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Kumbuka pia kwamba code ya activity huanza katika method ya **`onCreate`**.

**Authorisation bypass**

Wakati Activity ime-exported unaweza kuitangaza screen yake kutoka kwa app ya nje. Hivyo, ikiwa activity yenye **taarifa nyeti** ime-**exported** unaweza **kupitia** **mechanisms za authentication** ili kuifikia.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Unaweza pia kuanza exported activity kutoka adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF itagundua kama hatari matumizi ya _**singleTask/singleInstance**_ kama `android:launchMode` katika activity, lakini kutokana na [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), inaonekana hii ni hatari tu kwenye toleo za zamani (API versions < 21).

> [!TIP]
> Kumbuka kwamba an authorisation bypass si kila mara ni udhaifu; itategemea jinsi bypass inavyofanya kazi na taarifa gani zinaonyeshwa.

**Sensitive information leakage**

**Activities pia zinaweza kurudisha matokeo**. Ikiwa utaweza kupata exported na unprotected activity inayoitisha method ya **`setResult`** na **kurudisha taarifa nyeti**, kuna sensitive information leakage.

#### Tapjacking

Ikiwa Tapjacking haizuiziwi, unaweza kutumia exported activity vibaya ili kufanya **mtumiaji afanye vitendo visivyotarajiwa**. Kwa habari zaidi kuhusu [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers kwa msingi hutumiwa kwa ajili ya **share data**. Ikiwa app ina content providers zinazopatikana unaweza kuwa na uwezo wa **extract sensitive** data kutoka kwao. Pia ni muhimu kujaribu uwezekano wa **SQL injections** na **Path Traversals** kwani zinaweza kuwa vulnerable.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Kumbuka kwamba vitendo vya Service huanza katika method `onStartCommand`.

Service kwa kawaida ni kitu ambacho **kinaweza kupokea data**, **kuita process** na **kurudisha** (au la) response. Hivyo, ikiwa application inatokeza baadhi ya services unapaswa **kuangalia** **code** ili kuelewa inafanya nini na **kujaribu** kwa njia **dynamically** ili kutoa taarifa za siri, kupita hatua za uthibitishaji...

[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Kumbuka kwamba vitendo vya Broadcast Receiver huanza katika method `onReceive`.

Broadcast receiver itakuwa ikisubiri aina fulani ya message. Kulingana na jinsi receiver inavyoshughulikia message inaweza kuwa vulnerable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Unaweza kutafuta deep links kwa mkono, kwa kutumia zana kama MobSF au scripts kama [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Unaweza **open** declared **scheme** kwa kutumia **adb** au **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Kumbuka kwamba unaweza **kuacha jina la package** na simu itaitisha app itakayofungua link hiyo._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Msimbo unaotekelezwa**

Ili kupata **msimbo utakaoendeshwa katika App**, nenda kwenye activity inayoitwa na deeplink na tafuta function **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Taarifa nyeti**

Kila unapopata deep link hakikisha kuwa **haipokei data nyeti (kama nywila) kupitia vigezo vya URL**, kwa sababu programu nyingine yoyote inaweza **kuiga deep link na kuiba data hiyo!**

**Parameters in path**

Unapaswa pia kukagua kama deep link yoyote inatumia parameter ndani ya path ya URL kama: `https://api.example.com/v1/users/{username}` , katika kesi hiyo unaweza kulazimisha path traversal kwa kufikia kitu kama: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Kumbuka kwamba ukigundua endpoints sahihi ndani ya application unaweza kusababisha **Open Redirect** (ikiwa sehemu ya path inatumiwa kama domain name), **account takeover** (ikiwa unaweza kubadilisha maelezo ya users bila CSRF token na endpoint iliyo na udhaifu ilitumia method sahihi) na udhaifu mwingine wowote. Taarifa zaidi kuhusu hili [hapa](http://dphoeniixx.com/2020/12/13-2/).

Mrejeleo wa [ripoti ya bug bounty ya kuvutia](https://hackerone.com/reports/855618) kuhusu links (_/.well-known/assetlinks.json_).

### Uchunguzi wa Tabaka la Usafirishaji na Makosa ya Uthibitishaji

- **Certificates hazikaguliwi kila wakati ipasavyo** na applications za Android. Ni kawaida kwa applications hizi kupuuzia onyo na kukubali self-signed certificates au, katika matukio mengine, kurudi kutumia HTTP connections.
- **Mazungumzo wakati wa SSL/TLS handshake wakati mwingine ni dhaifu**, yakitumia insecure cipher suites. Udhaifu huu unafanya connection kuwa nyeti kwa man-in-the-middle (MITM) attacks, kuruhusu washambuliaji kuvunja usimbaji na kufikia data.
- **Leakage of private information** ni hatari wakati applications zinathibitisha kwa kutumia secure channels kisha kuwasiliana kwa non-secure channels kwa shughuli nyingine. Mbinu hii inashindwa kulinda data nyeti, kama session cookies au user details, dhidi ya interception na entities zenye nia mbaya.

#### Certificate Verification

Tutazingatia **certificate verification**. Uadilifu wa server's certificate ni lazima uthibitishwe ili kuongeza usalama. Hii ni muhimu kwa sababu misanidi isiyo salama ya TLS na uhamishaji wa data nyeti kupitia channels zisizosimbwa vinaweza kusababisha hatari kubwa. Kwa hatua za kina za kuthibitisha server certificates na kushughulikia udhaifu, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) inatoa mwongozo kamili.

#### SSL Pinning

SSL Pinning ni kifaa cha usalama ambapo application inathibitisha server's certificate dhidi ya nakala inayojulikana iliyohifadhiwa ndani ya application yenyewe. Njia hii ni muhimu kuzuia MITM attacks. Kutekeleza SSL Pinning kunashauriwa kwa nguvu kwa applications zinazoshughulikia taarifa nyeti.

#### Traffic Inspection

Ili kuchunguza HTTP traffic, ni muhimu **kusakinisha certificate ya proxy tool** (mfano, Burp). Bila kusakinisha certificate hii, traffic iliyosimbwa inaweza isionekane kupitia proxy. Kwa mwongozo wa kusakinisha custom CA certificate, [**bonyeza hapa**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Applications zinazolenga **API Level 24 and above** zinahitaji marekebisho ya Network Security Config ili kukubali proxy's CA certificate. Hatua hii ni muhimu kwa kuchunguza traffic iliyosimbwa. Kwa maelekezo ya kubadilisha Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Ikiwa **Flutter** inatumika lazima ufuate maelekezo kwenye [**this page**](flutter.md). Hii ni kwa sababu, kuingiza certificate tu kwenye store haitafanya kazi kwani Flutter ina orodha yake ya CA halali.

#### Static detection of SSL/TLS pinning

Kabla ya kujaribu runtime bypasses, chora haraka mahali pinning inatekelezwa ndani ya APK. Ugunduzi wa static utakusaidia kupanga hooks/patches na kuzingatia njia sahihi za msimbo.

Tool: SSLPinDetect
- Open-source static-analysis utility ambayo inadecompile APK hadi Smali (kwa apktool) na inascan kwa curated regex patterns za implementations za SSL/TLS pinning.
- Inaripoti path kamili ya faili, nambari ya mstari, na kipande cha msimbo kwa kila match.
- Inashughulikia frameworks zinazotumika na code paths maalum: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Matumizi
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Mfano wa kanuni za pattern (JSON)
Tumia au ongeza signatures ili kugundua proprietary/custom pinning styles. Unaweza kupakia JSON yako mwenyewe na scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- Fast scanning on large apps via multi-threading and memory-mapped I/O; pre-compiled regex reduces overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typical detection targets to triage next:
- OkHttp: matumizi ya CertificatePinner, setCertificatePinner, marejeo ya package okhttp3/okhttp
- TrustManagers maalum: javax.net.ssl.X509TrustManager, overrides za checkServerTrusted
- SSL contexts maalum: SSLContext.getInstance + SSLContext.init na managers maalum
- Declarative pins katika res/xml network security config na marejeo kwenye manifest
- Tumia maeneo yaliyoendana kupanga Frida hooks, static patches, au mapitio ya config kabla ya dynamic testing.



#### Kuvuka SSL Pinning

When SSL Pinning is implemented, bypassing it becomes necessary to inspect HTTPS traffic. Various methods are available for this purpose:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Ni muhimu pia kutafuta udhaifu wa kawaida wa wavuti ndani ya application. Maelezo ya kina juu ya utambuzi na kupunguza udhaifu huu yapo nje ya muhtasari huu lakini yameelezewa kwa kina mahali pengine.

### Frida

[Frida](https://www.frida.re) is a dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.\
**You can access running application and hook methods on run time to change the behaviour, change values, extract values, run different code...**\
If you want to pentest Android applications you need to know how to use Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Angalia kama application inahifadhi taarifa nyeti ndani ya memory ambazo haipaswi kuhifadhi kama passwords au mnemonics.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Hii itadump kumbukumbu katika folda ./dump, na huko unaweza kutumia grep kwa kitu kama:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Data nyeti katika Keystore**

Katika Android Keystore ni mahali bora pa kuhifadhi data nyeti, hata hivyo, kwa idhini za kutosha bado ni **inawezekana kuifikia**. Kwa kuwa programu zinaelekea kuhifadhi hapa **data nyeti kwa maandishi wazi**, pentests zinapaswa kuikagua kwa root user au mtu mwenye ufikiaji wa kimwili wa kifaa ambaye anaweza kuiba data hii.

Hata kama app ilihifadhi data katika keystore, data inapaswa kusimbwa.

Ili kufikia data ndani ya keystore unaweza kutumia Frida script hii: https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Kutumia Frida script ifuatayo, inaweza kuwa inawezekana **bypass fingerprint authentication** ambayo programu za Android zinaweza kufanya ili **kulinda maeneo fulani nyeti:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Picha za Mandharinyuma**

Unapoweka programu kwenye mandharinyuma, Android huhifadhi **snapshot ya programu**, hivyo inaporejeshwa kwenye foreground inaanza kupakia picha kabla ya programu ili ionekane kama ilipakuliwa haraka.

Hata hivyo, ikiwa snapshot hii ina **taarifa nyeti**, mtu mwenye ufikiaji wa snapshot anaweza **kuiba hizo taarifa** (kumbuka kwamba unahitaji root ili kuzifikia).

Snapshots kawaida huhifadhiwa karibu: **`/data/system_ce/0/snapshots`**

Android inatoa njia ya **kuzuia kuchukuliwa kwa screenshot kwa kuweka parameter ya layout FLAG_SECURE**. Kwa kutumia flag hii, yaliyomo kwenye dirisha yanachukuliwa kuwa salama, na hivyo kuzuia kuonekana kwenye screenshots au kutazamwa kwenye displays zisizo-salama.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Zana hii inaweza kukusaidia kusimamia zana tofauti wakati wa uchambuzi wa kimitambo (dynamic analysis): [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Waundaji mara nyingi huunda komponenti za proxy kama activities, services, na broadcast receivers ambazo hushughulikia Intent hizi na kuzipitisha kwa njia kama `startActivity(...)` au `sendBroadcast(...)`, jambo ambalo linaweza kuwa hatari.

Hatari iko katika kuruhusu wadukuzi kuchochea non-exported app components au kupata sensitive content providers kwa kuelekeza vibaya Intent hizi. Mfano wa kuzingatia ni `WebView` kubadilisha URLs kuwa vitu vya `Intent` kupitia `Intent.parseUri(...)` na kisha kuvitekeleza, jambo ambalo linaweza kusababisha malicious Intent injections.

### Hitimisho Muhimu

- **Intent Injection** ni sawa na tatizo la Open Redirect kwenye web.
- Udanganyifu unaohusisha kupitisha vitu vya `Intent` kama extras, ambavyo vinaweza kuelekezwa tena ili kutekeleza operesheni zisizo salama.
- Inaweza kufunua non-exported components na content providers kwa wadukuzi.
- U-badilishaji wa URL kuwa `Intent` katika `WebView` unaweza kuwezesha vitendo visivyokusudiwa.

### Android Client Side Injections and others

Huenda tayari unafahamu aina hizi za udhaifu kutoka kwenye Web. Lazima kuwa mwangalifu sana na udhaifu hivi katika programu ya Android:

- **SQL Injection:** Wakati wa kushughulikia queries zinazobadilika au Content-Providers, hakikisha unatumia parameterized queries.
- **JavaScript Injection (XSS):** Hakikisha JavaScript na Plugin support imezimwa kwa WebViews yoyote (imezimwa kwa default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews zinafaa kuzuia access to the file system (imewezeshwa kwa default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Katika kesi kadhaa programu ya android inapomaliza session cookie haifutwi au inaweza hata kuhifadhiwa kwenye disk
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF pia inakuwezesha kufanya **diff/Compare** analysis na kuunganishwa na **VirusTotal** (utahitaji kuweka API key yako katika _MobSF/settings.py_ na kuifungua: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Unaweza pia kuweka `VT_UPLOAD` kuwa `False`, basi **hash** itakuwa **upload** badala ya faili.

### Assisted Dynamic analysis with MobSF

**MobSF** pia inaweza kuwa msaada mkubwa kwa ajili ya **dynamic analysis** kwenye **Android**, lakini katika kesi hiyo utahitaji kusanidi MobSF na **genymotion** kwenye host yako (VM au Docker hazitafanyi kazi). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** inaweza:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Yote haya hufanyika kiotomatiki isipokuwa kwa screenshots; unahitaji ku-bonyeza unapohitaji screenshot au unahitaji ku-bonyeza "**Exported Activity Tester**" ili kupata screenshots za activities zote zilizoexportiwa.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Kuanzia android **versions > 5**, itaanzisha **Frida** kiotomatiki na itaweka mipangilio ya **proxy** ya global ili **capture** traffic. Itachukua tu traffic kutoka kwa application inayochambuliwa.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF pia inaweza **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF pia inakuwezesha kupakia **Frida scripts** zako mwenyewe (kama utatumia function `send()` kutuma matokeo ya Frida scripts zako kwa MobSF). Pia ina **several pre-written scripts** unaweza kupakia (unaweza kuongeza zaidi katika `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), chagua tu, bonyeza "**Load**" na bonyeza "**Start Instrumentation**" (utaweza kuona logs za script hizo ndani ya "**Frida Live Logs**").

![](<../../images/image (419).png>)

Zaidi ya hayo, una baadhi ya Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Mara utakapochagua module ya ziada unayotaka kutumia unahitaji kubonyeza "**Start Intrumentation**" na utaona matokeo yote katika "**Frida Live Logs**".

**Shell**

Mobsf pia inakuleta shell yenye baadhi ya amri za **adb**, **MobSF commands**, na amri za kawaida za **shell** kwenye sehemu ya chini ya ukurasa wa dynamic analysis. Baadhi ya amri za kuvutia:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Zana za HTTP**

Wakati traffic ya http inapokamatwa unaweza kuona mtazamo mbaya wa traffic iliyokamatwa kwenye kitufe cha "**HTTP(S) Traffic**" au mtazamo mzuri kwenye kitufe cha kijani "**Start HTTPTools**". Kutoka chaguo la pili, unaweza **kutuma** **maombi yaliyokamatwa** kwa **proxies** kama Burp au Owasp ZAP.\
Ili kufanya hivyo, _washa Burp -->_ _zima Intercept --> katika MobSB HTTPTools chagua request_ --> bonyeza "**Send to Fuzzer**" --> _chagua anwani ya proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Mara tu umemaliza dynamic analysis na MobSF unaweza kubonyeza "**Start Web API Fuzzer**" ili **fuzz http requests** na kutafuta udhaifu.

> [!TIP]
> Baada ya kufanya dynamic analysis na MobSF mipangilio ya proxy inaweza kuwa imepangwa vibaya na huwezi kuirekebisha kutoka GUI. Unaweza kurekebisha mipangilio ya proxy kwa kufanya:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Unaweza kupata zana kutoka [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Zana hii itatumia baadhi ya **Hooks** kukufahamisha **nini kinaendelea ndani ya application** wakati unafanya **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Hii ni **zana nzuri ya kufanya static analysis kwa GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Zana hii imeundwa kutafuta maeneo mbalimbali ya **security related Android application vulnerabilities**, iwe katika **source code** au **packaged APKs**. Zana pia ina uwezo wa **kuunda a "Proof-of-Concept" deployable APK** na **ADB commands**, ili kutekeleza baadhi ya vulnerabilities zilizopatikana (Exposed activities, intents, tapjacking...). Kama ilivyo kwa Drozer, hakuna haja ya ku-root kifaa cha mtihani.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Inaonyesha faili zote zilizochimbuliwa kwa rejea rahisi
- Inafanya decompile moja kwa moja ya APK files hadi Java na Smali format
- Huchambua AndroidManifest.xml kwa vulnerabilities za kawaida na tabia
- Static source code analysis kwa vulnerabilities za kawaida na tabia
- Taarifa za kifaa
- na mengine mengi
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER ni programu ya mstari wa amri inayoweza kutumika kwenye Windows, MacOS X na Linux, ambayo inachambua faili za _.apk_ kwa kutafuta udhaifu. Inafanya hivyo kwa kufungua APKs na kutumia mfululizo wa sheria kugundua udhaifu hizo.

Sheria zote ziko kwenye faili la `rules.json`, na kila kampuni au mtapimaji anaweza kuunda sheria zake ili kuchambua wanachohitaji.

Pakua binaries za hivi karibuni kutoka kwenye [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn ni zana ya **crossplatform** inayowasaidia waendelezaji, bugbounty hunters na ethical hackers wanaofanya [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) kwenye programu za rununu.

Dhana ni kwamba unaburuta na kuachia (drag and drop) faili ya programu yako ya rununu (faili ya .apk au .ipa) kwenye programu ya StaCoAn na itatengeneza ripoti ya kuona na inayobebeka kwa ajili yako. Unaweza kurekebisha settings na wordlists kupata uzoefu uliobinafsishwa.

Pakua[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework ni mfumo wa uchambuzi wa udhaifu wa Android unaosaidia waendelezaji au hackers kutafuta udhaifu za usalama zinazowezekana katika programu za Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** ni zana yenye lengo kuu la kugundua na kuwaonya watumiaji kuhusu tabia hatari zinazoweza kutendeka katika programu ya Android.

Ugunduzi unafanywa kwa kutumia **static analysis** ya Dalvik bytecode ya programu, iliyoonyeshwa kama **Smali**, kwa kutumia maktaba ya [`androguard`](https://github.com/androguard/androguard).

Zana hii inatafuta **tabia za kawaida za programu "mbaya"** kama: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Ni zana inayoweka pamoja zana zinazotumika sana za reverse engineering na analysis za mobile application, kusaidia katika kujaribu programu za rununu dhidi ya tishio za usalama za OWASP. Lengo lake ni kufanya kazi hii iwe rahisi na rafiki kwa waendelezaji wa programu za rununu na wataalamu wa usalama.

Ina uwezo wa:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Toka private information kutoka APK kwa kutumia regexps.
- Chambua Manifest.
- Chambua domains zilizopatikana kwa kutumia: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Useful to detect malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Kumbuka kwamba, kutegemea huduma na usanidi utakao tumia kuficha msimbo, secrets zinaweza kuwa zimefichwa au zisifichwe.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Inaweza kuboresha bytecode pamoja na kugundua na kuondoa maagizo yasiyotumika. ProGuard ni programu ya bure na inasambazwa chini ya GNU General Public License, version 2.

ProGuard inasambazwa kama sehemu ya Android SDK na inaendesha wakati wa kujenga application katika release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Pata mwongozo hatua kwa hatua wa ku-deobfuscate apk katika [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- pakia resource kama InputStream;
- pitisha matokeo kwa class inayoirithi kutoka FilterInputStream ili ku-decrypt;
- fanya obfuscation isiyo na maana ili kumwudhiwa reverser kwa muda;
- pitisha result iliyodecrypted kwa ZipInputStream ili kupata faili la DEX;
- hatimaye pokea DEX iliyopatikana kama Resource kwa kutumia method ya `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Unaweza kupakia APK iliyofichwa kwenye jukwaa lao.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Hii ni zana ya LLM ya kutafuta potential security vulnerabilities katika android apps na ku-deobfuscate code ya android app. Inatumia Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Ni **generic android deobfuscator.** Simplify **virtually executes an app** ili kuelewa tabia yake kisha **hujaribu kuboresha msimbo** ili ufanye kazi sawasawa lakini uwe rahisi kwa mwanadamu kuufahamu. Kila aina ya optimization ni rahisi na generic, kwa hivyo haijalishi ni aina gani ya obfuscation ilitumika.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD inakupa taarifa kuhusu **jinsi APK ilivyotengenezwa**. Inatambua compilers nyingi, packers, obfuscators, na mambo mengine ya ajabu. Ni [_PEiD_](https://www.aldeid.com/wiki/PEiD) kwa Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b ni mashine halisi ya usalama ya Android inayotegemea ubuntu-mate inayojumuisha mkusanyiko wa frameworks za hivi punde, tutorials na maabara kutoka kwa wanageek wa usalama na watafiti kwa ajili ya reverse engineering na malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Ni orodha nzuri ya rasilimali
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
