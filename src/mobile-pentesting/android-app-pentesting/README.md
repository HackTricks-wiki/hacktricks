# Pentesting de Aplicações Android

{{#include ../../banners/hacktricks-training.md}}

## Noções Básicas de Aplicações Android

É altamente recomendável começar lendo esta página para conhecer as **partes mais importantes relacionadas à segurança Android e os componentes mais perigosos em uma aplicação Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta é a ferramenta principal que você precisa para conectar-se a um dispositivo android (emulado ou físico).\
**ADB** permite controlar dispositivos tanto por **USB** quanto por **rede** a partir de um computador. Esta utilidade possibilita a **cópia** de arquivos em ambas as direções, **instalação** e **desinstalação** de apps, **execução** de comandos de shell, **backup** de dados, **leitura** de logs, entre outras funções.

Consulte a seguinte lista de [**ADB Commands**](adb-commands.md) para aprender como usar o adb.

## Smali

Às vezes é interessante **modificar o código da aplicação** para acessar **informações ocultas** (talvez senhas bem ofuscadas ou flags). Então, pode ser interessante decompilar o apk, modificar o código e recompilar.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Isso pode ser muito útil como uma **alternativa para vários testes durante a análise dinâmica** que serão apresentados. Então, **mantenha sempre essa possibilidade em mente**.

## Outros truques interessantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extrair APK do dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Mescle todos os splits e base apks com [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Estudos de Caso & Vulnerabilidades


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Análise Estática

First of all, for analysing an APK you should **take a look to the to the Java code** using a decompiler.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Procurando informações interessantes

Just taking a look to the **strings** of the APK you can search for **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** and anything interesting... look even for code execution **backdoors** or authentication backdoors (hardcoded admin credentials to the app).

**Firebase**

Pay special attention to **firebase URLs** and check if it is bad configured. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

A **examinação do _Manifest.xml_ e **_strings.xml_** de uma aplicação pode revelar potenciais vulnerabilidades de segurança**. These files can be accessed using decompilers or by renaming the APK file extension to .zip and then unzipping it.

**Vulnerabilities** identified from the **Manifest.xml** include:

- **Debuggable Applications**: Aplicações definidas como debuggable (`debuggable="true"`) no _Manifest.xml_ representam um risco, pois permitem conexões que podem levar à exploração. Para entender melhor como explorar aplicações debuggable, consulte um tutorial sobre encontrar e explorar debuggable applications on a device.
- **Backup Settings**: O atributo `android:allowBackup="false"` deve ser explicitamente definido para aplicações que lidam com informações sensíveis para evitar backups de dados não autorizados via adb, especialmente quando usb debugging está ativado.
- **Network Security**: Configurações customizadas de network security (`android:networkSecurityConfig="@xml/network_security_config"`) em _res/xml/_ podem especificar detalhes de segurança como certificate pins e configurações de tráfego HTTP. Um exemplo é permitir tráfego HTTP para domínios específicos.
- **Exported Activities and Services**: Identificar activities e services exported no manifest pode destacar componentes que podem ser mal utilizados. Análises adicionais durante testes dinâmicos podem revelar como explorar esses componentes.
- **Content Providers and FileProviders**: Content providers expostos podem permitir acesso não autorizado ou modificação de dados. A configuração de FileProviders também deve ser minuciosamente verificada.
- **Broadcast Receivers and URL Schemes**: Esses componentes podem ser aproveitados para exploração, com atenção especial a como os URL schemes são gerenciados para vulnerabilidades de input.
- **SDK Versions**: Os atributos `minSdkVersion`, `targetSDKVersion`, e `maxSdkVersion` indicam as versões Android suportadas, ressaltando a importância de não suportar versões Android desatualizadas e vulneráveis por motivos de segurança.

From the **strings.xml** file, sensitive information such as API keys, custom schemas, and other developer notes can be discovered, underscoring the need for careful review of these resources.

### Tapjacking

**Tapjacking** é um ataque onde uma **aplicação** **maliciosa** é iniciada e **se posiciona sobre uma aplicação vítima**. Once it visibly obscures the victim app, its user interface is designed in such a way as to trick the user to interact with it, while it is passing the interaction along to the victim app.\
In effect, it is **blinding the user from knowing they are actually performing actions on the victim app**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

An **activity** with the **`launchMode`** set to **`singleTask` without any `taskAffinity`** defined is vulnerable to task Hijacking. Isso significa que uma **application** pode ser instalada e, se iniciada antes da aplicação real, ela pode **hijack the task of the real application** (so the user will be interacting with the **malicious application thinking he is using the real one**).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

In Android, files **stored** in **internal** storage are **designed** to be **accessible** exclusively by the **app** that **created** them. This security measure is **enforced** by the Android operating system and is generally adequate for the security needs of most applications. However, developers sometimes utilize modes such as `MODE_WORLD_READABLE` and `MODE_WORLD_WRITABLE` to **allow** files to be **shared** between different applications. Yet, these modes **do not restrict access** to these files by other applications, including potentially malicious ones.

1. **Static Analysis:**
- **Ensure** that the use of `MODE_WORLD_READABLE` and `MODE_WORLD_WRITABLE` is **carefully scrutinized**. These modes **can potentially expose** files to **unintended or unauthorized access**.
2. **Dynamic Analysis:**
- **Verify** the **permissions** set on files created by the app. Specifically, **check** if any files are **set to be readable or writable worldwide**. This can pose a significant security risk, as it would allow **any application** installed on the device, regardless of its origin or intent, to **read or modify** these files.

**External Storage**

When dealing with files on **external storage**, such as SD Cards, certain precautions should be taken:

1. **Accessibility**:
- Files on external storage are **globally readable and writable**. This means any application or user can access these files.
2. **Security Concerns**:
- Given the ease of access, it's advised **not to store sensitive information** on external storage.
- External storage can be removed or accessed by any application, making it less secure.
3. **Handling Data from External Storage**:
- Always **perform input validation** on data retrieved from external storage. This is crucial because the data is from an untrusted source.
- Storing executables or class files on external storage for dynamic loading is strongly discouraged.
- If your application must retrieve executable files from external storage, ensure these files are **signed and cryptographically verified** before they are dynamically loaded. This step is vital for maintaining the security integrity of your application.

External storage can be **accessed** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android allow to each application to easily save xml files in the path `/data/data/<packagename>/shared_prefs/` and sometimes it's possible to find sensitive information in clear-text in that folder.
- **Databases**: Android allow to each application to easily save sqlite databases in the path `/data/data/<packagename>/databases/` and sometimes it's possible to find sensitive information in clear-text in that folder.

### Broken TLS

**Accept All Certificates**

For some reason sometimes developers accept all the certificates even if for example the hostname does not match with lines of code like the following one:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Criptografia Quebrada

**Processos fracos de gerenciamento de chaves**

Alguns desenvolvedores salvam dados sensíveis no armazenamento local e os encriptam com uma chave hardcoded/predictable no código. Isso não deve ser feito, pois alguma engenharia reversa pode permitir que atacantes extraiam a informação confidencial.

**Uso de algoritmos inseguros e/ou obsoletos**

Os desenvolvedores não devem usar **deprecated algorithms** para realizar **checks** de autorização, **armazenar** ou **enviar** dados. Alguns desses algoritmos são: RC4, MD4, MD5, SHA1... Se **hashes** forem usados para armazenar senhas, por exemplo, devem-se usar hashes resistentes a força-bruta com salt.

### Outras verificações

- Recomenda-se **ofuscar o APK** para dificultar o trabalho de engenharia reversa para os atacantes.
- Se o app for sensível (como apps bancários), ele deve realizar suas **próprias verificações para detectar se o dispositivo está rootado** e agir em consequência.
- Se o app for sensível (como apps bancários), ele deve verificar se um **emulador** está sendo usado.
- Se o app for sensível (como apps bancários), ele deve **verificar sua própria integridade antes de executar** para checar se foi modificado.
- Use [**APKiD**](https://github.com/rednaga/APKiD) para verificar qual compiler/packer/obfuscator foi usado para construir o APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. Esta ferramenta contém uma série de 'sources' conhecidas (que indicam à ferramenta os locais onde a entrada é controlada pelo usuário), 'sinks' (que indicam locais perigosos onde entradas maliciosas podem causar danos) e **regras**. Essas regras indicam a **combinação** de **sources-sinks** que caracteriza uma vulnerabilidade.

Com esse conhecimento, **mariana-trench irá revisar o código e encontrar possíveis vulnerabilidades nele**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Outras funções interessantes

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Outros truques**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Análise Dinâmica

> Primeiro de tudo, você precisa de um ambiente onde possa instalar a aplicação e todo o ambiente (Burp CA cert, Drozer and Frida principalmente). Portanto, um dispositivo com root (emulado ou não) é altamente recomendado.

### Análise dinâmica online

Você pode criar uma **conta gratuita** em: [https://appetize.io/](https://appetize.io). Esta plataforma permite **upload** e **execução** de APKs, sendo útil para ver como um apk está se comportando.

Você pode até **ver os logs da sua aplicação** na web e conectar através de **adb**.

![](<../../images/image (831).png>)

Graças à conexão ADB você pode usar **Drozer** e **Frida** dentro dos emuladores.

### Análise Dinâmica Local

#### Usando um emulador

- [**Android Studio**](https://developer.android.com/studio) (Você pode criar dispositivos **x86** e **arm**, e de acordo com [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**as últimas versões x86** **suportam ARM libraries** sem precisar de um emulador ARM lento).
- Aprenda a configurá-lo nesta página:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(versão gratuita:** Personal Edition, é necessário criar uma conta. _É recomendado **baixar** a versão **COM**_ _**VirtualBox** para evitar possíveis erros._)
- [**Nox**](https://es.bignox.com) (Gratuito, mas não suporta Frida ou Drozer).

> [!TIP]
> Ao criar um novo emulador em qualquer plataforma lembre-se de que quanto maior a tela, mais lento o emulador irá rodar. Portanto selecione telas pequenas se possível.

Para **instalar os serviços do Google** (como AppStore) no Genymotion você precisa clicar no botão marcado em vermelho na imagem a seguir:

![](<../../images/image (277).png>)

Além disso, repare que na **configuração da VM Android no Genymotion** você pode selecionar o modo **Bridge Network** (isso será útil se você for conectar na VM Android a partir de uma VM diferente com as ferramentas).

#### Usar um dispositivo físico

Você precisa ativar as opções de **debugging** e será interessante se você puder **rootear** o dispositivo:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Volte e você encontrará as **Developer options**.

> Depois de instalar a aplicação, a primeira coisa que você deve fazer é testá-la, investigar o que ela faz, como funciona e se familiarizar com ela.\
> Sugiro **realizar esta análise dinâmica inicial usando MobSF dynamic analysis + pidcat**, assim poderemos **aprender como a aplicação funciona** enquanto o MobSF **captura** muitos dados **interessantes** que você poderá revisar depois.

Magisk/Zygisk quick notes (recomendado em dispositivos Pixel)
- Patch boot.img com o app Magisk e flash via fastboot para obter root systemless
- Habilite Zygisk + DenyList para ocultar root; considere LSPosed/Shamiko quando for necessário um ocultamento mais forte
- Mantenha o boot.img original para recuperar de atualizações OTA; re-patche após cada OTA
- Para espelhamento de tela, use scrcpy no host



### Vazamento de dados não intencional

**Logging**

Os desenvolvedores devem ter cautela ao expor **informações de debugging** publicamente, pois isso pode levar a vazamentos de dados sensíveis. As ferramentas [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` são recomendadas para monitorar os logs da aplicação e identificar/proteger informações sensíveis. **Pidcat** é preferida por sua facilidade de uso e legibilidade.

> [!WARNING]
> Note que a partir de **versões posteriores ao Android 4.0**, **as aplicações só conseguem acessar seus próprios logs**. Então aplicações não podem acessar os logs de outros apps.\
> De qualquer forma, ainda é recomendado **não registrar informações sensíveis**.

**Cache da área de transferência (Copy/Paste)**

O framework baseado em **clipboard** do Android permite a funcionalidade de copiar/colar em apps, mas representa um risco pois **outras aplicações** podem **acessar** o clipboard, expondo potencialmente dados sensíveis. É crucial **desabilitar funções de copia/cola** para seções sensíveis de um aplicativo, como dados de cartão de crédito, para prevenir vazamentos.

**Crash Logs**

Se uma aplicação **crasha** e **salva logs**, esses logs podem auxiliar atacantes, especialmente quando a aplicação não pode ser facilmente revertida. Para mitigar esse risco, evite logar em crashes e, se os logs precisarem ser transmitidos pela rede, garanta que sejam enviados via um canal SSL.

Como pentester, **tente dar uma olhada nesses logs**.

**Analytics Data Sent To 3rd Parties**

Aplicações frequentemente integram serviços como Google Adsense, que podem inadvertidamente **vazar dados sensíveis** devido a implementação incorreta pelos desenvolvedores. Para identificar possíveis vazamentos, é aconselhável **interceptar o tráfego da aplicação** e checar se alguma informação sensível está sendo enviada para serviços de terceiros.

### SQLite DBs

A maioria das aplicações irá usar **bancos SQLite internos** para salvar informações. Durante o pentest observe os **bancos de dados** criados, os nomes das **tabelas** e **colunas** e todos os **dados** salvos porque você pode encontrar **informações sensíveis** (o que seria uma vulnerabilidade).\
Os bancos de dados devem estar localizados em `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`

Se o banco de dados estiver salvando informação confidencial e for **encrypted** mas você conseguir **encontrar** a **senha** dentro da aplicação, ainda assim é uma **vulnerabilidade**.

Enumere as tabelas usando `.tables` e enumere as colunas das tabelas usando `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer é uma ferramenta útil para **explorar activities exportadas, serviços exportados e Content Providers** como você aprenderá nas seções seguintes.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Lembre-se também que o código de uma activity começa no método **`onCreate`**.

**Authorisation bypass**

Quando uma Activity está exportada você pode invocar sua tela a partir de um app externo. Portanto, se uma activity com **informação sensível** estiver **exportada** você poderia **contornar** os mecanismos de **autenticação** para acessá-la.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Você também pode iniciar uma activity exportada via adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF detectará como malicioso o uso de _**singleTask/singleInstance**_ como `android:launchMode` em uma activity, mas devido a [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), aparentemente isso é perigoso apenas em versões antigas (versões de API < 21).

> [!TIP]
> Observe que um bypass de autorização nem sempre é uma vulnerabilidade; depende de como o bypass funciona e quais informações são expostas.

**Vazamento de informações sensíveis**

**Activities can also return results**. Se você conseguir encontrar uma activity exportada e desprotegida que chame o método **`setResult`** e **retorne informações sensíveis**, há um vazamento de informações sensíveis.

#### Tapjacking

Se o Tapjacking não for prevenido, você pode abusar da activity exportada para fazer o **usuário realizar ações inesperadas**. Para mais informações sobre [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Acessando e manipulando informações sensíveis

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers são basicamente usados para **compartilhar dados**. Se um app tiver content providers disponíveis, você pode ser capaz de **extrair dados sensíveis** deles. Também é interessante testar possíveis **SQL injections** e **Path Traversals**, pois eles podem ser vulneráveis.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Lembre-se que as ações de um Service começam no método `onStartCommand`.

O Service é basicamente algo que **pode receber dados**, **processá-los** e **retornar** (ou não) uma resposta. Então, se uma aplicação exporta alguns services você deve **verificar** o **código** para entender o que ele está fazendo e **testá-lo** **dinamicamente** para extrair informações confidenciais, contornar medidas de autenticação...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Lembre-se que as ações de um Broadcast Receiver começam no método `onReceive`.

Um Broadcast Receiver ficará à espera de um tipo de mensagem. Dependendo de como o receiver trata a mensagem, ele pode ser vulnerável.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Você pode procurar por deep links manualmente, usando ferramentas como MobSF ou scripts como [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Você pode **abrir** um declarado **scheme** usando **adb** ou um **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Observe que você pode **omitir o nome do pacote** e o dispositivo móvel chamará automaticamente o app que deve abrir esse link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código executado**

Para encontrar o **código que será executado no App**, vá para a activity chamada pelo deeplink e procure a função **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informação sensível**

Toda vez que encontrar um deep link verifique se **não está recebendo dados sensíveis (como senhas) via URL parameters**, porque qualquer outra aplicação poderia **se passsar pelo deep link e roubar esses dados!**

**Parâmetros no path**

Você **deve também verificar se algum deep link está usando um parâmetro dentro do path** da URL como: `https://api.example.com/v1/users/{username}`, nesse caso você pode forçar um path traversal acessando algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Note que se você encontrar os endpoints corretos dentro da aplicação pode ser possível causar um **Open Redirect** (se parte do path for usada como nome de domínio), **account takeover** (se você puder modificar detalhes de usuários sem CSRF token e o vuln endpoint usar o método correto) e qualquer outra vuln. Mais [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**Mais exemplos**

Um [interesting bug bounty report](https://hackerone.com/reports/855618) sobre links (_/.well-known/assetlinks.json_).

### Inspeção da Camada de Transporte e Falhas de Verificação

- **Certificates are not always inspected properly** por aplicações Android. É comum que essas aplicações ignorem warnings e aceitem certificados self-signed ou, em alguns casos, revertam para conexões HTTP.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, empregando cipher suites inseguros. Essa vulnerabilidade torna a conexão suscetível a ataques man-in-the-middle (MITM), permitindo que atacantes decifrem os dados.
- **Leakage of private information** é um risco quando aplicações se autenticam usando canais seguros mas depois comunicam-se por canais não seguros para outras transações. Essa abordagem falha em proteger dados sensíveis, como session cookies ou detalhes do usuário, contra interceptação por entidades maliciosas.

#### Verificação de Certificado

Vamos focar na **verificação de certificado**. A integridade do certificado do servidor deve ser verificada para aumentar a segurança. Isso é crucial porque configurações TLS inseguras e a transmissão de dados sensíveis por canais não criptografados podem apresentar riscos significativos. Para passos detalhados sobre verificação de certificados do servidor e correção de vulnerabilidades, [**este recurso**](https://manifestsecurity.com/android-application-security-part-10/) fornece orientação abrangente.

#### SSL Pinning

SSL Pinning é uma medida de segurança onde a aplicação verifica o certificado do servidor contra uma cópia conhecida armazenada dentro da própria aplicação. Esse método é essencial para prevenir ataques MITM. Implementar SSL Pinning é fortemente recomendado para aplicações que lidam com informação sensível.

#### Inspeção de Tráfego

Para inspecionar o tráfego HTTP, é necessário **instalar o certificado da ferramenta proxy** (por exemplo, Burp). Sem instalar esse certificado, o tráfego criptografado pode não ser visível através do proxy. Para um guia sobre como instalar um CA certificate customizado, [**clique aqui**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplicações alvo **API Level 24 and above** exigem modificações no Network Security Config para aceitar o CA certificate do proxy. Esse passo é crítico para inspecionar tráfego criptografado. Para instruções sobre como modificar o Network Security Config, [**consulte este tutorial**](make-apk-accept-ca-certificate.md).

Se **Flutter** estiver sendo usado, você precisa seguir as instruções em [**esta página**](flutter.md). Isso porque somente adicionar o certificado ao store não funcionará já que Flutter tem sua própria lista de CAs válidas.

#### Detecção estática de SSL/TLS pinning

Antes de tentar bypasses em runtime, mapeie rapidamente onde o pinning é imposto no APK. A descoberta estática ajuda a planejar hooks/patches e focar nos caminhos de código corretos.

Tool: SSLPinDetect
- Open-source static-analysis utility que decompila o APK para Smali (via apktool) e escaneia por padrões regex curados de implementações de SSL/TLS pinning.
- Reporta o caminho exato do arquivo, número da linha e um snippet de código para cada match.
- Cobre frameworks comuns e caminhos de código customizados: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init com custom TrustManagers/KeyManagers, e Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemplo de regras de padrões (JSON)
Use ou estenda signatures para detectar estilos proprietários/personalizados de pinning. Você pode carregar seu próprio JSON e escanear em larga escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notas e dicas
- Fast scanning on large apps via multi-threading and memory-mapped I/O; pre-compiled regex reduces overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Alvos típicos de detecção para triagem a seguir:
- OkHttp: uso de CertificatePinner, setCertificatePinner, referências aos pacotes okhttp3/okhttp
- TrustManagers personalizados: javax.net.ssl.X509TrustManager, overrides de checkServerTrusted
- Contextos SSL personalizados: SSLContext.getInstance + SSLContext.init com managers personalizados
- Pins declarativos em res/xml network security config e referências no manifest
- Use os locais correspondentes para planejar Frida hooks, patches estáticos, ou revisões de configuração antes do teste dinâmico.



#### Contornando SSL Pinning

When SSL Pinning is implemented, bypassing it becomes necessary to inspect HTTPS traffic. Various methods are available for this purpose:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Procurando Vulnerabilidades Web Comuns

It's important to also search for common web vulnerabilities within the application. Detailed information on identifying and mitigating these vulnerabilities is beyond the scope of this summary but is extensively covered elsewhere.

### Frida

[Frida](https://www.frida.re) é um toolkit de instrumentação dinâmica para desenvolvedores, analistas de engenharia reversa e pesquisadores de segurança.\
**Você pode acessar a aplicação em execução e hookar métodos em tempo de execução para alterar o comportamento, mudar valores, extrair valores, executar código diferente...**\
Se você quiser fazer pentesting em aplicações Android, precisa saber usar o Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Verifique se a aplicação está armazenando informações sensíveis na memória que não deveria, como senhas ou mnemônicos.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) você pode fazer o dump da memória do app com:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Isso fará o dump da memória na pasta ./dump, e lá você pode usar grep com algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dados sensíveis no Keystore**

No Android o Keystore é o melhor lugar para armazenar dados sensíveis, entretanto, com privilégios suficientes ainda é **possível acessá-lo**. Como aplicações tendem a armazenar aqui **dados sensíveis em texto claro**, os pentests devem verificar isso, pois um root user ou alguém com acesso físico ao dispositivo pode ser capaz de roubar esses dados.

Mesmo que um app armazene dados no keystore, os dados devem ser criptografados.

Para acessar os dados dentro do keystore você pode usar este script Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando o seguinte script Frida, pode ser possível **bypass fingerprint authentication** que aplicações Android podem realizar para **proteger certas áreas sensíveis:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imagens de fundo**

Quando você coloca um aplicativo em segundo plano, o Android armazena um **instantâneo do aplicativo** para que, quando for recuperado para o primeiro plano, comece a carregar a imagem antes do aplicativo, fazendo parecer que o aplicativo foi carregado mais rápido.

No entanto, se esse instantâneo contiver **informações sensíveis**, alguém com acesso ao instantâneo pode **roubar essas informações** (observe que você precisa de root para acessá-lo).

Os instantâneos geralmente são armazenados em: **`/data/system_ce/0/snapshots`**

O Android fornece uma maneira de **impedir a captura de screenshots definindo o parâmetro de layout FLAG_SECURE**. Ao usar essa flag, o conteúdo da janela é tratado como seguro, evitando que apareça em screenshots ou que seja visualizado em telas não seguras.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analisador de Aplicativos Android**

Esta ferramenta pode ajudá-lo a gerenciar diferentes ferramentas durante a análise dinâmica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Desenvolvedores frequentemente criam componentes proxy como activities, services, e broadcast receivers que manipulam esses Intents e os passam para métodos tais como `startActivity(...)` ou `sendBroadcast(...)`, o que pode ser arriscado.

O perigo reside em permitir que atacantes acionem componentes não-exportados do app ou acessem content providers sensíveis ao redirecionar esses Intents. Um exemplo notável é o componente `WebView` convertendo URLs em objetos `Intent` via `Intent.parseUri(...)` e então executando-os, o que pode levar a injeções de Intent maliciosas.

### Essential Takeaways

- **Intent Injection** é semelhante ao problema Open Redirect da web.
- Exploits envolvem passar objetos `Intent` como extras, que podem ser redirecionados para executar operações inseguras.
- Pode expor componentes não-exportados e content providers a atacantes.
- A conversão de URL para `Intent` do `WebView` pode facilitar ações não intencionais.

### Injeções no lado do cliente Android e outros

Provavelmente você conhece esse tipo de vulnerabilidade pela Web. Deve ter especial cuidado com essas vulnerabilidades em uma aplicação Android:

- **SQL Injection:** Ao lidar com consultas dinâmicas ou Content-Providers, assegure-se de usar consultas parametrizadas.
- **JavaScript Injection (XSS):** Verify that JavaScript and Plugin support is disabled for any WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews should have access to the file system disabled (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Em vários casos, quando a aplicação Android finaliza a sessão, o cookie não é revogado ou pode até ser salvo no disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Análise Automática

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análise estática**

![](<../../images/image (866).png>)

**Avaliação de vulnerabilidades da aplicação** usando um agradável frontend web. Você também pode realizar análise dinâmica (mas precisa preparar o ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF também permite fazer **diff/Compare** das análises e integrar o **VirusTotal** (você precisará definir sua API key em _MobSF/settings.py_ e habilitá-la: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Você também pode definir `VT_UPLOAD` para `False`, então o **hash** será **upload** em vez do arquivo.

### Assisted Dynamic analysis with MobSF

**MobSF** também pode ser muito útil para **dynamic analysis** em **Android**, mas nesse caso você precisará instalar MobSF e **genymotion** no seu host (uma VM ou Docker não funcionarão). _Nota: Você precisa primeiro iniciar uma VM no genymotion e depois o MobSF._\
O **MobSF dynamic analyser** pode:

- **Dump application data** (URLs, logs, clipboard, screenshots feitas por você, screenshots feitas pelo "**Exported Activity Tester**", emails, bancos de dados SQLite, arquivos XML e outros arquivos criados). Tudo isso é feito automaticamente, exceto as screenshots — você precisa pressionar quando quiser uma screenshot ou pressionar "**Exported Activity Tester**" para obter screenshots de todas as atividades exportadas.
- Capturar tráfego **HTTPS**
- Usar **Frida** para obter informações de **runtime**

Em versões Android > 5, ele irá iniciar o **Frida** automaticamente e definirá o **proxy** global para capturar o tráfego. Ele capturará apenas o tráfego da aplicação testada.

**Frida**

Por padrão, ele também usa alguns Frida Scripts para **bypass SSL pinning**, **root detection** e **debugger detection**, e para **monitor interesting APIs**.\
O MobSF também pode invocar **exported activities**, capturar **screenshots** dessas atividades e salvá-las para o relatório.

Para iniciar os testes dinâmicos pressione o botão verde: "**Start Instrumentation**". Pressione "**Frida Live Logs**" para ver os logs gerados pelos Frida scripts e "**Live API Monitor**" para ver todas as invocações aos métodos hooked, argumentos passados e valores retornados (isso aparecerá após pressionar "Start Instrumentation").\
O MobSF também permite carregar seus próprios **Frida scripts** (para enviar os resultados dos seus Friday scripts para o MobSF use a função `send()`). Ele também tem **vários scripts pré-escritos** que você pode carregar (você pode adicionar mais em `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), basta **selecioná-los**, pressionar "**Load**" e pressionar "**Start Instrumentation**" (você poderá ver os logs desses scripts dentro de "**Frida Live Logs**").

![](<../../images/image (419).png>)

Além disso, você tem algumas funcionalidades auxiliares do Frida:

- **Enumerate Loaded Classes**: Irá imprimir todas as classes carregadas
- **Capture Strings**: Irá imprimir todas as strings capturadas enquanto usa a aplicação (muito verboso)
- **Capture String Comparisons**: Pode ser muito útil. Irá **mostrar as 2 strings sendo comparadas** e se o resultado foi True ou False.
- **Enumerate Class Methods**: Coloque o nome da classe (como "java.io.File") e ele imprimirá todos os métodos da classe.
- **Search Class Pattern**: Buscar classes por padrão
- **Trace Class Methods**: **Trace** uma **classe inteira** (ver entradas e saídas de todos os métodos da classe). Lembre-se que por padrão o MobSF traça vários métodos interessantes da Android Api.

Depois de selecionar o módulo auxiliar que quer usar você precisa pressionar "**Start Intrumentation**" e verá todas as saídas em "**Frida Live Logs**".

**Shell**

O MobSF também inclui um shell com alguns comandos **adb**, comandos do **MobSF**, e comandos comuns de **shell** na parte inferior da página de análise dinâmica. Alguns comandos interessantes:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Ferramentas HTTP**

Quando o tráfego HTTP é capturado você pode ver uma visão feia do tráfego capturado no botão "**HTTP(S) Traffic**" ou uma visão mais agradável no botão verde "**Start HTTPTools**". A partir da segunda opção, você pode **enviar** as **captured requests** para **proxies** como Burp ou Owasp ZAP.\
Para isso, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> pressione "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Depois de terminar a análise dinâmica com MobSF você pode pressionar "**Start Web API Fuzzer**" para **fuzz http requests** e procurar vulnerabilidades.

> [!TIP]
> Após realizar uma análise dinâmica com MobSF as configurações de proxy podem ficar incorretas e você não conseguirá corrigi-las pela GUI. Você pode corrigir as configurações de proxy executando:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Você pode obter a ferramenta em [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta ferramenta usa alguns **Hooks** para mostrar **o que está acontecendo no aplicativo** enquanto você realiza uma **análise dinâmica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta é uma **excelente ferramenta para realizar static analysis com uma GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta ferramenta foi projetada para procurar várias **vulnerabilidades relacionadas à segurança** em aplicações Android, tanto no **source code** quanto em **packaged APKs**. A ferramenta também é **capaz de criar um "Proof-of-Concept" deployable APK** e **ADB commands**, para explorar algumas das vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Como com Drozer, não é necessário root no dispositivo de teste.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Exibe todos os arquivos extraídos para fácil referência
- Descompila automaticamente arquivos APK para os formatos Java e Smali
- Analisa o AndroidManifest.xml para vulnerabilidades e comportamentos comuns
- Análise estática de código-fonte para vulnerabilidades e comportamentos comuns
- Informações do dispositivo
- e mais
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER é uma aplicação de linha de comando que pode ser usada no Windows, MacOS X e Linux, que analisa arquivos _.apk_ em busca de vulnerabilidades. Faz isso descompactando APKs e aplicando uma série de regras para detectar essas vulnerabilidades.

Todas as regras estão centralizadas em um arquivo `rules.json`, e cada empresa ou testador pode criar suas próprias regras para analisar o que precisam.

Baixe os binários mais recentes na [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn é uma ferramenta **multiplataforma** que auxilia desenvolvedores, bugbounty hunters e ethical hackers na realização de [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) em aplicações móveis.

O conceito é que você arraste e solte seu arquivo de aplicativo móvel (um arquivo .apk ou .ipa) na aplicação StaCoAn e ela irá gerar um relatório visual e portátil para você. Você pode ajustar as configurações e wordlists para obter uma experiência personalizada.

Baixar[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework é um sistema de análise de vulnerabilidades para Android que ajuda desenvolvedores ou hackers a encontrar potenciais vulnerabilidades de segurança em aplicativos Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** é uma ferramenta cujo objetivo principal é detectar e alertar o usuário sobre potenciais comportamentos maliciosos desenvolvidos por uma aplicação Android.

A detecção é realizada por meio da **static analysis** do Dalvik bytecode da aplicação, representado como **Smali**, com a biblioteca [`androguard`](https://github.com/androguard/androguard).

Essa ferramenta procura por **common behavior of "bad" applications** like: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. É uma ferramenta que agrega ferramentas comumente usadas para reverse engineering e análise de aplicações móveis, para auxiliar nos testes de aplicações móveis contra as ameaças de segurança mobile da OWASP. Seu objetivo é tornar essa tarefa mais fácil e mais amigável para desenvolvedores de aplicações móveis e profissionais de segurança.

Ele é capaz de:

- Extrair código Java e Smali usando diferentes ferramentas
- Analisar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extrair informações privadas do APK usando regexps.
- Analisar o Manifest.
- Analisar os domínios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscar APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Observe que, dependendo do serviço e da configuração que você usa para ofuscar o código, segredos podem ou não acabar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** é uma ferramenta de linha de comando open source que reduz, otimiza e ofusca código Java. É capaz de otimizar bytecode assim como detectar e remover instruções não utilizadas. ProGuard é software livre e está distribuído sob a GNU General Public License, versão 2.

ProGuard é distribuído como parte do Android SDK e é executado ao construir a aplicação em modo release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- carregar um recurso como um InputStream;
- alimentar o resultado para uma classe que herda de FilterInputStream para descriptografá-lo;
- fazer alguma ofuscação inútil para gastar alguns minutos do tempo de um reverser;
- alimentar o resultado descriptografado para um ZipInputStream para obter um arquivo DEX;
- por fim carregar o DEX resultante como um Resource usando o método `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverte o processo de ofuscação realizado por ferramentas de ofuscação Android. Isso possibilita inúmeras análises de segurança, incluindo inspeção de código e identificação de bibliotecas.**

Você pode enviar um APK ofuscado para a plataforma deles.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Esta é uma ferramenta LLM para encontrar possíveis vulnerabilidades de segurança em apps android e deobfuscar o código de apps android. Usa a Google Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

É um **deofuscador android genérico.** Simplify **executa virtualmente um app** para entender seu comportamento e então **tenta otimizar o código** para que ele se comporte de forma idêntica, mas seja mais fácil para um humano entender. Cada tipo de otimização é simples e genérico, então não importa qual tipo específico de ofuscação foi usado.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD fornece informações sobre **como um APK foi feito**. Identifica muitos **compilers**, **packers**, **obfuscators**, e outras coisas estranhas. É o [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

[Leia este tutorial para aprender alguns truques sobre **como reverter ofuscação personalizada**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b é uma máquina virtual de segurança Android baseada em ubuntu-mate que inclui a coleção dos frameworks, tutoriais e labs mais recentes de diferentes geeks e pesquisadores de segurança para reverse engineering e análise de malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) É uma ótima lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Curso rápido de Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
