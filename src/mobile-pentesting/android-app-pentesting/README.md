# Aplicaciones Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Fundamentos de Aplicaciones Android

Se recomienda encarecidamente empezar leyendo esta página para conocer las **partes más importantes relacionadas con la seguridad de Android y los componentes más peligrosos en una aplicación Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta es la herramienta principal que necesitas para conectar un dispositivo Android (emulado o físico).\
**ADB** permite controlar dispositivos ya sea por **USB** o por **red** desde un ordenador. Esta utilidad permite el **copiado** de archivos en ambas direcciones, la **instalación** y **desinstalación** de apps, la **ejecución** de comandos shell, la **copia de seguridad** de datos, la **lectura** de logs, entre otras funciones.

Consulta la siguiente lista de [**ADB Commands**](adb-commands.md) para aprender a usar adb.

## Smali

A veces es interesante **modificar el código de la aplicación** para acceder a **información oculta** (tal vez contraseñas bien ofuscadas o flags). Entonces, podría ser útil descompilar el apk, modificar el código y recompilarlo.\
[**En este tutorial** puedes **aprender cómo descompilar un APK, modificar código Smali y recompilar el APK** con la nueva funcionalidad](smali-changes.md). Esto puede ser muy útil como una **alternativa para varias pruebas durante el análisis dinámico** que se van a presentar. Por tanto, **ten siempre presente esta posibilidad**.

## Otros trucos interesantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Descargar APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extraer APK del dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusiona todos los splits y base apks con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Estudios de caso y Vulnerabilidades


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Análisis Estático

Primero, para analizar un APK deberías **revisar el código Java** usando un decompiler.\
Por favor, [**lee aquí para encontrar información sobre los diferentes decompilers disponibles**](apk-decompilers.md).

### Buscando información interesante

Con solo revisar las **strings** del APK puedes buscar **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API** keys, **encryption**, **bluetooth UUIDs**, **tokens** y cualquier cosa interesante... busca incluso **backdoors** de ejecución de código o backdoors de autenticación (credenciales de admin hardcoded en la app).

**Firebase**

Presta especial atención a las **Firebase URLs** y verifica si está mal configurado. [Más información sobre qué es Firebase y cómo explotarlo aquí.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensión básica de la aplicación - Manifest.xml, strings.xml

El **examen del _Manifest.xml_ y los archivos _strings.xml_ de una aplicación puede revelar vulnerabilidades de seguridad potenciales**. Estos archivos pueden accederse usando decompilers o renombrando el archivo APK a .zip y descomprimiéndolo.

Las **vulnerabilidades** identificadas a partir del **Manifest.xml** incluyen:

- **Aplicaciones depurables**: Las aplicaciones marcadas como debuggable (`debuggable="true"`) en el _Manifest.xml_ representan un riesgo ya que permiten conexiones que pueden llevar a la explotación. Para entender mejor cómo explotar aplicaciones debuggable, consulta un tutorial sobre cómo encontrarlas y explotarlas en un dispositivo.
- **Ajustes de backup**: El atributo `android:allowBackup="false"` debería establecerse explícitamente para aplicaciones que manejan información sensible para evitar backups no autorizados vía adb, especialmente cuando usb debugging está habilitado.
- **Network Security**: Las configuraciones de seguridad de red personalizadas (`android:networkSecurityConfig="@xml/network_security_config"`) en _res/xml/_ pueden especificar detalles de seguridad como certificate pins y ajustes de tráfico HTTP. Un ejemplo es permitir tráfico HTTP para dominios específicos.
- **Actividades y Services exportados**: Identificar activities y services exportados en el manifest puede destacar componentes que podrían ser mal utilizados. Un análisis adicional durante pruebas dinámicas puede revelar cómo explotar estos componentes.
- **Content Providers y FileProviders**: Los content providers expuestos podrían permitir acceso o modificación no autorizada de datos. La configuración de FileProviders también debe ser examinada.
- **Broadcast Receivers y URL Schemes**: Estos componentes podrían aprovecharse para explotación, prestando especial atención a cómo se gestionan los URL schemes para vulnerabilidades de entrada.
- **Versiones de SDK**: Los atributos `minSdkVersion`, `targetSDKVersion` y `maxSdkVersion` indican las versiones de Android soportadas, lo que subraya la importancia de no soportar versiones antiguas y vulnerables de Android por razones de seguridad.

Desde el archivo **strings.xml**, se pueden descubrir datos sensibles como API keys, esquemas personalizados y otras notas del desarrollador, lo que enfatiza la necesidad de revisar cuidadosamente estos recursos.

### Tapjacking

**Tapjacking** es un ataque donde una **aplicación maliciosa** se lanza y **se posiciona encima de una aplicación víctima**. Una vez que oscurece visiblemente la app víctima, su interfaz está diseñada de forma que engaña al usuario para que interactúe con ella, mientras pasa la interacción a la app víctima.\
En efecto, está **cegando al usuario para que no sepa que en realidad está realizando acciones en la app víctima**.

Encuentra más información en:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Una **activity** con el **`launchMode`** establecido en **`singleTask` sin ningún `taskAffinity`** definido es vulnerable a task Hijacking. Esto significa que una **aplicación** puede ser instalada y, si se lanza antes que la aplicación real, podría **secuestrar la tarea de la aplicación real** (por lo que el usuario estará interactuando con la **aplicación maliciosa pensando que está usando la real**).

Más info en:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Almacenamiento de datos inseguro

**Internal Storage**

En Android, los archivos **almacenados** en el **internal storage** están **diseñados** para ser **accesibles** exclusivamente por la **app** que los **creó**. Esta medida de seguridad es **impuesta** por el sistema operativo Android y generalmente es adecuada para las necesidades de seguridad de la mayoría de las aplicaciones. Sin embargo, los desarrolladores a veces utilizan modos como `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` para **permitir** que los archivos sean **compartidos** entre diferentes aplicaciones. Aun así, estos modos **no restringen el acceso** a estos archivos por parte de otras aplicaciones, incluidas las potencialmente maliciosas.

1. **Análisis Estático:**
- **Comprueba** que el uso de `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` sea **minuciosamente revisado**. Estos modos **pueden exponer** archivos a **accesos no intencionados o no autorizados**.
2. **Análisis Dinámico:**
- **Verifica** los **permisos** establecidos en los archivos creados por la app. Específicamente, **revisa** si algún archivo está **configurado como readable o writable worldwide**. Esto puede suponer un riesgo de seguridad significativo, ya que permitiría a **cualquier aplicación** instalada en el dispositivo, independientemente de su origen o intención, **leer o modificar** dichos archivos.

**External Storage**

Al tratar con archivos en **external storage**, como SD Cards, se deben tomar ciertas precauciones:

1. **Accesibilidad**:
- Los archivos en external storage son **globalmente legibles y escribibles**. Esto significa que cualquier aplicación o usuario puede acceder a estos archivos.
2. **Preocupaciones de seguridad**:
- Dada la facilidad de acceso, se recomienda **no almacenar información sensible** en external storage.
- El external storage puede ser retirado o accedido por cualquier aplicación, haciéndolo menos seguro.
3. **Manejo de datos desde external storage**:
- Siempre **realiza validación de entrada** en los datos recuperados desde external storage. Esto es crucial porque los datos provienen de una fuente no confiable.
- Desaconsejado almacenar ejecutables o archivos de clase en external storage para carga dinámica.
- Si tu aplicación debe recuperar archivos ejecutables desde external storage, asegúrate de que estos archivos estén **firmados y verificados criptográficamente** antes de cargarlos dinámicamente. Este paso es vital para mantener la integridad de seguridad de tu aplicación.

External storage puede ser **accedido** en `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> A partir de Android 4.4 (**API 17**), la SD card tiene una estructura de directorios que **limita el acceso de una app al directorio que es específicamente para esa app**. Esto evita que aplicaciones maliciosas obtengan acceso de lectura o escritura a los archivos de otra app.

**Datos sensibles almacenados en texto claro**

- **Shared preferences**: Android permite a cada aplicación guardar fácilmente archivos xml en la ruta `/data/data/<packagename>/shared_prefs/` y a veces es posible encontrar información sensible en clear-text en esa carpeta.
- **Databases**: Android permite a cada aplicación guardar fácilmente bases de datos sqlite en la ruta `/data/data/<packagename>/databases/` y a veces es posible encontrar información sensible en clear-text en esa carpeta.

### Broken TLS

**Accept All Certificates**

Por alguna razón, a veces los desarrolladores aceptan todos los certificados incluso si, por ejemplo, el hostname no coincide con líneas de código como la siguiente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Una buena forma de probar esto es intentar capturar el tráfico usando algún proxy como Burp sin autorizar Burp CA dentro del dispositivo. También puedes generar con Burp un certificado para un hostname diferente y usarlo.

### Criptografía débil

**Procesos deficientes de gestión de claves**

Algunos desarrolladores guardan datos sensibles en el almacenamiento local y los encriptan con una clave hardcodeada/predictible en el código. Esto no debería hacerse ya que algo de ingeniería inversa podría permitir a los atacantes extraer la información confidencial.

**Uso de algoritmos inseguros y/o obsoletos**

Los desarrolladores no deberían usar **algoritmos obsoletos** para realizar comprobaciones de **autorización**, **almacenar** o **enviar** datos. Algunos de estos algoritmos son: RC4, MD4, MD5, SHA1... Si se usan **hashes** para almacenar contraseñas, por ejemplo, deberían usarse hashes resistentes a fuerza bruta junto con salt.

### Otras comprobaciones

- Se recomienda **ofuscar el APK** para dificultar el trabajo de ingeniería inversa a los atacantes.
- Si la app es sensible (como apps bancarias), debería realizar sus **propias comprobaciones para ver si el móvil está rooteado** y actuar en consecuencia.
- Si la app es sensible (como apps bancarias), debería comprobar si se está usando un **emulador**.
- Si la app es sensible (como apps bancarias), debería **comprobar su propia integridad antes de ejecutarse** para verificar si fue modificada.
- Usa [**APKiD**](https://github.com/rednaga/APKiD) para comprobar qué compiler/packer/obfuscator se usó para construir el APK

### Aplicación React Native

Lee la siguiente página para aprender cómo acceder fácilmente al código javascript de aplicaciones React:


{{#ref}}
react-native-application.md
{{#endref}}

### Aplicaciones Xamarin

Lee la siguiente página para aprender cómo acceder fácilmente al código C# de una aplicación Xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Aplicaciones Superpacked

Según este [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked es un algoritmo Meta que comprime el contenido de una aplicación en un único archivo. El blog habla sobre la posibilidad de crear una app que descomprima este tipo de apps... y una forma más rápida que implica **ejecutar la aplicación y recopilar los archivos descomprimidos desde el sistema de archivos.**

### Análisis estático automatizado de código

La herramienta [**mariana-trench**](https://github.com/facebook/mariana-trench) es capaz de encontrar **vulnerabilidades** escaneando el **código** de la aplicación. Esta herramienta contiene una serie de **known sources** (que indican a la herramienta los **lugares** donde la **entrada** es **controlada por el usuario**), **sinks** (que indican a la herramienta **lugares peligrosos** donde la entrada maliciosa podría causar daños) y **rules**. Estas reglas indican la **combinación** de **sources-sinks** que señala una vulnerabilidad.

Con este conocimiento, **mariana-trench revisará el código y encontrará posibles vulnerabilidades en él**.

### Secrets leaked

Una aplicación puede contener secrets (API keys, passwords, hidden urls, subdomains...) dentro de ella que podrías ser capaz de descubrir. Puedes usar una herramienta como [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Otras funciones interesantes

- **Ejecución de código**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Enviar SMS**: `sendTextMessage, sendMultipartTestMessage`
- **Funciones nativas** declaradas como `native`: `public native, System.loadLibrary, System.load`
- [Lee esto para aprender **cómo hacer ingeniería inversa de funciones nativas**](reversing-native-libraries.md)

### **Otros trucos**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Análisis dinámico

> Primero que nada, necesitas un entorno donde puedas instalar la aplicación y todo el entorno (Burp CA cert, Drozer y Frida principalmente). Por lo tanto, se recomienda encarecidamente un dispositivo rooteado (emulado o no).

### Análisis dinámico online

Puedes crear una **cuenta gratuita** en: [https://appetize.io/](https://appetize.io/). Esta plataforma te permite **subir** y **ejecutar** APKs, por lo que es útil para ver cómo se comporta un apk.

Incluso puedes **ver los logs de tu aplicación** en la web y conectarte mediante **adb**.

![](<../../images/image (831).png>)

Gracias a la conexión ADB puedes usar **Drozer** y **Frida** dentro de los emuladores.

### Análisis dinámico local

#### Usando un emulador

- [**Android Studio**](https://developer.android.com/studio) (Puedes crear dispositivos **x86** y **arm**, y según [**esta** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**las últimas** versiones **x86** **soportan librerías ARM** sin necesitar un emulador ARM lento).
- Aprende a configurarlo en esta página:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versión gratuita:** Personal Edition, necesitas crear una cuenta. _Se recomienda **descargar** la versión **CON**_ _**VirtualBox** para evitar errores potenciales._)
- [**Nox**](https://es.bignox.com) (Gratis, pero no soporta Frida ni Drozer).

> [!TIP]
> Al crear un nuevo emulador en cualquier plataforma recuerda que cuanto mayor sea la pantalla, más lento funcionará el emulador. Así que selecciona pantallas pequeñas si es posible.

Para **instalar google services** (como AppStore) en Genymotion necesitas hacer clic en el botón marcado en rojo de la siguiente imagen:

![](<../../images/image (277).png>)

Además, ten en cuenta que en la **configuración de la VM Android en Genymotion** puedes seleccionar **Bridge Network mode** (esto será útil si te vas a conectar a la VM Android desde otra VM con las herramientas).

#### Usar un dispositivo físico

Necesitas activar las opciones de **depuración** y sería ideal si puedes **rootearlo**:

1. **Configuración**.
2. (Desde Android 8.0) Selecciona **Sistema**.
3. Selecciona **Acerca del teléfono**.
4. Pulsa **Número de compilación** 7 veces.
5. Vuelve atrás y encontrarás las **Opciones de desarrollador**.

> Una vez que hayas instalado la aplicación, lo primero que deberías hacer es probarla e investigar qué hace, cómo funciona y familiarizarte con ella.\
> Te sugeriría **realizar este análisis dinámico inicial usando MobSF dynamic analysis + pidcat**, de modo que podamos **aprender cómo funciona la aplicación** mientras MobSF **captura** muchos **datos interesantes** que podrás revisar más tarde.

Magisk/Zygisk quick notes (recomendado en dispositivos Pixel)
- Parchea boot.img con la app Magisk y flashea vía fastboot para obtener root sin tocar el sistema
- Habilita Zygisk + DenyList para ocultar el root; considera LSPosed/Shamiko cuando se requiera ocultamiento más fuerte
- Mantén el boot.img original para recuperarte de actualizaciones OTA; vuelve a parchear después de cada OTA
- Para mirroring de pantalla, usa scrcpy en el host



### Filtración de datos no intencional

**Registro (Logging)**

Los desarrolladores deben tener cuidado de no exponer información de **depuración** públicamente, ya que puede conducir a filtraciones de datos sensibles. Se recomiendan las herramientas [**pidcat**](https://github.com/JakeWharton/pidcat) y `adb logcat` para monitorizar los logs de la aplicación e identificar y proteger información sensible. **Pidcat** se prefiere por su facilidad de uso y legibilidad.

> [!WARNING]
> Ten en cuenta que desde **versiones posteriores a Android 4.0**, **las aplicaciones sólo pueden acceder a sus propios logs**. Por lo tanto, las aplicaciones no pueden acceder a los logs de otras apps.\
> De todos modos, se recomienda **no registrar información sensible**.

**Caché del portapapeles (Copy/Paste Buffer Caching)**

El framework de Android basado en **portapapeles** permite la funcionalidad copiar/pegar en las apps, pero supone un riesgo ya que **otras aplicaciones** pueden **acceder** al portapapeles, exponiendo potencialmente datos sensibles. Es crucial **deshabilitar las funciones de copiar/pegar** para secciones sensibles de una aplicación, como los datos de tarjetas de crédito, para evitar filtraciones.

**Crash Logs**

Si una aplicación **se bloquea** y **guarda logs**, estos registros pueden ayudar a los atacantes, particularmente cuando la aplicación no puede ser sometida a ingeniería inversa. Para mitigar este riesgo, evita registrar información en los bloqueos y, si los logs deben transmitirse por la red, asegúrate de enviarlos a través de un canal SSL para seguridad.

Como pentester, **intenta revisar estos logs**.

**Datos de analítica enviados a terceros**

Las aplicaciones suelen integrar servicios como Google Adsense, que pueden filtrar información sensible de forma inadvertida debido a una implementación incorrecta por parte de los desarrolladores. Para identificar posibles filtraciones de datos, es aconsejable interceptar el tráfico de la aplicación y comprobar si se está enviando información sensible a servicios de terceros.

### SQLite DBs

La mayoría de las aplicaciones usarán **bases de datos SQLite internas** para guardar información. Durante el pentest revisa las **bases de datos** creadas, los nombres de **tablas** y **columnas** y todos los **datos** guardados porque podrías encontrar **información sensible** (lo que sería una vulnerabilidad).\
Las bases de datos deberían encontrarse en `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`

Si la base de datos guarda información confidencial y está **encriptada** pero puedes **encontrar** la **contraseña** dentro de la aplicación, sigue siendo una **vulnerabilidad**.

Enumera las tablas usando `.tables` y enumera las columnas de las tablas con `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** te permite **asumir el rol de una app Android** e interactuar con otras apps. Puede hacer **todo lo que una aplicación instalada puede hacer**, como utilizar el mecanismo de Inter-Process Communication (IPC) de Android e interactuar con el sistema operativo subyacente. .\
Drozer es una herramienta útil para **explotar exported activities, exported services y Content Providers** como aprenderás en las siguientes secciones.

### Exploitation de Activities exportadas

[**Lee esto si quieres repasar qué es una Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
También recuerda que el código de una Activity comienza en el método `onCreate`.

**Bypass de autorización**

Cuando una Activity está exportada puedes invocar su pantalla desde una app externa. Por lo tanto, si una activity con **información sensible** está **exportada** podrías **eludir** los mecanismos de **autenticación** para acceder a ella.

[**Aprende cómo explotar exported activities con Drozer.**](drozer-tutorial/index.html#activities)

También puedes iniciar una activity exportada desde adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF detectará como malicioso el uso de _**singleTask/singleInstance**_ como `android:launchMode` en una activity, pero debido a [esto](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), aparentemente esto solo es peligroso en versiones antiguas (API versions < 21).

> [!TIP]
> Ten en cuenta que un authorisation bypass no siempre es una vulnerabilidad; dependerá de cómo funcione el bypass y qué información se exponga.

**Filtración de información sensible**

**Activities can also return results**. Si logras encontrar una activity exportada y sin protección que llame al método **`setResult`** y **devuelva información sensible**, existe una filtración de información sensible.

#### Tapjacking

Si el tapjacking no se previene, podrías abusar de la activity exportada para hacer que el **usuario realice acciones inesperadas**. Para más info sobre [**qué es Tapjacking sigue el enlace**](#tapjacking).

### Exploiting Content Providers - Accediendo y manipulando información sensible

[**Lee esto si quieres repasar qué es un Content Provider.**](android-applications-basics.md#content-provider)\
Los Content Providers se usan básicamente para **compartir datos**. Si una app tiene Content Providers disponibles, podrías **extraer datos sensibles** de ellos. También es interesante probar posibles **SQL injections** y **Path Traversals**, ya que podrían ser vulnerables.

[**Aprende a explotar Content Providers con Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Lee esto si quieres repasar qué es un Service.**](android-applications-basics.md#services)\
Recuerda que las acciones de un Service comienzan en el método `onStartCommand`.

Un Service es básicamente algo que **puede recibir datos**, **procesarlos** y **devolver** (o no) una respuesta. Entonces, si una aplicación exporta algunos services deberías **revisar** el **código** para entender qué hace y **probarlo** **dinámicamente** para extraer info confidencial, bypassing authentication measures...\
[**Aprende a explotar Services con Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Lee esto si quieres repasar qué es un Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Recuerda que las acciones de un Broadcast Receiver comienzan en el método `onReceive`.

Un broadcast receiver estará esperando un tipo de mensaje. Dependiendo de cómo el receiver maneje el mensaje, podría ser vulnerable.\
[**Aprende a explotar Broadcast Receivers con Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Puedes buscar deep links manualmente, usando herramientas como MobSF o scripts como [este](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puedes **abrir** un **scheme** declarado usando **adb** o un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Ten en cuenta que puedes **omitir el nombre del paquete** y el dispositivo móvil llamará automáticamente a la app que debe abrir ese enlace._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

In order to find the **código que se ejecutará en la App**, go to the activity called by the deeplink and search the function **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informacion sensible**

Every time you find a deep link check that i**no esté recibiendo datos sensibles (como contraseñas) vía URL parameters**, because any other application could **impersonate the deep link and steal that data!**

**Parámetros en el path**

You **must check also if any deep link is using a parameter inside the path** of the URL like: `https://api.example.com/v1/users/{username}` , in that case you can force a path traversal accessing something like: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Note that if you find the correct endpoints inside the application you may be able to cause a **Open Redirect** (if part of the path is used as domain name), **account takeover** (if you can modify users details without CSRF token and the vuln endpoint used the correct method) and any other vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Los certificados no siempre se inspeccionan correctamente** por las aplicaciones Android. Es común que estas aplicaciones pasen por alto las advertencias y acepten self-signed certificates o, en algunos casos, vuelvan a usar conexiones HTTP.
- **Las negociaciones durante el handshake SSL/TLS a veces son débiles**, empleando suites de cifrado inseguras. Esta vulnerabilidad hace la conexión susceptible a ataques man-in-the-middle (MITM), permitiendo a los atacantes descifrar los datos.
- **Filtración de información privada** es un riesgo cuando las aplicaciones se autentican usando canales seguros pero luego se comunican por canales no seguros para otras transacciones. Este enfoque no protege datos sensibles, como cookies de sesión o detalles del usuario, de la interceptación por entidades maliciosas.

#### Certificate Verification

Nos centraremos en la **verificación de certificados**. La integridad del certificado del servidor debe verificarse para mejorar la seguridad. Esto es crucial porque las configuraciones TLS inseguras y la transmisión de datos sensibles por canales no cifrados pueden suponer riesgos significativos. For detailed steps on verifying server certificates and addressing vulnerabilities, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) provides comprehensive guidance.

#### SSL Pinning

SSL Pinning es una medida de seguridad en la que la aplicación verifica el certificado del servidor frente a una copia conocida almacenada dentro de la propia aplicación. Este método es esencial para prevenir ataques MITM. Se recomienda encarecidamente implementar SSL Pinning en aplicaciones que manejen información sensible.

#### Traffic Inspection

To inspect HTTP traffic, it's necessary to **install the proxy tool's certificate** (e.g., Burp). Without installing this certificate, encrypted traffic might not be visible through the proxy. For a guide on installing a custom CA certificate, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Applications targeting **API Level 24 and above** require modifications to the Network Security Config to accept the proxy's CA certificate. This step is critical for inspecting encrypted traffic. For instructions on modifying the Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). This is becasue, just adding the certificate into the store won't work as Flutter has its own list of valid CAs.

#### Static detection of SSL/TLS pinning

Antes de intentar bypasses en tiempo de ejecución, mapea rápidamente dónde se aplica el pinning en el APK. El descubrimiento estático te ayuda a planificar hooks/patches y a centrarte en las rutas de código correctas.

Tool: SSLPinDetect
- Utilidad de análisis estático de código abierto que decompila el APK a Smali (via apktool) y escanea patrones regex curados de implementaciones de SSL/TLS pinning.
- Informa la ruta exacta del archivo, número de línea y un fragmento de código para cada coincidencia.
- Cubre frameworks comunes y rutas de código personalizadas: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Requisitos previos: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Ejemplo de reglas de patrón (JSON)
Usa o extiende signatures para detectar estilos propietarios/personalizados de pinning. Puedes cargar tu propio JSON y escanear a gran escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notas y consejos
- Escaneo rápido en aplicaciones grandes mediante multi-threading y I/O mapeado en memoria; regex precompilados reducen la sobrecarga/falsos positivos.
- Colección de patrones: https://github.com/aancw/smali-sslpin-patterns
- Objetivos típicos de detección para priorizar a continuación:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Usa las ubicaciones coincidentes para planear Frida hooks, parches estáticos o revisiones de config antes de las pruebas dinámicas.



#### Evasión de SSL Pinning

When SSL Pinning is implemented, bypassing it becomes necessary to inspect HTTPS traffic. Various methods are available for this purpose:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Es importante también buscar vulnerabilidades web comunes dentro de la aplicación. La información detallada sobre cómo identificar y mitigar estas vulnerabilidades excede el alcance de este resumen, pero está ampliamente cubierta en otros recursos.

### Frida

[Frida](https://www.frida.re) is a dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.\
**Puedes acceder a la aplicación en ejecución y hacer hook a métodos en tiempo de ejecución para cambiar el comportamiento, modificar valores, extraer valores, ejecutar código diferente...**\
Si quieres pentestear aplicaciones Android necesitas saber cómo usar Frida.

- Aprende a usar Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Algunas GUI para acciones con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Objection es ideal para automatizar el uso de Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puedes encontrar algunos scripts Awesome de Frida aquí: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Intenta eludir mecanismos anti-debugging / anti-frida cargando Frida como se indica en [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (herramienta [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Volcado de memoria - Fridump**

Comprueba si la aplicación está almacenando información sensible en la memoria que no debería guardar, como contraseñas o mnemónicos.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Esto volcará la memoria en la carpeta ./dump, y allí podrías usar grep con algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Datos sensibles en Keystore**

En Android el Keystore es el mejor lugar para almacenar datos sensibles; sin embargo, con privilegios suficientes todavía es **posible acceder a él**. Como las aplicaciones tienden a almacenar aquí **datos sensibles en texto plano**, los pentests deberían comprobarlo como root user, o alguien con acceso físico al dispositivo podría robar estos datos.

Incluso si una app almacenara datos en el keystore, los datos deberían estar cifrados.

Para acceder a los datos dentro del keystore puedes usar este Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando el siguiente script de Frida, podría ser posible realizar un **bypass fingerprint authentication** que las aplicaciones Android llevan a cabo para **proteger ciertas áreas sensibles:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imágenes de fondo**

Cuando pones una aplicación en segundo plano, Android guarda una **instantánea de la aplicación** de modo que, cuando se recupera al primer plano, comienza cargando la imagen antes que la app para que parezca que la aplicación se cargó más rápido.

Sin embargo, si esta instantánea contiene **información sensible**, alguien con acceso a la instantánea podría **robar esa información** (ten en cuenta que necesitas root para acceder a ella).

Las instantáneas normalmente se almacenan en: **`/data/system_ce/0/snapshots`**

Android proporciona una forma de **evitar la captura de pantalla configurando el parámetro de layout FLAG_SECURE**. Al usar este flag, el contenido de la ventana se trata como seguro, evitando que aparezca en capturas de pantalla o que sea visible en pantallas no seguras.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Esta herramienta puede ayudarte a gestionar diferentes herramientas durante el análisis dinámico: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Los desarrolladores suelen crear componentes proxy como activities, services y broadcast receivers que manejan estos Intents y los pasan a métodos como `startActivity(...)` o `sendBroadcast(...)`, lo cual puede ser arriesgado.

El peligro radica en permitir que atacantes desencadenen componentes no exportados de la app o accedan a content providers sensibles al redirigir estos Intents. Un ejemplo notable es el componente `WebView` que convierte URLs en objetos `Intent` mediante `Intent.parseUri(...)` y luego los ejecuta, lo que puede conducir a inyecciones maliciosas de Intent.

### Essential Takeaways

- **Intent Injection** es similar al problema web de Open Redirect.
- Los exploits implican pasar objetos `Intent` como extras, que pueden ser redirigidos para ejecutar operaciones inseguras.
- Puede exponer componentes no exportados y content providers a atacantes.
- La conversión de URL a `Intent` de `WebView` puede facilitar acciones no deseadas.

### Android Client Side Injections and others

Probablemente conozcas este tipo de vulnerabilidades por la Web. Debes tener especial cuidado con estas vulnerabilidades en una aplicación Android:

- **SQL Injection:** Al tratar consultas dinámicas o Content-Providers, asegúrate de usar consultas parametrizadas.
- **JavaScript Injection (XSS):** Verifica que el soporte de JavaScript y Plugins esté deshabilitado para cualquier WebView (deshabilitado por defecto). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Los WebViews deberían tener el acceso al sistema de archivos deshabilitado (habilitado por defecto) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: En varios casos cuando la aplicación Android finaliza la sesión la cookie no se revoca o incluso puede guardarse en disco.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Evaluación de vulnerabilidades de la aplicación** utilizando una agradable interfaz web. También puedes realizar análisis dinámico (pero necesitas preparar el entorno).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Nota que MobSF puede analizar **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Además, si creas un archivo **ZIP** con el código fuente de una app **Android** o **IOS** (ve a la carpeta raíz de la aplicación, selecciona todo y crea un ZIPfile), también podrá analizarlo.

MobSF también te permite hacer **diff/Compare** de análisis e integrar **VirusTotal** (necesitarás configurar tu API key en _MobSF/settings.py_ y habilitarlo: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). También puedes poner `VT_UPLOAD` a `False`, entonces el **hash** será **upload** en vez del fichero.

### Assisted Dynamic analysis with MobSF

**MobSF** también puede ser muy útil para el **dynamic analysis** en **Android**, pero en ese caso necesitarás instalar MobSF y **genymotion** en tu host (una VM o Docker no funcionarán). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
El **MobSF dynamic analyser** puede:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Todo esto se hace automáticamente excepto las capturas de pantalla, debes pulsar cuando quieras una captura o tienes que pulsar "**Exported Activity Tester**" para obtener capturas de todas las actividades exportadas.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: Imprime todas las clases cargadas
- **Capture Strings**: Imprime todas las capture strings mientras usas la aplicación (muy ruidoso)
- **Capture String Comparisons**: Puede ser muy útil. **Muestra las 2 strings que se están comparando** y si el resultado fue True o False.
- **Enumerate Class Methods**: Introduce el nombre de la clase (como "java.io.File") y mostrará todos los métodos de la clase.
- **Search Class Pattern**: Buscar clases por patrón
- **Trace Class Methods**: **Trace** a **whole class** (ver entradas y salidas de todos los métodos de la clase). Recuerda que por defecto MobSF traza varios métodos Android API interesantes.

Una vez que hayas seleccionado el módulo auxiliar que quieres usar debes pulsar "**Start Intrumentation**" y verás todas las salidas en "**Frida Live Logs**".

**Shell**

Mobsf también te proporciona un shell con algunos comandos **adb**, **MobSF commands**, y comunes **shell** **commands** en la parte inferior de la página de dynamic analysis. Algunos comandos interesantes:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Herramientas HTTP**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** an look for vulnerabilities.

> [!TIP]
> After performing a dynamic analysis with MobSF the proxy settings me be misconfigured and you won't be able to fix them from the GUI. You can fix the proxy settings by doing:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Análisis dinámico asistido con Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta herramienta usará algunos **Hooks** para informarte **lo que está ocurriendo en la aplicación** mientras realizas un **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta es una **gran herramienta para realizar static analysis con GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta herramienta está diseñada para buscar varias **security related Android application vulnerabilities**, ya sea en **source code** o en **packaged APKs**. La herramienta también es **capable of creating a "Proof-of-Concept" deployable APK** y **ADB commands**, para explotar algunas de las vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Como con Drozer, no es necesario rootear el dispositivo de prueba.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Muestra todos los archivos extraídos para referencia fácil
- Decompila automáticamente archivos APK a formato Java y Smali
- Analiza AndroidManifest.xml en busca de vulnerabilidades y comportamientos comunes
- Análisis estático del código fuente en busca de vulnerabilidades y comportamientos comunes
- Información del dispositivo
- y más
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER es una aplicación de línea de comandos que puede usarse en Windows, MacOS X y Linux, que analiza archivos _.apk_ en busca de vulnerabilidades. Lo hace descomprimiendo APKs y aplicando una serie de reglas para detectar dichas vulnerabilidades.

Todas las reglas están centralizadas en un archivo `rules.json`, y cada empresa o tester puede crear sus propias reglas para analizar lo que necesiten.

Descarga los últimos binarios desde la [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn es una herramienta **multiplataforma** que ayuda a desarrolladores, bugbounty hunters y hackers éticos a realizar [análisis estático de código](https://en.wikipedia.org/wiki/Static_program_analysis) en aplicaciones móviles.

El concepto es que arrastras y sueltas el archivo de tu aplicación móvil (un archivo .apk o .ipa) sobre la aplicación StaCoAn y esta generará un informe visual y portátil para ti. Puedes ajustar la configuración y las wordlists para obtener una experiencia personalizada.

Descargar [última versión](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework es un sistema de análisis de vulnerabilidades para Android que ayuda a desarrolladores o hackers a encontrar vulnerabilidades de seguridad potenciales en aplicaciones Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** es una herramienta cuyo objetivo principal es detectar y advertir al usuario sobre posibles comportamientos maliciosos desarrollados por una aplicación Android.

La detección se realiza mediante el **static analysis** del Dalvik bytecode de la aplicación, representado como **Smali**, con la librería [`androguard`](https://github.com/androguard/androguard).

Esta herramienta busca **comportamientos comunes de "bad" applications** como: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Es una herramienta que agrupa herramientas comúnmente usadas de reverse engineering y analysis de aplicaciones móviles, para ayudar en las pruebas de aplicaciones móviles frente a las amenazas de seguridad móvil de OWASP. Su objetivo es hacer esta tarea más fácil y accesible para desarrolladores de aplicaciones móviles y profesionales de seguridad.

It is able to:

- Extraer código Java y Smali usando diferentes herramientas
- Analizar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraer información privada del APK usando regexps.
- Analizar el Manifest.
- Analizar dominios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Ten en cuenta que, dependiendo del servicio y la configuración que utilices para obfuscate el código, los Secrets pueden o no terminar obfuscated.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Es capaz de optimizar bytecode así como detectar y eliminar instrucciones no utilizadas. ProGuard es software libre y se distribuye bajo la GNU General Public License, versión 2.

ProGuard se distribuye como parte del Android SDK y se ejecuta al construir la aplicación en release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Encuentra una guía paso a paso para deobfuscate el apk en [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) La última vez que lo comprobamos, el modo de operación de Dexguard era:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Puedes subir un APK obfuscated a su plataforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Esta es una herramienta LLM para encontrar posibles vulnerabilidades de seguridad en android apps y deobfuscate android app code. Usa la Gemini public API de Google.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** para entender su comportamiento y luego **tries to optimize the code** para que se comporte idénticamente pero sea más fácil para un humano entender. Cada tipo de optimización es simple y generic, por lo que no importa qué tipo específico de obfuscation se use.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD te da información sobre **how an APK was made**. Identifica muchos **compilers**, **packers**, **obfuscators**, y otras cosas raras. Es [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

[Lee este tutorial para aprender algunos trucos sobre **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b es una Android security virtual machine basada en ubuntu-mate que incluye la colección de los últimos framework, tutorials y labs de diferentes security geeks y researchers para reverse engineering y malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Es una gran lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
