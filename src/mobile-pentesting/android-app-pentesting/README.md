# Applicazioni Android Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Nozioni di base sulle Applicazioni Android

È altamente consigliato iniziare leggendo questa pagina per conoscere le **parti più importanti relative alla sicurezza Android e i componenti più pericolosi in un'applicazione Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Questo è lo strumento principale che serve per connettersi a un dispositivo Android (emulato o fisico).\
**ADB** permette di controllare i dispositivi sia tramite **USB** sia tramite **Network** da un computer. Questa utility consente la **copia** di file in entrambe le direzioni, l'**installazione** e la **disinstallazione** di app, l'**esecuzione** di comandi shell, il **backup** dei dati, la **lettura** dei log, tra le altre funzioni.

Dai un'occhiata alla seguente lista di [**ADB Commands**](adb-commands.md) per imparare come usare adb.

## Smali

A volte è interessante **modificare il codice dell'applicazione** per accedere a **informazioni nascoste** (ad esempio password ben offuscate o flag). In questo caso può essere utile decompilare l'apk, modificare il codice e ricompilarlo.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Questo può essere molto utile come **alternativa per diversi test durante l'analisi dinamica** che verranno presentati. Quindi, **tieni sempre presente questa possibilità**.

## Altri trucchi interessanti

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Estrai APK dal dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Unisci tutti i splits e gli apks base con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Casi di studio e Vulnerabilità


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Analisi statica

Prima di tutto, per analizzare un APK dovresti **dare un'occhiata al codice Java** usando un decompiler.\
Per favore, [**leggi qui per trovare informazioni sui diversi decompiler disponibili**](apk-decompilers.md).

### Ricerca di informazioni interessanti

Solo dando un'occhiata alle **strings** dell'APK puoi cercare **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API** keys, **encryption**, **bluetooth uuids**, **tokens** e qualsiasi cosa interessante... cerca anche code execution **backdoors** o authentication backdoors (hardcoded admin credentials nell'app).

**Firebase**

Presta particolare attenzione alle **Firebase URLs** e verifica se sono configurate in modo errato. [Maggiori informazioni su cos'è Firebase e come sfruttarlo qui.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensione di base dell'applicazione - Manifest.xml, strings.xml

L'**esame dei file _Manifest.xml_ e _strings.xml_** di un'applicazione può rivelare potenziali vulnerabilità di sicurezza. Questi file possono essere ottenuti usando decompiler o rinominando l'estensione dell'APK in .zip e poi decomprimendolo.

**Vulnerabilità** identificate dal **Manifest.xml** includono:

- **Applicazioni debuggabili**: Le applicazioni impostate come debuggabili (`debuggable="true"`) nel file _Manifest.xml_ rappresentano un rischio poiché consentono connessioni che possono portare a sfruttamento. Per capire come sfruttare applicazioni debuggabili, consulta un tutorial su come individuare e sfruttare applicazioni debuggabili su un dispositivo.
- **Impostazioni di backup**: L'attributo `android:allowBackup="false"` dovrebbe essere impostato esplicitamente per le applicazioni che trattano informazioni sensibili per prevenire backup non autorizzati dei dati via adb, specialmente quando il debug USB è abilitato.
- **Network Security**: Le configurazioni personalizzate di network security (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ possono specificare dettagli di sicurezza come certificate pinning e impostazioni del traffico HTTP. Un esempio è consentire traffico HTTP per domini specifici.
- **Attività e servizi esportati**: Identificare attività e servizi esportati nel manifest può evidenziare componenti che potrebbero essere sfruttati. Un'ulteriore analisi durante i test dinamici può rivelare come sfruttare questi componenti.
- **Content Providers e FileProviders**: Content provider esposti potrebbero permettere accesso non autorizzato o modifica dei dati. Anche la configurazione dei FileProvider dovrebbe essere esaminata attentamente.
- **Broadcast Receivers e URL Schemes**: Questi componenti potrebbero essere sfruttati, prestando particolare attenzione a come gli URL scheme sono gestiti riguardo alle vulnerabilità di input.
- **Versioni SDK**: Gli attributi `minSdkVersion`, `targetSDKVersion` e `maxSdkVersion` indicano le versioni Android supportate, sottolineando l'importanza di non supportare versioni Android obsolete e vulnerabili per ragioni di sicurezza.

Dal file **strings.xml**, possono essere scoperte informazioni sensibili come API keys, custom schemas e altre note degli sviluppatori, sottolineando la necessità di una revisione accurata di queste risorse.

### Tapjacking

**Tapjacking** è un attacco in cui una **applicazione malevola** viene lanciata e **si posiziona sopra un'applicazione vittima**. Una volta che oscura visibilmente l'app vittima, la sua interfaccia utente è progettata in modo da indurre l'utente a interagire con essa, mentre l'interazione viene inoltrata all'app vittima.\
Di fatto, è **accecare l'utente impedendogli di rendersi conto che sta effettivamente eseguendo azioni sull'app vittima**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Un'attività con il `launchMode` impostato su `singleTask` senza alcun `taskAffinity` definito è vulnerabile al task Hijacking. Questo significa che un'applicazione può essere installata e, se avviata prima della vera applicazione, potrebbe dirottare il task della vera applicazione (così l'utente interagirà con l'app malevola pensando di usare quella reale).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Archiviazione dei dati insicura

**Internal Storage**

In Android, i file **memorizzati** nella **internal storage** sono progettati per essere accessibili esclusivamente dall'**app** che li ha creati. Questa misura di sicurezza è **applicata** dal sistema operativo Android ed è generalmente adeguata per le esigenze di sicurezza della maggior parte delle applicazioni. Tuttavia, gli sviluppatori a volte utilizzano modalità come `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` per **permettere** che i file siano **condivisi** tra diverse applicazioni. Queste modalità **non limitano l'accesso** a questi file da altre applicazioni, comprese quelle potenzialmente malevole.

1. **Analisi statica:**
- **Verifica** che l'uso di `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` sia **attentamente esaminato**. Queste modalità **possono potenzialmente esporre** file ad **accessi non intenzionati o non autorizzati**.
2. **Analisi dinamica:**
- **Controlla** i **permessi** impostati sui file creati dall'app. In particolare, **verifica** se alcuni file sono impostati come leggibili o scrivibili da tutti. Questo può rappresentare un rischio significativo per la sicurezza, poiché permetterebbe a **qualsiasi applicazione** installata sul dispositivo, indipendentemente dalla sua origine o intenzione, di **leggere o modificare** tali file.

**External Storage**

Quando si lavora con file su **external storage**, come SD Card, devono essere prese alcune precauzioni:

1. **Accessibilità**:
- I file su external storage sono **globalmente leggibili e scrivibili**. Questo significa che qualsiasi applicazione o utente può accedere a questi file.
2. **Problemi di sicurezza**:
- Data la facilità di accesso, è sconsigliato **memorizzare informazioni sensibili** su external storage.
- L'external storage può essere rimosso o accessibile da qualsiasi applicazione, rendendolo meno sicuro.
3. **Gestione dei dati dall'external storage**:
- Esegui sempre **validazione degli input** sui dati recuperati dall'external storage. Questo è cruciale perché i dati provengono da una fonte non fidata.
- È fortemente sconsigliato memorizzare eseguibili o file di classi su external storage per il caricamento dinamico.
- Se la tua applicazione deve recuperare file eseguibili dall'external storage, assicurati che questi file siano **firmati e verificati criptograficamente** prima del caricamento dinamico. Questo passaggio è vitale per mantenere l'integrità della sicurezza della tua applicazione.

External storage può essere **acceduto** in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> A partire da Android 4.4 (**API 17**), la SD card ha una struttura di directory che limita l'accesso di un'app alla directory specifica per quell'app. Questo impedisce a un'applicazione malevola di ottenere accesso in lettura o scrittura ai file di un'altra app.

**Dati sensibili memorizzati in chiaro**

- **Shared preferences**: Android permette a ogni applicazione di salvare facilmente file xml nel percorso `/data/data/<packagename>/shared_prefs/` e talvolta è possibile trovare informazioni sensibili in chiaro in quella cartella.
- **Databases**: Android permette a ogni applicazione di salvare facilmente database sqlite nel percorso `/data/data/<packagename>/databases/` e talvolta è possibile trovare informazioni sensibili in chiaro in quella cartella.

### TLS rotto

**Accept All Certificates**

Per qualche motivo, a volte gli sviluppatori accettano tutti i certificati anche se, ad esempio, l'hostname non corrisponde, con righe di codice come la seguente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Un buon modo per testare questo è provare a catturare il traffico usando un proxy come Burp senza autorizzare la Burp CA sul dispositivo. Inoltre, puoi generare con Burp un certificato per un hostname diverso e usarlo.

### Crittografia difettosa

**Processi di gestione delle chiavi insufficienti**

Alcuni sviluppatori salvano dati sensibili nello storage locale e li cifrano con una chiave hardcoded/predictable nel codice. Questo non dovrebbe essere fatto, perché del reversing potrebbe permettere agli attaccanti di estrarre le informazioni riservate.

**Uso di algoritmi insicuri e/o deprecati**

Gli sviluppatori non dovrebbero usare **algoritmi deprecati** per eseguire authorisation **checks**, **store** o **send** data. Alcuni di questi algoritmi sono: RC4, MD4, MD5, SHA1... Se **hashes** sono usati per memorizzare le password per esempio, dovrebbero essere usati hash resistenti al brute-force con salt.

### Altri controlli

- È raccomandato di **obfuscate the APK** per rendere più difficile il lavoro di reverse engineering agli attaccanti.
- Se l'app è sensibile (come le app bancarie), dovrebbe eseguire i propri controlli per verificare se il mobile è **rooted** e agire di conseguenza.
- Se l'app è sensibile (come le app bancarie), dovrebbe verificare se viene usato un **emulator**.
- Se l'app è sensibile (come le app bancarie), dovrebbe **controllare la propria integrità prima di eseguirla** per verificare se è stata modificata.
- Usa [**APKiD**](https://github.com/rednaga/APKiD) per verificare quale compiler/packer/obfuscator è stato usato per buildare l'APK

### Applicazione React Native

Leggi la pagina seguente per imparare come accedere facilmente al codice javascript delle applicazioni React:


{{#ref}}
react-native-application.md
{{#endref}}

### Applicazioni Xamarin

Leggi la pagina seguente per imparare come accedere facilmente al codice C# di applicazioni Xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Applicazioni Superpacked

Secondo questo [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked è un algoritmo Meta che comprime il contenuto di un'applicazione in un unico file. Il blog parla della possibilità di creare un'app che decomprima questo tipo di app... e di un metodo più veloce che consiste nell'**eseguire l'applicazione e raccogliere i file decompressi dal filesystem.**

### Analisi statica automatizzata del codice

Lo strumento [**mariana-trench**](https://github.com/facebook/mariana-trench) è in grado di trovare **vulnerabilities** scansionando il **code** dell'applicazione. Questo tool contiene una serie di **known sources** (che indicano allo strumento i **places** dove l'**input** è **controlled by the user**), **sinks** (che indicano allo strumento **dangerous** **places** dove un input malevolo potrebbe causare danni) e **rules**. Queste regole indicano la **combinazione** di **sources-sinks** che segnala una vulnerabilità.

Con queste informazioni, **mariana-trench analizzerà il codice e troverà possibili vulnerabilities su di esso**.

### Secrets leaked

Un'applicazione può contenere segreti (API keys, passwords, hidden urls, subdomains...) al suo interno che potresti riuscire a scoprire. Puoi usare uno strumento come [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Altre funzioni interessanti

- **Esecuzione di codice**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Invio di SMS**: `sendTextMessage, sendMultipartTestMessage`
- **Funzioni native** dichiarate come `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Altri trucchi**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analisi Dinamica

> Prima di tutto, hai bisogno di un ambiente dove puoi installare l'applicazione e tutto l'ambiente (Burp CA cert, Drozer e Frida principalmente). Pertanto, è fortemente raccomandato un dispositivo rooted (emulato o meno).

### Analisi dinamica online

Puoi creare un **account gratuito** su: [https://appetize.io/](https://appetize.io/). Questa piattaforma ti permette di **upload** e **execute** APKs, quindi è utile per vedere come si comporta un apk.

Puoi anche **vedere i log della tua applicazione** sul web e connetterti tramite **adb**.

![](<../../images/image (831).png>)

Grazie alla connessione ADB puoi usare **Drozer** e **Frida** all'interno degli emulatori.

### Analisi dinamica locale

#### Usare un emulatore

- [**Android Studio**](https://developer.android.com/studio) (Puoi creare **x86** e **arm** devices, e secondo [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** senza bisogno di un emulatore arm lento).
- Impara a configurarlo in questa pagina:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versione gratuita:** Personal Edition, devi creare un account. _Si raccomanda di **download** la versione **WITH** _**VirtualBox** per evitare errori potenziali._)
- [**Nox**](https://es.bignox.com) (Gratuito, ma non supporta Frida o Drozer).

> [!TIP]
> Quando crei un nuovo emulatore su qualsiasi piattaforma ricorda che più grande è lo schermo, più lento sarà l'emulatore. Quindi seleziona schermi piccoli se possibile.

Per **install google services** (come AppStore) in Genymotion devi cliccare sul pulsante evidenziato in rosso nell'immagine seguente:

![](<../../images/image (277).png>)

Inoltre, nota che nella **configurazione della Android VM in Genymotion** puoi selezionare la **Bridge Network mode** (questo sarà utile se ti connetterai alla Android VM da una VM diversa con gli strumenti).

#### Usare un dispositivo fisico

Devi attivare le opzioni di **debugging** e sarebbe utile se riuscissi a **rootarlo**:

1. **Settings**.
2. (Da Android 8.0) Seleziona **System**.
3. Seleziona **About phone**.
4. Premi **Build number** 7 volte.
5. Torna indietro e troverai le **Developer options**.

> Una volta installata l'applicazione, la prima cosa da fare è provarla e indagare cosa fa, come funziona e familiarizzare con essa.\
> Suggerisco di **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, così potremo **imparare come funziona l'applicazione** mentre MobSF **cattura** molti **dati** **interessanti** che potrai rivedere in seguito.

### Unintended Data Leakage

**Logging**

Gli sviluppatori dovrebbero fare attenzione a esporre informazioni di **debugging** pubblicamente, poiché possono portare a leak di dati sensibili. Gli strumenti [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` sono raccomandati per monitorare i log dell'applicazione per identificare e proteggere informazioni sensibili. **Pidcat** è preferito per la sua facilità d'uso e leggibilità.

> [!WARNING]
> Nota che da **versioni successive ad Android 4.0**, **le applicazioni possono accedere solo ai propri log**. Quindi le applicazioni non possono accedere ai log di altre app.\
> Comunque, è sempre raccomandato di **non loggare informazioni sensibili**.

**Copy/Paste Buffer Caching**

Il framework **clipboard-based** di Android abilita la funzionalità copia-incolla nelle app, ma rappresenta un rischio poiché **altre applicazioni** possono **accedere** agli appunti, potenzialmente esponendo dati sensibili. È fondamentale **disabilitare le funzioni di copia/incolla** per sezioni sensibili dell'applicazione, come i dettagli della carta di credito, per prevenire leak di dati.

**Crash Logs**

Se un'applicazione **crasha** e **salva log**, questi log possono aiutare gli attaccanti, in particolare quando l'applicazione non può essere reverse-engineered. Per mitigare questo rischio, evita di loggare nei crash, e se i log devono essere trasmessi in rete, assicurati che siano inviati tramite un canale SSL per sicurezza.

Come pentester, **cerca di dare un'occhiata a questi log**.

**Analytics Data Sent To 3rd Parties**

Le applicazioni spesso integrano servizi come Google Adsense, che possono involontariamente causare leak di dati sensibili a causa di una cattiva implementazione da parte degli sviluppatori. Per identificare potenziali leak di dati, è consigliabile **intercettare il traffico dell'applicazione** e controllare se informazioni sensibili vengono inviate a servizi di terze parti.

### SQLite DBs

La maggior parte delle applicazioni userà **database SQLite interni** per salvare informazioni. Durante il pentest dai un'occhiata ai **databases** creati, ai nomi delle **tabelle** e **colonne** e a tutti i **dati** salvati perché potresti trovare **informazioni sensibili** (che costituirebbero una vulnerabilità).\
I database dovrebbero essere localizzati in `/data/data/the.package.name/databases` come `/data/data/com.mwr.example.sieve/databases`

Se il database salva informazioni confidenziali ed è **crittografato** ma puoi **trovare** la **password** all'interno dell'applicazione, è comunque una **vulnerabilità**.

Enumera le tabelle usando `.tables` e enumera le colonne delle tabelle eseguendo `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

Dalla [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** ti permette di **assumere il ruolo di un'app Android** e interagire con altre app. Può fare **qualsiasi cosa che un'applicazione installata può fare**, come fare uso del meccanismo di Inter-Process Communication (IPC) di Android e interagire con il sistema operativo sottostante.\
Drozer è uno strumento utile per **exploit exported activities, exported services and Content Providers** come imparerai nelle sezioni seguenti.

### Sfruttare le exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ricorda inoltre che il codice di un'activity inizia nel metodo **`onCreate`**.

**Authorisation bypass**

Quando un'Activity è exported puoi invocarne la schermata da un'app esterna. Pertanto, se un'activity con **informazioni sensibili** è **exported** potresti **bypassare** i meccanismi di **autenticazione** per **accedervi.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Puoi anche avviare un'activity exported tramite adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF rileverà come malevolo l'uso di _**singleTask/singleInstance**_ come `android:launchMode` in un'activity, ma a causa di [questo](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparentemente questo è pericoloso solo su versioni vecchie (API versions < 21).

> [!TIP]
> Nota che un bypass di autorizzazione non è sempre una vulnerabilità; dipende da come funziona il bypass e quali informazioni vengono esposte.

**Perdita di informazioni sensibili**

**Le Activity possono anche restituire risultati**. Se riesci a trovare un'activity esportata e non protetta che chiama il metodo **`setResult`** e **restituisce informazioni sensibili**, c'è una perdita di informazioni sensibili.

#### Tapjacking

Se il Tapjacking non è prevenuto, potresti abusare dell'activity esportata per far eseguire all'utente **azioni inaspettate**. Per maggiori informazioni su [**cos'è Tapjacking segui il link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Leggi questo se vuoi rinfrescare cos'è un Content Provider.**](android-applications-basics.md#content-provider)\
I Content Provider sono fondamentalmente usati per **condividere dati**. Se un'app ha content provider disponibili potresti essere in grado di **estrarre dati sensibili** da essi. È anche interessante testare possibili **SQL injections** e **Path Traversals** poiché potrebbero essere vulnerabili.

[**Scopri come sfruttare i Content Providers con Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Leggi questo se vuoi rinfrescare cos'è un Service.**](android-applications-basics.md#services)\
Ricorda che le azioni di un Service iniziano nel metodo `onStartCommand`.

Un Service è fondamentalmente qualcosa che **può ricevere dati**, **elaborarli** e **restituire** (o meno) una risposta. Quindi, se un'applicazione espone dei service dovresti **controllare** il **codice** per capire cosa sta facendo e **testarlo** **dinamicamente** per estrarre informazioni riservate, bypassare misure di autenticazione...\
[**Scopri come sfruttare i Service con Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Leggi questo se vuoi rinfrescare cos'è un Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Ricorda che le azioni di un Broadcast Receiver iniziano nel metodo `onReceive`.

Un Broadcast Receiver attenderà un tipo di messaggio. A seconda di come il receiver gestisce il messaggio, potrebbe essere vulnerabile.\
[**Scopri come sfruttare i Broadcast Receiver con Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Puoi cercare deep links manualmente, usando strumenti come MobSF o script come [questo](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puoi **aprire** uno **scheme** dichiarato usando **adb** o un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Nota che puoi **omettere il nome del package** e il dispositivo mobile chiamerà automaticamente l'app che dovrebbe aprire quel link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Codice eseguito**

Per trovare il **codice che verrà eseguito nell'App**, vai all'activity chiamata dal deeplink e cerca la funzione **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informazioni sensibili**

Ogni volta che trovi un deep link verifica che **non stia ricevendo dati sensibili (come passwords) tramite parametri URL**, perché qualsiasi altra applicazione potrebbe **impersonate the deep link and steal that data!**

**Parameters in path**

Devi anche verificare se un deep link sta usando un parametro all'interno del path dell'URL come: `https://api.example.com/v1/users/{username}` , in tal caso puoi forzare un path traversal accedendo a qualcosa come: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Nota che se trovi gli endpoint corretti all'interno dell'applicazione potresti essere in grado di causare un **Open Redirect** (se parte del path è usata come domain name), **account takeover** (se puoi modificare i dettagli degli utenti senza token CSRF e l'endpoint vuln usa il metodo corretto) e qualsiasi altra vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Un [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** by Android applications. È comune che queste applicazioni ignorino gli avvisi e accettino certificati self-signed o, in alcuni casi, tornino a utilizzare connessioni HTTP.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, impiegando cipher suites non sicure. Questa vulnerabilità rende la connessione suscettibile ad attacchi man-in-the-middle (MITM), permettendo agli attaccanti di decrittare i dati.
- **Leakage of private information** è un rischio quando le applicazioni si autenticano usando canali sicuri ma poi comunicano su canali non sicuri per altre transazioni. Questo approccio non protegge i dati sensibili, come session cookies o dettagli utente, dall'intercettazione da parte di entità malintenzionate.

#### Certificate Verification

Ci concentreremo sulla **certificate verification**. L'integrità del certificato del server deve essere verificata per aumentare la sicurezza. Questo è cruciale perché configurazioni TLS insicure e la trasmissione di dati sensibili su canali non cifrati possono rappresentare rischi significativi. Per passaggi dettagliati su come verificare i certificati server e risolvere le vulnerabilità, [**questa risorsa**](https://manifestsecurity.com/android-application-security-part-10/) fornisce una guida completa.

#### SSL Pinning

SSL Pinning è una misura di sicurezza in cui l'applicazione verifica il certificato del server rispetto a una copia nota memorizzata all'interno dell'app stessa. Questo metodo è essenziale per prevenire attacchi MITM. Implementare SSL Pinning è fortemente raccomandato per applicazioni che gestiscono informazioni sensibili.

#### Traffic Inspection

Per ispezionare il traffico HTTP, è necessario **installare il certificato dello strumento proxy** (es. Burp). Senza installare questo certificato, il traffico cifrato potrebbe non essere visibile tramite il proxy. Per una guida su come installare un certificato CA personalizzato, [**clicca qui**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Le applicazioni che targettizzano **API Level 24 and above** richiedono modifiche al Network Security Config per accettare il certificato CA del proxy. Questo passaggio è critico per ispezionare il traffico cifrato. Per istruzioni su come modificare il Network Security Config, [**consulta questo tutorial**](make-apk-accept-ca-certificate.md).

Se viene usato **Flutter** devi seguire le istruzioni in [**questa pagina**](flutter.md). Questo perché aggiungere semplicemente il certificato nello store non funzionerà poiché Flutter ha la propria lista di CA valide.

#### Static detection of SSL/TLS pinning

Prima di tentare bypass runtime, mappa rapidamente dove il pinning è applicato nell'APK. La scoperta statica ti aiuta a pianificare hook/patch e a concentrarti sui corretti code paths.

Tool: SSLPinDetect
- Utility open-source di static-analysis che decompila l'APK in Smali (via apktool) e scansiona pattern regex curati di implementazioni di pinning SSL/TLS.
- Riporta il file path esatto, il numero di linea e uno snippet di codice per ogni match.
- Copre framework comuni e code path custom: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, e pin nel Network Security Config XML.

Installazione
- Prerequisiti: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Esempio di regole di pattern (JSON)
Usa o estendi le signatures per rilevare stili di pinning proprietari/custom. Puoi caricare il tuo JSON e eseguire scan su larga scala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Note e consigli
- Fast scanning on large apps via multi-threading and memory-mapped I/O; pre-compiled regex reduces overhead/false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typical detection targets to triage next:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Use the matched locations to plan Frida hooks, static patches, or config reviews before dynamic testing.



#### Bypass SSL Pinning

Quando SSL Pinning è implementato, bypassarlo diventa necessario per ispezionare il traffico HTTPS. Sono disponibili diversi metodi per questo scopo:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

È importante cercare anche vulnerabilità web comuni all'interno dell'applicazione. Informazioni dettagliate sull'identificazione e la mitigazione di queste vulnerabilità sono oltre lo scopo di questo sommario ma sono ampiamente trattate altrove.

### Frida

[Frida](https://www.frida.re) è un toolkit di strumentazione dinamica per sviluppatori, analisti di reverse engineering e ricercatori di sicurezza.\
**Puoi accedere all'applicazione in esecuzione e hook methods on run time to change the behaviour, change values, extract values, run different code...**\
Se vuoi fare pentest di applicazioni Android devi sapere come usare Frida.

- Impara come usare Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump della memoria - Fridump**

Controlla se l'applicazione sta memorizzando informazioni sensibili nella memoria che non dovrebbe memorizzare, come password o mnemonics.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) puoi eseguire il dump della memoria dell'app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Questo eseguirà il dump della memoria nella cartella ./dump, e lì puoi usare grep con qualcosa del tipo:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dati sensibili nel Keystore**

In Android il Keystore è il posto migliore per memorizzare dati sensibili, tuttavia, con privilegi sufficienti è ancora **possibile accedervi**. Poiché le applicazioni tendono a memorizzare qui **dati sensibili in chiaro**, i pentest dovrebbero verificarne la presenza in quanto un utente root o qualcuno con accesso fisico al dispositivo potrebbe essere in grado di rubare questi dati.

Anche se un'app memorizza dati nel keystore, i dati dovrebbero essere crittografati.

Per accedere ai dati all'interno del keystore puoi usare questo script Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando il seguente script Frida potrebbe essere possibile **bypass fingerprint authentication** che le applicazioni Android potrebbero eseguire per **proteggere alcune aree sensibili:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Immagini di sfondo**

Quando metti un'applicazione in background, Android memorizza una **istantanea dell'applicazione** così quando viene riportata in primo piano inizia a caricare l'immagine prima dell'app in modo che sembri che l'app sia stata caricata più velocemente.

Tuttavia, se questa istantanea contiene **informazioni sensibili**, qualcuno con accesso all'istantanea potrebbe **rubare queste informazioni** (nota che è necessario avere i permessi di root per accedervi).

Le istantanee sono solitamente memorizzate in: **`/data/system_ce/0/snapshots`**

Android fornisce un modo per **impedire la cattura dello screenshot impostando il parametro di layout FLAG_SECURE**. Usando questo flag, il contenuto della finestra viene trattato come sicuro, impedendone l'apparizione negli screenshot o la visualizzazione su display non sicuri.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Questo strumento può aiutarti a gestire diversi tool durante l'analisi dinamica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developers often create proxy components like activities, services, and broadcast receivers that handle these Intents and pass them to methods such as `startActivity(...)` or `sendBroadcast(...)`, which can be risky.

Il pericolo consiste nel permettere a malintenzionati di attivare componenti dell'app non-exported o accedere a content provider sensibili deviando questi Intent. Un esempio notevole è il componente `WebView` che converte URL in oggetti `Intent` tramite `Intent.parseUri(...)` e poi li esegue, potenzialmente portando a iniezioni di Intent malevoli.

### Essential Takeaways

- **Intent Injection** è simile al problema Open Redirect del web.
- Gli exploit comportano il passaggio di oggetti `Intent` come extras, che possono essere reindirizzati per eseguire operazioni non sicure.
- Può esporre componenti non-exported e content provider a malintenzionati.
- La conversione da URL a `Intent` di `WebView` può facilitare azioni non intenzionali.

### Iniezioni lato client Android e altri

Probabilmente conosci questo tipo di vulnerabilità dal Web. Devi prestare particolare attenzione a queste vulnerabilità in un'app Android:

- **SQL Injection:** Quando si gestiscono query dinamiche o Content-Providers assicurati di usare query parametrizzate.
- **JavaScript Injection (XSS):** Verifica che il supporto a JavaScript e Plugin sia disabilitato per qualsiasi WebView (disabilitato di default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** I WebView dovrebbero avere l'accesso al file system disabilitato (abilitato di default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In diversi casi quando l'app Android termina la sessione il cookie non viene revocato o può essere persino salvato su disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Analisi automatica

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analisi statica**

![](<../../images/image (866).png>)

**Valutazione delle vulnerabilità dell'applicazione** usando una gradevole interfaccia web. Puoi anche eseguire analisi dinamica (ma devi preparare l'ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Nota che MobSF può analizzare **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Le applicazioni Windows devono essere analizzate da un MobSF installato su un host Windows_).\
Inoltre, se crei un file **ZIP** con il codice sorgente di un'app **Android** o **IOS** (vai nella cartella root dell'applicazione, seleziona tutto e crea un ZIPfile), sarà in grado di analizzarlo.

MobSF permette anche di fare il **diff/Compare** delle analisi e di integrare **VirusTotal** (dovrai impostare la tua API key in _MobSF/settings.py_ e abilitarla: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Puoi anche impostare `VT_UPLOAD` a `False`, allora l'**hash** sarà **upload** invece del file.

### Analisi dinamica assistita con MobSF

**MobSF** può essere molto utile anche per la **dynamic analysis** su **Android**, ma in quel caso dovrai installare MobSF e **genymotion** sul tuo host (una VM o Docker non funzioneranno). _Nota: Devi **start first a VM in genymotion** e **then MobSF.**_\
Il **MobSF dynamic analyser** può:

- **Dump application data** (URLs, logs, clipboard, screenshots fatte da te, screenshots fatte da "**Exported Activity Tester**", email, SQLite databases, XML files, e altri file creati). Tutto questo viene fatto automaticamente eccetto gli screenshot: per gli screenshot devi premere quando vuoi catturarne uno oppure devi premere "**Exported Activity Tester**" per ottenere screenshot di tutte le attività esportate.
- Catturare il **HTTPS traffic**
- Usare **Frida** per ottenere informazioni a runtime

Dalle **versioni di Android > 5**, avvierà **automaticamente Frida** e imposterà le impostazioni globali del **proxy** per catturare il traffico. Catturerà solo il traffico dell'applicazione testata.

**Frida**

Di default userà anche alcuni Frida Scripts per **bypass SSL pinning**, **root detection** e **debugger detection** e per **monitor interesting APIs**.\
MobSF può anche **invoke exported activities**, catturare **screenshots** di esse e **save**le per il report.

Per **start** il testing dinamico premi il bottone verde: "**Start Instrumentation**". Premi "**Frida Live Logs**" per vedere i log generati dagli script Frida e "**Live API Monitor**" per vedere tutte le invocation ai metodi hooked, gli argomenti passati e i valori restituiti (questo apparirà dopo aver premuto "Start Instrumentation").\
MobSF permette anche di caricare i tuoi **Frida scripts** (per inviare i risultati dei tuoi Frida scripts a MobSF usa la funzione `send()`). Ha anche **several pre-written scripts** che puoi caricare (puoi aggiungerne altri in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), basta **select them**, premere "**Load**" e premere "**Start Instrumentation**" (potrai vedere i log di quegli script dentro "**Frida Live Logs**").

![](<../../images/image (419).png>)

Inoltre, hai alcune funzionalità ausiliarie di Frida:

- **Enumerate Loaded Classes**: Stamperà tutte le classi caricate
- **Capture Strings**: Stamperà tutte le stringhe catturate mentre usi l'applicazione (molto noisy)
- **Capture String Comparisons**: Può essere molto utile. Mostrerà le 2 stringhe confrontate e se il risultato è True o False.
- **Enumerate Class Methods**: Inserisci il nome della classe (come "java.io.File") e stamperà tutti i metodi della classe.
- **Search Class Pattern**: Cerca classi per pattern
- **Trace Class Methods**: **Trace** un'intera classe (vedi input e output di tutti i metodi della classe). Ricorda che di default MobSF traccia diversi metodi interessanti delle Android Api.

Una volta selezionato il modulo ausiliario che vuoi usare devi premere "**Start Intrumentation**" e vedrai tutti gli output in "**Frida Live Logs**".

**Shell**

MobSF offre anche una shell con alcuni comandi **adb**, **MobSF commands**, e comuni **shell** **commands** in fondo alla pagina di dynamic analysis. Alcuni comandi interessanti:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Strumenti HTTP**

Quando il traffico http viene catturato puoi vedere una vista brutta del traffico catturato sul pulsante "**HTTP(S) Traffic**" in basso oppure una vista più pulita nel pulsante verde "**Start HTTPTools**". Dalla seconda opzione, puoi **inviare** le **richieste catturate** a **proxies** come Burp o Owasp ZAP.\
Per farlo, _accendi Burp -->_ _disattiva Intercept --> in MobSB HTTPTools seleziona la request_ --> premi "**Send to Fuzzer**" --> _seleziona l'indirizzo del proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una volta terminata l'analisi dinamica con MobSF puoi premere su "**Start Web API Fuzzer**" per **fuzz http requests** e cercare vulnerabilità.

> [!TIP]
> Dopo aver eseguito un'analisi dinamica con MobSF le impostazioni del proxy potrebbero essere mal configurate e potresti non riuscire a correggerle dall'interfaccia. Puoi correggere le impostazioni del proxy eseguendo:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Puoi ottenere lo strumento da [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Questo tool utilizza alcuni **Hooks** per farti sapere **cosa sta succedendo nell'applicazione** mentre esegui un'**analisi dinamica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Questo è un **ottimo strumento per eseguire analisi statica con una GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Questo tool è progettato per cercare diverse **vulnerabilità delle applicazioni Android legate alla security**, sia nel **source code** sia negli **APKs** confezionati. Lo strumento è inoltre **in grado di creare un APK deployable "Proof-of-Concept"** e **ADB commands**, per sfruttare alcune delle vulnerabilità trovate (Exposed activities, intents, tapjacking...). Come con Drozer, non è necessario effettuare il root del dispositivo di test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Mostra tutti i file estratti per un facile riferimento
- Decompila automaticamente gli APK in formato Java e Smali
- Analizza AndroidManifest.xml per vulnerabilità comuni e comportamento
- Analisi statica del codice sorgente per vulnerabilità comuni e comportamento
- Informazioni sul dispositivo
- e altro
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER è un'applicazione da riga di comando utilizzabile su Windows, MacOS X e Linux, che analizza file _.apk_ alla ricerca di vulnerabilità. Lo fa decomprimendo gli APK e applicando una serie di regole per rilevarle.

Tutte le regole sono raccolte in un file `rules.json`, e ogni azienda o tester può creare le proprie regole per analizzare ciò di cui ha bisogno.

Scarica gli ultimi binari dalla [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn è uno strumento **multipiattaforma** che aiuta sviluppatori, bugbounty hunters e ethical hackers nello svolgimento di [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) su applicazioni mobile.

Il concetto è che trascini e rilasci il file della tua applicazione mobile (un file .apk o .ipa) sull'applicazione StaCoAn e questo genererà per te un report visuale e portatile. Puoi modificare le impostazioni e le wordlists per ottenere un'esperienza personalizzata.

Scarica[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework è un sistema di analisi delle vulnerabilità per Android che aiuta sviluppatori o hacker a trovare potenziali vulnerabilità di sicurezza nelle applicazioni Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** è uno strumento il cui obiettivo principale è rilevare e avvisare l'utente su potenziali comportamenti dannosi sviluppati da un'applicazione Android.

La rilevazione viene eseguita tramite **static analysis** del Dalvik bytecode dell'applicazione, rappresentato come **Smali**, usando la libreria [`androguard`](https://github.com/androguard/androguard).

Questo strumento individua i **comportamenti comuni delle applicazioni "maligne"** come: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. È uno strumento che mette insieme strumenti comunemente usati per il reverse engineering e l'analisi delle mobile application, per assistere nel testing delle mobile application contro le minacce per la sicurezza mobile identificate da OWASP. Il suo obiettivo è rendere questo compito più facile e accessibile agli sviluppatori di mobile application e ai professionisti della sicurezza.

È in grado di:

- Estrarre codice Java e Smali usando diversi strumenti
- Analizzare APK usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Estrarre informazioni private dall'APK usando regexp.
- Analizzare il Manifest.
- Analizzare i domini trovati usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) e [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile per rilevare malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Nota che a seconda del servizio e della configurazione che usi per offuscare il codice, i segreti potrebbero o meno risultare offuscati.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Da [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** è uno strumento open source da riga di comando che riduce, ottimizza e offusca codice Java. È in grado di ottimizzare il bytecode oltre a rilevare e rimuovere istruzioni non utilizzate. ProGuard è software libero distribuito sotto la GNU General Public License, versione 2.

ProGuard è distribuito come parte dell'Android SDK e viene eseguito durante la build dell'applicazione in modalità release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Trova una guida passo-passo per deoffuscare l'apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Dalla guida) L'ultima volta che abbiamo controllato, la modalità di funzionamento di Dexguard era:

- caricare una risorsa come InputStream;
- passare il risultato a una classe che eredita da FilterInputStream per decrittarlo;
- fare alcune inutili operazioni di obfuscation per far perdere qualche minuto al reverser;
- passare il risultato decrittato a un ZipInputStream per ottenere un file DEX;
- infine caricare il DEX risultante come risorsa usando il metodo `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard inverte il processo di offuscamento eseguito dagli strumenti di offuscamento Android. Questo abilita numerose analisi di sicurezza, inclusa l'ispezione del codice e la predizione delle librerie.**

Puoi caricare un APK offuscato sulla loro piattaforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Questo è uno strumento LLM per trovare potenziali vulnerabilità di sicurezza nelle app Android e deoffuscare il codice delle app Android. Usa l'API pubblica Gemini di Google.

### [Simplify](https://github.com/CalebFenton/simplify)

È un deobfuscator Android generico. Simplify esegue virtualmente un'app per comprenderne il comportamento e poi cerca di ottimizzare il codice in modo che si comporti identicamente ma sia più facile da comprendere per un umano. Ogni tipo di ottimizzazione è semplice e generica, quindi non importa quale tipo specifico di offuscamento sia stato usato.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD ti dà informazioni su **come è stato creato un APK**. Identifica molti **compilatori**, **packers**, **obfuscators**, e altre cose strane. È lo [_PEiD_] per Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b è una virtual machine per la sicurezza Android basata su ubuntu-mate che include una raccolta dei più recenti framework, tutorial e lab da diversi esperti e ricercatori per reverse engineering e analisi di malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) È un'ottima lista di risorse
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Corso rapido Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
