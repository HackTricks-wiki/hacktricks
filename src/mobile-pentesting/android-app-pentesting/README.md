# Android Uygulamaları Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Uygulamaları Temelleri

Bu sayfayı okumaya başlamanız şiddetle tavsiye edilir; **Android güvenliğiyle ilgili en önemli parçalar ve bir Android uygulamasındaki en tehlikeli bileşenler** hakkında bilgi edinmek için:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Bu, bir Android cihaza (emüle veya fiziksel) bağlanmak için gereken ana araçtır.\
**ADB**, bir bilgisayardan cihazları **USB** veya **Network** üzerinden kontrol etmeyi sağlar. Bu yardımcı program, dosyaların her iki yönde **kopyalanmasını**, uygulamaların **kurulmasını** ve **kaldırılmasını**, **shell** komutlarının çalıştırılmasını, verilerin **yedeklenmesini**, logların **okunmasını** ve diğer işlevleri mümkün kılar.

ADB'yi nasıl kullanacağınızı öğrenmek için aşağıdaki [**ADB Commands**](adb-commands.md) listesine göz atın.

## Smali

Bazen **uygulama kodunu değiştirmek**, **gizli bilgilere** (örneğin iyi obfuscated parolalar veya flags) erişmek için ilgi çekici olabilir. Bu durumda, APK'yı decompile edip, kodu değiştirip yeniden derlemek ilginç olabilir.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Bu, dinamik analiz sırasında sunulacak bazı testler için bir alternatif olarak çok faydalı olabilir. Bu seçeneği her zaman aklınızda bulundurun.

## Diğer ilginç tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Tüm split'leri ve base apk'ları [APKEditor](https://github.com/REAndroid/APKEditor) ile birleştirin:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise ve Work Profile Saldırıları

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Vaka Çalışmaları ve Zafiyetler


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Statik Analiz

Öncelikle, bir APK'yı analiz etmek için decompiler kullanarak **Java koduna bakmalısınız**.\
Lütfen, [**farklı kullanılabilir decompiler'lar hakkında bilgi almak için burayı okuyun**](apk-decompilers.md).

### İlginç Bilgiler Arama

Sadece APK'nın **strings**'ine bakarak **parolalar**, **URL'ler** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **API anahtarları**, **şifreleme**, **bluetooth UUID'leri**, **tokenlar** ve diğer ilginç şeyleri arayabilirsiniz... ayrıca kod yürütme için olan **backdoor**'ları veya kimlik doğrulama backdoor'larını (uygulamaya hardcoded admin kimlik bilgileri) da kontrol edin.

**Firebase**

Firebase URL'lerine özellikle dikkat edin ve kötü yapılandırılıp yapılandırılmadığını kontrol edin. [Firebase'in ne olduğu ve nasıl istismar edileceği hakkında daha fazla bilgi için burayı okuyun.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Uygulamayı Temel Düzeyde Anlama - Manifest.xml, strings.xml

Bir uygulamanın _Manifest.xml_ ve _strings.xml_ dosyalarının **incelenmesi potansiyel güvenlik açıklarını ortaya çıkarabilir**. Bu dosyalara decompiler kullanarak veya APK dosya uzantısını .zip olarak değiştirip açarak erişilebilir.

**Manifest.xml** dosyasından tespit edilebilecek zafiyetler şunlardır:

- **Debuggable Applications**: _Manifest.xml_ dosyasında `debuggable="true"` olarak ayarlanmış uygulamalar risk taşır; çünkü bağlantılara izin vererek istismara yol açabilir. Debuggable uygulamaların cihazda nasıl bulunup istismar edileceğiyle ilgili bir eğitim kaynağına başvurun.
- **Backup Settings**: Hassas bilgilerle çalışan uygulamalar için `android:allowBackup="false"` özniteliğinin açıkça ayarlanması gerekir; aksi halde adb üzerinden yetkisiz yedeklemelere izin verilebilir, özellikle usb debugging etkinse.
- **Network Security**: _res/xml/_ içindeki özel network security konfigürasyonları (`android:networkSecurityConfig="@xml/network_security_config"`) sertifika pinleri ve HTTP trafiği ayarları gibi güvenlik detaylarını belirtebilir. Örneğin belirli domainler için HTTP trafiğine izin verilebilir.
- **Exported Activities and Services**: Manifest içindeki exported aktiviteler ve servisler, kötüye kullanılabilecek bileşenleri ortaya çıkarabilir. Dinamik testler sırasında bu bileşenlerin nasıl istismar edilebileceği daha detaylı analiz edilebilir.
- **Content Providers and FileProviders**: Açıkta olan content provider'lar yetkisiz erişim veya veri değiştirmeye izin verebilir. FileProvider konfigürasyonları da dikkatle incelenmelidir.
- **Broadcast Receivers and URL Schemes**: Bu bileşenler istismar için kullanılabilir; özellikle URL scheme'lerinin nasıl ele alındığı ve girdi doğrulamalarına dikkat edilmelidir.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion` ve `maxSdkVersion` öznitelikleri desteklenen Android sürümlerini gösterir; eski ve zayıf Android sürümlerini desteklememek güvenlik açısından önemlidir.

**strings.xml** dosyasından API anahtarları, özel şemalar ve diğer geliştirici notları gibi hassas bilgiler bulunabilir; bu kaynakların dikkatle incelenmesi gerekir.

### Tapjacking

Tapjacking, kötü niyetli bir uygulamanın başlatılıp mağdur uygulamanın üzerine konumlandığı bir saldırıdır. Mağdur uygulamayı görünür şekilde örttüğünde, kullanıcıyı aldatacak biçimde tasarlanmış kullanıcı arayüzü etkileşimi mağdur uygulamaya geçirir.\
Sonuç olarak, kullanıcı aslında mağdur uygulamada işlem yaptığını fark edemez.

Daha fazla bilgi için bakın:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode`'u `singleTask` olarak ayarlanmış ve herhangi bir `taskAffinity` tanımlanmamış bir **activity**, task Hijacking'e karşı savunmasızdır. Bu, kötü niyetli bir uygulamanın yüklenip gerçek uygulamadan önce başlatılması durumunda gerçek uygulamanın task'ını ele geçirebileceği anlamına gelir (yani kullanıcı, gerçekini kullandığını düşünerek kötü amaçlı uygulamayla etkileşimde bulunur).

Daha fazla bilgi:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Güvensiz veri depolama

Internal Storage

Android'de internal storage'da **saklanan** dosyalar, onları oluşturan uygulama tarafından **yalnızca** erişilebilir olacak şekilde tasarlanmıştır. Bu güvenlik önlemi Android işletim sistemi tarafından uygulanır ve çoğu uygulamanın güvenlik ihtiyaçları için genellikle yeterlidir. Ancak geliştiriciler bazen dosyaların farklı uygulamalar arasında paylaşılmasına olanak vermek için `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` gibi modları kullanırlar. Bu modlar, potansiyel olarak bu dosyaların diğer uygulamalar tarafından (kötü niyetli olanlar dahil) erişimine kısıtlama getirmez.

1. Static Analysis:
- `MODE_WORLD_READABLE` ve `MODE_WORLD_WRITABLE` kullanımının dikkatle incelendiğinden emin olun. Bu modlar dosyaları istem dışı veya yetkisiz erişime açabilir.
2. Dynamic Analysis:
- Uygulama tarafından oluşturulan dosyaların izinlerini doğrulayın. Özellikle herhangi bir dosyanın dünya çapında okunabilir veya yazılabilir olarak ayarlanıp ayarlanmadığını kontrol edin. Bu, cihaza yüklü olan herhangi bir uygulamanın bu dosyaları okumasına veya değiştirmesine izin verebilir ve ciddi bir güvenlik riski oluşturur.

External Storage

SD kart gibi external storage'daki dosyalarla uğraşırken bazı önlemler alınmalıdır:

1. Erişilebilirlik:
- External storage'daki dosyalar global olarak okunabilir ve yazılabilirdir. Yani herhangi bir uygulama veya kullanıcı bu dosyalara erişebilir.
2. Güvenlik Endişeleri:
- Kolay erişilebilirlik nedeniyle hassas bilgilerin external storage'da saklanmaması önerilir.
- External storage çıkarılabilir veya herhangi bir uygulama tarafından erişilebilir olduğundan daha az güvenlidir.
3. External Storage'dan Gelen Verilerin İşlenmesi:
- External storage'dan alınan veriler üzerinde her zaman girdi doğrulaması yapın. Çünkü bu veriler güvenilmeyen bir kaynaktan gelmektedir.
- Executable veya class dosyalarını dynamic loading için external storage'da depolamak şiddetle önerilmez.
- Uygulamanız external storage'dan executable dosyaları almak zorundaysa, bu dosyaların dinamik olarak yüklenmeden önce **imzalanmış** ve kriptografik olarak doğrulanmış olduğundan emin olun. Bu adım uygulamanızın güvenliği için hayati öneme sahiptir.

External storage şu yollarda erişilebilir: /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Android 4.4 (**API 17**) ile başlayarak SD kartın bir dizin yapısı vardır ve bu yapı bir uygulamanın yalnızca kendisine özel dizine erişimini sınırlar. Bu, kötü niyetli bir uygulamanın başka bir uygulamanın dosyalarına okuma veya yazma erişimi elde etmesini engeller.

Açık metin olarak saklanan hassas veriler

- **Shared preferences**: Android, her uygulamanın `/data/data/<packagename>/shared_prefs/` yolunda kolayca xml dosyaları kaydetmesine izin verir ve bazen o klasörde açık metin halinde hassas bilgiler bulunabilir.
- **Databases**: Android, her uygulamanın `/data/data/<packagename>/databases/` yolunda sqlite veritabanları kaydetmesine izin verir ve bazen o klasörde açık metin halinde hassas bilgiler bulunabilir.

### Broken TLS

**Accept All Certificates**

Bazı nedenlerle geliştiriciler bazen hostname eşleşmese bile tüm sertifikaları kabul ederler; örneğin aşağıdaki gibi kod satırlarıyla:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

Bazı geliştiriciler hassas verileri local storage içinde saklayıp, kod içinde hardcoded / öngörülebilir bir anahtarla şifrelerler. Bu yapılmamalıdır çünkü bazı reversing işlemleri saldırganların gizli bilgileri çıkarmasına olanak verebilir.

**Use of Insecure and/or Deprecated Algorithms**

Geliştiriciler yetkilendirme **kontrolleri** yapmak, veri **saklamak** veya **göndermek** için **deprecated algorithms** kullanmamalıdır. Bu algoritmalardan bazıları: RC4, MD4, MD5, SHA1... Örneğin şifreleri saklamak için **hashes** kullanılıyorsa, salt ile birlikte brute-force'a **dirençli** hash'ler kullanılmalıdır.

### Other checks

- APK'yı tersine mühendislik işini zorlaştırmak için **obfuscate the APK** yapması önerilir.
- Uygulama hassassa (ör. banka uygulamaları), mobilin **rooted** olup olmadığını kontrol etmek için kendi **kontrollerini** yapmalı ve duruma göre hareket etmelidir.
- Uygulama hassassa (ör. banka uygulamaları), bir **emulator** kullanılıp kullanılmadığını kontrol etmelidir.
- Uygulama hassassa (ör. banka uygulamaları), çalıştırmadan önce **kendi bütünlüğünü kontrol etmeli** ve değiştirilip değiştirilmediğini doğrulamalıdır.
- Hangi compiler/packer/obfuscator kullanılarak APK'nin oluşturulduğunu kontrol etmek için [**APKiD**](https://github.com/rednaga/APKiD) kullanın

### React Native Application

React uygulamalarının javascript koduna kolayca nasıl erişileceğini öğrenmek için aşağıdaki sayfayı okuyun:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Xamarin uygulamalarının C# koduna kolayca nasıl erişileceğini öğrenmek için aşağıdaki sayfayı okuyun:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Bu [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)'a göre superpacked, bir uygulamanın içeriğini tek bir dosyaya sıkıştıran Meta bir algoritmadır. Blog, bu tür uygulamaları açan bir uygulama oluşturma olasılığından bahseder... ve daha hızlı bir yol olarak **uygulamayı çalıştırıp filesystem’den açılmış dosyaları toplama** yönteminden söz eder.

### Automated Static Code Analysis

[**mariana-trench**](https://github.com/facebook/mariana-trench) aracı, uygulamanın **kodunu** **tarayarak** **vulnerabilities** bulmaya kabildir. Bu araç, araç için **kullanıcının kontrol ettiği input'un bulunduğu yerleri** gösteren bir dizi **known sources**, zararlı kullanıcı girdilerinin zarar verebileceği **dangerous places** olan **sinks** ve **rules** içerir. Bu kurallar, bir vulnerability'yi gösteren **sources-sinks** kombinasyonlarını belirtir.

Bu bilgiyle birlikte, **mariana-trench kodu inceleyecek ve olası vulnerabilities bulacaktır**.

### Secrets leaked

Bir uygulama içinde keşfedebileceğiniz anahtarlar (API keys, şifreler, gizli url'ler, subdomain'ler...) olabilir. Böyle bilgileri bulmak için [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks) gibi bir araç kullanabilirsiniz.

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Bu bağlantıyı okuyarak **native fonksiyonların nasıl reverse edileceğini** öğrenin](reversing-native-libraries.md)
- JNI aracılığıyla bellek içi native kod çalıştırma (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> Öncelikle, uygulamayı ve tüm ortamı (Burp CA cert, Drozer ve Frida başta olmak üzere) kurabileceğiniz bir ortama ihtiyacınız var. Bu nedenle rooted bir cihaz (emüle edilmiş veya değil) şiddetle tavsiye edilir.

### Online Dynamic analysis

Şurada bir **free account** oluşturabilirsiniz: [https://appetize.io/](https://appetize.io). Bu platform, APK'leri **upload** edip **execute** etmenize olanak tanır; bu yüzden bir apk'nin nasıl davrandığını görmek için faydalıdır.

Web üzerinden uygulamanızın loglarını **görebilir** ve **adb** üzerinden bağlanabilirsiniz.

![](<../../images/image (831).png>)

ADB bağlantısı sayesinde emülatörler içinde **Drozer** ve **Frida** kullanabilirsiniz.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Burada **x86** ve **arm** cihazlar oluşturabilirsiniz ve [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**en son x86** sürümleri, yavaş bir arm emülatöre gerek kalmadan ARM kütüphanelerini destekler).
- Kurulumunu bu sayfada öğrenin:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, bir hesap oluşturmanız gerekir. _Potansiyel hataları önlemek için **VirtualBox İLE** gelen sürümü **indirmeniz** önerilir._)
- [**Nox**](https://es.bignox.com) (Ücretsiz, fakat Frida veya Drozer'u desteklemiyor).

> [!TIP]
> Yeni bir emülatör oluştururken ekran ne kadar büyükse, emülatör o kadar yavaş çalışır. Mümkünse küçük ekranlar seçin.

Genymotion'da google servislerini (örn. AppStore) **install** etmek için aşağıdaki resimde kırmızı ile işaretlenmiş butona tıklamanız gerekir:

![](<../../images/image (277).png>)

Ayrıca, **Genymotion içindeki Android VM konfigürasyonunda** **Bridge Network mode** seçebileceğinizi unutmayın (bu, Android VM'ye araçlarla farklı bir VM'den bağlanacaksanız faydalı olacaktır).

#### Use a physical device

Debugging seçeneklerini etkinleştirmeniz gerekir ve cihazı **root** yapabilmeniz iyi olur:

1. **Settings**.
2. (Android 8.0 ve sonrası) **System** seçin.
3. **About phone** seçin.
4. **Build number** üzerine 7 kez basın.
5. Geri gidin ve **Developer options**'ı bulacaksınız.

> Uygulamayı yükledikten sonra yapmanız gereken ilk şey onu çalıştırmak, ne yaptığını ve nasıl çalıştığını incelemek ve alışmaktır.\
> İlk dinamik analizi MobSF dynamic analysis + pidcat kullanarak yapmanızı öneririm; böylece uygulamanın **nasıl çalıştığını öğrenirken**, MobSF birçok **ilginç** **veriyi** yakalar ve daha sonra inceleyebileceğiniz pek çok bilgi sunar.

Magisk/Zygisk hızlı notlar (Pixel cihazlarda tavsiye edilir)
- Boot.img'yi Magisk uygulaması ile patchleyip fastboot ile flashlayarak systemless root elde edin
- Zygisk + DenyList'i root gizleme için etkinleştirin; daha güçlü gizleme gerektiğinde LSPosed/Shamiko düşünün
- OTA güncellemelerinden geri dönebilmek için orijinal boot.img'yi saklayın; her OTA'dan sonra yeniden patchleyin
- Ekran yansıtma için host üzerinde scrcpy kullanın



### Unintended Data Leakage

**Logging**

Geliştiriciler, **debugging information**'ı halka açık şekilde ifşa etmek konusunda dikkatli olmalıdır; aksi halde hassas veri sızıntılarına yol açabilir. Uygulama loglarını izlemek ve hassas bilgileri tespit etmek için [**pidcat**](https://github.com/JakeWharton/pidcat) ve `adb logcat` araçları önerilir. **Pidcat**, kullanım kolaylığı ve okunabilirliği sebebiyle tercih edilir.

> [!WARNING]
> **Android 4.0’dan daha yeni sürümlerden itibaren**, **uygulamalar yalnızca kendi loglarına erişebilirler**. Bu nedenle uygulamalar diğer uygulamaların loglarına erişemez.\
> Yine de, hassas bilgileri loglamamak hâlâ önerilir.

**Copy/Paste Buffer Caching**

Android'in **clipboard-based** framework'ü uygulamalarda kopyala-yapıştır işlevselliği sağlar, fakat **diğer uygulamaların** panoya erişebilme riski nedeniyle hassas verilerin açığa çıkmasına neden olabilir. Kredi kartı bilgileri gibi hassas bölümler için kopyala/yapıştır fonksiyonlarını devre dışı bırakmak önemlidir.

**Crash Logs**

Bir uygulama **crash** yapıp logları kaydederse, bu loglar özellikle uygulama tersine mühendislik yapılamıyorsa saldırganlara yardımcı olabilir. Bu riski azaltmak için crash durumlarında loglama yapmaktan kaçının; eğer loglar ağ üzerinden gönderilecekse, güvenlik için SSL kanalı üzerinden gönderildiğinden emin olun.

Bir pentester olarak, **bu loglara bakmaya çalışın**.

**Analytics Data Sent To 3rd Parties**

Uygulamalar genellikle Google Adsense gibi servisleri entegre eder; geliştiricinin hatalı uygulaması nedeniyle hassas veriler **leak** edilebilir. Potansiyel veri sızıntılarını tespit etmek için uygulamanın trafiğini intercept edin ve üçüncü taraf servislerine gönderilen hassas bilgileri kontrol edin.

### SQLite DBs

Çoğu uygulama bilgi saklamak için **internal SQLite databases** kullanır. Pentest sırasında oluşturulan **veritabanlarına**, **tabloların** ve **sütunların** isimlerine ve kaydedilen tüm **verilere** bakın; çünkü burada **hassas bilgiler** (bu bir vulnerability olur) bulabilirsiniz.\
Veritabanları genellikle `/data/data/the.package.name/databases` dizininde bulunur; örneğin `/data/data/com.mwr.example.sieve/databases`

Eğer veritabanı gizli bilgileri şifreliyorsa ve şifre uygulama içinde bulunabiliyorsa, bu hâlâ bir **vulnerability**'dir.

Tabloları `.tables` ile listeleyin ve tabloların sütunlarını `.schema <table_name>` ile inceleyin

### Drozer (Exploit Activities, Content Providers and Services)

Drozer Docs'a göre (https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer**, bir Android uygulamasının rolünü üstlenmenize ve diğer uygulamalarla etkileşim kurmanıza izin verir. Yüklü bir uygulamanın yapabileceği her şeyi yapabilir; Android’in Inter-Process Communication (IPC) mekanizmasını kullanmak ve alt işletim sistemi ile etkileşimde bulunmak gibi. .\
Drozer, export edilmiş activities, exported services ve Content Providers'ı **exploit etmek** için kullanışlı bir araçtır; bunu aşağıdaki bölümlerde öğreneceksiniz.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ayrıca, bir activity'nin kodunun `onCreate` metodunda başladığını unutmayın.

**Authorisation bypass**

Bir Activity export edilmişse, ekranını harici bir uygulamadan çağırabilirsiniz. Bu nedenle, **hassas bilgi içeren** bir activity eğer **exported** ise, ona erişmek için **authentication** mekanizmalarını **bypass** edebilirsiniz.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Ayrıca adb üzerinden export edilmiş bir activity'yi başlatabilirsiniz:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF, bir activity'de `android:launchMode` olarak _**singleTask/singleInstance**_ kullanımını kötü amaçlı olarak tespit eder, ancak [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) nedeniyle görünüşe göre bu yalnızca eski sürümlerde (API sürümleri < 21) tehlikelidir.

> [!TIP]
> Authorisation bypass her zaman bir güvenlik açığı değildir; bunun nasıl çalıştığına ve hangi bilgilerin açığa çıktığına bağlıdır.

**Hassas bilgi sızıntısı**

Activities ayrıca sonuç döndürebilir. Eğer dışa açılmış ve korunmasız bir activity bulup **`setResult`** metodunu çağırdığını ve **hassas bilgi döndürdüğünü** tespit ederseniz, hassas bilgi sızıntısı vardır.

#### Tapjacking

Eğer Tapjacking önlenmemişse, dışa açılmış activity'yi kötüye kullanarak **kullanıcının beklenmeyen işlemler gerçekleştirmesini** sağlayabilirsiniz. Tapjacking hakkında daha fazla bilgi için [**Tapjacking nedir, bağlantıya bakın**](#tapjacking).

### Exploiting Content Providers - Hassas bilgilere erişim ve manipülasyon

[**Content Provider nedir hatırlamak istiyorsanız burayı okuyun.**](android-applications-basics.md#content-provider)\
Content providers temel olarak **veri paylaşmak** için kullanılır. Eğer bir uygulamanın erişilebilir content providers'ı varsa, bunlardan **hassas veriler çıkarabilirsiniz**. Ayrıca olası **SQL injections** ve **Path Traversals**'ı test etmek ilginçtir çünkü bunlar da vulnerable olabilir.

[**Drozer ile Content Providers'ı nasıl exploit edeceğinizi öğrenin.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Service nedir hatırlamak istiyorsanız burayı okuyun.**](android-applications-basics.md#services)\
Unutmayın ki bir Service'in işlemleri `onStartCommand` metodunda başlar.

Service temelde **veri alabilen**, **işleyebilen** ve (veya) bir cevap **döndürebilen** bir şeydir. Bu nedenle, bir uygulama bazı servisleri dışa açıyorsa, ne yaptığını anlamak için **kodu** kontrol etmeli ve gizli bilgileri çıkarmak, yetkilendirme önlemlerini bypass etmek için **dinamik** olarak test etmelisiniz...\
[**Drozer ile Services'ı nasıl exploit edeceğinizi öğrenin.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Broadcast Receiver nedir hatırlamak istiyorsanız burayı okuyun.**](android-applications-basics.md#broadcast-receivers)\
Unutmayın ki bir Broadcast Receiver'ın işlemleri `onReceive` metodunda başlar.

Bir broadcast receiver belirli bir tür mesajı bekler. Alıcının mesajı nasıl işlediğine bağlı olarak açık olabilir.\
[**Drozer ile Broadcast Receivers'ı nasıl exploit edeceğinizi öğrenin.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Deep link'leri manuel olarak MobSF gibi araçları veya [bu](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) gibi script'leri kullanarak arayabilirsiniz.\
Bildirilmiş bir **scheme**'i **adb** veya bir **browser** ile açabilirsiniz:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Paket adını **belirtmeyebileceğinizi** unutmayın ve mobil cihaz o bağlantıyı açması gereken uygulamayı otomatik olarak çağıracaktır._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Çalıştırılan kod**

Uygulamada çalıştırılacak **kodu** bulmak için, deeplink tarafından çağrılan activity'ye gidin ve **`onNewIntent`** fonksiyonunu arayın.

![](<../../images/image (436) (1) (1) (1).png>)

**Hassas bilgi**

Her deep link bulduğunuzda kontrol edin ki i**çeriğinin URL parameters aracılığıyla hassas veri (like passwords) almadığını**, çünkü herhangi bir başka uygulama deep link'i **impersonate** edip bu verileri çalabilir!

**Parameters in path**

Ayrıca herhangi bir deep link'in URL path içinde bir parametre kullanıp kullanmadığını da **kontrol etmelisiniz**; örneğin: `https://api.example.com/v1/users/{username}` , bu durumda şu şekilde bir path traversal zorlayabilirsiniz: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Doğru endpoint'leri uygulama içinde bulursanız, path'in bir kısmı domain adı olarak kullanılıyorsa bir **Open Redirect** , kullanıcı detaylarını CSRF token olmadan değiştirebiliyorsanız ve zayıf endpoint uygun method'u kullanıyorsa **account takeover** ve benzeri diğer zaafiyetleri tetikleyebilirsiniz. Daha fazla [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

Bir [interesting bug bounty report](https://hackerone.com/reports/855618) links hakkında (_/.well-known/assetlinks.json_).

### Taşıma Katmanı İncelemesi ve Doğrulama Hataları

- **Sertifikalar her zaman düzgün şekilde incelenmiyor** Android uygulamaları tarafından. Bu uygulamaların uyarıları görmezden gelip self-signed sertifikaları kabul etmeleri veya bazı durumlarda HTTP bağlantılarına geri dönmeleri yaygındır.
- **SSL/TLS el sıkışması sırasında yapılan müzakereler bazen zayıf** ve güvensiz cipher suite'ler kullanılabiliyor. Bu zafiyet bağlantıyı man-in-the-middle (MITM) saldırılarına karşı savunmasız kılar ve saldırganların veriyi deşifre etmesine izin verebilir.
- **Leakage of private information** riski, uygulamalar güvenli kanallarla kimlik doğrulaması yapıp sonra diğer işlemler için güvenli olmayan kanallar üzerinden iletişim kurduğunda ortaya çıkar. Bu yaklaşım, session cookie'leri veya kullanıcı bilgileri gibi hassas verileri kötü niyetli aktörlerin ele geçirmesine karşı koruyamaz.

#### Sertifika Doğrulama

Biz **certificate verification** üzerinde yoğunlaşacağız. Sunucunun sertifikasının bütünlüğünün doğrulanması güvenliği artırmak için gereklidir. Güvensiz TLS yapılandırmaları ve hassas verilerin şifrelenmemiş kanallar üzerinden iletilmesi önemli riskler oluşturabilir. Sunucu sertifikalarının doğrulanması ve zafiyetlerin giderilmesiyle ilgili ayrıntılı adımlar için [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) kapsamlı rehberlik sağlar.

#### SSL Pinning

SSL Pinning, uygulamanın sunucunun sertifikasını uygulama içinde saklanan bilinen bir kopyaya karşı doğruladığı bir güvenlik önlemidir. Bu yöntem MITM saldırılarını önlemek için kritiktir. Hassas bilgi işleyen uygulamalarda SSL Pinning uygulanması şiddetle tavsiye edilir.

#### Traffic Inspection

HTTP trafiğini incelemek için proxy aracının sertifikasını **yüklemeniz gerekir** (ör. Burp). Bu sertifika yüklenmeden şifreli trafik proxy üzerinden görünmeyebilir. Özel bir CA sertifikasının nasıl yükleneceğine dair rehber için [**buraya tıklayın**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

API Level 24 ve üzerini hedefleyen uygulamalar, proxy'nin CA sertifikasını kabul etmek için Network Security Config üzerinde değişiklikler gerektirir. Bu adım, şifrelenmiş trafiğin incelenmesi için kritiktir. Network Security Config'in nasıl değiştirileceğine dair talimatlar için [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Eğer **Flutter** kullanılıyorsa, [**this page**](flutter.md) içindeki talimatları takip etmeniz gerekir. Çünkü sertifikayı sadece store'a eklemek işe yaramaz; Flutter'ın geçerli CA'ların kendi listesi vardır.

#### SSL/TLS pinning'in statik tespiti

Runtime bypass'lara girişmeden önce, pinning'in APK içinde nerede uygulandığını hızlıca haritalayın. Statik keşif, hook/patch planlamanıza yardımcı olur ve doğru code path'lere odaklanmanızı sağlar.

Tool: SSLPinDetect
- Açık kaynaklı statik-analiz aracı; APK'yı Smali'ye (apktool ile) decompile eder ve SSL/TLS pinning implementasyonlarına ait kürate edilmiş regex pattern'lerini tarar.
- Her eşleşme için tam dosya yolu, satır numarası ve bir kod snippet'i raporlar.
- Yaygın frameworkleri ve özel kod yollarını kapsar: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, ve Network Security Config XML pins.

Install
- Gereksinimler: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Kullanım
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Örnek pattern kuralları (JSON)
Proprietary/custom pinning stillerini tespit etmek için signatures kullanın veya genişletin. Kendi JSON'unuzu yükleyebilir ve ölçekli olarak scan yapabilirsiniz.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notlar ve ipuçları
- Büyük uygulamalarda hızlı tarama için multi-threading ve memory-mapped I/O kullanın; önceden derlenmiş regex yükü ve false positive'leri azaltır.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Sonraki triage için tipik tespit hedefleri:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Eşleşen konumları Frida hooks, statik yamalar veya konfigürasyon incelemeleri planlamak için kullanın; bunları dinamik testlerden önce gözden geçirin.

#### SSL Pinning'i Aşma

SSL Pinning uygulandığında, HTTPS trafiğini incelemek için bunu aşmak gerekir. Bu amaçla çeşitli yöntemler mevcuttur:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Uygulama içinde yaygın web zafiyetlerini aramak da önemlidir. Bu zafiyetlerin tespiti ve giderilmesine ilişkin ayrıntılı bilgiler bu özetin kapsamı dışında olmakla birlikte başka kaynaklarda geniş şekilde ele alınmıştır.

### Frida

[Frida](https://www.frida.re) geliştiriciler, reverser'lar ve güvenlik araştırmacıları için bir dynamic instrumentation toolkit'tir.\
**Çalışan uygulamaya erişip çalışma zamanında method'lara hook atarak davranışı değiştirebilir, değerleri değiştirebilir, değerleri çıkarabilir, farklı kod çalıştırabilirsiniz...**\
Android uygulamalarını pentest etmek istiyorsanız Frida kullanmayı bilmeniz gerekir.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Uygulamanın parolalar veya mnemonic'ler gibi saklamaması gereken hassas bilgileri bellekte tutup tutmadığını kontrol edin.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Bu, belleği ./dump klasörüne dökecek; orada şu gibi bir komutla grep yapabilirsiniz:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore'daki hassas veriler**

Android'de Keystore, hassas verileri saklamak için en iyi yerdir; ancak yeterli ayrıcalıklara sahip olunursa yine de **erişmek mümkün**. Uygulamalar burada genellikle **hassas verileri düz metin olarak** depolamaya eğilimli olduğundan, pentests bunu kontrol etmelidir çünkü root user veya cihaza fiziksel erişimi olan kişiler bu verileri çalabilir.

Bir uygulama keystore'da veri depolamış olsa bile, veriler şifrelenmiş olmalıdır.

Keystore içindeki verilere erişmek için şu Frida script'ini kullanabilirsiniz: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Aşağıdaki Frida scriptiyle Android uygulamalarının belirli hassas alanları korumak için uyguladığı **bypass fingerprint authentication** atlatılabilir:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Arka Plan Görüntüleri**

Bir uygulamayı arka plana attığınızda, Android uygulamanın bir **snapshot'ını** saklar; uygulama ön plana geri döndüğünde, uygulama başlamadan önce bu görüntüyü yükleyerek uygulamanın daha hızlı yüklendiği izlenimini verir.

Ancak bu snapshot **hassas bilgiler** içeriyorsa, snapshot'a erişimi olan biri bu bilgileri **çalabilir** (erişim için root gerektiğini unutmayın).

Snapshot'lar genellikle şu konumda saklanır: **`/data/system_ce/0/snapshots`**

Android, **FLAG_SECURE layout parametresini ayarlayarak ekran görüntüsü alınmasını engelleme** imkanı sağlar. Bu flag kullanıldığında, pencere içeriği güvenli kabul edilir; ekran görüntülerinde görünmesi veya güvenli olmayan ekranlarda görüntülenmesi engellenir.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Bu araç, dinamik analiz sırasında farklı araçları yönetmenize yardımcı olabilir: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Geliştiriciler genellikle bu Intent'leri işleyen ve bunları `startActivity(...)` veya `sendBroadcast(...)` gibi yöntemlere ileten activities, services ve broadcast receivers gibi proxy bileşenler oluşturur; bu durum riskli olabilir.

Tehlike, saldırganların bu Intent'leri yanlış yönlendirerek non-exported app components veya hassas content providers erişimini tetikleyebilmesindedir. Önemli bir örnek, `WebView` bileşeninin URL'leri `Intent.parseUri(...)` ile `Intent` nesnelerine dönüştürmesi ve ardından bunları çalıştırmasıdır; bu, potansiyel olarak kötü niyetli Intent enjeksiyonlarına yol açabilir.

### Temel Çıkarımlar

- **Intent Injection** web'in Open Redirect sorununa benzer.
- İstismarlar, ekstra olarak `Intent` nesnelerinin geçirilmesini ve bunların tehlikeli işlemleri gerçekleştirecek şekilde yönlendirilmesini içerir.
- Bu, non-exported app bileşenlerini ve content providers'ı saldırganlara maruz bırakabilir.
- `WebView`'in URL'den `Intent`'e dönüşümü istenmeyen eylemlere olanak sağlayabilir.

### Android Client Side Injections and others

Muhtemelen bu tür zayıflıkları Web'den biliyorsunuzdur. Bir Android uygulamasında bu zayıflıklara karşı özellikle dikkatli olmalısınız:

- **SQL Injection:** Dinamik sorgularla veya Content-Providers ile uğraşıyorsanız parametreli sorgular kullandığınızdan emin olun.
- **JavaScript Injection (XSS):** Herhangi bir WebView için JavaScript ve Plugin desteğinin devre dışı olduğundan emin olun (varsayılan olarak devre dışı). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebView'lerin dosya sistemine erişimi devre dışı olmalıdır (varsayılan olarak etkin) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Bazı durumlarda Android uygulaması oturumu kapattığında cookie iptal edilmez veya hatta diske kaydedilebilir
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Otomatik Analiz

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Statik analiz**

![](<../../images/image (866).png>)

Uygulamanın zafiyet değerlendirmesi güzel bir web tabanlı frontend kullanılarak yapılır. Ayrıca dinamik analiz de gerçekleştirebilirsiniz (ancak ortamı hazırlamanız gerekir).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSF'in **Android**(apk)**, IOS**(ipa) **ve Windows**(apx) uygulamalarını analiz edebildiğini unutmayın (_Windows uygulamaları, Windows host üzerine kurulu bir MobSF'den analiz edilmelidir_).\
Ayrıca, eğer bir **Android** veya **IOS** uygulamanın kaynak koduyla bir **ZIP** dosyası oluşturursanız (uygulamanın kök klasörüne gidip her şeyi seçip bir ZIP dosyası oluşturun), MobSF bunu da analiz edebilecektir.

MobSF ayrıca **diff/Compare** analizlerine izin verir ve **VirusTotal** ile entegrasyon sağlar (API anahtarınızı _MobSF/settings.py_ içinde ayarlamanız ve etkinleştirmeniz gerekir: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). `VT_UPLOAD` değerini `False` yaparsanız, dosya yerine **hash** **upload** edilecektir.

### Assisted Dynamic analysis with MobSF

**MobSF**, **Android** için dinamik analizde de çok yardımcı olabilir, ancak bu durumda hostunuza MobSF ve **genymotion** kurmanız gerekir (bir VM veya Docker işe yaramayacaktır). _Not: Önce genymotion'da bir VM **başlatmanız** ve ardından MobSF'yi **başlatmanız** gerekir._\
**MobSF dynamic analyser** şunları yapabilir:

- **Dump application data** (URL'ler, loglar, clipboard, sizin aldığınız ekran görüntüleri, "**Exported Activity Tester**" tarafından alınan ekran görüntüleri, e-postalar, SQLite veritabanları, XML dosyaları ve oluşturulan diğer dosyalar). Bunların hepsi otomatik olarak yapılır, ekran görüntüleri hariç; ekran görüntüsü almak istediğinizde manuel olarak butona basmanız veya tüm exported aktivitelerin ekran görüntülerini almak için "**Exported Activity Tester**"a basmanız gerekir.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Android sürümleri > 5 olduğunda, otomatik olarak **Frida**'yı başlatır ve trafiği yakalamak için global **proxy** ayarlarını yapılandırır. Sadece test edilen uygulamanın trafiğini yakalayacaktır.

**Frida**

Varsayılan olarak, SSL pinning, root detection ve debugger detection'ı **by-pass** etmek ve ilginç API'leri **monitor** etmek için bazı Frida Scripts'leri kullanır.\
MobSF ayrıca **exported activities**'leri çağırabilir, bunların **screenshots**'larını alabilir ve rapor için **save** edebilir.

Dinamik testi **başlatmak** için yeşil butona: "**Start Instrumentation**" basın. Frida script'leri tarafından üretilen logları görmek için "**Frida Live Logs**" a, hooklanmış metodların tüm çağrılarını, geçirilen argümanları ve dönen değerleri görmek için ise "**Live API Monitor**" a basın (bunlar "Start Instrumentation" a bastıktan sonra görünecektir).\
MobSF ayrıca kendi **Frida scripts**'lerinizi yüklemenize olanak verir (Frida script'lerinizin sonuçlarını MobSF'ye göndermek için `send()` fonksiyonunu kullanın). Ayrıca yükleyebileceğiniz **birkaç önceden yazılmış script** içerir (daha fazlasını `MobSF/DynamicAnalyzer/tools/frida_scripts/others/` içine ekleyebilirsiniz), sadece bunları **select** edin, "**Load**" a basın ve "**Start Instrumentation**" a basın (o script'lerin loglarını "**Frida Live Logs**" içinde görebileceksiniz).

![](<../../images/image (419).png>)

Buna ek olarak bazı Yardımcı Frida fonksiyonları mevcuttur:

- **Enumerate Loaded Classes**: Yüklenmiş tüm sınıfları yazdırır
- **Capture Strings**: Uygulamayı kullanırken yakalanan tüm string'leri yazdırır (çok gürültülüdür)
- **Capture String Comparisons**: Çok faydalı olabilir. Karşılaştırılan 2 string'i ve sonucun True mu False mu olduğunu **gösterir**.
- **Enumerate Class Methods**: Sınıf adını (ör. "java.io.File") girin ve sınıfın tüm metodlarını yazdırır.
- **Search Class Pattern**: Pattern ile sınıf araması yapar
- **Trace Class Methods**: Bir **sınıfın tamamını trace** eder (sınıfın tüm metodlarının girdilerini ve çıktlarını görür). Varsayılan olarak MobSF, birçok ilginç Android API metodunu trace ettiğini unutmayın.

Kullanmak istediğiniz yardımcı modülü seçtikten sonra "**Start Intrumentation**" a basmanız gerekir ve tüm çıktıları "**Frida Live Logs**" içinde göreceksiniz.

**Shell**

MobSF ayrıca dynamic analysis sayfasının altında bazı **adb** komutları, **MobSF** komutları ve yaygın **shell** komutları içeren bir shell sunar. Bazı ilginç komutlar:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP araçları**

HTTP trafiği yakalandığında, yakalanan trafiğin çirkin bir görünümünü "**HTTP(S) Traffic**" butonunda veya daha hoş bir görünümünü "**Start HTTPTools**" yeşil butonunda görebilirsiniz. İkinci seçenekten, yakalanan **requests**leri Burp veya Owasp ZAP gibi **proxies**'e **send** edebilirsiniz.\
Bunu yapmak için _Burp'u açın -->_ _Intercept'i kapatın --> MobSB HTTPTools içinde isteği seçin_ --> basın "**Send to Fuzzer**" --> _proxy adresini seçin_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF ile dinamik analizi bitirdikten sonra "**Start Web API Fuzzer**" a basarak **fuzz http requests** yapıp zafiyet arayabilirsiniz.

> [!TIP]
> MobSF ile dinamik analiz yaptıktan sonra proxy ayarları yanlış yapılandırılmış olabilir ve GUI'den düzeltilemeyebilir. Proxy ayarlarını şu komutla düzeltebilirsiniz:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage ile Yardımlı Dinamik Analiz

Aracı [**Inspeckage**](https://github.com/ac-pm/Inspeckage) adresinden edinebilirsiniz.\
Bu araç, **dinamik analiz** yaparken uygulamada **neler olduğunu** size bildirmek için bazı **Hooks** kullanır.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Bu, bir GUI ile **statik analiz yapmak için harika bir araçtır**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Bu araç, hem kaynak kodda hem de paketlenmiş APK'lerde çeşitli Android uygulama güvenlik zafiyetlerini aramak için tasarlanmıştır. Araç ayrıca bulunan bazı zafiyetleri sömürmek için **"Proof-of-Concept" deployable APK** ve **ADB commands** oluşturma yeteneğine sahiptir (Exposed activities, intents, tapjacking...). Drozer'da olduğu gibi, test cihazını rootlamaya gerek yoktur.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Kolay referans için çıkarılan tüm dosyaları gösterir
- APK dosyalarını otomatik olarak Java ve Smali formatına decompile eder
- AndroidManifest.xml dosyasını yaygın zafiyetler ve davranışlar açısından analiz eder
- Yaygın zafiyetler ve davranışlar için statik kaynak kod analizi
- Cihaz bilgileri
- ve daha fazlası
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER, Windows, MacOS X ve Linux'ta kullanılabilen bir komut satırı uygulamasıdır; _.apk_ dosyalarını zafiyet aramak için analiz eder. Bunu APK'ları açıp, bu zafiyetleri tespit etmek için bir dizi kural uygulayarak yapar.

Tüm kurallar `rules.json` dosyasında toplanmıştır ve her şirket veya tester ihtiyaçlarını analiz etmek için kendi kurallarını oluşturabilir.

En son ikili dosyaları [download page](https://superanalyzer.rocks/download.html) sayfasından indirin
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn, mobil uygulamalarda [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) yapan geliştiricilere, bugbounty hunters ve ethical hackers yardımcı olan bir **crossplatform** araçtır.

Kavram şu: mobil uygulama dosyanızı (.apk veya .ipa dosyası) StaCoAn uygulamasının üzerine sürükleyip bırakırsınız ve sizin için görsel ve taşınabilir bir rapor oluşturulur. Ayarları ve wordlists'i değiştirerek özelleştirilmiş bir deneyim elde edebilirsiniz.

İndir[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework, geliştiricilerin veya hackers'ın Android uygulamalarındaki potansiyel güvenlik açıklarını bulmalarına yardımcı olan bir analiz sistemidir.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** bir araçtır; ana amacı bir Android uygulaması tarafından geliştirilebilecek potansiyel kötü amaçlı davranışları tespit etmek ve kullanıcıyı uyarmaktır.

Tespit, uygulamanın Dalvik bytecode'unun, **Smali** olarak temsil edilen **static analysis** ile [`androguard`](https://github.com/androguard/androguard) kütüphanesi kullanılarak yapılır.

Bu araç, **"kötü" uygulamaların ortak davranışları** gibi Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution... arar
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Mobil uygulama reverse engineering ve analysis araçlarını bir araya getiren bir araçtır; OWASP mobile security threats karşı mobil uygulamaları test etmeye yardımcı olur. Amacı bu görevi mobil uygulama geliştiricileri ve güvenlik profesyonelleri için daha kolay ve kullanıcı dostu hale getirmektir.

It is able to:

- Extract Java and Smali code using different tools
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Useful to detect malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

Kodu obfuscate etmek için kullandığınız servis ve yapılandırmaya bağlı olarak, Secrets obfuscated olabilir veya olmayabilir.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Java bytecode'unu optimize edebilir ve kullanılmayan talimatları tespit edip kaldırabilir. ProGuard ücretsiz yazılımdır ve GNU General Public License, version 2 ile dağıtılır.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) En son kontrol ettiğimizde, Dexguard'ın çalışma modu şuydu:

- bir kaynağı InputStream olarak yükler;
- sonucu FilterInputStream'ten türeyen bir sınıfa verip decrypt eder;
- reverser'ın birkaç dakikasını boşa harcamak için bazı gereksiz obfuscation yapar;
- dekripte edilmiş sonucu ZipInputStream'e verip bir DEX dosyası elde eder;
- sonunda ortaya çıkan DEX'i `loadDex` metodunu kullanarak bir Resource olarak yükler.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Obfuscated bir APK'yı platformlarına yükleyebilirsiniz.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Her optimizasyon türü basit ve generic olduğu için kullanılan obfuscation türü önemli değildir.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. Birçok **compiler**, **packer**, **obfuscator** ve diğer tuhaf şeyleri tespit eder. Android için bir [_PEiD_](https://www.aldeid.com/wiki/PEiD) gibidir.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b, ubuntu-mate tabanlı bir Android security virtual machine'dir; farklı security meraklıları ve araştırmacıların reverse engineering ve malware analysis için en son framework, tutorial ve lab koleksiyonunu içerir.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Harika bir kaynak listesi
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android hızlı kursu
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
