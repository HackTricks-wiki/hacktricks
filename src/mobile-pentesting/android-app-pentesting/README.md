# Pentesting de Aplicaciones Android

{{#include ../../banners/hacktricks-training.md}}

## Fundamentos de Aplicaciones Android

Se recomienda encarecidamente comenzar leyendo esta página para conocer las **partes más importantes relacionadas con la seguridad de Android y los componentes más peligrosos en una aplicación Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta es la herramienta principal que necesitas para conectar con un dispositivo Android (emulado o físico).\
**ADB** permite controlar dispositivos tanto por **USB** como por **red** desde un ordenador. Esta utilidad permite la **copia** de archivos en ambas direcciones, la **instalación** y **desinstalación** de apps, la **ejecución** de comandos de shell, la **copia de seguridad** de datos, la **lectura** de logs, entre otras funciones.

Consulta la siguiente lista de [**ADB Commands**](adb-commands.md) para aprender a usar adb.

## Smali

A veces es interesante **modificar el código de la aplicación** para acceder a **información oculta** (posiblemente contraseñas bien ofuscadas o flags). Entonces, puede ser útil descompilar el apk, modificar el código y recompilarlo.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Esto puede ser muy útil como una **alternativa para varias pruebas durante el análisis dinámico** que se van a presentar. Por tanto, **mantén siempre presente esta posibilidad**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Descargar APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extraer APK del dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusiona todos los splits y los base apks con [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

Antes que nada, para analizar un APK deberías **echar un vistazo al código Java** usando un decompiler.\
Por favor, [**lee aquí para encontrar información sobre los diferentes decompilers disponibles**](apk-decompilers.md).

### Looking for interesting Info

Con solo revisar las **strings** del APK puedes buscar **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** y cualquier cosa interesante... busca incluso **backdoors** de ejecución de código o backdoors de autenticación (credenciales admin hardcoded en la app).

**Firebase**

Presta especial atención a las **firebase URLs** y comprueba si está mal configurado. [Más información sobre qué es Firebase y cómo explotarlo aquí.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

La **examinación del _Manifest.xml_ y los archivos **_strings.xml_** de una aplicación puede revelar vulnerabilidades de seguridad potenciales**. Estos archivos pueden ser accedidos usando decompilers o renombrando la extensión del archivo APK a .zip y descomprimiéndolo.

**Vulnerabilidades** identificadas en el **Manifest.xml** incluyen:

- **Debuggable Applications**: Las aplicaciones marcadas como debuggable (`debuggable="true"`) en el _Manifest.xml_ representan un riesgo ya que permiten conexiones que pueden llevar a la explotación. Para una mejor comprensión de cómo explotar aplicaciones debuggable, consulta un tutorial sobre cómo encontrar y explotar aplicaciones debuggable en un dispositivo.
- **Backup Settings**: El atributo `android:allowBackup="false"` debería establecerse explícitamente para aplicaciones que manejan información sensible para prevenir backups no autorizados vía adb, especialmente cuando usb debugging está habilitado.
- **Network Security**: Configuraciones personalizadas de network security (`android:networkSecurityConfig="@xml/network_security_config"`) en _res/xml/_ pueden especificar detalles de seguridad como certificate pins y ajustes de tráfico HTTP. Un ejemplo es permitir tráfico HTTP para dominios específicos.
- **Exported Activities and Services**: Identificar actividades y servicios exportados en el manifest puede resaltar componentes que podrían ser mal utilizados. Un análisis más profundo durante las pruebas dinámicas puede revelar cómo explotar estos componentes.
- **Content Providers and FileProviders**: Content providers expuestos podrían permitir acceso o modificación de datos no autorizada. La configuración de FileProviders también debe ser escrutada.
- **Broadcast Receivers and URL Schemes**: Estos componentes podrían ser aprovechados para explotación, prestando especial atención a cómo se gestionan los URL schemes para vulnerabilidades de entrada.
- **SDK Versions**: Los atributos `minSdkVersion`, `targetSDKVersion`, y `maxSdkVersion` indican las versiones de Android soportadas, destacando la importancia de no soportar versiones antiguas y vulnerables de Android por razones de seguridad.

Desde el archivo **strings.xml**, se pueden descubrir información sensible como API keys, schemas personalizados y otras notas del desarrollador, subrayando la necesidad de revisar cuidadosamente estos recursos.

### Tapjacking

**Tapjacking** es un ataque donde una **malicious** **application** se lanza y **se posiciona encima de una aplicación víctima**. Una vez que cubre visualmente la app víctima, su interfaz está diseñada de tal manera para engañar al usuario a interactuar con ella, mientras pasa la interacción a la app víctima.\
En efecto, está **cegando al usuario para que no sepa que en realidad está realizando acciones en la app víctima**.

Encuentra más información en:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Una **activity** con el **`launchMode`** configurado como **`singleTask` sin ningún `taskAffinity`** definido es vulnerable a Task Hijacking. Esto significa que una **application** puede ser instalada y si se lanza antes que la aplicación real podría **hijackear la tarea de la aplicación real** (por lo que el usuario estará interactuando con la **malicious application** pensando que está usando la real).

Más info en:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

En Android, los archivos **almacenados** en **internal** storage están **diseñados** para ser **accesibles** exclusivamente por la **app** que los **creó**. Esta medida de seguridad es **impuesta** por el sistema operativo Android y generalmente es adecuada para las necesidades de seguridad de la mayoría de las aplicaciones. Sin embargo, los desarrolladores a veces utilizan modos como `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` para **permitir** que los archivos sean **compartidos** entre diferentes aplicaciones. Aun así, estos modos **no restringen el acceso** a esos archivos por otras aplicaciones, incluidas potencialmente maliciosas.

1. **Static Analysis:**
- **Asegúrate** de que el uso de `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` sea **examinado cuidadosamente**. Estos modos **pueden exponer potencialmente** archivos a **accesos no intencionados o no autorizados**.
2. **Dynamic Analysis:**
- **Verifica** los **permisos** establecidos en los archivos creados por la app. Específicamente, **comprueba** si algún archivo está **establecido como legible o escribible por todo el mundo**. Esto puede suponer un riesgo significativo de seguridad, ya que permitiría a **cualquier aplicación** instalada en el dispositivo, independientemente de su origen o intención, **leer o modificar** esos archivos.

**External Storage**

Al tratar con archivos en **external storage**, como las tarjetas SD, se deben tomar ciertas precauciones:

1. **Accesibilidad**:
- Los archivos en external storage son **globalmente legibles y escribibles**. Esto significa que cualquier aplicación o usuario puede acceder a ellos.
2. **Preocupaciones de seguridad**:
- Dada la facilidad de acceso, se recomienda **no almacenar información sensible** en external storage.
- El external storage puede ser removido o accedido por cualquier aplicación, lo que lo hace menos seguro.
3. **Manejo de datos desde External Storage**:
- Siempre **realiza validación de entrada** en los datos recuperados desde external storage. Esto es crucial porque los datos provienen de una fuente no confiable.
- Se desaconseja fuertemente almacenar ejecutables o archivos .class en external storage para carga dinámica.
- Si tu aplicación debe recuperar archivos ejecutables desde external storage, asegúrate de que estos archivos estén **signed y verificados criptográficamente** antes de cargarlos dinámicamente. Este paso es vital para mantener la integridad de seguridad de tu aplicación.

External storage puede ser **accedido** en `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android permite a cada aplicación guardar fácilmente archivos xml en la ruta `/data/data/<packagename>/shared_prefs/` y a veces es posible encontrar información sensible en clear-text en esa carpeta.
- **Databases**: Android permite a cada aplicación guardar fácilmente bases de datos sqlite en la ruta `/data/data/<packagename>/databases/` y a veces es posible encontrar información sensible en clear-text en esa carpeta.

### Broken TLS

**Accept All Certificates**

For some reason sometimes developers accept all the certificates even if for example the hostname does not match with lines of code like the following one:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Una buena forma de probar esto es intentar capturar el tráfico usando algún proxy como Burp sin autorizar Burp CA dentro del dispositivo. Además, puedes generar con Burp un certificado para un nombre de host diferente y usarlo.

### Criptografía rota

**Procesos deficientes de gestión de claves**

Algunos desarrolladores guardan datos sensibles en el almacenamiento local y los encriptan con una key hardcoded/predictable en el código. Esto no debería hacerse ya que algún reversing podría permitir a atacantes extraer la información confidencial.

**Uso de algoritmos inseguros y/o obsoletos**

Los desarrolladores no deberían usar **algoritmos obsoletos** para realizar comprobaciones de **autorización**, **almacenar** o **enviar** datos. Algunos de estos algoritmos son: RC4, MD4, MD5, SHA1... Si se usan **hashes** para almacenar contraseñas por ejemplo, deben usarse hashes resistentes a fuerza bruta con sal.

### Otras comprobaciones

- Se recomienda **ofuscar el APK** para dificultar el trabajo de reverse engineering a los atacantes.
- Si la app es sensible (como apps bancarias), debería realizar sus **propias comprobaciones para ver si el móvil está rooted** y actuar en consecuencia.
- Si la app es sensible (como apps bancarias), debería comprobar si se está usando un **emulador**.
- Si la app es sensible (como apps bancarias), debería **comprobar su propia integridad antes de ejecutarse** para verificar si fue modificada.
- Usa [**APKiD**](https://github.com/rednaga/APKiD) para comprobar cuál compiler/packer/obfuscator se usó para construir el APK

### React Native Application

Lee la siguiente página para aprender cómo acceder fácilmente al código javascript de aplicaciones React:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Lee la siguiente página para aprender cómo acceder fácilmente al código C# de aplicaciones Xamarin:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Según este [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked es un algoritmo Meta que comprime el contenido de una aplicación en un único archivo. El blog habla sobre la posibilidad de crear una app que descomprima este tipo de apps... y una forma más rápida que implica **ejecutar la aplicación y recopilar los archivos descomprimidos desde el sistema de archivos.**

### Automated Static Code Analysis

La herramienta [**mariana-trench**](https://github.com/facebook/mariana-trench) es capaz de encontrar **vulnerabilidades** escaneando el **código** de la aplicación. Esta herramienta contiene una serie de **known sources** (que indican a la herramienta los **lugares** donde la **entrada** está **controlada por el usuario**), **sinks** (que indican a la herramienta **lugares peligrosos** donde la entrada maliciosa del usuario podría causar daños) y **rules**. Estas reglas indican la **combinación** de **sources-sinks** que señala una vulnerabilidad.

Con este conocimiento, **mariana-trench revisará el código y encontrará posibles vulnerabilidades en él**.

### Secrets leaked

Una aplicación puede contener secrets (API keys, passwords, hidden urls, subdomains...) dentro de ella que podrías ser capaz de descubrir. Puedes usar una herramienta como [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Otras funciones interesantes

- **Ejecución de código**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Enviar SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Funciones nativas** declaradas como `native`: `public native, System.loadLibrary, System.load`
- [Lee esto para aprender **cómo analizar funciones nativas**](reversing-native-libraries.md)
- Ejecución de código nativo en memoria vía JNI (shellcode descargado → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Otros trucos**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Análisis dinámico

> Primero que todo, necesitas un entorno donde puedas instalar la aplicación y todo el entorno (Burp CA cert, Drozer and Frida principalmente). Por lo tanto, se recomienda encarecidamente un dispositivo rooted (emulado o no).

### Análisis dinámico en línea

Puedes crear una **cuenta gratuita** en: [https://appetize.io/](https://appetize.io). Esta plataforma te permite **subir** y **ejecutar** APKs, por lo que es útil para ver cómo se comporta un apk.

Incluso puedes **ver los logs de tu aplicación** en la web y conectar mediante **adb**.

![](<../../images/image (831).png>)

Gracias a la conexión ADB puedes usar **Drozer** y **Frida** dentro de los emuladores.

### Análisis dinámico local

#### Usando un emulador

- [**Android Studio**](https://developer.android.com/studio) (Puedes crear dispositivos **x86** y **arm**, y según [**esto** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**las últimas versiones x86** soportan **librerías ARM** sin necesitar un emulador ARM lento).
- Aprende a configurarlo en esta página:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(versión gratuita:** Personal Edition, necesitas crear una cuenta. _Se recomienda **descargar** la versión **CON**_ _**VirtualBox** para evitar errores potenciales._)
- [**Nox**](https://es.bignox.com) (Gratis, pero no soporta Frida ni Drozer).

> [!TIP]
> Al crear un nuevo emulador en cualquier plataforma recuerda que cuanto más grande sea la pantalla, más lento funcionará el emulador. Así que selecciona pantallas pequeñas si es posible.

Para **instalar google services** (como AppStore) en Genymotion necesitas hacer clic en el botón marcado en rojo de la siguiente imagen:

![](<../../images/image (277).png>)

Además, fíjate que en la **configuración de la VM Android en Genymotion** puedes seleccionar **Bridge Network mode** (esto será útil si te vas a conectar a la VM Android desde una VM diferente con las herramientas).

#### Usar un dispositivo físico

Necesitas activar las opciones de **depuración** y sería ideal si pudieras **rootear** el dispositivo:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Una vez que hayas instalado la aplicación, lo primero que deberías hacer es probarla e investigar qué hace, cómo funciona y familiarizarte con ella.\
> Sugiero **realizar este análisis dinámico inicial usando MobSF dynamic analysis + pidcat**, así podremos **aprender cómo funciona la aplicación** mientras MobSF **captura** muchos **datos interesantes** que puedes revisar más tarde.

Magisk/Zygisk notas rápidas (recomendado en dispositivos Pixel)
- Parchea boot.img con la app Magisk y flashea vía fastboot para obtener root sin tocar el sistema
- Habilita Zygisk + DenyList para ocultar el root; considera LSPosed/Shamiko cuando se requiera un ocultamiento más fuerte
- Conserva el boot.img original para recuperarte de actualizaciones OTA; vuelve a parchear después de cada OTA
- Para duplicar pantalla, usa scrcpy en el host



### Filtración involuntaria de datos

**Registro**

Los desarrolladores deben tener cuidado de exponer públicamente información de depuración, ya que puede conducir a leak de datos sensibles. Se recomiendan las herramientas [**pidcat**](https://github.com/JakeWharton/pidcat) y `adb logcat` para monitorizar los logs de la aplicación e identificar y proteger información sensible. **Pidcat** es preferido por su facilidad de uso y legibilidad.

> [!WARNING]
> Ten en cuenta que desde **versiones posteriores a Android 4.0**, **las aplicaciones solo pueden acceder a sus propios logs**. Por lo tanto, las aplicaciones no pueden acceder a los logs de otras apps.\
> De todas formas, sigue siendo recomendable **no registrar información sensible**.

**Copia/Pega y caché del portapapeles**

El framework basado en **clipboard** de Android permite la funcionalidad de copiar-pegar en las apps, pero supone un riesgo ya que **otras aplicaciones** pueden **acceder** al portapapeles, exponiendo potencialmente datos sensibles. Es crucial **deshabilitar las funciones de copiar/pegar** en secciones sensibles de una aplicación, como los datos de tarjetas de crédito, para prevenir filtraciones de datos.

**Registros de fallos**

Si una aplicación **crashea** y **guarda logs**, estos logs pueden ayudar a atacantes, especialmente cuando la aplicación no puede ser reverse-engineered. Para mitigar este riesgo, evita registrar información en los crashes, y si los logs deben transmitirse por la red, asegúrate de que se envíen vía un canal SSL para seguridad.

Como pentester, **intenta echar un vistazo a estos logs**.

**Datos de analítica enviados a terceros**

Las aplicaciones a menudo integran servicios como Google Adsense, que pueden inadvertidamente leak sensitive data debido a una implementación inadecuada por parte de los desarrolladores. Para identificar posibles leaks de datos, es aconsejable **interceptar el tráfico de la aplicación** y comprobar si se está enviando información sensible a servicios de terceros.

### SQLite DBs

La mayoría de las aplicaciones utilizarán **bases de datos SQLite internas** para guardar información. Durante el pentest echa un **vistazo** a las **bases de datos** creadas, los nombres de **tablas** y **columnas** y todos los **datos** guardados porque podrías encontrar **información sensible** (lo que sería una vulnerabilidad).\
Las bases de datos deberían estar en `/data/data/the.package.name/databases` como `/data/data/com.mwr.example.sieve/databases`

Si la base de datos almacena información confidencial y está **cifrada** pero puedes **encontrar** la **contraseña** dentro de la aplicación, sigue siendo una **vulnerabilidad**.

Enumera las tablas usando `.tables` y enumera las columnas de las tablas con `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** te permite **asumir el rol de una app Android** e interactuar con otras apps. Puede hacer **todo lo que una aplicación instalada puede hacer**, como hacer uso del mecanismo de Inter-Process Communication (IPC) de Android e interactuar con el sistema operativo subyacente. .\
Drozer es una herramienta útil para **explotar activities exportadas, servicios exportados y Content Providers** como aprenderás en las secciones siguientes.

### Explotación de Activities exportadas

[**Lee esto si quieres refrescar qué es una Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Recuerda también que el código de una activity comienza en el método **`onCreate`**.

**Bypass de autorización**

Cuando una Activity está exportada puedes invocar su pantalla desde una app externa. Por lo tanto, si una activity con **información sensible** está **exportada** podrías **bypassear** los mecanismos de **autenticación** para acceder a ella.

[**Aprende cómo explotar activities exportadas con Drozer.**](drozer-tutorial/index.html#activities)

También puedes iniciar una activity exportada desde adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Ten en cuenta que un authorisation bypass no siempre es una vulnerabilidad; depende de cómo funcione el bypass y qué información quede expuesta.

**Fuga de información sensible**

**Activities can also return results**. If you manage to find an exported and unprotected activity calling the **`setResult`** method and **returning sensitive information**, there is a sensitive information leakage.

#### Tapjacking

If Tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Los Content Providers se usan básicamente para **compartir datos**. Si una app tiene Content Providers disponibles podrías ser capaz de **extraer datos sensibles** de ellos. También es interesante probar posibles **SQL injections** y **Path Traversals**, ya que podrían ser vulnerables.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Recuerda que las acciones de un Service comienzan en el método `onStartCommand`.

Un Service es básicamente algo que **puede recibir datos**, **procesarlos** y **devolver** (o no) una respuesta. Entonces, si una aplicación está exportando algunos services deberías **revisar** el **código** para entender qué hace y **probarlo** **dinámicamente** para extraer información confidencial, eludir medidas de autenticación...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Recuerda que las acciones de un Broadcast Receiver empiezan en el método `onReceive`.

Un Broadcast Receiver estará esperando un tipo de mensaje. Dependiendo de cómo el Broadcast Receiver maneje el mensaje, podría ser vulnerable.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

You can look for deep links manually, using tools like MobSF or scripts like [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
You can **open** a declared **scheme** using **adb** or a **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Ten en cuenta que puedes **omit the package name** y el móvil llamará automáticamente a la app que debería abrir ese enlace._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código ejecutado**

Para encontrar el **código que se ejecutará en la App**, ve a la activity llamada por el deeplink y busca la función **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Información sensible**

Cada vez que encuentres un deep link verifica que **no esté recibiendo datos sensibles (como contraseñas) vía parámetros de la URL**, ¡porque cualquier otra aplicación podría **suplantar el deep link y robar esos datos!**

**Parámetros en la ruta**

También **debes comprobar si algún deep link está usando un parámetro dentro de la ruta** de la URL como: `https://api.example.com/v1/users/{username}` , en ese caso puedes forzar un path traversal accediendo a algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Ten en cuenta que si encuentras los endpoints correctos dentro de la aplicación podrías provocar un **Open Redirect** (si parte de la ruta se usa como nombre de dominio), **account takeover** (si puedes modificar detalles de usuarios sin token CSRF y el endpoint vulnerable usa el método correcto) y cualquier otra vuln. Más [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**Más ejemplos**

Un [informe de bug bounty interesante](https://hackerone.com/reports/855618) sobre enlaces (_/.well-known/assetlinks.json_).

### Inspección de la capa de transporte y fallos de verificación

- **Los certificados no siempre son inspeccionados correctamente** por las aplicaciones Android. Es común que estas aplicaciones pasen por alto advertencias y acepten certificados self-signed o, en algunos casos, vuelvan a usar conexiones HTTP.
- **Las negociaciones durante el handshake SSL/TLS a veces son débiles**, empleando cipher suites inseguros. Esta vulnerabilidad hace que la conexión sea susceptible a ataques man-in-the-middle (MITM), permitiendo a los atacantes descifrar los datos.
- **La divulgación de información privada** es un riesgo cuando las aplicaciones se autentican usando canales seguros pero luego se comunican por canales no seguros en otras transacciones. Este enfoque no protege datos sensibles, como cookies de sesión o detalles de usuario, de la intercepción por entidades maliciosas.

#### Verificación de certificados

Nos centraremos en la **verificación de certificados**. Debe verificarse la integridad del certificado del servidor para aumentar la seguridad. Esto es crucial porque las configuraciones TLS inseguras y la transmisión de datos sensibles por canales no cifrados pueden suponer riesgos significativos. Para pasos detallados sobre cómo verificar certificados de servidor y solucionar vulnerabilidades, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) ofrece una guía completa.

#### SSL Pinning

SSL Pinning es una medida de seguridad en la que la aplicación verifica el certificado del servidor contra una copia conocida almacenada dentro de la propia aplicación. Este método es esencial para prevenir ataques MITM. Se recomienda encarecidamente implementar SSL Pinning en aplicaciones que manejen información sensible.

#### Inspección de tráfico

Para inspeccionar el tráfico HTTP, es necesario **instalar el certificado del proxy** (por ejemplo, Burp). Sin instalar este certificado, el tráfico cifrado podría no ser visible a través del proxy. Para una guía sobre cómo instalar un CA certificate personalizado, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Las aplicaciones dirigidas a **API Level 24 and above** requieren modificaciones en el Network Security Config para aceptar el CA certificate del proxy. Este paso es crítico para inspeccionar tráfico cifrado. Para instrucciones sobre cómo modificar el Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Si se está usando **Flutter** necesitas seguir las instrucciones en [**this page**](flutter.md). Esto se debe a que, simplemente añadiendo el certificado al store no funcionará, ya que Flutter tiene su propia lista de CAs válidas.

#### Detección estática de SSL/TLS pinning

Antes de intentar runtime bypasses, mapea rápidamente dónde se aplica el pinning en el APK. El descubrimiento estático te ayuda a planear hooks/patches y a centrarte en los code paths correctos.

Tool: SSLPinDetect
- Open-source static-analysis utility que decompila el APK a Smali (via apktool) y escanea patrones regex curados de implementaciones de SSL/TLS pinning.
- Reporta la ruta exacta del archivo, número de línea y un snippet de código para cada coincidencia.
- Cubre frameworks comunes y rutas de código personalizadas: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init con custom TrustManagers/KeyManagers, y Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Ejemplo de reglas de patrones (JSON)
Usa o extiende signatures para detectar estilos de pinning propietarios/personalizados. Puedes cargar tu propio JSON y escanear a escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notas y consejos
- Escaneo rápido en aplicaciones grandes mediante multihilo e I/O mapeado en memoria; expresiones regulares precompiladas reducen la sobrecarga/falsos positivos.
- Colección de patrones: https://github.com/aancw/smali-sslpin-patterns
- Objetivos típicos de detección para priorizar a continuación:
- OkHttp: uso de CertificatePinner, setCertificatePinner, referencias al paquete okhttp3/okhttp
- TrustManagers personalizados: javax.net.ssl.X509TrustManager, overrides de checkServerTrusted
- Contextos SSL personalizados: SSLContext.getInstance + SSLContext.init con managers personalizados
- Pins declarativos en res/xml network security config y referencias en el manifest
- Usa las ubicaciones encontradas para planificar Frida hooks, parches estáticos o revisiones de configuración antes de las pruebas dinámicas.



#### Evasión de SSL Pinning

Cuando se implementa SSL Pinning, evadirlo se vuelve necesario para inspeccionar el tráfico HTTPS. Existen varios métodos para este propósito:

- Modificar automáticamente el **apk** para evadir SSLPinning con [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). La mejor ventaja de esta opción es que no necesitarás root para evadir el SSL Pinning, pero tendrás que eliminar la aplicación y reinstalar la nueva, y esto no siempre funcionará.
- Podrías usar **Frida** (discutido abajo) para evadir esta protección. Aquí tienes una guía para usar Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- También puedes intentar **evadir automáticamente SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- También puedes intentar **evadir automáticamente SSL Pinning** usando **MobSF dynamic analysis** (explicado abajo)
- Si aún crees que hay tráfico que no estás capturando, puedes intentar **redirigir el tráfico a burp usando iptables**. Lee este blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Búsqueda de vulnerabilidades web comunes

También es importante buscar vulnerabilidades web comunes dentro de la aplicación. La información detallada sobre cómo identificarlas y mitigarlas está fuera del alcance de este resumen, pero se trata extensamente en otras fuentes.

### Frida

[Frida](https://www.frida.re) es un toolkit de instrumentación dinámica para desarrolladores, reverse-engineers e investigadores de seguridad.\
**Puedes acceder a la aplicación en ejecución y hook methods en tiempo de ejecución para cambiar el comportamiento, modificar valores, extraer valores, ejecutar distinto código...**\
Si quieres pentest aplicaciones Android necesitas saber cómo usar Frida.

- Aprende a usar Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Algunas "GUI" para acciones con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection es excelente para automatizar el uso de Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Puedes encontrar algunos scripts Awesome Frida aquí: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Intenta evadir mecanismos anti-debugging / anti-frida cargando Frida como se indica en [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (herramienta [linjector](https://github.com/erfur/linjector-rs))

#### Flujo de trabajo: Anti-instrumentation y bypass de SSL pinning

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Volcar memoria - Fridump**

Comprueba si la aplicación está almacenando información sensible en la memoria que no debería, como contraseñas o mnemónicos.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) puedes volcar la memoria de la app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Esto volcará la memoria en la carpeta ./dump, y allí podrías usar grep con algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Datos sensibles en Keystore**

En Android, el Keystore es el mejor lugar para almacenar datos sensibles; sin embargo, con suficientes privilegios sigue siendo **posible acceder a él**. Como las aplicaciones tienden a almacenar aquí **sensitive data in clear text**, los pentests deberían comprobarlo, ya que un root user o alguien con physical access al dispositivo podría robar estos datos.

Incluso si una app almacenó datos en el keystore, los datos deberían estar cifrados.

Para acceder a los datos dentro del keystore puedes usar este Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando el siguiente Frida script, podría ser posible **bypass fingerprint authentication** que las aplicaciones Android podrían estar realizando para **proteger ciertas áreas sensibles:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imágenes de fondo**

Cuando pones una aplicación en segundo plano, Android guarda una **instantánea de la aplicación** para que, cuando se recupere al primer plano, empiece mostrando la imagen antes que la aplicación, de modo que parezca que la app se cargó más rápido.

Sin embargo, si esta instantánea contiene **información sensible**, alguien con acceso a la instantánea podría **robar esa información** (ten en cuenta que necesitas root para acceder).

Las instantáneas normalmente se almacenan en: **`/data/system_ce/0/snapshots`**

Android proporciona una forma de **prevenir la captura de pantalla estableciendo el parámetro de layout FLAG_SECURE**. Al usar este flag, el contenido de la ventana se trata como seguro, impidiendo que aparezca en capturas de pantalla o que sea mostrado en pantallas no seguras.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Esta herramienta puede ayudarte a gestionar diferentes herramientas durante el análisis dinámico: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Los desarrolladores a menudo crean componentes proxy como activities, services y broadcast receivers que manejan estos Intents y los pasan a métodos como `startActivity(...)` o `sendBroadcast(...)`, lo cual puede ser riesgoso.

El peligro radica en permitir que atacantes desencadenen componentes de la app no exportados o accedan a content providers sensibles al redirigir estos Intents. Un ejemplo notable es el componente `WebView` convirtiendo URLs a objetos `Intent` mediante `Intent.parseUri(...)` y luego ejecutándolos, lo que potencialmente puede llevar a malicious Intent injections.

### Essential Takeaways

- **Intent Injection** es similar al Open Redirect de la web.
- Exploits implican pasar objetos `Intent` como extras, que pueden ser redirigidos para ejecutar operaciones inseguras.
- Puede exponer componentes no exportados y content providers a atacantes.
- La conversión de URL a `Intent` en `WebView` puede facilitar acciones no deseadas.

### Android Client Side Injections and others

Probablemente conozcas este tipo de vulnerabilidades desde la Web. Debes tener especial cuidado con estas vulnerabilidades en una aplicación Android:

- **SQL Injection:** Cuando se trate con consultas dinámicas o Content-Providers, asegúrate de usar consultas parametrizadas.
- **JavaScript Injection (XSS):** Verifica que el soporte de JavaScript y de Plugins esté deshabilitado para cualquier WebView (deshabilitado por defecto). [Más info aquí](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Los WebViews deberían tener deshabilitado el acceso al sistema de archivos (habilitado por defecto) - `(webview.getSettings().setAllowFileAccess(false);)`. [Más info aquí](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: En varios casos, cuando la aplicación Android termina la sesión, la cookie no se revoca o incluso puede guardarse en disco.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** usando un frontend web agradable. También puedes realizar análisis dinámico (pero necesitas preparar el entorno).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Tenga en cuenta que MobSF puede analizar **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Además, si creas un archivo **ZIP** con el código fuente de una app **Android** o **IOS** (ve a la carpeta raíz de la aplicación, selecciona todo y crea un ZIPfile), también podrá analizarlo.

MobSF también te permite hacer **diff/Compare** de análisis e integrar **VirusTotal** (necesitarás poner tu API key en _MobSF/settings.py_ y habilitarlo: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). También puedes poner `VT_UPLOAD` a `False`, entonces el **hash** será **upload** en lugar del archivo.

### Assisted Dynamic analysis with MobSF

**MobSF** también puede ser muy útil para **dynamic analysis** en **Android**, pero en ese caso necesitarás instalar MobSF y **genymotion** en tu host (una VM o Docker no funcionarán). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
El **MobSF dynamic analyser** puede:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Todo esto se hace automáticamente excepto las capturas de pantalla; debes pulsar cuando quieras una screenshot o debes pulsar "**Exported Activity Tester**" para obtener screenshots de todas las exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Desde versiones de Android > 5, iniciará **Frida** automáticamente y configurará el proxy global para **capture** traffic. Solo capturará tráfico de la aplicación bajo prueba.

**Frida**

Por defecto, también usará algunos Frida Scripts para **bypass SSL pinning**, **root detection** y **debugger detection** y para **monitor interesting APIs**.\
MobSF también puede **invoke exported activities**, tomar **screenshots** de ellas y **save**las para el reporte.

Para **start** el dynamic testing pulsa el botón verde: "**Start Instrumentation**". Pulsa "**Frida Live Logs**" para ver los logs generados por los Frida scripts y "**Live API Monitor**" para ver todas las invocaciones a métodos hooked, los argumentos pasados y los valores retornados (esto aparecerá después de pulsar "Start Instrumentation").\
MobSF también te permite cargar tus propios **Frida scripts** (para enviar los resultados de tus Frida scripts a MobSF usa la función `send()`). También incluye **varios scripts pre-escritos** que puedes cargar (puedes añadir más en `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), simplemente **seléctalos**, pulsa "**Load**" y pulsa "**Start Instrumentation**" (podrás ver los logs de esos scripts dentro de "**Frida Live Logs**").

![](<../../images/image (419).png>)

Además, tienes algunas funcionalidades auxiliares de Frida:

- **Enumerate Loaded Classes**: Imprimirá todas las clases cargadas.
- **Capture Strings**: Imprimirá todas las strings capturadas mientras usas la aplicación (muy ruidoso).
- **Capture String Comparisons**: Puede ser muy útil. **Mostrará las 2 strings que se están comparando** y si el resultado fue True o False.
- **Enumerate Class Methods**: Introduce el nombre de la clase (por ejemplo "java.io.File") y listará todos los métodos de la clase.
- **Search Class Pattern**: Busca clases por patrón.
- **Trace Class Methods**: **Trace** a **whole class** (ver entradas y salidas de todos los métodos de la clase). Recuerda que por defecto MobSF traza varios métodos interesantes del Android Api.

Una vez que hayas seleccionado el módulo auxiliar que quieras usar necesitas pulsar "**Start Intrumentation**" y verás todas las salidas en "**Frida Live Logs**".

**Shell**

Mobsf también incluye un shell con algunos comandos **adb**, comandos de **MobSF**, y comandos comunes de **shell** en la parte inferior de la página de dynamic analysis. Algunos comandos interesantes:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Herramientas HTTP**

When http traffic is capture you can see an ugly view of the captured traffic on "**HTTP(S) Traffic**" bottom or a nicer view in "**Start HTTPTools**" green bottom. From the second option, you can **send** the **captured requests** to **proxies** like Burp or Owasp ZAP.\
To do so, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una vez finalizado el análisis dinámico con MobSF puedes pulsar "**Start Web API Fuzzer**" para **fuzz http requests** y buscar vulnerabilidades.

> [!TIP]
> Después de realizar un análisis dinámico con MobSF, la configuración del proxy puede quedar mal configurada y no podrás arreglarla desde la GUI. Puedes corregir la configuración del proxy ejecutando:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Análisis dinámico asistido con Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta herramienta usa algunos **Hooks** para informarte **qué está pasando en la aplicación** mientras realizas un **análisis dinámico**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta es una **excelente herramienta para realizar static analysis con una GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta herramienta está diseñada para buscar varias **vulnerabilidades de seguridad relacionadas con aplicaciones Android**, ya sea en **source code** o en **packaged APKs**. La herramienta también es **capaz de crear un "Proof-of-Concept" deployable APK** y **ADB commands**, para explotar algunas de las vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Como con Drozer, no es necesario rootear el dispositivo de prueba.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Muestra todos los archivos extraídos para facilitar su consulta
- Descompila automáticamente archivos APK a formato Java y Smali
- Analiza AndroidManifest.xml en busca de vulnerabilidades y comportamientos comunes
- Análisis estático del código fuente en busca de vulnerabilidades y comportamientos comunes
- Información del dispositivo
- y más
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER es una aplicación de línea de comandos que se puede usar en Windows, MacOS X y Linux, que analiza archivos _.apk_ en busca de vulnerabilidades. Hace esto descomprimiendo los APKs y aplicando una serie de reglas para detectar esas vulnerabilidades.

Todas las reglas están centralizadas en un archivo `rules.json`, y cada empresa o tester puede crear sus propias reglas para analizar lo que necesiten.

Descarga los binarios más recientes en la [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn es una herramienta **multiplataforma** que ayuda a desarrolladores, bugbounty hunters y ethical hackers a realizar [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) en aplicaciones móviles.

El concepto es que arrastras y sueltas el archivo de tu aplicación móvil (un archivo .apk o .ipa) en la aplicación StaCoAn y esta generará un informe visual y portable para ti. Puedes ajustar la configuración y las wordlists para obtener una experiencia personalizada.

Descargar[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework es un sistema de análisis de vulnerabilidades en Android que ayuda a desarrolladores o hackers a encontrar posibles vulnerabilidades de seguridad en aplicaciones Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** es una herramienta cuyo objetivo principal es detectar y advertir al usuario sobre comportamientos potencialmente maliciosos desarrollados por una aplicación Android.

La detección se realiza mediante el **análisis estático** del Dalvik bytecode de la aplicación, representado como **Smali**, con la librería [`androguard`](https://github.com/androguard/androguard).

Esta herramienta busca **comportamientos comunes de aplicaciones "malas"** como: exfiltración de identificadores de telefonía, intercepción de flujos de audio/video, modificación de datos PIM, ejecución arbitraria de código...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Es una herramienta que agrupa las herramientas comúnmente usadas de reverse engineering y análisis de aplicaciones móviles, para ayudar a probar aplicaciones móviles frente a las amenazas de seguridad móvil de OWASP. Su objetivo es hacer esta tarea más fácil y amigable para desarrolladores de aplicaciones móviles y profesionales de seguridad.

Es capaz de:

- Extraer código Java y Smali usando diferentes herramientas
- Analizar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraer información privada del APK usando regexps.
- Analizar el Manifest.
- Analizar los dominios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK vía [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Ofuscación/Desofuscación de código

Tenga en cuenta que, dependiendo del servicio y la configuración que use para ofuscar el código, los secretos pueden o no terminar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Es capaz de optimizar bytecode así como detectar y eliminar instrucciones no usadas. ProGuard es software libre y se distribuye bajo la GNU General Public License, versión 2.

ProGuard se distribuye como parte del Android SDK y se ejecuta al construir la aplicación en modo release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Puedes subir un APK ofuscado a su plataforma.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Usa la API pública Gemini de Google.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Cada tipo de optimización es simple y genérico, por lo que no importa qué tipo específico de ofuscación se haya usado.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD te da información sobre **cómo se hizo un APK**. Identifica muchos **compilers**, **packers**, **obfuscators**, y otras cosas raras. Es [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

[Lee este tutorial para aprender algunos trucos sobre **cómo revertir ofuscación personalizada**](manual-deobfuscation.md)

## Laboratorios

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b es una máquina virtual de seguridad Android basada en ubuntu-mate que incluye la colección de los últimos frameworks, tutoriales y labs de diferentes geeks e investigadores de seguridad para reverse engineering y malware analysis.

## Referencias

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Es una gran lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Curso rápido de Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
