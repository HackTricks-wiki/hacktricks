# Pentesting de Aplicações Android

{{#include ../../banners/hacktricks-training.md}}

## Noções Básicas sobre Aplicações Android

É altamente recomendado começar lendo esta página para conhecer as **partes mais importantes relacionadas à segurança do Android e os componentes mais perigosos em uma aplicação Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Esta é a ferramenta principal para conectar a um dispositivo android (emulado ou físico).\
**ADB** permite controlar dispositivos tanto por **USB** quanto por **Network** a partir de um computador. Esta utilidade possibilita a **cópia** de arquivos em ambas as direções, **instalação** e **desinstalação** de apps, **execução** de comandos de shell, **backup** de dados, **leitura** de logs, entre outras funções.

Consulte a seguinte lista de [**ADB Commands**](adb-commands.md) para aprender como usar o adb.

## Smali

Às vezes é interessante **modificar o código da aplicação** para acessar **informações ocultas** (por exemplo, senhas bem ofuscadas ou flags). Nesse caso, pode ser útil decompilar o apk, modificar o código e recompilá-lo.\
[**Neste tutorial** você pode **aprender como decompilar um APK, modificar código Smali e recompilar o APK** com a nova funcionalidade](smali-changes.md). Isso pode ser muito útil como uma **alternativa para diversos testes durante a análise dinâmica** que serão apresentados. Portanto, **mantenha sempre em mente essa possibilidade**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Baixar APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extrair APK do dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Mesclar todos os splits e os base apks com [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}


{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Análise Estática

Antes de mais nada, para analisar um APK você deve **dar uma olhada no código Java** usando um decompilador.\
Por favor, [**leia aqui para encontrar informações sobre diferentes decompiladores disponíveis**](apk-decompilers.md).

### Procurando informações interessantes

Apenas olhando as **strings** do APK você pode procurar por **senhas**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** e qualquer coisa interessante... procure até por backdoors de execução de código ou backdoors de autenticação (credenciais de admin hardcoded no app).

**Firebase**

Preste atenção especial às **Firebase URLs** e verifique se estão mal configuradas. [Mais informações sobre o que é Firebase e como explorá-lo aqui.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Entendimento básico da aplicação - Manifest.xml, strings.xml

A **análise do _Manifest.xml_ e dos arquivos **_strings.xml_** de uma aplicação pode revelar potenciais vulnerabilidades de segurança**. Esses arquivos podem ser acessados usando decompiladores ou renomeando a extensão do APK para .zip e descompactando-o.

As **vulnerabilidades** identificadas a partir do **Manifest.xml** incluem:

- **Debuggable Applications**: Aplicações definidas como debuggable (`debuggable="true"`) no _Manifest.xml_ representam um risco, pois permitem conexões que podem levar à exploração. Para entender melhor como explorar aplicações debuggable, consulte um tutorial sobre como encontrar e explorar aplicações debuggable em um dispositivo.
- **Backup Settings**: O atributo `android:allowBackup="false"` deve ser definido explicitamente para aplicações que lidam com informações sensíveis para impedir backups não autorizados via adb, especialmente quando usb debugging está habilitado.
- **Network Security**: Configurações personalizadas de segurança de rede (`android:networkSecurityConfig="@xml/network_security_config"`) em _res/xml/_ podem especificar detalhes de segurança como certificate pins e configurações de tráfego HTTP. Um exemplo é permitir tráfego HTTP para domínios específicos.
- **Exported Activities and Services**: Identificar activities e services exportados no manifest pode destacar componentes que podem ser mal utilizados. Análises adicionais durante testes dinâmicos podem revelar como explorar esses componentes.
- **Content Providers and FileProviders**: Content providers expostos podem permitir acesso ou modificação não autorizada de dados. A configuração de FileProviders também deve ser escrutinada.
- **Broadcast Receivers and URL Schemes**: Esses componentes podem ser aproveitados para exploração, com atenção especial em como os esquemas de URL são gerenciados para vulnerabilidades de input.
- **SDK Versions**: Os atributos `minSdkVersion`, `targetSDKVersion` e `maxSdkVersion` indicam as versões do Android suportadas, ressaltando a importância de não suportar versões antigas e vulneráveis do Android por motivos de segurança.

No arquivo **strings.xml**, informações sensíveis como API keys, custom schemas e outras notas de desenvolvedor podem ser descobertas, ressaltando a necessidade de revisão cuidadosa desses recursos.

### Tapjacking

**Tapjacking** é um ataque onde uma **aplicação** **maliciosa** é lançada e **se posiciona sobre a aplicação vítima**. Uma vez que obscurece visivelmente o app vítima, sua interface é projetada de forma a enganar o usuário para interagir com ela, enquanto a interação é passada para o app vítima.\
Na prática, isso **cega o usuário, que não sabe que na verdade está realizando ações no app vítima**.

Encontre mais informação em:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Uma **activity** com o **`launchMode`** definida como **`singleTask` sem qualquer `taskAffinity`** definida é vulnerável a Task Hijacking. Isso significa que uma **aplicação** pode ser instalada e, se lançada antes da aplicação real, pode **sequestrar a task da aplicação real** (fazendo com que o usuário interaja com a **aplicação maliciosa achando que está usando a aplicação legítima**).

Mais informações em:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Armazenamento de dados inseguro

**Internal Storage**

No Android, arquivos **armazenados** em **internal** storage são **projetados** para serem **acessíveis** exclusivamente pelo **app** que os **criou**. Essa medida de segurança é **aplicada** pelo sistema operacional Android e é geralmente adequada para as necessidades de segurança da maioria das aplicações. No entanto, desenvolvedores às vezes utilizam modos como `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` para **permitir** que arquivos sejam **compartilhados** entre diferentes aplicações. Esses modos, porém, **não restringem o acesso** a esses arquivos por outras aplicações, incluindo possíveis aplicações maliciosas.

1. **Análise Estática:**
- **Verifique** cuidadosamente o uso de `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE`. Esses modos **podem expor** arquivos a **acesso não intencional ou não autorizado**.
2. **Análise Dinâmica:**
- **Verifique** as **permissões** definidas em arquivos criados pelo app. Especificamente, **confirme** se algum arquivo está **definido como legível ou gravável por todos**. Isso pode representar um risco de segurança significativo, pois permitiria **qualquer aplicação** instalada no dispositivo, independentemente de sua origem ou intenção, **ler ou modificar** esses arquivos.

**External Storage**

Ao lidar com arquivos no **external storage**, como SD Cards, algumas precauções devem ser tomadas:

1. **Acessibilidade**:
- Arquivos no external storage são **globalmente legíveis e graváveis**. Isso significa que qualquer aplicação ou usuário pode acessar esses arquivos.
2. **Preocupações de Segurança**:
- Dada a facilidade de acesso, é recomendado **não armazenar informações sensíveis** no external storage.
- O external storage pode ser removido ou acessado por qualquer aplicação, tornando-o menos seguro.
3. **Tratamento de Dados do External Storage**:
- Sempre **realize validação de input** nos dados recuperados do external storage. Isso é crucial porque os dados vêm de uma fonte não confiável.
- Não é recomendado armazenar executáveis ou arquivos de classe no external storage para carregamento dinâmico.
- Se sua aplicação precisar recuperar arquivos executáveis do external storage, garanta que esses arquivos estejam **assinados e verificados criptograficamente** antes de serem carregados dinamicamente. Essa etapa é vital para manter a integridade de segurança da sua aplicação.

External storage pode ser **acessado** em /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> A partir do Android 4.4 (**API 17**), o SD card possui uma estrutura de diretórios que **limita o acesso de um app ao diretório especificamente destinado àquele app**. Isso impede que aplicações maliciosas obtenham acesso de leitura ou escrita aos arquivos de outro app.

**Dados sensíveis armazenados em texto claro**

- **Shared preferences**: O Android permite que cada aplicação salve facilmente arquivos xml no caminho /data/data/<packagename>/shared_prefs/ e às vezes é possível encontrar informações sensíveis em texto claro nessa pasta.
- **Databases**: O Android permite que cada aplicação salve facilmente bancos sqlite no caminho /data/data/<packagename>/databases/ e às vezes é possível encontrar informações sensíveis em texto claro nessa pasta.

### Broken TLS

**Accept All Certificates**

Por algum motivo, às vezes desenvolvedores aceitam todos os certificados mesmo se, por exemplo, o hostname não corresponder, com linhas de código como a seguinte:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Uma boa maneira de testar isso é tentar capturar o tráfego usando algum proxy como o Burp sem autorizar o Burp CA dentro do dispositivo. Além disso, você pode gerar com o Burp um certificado para um hostname diferente e usá-lo.

### Criptografia Quebrada

**Processos pobres de gerenciamento de chaves**

Alguns desenvolvedores salvam dados sensíveis no armazenamento local e os encriptam com uma chave hardcoded/preditível no código. Isso não deveria ser feito, pois algum reversing pode permitir que atacantes extraiam a informação confidencial.

**Uso de algoritmos inseguros e/ou obsoletos**

Desenvolvedores não devem usar **deprecated algorithms** para realizar **checks** de autorização, **store** ou **send** dados. Alguns desses algoritmos são: RC4, MD4, MD5, SHA1... Se **hashes** forem usados para armazenar passwords, por exemplo, devem ser usados hashes resistentes a brute-force com salt.

### Outras verificações

- É recomendado **ofuscar o APK** para dificultar o trabalho de reverse engineer para os atacantes.
- Se o app for sensível (como apps bancários), ele deve realizar suas próprias verificações para ver se o dispositivo está rooted e agir em consequência.
- Se o app for sensível (como apps bancários), ele deve checar se um **emulator** está sendo usado.
- Se o app for sensível (como apps bancários), ele deve **verificar sua própria integridade antes de executar** para checar se foi modificado.
- Use [**APKiD**](https://github.com/rednaga/APKiD) para verificar qual compiler/packer/obfuscator foi usado para construir o APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Execução de código**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Envio de SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Funções nativas** declaradas como `native`: `public native, System.loadLibrary, System.load`
- [Leia isto para aprender **como reverse native functions**](reversing-native-libraries.md)
- Execução de código nativo em memória via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Análise Dinâmica

> Primeiro de tudo, você precisa de um ambiente onde possa instalar a aplicação e todo o ambiente (principalmente o Burp CA cert, Drozer and Frida). Portanto, um dispositivo rootado (emulado ou não) é extremamente recomendado.

### Análise Dinâmica Online

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Análise Dinâmica Local

#### Usando um emulador

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versão gratuita:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Gratuito, mas não suporta Frida ou Drozer).

> [!TIP]
> Ao criar um novo emulador em qualquer plataforma, lembre-se que quanto maior a tela, mais lento o emulador irá rodar. Então selecione telas pequenas se possível.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Desenvolvedores devem ter cautela ao expor informações de debugging publicamente, pois isso pode levar a sensitive data leaks. As ferramentas [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` são recomendadas para monitorar os logs da aplicação e identificar e proteger informações sensíveis. **Pidcat** é preferida por sua facilidade de uso e legibilidade.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

O framework baseado em clipboard do Android permite a funcionalidade de copiar/colar em apps, porém representa um risco pois **other applications** podem **access** o clipboard, potencialmente expondo dados sensíveis. É crucial desabilitar funções de copy/paste para seções sensíveis de uma aplicação, como detalhes de cartão de crédito, para prevenir data leaks.

**Crash Logs**

Se uma aplicação **crasha** e **salva logs**, esses logs podem ajudar atacantes, particularmente quando a aplicação não pode ser reverse-engineered. Para mitigar esse risco, evite logar em crashes, e se os logs precisarem ser transmitidos pela rede, garanta que sejam enviados via um canal SSL por segurança.

Como pentester, **tente dar uma olhada nesses logs**.

**Analytics Data Sent To 3rd Parties**

Aplicações frequentemente integram serviços como Google Adsense, os quais podem inadvertidamente **leak sensitive data** devido à implementação inadequada pelos desenvolvedores. Para identificar possíveis leaks, é aconselhável interceptar o tráfego da aplicação e verificar se qualquer informação sensível está sendo enviada para serviços de terceiros.

### SQLite DBs

A maioria das aplicações usará **internal SQLite databases** para salvar informação. Durante o pentest dê uma olhada nos **databases** criados, nos nomes de **tables** e **columns** e em todos os **dados** salvos porque você pode encontrar **informação sensível** (o que seria uma vulnerabilidade).\
Databases should be located in `/data/data/the.package.name/databases` like `/data/data/com.mwr.example.sieve/databases`

Se o database estiver salvando informação confidencial e estiver **encrypted** mas você conseguir **find** a **password** dentro da aplicação, isso ainda é uma **vulnerabilidade**.

Enumere as tabelas usando `.tables` e enumere as colunas das tabelas com `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Leia isto se quiser relembrar o que é uma Activity do Android.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [isto](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Note que um authorisation bypass nem sempre é uma vulnerabilidade; isso depende de como o bypass funciona e quais informações são expostas.

**Vazamento de informações sensíveis**

**Activities can also return results**. Se você conseguir encontrar uma activity exportada e desprotegida que chame o método **`setResult`** e **retorne informações sensíveis**, há um vazamento de informações sensíveis.

#### Tapjacking

If tapjacking isn't prevented, you could abuse the exported activity to make the **user perform unexpected actions**. Para mais informações sobre [**o que é Tapjacking siga o link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers são basicamente usados para **compartilhar dados**. Se um app tem content providers disponíveis, você pode ser capaz de **extrair informações sensíveis** deles. Também é interessante testar possíveis **SQL injections** e **Path Traversals**, pois eles podem ser vulneráveis.

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
Lembre-se de que as ações de um Service começam no método `onStartCommand`.

Um service é basicamente algo que **pode receber dados**, **processá-los** e **retornar** (ou não) uma resposta. Então, se uma aplicação estiver exportando alguns services você deve **verificar** o **código** para entender o que ele está fazendo e **testá-lo** **dinamicamente** para extrair informações confidenciais, contornar medidas de autenticação...\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Lembre-se de que as ações de um Broadcast Receiver começam no método `onReceive`.

Um broadcast receiver ficará esperando por um tipo de mensagem. Dependendo de como o receiver lida com a mensagem, ele pode ser vulnerável.\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Você pode procurar por deep links manualmente, usando ferramentas como MobSF ou scripts como [este](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Você pode **abrir** um declarado **scheme** usando **adb** ou um **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Observe que você pode **omitir o nome do pacote** e o dispositivo móvel chamará automaticamente o aplicativo que deve abrir esse link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código executado**

Para encontrar o **código que será executado no App**, vá para a activity chamada pelo deeplink e procure a função **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informação sensível**

Sempre que encontrar um deep link verifique que **ele não está recebendo dados sensíveis (como senhas) via parâmetros de URL**, porque qualquer outra aplicação poderia **se passar pelo deep link e roubar esses dados!**

**Parâmetros no caminho**

Você **deve também verificar se algum deep link está usando um parâmetro dentro do caminho** da URL como: `https://api.example.com/v1/users/{username}`, nesse caso você pode forçar um path traversal acessando algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Note que se você encontrar os endpoints corretos dentro da aplicação pode ser capaz de causar um **Open Redirect** (se parte do caminho for usada como nome de domínio), **account takeover** (se você puder modificar detalhes de usuários sem token CSRF e o endpoint vulnerável usar o método correto) e qualquer outra vuln. Mais [mais informações sobre isso aqui](http://dphoeniixx.com/2020/12/13-2/).

**Mais exemplos**

Um [relatório de bug bounty interessante](https://hackerone.com/reports/855618) sobre links (_/.well-known/assetlinks.json_).

### Inspeção da Camada de Transporte e Falhas de Verificação

- **Certificados nem sempre são inspecionados corretamente** por aplicações Android. É comum que essas aplicações ignorem avisos e aceitem certificados self-signed ou, em alguns casos, revertam para conexões HTTP.
- **Negociações durante o handshake SSL/TLS às vezes são fracas**, empregando cipher suites inseguros. Essa vulnerabilidade torna a conexão suscetível a ataques man-in-the-middle (MITM), permitindo que atacantes desencriptem os dados.
- **Vazamento de informações privadas** é um risco quando aplicações autenticam usando canais seguros mas depois se comunicam por canais não seguros para outras transações. Essa abordagem não protege dados sensíveis, como cookies de sessão ou detalhes do usuário, contra interceptação por entidades maliciosas.

#### Verificação de Certificado

Vamos focar na **verificação de certificados**. A integridade do certificado do servidor deve ser verificada para aumentar a segurança. Isso é crucial porque configurações TLS inseguras e a transmissão de dados sensíveis por canais não criptografados podem representar riscos significativos. Para passos detalhados sobre como verificar certificados de servidor e tratar vulnerabilidades, [**este recurso**](https://manifestsecurity.com/android-application-security-part-10/) fornece orientação abrangente.

#### SSL Pinning

SSL Pinning é uma medida de segurança onde a aplicação verifica o certificado do servidor comparando com uma cópia conhecida armazenada dentro da própria aplicação. Esse método é essencial para prevenir ataques MITM. Recomenda-se fortemente implementar SSL Pinning em aplicações que lidam com informação sensível.

#### Inspeção de Tráfego

Para inspecionar tráfego HTTP, é necessário **instalar o certificado da ferramenta proxy** (por exemplo, Burp). Sem instalar esse certificado, o tráfego criptografado pode não ser visível através do proxy. Para um guia sobre como instalar um certificado CA customizado, [**clique aqui**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplicações que visam **API Level 24 and above** requerem modificações no Network Security Config para aceitar o certificado CA do proxy. Esse passo é crítico para inspecionar tráfego criptografado. Para instruções sobre modificar o Network Security Config, [**consulte este tutorial**](make-apk-accept-ca-certificate.md).

Se **Flutter** estiver sendo usado, você precisa seguir as instruções em [**esta página**](flutter.md). Isso é porque, apenas adicionar o certificado ao store não funcionará já que o Flutter tem sua própria lista de CAs válidas.

#### Detecção estática de SSL/TLS pinning

Antes de tentar bypasses em runtime, mapeie rapidamente onde o pinning é aplicado no APK. A descoberta estática ajuda a planejar hooks/patches e a focar nos caminhos de código corretos.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Instalar
- Pré-requisitos: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Uso
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemplo de regras de padrão (JSON)
Use ou estenda signatures para detectar estilos proprietários/personalizados de pinning. Você pode carregar seu próprio JSON e escanear em larga escala.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notas e dicas
- Fast scanning on large apps via multi-threading and memory-mapped I/O; pre-compiled regex reduces overhead/false positives.
- Coleção de padrões: https://github.com/aancw/smali-sslpin-patterns
- Alvos típicos de detecção para triagem a seguir:
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Use the matched locations to plan Frida hooks, static patches, or config reviews before dynamic testing.



#### Contornando SSL Pinning

Quando SSL Pinning está implementado, contorná-lo torna-se necessário para inspecionar o tráfego HTTPS. Diversos métodos estão disponíveis para isso:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Procurando Vulnerabilidades Web Comuns

Também é importante procurar por vulnerabilidades web comuns dentro da aplicação. Informações detalhadas sobre identificação e mitigação dessas vulnerabilidades fogem ao escopo deste resumo, mas são amplamente cobertas em outros lugares.

### Frida

[Frida](https://www.frida.re) é um toolkit de instrumentação dinâmica para desenvolvedores, analistas de engenharia reversa, e pesquisadores de segurança.\
**Você pode acessar a aplicação em execução e hookar métodos em tempo de execução para alterar o comportamento, modificar valores, extrair valores, executar código diferente...**\
Se você quer pentestar aplicações Android, precisa saber como usar o Frida.

- Aprenda a usar o Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Algumas "GUI" para ações com Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection é ótimo para automatizar o uso do Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Você pode encontrar alguns scripts Awesome do Frida aqui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Tente contornar mecanismos anti-debugging / anti-frida carregando o Frida como indicado em [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump de Memória - Fridump**

Verifique se a aplicação está armazenando informações sensíveis na memória que não deveria armazenar, como senhas ou mnemonics.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) você pode dumpar a memória do app com:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Isso fará dump da memória no diretório ./dump, e lá você poderá usar grep com algo como:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Dados sensíveis no Keystore**

No Android, o Keystore é o melhor lugar para armazenar dados sensíveis, no entanto, com privilégios suficientes ainda é **possível acessá-lo**. Como aplicações tendem a armazenar aqui **dados sensíveis em clear text** os pentests devem verificar isso, pois um root user ou alguém com acesso físico ao dispositivo pode conseguir roubar esses dados.

Mesmo que um app armazene dados no keystore, os dados devem estar criptografados.

Para acessar os dados dentro do keystore você pode usar este Frida script: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Usando o seguinte Frida script, pode ser possível **bypass fingerprint authentication** realizada por aplicações Android para **proteger certas áreas sensíveis:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Imagens de Fundo**

Quando você coloca um aplicativo em segundo plano, o Android armazena um **instantâneo do aplicativo** para que, quando ele for recuperado para o primeiro plano, comece a carregar a imagem antes do aplicativo, fazendo com que pareça que o app foi carregado mais rápido.

No entanto, se esse snapshot contiver **informações sensíveis**, alguém com acesso ao snapshot pode **roubar essas informações** (observe que você precisa de root para acessá-lo).

Os snapshots normalmente são armazenados em: **`/data/system_ce/0/snapshots`**

O Android fornece uma forma de **impedir a captura de tela configurando o parâmetro de layout FLAG_SECURE**. Ao usar essa flag, o conteúdo da janela é tratado como seguro, impedindo que apareça em capturas de tela ou que seja visualizado em displays não seguros.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Esta ferramenta pode ajudar a gerenciar diferentes ferramentas durante a análise dinâmica: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Frequentemente os desenvolvedores criam componentes proxy como activities, services e broadcast receivers que manipulam esses Intents e os passam para métodos como `startActivity(...)` ou `sendBroadcast(...)`, o que pode ser arriscado.

O perigo está em permitir que atacantes acionem componentes do app não-exportados ou acessem content providers sensíveis ao redirecionar indevidamente esses Intents. Um exemplo notável é o componente `WebView` converter URLs em objetos `Intent` via `Intent.parseUri(...)` e então executá-los, potencialmente levando a um Intent Injection malicioso.

### Principais conclusões

- **Intent Injection** é similar ao problema de Open Redirect na web.
- Exploits envolvem passar objetos `Intent` como extras, que podem ser redirecionados para executar operações inseguras.
- Isso pode expor componentes não-exportados e content providers a atacantes.
- A conversão de URLs para `Intent` do `WebView` pode facilitar ações não intencionais.

### Android Client Side Injections and others

Provavelmente você conhece esse tipo de vulnerabilidade pela Web. Deve ter cuidado especial com essas vulnerabilidades em uma aplicação Android:

- **SQL Injection:** Ao lidar com queries dinâmicas ou Content-Providers, assegure-se de usar consultas parametrizadas.
- **JavaScript Injection (XSS):** Verifique que o suporte a JavaScript e Plugins está desabilitado para qualquer WebViews (desabilitado por padrão). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Os WebViews devem ter acesso ao sistema de arquivos desabilitado (habilitado por padrão) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: Em vários casos, quando a aplicação Android termina a sessão o cookie não é revogado ou pode até ser salvo em disco
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Análise Automática

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análise estática**

![](<../../images/image (866).png>)

**Avaliação de vulnerabilidades da aplicação** usando uma interface web agradável. Você também pode realizar análise dinâmica (mas precisa preparar o ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Observe que o MobSF pode analisar **Android**(apk)**, IOS**(ipa) **and Windows**(apx) aplicações (_As aplicações Windows devem ser analisadas a partir de um MobSF instalado em um host Windows_).\
Além disso, se você criar um arquivo **ZIP** com o código-fonte de um app **Android** ou **IOS** (vá para a pasta raiz do aplicativo, selecione tudo e crie um arquivo ZIP), ele também será capaz de analisá-lo.

O MobSF também permite fazer **diff/Compare** de análises e integrar o **VirusTotal** (você precisará configurar sua API key em _MobSF/settings.py_ e habilitá-la: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Você também pode definir `VT_UPLOAD` como `False`, então o **hash** será **upload** em vez do arquivo.

### Análise Dinâmica Assistida com MobSF

**MobSF** também pode ser muito útil para **análise dinâmica** em **Android**, mas nesse caso você precisará instalar o MobSF e o **genymotion** no seu host (uma VM ou Docker não funcionarão). _Nota: você precisa **iniciar primeiro uma VM no genymotion** e **depois o MobSF.**_\
O **analisador dinâmico do MobSF** pode:

- **Dump application data** (URLs, logs, clipboard, capturas de tela feitas por você, capturas de tela feitas pelo "**Exported Activity Tester**", emails, bancos de dados SQLite, arquivos XML e outros arquivos gerados). Tudo isso é feito automaticamente, exceto pelas capturas de tela: você precisa pressionar quando quiser uma captura ou pressionar "**Exported Activity Tester**" para obter capturas de todas as activities exportadas.
- Capturar **HTTPS traffic**
- Usar **Frida** para obter **informações de tempo de execução**

A partir das versões do **Android** **> 5**, ele ** irá iniciar automaticamente o Frida ** e definirá as configurações globais de **proxy** para **capture** o tráfego. Ele capturará apenas o tráfego da aplicação testada.

**Frida**

Por padrão, ele também usará alguns Frida Scripts para **bypass SSL pinning**, **root detection** e **debugger detection** e para **monitor interesting APIs**.\
O MobSF também pode **invoke exported activities**, capturar **screenshots** delas e **save** para o relatório.

Para **start** os testes dinâmicos pressione o botão verde: "**Start Instrumentation**". Pressione "**Frida Live Logs**" para ver os logs gerados pelos Frida scripts e "**Live API Monitor**" para ver todas as invocações para métodos hookados, argumentos passados e valores retornados (isso aparecerá após pressionar "Start Instrumentation").\
O MobSF também permite carregar seus próprios **Frida scripts** (para enviar os resultados dos seus Frida scripts para o MobSF use a função `send()`). Ele também tem **several pre-written scripts** que você pode carregar (você pode adicionar mais em `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), apenas **select them**, pressione "**Load**" e pressione "**Start Instrumentation**" (você poderá ver os logs desses scripts dentro de "**Frida Live Logs**").

![](<../../images/image (419).png>)

Além disso, você tem algumas funcionalidades auxiliares do Frida:

- **Enumerate Loaded Classes**: Ele imprimirá todas as classes carregadas
- **Capture Strings**: Ele imprimirá todas as strings capturadas durante o uso da aplicação (muito ruidoso)
- **Capture String Comparisons**: Pode ser muito útil. Irá mostrar as 2 strings que estão sendo comparadas e se o resultado foi True ou False.
- **Enumerate Class Methods**: Coloque o nome da classe (como "java.io.File") e ele imprimirá todos os métodos da classe.
- **Search Class Pattern**: Pesquisar classes por padrão
- **Trace Class Methods**: Trace uma classe inteira (veja entradas e saídas de todos os métodos da classe). Lembre-se que por padrão o MobSF traça vários métodos interessantes da Android API.

Uma vez que você tenha selecionado o módulo auxiliar que deseja usar, você precisa pressionar "**Start Intrumentation**" e verá todas as saídas em "**Frida Live Logs**".

**Shell**

O MobSF também fornece um shell com alguns comandos **adb**, **MobSF commands**, e comandos comuns de **shell** na parte inferior da página de análise dinâmica. Alguns comandos interessantes:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Ferramentas HTTP**

Quando o tráfego HTTP é capturado você pode ver uma visão feia do tráfego capturado no botão "**HTTP(S) Traffic**" embaixo ou uma visão mais agradável no botão verde "**Start HTTPTools**". A partir da segunda opção, você pode **send** as **captured requests** para **proxies** como Burp ou Owasp ZAP.\
Para isso, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Ao terminar a análise dinâmica com MobSF você pode pressionar "**Start Web API Fuzzer**" para **fuzz http requests** e procurar por vulnerabilidades.

> [!TIP]
> Após realizar uma análise dinâmica com MobSF, as configurações de proxy podem ficar mal configuradas e você não conseguirá corrigi-las pela GUI. Você pode corrigir as configurações de proxy executando:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Análise Dinâmica Assistida com Inspeckage

Você pode obter a ferramenta em [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta ferramenta usa alguns **Hooks** para informar **o que está acontecendo no aplicativo** enquanto você realiza uma **análise dinâmica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta é uma **ótima ferramenta para realizar análise estática com uma GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Esta ferramenta foi projetada para procurar várias vulnerabilidades de segurança em aplicações Android, seja no código-fonte ou em APKs empacotados. A ferramenta também é capaz de criar um APK deployable de "Proof-of-Concept" e comandos ADB, para explorar algumas das vulnerabilidades encontradas (Exposed activities, intents, tapjacking...). Como no Drozer, não há necessidade de rootar o dispositivo de teste.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Exibe todos os arquivos extraídos para referência rápida
- Decompila automaticamente arquivos APK para os formatos Java e Smali
- Analisa AndroidManifest.xml em busca de vulnerabilidades comuns e comportamento
- Análise estática do código-fonte em busca de vulnerabilidades comuns e comportamento
- Informações do dispositivo
- e mais
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER é um aplicativo de linha de comando que pode ser usado em Windows, MacOS X e Linux, que analisa arquivos _.apk_ em busca de vulnerabilidades. Ele faz isso descompactando APKs e aplicando uma série de regras para detectar essas vulnerabilidades.

Todas as regras estão centralizadas em um arquivo `rules.json`, e cada empresa ou testador pode criar suas próprias regras para analisar o que precisar.

Baixe os binários mais recentes na [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn é uma ferramenta **crossplatform** que auxilia desenvolvedores, bugbounty hunters e ethical hackers na realização de [static code analysis] em aplicações móveis.

O conceito é que você arraste e solte o arquivo da sua aplicação móvel (um arquivo .apk ou .ipa) na aplicação StaCoAn e ela gerará um relatório visual e portátil para você. Você pode ajustar as configurações e wordlists para obter uma experiência personalizada.

Baixar[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework é um sistema de análise de vulnerabilidades para Android que ajuda desenvolvedores ou hackers a encontrar potenciais vulnerabilidades de segurança em aplicações Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** é uma ferramenta cujo objetivo principal é detectar e avisar o usuário sobre potenciais comportamentos maliciosos desenvolvidos por um aplicativo Android.

A detecção é realizada através da **static analysis** do bytecode Dalvik da aplicação, representado como **Smali**, com a biblioteca [`androguard`](https://github.com/androguard/androguard).

Esta ferramenta procura por **common behavior of "bad" applications** como: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** é um framework de engenharia reversa e análise de aplicações móveis. É uma ferramenta que reúne ferramentas comumente usadas para reverse engineering e análise de aplicações móveis, para auxiliar no teste de aplicações móveis contra as ameaças de segurança mobile do OWASP. Seu objetivo é tornar essa tarefa mais fácil e amigável para desenvolvedores de aplicações móveis e profissionais de segurança.

Ele é capaz de:

- Extrair código Java e Smali usando diferentes ferramentas
- Analisar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extrair informação privada do APK usando regexps.
- Analisar o Manifest.
- Analisar domínios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) e [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscar APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com/)

## Ofuscação/Deofuscação de código

Note que, dependendo do serviço e da configuração que você usa para ofuscar o código, segredos podem ou não terminar ofuscados.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** é uma ferramenta open source de linha de comando que reduz, otimiza e ofusca código Java. É capaz de otimizar bytecode assim como detectar e remover instruções não usadas. ProGuard é software livre e é distribuído sob a GNU General Public License, versão 2.

ProGuard é distribuído como parte do Android SDK e roda quando a aplicação é compilada em modo release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverte o processo de ofuscação realizado por ferramentas de ofuscação Android. Isso possibilita inúmeras análises de segurança, incluindo inspeção de código e identificação de bibliotecas.**

Você pode enviar um APK ofuscado para a plataforma deles.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

É um deobfuscador genérico para android. Simplify **executa virtualmente um app** para entender seu comportamento e então **tenta otimizar o código** para que ele se comporte de forma idêntica mas seja mais fácil para um humano entender. Cada tipo de otimização é simples e genérica, então não importa qual tipo específico de ofuscação foi usado.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD te dá informação sobre **como um APK foi criado**. Identifica muitos **compiladores**, **packers**, **obfuscators**, e outras coisas estranhas. É o [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b é uma máquina virtual de segurança Android baseada em ubuntu-mate que inclui uma coleção dos últimos frameworks, tutoriais e labs de diferentes pesquisadores e entusiastas para engenharia reversa e análise de malware.

## Referências

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) É uma ótima lista de recursos
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Curso rápido de Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
