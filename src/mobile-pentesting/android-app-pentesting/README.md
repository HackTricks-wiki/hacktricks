# Pentesting aplikacji Android

{{#include ../../banners/hacktricks-training.md}}

## Podstawy aplikacji Android

Zaleca się rozpoczęcie od przeczytania tej strony, aby poznać **najważniejsze elementy związane z bezpieczeństwem Androida oraz najniebezpieczniejsze komponenty w aplikacji Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

To główne narzędzie potrzebne do połączenia się z urządzeniem Android (emulowanym lub fizycznym).\
**ADB** pozwala kontrolować urządzenia zarówno przez **USB** lub **Network** z komputera. To narzędzie umożliwia **kopiowanie** plików w obu kierunkach, **instalację** i **odinstalowanie** aplikacji, **wykonywanie** poleceń shell, **tworzenie kopii zapasowych** danych, **odczytywanie** logów oraz inne funkcje.

Zerknij na następującą listę [**ADB Commands**](adb-commands.md), aby nauczyć się używać adb.

## Smali

Czasami warto **zmodyfikować kod aplikacji**, aby uzyskać dostęp do **ukrytych informacji** (np. silnie obfuskowane hasła lub flagi). W takim przypadku może być interesujące zdekompilować apk, zmodyfikować kod i ponownie skompilować go.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Może to być bardzo przydatne jako **alternatywa dla kilku testów podczas dynamicznej analizy**, które zostaną przedstawione. Zatem **zawsze miej tę możliwość na uwadze**.

## Inne ciekawe triki

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Wyodrębnij APK z urządzenia:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Scal wszystkie splits i base apks za pomocą [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Studia przypadków i podatności


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Analiza statyczna

Przede wszystkim, analizując APK powinieneś **przejrzeć kod Java** używając dekompilera.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Poszukiwanie interesujących informacji

Wystarczy spojrzeć na **strings** pliku APK, aby wyszukać **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** i wszystko co może być interesujące... szukaj nawet backdoorów do wykonania kodu lub backdoorów uwierzytelniania (hardcoded admin credentials do aplikacji).

**Firebase**

Zwróć szczególną uwagę na **firebase URLs** i sprawdź, czy nie są źle skonfigurowane. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

Badanie **pliku aplikacji _Manifest.xml_ i **_strings.xml_** może ujawnić potencjalne luki w zabezpieczeniach**. Te pliki można uzyskać przy pomocy dekompilerów lub zmieniając rozszerzenie APK na .zip i rozpakowując je.

**Zagrożenia** zidentyfikowane w **Manifest.xml** obejmują:

- **Debuggable Applications**: Aplikacje ustawione jako debuggable (`debuggable="true"`) w pliku _Manifest.xml_ stanowią ryzyko, ponieważ pozwalają na połączenia, które mogą prowadzić do eksploatacji. Aby lepiej zrozumieć jak eksploatować aplikacje z włączonym debugowaniem, odnieś się do tutorialu o znajdowaniu i wykorzystaniu debuggable applications na urządzeniu.
- **Backup Settings**: Atrybut `android:allowBackup="false"` powinien być jawnie ustawiony dla aplikacji przetwarzających wrażliwe informacje, aby zapobiec nieautoryzowanym backupom danych przez adb, szczególnie gdy usb debugging jest włączony.
- **Network Security**: Niestandardowe konfiguracje network security (`android:networkSecurityConfig="@xml/network_security_config"`) w _res/xml/_ mogą określać szczegóły takie jak certificate pins i ustawienia ruchu HTTP. Przykładem jest zezwolenie na HTTP dla konkretnych domen.
- **Exported Activities and Services**: Identyfikacja exported activities i services w manifeście może ujawnić komponenty, które mogą być niewłaściwie wykorzystane. Dalsza analiza podczas testów dynamicznych może pokazać, jak eksploatować te komponenty.
- **Content Providers and FileProviders**: Eksponowane content providers mogą umożliwić nieautoryzowany dostęp lub modyfikację danych. Konfiguracja FileProviders powinna być również dokładnie sprawdzona.
- **Broadcast Receivers and URL Schemes**: Te komponenty mogą być wykorzystane do eksploatacji, ze szczególną uwagę na to, jak zarządzane są URL schemes w kontekście podatności na wprowadzanie danych.
- **SDK Versions**: Atrybuty `minSdkVersion`, `targetSDKVersion`, oraz `maxSdkVersion` wskazują wspierane wersje Androida, podkreślając znaczenie niewspierania przestarzałych, podatnych wersji Androida ze względów bezpieczeństwa.

Z pliku **strings.xml** można odkryć wrażliwe informacje takie jak API keys, custom schemas oraz inne notatki deweloperskie, co podkreśla potrzebę dokładnego przeglądu tych zasobów.

### Tapjacking

**Tapjacking** to atak, w którym **malicious** **application** jest uruchamiana i **ustawia się nad aplikacją ofiary**. Gdy wizualnie zasłoni aplikację ofiary, jej interfejs użytkownika jest zaprojektowany w taki sposób, by oszukać użytkownika, skłaniając go do interakcji z nim, podczas gdy interakcja ta jest przekazywana do aplikacji ofiary.\
W efekcie użytkownik **nie widzi, że w rzeczywistości wykonuje akcje w aplikacji ofiary**.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Aktywność z ustawionym **`launchMode`** na **`singleTask` bez zdefiniowanego `taskAffinity`** jest podatna na Task Hijacking. Oznacza to, że **aplikacja** może zostać zainstalowana i jeśli zostanie uruchomiona przed prawdziwą aplikacją, może **przejąć task prawdziwej aplikacji** (tak że użytkownik będzie wchodził w interakcje z **malicious application**, myśląc, że używa prawdziwej).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

Internal Storage

W Androidzie pliki **przechowywane** w pamięci **internal** są **zaprojektowane** tak, aby były **dostępne** wyłącznie dla **aplikacji**, która je **utworzyła**. Ten mechanizm bezpieczeństwa jest **egzekwowany** przez system operacyjny Android i zwykle wystarcza dla potrzeb bezpieczeństwa większości aplikacji. Jednak deweloperzy czasami używają trybów takich jak `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE`, aby **pozwolić** na **udostępnianie** plików pomiędzy różnymi aplikacjami. Te tryby **nie ograniczają jednak dostępu** do tych plików przez inne aplikacje, w tym potencjalnie złośliwe.

1. **Static Analysis:**
- **Upewnij się**, że użycie `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` jest **dokładnie przeanalizowane**. Te tryby **mogą potencjalnie ujawnić** pliki **niezamierzonemu lub nieautoryzowanemu dostępowi**.
2. **Dynamic Analysis:**
- **Zweryfikuj** uprawnienia ustawione na plikach tworzonych przez aplikację. Konkretnie, **sprawdź**, czy jakiekolwiek pliki nie są ustawione jako czytelne lub zapisywalne dla wszystkich. To może stanowić istotne ryzyko bezpieczeństwa, ponieważ pozwoli **dowolnej aplikacji** zainstalowanej na urządzeniu, niezależnie od jej pochodzenia lub intencji, na **odczyt lub modyfikację** tych plików.

External Storage

Przy pracy z plikami na **external storage**, takimi jak karty SD, należy zachować ostrożność:

1. **Dostępność**:
- Pliki na external storage są **globalnie czytelne i zapisywalne**. Oznacza to, że każda aplikacja lub użytkownik może mieć do nich dostęp.
2. **Problemy bezpieczeństwa**:
- Ze względu na łatwość dostępu, nie zaleca się **przechowywania wrażliwych informacji** na external storage.
- External storage może zostać usunięty lub dostęp do niego może uzyskać dowolna aplikacja, co czyni go mniej bezpiecznym.
3. **Przetwarzanie danych z External Storage**:
- Zawsze **waliduj dane wejściowe** pobierane z external storage. To kluczowe, ponieważ dane pochodzą ze źródła niezatwierdzonego.
- Przechowywanie plików wykonywalnych lub plików klas na external storage w celu dynamicznego ładowania jest zdecydowanie odradzane.
- Jeśli aplikacja musi pobierać pliki wykonywalne z external storage, upewnij się, że pliki te są **podpisane i kryptograficznie weryfikowane** przed ich dynamicznym załadowaniem. Ten krok jest istotny dla zachowania integralności bezpieczeństwa aplikacji.

External storage can be **accessed** in /storage/emulated/0 , /sdcard , /mnt/sdcard

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

Wrażliwe dane przechowywane w postaci jawnej

- **Shared preferences**: Android pozwala każdej aplikacji łatwo zapisywać pliki xml w ścieżce /data/data/<packagename>/shared_prefs/ i czasami można znaleźć wrażliwe informacje w postaci jawnej w tym folderze.
- **Databases**: Android pozwala każdej aplikacji łatwo zapisywać bazy sqlite w ścieżce /data/data/<packagename>/databases/ i czasami można znaleźć wrażliwe informacje w postaci jawnej w tym folderze.

### Broken TLS

Accept All Certificates

Z jakiegoś powodu deweloperzy czasami akceptują wszystkie certyfikaty, nawet jeśli na przykład hostname nie pasuje, z liniami kodu takimi jak poniższa:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Dobrym sposobem przetestowania tego jest próba przechwycenia ruchu za pomocą proxy, takiego jak Burp, bez autoryzowania Burp CA w urządzeniu. Możesz też wygenerować w Burp certyfikat dla innej nazwy hosta i go użyć.

### Broken Cryptography

**Poor Key Management Processes**

Niektórzy deweloperzy zapisują dane wrażliwe w lokalnym storage i szyfrują je kluczem zakodowanym na stałe/przewidywalnym w kodzie. Nie powinno się tego robić, ponieważ odwrócenie (reversing) może pozwolić atakującym na wyodrębnienie poufnych informacji.

**Use of Insecure and/or Deprecated Algorithms**

Deweloperzy nie powinni używać **deprecated algorithms** do wykonywania **checks autoryzacyjnych**, **przechowywania** lub **wysyłania** danych. Niektóre z tych algorytmów to: RC4, MD4, MD5, SHA1... Jeśli **hashes** są używane do przechowywania haseł, należy stosować hashes odporne na brute-force z saltą.

### Other checks

- Zaleca się **obfuskować APK**, aby utrudnić pracę reverse engineerom.
- Jeśli aplikacja jest wrażliwa (np. bank apps), powinna wykonywać własne kontrole, aby sprawdzić, czy mobile jest rooted i odpowiednio reagować.
- Jeśli aplikacja jest wrażliwa (np. bank apps), powinna sprawdzać, czy używany jest **emulator**.
- Jeśli aplikacja jest wrażliwa (np. bank apps), powinna **sprawdzić swoją integralność przed uruchomieniem**, aby upewnić się, że nie została zmodyfikowana.
- Użyj [**APKiD**](https://github.com/rednaga/APKiD), aby sprawdzić, który compiler/packer/obfuscator został użyty do zbudowania APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) potrafi znaleźć podatności przez **skanowanie** **kodu** aplikacji. To narzędzie zawiera zestaw **known sources** (które wskazują narzędziu **miejsca**, gdzie **input** jest **kontrolowany przez użytkownika**), **sinks** (które wskazują **niebezpieczne** **miejsca**, gdzie złośliwy input użytkownika może wyrządzić szkody) oraz **rules**. Reguły te określają **kombinacje** **sources-sinks**, które wskazują na podatność.

Dzięki tej wiedzy **mariana-trench przejrzy kod i znajdzie możliwe podatności**.

### Secrets leaked

Aplikacja może zawierać secrets (API keys, passwords, hidden urls, subdomains...) wewnątrz, które możesz być w stanie odkryć. Możesz użyć narzędzia takiego jak [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

Możesz stworzyć **bezpłatne konto** na: [https://appetize.io/](https://appetize.io). Ta platforma pozwala **uploadować** i **uruchamiać** APK, więc jest przydatna, aby zobaczyć, jak apk się zachowuje.

Możesz nawet **widzieć logi swojej aplikacji** w sieci i łączyć się przez **adb**.

![](<../../images/image (831).png>)

Dzięki połączeniu ADB możesz używać **Drozer** i **Frida** wewnątrz emulatorów.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (Możesz tworzyć urządzenia **x86** i **arm**, a zgodnie z [**tym** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**najnowsze wersje x86** wspierają **biblioteki ARM** bez potrzeby używania wolnego emulatora ARM).
- Naucz się jak to skonfigurować na tej stronie:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Wersja darmowa:** Personal Edition, wymaga utworzenia konta. _Zaleca się **pobrać** wersję **Z**_ _**VirtualBox** aby uniknąć potencjalnych błędów._)
- [**Nox**](https://es.bignox.com) (Darmowy, ale nie wspiera Frida ani Drozer).

> [!TIP]
> Przy tworzeniu nowego emulatora na dowolnej platformie pamiętaj, że im większy ekran, tym wolniej emulator będzie działać. Dlatego wybieraj możliwie małe ekrany.

Aby **zainstalować google services** (jak AppStore) w Genymotion musisz kliknąć przycisk zaznaczony na czerwono na poniższym obrazie:

![](<../../images/image (277).png>)

Zwróć też uwagę, że w **konfiguracji VM Androida w Genymotion** możesz wybrać **Bridge Network mode** (to będzie przydatne, jeśli będziesz łączyć się z Android VM z innej VM z narzędziami).

#### Use a physical device

Musisz aktywować opcje **debugging** i fajnie by było, gdybyś mógł je **root**:

1. **Settings**.
2. (FromAndroid 8.0) Wybierz **System**.
3. Wybierz **About phone**.
4. Naciśnij **Build number** 7 razy.
5. Wróć i znajdziesz **Developer options**.

> Gdy już zainstalujesz aplikację, pierwszą rzeczą, którą powinieneś zrobić, jest ją uruchomić, zbadać co robi, jak działa i oswoić się z nią.\
> Sugeruję **wykonać to początkowe dynamiczne badanie używając MobSF dynamic analysis + pidcat**, dzięki czemu będziemy mogli **nauczyć się, jak aplikacja działa**, podczas gdy MobSF **przechwyci** dużo **interesujących** **danych**, które możesz później przejrzeć.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Deweloperzy powinni uważać, aby nie ujawniać publicznie informacji debugowych, ponieważ może to prowadzić do wycieku danych wrażliwych. Narzędzia [**pidcat**](https://github.com/JakeWharton/pidcat) oraz `adb logcat` są zalecane do monitorowania logów aplikacji w celu identyfikacji i ochrony informacji wrażliwych. **Pidcat** jest preferowany ze względu na łatwość użycia i czytelność.

> [!WARNING]
> Zauważ, że od **wersji nowszej niż Android 4.0**, **aplikacje mają dostęp jedynie do własnych logów**. Zatem aplikacje nie mogą uzyskiwać dostępu do logów innych aplikacji.\
> Mimo to nadal zaleca się **nie logować informacji wrażliwych**.

**Copy/Paste Buffer Caching**

Androidowy framework oparty na schowku umożliwia funkcję kopiuj-wklej w aplikacjach, jednak stwarza to ryzyko, gdyż **inne aplikacje** mogą **uzyskać dostęp** do schowka, potencjalnie ujawniając dane wrażliwe. Ważne jest, aby **wyłączyć funkcje kopiuj/wklej** w wrażliwych sekcjach aplikacji, takich jak dane karty kredytowej, aby zapobiec wyciekowi danych.

**Crash Logs**

Jeśli aplikacja **crashuje** i **zapisuje logi**, te logi mogą pomóc atakującym, szczególnie gdy aplikacji nie da się odwrócić. Aby zminimalizować to ryzyko, unikaj logowania przy awariach, a jeśli logi muszą być przesyłane przez sieć, zapewnij przesyłanie ich przez kanał SSL.

Jako pentester, **spróbuj rzucić okiem na te logi**.

**Analytics Data Sent To 3rd Parties**

Aplikacje często integrują usługi typu Google Adsense, które mogą przypadkowo **leak** danych wrażliwych z powodu nieprawidłowej implementacji przez deweloperów. Aby zidentyfikować potencjalne wycieki, warto **przechwycić ruch aplikacji** i sprawdzić, czy jakiekolwiek dane wrażliwe są wysyłane do usług stron trzecich.

### SQLite DBs

Większość aplikacji będzie używać **wewnętrznych baz SQLite** do zapisywania informacji. Podczas pentestu przejrzyj **bazy danych** utworzone przez aplikację, nazwy **tabel** i **kolumn** oraz wszystkie zapisane **dane**, ponieważ możesz znaleźć **dane wrażliwe** (co byłoby podatnością).\
Bazy danych powinny znajdować się w /data/data/the.package.name/databases, np. /data/data/com.mwr.example.sieve/databases

Jeśli baza danych zapisuje informacje poufne i jest **szyfrowana**, ale możesz **znaleźć** hasło wewnątrz aplikacji, to nadal jest to **podatność**.

Wylistuj tabele używając `.tables` i wylistuj kolumny tabel za pomocą `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** pozwala przyjąć rolę aplikacji Android i wchodzić w interakcje z innymi aplikacjami. Może robić **wszystko, co zainstalowana aplikacja może zrobić**, takie jak korzystanie z mechanizmu Inter-Process Communication (IPC) Androida i interakcję z systemem operacyjnym.\
Drozer jest użytecznym narzędziem do **eksploatacji exported activities, exported services i Content Providers**, jak dowiesz się w kolejnych sekcjach.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Pamiętaj także, że kod activity zaczyna się w metodzie **`onCreate`**.

**Authorisation bypass**

Gdy Activity jest exported, możesz wywołać jego ekran z zewnętrznej aplikacji. W związku z tym, jeśli activity z **informacjami wrażliwymi** jest **exported**, możesz **pominąć** mechanizmy **autoryzacji**, aby uzyskać do niej dostęp.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

Możesz także uruchomić exported activity z adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Zwróć uwagę, że authorisation bypass nie zawsze jest podatnością — zależy to od tego, jak działa bypass i które informacje są ujawniane.

**Ujawnianie wrażliwych informacji**

**Activities mogą również zwracać wyniki**. Jeśli uda Ci się znaleźć eksportowaną i niezabezpieczoną activity wywołującą metodę **`setResult`** i **zwracającą wrażliwe informacje**, dochodzi do ujawnienia wrażliwych informacji.

#### Tapjacking

Jeśli tapjacking nie jest zapobiegane, możesz nadużyć eksportowanej activity, aby spowodować, że **użytkownik wykona nieoczekiwane akcje**. Więcej informacji o [**czym jest Tapjacking — zobacz link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Content Provider.**](android-applications-basics.md#content-provider)\
Content providers są zasadniczo używane do **udostępniania danych**. Jeśli aplikacja ma dostępne content providers, możesz być w stanie **wyodrębnić wrażliwe** dane z nich. Warto też przetestować możliwe **SQL injections** i **Path Traversals**, ponieważ mogą być podatne.

[**Dowiedz się, jak exploit Content Providers przy użyciu Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Service.**](android-applications-basics.md#services)\
Pamiętaj, że działania Service rozpoczynają się w metodzie `onStartCommand`.

Service to w zasadzie coś, co **może otrzymywać dane**, **przetwarzać** je i **zwracać** (lub nie) odpowiedź. Zatem, jeśli aplikacja eksportuje jakieś services, powinieneś **sprawdzić** **kod**, aby zrozumieć, co robi, i **przetestować** go **dynamicznie** w celu wydobycia poufnych informacji, obejścia mechanizmów uwierzytelniania itp.\
[**Dowiedz się, jak exploit Services przy użyciu Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Przeczytaj to, jeśli chcesz odświeżyć, czym jest Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Pamiętaj, że działania Broadcast Receiver zaczynają się w metodzie `onReceive`.

Broadcast receiver będzie czekać na określony typ wiadomości. W zależności od tego, jak receiver obsługuje wiadomość, może być podatny.\
[**Dowiedz się, jak exploit Broadcast Receivers przy użyciu Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Możesz wyszukiwać deep links ręcznie, używając narzędzi takich jak MobSF lub skryptów jak [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Możesz **otworzyć** zadeklarowany **scheme** używając **adb** lub **przeglądarki**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Zwróć uwagę, że możesz **pominąć nazwę pakietu**, a urządzenie mobilne automatycznie wywoła aplikację, która powinna otworzyć ten link._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Kod wykonywany**

Aby znaleźć **kod, który zostanie wykonany w App**, przejdź do activity wywoływanej przez deeplink i wyszukaj funkcję **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Wrażliwe info**

Za każdym razem, gdy znajdziesz deep link, sprawdź, że i**nie otrzymuje sensitive data (np. passwords) przez parametry URL**, ponieważ każda inna aplikacja mogłaby **podszyć się pod deep link i ukraść te dane!**

**Parametry w ścieżce**

Musisz również **sprawdzić, czy któryś deep link używa parametru wewnątrz ścieżki** URL, np.: `https://api.example.com/v1/users/{username}`, w takim przypadku możesz wymusić path traversal uzyskując dostęp do czegoś takiego: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Zauważ, że jeśli znajdziesz poprawne endpoints wewnątrz aplikacji, możesz być w stanie spowodować **Open Redirect** (jeśli część ścieżki jest używana jako nazwa domeny), **account takeover** (jeśli możesz zmodyfikować dane użytkownika bez CSRF token i podatny endpoint używał poprawnej metody) i inne vuln. Więcej [informacji na ten temat tutaj](http://dphoeniixx.com/2020/12/13-2/).

**Więcej przykładów**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Inspekcja warstwy transportowej i błędy weryfikacji

- **Certyfikaty nie zawsze są poprawnie sprawdzane** przez aplikacje Android. Często aplikacje pomijają ostrzeżenia i akceptują self-signed certificates lub, w niektórych przypadkach, przechodzą na użycie HTTP.
- **Negocjacje podczas SSL/TLS handshake bywają czasem słabe**, stosując niebezpieczne cipher suites. Ta podatność naraża połączenie na ataki man-in-the-middle (MITM), pozwalając atakującym odszyfrować dane.
- **Leakage of private information** stanowi ryzyko, gdy aplikacje uwierzytelniają się przy użyciu bezpiecznych kanałów, a następnie komunikują się przez kanały niezabezpieczone dla innych transakcji. Takie podejście nie chroni sensitive data, takich jak session cookies czy dane użytkownika, przed przechwyceniem przez złośliwe podmioty.

#### Weryfikacja certyfikatu

Skupimy się na **certificate verification**. Integralność certyfikatu serwera musi być weryfikowana, aby zwiększyć bezpieczeństwo. To kluczowe, ponieważ niebezpieczne konfiguracje TLS i przesyłanie sensitive data przez niezaszyfrowane kanały mogą stanowić poważne ryzyko. Dla szczegółowych kroków dotyczących weryfikacji certyfikatów serwera i usuwania podatności, [**to źródło**](https://manifestsecurity.com/android-application-security-part-10/) zawiera wyczerpujące wskazówki.

#### SSL Pinning

SSL Pinning to środek bezpieczeństwa, gdzie aplikacja weryfikuje certyfikat serwera względem znanej kopii przechowywanej w samej aplikacji. Ta metoda jest istotna dla zapobiegania MITM. Implementacja SSL Pinning jest zdecydowanie zalecana dla aplikacji przetwarzających sensitive information.

#### Traffic Inspection

Aby inspect HTTP traffic, konieczne jest **zainstalowanie certyfikatu narzędzia proxy** (np. Burp). Bez zainstalowania tego certyfikatu zaszyfrowany ruch może nie być widoczny przez proxy. Instrukcję instalacji custom CA certificate znajdziesz na [**tej stronie**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Aplikacje targetujące **API Level 24 and above** wymagają modyfikacji Network Security Config, aby zaakceptować proxy's CA certificate. Ten krok jest krytyczny do inspect zaszyfrowanego ruchu. Instrukcje dotyczące modyfikacji Network Security Config znajdują się w [**tym tutorialu**](make-apk-accept-ca-certificate.md).

Jeśli używany jest **Flutter**, musisz postępować zgodnie z instrukcjami na [**tej stronie**](flutter.md). To dlatego, że samo dodanie certyfikatu do store nie zadziała — Flutter ma swoją własną listę valid CAs.

#### Statyczne wykrywanie SSL/TLS pinning

Zanim spróbujesz runtime bypasses, szybko zmapuj, gdzie pinning jest egzekwowany w APK. Statyczne wykrywanie pomaga zaplanować hooki/patchy i skupić się na właściwych ścieżkach kodu.

Tool: SSLPinDetect
- Open-source static-analysis utility that decompiles the APK to Smali (via apktool) and scans for curated regex patterns of SSL/TLS pinning implementations.
- Reports exact file path, line number, and a code snippet for each match.
- Covers common frameworks and custom code paths: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Użycie
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Przykładowe reguły wzorców (JSON)
Użyj lub rozszerz signatures, aby wykryć proprietary/custom pinning styles. Możesz załadować własny JSON i scan at scale.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notatki i wskazówki
- Szybkie skanowanie dużych aplikacji przy użyciu wielowątkowości i memory-mapped I/O; pre-compiled regex zmniejsza narzut i false positives.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Typowe cele wykrywania do dalszej analizy:
- OkHttp: użycie CertificatePinner, setCertificatePinner, odwołania do pakietów okhttp3/okhttp
- Niestandardowe TrustManagery: javax.net.ssl.X509TrustManager, nadpisania checkServerTrusted
- Niestandardowe SSL contexty: SSLContext.getInstance + SSLContext.init z niestandardowymi managerami
- Deklaratywne piny w res/xml network security config oraz odwołania w manifest
- Wykorzystaj dopasowane lokalizacje do zaplanowania Frida hooks, static patches lub przeglądu konfiguracji przed testami dynamicznymi.



#### Bypassing SSL Pinning

When SSL Pinning is implemented, bypassing it becomes necessary to inspect HTTPS traffic. Various methods are available for this purpose:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- You can also try to **automatically bypass SSL Pinning** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- You can also try to **automatically bypass SSL Pinning** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

Ważne jest również wyszukiwanie typowych podatności webowych w aplikacji. Szczegółowe informacje o identyfikacji i łagodzeniu tych podatności wykraczają poza zakres tego streszczenia, ale są szeroko opisane w innych źródłach.

### Frida

[Frida](https://www.frida.re) jest zbiorem narzędzi do dynamicznej instrumentacji dla developerów, reverse-engineerów i badaczy bezpieczeństwa.\
**Możesz uzyskać dostęp do działającej aplikacji i hookować metody w czasie działania, aby zmienić zachowanie, zmienić wartości, wydobyć wartości, uruchomić inny kod...**\
Jeśli chcesz pentestować aplikacje Android musisz umieć używać Frida.

- Learn how to use Frida: [**Frida tutorial**](frida-tutorial/index.html)
- Some "GUI" for actions with Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Objection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Try to bypass anti-debugging / anti-frida mechanisms loading Frida as in indicated in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Zrzut pamięci - Fridump**

Sprawdź, czy aplikacja nie przechowuje w pamięci informacji wrażliwych, których nie powinna, takich jak hasła czy mnemoniki.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
To zrzuci pamięć do katalogu ./dump, a w nim możesz użyć grep w taki sposób:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Wrażliwe dane w Keystore**

W Androidzie Keystore jest najlepszym miejscem do przechowywania wrażliwych danych, jednak przy odpowiednich uprawnieniach wciąż **można mieć do niego dostęp**. Ponieważ aplikacje mają tendencję do przechowywania tutaj **wrażliwych danych w postaci jawnej**, pentests powinny to sprawdzać jako root, ponieważ osoba z fizycznym dostępem do urządzenia mogłaby ukraść te dane.

Nawet jeśli aplikacja przechowywała dane w keystore, dane powinny być zaszyfrowane.

Aby uzyskać dostęp do danych w keystore, możesz użyć tego skryptu Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Używając poniższego skryptu Frida, możliwe jest **bypass uwierzytelniania odciskiem palca**, które aplikacje Android mogą stosować, aby **chronić pewne wrażliwe obszary:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Obrazy w tle**

Kiedy umieścisz aplikację w tle, Android zapisuje **migawkę aplikacji**, dzięki czemu po przywróceniu jej na pierwszy plan zaczyna ładować obraz wcześniej niż samą aplikację, co sprawia, że wygląda na szybsze załadowanie.

Jednak jeśli ta **migawka zawiera wrażliwe informacje**, ktoś mający dostęp do migawki może **ukraść te informacje** (uwaga: do uzyskania dostępu potrzebny jest root).

Migawki są zwykle przechowywane w: **`/data/system_ce/0/snapshots`**

Android udostępnia sposób, aby **zapobiec przechwytywaniu zrzutów ekranu przez ustawienie parametru layout FLAG_SECURE**. Korzystając z tej flagi, zawartość okna jest traktowana jako bezpieczna, uniemożliwiając jej pojawienie się na zrzutach ekranu lub wyświetlanie na niezabezpieczonych wyświetlaczach.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

This tool could help you managing different tools during the dynamic analysis: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developers often create proxy components like activities, services, and broadcast receivers that handle these Intents and pass them to methods such as `startActivity(...)` or `sendBroadcast(...)`, which can be risky.

Niebezpieczeństwo polega na tym, że atakujący mogą zmusić aplikację do wywołania non-exported app components lub uzyskania dostępu do wrażliwych content providers poprzez przekierowanie tych Intents. Przykładem jest komponent `WebView`, który konwertuje URL-e na `Intent` objects za pomocą `Intent.parseUri(...)` i następnie je wykonuje, co może prowadzić do malicious Intent injections.

### Kluczowe wnioski

- **Intent Injection** is similar to web's Open Redirect issue.
- Exploits involve passing `Intent` objects as extras, which can be redirected to execute unsafe operations.
- It can expose non-exported components and content providers to attackers.
- `WebView`’s URL to `Intent` conversion can facilitate unintended actions.

### Android Client Side Injections and others

Pewnie znasz tego typu podatności z webu. Musisz być szczególnie ostrożny z tymi podatnościami w aplikacji Android:

- **SQL Injection:** When dealing with dynamic queries or Content-Providers ensure you are using parameterized queries.
- **JavaScript Injection (XSS):** Verify that JavaScript and Plugin support is disabled for any WebViews (disabled by default). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews should have access to the file system disabled (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: W wielu przypadkach, gdy aplikacja Android kończy sesję, cookie nie zostaje unieważnione lub może zostać zapisane na dysku.
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** using a nice web-based frontend. You can also perform dynamic analysis (but you need to prepare the environment).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Zauważ, że MobSF może analizować **Android**(apk)**, IOS**(ipa) oraz **Windows**(apx) applications (_Aplikacje Windows muszą być analizowane z MobSF zainstalowanym na hoście Windows_).\
Również, jeśli stworzysz plik **ZIP** ze źródłami aplikacji **Android** lub **IOS** (przejdź do katalogu głównego aplikacji, zaznacz wszystko i utwórz ZIPfile), będzie on również możliwy do analizy.

MobSF pozwala także na **diff/Compare** analiz oraz integrację z **VirusTotal** (musisz ustawić swój klucz API w _MobSF/settings.py_ i go włączyć: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). Możesz też ustawić `VT_UPLOAD` na `False`, wtedy zamiast pliku zostanie **upload**owany **hash**.

### Wspomagana analiza dynamiczna z MobSF

**MobSF** może być także bardzo pomocny przy **dynamic analysis** w **Android**, ale w tym przypadku musisz zainstalować MobSF i **genymotion** na swoim hoście (VM lub Docker nie zadziałają). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
**MobSF dynamic analyser** potrafi:

- **Dump application data** (URL-e, logi, clipboard, screenshoty wykonane przez ciebie, screenshoty wykonane przez "**Exported Activity Tester**", e-maile, bazy SQLite, pliki XML i inne utworzone pliki). Wszystko to jest wykonywane automatycznie z wyjątkiem screenshotów — musisz wcisnąć w momencie, kiedy chcesz zrzut ekranu albo nacisnąć "**Exported Activity Tester**", aby uzyskać screenshoty wszystkich eksportowanych aktywności.
- Przechwytywać **HTTPS traffic**
- Używać **Frida** do uzyskania **runtime** **information**

Od wersji android **> 5** automatycznie uruchomi **Frida** i ustawi globalne ustawienia **proxy**, aby **capture**ować ruch. Będzie przechwytywać ruch tylko z testowanej aplikacji.

**Frida**

Domyślnie użyje także kilku Frida Scripts, aby **bypass SSL pinning**, **root detection** i **debugger detection** oraz aby **monitor interesting APIs**.\
MobSF może również **invoke exported activities**, robić **screenshots** tych aktywności i **save** je do raportu.

Aby **start**ować dynamiczne testy naciśnij zielony przycisk: "**Start Instrumentation**". Naciśnij "**Frida Live Logs**", aby zobaczyć logi generowane przez skrypty Frida oraz "**Live API Monitor**", aby zobaczyć wszystkie wywołania zahaczonych metod, przekazane argumenty i wartości zwracane (pojawi się to po naciśnięciu "Start Instrumentation").\
MobSF pozwala też załadować własne **Frida scripts** (aby wysłać wyniki swoich Friday scripts do MobSF użyj funkcji `send()`). Ma też **kilka wstępnie napisanych skryptów**, które możesz załadować (możesz dodać więcej w `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), po prostu **wybierz je**, naciśnij "**Load**" i naciśnij "**Start Instrumentation**" (logi tych skryptów zobaczysz w "**Frida Live Logs**").

![](<../../images/image (419).png>)

Ponadto, masz kilka pomocniczych funkcji Frida:

- **Enumerate Loaded Classes**: Wypisze wszystkie załadowane klasy
- **Capture Strings**: Wypisuje wszystkie złapane stringi podczas używania aplikacji (bardzo głośne)
- **Capture String Comparisons**: Może być bardzo użyteczne. Pokaże **dwa porównywane stringi** i czy wynik był True czy False.
- **Enumerate Class Methods**: Wpisz nazwę klasy (np. "java.io.File") i wypisze wszystkie metody tej klasy.
- **Search Class Pattern**: Wyszukuje klasy po wzorcu
- **Trace Class Methods**: **Trace** całej **klasy** (zobacz inputs i outputs wszystkich metod klasy). Pamiętaj, że domyślnie MobSF śledzi kilka interesujących metod Android API.

Gdy wybierzesz moduł pomocniczy, którego chcesz użyć, musisz wcisnąć "**Start Intrumentation**" i zobaczysz wszystkie wyjścia w "**Frida Live Logs**".

**Shell**

MobSF daje również shell z kilkoma poleceniami **adb**, poleceniami **MobSF** oraz typowymi poleceniami **shell** na dole strony dynamic analysis. Niektóre interesujące polecenia:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP tools**

Kiedy ruch http jest przechwycony, możesz zobaczyć nieestetyczny widok przechwyconego ruchu na przycisku "**HTTP(S) Traffic**" u dołu albo ładniejszy widok na zielonym przycisku "**Start HTTPTools**". Z drugiej opcji możesz **wysłać** **przechwycone requests** do **proxies** takich jak Burp lub Owasp ZAP.\
Aby to zrobić, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> naciśnij "**Send to Fuzzer**" --> _wybierz adres proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Once you finish the dynamic analysis with MobSF you can press on "**Start Web API Fuzzer**" to **fuzz http requests** i szukać podatności.

> [!TIP]
> Po wykonaniu dynamic analysis z MobSF ustawienia proxy mogą być nieprawidłowo skonfigurowane i nie będziesz w stanie naprawić ich z GUI. Możesz naprawić ustawienia proxy, wykonując:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Wspomagana Dynamic Analysis z Inspeckage

Możesz pobrać narzędzie z [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
To narzędzie używa kilku **Hooks**, aby poinformować Cię **co się dzieje w aplikacji** podczas wykonywania **dynamic analysis**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

To **świetne narzędzie do przeprowadzania static analysis z GUI**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

To narzędzie zostało zaprojektowane do wyszukiwania różnych **security related Android application vulnerabilities**, zarówno w **source code**, jak i w **packaged APKs**. Narzędzie jest również **capable of creating a "Proof-of-Concept" deployable APK** oraz **ADB commands**, aby wykorzystać niektóre z znalezionych podatności (Exposed activities, intents, tapjacking...). Podobnie jak w przypadku Drozer, nie ma potrzeby rootowania urządzenia testowego.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wyświetla wszystkie wyodrębnione pliki do szybkiego przeglądu
- Automatycznie dekompiluje pliki APK do formatu Java i Smali
- Analizuje AndroidManifest.xml pod kątem common vulnerabilities i zachowań
- Statyczna analiza kodu źródłowego pod kątem common vulnerabilities i zachowań
- Informacje o urządzeniu
- i więcej
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER to aplikacja wiersza poleceń, która może być używana w Windows, MacOS X i Linux, i analizuje pliki _.apk_ w poszukiwaniu podatności. Robi to przez dekompresję APK i zastosowanie serii reguł do wykrywania tych podatności.

Wszystkie reguły znajdują się w pliku `rules.json`, a każda firma lub tester może stworzyć własne reguły, aby analizować to, czego potrzebują.

Pobierz najnowsze binaria ze [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn to **crossplatform** narzędzie, które pomaga programistom, bugbounty hunters i ethical hackers w przeprowadzaniu [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) aplikacji mobilnych.

Koncepcja polega na przeciągnięciu i upuszczeniu pliku aplikacji mobilnej (pliku .apk lub .ipa) na aplikację StaCoAn, która wygeneruje dla Ciebie wizualny i przenośny raport. Możesz dostosować ustawienia i wordlists, aby uzyskać spersonalizowane doświadczenie.

Pobierz[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework to system analizy podatności dla Androida, który pomaga deweloperom lub hackers znaleźć potencjalne luki bezpieczeństwa w aplikacjach Androida.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** to narzędzie, którego głównym celem jest wykrywanie i ostrzeganie użytkownika o potencjalnie złośliwych zachowaniach rozwijanych przez aplikację Android.

Wykrywanie odbywa się poprzez **analizę statyczną** Dalvik bytecode aplikacji, reprezentowanego jako **Smali**, przy użyciu biblioteki [`androguard`](https://github.com/androguard/androguard).

To narzędzie wyszukuje **common behavior of "bad" applications** takie jak: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** to framework do reverse engineering i analizy aplikacji mobilnych. To narzędzie łączy w sobie powszechnie używane narzędzia do reverse engineering i analizy aplikacji mobilnych, aby wspomóc testowanie aplikacji mobilnych pod kątem zagrożeń bezpieczeństwa mobilnego zdefiniowanych przez OWASP. Jego celem jest ułatwienie tego zadania i uczynienie go bardziej przyjaznym dla deweloperów aplikacji mobilnych oraz specjalistów ds. bezpieczeństwa.

Potrafi:

- Wyodrębniać kod Java i Smali przy użyciu różnych narzędzi
- Analizować APK za pomocą: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Wyodrębniać prywatne informacje z APK przy użyciu regexpów.
- Analizować Manifest.
- Analizować znalezione domeny przy użyciu: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskować APK za pomocą [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Przydatne do wykrywania malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Zwróć uwagę, że w zależności od usługi i konfiguracji użytej do obfuskacji kodu, sekrety mogą, ale nie muszą zostać obfuskowane.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Z [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** jest narzędziem wiersza poleceń open source, które zmniejsza, optymalizuje i obfuskcuje kod Java. Potrafi optymalizować bytecode oraz wykrywać i usuwać nieużywane instrukcje. ProGuard jest oprogramowaniem wolnym i jest rozpowszechniany na licencji GNU General Public License, wersja 2.

ProGuard jest dołączany jako część Android SDK i uruchamiany przy budowaniu aplikacji w trybie release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Znajdziesz przewodnik krok po kroku dotyczący deobfuskacji APK na [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Z tego przewodnika) Ostatnim razem, gdy sprawdzaliśmy, tryb działania Dexguard był:

- załadować zasób jako InputStream;
- przekazać wynik do klasy dziedziczącej po FilterInputStream, aby go odszyfrować;
- wykonać bezużyteczną obfuskację, aby zmarnować kilka minut czasu reversera;
- przekazać odszyfrowany wynik do ZipInputStream, aby uzyskać plik DEX;
- na końcu załadować uzyskany DEX jako Resource używając metody `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard odwraca proces obfuskacji wykonywany przez narzędzia do obfuskacji Androida. Umożliwia to wiele analiz bezpieczeństwa, w tym inspekcję kodu i identyfikację bibliotek.**

Możesz przesłać obfuskowane APK na ich platformę.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

To narzędzie LLM do znajdowania potencjalnych podatności w aplikacjach android oraz deobfuskacji kodu aplikacji. Wykorzystuje publiczne API Gemini od Google.

### [Simplify](https://github.com/CalebFenton/simplify)

To ogólny deobfuskator dla androida. Simplify wirtualnie wykonuje aplikację, aby zrozumieć jej zachowanie, a następnie próbuje zoptymalizować kod tak, aby zachowywał się identycznie, ale był łatwiejszy do zrozumienia dla człowieka. Każdy typ optymalizacji jest prosty i uniwersalny, więc nie ma znaczenia, jaki konkretny rodzaj obfuskacji został użyty.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD dostarcza informacji o tym, jak APK został stworzony. Identyfikuje wiele kompilatorów, packerów, obfuskatorów i innych nietypowych rzeczy. To [_PEiD_](https://www.aldeid.com/wiki/PEiD) dla Androida.

### Manual

[Przeczytaj ten samouczek, aby poznać triki dotyczące **jak odwrócić niestandardową obfuskację**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b to wirtualna maszyna do bezpieczeństwa Androida oparta na ubuntu-mate, zawierająca zbiór najnowszych frameworków, samouczków i laboratoriów od różnych pasjonatów bezpieczeństwa i badaczy do reverse engineering i analizy malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To świetna lista zasobów
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Szybki kurs Androida
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
