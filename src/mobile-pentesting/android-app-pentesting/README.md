# Pentesting d'applications Android

{{#include ../../banners/hacktricks-training.md}}

## Bases des applications Android

Il est fortement recommandé de commencer par lire cette page pour connaître les **parties les plus importantes liées à la sécurité Android et les composants les plus dangereux d'une application Android**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

C'est l'outil principal nécessaire pour se connecter à un appareil Android (émulé ou physique).\
**ADB** permet de contrôler les appareils soit via **USB** soit via **Network** depuis un ordinateur. Cet utilitaire permet la **copie** de fichiers dans les deux sens, l'**installation** et la **désinstallation** d'apps, l'**exécution** de commandes shell, la **sauvegarde** des données, la **lecture** des logs, entre autres fonctions.

Consultez la liste suivante de [**ADB Commands**](adb-commands.md) pour apprendre à utiliser adb.

## Smali

Parfois, il est intéressant de **modifier le code de l'application** pour accéder à des **informations cachées** (peut-être des mots de passe fortement obfusqués ou des flags). Il peut alors être intéressant de décompiler l'apk, de modifier le code et de le recompiler.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Cela peut être très utile comme **alternative pour plusieurs tests lors de l'analyse dynamique** qui vont être présentés. Donc, **gardez toujours cette possibilité en tête**.

## Autres astuces intéressantes

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [Android IME / InputMethodService Abuse (Malicious Keyboards)](inputmethodservice-ime-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Télécharger des APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extraire l'APK de l'appareil:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Fusionnez tous les splits et les apks de base avec [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Attaques Android Enterprise & Work Profile

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Études de cas & Vulnérabilités


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

{{#ref}}
abusing-android-media-pipelines-image-parsers.md
{{#endref}}

{{#ref}}
../../binary-exploitation/linux-kernel-exploitation/arm64-static-linear-map-kaslr-bypass.md
{{#endref}}

## Analyse statique

Tout d'abord, pour analyser un APK vous devriez **regarder le code Java** en utilisant un décompilateur.\
Veuillez [**lire ici pour trouver des informations sur les différents décompilateurs disponibles**](apk-decompilers.md).

### Recherche d'informations intéressantes

Rien qu'en regardant les **strings** de l'APK vous pouvez rechercher des **mots de passe**, des **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), des **api keys**, du **encryption**, des **bluetooth uuids**, des **tokens** et tout ce qui est intéressant... cherchez même des **backdoors** d'exécution de code ou des backdoors d'authentification (identifiants admin hardcodés dans l'app).

**Firebase**

Portez une attention particulière aux **Firebase URLs** et vérifiez si elles sont mal configurées. [Plus d'informations sur ce qu'est Firebase et comment l'exploiter ici.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Compréhension basique de l'application - Manifest.xml, strings.xml

L'**examen des fichiers _Manifest.xml_ et **_strings.xml_** d'une application peut révéler des vulnérabilités potentielles de sécurité**. Ces fichiers peuvent être consultés à l'aide de décompilateurs ou en renommant l'extension du fichier APK en .zip puis en le décompressant.

Les **vulnérabilités** identifiables depuis le **Manifest.xml** incluent :

- **Applications débogables** : Les applications définies comme debuggable (`debuggable="true"`) dans le _Manifest.xml_ présentent un risque car elles permettent des connexions pouvant mener à une exploitation. Pour comprendre comment exploiter des applications débogables, référez-vous à un tutoriel sur la découverte et l'exploitation d'applications debuggables sur un appareil.
- **Paramètres de sauvegarde** : L'attribut `android:allowBackup="false"` doit être explicitement défini pour les applications manipulant des informations sensibles afin d'empêcher des sauvegardes non autorisées via adb, surtout lorsque le débogage USB est activé.
- **Sécurité réseau** : Les configurations réseau personnalisées (`android:networkSecurityConfig="@xml/network_security_config"`) dans _res/xml/_ peuvent spécifier des détails de sécurité comme des pins de certificats et les paramètres de trafic HTTP. Un exemple est d'autoriser le trafic HTTP pour des domaines spécifiques.
- **Activités et Services exportés** : Identifier les activités et services exportés dans le manifest peut mettre en évidence des composants susceptibles d'être détournés. Une analyse plus approfondie lors des tests dynamiques peut révéler comment exploiter ces composants.
- **Content Providers et FileProviders** : Des content providers exposés pourraient permettre un accès non autorisé ou la modification de données. La configuration des FileProviders doit aussi être scrutée.
- **Broadcast Receivers et schémas d'URL** : Ces composants peuvent être exploités, avec une attention particulière sur la manière dont les schémas d'URL gèrent les entrées susceptibles d'être vulnérables.
- **Versions du SDK** : Les attributs `minSdkVersion`, `targetSDKVersion` et `maxSdkVersion` indiquent les versions Android supportées, soulignant l'importance de ne pas supporter des versions Android obsolètes et vulnérables.

À partir du fichier **strings.xml**, des informations sensibles comme des clés API, des schémas personnalisés et d'autres notes de développeur peuvent être découvertes, ce qui souligne la nécessité d'un examen attentif de ces ressources.

### Tapjacking

**Tapjacking** est une attaque où une **application malveillante** est lancée et **se positionne au-dessus d'une application victime**. Une fois qu'elle couvre visiblement l'application victime, son interface utilisateur est conçue de telle façon qu'elle trompe l'utilisateur pour qu'il interagisse avec elle, alors qu'elle transmet l'interaction à l'application victime.\
En pratique, cela consiste à **rendre l'utilisateur aveugle au fait qu'il effectue en réalité des actions sur l'application victime**.

Trouvez plus d'informations dans :


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

Une **activity** avec le **`launchMode`** défini sur **`singleTask` sans aucun `taskAffinity`** est vulnérable au task Hijacking. Cela signifie qu'une **application** peut être installée et si elle est lancée avant la véritable application, elle pourrait **détourner la tâche de la vraie application** (ainsi l'utilisateur interagira avec **l'application malveillante en pensant utiliser la vraie**).

Plus d'infos dans :


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Stockage de données non sécurisé

**Stockage interne**

Sur Android, les fichiers **stockés** en **stockage interne** sont **conçus** pour être **accessibles** exclusivement par l'**app** qui les a **créés**. Cette mesure de sécurité est **imposée** par le système d'exploitation Android et est généralement suffisante pour les besoins de sécurité de la plupart des applications. Cependant, les développeurs utilisent parfois des modes tels que `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE` pour **permettre** aux fichiers d'être **partagés** entre différentes applications. Ces modes **ne restreignent pas l'accès** à ces fichiers par d'autres applications, y compris potentiellement des applications malveillantes.

1. **Analyse statique :**
- **Vérifier** attentivement l'utilisation de `MODE_WORLD_READABLE` et `MODE_WORLD_WRITABLE`. Ces modes **peuvent potentiellement exposer** des fichiers à des **accès non intentionnés ou non autorisés**.
2. **Analyse dynamique :**
- **Vérifier** les **permissions** définies sur les fichiers créés par l'app. Plus précisément, **contrôlez** si des fichiers sont **définis comme lisibles ou modifiables mondialement**. Cela peut représenter un risque de sécurité important, car cela permettrait à **n'importe quelle application** installée sur l'appareil, quelle qu'en soit la provenance ou l'intention, de **lire ou modifier** ces fichiers.

**Stockage externe**

Lorsqu'on traite des fichiers sur le **stockage externe**, comme les cartes SD, certaines précautions doivent être prises :

1. **Accessibilité** :
- Les fichiers sur le stockage externe sont **globalement lisibles et modifiables**. Cela signifie que n'importe quelle application ou utilisateur peut y accéder.
2. **Problèmes de sécurité** :
- Étant donné la facilité d'accès, il est conseillé de **ne pas stocker d'informations sensibles** sur le stockage externe.
- Le stockage externe peut être retiré ou accédé par n'importe quelle application, ce qui le rend moins sûr.
3. **Traitement des données venant du stockage externe** :
- Toujours **effectuer une validation d'entrée** sur les données récupérées depuis le stockage externe. C'est crucial car les données proviennent d'une source non fiable.
- Déconseillé de stocker des exécutables ou des fichiers de classe sur le stockage externe pour un chargement dynamique.
- Si votre application doit récupérer des fichiers exécutables depuis le stockage externe, assurez-vous que ces fichiers sont **signés et vérifiés cryptographiquement** avant d'être chargés dynamiquement. Cette étape est essentielle pour maintenir l'intégrité de sécurité de votre application.

Le stockage externe peut être **accédé** dans `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`

> [!TIP]
> Depuis Android 4.4 (**API 17**), la carte SD possède une structure de répertoires qui **limite l'accès d'une app au répertoire qui lui est spécifiquement destiné**. Cela empêche une application malveillante d'obtenir un accès en lecture ou écriture aux fichiers d'une autre app.

**Données sensibles stockées en clair**

- **Shared preferences** : Android permet à chaque application de facilement sauvegarder des fichiers xml dans le chemin `/data/data/<packagename>/shared_prefs/` et parfois il est possible de trouver des informations sensibles en clair dans ce dossier.
- **Databases** : Android permet à chaque application de facilement sauvegarder des bases sqlite dans le chemin `/data/data/<packagename>/databases/` et parfois il est possible de trouver des informations sensibles en clair dans ce dossier.

### TLS défaillant

**Accept All Certificates**

Pour une raison quelconque, il arrive que des développeurs acceptent tous les certificats même si, par exemple, le hostname ne correspond pas, avec des lignes de code comme l'exemple suivant :
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Une bonne façon de tester cela est d'essayer de capturer le trafic en utilisant un proxy comme Burp sans autoriser le Burp CA sur l'appareil. Vous pouvez aussi générer avec Burp un certificat pour un nom d'hôte différent et l'utiliser.

### Cryptographie défaillante

**Mauvaises procédures de gestion des clés**

Certains développeurs sauvegardent des données sensibles dans le stockage local et les chiffrent avec une clé codée en dur/prévisible dans le code. Cela ne devrait pas être fait car du reversing pourrait permettre aux attaquants d'extraire les informations confidentielles.

**Utilisation d'algorithmes non sécurisés et/ou obsolètes**

Les développeurs ne devraient pas utiliser des **algorithmes obsolètes** pour effectuer des **vérifications** d'authorisation, **stocker** ou **envoyer** des données. Certains de ces algorithmes sont : RC4, MD4, MD5, SHA1... Si des **hashes** sont utilisés pour stocker des mots de passe par exemple, des hashes résistants au brute-force devraient être utilisés avec un salt.

### Autres vérifications

- Il est recommandé d'**obfusquer l'APK** pour compliquer le travail de reverse engineering des attaquants.
- Si l'app est sensible (comme les apps bancaires), elle devrait effectuer ses propres vérifications pour déterminer si le mobile est **rooted** et agir en conséquence.
- Si l'app est sensible (comme les apps bancaires), elle devrait vérifier si un **emulator** est utilisé.
- Si l'app est sensible (comme les apps bancaires), elle devrait **vérifier son intégrité avant de s'exécuter** pour vérifier si elle a été modifiée.
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### Application React Native

Lisez la page suivante pour apprendre comment accéder facilement au code javascript des applications React :


{{#ref}}
react-native-application.md
{{#endref}}

### Applications Xamarin

Lisez la page suivante pour apprendre comment accéder facilement au code C# d'une application xamarin :


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Applications Superpacked

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Analyse statique automatisée du code

L'outil [**mariana-trench**](https://github.com/facebook/mariana-trench) est capable of finding **vulnerabilities** by **scanning** the **code** of the application. Cet outil contient une série de **known sources** (qui indique à l'outil les **endroits** où l'**input** est **contrôlé par l'utilisateur**), **sinks** (qui indique à l'outil les **endroits dangereux** où un input malveillant pourrait causer des dommages) et des **rules**. Ces règles indiquent la **combinaison** de **sources-sinks** qui signale une vulnérabilité.

Avec cette connaissance, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Autres fonctions intéressantes

- **Exécution de code**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Envoyer des SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Fonctions natives** déclarées comme `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Analyse dynamique

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Analyse dynamique en ligne

Vous pouvez créer un **compte gratuit** sur : [https://appetize.io/](https://appetize.io/). Cette plateforme permet d'**uploader** et d'**exécuter** des APKs, donc elle est utile pour voir comment un apk se comporte.

Vous pouvez même **voir les logs de votre application** sur le web et vous connecter via **adb**.

![](<../../images/image (831).png>)

Grâce à la connexion ADB vous pouvez utiliser **Drozer** et **Frida** dans les émulateurs.

### Analyse dynamique locale

#### Utiliser un émulateur

- [**Android Studio**](https://developer.android.com/studio) (Vous pouvez créer des appareils **x86** et **arm**, et selon [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Apprenez à le configurer sur cette page :


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, vous devez créer un compte. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Gratuit, mais il ne supporte pas Frida ou Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Utiliser un appareil physique

Vous devez activer les options de **debugging** et il est conseillé si possible de pouvoir **rooter** l'appareil :

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Une fois que vous avez installé l'application, la première chose à faire est de l'utiliser et d'étudier ce qu'elle fait, comment elle fonctionne et de vous familiariser avec elle.\
> Je suggère d'**effectuer cette analyse dynamique initiale en utilisant MobSF dynamic analysis + pidcat**, ainsi nous pourrons **apprendre le fonctionnement de l'application** pendant que MobSF **capture** beaucoup de **données intéressantes** que vous pourrez consulter ensuite.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host

### Unintended Data Leakage

**Logging**

Les développeurs doivent faire attention à ne pas exposer des **informations de debug** publiquement, car cela peut conduire à des leaks de données sensibles. Les outils [**pidcat**](https://github.com/JakeWharton/pidcat) et `adb logcat` sont recommandés pour surveiller les logs des applications afin d'identifier et protéger les informations sensibles. **Pidcat** est préféré pour sa facilité d'utilisation et sa lisibilité.

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Le framework **clipboard-based** d'Android permet la fonctionnalité copier-coller dans les apps, mais présente un risque car **d'autres applications** peuvent **accéder** au clipboard, exposant potentiellement des données sensibles. Il est crucial de **désactiver les fonctions copier/coller** pour les sections sensibles d'une application, comme les détails de carte bancaire, afin de prévenir les leaks de données.

**Crash Logs**

Si une application **crashe** et **sauvegarde des logs**, ces logs peuvent aider des attaquants, particulièrement quand l'application ne peut pas être reverse-engineered. Pour atténuer ce risque, évitez de logger lors de crashes, et si des logs doivent être transmis sur le réseau, assurez-vous qu'ils le soient via un canal SSL pour la sécurité.

En tant que pentester, **essayez de consulter ces logs**.

**Analytics Data Sent To 3rd Parties**

Les applications intègrent souvent des services comme Google Adsense, ce qui peut involontairement **leak** des données sensibles à cause d'une mauvaise implémentation par les développeurs. Pour identifier d'éventuels leaks de données, il est conseillé d'**intercepter le trafic de l'application** et de vérifier si des informations sensibles sont envoyées à des services tiers.

### SQLite DBs

La plupart des applications utiliseront des **bases de données SQLite internes** pour sauvegarder des informations. Pendant le pentest, jetez un **œil** aux **bases de données** créées, aux noms des **tables** et des **colonnes** et à toutes les **données** sauvegardées car vous pourriez trouver des **informations sensibles** (ce qui constituerait une vulnérabilité).\
Les bases de données devraient se trouver dans `/data/data/the.package.name/databases` comme `/data/data/com.mwr.example.sieve/databases`

Si la base de données contient des informations confidentielles et est **chiffrée** mais que vous pouvez **trouver** le **mot de passe** à l'intérieur de l'application, c'est toujours une **vulnérabilité**.

Énumérez les tables en utilisant `.tables` et énumérez les colonnes des tables en faisant `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTE**: MobSF will detect as malicious the use of _**singleTask/singleInstance**_ as `android:launchMode` in an activity, but due to [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparently this is only dangerous on old versions (API versions < 21).

> [!TIP]
> Notez qu'un authorisation bypass n'est pas toujours une vulnérabilité ; cela dépend de la manière dont le bypass fonctionne et des informations exposées.

**Sensitive information leakage**

**Activities can also return results**. Si vous parvenez à trouver une activity exportée et non protégée appelant la méthode **`setResult`** et **retournant des informations sensibles**, il y a une sensitive information leakage.

#### Tapjacking

Si le tapjacking n'est pas empêché, vous pourriez abuser de l'activity exportée pour faire en sorte que **l'utilisateur effectue des actions inattendues**. Pour plus d'infos sur [**qu'est-ce que Tapjacking — suivez le lien**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Lisez ceci si vous voulez réviser ce qu'est un Content Provider.**](android-applications-basics.md#content-provider)\
Les Content providers sont essentiellement utilisés pour **partager des données**. Si une app dispose de content providers accessibles, vous pourriez être capable d'**extraire des données sensibles** depuis eux. Il est aussi intéressant de tester d'éventuelles **SQL injections** et **Path Traversals** car elles pourraient être vulnérables.

[**Apprenez comment exploiter les Content Providers avec Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Lisez ceci si vous voulez réviser ce qu'est un Service.**](android-applications-basics.md#services)\
Rappelez-vous que les actions d'un Service commencent dans la méthode `onStartCommand`.

Un Service est essentiellement quelque chose qui **peut recevoir des données**, les **traiter** et **renvoyer** (ou non) une réponse. Donc, si une application exporte certains services, vous devriez **vérifier** le **code** pour comprendre ce qu'il fait et le **tester** **dynamiquement** pour extraire des infos confidentielles, bypasser des mesures d'authentification...\
[**Apprenez comment exploiter les Services avec Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Lisez ceci si vous voulez réviser ce qu'est un Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
Rappelez-vous que les actions d'un Broadcast Receiver commencent dans la méthode `onReceive`.

Un broadcast receiver attendra un type de message. Selon la façon dont le receiver gère le message, il pourrait être vulnérable.\
[**Apprenez comment exploiter les Broadcast Receivers avec Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Vous pouvez rechercher des deep links manuellement, en utilisant des outils comme MobSF ou des scripts comme [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Vous pouvez **ouvrir** un **scheme** déclaré en utilisant **adb** ou un **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Notez que vous pouvez **omettre le nom du package** et le mobile appellera automatiquement l'application qui doit ouvrir ce lien._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code exécuté**

Pour trouver le **code qui sera exécuté dans l'App**, allez à l'activité appelée par le deeplink et cherchez la fonction **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Informations sensibles**

Chaque fois que vous trouvez un deep link vérifiez i**l ne reçoit pas de données sensibles (comme des mots de passe) via les paramètres URL**, car n'importe quelle autre application pourrait **usurper le deep link et voler ces données !**

**Parameters in path**

Vous **devez aussi vérifier si un deep link utilise un paramètre à l'intérieur du path** de l'URL comme : `https://api.example.com/v1/users/{username}` , dans ce cas vous pouvez forcer un path traversal en accédant à quelque chose comme : `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
Notez que si vous trouvez les endpoints corrects à l'intérieur de l'application vous pourriez provoquer un **Open Redirect** (si une partie du path est utilisée comme nom de domaine), un **account takeover** (si vous pouvez modifier les détails des users sans token CSRF et que l'endpoint vulnérable utilise la bonne méthode) et toute autre vuln. Plus d'[info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- **Certificates are not always inspected properly** par les applications Android. Il est courant que ces applications ignorent les avertissements et acceptent des certificats self-signed ou, dans certains cas, reviennent à des connexions HTTP.
- **Negotiations during the SSL/TLS handshake are sometimes weak**, employant des suites de chiffrement non sécurisées. Cette vulnérabilité rend la connexion susceptible à des attaques man-in-the-middle (MITM), permettant à un attaquant de décrypter les données.
- **Leakage of private information** est un risque lorsque les applications s'authentifient en utilisant des canaux sécurisés mais communiquent ensuite sur des canaux non sécurisés pour d'autres transactions. Cette approche ne protège pas les données sensibles, comme les session cookies ou les détails des users, contre l'interception par des entités malveillantes.

#### Certificate Verification

Nous allons nous concentrer sur la **vérification des certificats**. L'intégrité du certificat du serveur doit être vérifiée pour renforcer la sécurité. C'est crucial car des configurations TLS non sûres et la transmission de données sensibles sur des canaux non chiffrés peuvent présenter des risques importants. Pour des étapes détaillées sur la vérification des certificats serveur et la correction des vulnérabilités, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) fournit des conseils complets.

#### SSL Pinning

SSL Pinning est une mesure de sécurité où l'application vérifie le certificat du serveur par rapport à une copie connue stockée dans l'application elle-même. Cette méthode est essentielle pour prévenir les attaques MITM. Mettre en place SSL Pinning est fortement recommandé pour les applications manipulant des informations sensibles.

#### Traffic Inspection

Pour inspecter le trafic HTTP, il est nécessaire d'**installer le certificat de l'outil proxy** (par ex., Burp). Sans installer ce certificat, le trafic chiffré peut ne pas être visible via le proxy. Pour un guide sur l'installation d'un CA certificate personnalisé, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Les applications ciblant **API Level 24 and above** nécessitent des modifications du Network Security Config pour accepter le CA certificate du proxy. Cette étape est critique pour inspecter le trafic chiffré. Pour des instructions sur la modification du Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

Si **Flutter** est utilisé, vous devez suivre les instructions dans [**this page**](flutter.md). Cela est dû au fait que, simplement ajouter le certificate dans le store ne fonctionnera pas car Flutter a sa propre liste de CAs valides.

#### Static detection of SSL/TLS pinning

Avant d'essayer des contournements au runtime, cartographiez rapidement où le pinning est appliqué dans l'APK. La découverte statique vous aide à planifier des hooks/patches et à vous concentrer sur les bons chemins de code.

Tool: SSLPinDetect
- Open-source static-analysis utility qui décompile l'APK en Smali (via apktool) et scanne des patterns regex sélectionnés d'implémentations de SSL/TLS pinning.
- Rapporte le chemin de fichier exact, le numéro de ligne, et un extrait de code pour chaque match.
- Couvre des frameworks communs et des chemins de code personnalisés : OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Utilisation
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Exemples de règles de pattern (JSON)
Utilisez ou étendez les signatures pour détecter les styles de pinning propriétaires/personnalisés. Vous pouvez charger votre propre JSON et lancer des scans à grande échelle.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes et conseils
- Analyse rapide des grandes applications via multithreading et I/O mappée en mémoire ; les regex pré-compilées réduisent la charge/faux positifs.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Cibles typiques de détection à prioriser :
- OkHttp: CertificatePinner usage, setCertificatePinner, okhttp3/okhttp package references
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init with custom managers
- Declarative pins in res/xml network security config and manifest references
- Utilisez les emplacements trouvés pour planifier des hooks Frida, des patchs statiques, ou des revues de config avant les tests dynamiques.



#### Contourner SSL Pinning

Quand SSL Pinning est implémenté, le contourner devient nécessaire pour inspecter le trafic HTTPS. Différentes méthodes sont disponibles pour cela :

- Modifier automatiquement l'apk pour bypasser SSLPinning avec [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Le principal avantage de cette option est que vous n'aurez pas besoin de root pour contourner le SSL Pinning, mais vous devrez supprimer l'application et réinstaller la nouvelle, et cela ne fonctionne pas toujours.
- Vous pouvez utiliser **Frida** (discuté ci-dessous) pour bypasser cette protection. Voici un guide pour utiliser Burp+Frida+Genymotion : [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Vous pouvez aussi tenter de bypasser automatiquement SSL Pinning en utilisant [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Vous pouvez également essayer de bypasser automatiquement SSL Pinning en utilisant l'analyse dynamique de **MobSF** (expliquée ci-dessous)
- Si vous pensez encore qu'il existe du trafic que vous ne capturez pas, vous pouvez essayer de rediriger le trafic vers burp en utilisant iptables. Lisez ce blog : [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Recherche de vulnérabilités web courantes

Il est important de rechercher également les vulnérabilités web courantes au sein de l'application. Les informations détaillées sur l'identification et l'atténuation de ces vulnérabilités dépassent le cadre de ce résumé mais sont largement couvertes ailleurs.

### Frida

[Frida](https://www.frida.re) est une boîte à outils d'instrumentation dynamique pour développeurs, reverse-engineers et chercheurs en sécurité.\
**Vous pouvez accéder à une application en cours d'exécution et hooker des méthodes à l'exécution pour modifier le comportement, changer des valeurs, extraire des valeurs, exécuter du code différent...**\
Si vous voulez pentest des applications Android, vous devez savoir comment utiliser Frida.

- Apprenez à utiliser Frida : [**Tutoriel Frida**](frida-tutorial/index.html)
- Quelques "GUI" pour interagir avec Frida : [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection est excellent pour automatiser l'utilisation de Frida : [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Vous pouvez trouver quelques scripts Frida intéressants ici : [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Essayez de bypasser les mécanismes anti-debugging / anti-frida en chargeant Frida comme indiqué dans [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (outil [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

Vérifiez si l'application stocke des informations sensibles en mémoire qu'elle ne devrait pas conserver, comme des passwords ou des mnémoniques.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Cela va dump la mémoire dans le dossier ./dump, et vous pouvez y grep avec quelque chose comme:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Données sensibles dans Keystore**

Sur Android le Keystore est l'endroit idéal pour stocker des données sensibles, cependant, avec suffisamment de privilèges il est toujours **possible d'y accéder**. Comme les applications ont tendance à stocker ici **des données sensibles en clair**, les pentests devraient vérifier cela en tant que root user, car quelqu'un ayant un accès physique à l'appareil pourrait être capable de voler ces données.

Même si une app stocke des données dans le keystore, les données devraient être chiffrées.

Pour accéder aux données à l'intérieur du keystore vous pouvez utiliser ce script Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

En utilisant le script Frida suivant, il pourrait être possible de **bypass fingerprint authentication** mis en place par des applications Android afin de **protéger certaines zones sensibles :**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Images d'arrière-plan**

Lorsque vous placez une application en arrière-plan, Android enregistre un **instantané de l'application** : lorsqu'elle est ramenée au premier plan, le système charge d'abord cette image avant l'application, donnant l'impression que l'application s'est chargée plus rapidement.

Cependant, si cet instantané contient des **informations sensibles**, quelqu'un ayant accès à l'instantané pourrait **voler ces informations** (notez qu'il faut root pour y accéder).

Les instantanés sont généralement stockés à : **`/data/system_ce/0/snapshots`**

Android fournit un moyen de **prévenir la capture de screenshot en définissant le paramètre de layout FLAG_SECURE**. En utilisant ce flag, le contenu de la fenêtre est traité comme sécurisé, l'empêchant d'apparaître dans des screenshots ou d'être affiché sur des écrans non sécurisés.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analyseur d'applications Android**

Cet outil peut vous aider à gérer différents outils lors de l'analyse dynamique : [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Les développeurs créent souvent des composants proxy comme activities, services, and broadcast receivers qui gèrent ces Intents et les transmettent à des méthodes telles que `startActivity(...)` ou `sendBroadcast(...)`, ce qui peut être risqué.

Le danger réside dans le fait de permettre à des attaquants de déclencher des composants d'application non-exported ou d'accéder à des content providers sensibles en détournant ces Intents. Un exemple notable est le composant WebView convertissant des URLs en objets Intent via `Intent.parseUri(...)` puis les exécutant, pouvant conduire à des injections d'Intent malveillantes.

### Points essentiels

- **Intent Injection** est similaire au problème Open Redirect sur le web.
- Les exploits impliquent le passage d'objets `Intent` en tant qu'extras, qui peuvent être redirigés pour exécuter des opérations non sécurisées.
- Cela peut exposer des composants non-exported et des content providers aux attaquants.
- La conversion d'URL en Intent par WebView peut faciliter des actions non désirées.

### Android Client Side Injections and others

Vous connaissez probablement ce type de vulnérabilités depuis le Web. Il faut être particulièrement vigilant avec ces vulnérabilités dans une application Android :

- **SQL Injection:** Lors de la gestion de requêtes dynamiques ou de Content-Providers, assurez-vous d'utiliser des requêtes paramétrées.
- **JavaScript Injection (XSS):** Vérifiez que le support JavaScript et Plugin est désactivé pour tout WebViews (désactivé par défaut). [Plus d'infos ici](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** Les WebViews devraient avoir l'accès au système de fichiers désactivé (activé par défaut) - `(webview.getSettings().setAllowFileAccess(false);)`. [Plus d'infos ici](webview-attacks.md#javascript-enabled).
- **Cookies persistants :** Dans plusieurs cas, lorsque l'application Android termine la session, le cookie n'est pas révoqué ou peut même être enregistré sur le disque.
- [**Secure Flag** dans les cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Analyse automatique

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analyse statique**

![](<../../images/image (866).png>)

**Évaluation des vulnérabilités de l'application** via une jolie interface web. Vous pouvez aussi effectuer une analyse dynamique (mais vous devez préparer l'environnement).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Analyse dynamique assistée avec MobSF

**MobSF** peut aussi être très utile pour l’**analyse dynamique** sur **Android**, mais dans ce cas vous devrez installer MobSF et **genymotion** sur votre hôte (une **VM** ou **Docker** ne fonctionneront pas). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\  
L’**analyser dynamique** de MobSF peut :

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). Tout cela est fait automatiquement sauf pour les captures d’écran : vous devez appuyer lorsque vous voulez une capture d’écran ou appuyer sur "**Exported Activity Tester**" pour obtenir des captures de toutes les activités exportées.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

À partir des versions Android **> 5**, il **démarrera automatiquement Frida** et définira les paramètres **proxy** globaux pour **capturer** le trafic. Il ne capturera que le trafic de l’application testée.

**Frida**

Par défaut, il utilisera aussi quelques Frida Scripts pour **bypass SSL pinning**, **root detection** et **debugger detection** et pour **monitor interesting APIs**.\  
MobSF peut également **invoke exported activities**, prendre des **screenshots** de celles-ci et les **save** pour le rapport.

Pour **start** le test dynamique, appuyez sur le bouton vert : "**Start Instrumentation**". Appuyez sur "**Frida Live Logs**" pour voir les logs générés par les Frida scripts et sur "**Live API Monitor**" pour voir toutes les invocations des méthodes hookées, les arguments passés et les valeurs retournées (cela apparaîtra après avoir appuyé sur "Start Instrumentation").\
MobSF permet aussi de charger vos propres **Frida scripts** (pour envoyer les résultats de vos scripts Frida à MobSF utilisez la fonction `send()`). Il contient également **plusieurs scripts pré-écrits** que vous pouvez charger (vous pouvez en ajouter dans `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), il suffit de **select them**, appuyer sur "**Load**" puis sur "**Start Instrumentation**" (vous pourrez voir les logs de ces scripts dans "**Frida Live Logs**").

![](<../../images/image (419).png>)

De plus, vous disposez de quelques fonctionnalités auxiliaires Frida :

- **Enumerate Loaded Classes**: Il affichera toutes les classes chargées
- **Capture Strings**: Il affichera toutes les chaînes capturées pendant l’utilisation de l’application (très verbeux)
- **Capture String Comparisons**: Peut être très utile. Il affichera les 2 chaînes en cours de comparaison et si le résultat était True ou False.
- **Enumerate Class Methods**: Indiquez le nom de la classe (par exemple "java.io.File") et il affichera toutes les méthodes de la classe.
- **Search Class Pattern**: Recherche des classes par pattern
- **Trace Class Methods**: Trace une classe entière (voir les entrées et sorties de toutes les méthodes de la classe). N’oubliez pas que par défaut MobSF trace plusieurs méthodes intéressantes de l’API Android.

Une fois que vous avez sélectionné le module auxiliaire que vous voulez utiliser, vous devez appuyer sur "**Start Intrumentation**" et vous verrez toutes les sorties dans "**Frida Live Logs**".

**Shell**

MobSF propose aussi un shell avec quelques commandes **adb**, **MobSF commands**, et des **shell** **commands** courantes en bas de la page d’analyse dynamique. Quelques commandes intéressantes :
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Outils HTTP**

Lorsque le trafic HTTP est capturé, vous pouvez voir une vue brute du trafic capturé dans le bouton bas "**HTTP(S) Traffic**" ou une vue plus agréable dans le bouton vert "**Start HTTPTools**". À partir de la seconde option, vous pouvez **envoyer** les **requêtes capturées** vers des **proxies** comme Burp ou Owasp ZAP.\
Pour ce faire, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> appuyez sur "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Une fois que vous avez terminé l'analyse dynamique avec MobSF, vous pouvez appuyer sur "**Start Web API Fuzzer**" pour **fuzz** les requêtes HTTP et rechercher des vulnérabilités.

> [!TIP]
> Après avoir réalisé une analyse dynamique avec MobSF, les paramètres du proxy peuvent être mal configurés et vous ne pourrez pas les corriger depuis la GUI. Vous pouvez corriger les paramètres du proxy en exécutant :
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Analyse dynamique assistée avec Inspeckage

Vous pouvez obtenir l'outil depuis [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Cet outil utilise des **Hooks** pour vous indiquer **ce qui se passe dans l'application** pendant que vous effectuez une **analyse dynamique**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

C'est un **excellent outil pour effectuer une analyse statique avec une interface graphique**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Cet outil est conçu pour rechercher plusieurs **vulnérabilités liées à la sécurité des applications Android**, soit dans le **code source**, soit dans des **APKs empaquetés**. L'outil est également **capable de créer un APK déployable "Proof-of-Concept"** et des **commandes ADB**, pour exploiter certaines des vulnérabilités trouvées (Exposed activities, intents, tapjacking...). Comme avec Drozer, il n'est pas nécessaire de rooter l'appareil de test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Affiche tous les fichiers extraits pour une consultation facile
- Décompile automatiquement les fichiers APK au format Java et Smali
- Analyse AndroidManifest.xml pour détecter des vulnérabilités et comportements courants
- Analyse statique du code source pour détecter des vulnérabilités et comportements courants
- Informations sur l'appareil
- et plus encore
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER est une application en ligne de commande qui peut être utilisée sous Windows, MacOS X et Linux, qui analyse des fichiers _.apk_ à la recherche de vulnérabilités. Elle le fait en décompressant les APKs et en appliquant une série de règles pour détecter ces vulnérabilités.

Toutes les règles sont centralisées dans un fichier `rules.json`, et chaque entreprise ou testeur peut créer ses propres règles pour analyser ce dont ils ont besoin.

Téléchargez les derniers binaires depuis la [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn est un outil **multi-plateforme** qui aide les développeurs, bugbounty hunters et ethical hackers effectuant [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) sur les applications mobiles.

Le concept est que vous glissez-déposez votre fichier d'application mobile (un .apk ou .ipa) sur l'application StaCoAn et elle générera un rapport visuel et portable pour vous. Vous pouvez ajuster les paramètres et les wordlists pour obtenir une expérience personnalisée.

Télécharger[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework est un système d'analyse de vulnérabilités Android qui aide les développeurs ou hackers à trouver des vulnérabilités potentielles dans les applications Android.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** est un outil dont le but principal est de détecter et d'alerter l'utilisateur au sujet de comportements potentiellement malveillants développés par une application Android.

La détection est réalisée via la **static analysis** du Dalvik bytecode de l'application, représenté en **Smali**, grâce à la librairie [`androguard`](https://github.com/androguard/androguard).

Cet outil recherche des **comportements courants des applications "malveillantes"** tels que : Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. C'est un outil qui regroupe des outils couramment utilisés pour le reverse engineering et l'analyse d'applications mobiles, afin d'aider à tester les applications mobiles contre les menaces de sécurité mobile d'OWASP. Son objectif est de rendre cette tâche plus simple et plus accessible aux développeurs d'applications mobiles et aux professionnels de la sécurité.

Il peut :

- Extract Java and Smali code using different tools
- Analyser les APKs en utilisant : [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extraire des informations privées de l'APK en utilisant des regexps.
- Analyser le Manifest.
- Analyser les domaines trouvés en utilisant : [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) et [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Déobfusquer un APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile pour détecter les malware : [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

Notez que selon le service et la configuration que vous utilisez pour obfusquer le code, les secrets peuvent ou non être obfusqués.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. Il est capable d'optimiser le bytecode ainsi que de détecter et supprimer les instructions non utilisées. ProGuard est un logiciel libre distribué sous la GNU General Public License, version 2.

ProGuard est distribué dans l'Android SDK et s'exécute lors de la compilation de l'application en mode release.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Vous pouvez télécharger un APK obfusqué sur leur plateforme.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

C'est un outil LLM pour trouver d'éventuelles vulnérabilités de sécurité dans les apps Android et déobfusquer le code d'apps Android. Utilise l'API publique Gemini de Google.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Lisez ce tutoriel pour apprendre quelques astuces sur **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b est une machine virtuelle de sécurité Android basée sur ubuntu-mate, incluant une collection des derniers frameworks, tutoriels et labs de différents geeks et chercheurs en sécurité pour le reverse engineering et l'analyse de malware.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) C'est une excellente liste de ressources
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Cours rapide Android
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
