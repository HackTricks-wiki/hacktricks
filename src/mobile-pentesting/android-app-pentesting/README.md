# Android 애플리케이션 Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android 애플리케이션 기본

이 페이지를 먼저 읽어 Android 보안과 Android 애플리케이션에서 가장 위험한 구성요소와 관련된 **가장 중요한 부분들**을 아는 것을 강력히 권장합니다:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

이는 에뮬레이터이거나 실제 장치인 Android 디바이스에 연결할 때 필요한 주요 도구입니다.\
**ADB**를 사용하면 컴퓨터에서 **USB** 또는 **Network**를 통해 디바이스를 제어할 수 있습니다. 이 유틸리티는 양방향 파일 **복사**, 앱의 **설치** 및 **제거**, 셸 명령 **실행**, 데이터 **백업**, 로그 **읽기** 등 다양한 기능을 제공합니다.

adb 사용 방법을 배우려면 다음 목록의 [**ADB Commands**](adb-commands.md)를 확인하세요.

## Smali

때때로 **숨겨진 정보**(예: 잘 난독화된 비밀번호나 플래그)에 접근하기 위해 애플리케이션 코드를 **수정**하는 것이 흥미로울 수 있습니다. 이 경우 apk를 디컴파일하고 코드를 수정한 다음 다시 컴파일하는 것이 유용할 수 있습니다.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). 이는 앞으로 소개될 동적 분석 중 여러 테스트에 대한 **대안**으로 매우 유용할 수 있습니다. 그러므로 항상 이 가능성을 **염두에 두세요**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **APK 다운로드**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- 디바이스에서 APK 추출:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- 모든 splits 및 base apks를 [APKEditor](https://github.com/REAndroid/APKEditor)로 병합:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## 사례 연구 및 취약점


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## 정적 분석

무엇보다도, APK를 분석할 때는 디컴파일러를 사용해 **Java code를 살펴봐야 합니다**.\
Please, [**read here to find information about different available decompilers**](apk-decompilers.md).

### 흥미로운 정보 찾기

APK의 **strings**만 살펴봐도 **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** 등 흥미로운 항목을 찾을 수 있습니다... code execution **backdoors**나 authentication backdoors(앱에 하드코딩된 admin credentials)도 찾아보세요.

**Firebase**

특히 **Firebase** URL에 주의하고 잘못 구성되어 있는지 확인하세요. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 애플리케이션의 기본 이해 - Manifest.xml, strings.xml

애플리케이션의 **_Manifest.xml_ 및 **_strings.xml_ 파일을 검사하면 잠재적 보안 취약점이 드러날 수 있습니다**. 이 파일들은 디컴파일러로 접근하거나 APK 파일 확장자를 .zip으로 변경한 뒤 압축을 풀어 확인할 수 있습니다.

**Manifest.xml**에서 확인되는 **취약점** 예시는 다음과 같습니다:

- **Debuggable Applications**: _Manifest.xml_에 `debuggable="true"`로 설정된 애플리케이션은 연결을 허용하여 악용될 가능성이 있으므로 위험합니다. 디버깅 가능한 애플리케이션을 기기에서 찾아 악용하는 방법에 대한 튜토리얼을 참고하세요.
- **Backup Settings**: 민감한 정보를 처리하는 애플리케이션은 `android:allowBackup="false"`를 명시적으로 설정해 adb를 통한 무단 데이터 백업을 방지해야 합니다(특히 USB debugging이 활성화된 경우).
- **Network Security**: `android:networkSecurityConfig="@xml/network_security_config"`와 같은 커스텀 네트워크 보안 설정은 res/xml/에 위치하며 certificate pin이나 HTTP 트래픽 설정 등 보안 세부사항을 지정할 수 있습니다. 예를 들어 특정 도메인에 대해 HTTP 트래픽을 허용할 수 있습니다.
- **Exported Activities and Services**: 매니페스트에서 exported된 activities와 services를 식별하면 오용될 수 있는 컴포넌트를 파악할 수 있습니다. 동적 테스트 중 추가 분석을 통해 이러한 컴포넌트를 어떻게 악용할 수 있는지 확인하세요.
- **Content Providers and FileProviders**: 노출된 content providers는 무단 액세스나 데이터 수정의 원인이 될 수 있습니다. FileProviders의 구성도 면밀히 검토해야 합니다.
- **Broadcast Receivers and URL Schemes**: 이러한 컴포넌트는 악용에 이용될 수 있으므로, 특히 URL scheme이 입력을 어떻게 처리하는지 주의 깊게 확인하세요.
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, `maxSdkVersion` 속성은 지원되는 Android 버전을 나타내며, 오래된 취약한 Android 버전을 지원하지 않도록 주의해야 합니다.

**strings.xml** 파일에서는 API keys, custom schemas 및 개발자 메모 등 민감한 정보를 발견할 수 있으므로 이러한 리소스를 주의 깊게 검토해야 합니다.

### Tapjacking

**Tapjacking**은 **malicious** **application**이 시작되어 **victim application 위에 자신을 배치**하는 공격입니다. 피해자 앱을 시각적으로 가린 상태에서 악성 앱의 UI는 사용자를 속여 상호작용하게 한 뒤 그 상호작용을 피해자 앱으로 전달하도록 설계됩니다.\
결과적으로 사용자는 자신이 실제로는 피해자 앱에서 동작을 수행하고 있다는 사실을 알 수 없게 됩니다.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

`launchMode`가 **`singleTask`로 설정되어 있고 `taskAffinity`가 정의되어 있지 않은** **activity**는 task Hijacking에 취약합니다. 이는 악성 **application**이 설치되어 실제 애플리케이션보다 먼저 실행되면 **실제 애플리케이션의 task를 hijack할 수 있다**는 것을 의미합니다(사용자는 실제 애플리케이션을 사용한다고 생각하며 **malicious application**과 상호작용하게 됩니다).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android에서 내부 저장소에 **저장된** 파일은 해당 파일을 **생성한 앱만 접근할 수 있도록 설계**되어 있습니다. 이 보안 조치는 Android OS에 의해 적용되며 대부분의 애플리케이션 보안 요구에 충분합니다. 그러나 개발자가 `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE` 같은 모드를 사용해 파일을 다른 애플리케이션과 **공유하도록 허용하는 경우**가 있습니다. 이러한 모드는 잠재적으로 악의적인 애플리케이션을 포함한 다른 애플리케이션의 접근을 **제한하지 않습니다**.

1. **Static Analysis:**
- `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`의 사용을 **면밀히 검토**하세요. 이러한 모드는 파일을 **의도치 않거나 무단으로 접근 가능하도록 노출**할 수 있습니다.
2. **Dynamic Analysis:**
- 앱이 생성한 파일의 **권한**을 **확인**하세요. 특히 어떤 파일이 전 세계적으로 읽기 또는 쓰기가 가능하도록 설정되어 있는지 **체크**해야 합니다. 이는 기기에 설치된 **어떤 애플리케이션이든** 출처나 의도와 관계없이 해당 파일을 **읽거나 수정할 수 있게** 하므로 심각한 보안 위험이 될 수 있습니다.

**External Storage**

SD 카드와 같은 **external storage**의 파일을 다룰 때는 다음과 같은 주의가 필요합니다:

1. **Accessibility**:
- external storage의 파일은 **전역적으로 읽기 및 쓰기가 가능**합니다. 즉, 어떤 애플리케이션이나 사용자라도 이 파일들에 접근할 수 있습니다.
2. **Security Concerns**:
- 접근이 용이하기 때문에 민감한 정보를 external storage에 저장하지 않는 것이 권장됩니다.
- external storage는 제거되거나 어떤 애플리케이션에 의해서든 접근될 수 있어 보안성이 낮습니다.
3. **Handling Data from External Storage**:
- external storage에서 가져온 데이터는 항상 **입력 검증**을 수행하세요. 해당 데이터는 신뢰할 수 없는 출처에서 온 것이기 때문에 중요합니다.
- 외부 저장소에 실행 파일이나 class 파일을 저장해 동적으로 로드하는 것은 강력히 권장되지 않습니다.
- 애플리케이션이 외부 저장소에서 실행 파일을 불러야 하는 경우, 해당 파일들이 동적으로 로드되기 전에 **서명되고 암호학적으로 검증**되었는지 확인하세요. 이 단계는 애플리케이션의 보안 무결성을 유지하는 데 필수적입니다.

External storage는 `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard`에서 접근할 수 있습니다.

> [!TIP]
> Starting with Android 4.4 (**API 17**), the SD card has a directory structure which **limits access from an app to the directory which is specifically for that app**. This prevents malicious application from gaining read or write access to another app's files.

**Sensitive data stored in clear-text**

- **Shared preferences**: Android는 각 애플리케이션이 `/data/data/<packagename>/shared_prefs/` 경로에 xml 파일을 쉽게 저장할 수 있도록 허용하며 때로는 그 폴더에서 평문으로 민감한 정보를 찾을 수 있습니다.
- **Databases**: Android는 각 애플리케이션이 `/data/data/<packagename>/databases/` 경로에 sqlite 데이터베이스를 쉽게 저장할 수 있도록 허용하며 때로는 그 폴더에서 평문으로 민감한 정보를 찾을 수 있습니다.

### Broken TLS

**Accept All Certificates**

때때로 개발자가 호스트네임이 일치하지 않더라도 모든 인증서를 수락하는 코드를 작성하는 경우가 있습니다. 예를 들어 다음과 같은 코드 라인이 있을 수 있습니다:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Broken Cryptography

**Poor Key Management Processes**

일부 개발자는 민감한 데이터를 로컬 스토리지에 저장하고 코드에 하드코딩되거나 예측 가능한 키로 암호화합니다. 이는 리버싱(reversing)을 통해 공격자가 기밀 정보를 추출할 수 있으므로 해서는 안 됩니다.

**Use of Insecure and/or Deprecated Algorithms**

개발자는 **deprecated algorithms**을 사용하여 권한 부여 **checks**, 데이터를 **store**하거나 **send**해서는 안 됩니다. 이러한 알고리즘에는 RC4, MD4, MD5, SHA1 등이 포함됩니다. 예를 들어 비밀번호 저장에 **hashes**를 사용하는 경우에는 salt와 함께 해시 brute-force에 **resistant**한 방식을 사용해야 합니다.

### Other checks

- 공격자가 리버스 엔지니어링 작업을 어렵게 만들기 위해 **APK를 obfuscate**하는 것을 권장합니다.
- 앱이 민감한 경우(예: bank apps) **mobile이 rooted인지 확인하는 자체 검사**를 수행하고 그에 따라 동작해야 합니다.
- 앱이 민감한 경우(예: bank apps) **emulator 사용 여부를 확인**해야 합니다.
- 앱이 민감한 경우(예: bank apps) **실행 전에 자체 무결성 검사를 수행하여 수정 여부를 확인**해야 합니다.
- 어떤 compiler/packer/obfuscator로 APK가 빌드되었는지 확인하려면 [**APKiD**](https://github.com/rednaga/APKiD)를 사용하세요

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

툴 [**mariana-trench**](https://github.com/facebook/mariana-trench)는 애플리케이션의 **code**를 **scanning**하여 **vulnerabilities**를 찾을 수 있습니다. 이 도구에는 **known sources**(툴에 **input**이 **사용자에 의해 제어되는 위치**를 알려주는 것), **sinks**(악의적 입력이 피해를 줄 수 있는 **dangerous** **장소**를 툴에 알려주는 것) 및 **rules**의 집합이 포함되어 있습니다. 이러한 rules는 취약점을 나타내는 **sources-sinks**의 **조합**을 지정합니다.

이 지식을 바탕으로 **mariana-trench는 코드를 검토하고 가능한 취약점을 찾아냅니다**.

### Secrets leaked

응용프로그램에는 API keys, passwords, hidden urls, subdomains...과 같은 secrets가 포함되어 있을 수 있으며, 이를 발견할 수 있습니다. 예를 들어 [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)와 같은 도구를 사용할 수 있습니다.

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

다음에서 **무료 계정**을 생성할 수 있습니다: [https://appetize.io/](https://appetize.io/). 이 플랫폼은 APK를 **업로드**하고 **실행**할 수 있게 해 주므로 APK가 어떻게 동작하는지 확인하는 데 유용합니다.

웹에서 **애플리케이션 로그를 볼 수** 있고 **adb**를 통해 연결할 수도 있습니다.

![](<../../images/image (831).png>)

ADB 연결 덕분에 에뮬레이터 내에서 **Drozer**와 **Frida**를 사용할 수 있습니다.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- 이 페이지에서 설정 방법을 배우세요:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> 어떤 플랫폼에서든 새 에뮬레이터를 만들 때 화면이 클수록 에뮬레이터가 느려진다는 점을 기억하세요. 가능한 작은 화면을 선택하세요.

Genymotion에 Google 서비스를(예: AppStore) **설치하려면** 다음 이미지의 빨간 표시된 버튼을 클릭해야 합니다:

![](<../../images/image (277).png>)

또한 **Genymotion의 Android VM 구성**에서 **Bridge Network mode**를 선택할 수 있다는 점을 확인하세요(다른 VM에서 Android VM으로 도구에 접속할 경우 유용합니다).

#### Use a physical device

**debugging** 옵션을 활성화해야 하며, 가능하면 **root**하는 것이 좋습니다:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> 앱을 설치한 후 가장 먼저 해야 할 일은 앱을 직접 사용해 보고 무엇을 하는지, 어떻게 동작하는지 조사하여 익숙해지는 것입니다.\
> 초기 dynamic analysis를 MobSF dynamic analysis + pidcat을 사용하여 수행할 것을 권장합니다. 이렇게 하면 애플리케이션이 어떻게 동작하는지 배우는 동안 MobSF가 나중에 검토할 수 있는 많은 **흥미로운 데이터**를 **캡처**합니다.

### Unintended Data Leakage

**Logging**

개발자는 **debugging information**을 공개적으로 노출하는 것을 주의해야 합니다. 이는 민감한 데이터의 leak로 이어질 수 있습니다. 애플리케이션 로그를 모니터링하여 민감한 정보를 식별하고 보호하기 위해 [**pidcat**](https://github.com/JakeWharton/pidcat) 및 `adb logcat` 도구를 권장합니다. **Pidcat**은 사용 편의성과 가독성 때문에 선호됩니다.

> [!WARNING]
> Android 4.0 이후 버전에서는 **애플리케이션이 자신의 로그만 접근할 수 있습니다**. 따라서 애플리케이션은 다른 앱의 로그에 접근할 수 없습니다.\
> 어쨌든 민감한 정보를 로그에 남기지 않는 것이 권장됩니다.

**Copy/Paste Buffer Caching**

Android의 **clipboard-based** 프레임워크는 앱에서 복사-붙여넣기 기능을 제공하지만, **다른 애플리케이션이 clipboard에 접근할 수 있어** 민감한 정보를 노출할 위험이 있습니다. 신용카드 정보와 같은 민감한 섹션에 대해서는 복사/붙여넣기 기능을 비활성화하는 것이 중요합니다.

**Crash Logs**

애플리케이션이 **crash**하고 로그를 저장하면, 이러한 로그는 특히 애플리케이션을 리버스 엔지니어링할 수 없을 때 공격자에게 도움이 될 수 있습니다. 이러한 위험을 완화하려면 크래시 시 로깅을 피하고, 로그를 네트워크로 전송해야 하는 경우 SSL 채널을 통해 전송되도록 하세요.

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

앱은 종종 Google Adsense와 같은 서비스를 통합하는데, 개발자의 잘못된 구현으로 인해 민감한 데이터가 의도치 않게 leak sensitive data할 수 있습니다. 잠재적인 데이터 leak를 식별하려면 애플리케이션의 트래픽을 가로채어 타사 서비스로 전송되는 민감한 정보가 있는지 확인하는 것이 좋습니다.

### SQLite DBs

대부분의 애플리케이션은 정보를 저장하기 위해 **internal SQLite databases**를 사용합니다. 펜테스트 중에는 생성된 **databases**, **tables** 및 **columns**의 이름과 저장된 **data**를 확인하세요. 여기서 **민감한 정보**를 찾을 수 있으며 이는 취약점이 될 수 있습니다.\
데이터베이스는 `/data/data/the.package.name/databases` 예: `/data/data/com.mwr.example.sieve/databases`에 위치해야 합니다.

데이터베이스가 기밀 정보를 저장하고 **encrypted**되어 있지만 애플리케이션 내에서 **password**를 찾을 수 있다면 이것도 여전히 **취약점**입니다.

.tables를 사용하여 테이블을 나열하고 `.schema <table_name>`으로 테이블의 컬럼을 열거하세요.

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer**는 당신이 **Android app의 역할을 가정**하고 다른 앱과 상호작용할 수 있게 해줍니다. 설치된 애플리케이션이 할 수 있는 모든 것을 수행할 수 있으며, Android의 Inter-Process Communication(IPC) 메커니즘을 사용하고 기본 운영체제와 상호작용할 수 있습니다. .\
Drozer는 **exported activities, exported services 및 Content Providers를 exploit**하는 데 유용한 도구입니다. 다음 섹션에서 이를 배울 수 있습니다.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
또한 activity의 코드는 **`onCreate`** 메서드에서 시작된다는 것을 기억하세요.

**Authorisation bypass**

Activity가 exported되어 있으면 외부 앱에서 해당 화면을 호출할 수 있습니다. 따라서 **sensitive information**을 가진 Activity가 **exported**되어 있다면 **authentication** 메커니즘을 **bypass**하고 접근할 수 있습니다.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**참고**: MobSF는 activity에서 `android:launchMode`로 _**singleTask/singleInstance**_를 사용하는 것을 악성으로 탐지하지만, [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) 때문에 보이는 바에 따르면 이는 오래된 버전(API versions < 21)에서만 위험합니다.

> [!TIP]
> authorisation bypass는 항상 취약점이 되는 것은 아닙니다. 우회가 어떻게 작동하는지와 어떤 정보가 노출되는지에 따라 달라집니다.

**민감한 정보 leakage**

**Activities는 결과를 반환할 수도 있습니다**. 만약 exported 및 unprotected한 activity가 **`setResult`** 메서드를 호출하고 **민감한 정보를 반환**하는 것을 찾는다면, 민감한 정보 leakage가 발생합니다.

#### Tapjacking

Tapjacking이 방지되지 않으면, exported activity를 악용해 **사용자에게 예상치 못한 동작을 수행하게 만들 수 있습니다**. For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - 민감한 정보 접근 및 조작

[**Content Provider가 무엇인지 다시 확인하려면 읽어보세요.**](android-applications-basics.md#content-provider)\
Content providers는 기본적으로 **데이터를 공유**하기 위해 사용됩니다. 앱이 사용 가능한 content providers를 가지고 있다면 그들로부터 **민감한 데이터를 추출**할 수 있습니다. 또한 잠재적으로 취약할 수 있으므로 가능한 **SQL injections** 및 **Path Traversals**를 테스트하는 것도 중요합니다.

[**Drozer로 Content Providers를 익스플로잇하는 방법을 배우세요.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Service가 무엇인지 다시 확인하려면 읽어보세요.**](android-applications-basics.md#services)\
Service의 동작은 `onStartCommand` 메서드에서 시작된다는 점을 기억하세요.

Service는 기본적으로 데이터를 **수신**하고, 이를 **처리**하며 (또는 그렇지 않을 수도 있지만) **응답을 반환**할 수 있는 것입니다. 따라서 앱이 일부 services를 export하고 있다면, 무엇을 하는지 이해하기 위해 **코드**를 확인하고 기밀 정보를 추출하거나 인증 우회를 위해 **동적으로** 테스트해야 합니다.\
[**Drozer로 Services를 익스플로잇하는 방법을 배우세요.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Broadcast Receiver가 무엇인지 다시 확인하려면 읽어보세요.**](android-applications-basics.md#broadcast-receivers)\
Broadcast Receiver의 동작은 `onReceive` 메서드에서 시작됩니다.

Broadcast receiver는 특정 타입의 메시지를 대기합니다. 리시버가 메시지를 처리하는 방식에 따라 취약할 수 있습니다.\
[**Drozer로 Broadcast Receivers를 익스플로잇하는 방법을 배우세요.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

MobSF 같은 도구나 [이 스크립트](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) 같은 것을 사용해 수동으로 deep links를 찾을 수 있습니다.\
선언된 **scheme**을 **adb**나 **browser**로 **열 수** 있습니다:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_**패키지 이름을 생략할 수** 있다는 점을 유의하세요. 모바일이 해당 링크를 열 앱을 자동으로 호출합니다._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

App에서 실행될 **code that will be executed in the App**를 찾으려면 deeplink에 의해 호출되는 activity로 이동해 함수 **`onNewIntent`**을 검색하세요.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitive info**

deep link를 발견할 때마다 URL 파라미터를 통해 비밀번호 같은 민감한 데이터를 받고 있지 않은지 항상 확인하세요. 다른 애플리케이션이 해당 deep link를 **impersonate**하여 그 데이터를 훔칠 수 있습니다!

**Parameters in path**

You **must check also if any deep link is using a parameter inside the path** of the URL like: `https://api.example.com/v1/users/{username}` , in that case you can force a path traversal accessing something like: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
앱 내부에서 올바른 엔드포인트를 찾는다면 경로의 일부가 도메인 이름으로 사용되는 경우 **Open Redirect**를 유발할 수 있고, CSRF 토큰 없이 사용자 정보를 수정할 수 있고 취약한 엔드포인트가 적절한 메서드를 사용했다면 **account takeover** 등이 가능할 수 있으며 기타 여러 취약점이 발생할 수 있습니다. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**More examples**

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer Inspection and Verification Failures

- Android 애플리케이션은 **certificates를 항상 제대로 검사하지 않을 수 있습니다**. 이러한 앱들은 self-signed certificate 경고를 무시하거나, 어떤 경우에는 HTTP 연결로 되돌아가는 것을 간과하는 일이 흔합니다.
- **SSL/TLS 핸드셰이크 중 협상 과정이 약한 경우**가 있어 안전하지 않은 cipher suite를 사용할 수 있습니다. 이 취약점은 MITM 공격에 취약하게 하여 공격자가 데이터를 복호화할 수 있게 만듭니다.
- **Leakage of private information**은 애플리케이션이 일부는 secure 채널로 인증하지만 다른 트랜잭션에서는 non-secure 채널로 통신할 때 발생할 수 있는 위험입니다. 이 접근 방식은 세션 쿠키나 사용자 정보 같은 민감한 데이터를 악의적인 제3자에 의해 가로채지 못하도록 보호하지 못합니다.

#### Certificate Verification

우리는 **certificate verification**에 중점을 둘 것입니다. 서버의 certificate 무결성을 검증하는 것은 보안을 강화하기 위해 필수적입니다. 불안전한 TLS 설정과 암호화되지 않은 채널을 통한 민감한 데이터 전송은 심각한 위험을 초래할 수 있습니다. 서버 인증서 검증 및 취약점 대응에 대한 자세한 단계는 [**this resource**](https://manifestsecurity.com/android-application-security-part-10/)에서 확인하세요.

#### SSL Pinning

SSL Pinning은 애플리케이션이 서버의 certificate를 앱 내에 저장된 알려진 복사본과 비교하여 검증하는 보안 기법입니다. 이는 MITM 공격을 방지하는 데 필수적입니다. 민감한 정보를 다루는 애플리케이션에는 SSL Pinning 구현을 강력히 권장합니다.

#### Traffic Inspection

HTTP 트래픽을 검사하려면 proxy 도구의 certificate(예: Burp)를 **설치해야** 합니다. 이 인증서를 설치하지 않으면 암호화된 트래픽이 프록시를 통해 보이지 않을 수 있습니다. custom CA certificate 설치 가이드는 [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)를 참고하세요.

애플리케이션이 **API Level 24 and above**를 타겟으로 하는 경우, 프록시의 CA certificate를 수락하도록 Network Security Config를 수정해야 합니다. 암호화된 트래픽을 검사하려면 이 단계가 중요합니다. Network Security Config 수정 방법은 [**refer to this tutorial**](make-apk-accept-ca-certificate.md)를 확인하세요.

만약 **Flutter**를 사용하고 있다면 [**this page**](flutter.md)에 있는 지침을 따르세요. 단순히 인증서를 스토어에 추가하는 것만으로는 작동하지 않습니다. Flutter는 자체적인 유효한 CA 목록을 사용하기 때문입니다.

#### Static detection of SSL/TLS pinning

런타임 우회 시도를 하기 전에 APK에서 pinning이 강제되는 위치를 빠르게 매핑하세요. 정적 탐지는 훅/패치 계획을 세우고 올바른 코드 경로에 집중하는 데 도움이 됩니다.

Tool: SSLPinDetect
- 오픈소스 정적 분석 유틸리티로 APK를 Smali로 디컴파일(apktool 사용)하고 SSL/TLS pinning 구현에 대한 정규식 패턴을 스캔합니다.
- 각 매치에 대해 정확한 파일 경로, 라인 번호 및 코드 스니펫을 리포트합니다.
- OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, 및 Network Security Config XML pins 등 일반적인 프레임워크와 커스텀 코드 경로를 커버합니다.

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
사용법
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
예시 패턴 규칙 (JSON)
signatures를 사용하거나 확장하여 독점/맞춤형 pinning 스타일을 탐지하세요. 자신의 JSON을 로드해 대규모로 스캔할 수 있습니다.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
노트 및 팁
- 대용량 앱을 빠르게 스캔하려면 multi-threading 및 memory-mapped I/O를 사용하세요; pre-compiled regex는 오버헤드/오탐을 줄여줍니다.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- 다음으로 분류할 일반적인 탐지 대상:
- OkHttp: CertificatePinner 사용, setCertificatePinner, okhttp3/okhttp 패키지 참조
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted 오버라이드
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init와 custom managers
- res/xml의 선언적 pins 및 manifest 참조에 명시된 pins
- 일치한 위치들을 이용해 Frida hooks, static patches, 또는 config 리뷰를 동적 테스트 전에 계획하세요.



#### Bypassing SSL Pinning

SSL Pinning이 구현된 경우, HTTPS 트래픽을 검사하려면 이를 bypass하는 것이 필요합니다. 이를 위한 다양한 방법이 있습니다:

- 자동으로 **apk**를 수정하여 **SSLPinning**을 **bypass**하도록 [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)를 사용할 수 있습니다. 이 옵션의 가장 큰 장점은 SSL Pinning을 bypass하는 데 root가 필요 없다는 점이지만, 애플리케이션을 삭제하고 새로 설치해야 하며 항상 동작하지는 않습니다.
- 아래에서 설명하는 것처럼 **Frida**를 사용해 이 보호를 bypass할 수 있습니다. Burp+Frida+Genymotion을 사용하는 가이드는 다음을 참조하세요: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- [**objection**](frida-tutorial/objection-tutorial.md)를 사용해 SSL Pinning을 자동으로 bypass해볼 수도 있습니다: `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- **MobSF dynamic analysis**를 이용해 SSL Pinning을 자동으로 bypass해볼 수도 있습니다(아래 설명).
- 여전히 캡처되지 않는 트래픽이 있다고 생각되면 iptables를 사용해 트래픽을 Burp로 포워딩해 보세요. 블로그: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Looking for Common Web Vulnerabilities

애플리케이션 내부에서 일반적인 웹 취약점을 찾아보는 것도 중요합니다. 이러한 취약점을 식별하고 완화하는 방법에 대한 자세한 정보는 이 요약의 범위를 벗어나며 다른 곳에서 광범위하게 다루어집니다.

### Frida

[Frida](https://www.frida.re) 는 개발자, 리버스 엔지니어, 보안 연구자를 위한 동적 계측 툴킷입니다.\
**실행 중인 애플리케이션에 접근해 런타임에 메서드를 hook하여 동작을 변경하거나 값 변경/추출, 다른 코드 실행 등을 할 수 있습니다...**\
Android 애플리케이션을 pentest하려면 Frida 사용법을 알아야 합니다.

- Frida 사용법 배우기: [**Frida tutorial**](frida-tutorial/index.html)
- Frida 작업을 위한 일부 "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection은 Frida 사용을 자동화하는 데 유용합니다: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- Awesome Frida 스크립트 모음: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Frida 없이도 code injection을 통해 anti-debugging / anti-frida 메커니즘을 우회해보세요: [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (도구 [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

애플리케이션이 비밀번호나 니모닉과 같이 저장해서는 안 되는 민감한 정보를 메모리에 보관하고 있는지 확인하세요.

Using [**Fridump3**](https://github.com/rootbsd/fridump3) you can dump the memory of the app with:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
이 명령은 메모리를 ./dump 폴더에 덤프합니다. 그 안에서 다음과 같이 grep할 수 있습니다:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore의 민감한 데이터**

Android에서는 Keystore가 민감한 데이터를 저장하기에 가장 좋은 장소이지만, 충분한 권한이 있다면 여전히 **접근할 수 있습니다**. 애플리케이션이 이곳에 **sensitive data in clear text**를 저장하는 경향이 있으므로 pentests는 이를 확인해야 합니다. root user나 장치에 물리적으로 접근할 수 있는 사람은 이 데이터를 탈취할 수 있습니다.

앱이 keystore에 데이터를 저장하더라도 데이터는 암호화되어야 합니다.

keystore 내부의 데이터에 접근하려면 다음 Frida 스크립트를 사용할 수 있습니다: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

다음 Frida 스크립트를 사용하면 Android 애플리케이션이 **특정 민감 영역을 보호하기 위해** 수행하는 **bypass fingerprint authentication**을 우회할 수 있습니다:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **백그라운드 이미지**

애플리케이션을 백그라운드로 보낼 때, Android는 **애플리케이션의 스냅샷**을 저장합니다. 따라서 포그라운드로 복구될 때 앱보다 먼저 이미지를 불러와 앱이 더 빨리 로드된 것처럼 보이게 합니다.

그러나 이 스냅샷에 **민감한 정보**가 포함되어 있으면, 스냅샷에 접근할 수 있는 사람이 그 정보를 **탈취할 수 있습니다** (참고: 접근하려면 root 권한이 필요합니다).

스냅샷은 일반적으로 다음 경로에 저장됩니다: **`/data/system_ce/0/snapshots`**

Android는 레이아웃 파라미터로 **FLAG_SECURE을 설정하여 스크린샷 캡처를 방지하는 방법**을 제공합니다. 이 플래그를 사용하면 윈도우 내용이 보안 처리되어 스크린샷에 표시되거나 비보안 디스플레이에서 표시되는 것을 방지합니다.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android 애플리케이션 분석기**

이 도구는 동적 분석을 수행하는 동안 다양한 도구를 관리하는 데 도움이 될 수 있습니다: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

개발자들은 종종 activities, services, and broadcast receivers 같은 프록시 컴포넌트를 생성하여 이러한 Intents를 처리하고 `startActivity(...)` 또는 `sendBroadcast(...)` 같은 메서드로 전달하는데, 이는 위험할 수 있습니다.

위험은 공격자가 이러한 Intents를 잘못 유도하여 non-exported app components를 트리거하거나 민감한 content providers에 접근할 수 있게 하는 데 있습니다. 한 가지 주목할 예는 `WebView` 컴포넌트가 URL을 `Intent` 객체로 변환하기 위해 `Intent.parseUri(...)`를 사용한 뒤 이를 실행하여 악의적인 Intent 주입을 초래할 수 있다는 점입니다.

### 핵심 요점

- **Intent Injection**은 웹의 Open Redirect 문제와 유사합니다.
- 익스플로잇은 `Intent` 객체를 extras로 전달하는 것을 포함하며, 이는 리디렉션되어 안전하지 않은 동작을 실행할 수 있습니다.
- 이는 non-exported components 및 content providers를 공격자에게 노출시킬 수 있습니다.
- `WebView`의 URL → `Intent` 변환은 의도치 않은 동작을 촉진할 수 있습니다.

### Android 클라이언트 측 인젝션 및 기타

아마 웹에서 이러한 유형의 취약점을 알고 있을 것입니다. Android 애플리케이션에서는 특히 이러한 취약점에 주의해야 합니다:

- **SQL Injection:** 동적 쿼리나 Content-Providers를 다룰 때는 파라미터화된 쿼리를 사용하고 있는지 확인하세요.
- **JavaScript Injection (XSS):** 모든 WebViews에서 JavaScript 및 Plugin 지원이 비활성화되어 있는지 확인하세요 (기본적으로 비활성화되어 있음). [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews는 파일 시스템 접근이 비활성화되어야 합니다 (기본적으로 활성화되어 있음) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: 여러 경우에서 Android 애플리케이션이 세션을 종료할 때 쿠키가 해지되지 않거나 디스크에 저장될 수 있습니다
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## 자동 분석

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**정적 분석**

![](<../../images/image (866).png>)

**애플리케이션의 취약점 평가**는 깔끔한 웹 기반 프론트엔드를 통해 제공됩니다. 동적 분석도 수행할 수 있지만 환경을 준비해야 합니다.
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
알려드립니다: MobSF는 **Android**(apk)**, IOS**(ipa) **and Windows**(apx) 애플리케이션을 분석할 수 있습니다 (_Windows 애플리케이션은 Windows 호스트에 설치된 MobSF에서 분석되어야 합니다_).\
또한, **Android** 또는 **IOS** 앱의 소스 코드로 **ZIP** 파일을 만들면(애플리케이션의 루트 폴더로 가서 모든 것을 선택한 후 ZIP 파일을 생성), MobSF가 이를 분석할 수 있습니다.

MobSF는 또한 분석을 **diff/Compare**할 수 있고 **VirusTotal**을 통합할 수 있습니다 (API 키를 _MobSF/settings.py_에 설정하고 활성화해야 합니다: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). `VT_UPLOAD`를 `False`로 설정하면 파일 대신 **hash**가 **upload**됩니다.

### MobSF를 이용한 보조 동적 분석

**MobSF**는 **Android**에서의 **dynamic analysis**에도 매우 유용합니다. 다만 이 경우 호스트에 MobSF와 **genymotion**을 설치해야 합니다(가상 머신이나 Docker에서는 작동하지 않습니다). _참고: 먼저 **genymotion에서 VM을 시작**한 후 **MobSF를 시작**해야 합니다._\
**MobSF dynamic analyser**는 다음을 수행할 수 있습니다:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). 이들 중 스크린샷을 제외한 모든 항목은 자동으로 수행됩니다. 스크린샷은 원하는 시점에 직접 버튼을 눌러야 하거나 모든 exported activities의 스크린샷을 얻기 위해 "**Exported Activity Tester**"를 눌러야 합니다.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

Android **versions > 5**부터는 **Frida를 자동으로 시작**하고 전역 **proxy** 설정을 구성하여 트래픽을 **capture**합니다. 테스트 중인 애플리케이션에서 나오는 트래픽만 캡처됩니다.

**Frida**

기본적으로 일부 Frida 스크립트를 사용하여 **bypass SSL pinning**, **root detection** 및 **debugger detection**을 우회하고 **monitor interesting APIs**를 수행합니다.\
MobSF는 또한 **invoke exported activities**를 실행하고, 해당 활동의 **screenshots**을 캡처하여 리포트용으로 **save**할 수 있습니다.

동적 테스트를 시작하려면 초록색 버튼인 "**Start Instrumentation**"을 누르세요. Frida 스크립트가 생성한 로그를 보려면 "**Frida Live Logs**"를, 후킹된 메소드 호출, 전달된 인자 및 반환값을 모두 보려면 "**Live API Monitor**"를 누르세요(이는 "Start Instrumentation"을 누른 후에 나타납니다).\
MobSF는 또한 자체 **Frida scripts**를 로드할 수 있습니다(Frida 스크립트의 결과를 MobSF로 보내려면 `send()` 함수를 사용). 또한 로드할 수 있는 **several pre-written scripts**가 있으며(더 추가하려면 `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`에 추가), 단순히 **select them**, 버튼 "**Load**"를 누르고 "**Start Instrumentation**"을 누르세요(해당 스크립트의 로그는 "**Frida Live Logs**"에서 볼 수 있습니다).

![](<../../images/image (419).png>)

또한 몇 가지 보조 Frida 기능이 있습니다:

- **Enumerate Loaded Classes**: 로드된 모든 클래스를 출력합니다.
- **Capture Strings**: 애플리케이션 사용 중 캡처된 모든 문자열을 출력합니다 (매우 노이즈가 많음).
- **Capture String Comparisons**: 매우 유용할 수 있습니다. 비교되는 두 문자열을 표시하고 결과가 True인지 False인지 보여줍니다.
- **Enumerate Class Methods**: 클래스 이름(예: "java.io.File")을 입력하면 해당 클래스의 모든 메서드를 출력합니다.
- **Search Class Pattern**: 패턴으로 클래스를 검색합니다.
- **Trace Class Methods**: **Trace** a **whole class** (해당 클래스의 모든 메서드의 입력과 출력을 확인). 기본적으로 MobSF는 여러 흥미로운 Android Api 메서드를 추적합니다.

원하는 보조 모듈을 선택한 후 "**Start Intrumentation**"을 눌러야 하며, 모든 출력은 "**Frida Live Logs**"에서 확인할 수 있습니다.

**Shell**

MobSF는 동적 분석 페이지 하단에 몇 가지 **adb** 명령, **MobSF commands**, 그리고 일반적인 **shell** **commands**가 포함된 쉘을 제공합니다. 몇 가지 흥미로운 명령:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 도구**

http 트래픽을 캡처하면 아래의 "**HTTP(S) Traffic**" 버튼에서 캡처된 트래픽의 거친 뷰를 보거나 "**Start HTTPTools**" 녹색 버튼에서 더 깔끔한 뷰를 볼 수 있습니다. 두 번째 옵션에서는 캡처된 요청을 Burp나 Owasp ZAP 같은 **proxies**로 **보낼** 수 있습니다.\
방법: _Burp 전원 켜기 -->_ _Intercept 끄기 --> MobSB HTTPTools에서 요청 선택_ --> 버튼 "**Send to Fuzzer**" 클릭 --> _프록시 주소 선택_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF로 동적 분석을 마치면 "**Start Web API Fuzzer**"를 눌러 **fuzz http requests**를 실행하여 취약점을 찾을 수 있습니다.

> [!TIP]
> MobSF로 동적 분석을 수행한 후 프록시 설정이 잘못되어 GUI에서 수정할 수 없게 될 수 있습니다. 프록시 설정은 다음 명령으로 수정할 수 있습니다:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Inspeckage를 이용한 보조 동적 분석

도구는 [**Inspeckage**](https://github.com/ac-pm/Inspeckage)에서 얻을 수 있습니다.\
이 도구는 몇몇 **Hooks**를 사용하여 동적 분석을 수행하는 동안 애플리케이션에서 **무슨 일이 일어나고 있는지** 알려줍니다.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

GUI로 정적 분석을 수행하기에 **훌륭한 도구**입니다.

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

이 도구는 **source code** 또는 **packaged APKs**에서 여러 **security related Android application vulnerabilities**를 탐지하도록 설계되었습니다. 또한 발견된 일부 취약점(Exposed activities, intents, tapjacking...)을 악용하기 위한 "Proof-of-Concept" 배포 가능한 APK와 **ADB commands**를 **생성할 수 있습니다**. Drozer와 마찬가지로 테스트 기기를 루팅할 필요는 없습니다.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- 참조하기 쉽게 추출된 모든 파일을 표시합니다
- APK 파일을 자동으로 Java 및 Smali 형식으로 디컴파일합니다
- AndroidManifest.xml을 분석하여 일반적인 취약점 및 동작을 검사합니다
- 정적 소스 코드 분석을 통해 일반적인 취약점 및 동작을 확인합니다
- 장치 정보
- 그 외
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER는 Windows, MacOS X 및 Linux에서 사용할 수 있는 명령줄 애플리케이션으로, 취약점을 찾기 위해 _.apk_ 파일을 분석합니다. 이 작업은 APKs를 압축 해제하고 일련의 규칙을 적용하여 이러한 취약점을 탐지함으로써 수행됩니다.

모든 규칙은 `rules.json` 파일에 집중되어 있으며, 각 회사나 테스터는 필요한 분석을 위해 자체 규칙을 만들 수 있습니다.

최신 바이너리는 [download page](https://superanalyzer.rocks/download.html)에서 다운로드하세요.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn은 모바일 애플리케이션에 대해 [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis)를 수행하는 개발자, bugbounty hunters 및 ethical hackers를 돕는 **crossplatform** 도구입니다.

개념은 모바일 애플리케이션 파일(.apk 또는 .ipa 파일)을 StaCoAn 애플리케이션으로 드래그 앤 드롭하면 시각적이고 휴대 가능한 보고서를 생성해 준다는 것입니다. 설정과 wordlists를 조정하여 맞춤형 경험을 얻을 수 있습니다.

다운로드[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework는 Android 애플리케이션에서 개발자 또는 hackers가 잠재적인 보안 취약점을 찾도록 돕는 취약점 분석 시스템입니다.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**는 Android 애플리케이션에 의해 발생할 수 있는 잠재적 악성 동작을 탐지하고 사용자에게 경고하는 것을 주요 목적으로 하는 도구입니다.

탐지는 [`androguard`](https://github.com/androguard/androguard) 라이브러리를 사용해 애플리케이션의 Dalvik bytecode를 Smali로 표현한 것에 대한 **static analysis**로 수행됩니다.

이 도구는 **"bad" 애플리케이션의 일반적인 동작**을 다음과 같이 탐지합니다: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. 이 도구는 일반적으로 사용되는 mobile application reverse engineering and analysis tools들을 모아 OWASP mobile security threats에 대한 모바일 애플리케이션 테스트를 지원합니다. 목표는 모바일 애플리케이션 개발자와 보안 전문가들이 이 작업을 더 쉽고 친숙하게 수행할 수 있도록 돕는 것입니다.

It is able to:

- Extract Java and Smali code using different tools  
  다양한 도구를 사용해 Java 및 Smali 코드를 추출합니다.
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)  
  다음 도구들로 APK를 분석합니다:
- Extract private information from the APK using regexps.  
  regexps를 사용하여 APK에서 민감한 정보를 추출합니다.
- Analyze the Manifest.  
  Manifest를 분석합니다.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)  
  발견된 도메인을 다음 도구들로 분석합니다:
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)  
  [apk-deguard.com](http://www.apk-deguard.com)을 통해 APK 난독화를 해제합니다.

### Koodous

Useful to detect malware: [https://koodous.com/](https://koodous.com)

## Obfuscating/Deobfuscating code

사용하는 서비스와 구성에 따라 코드를 난독화할 때 비밀(Secrets)이 난독화되거나 그렇지 않을 수 있다는 점을 유의하세요.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is an open source command-line tool that shrinks, optimizes and obfuscates Java code. It is able to optimize bytecode as well as detect and remove unused instructions. ProGuard is free software and is distributed under the GNU General Public License, version 2.  
위키피디아에 따르면, **ProGuard**는 Java 코드를 축소(shrink), 최적화(optimize) 및 난독화(obfuscate)하는 오픈 소스 명령줄 도구입니다. 바이트코드(bytecode)를 최적화하고 사용되지 않는 명령어를 탐지하여 제거할 수 있습니다. ProGuard는 자유 소프트웨어이며 GNU General Public License 버전 2로 배포됩니다.

ProGuard is distributed as part of the Android SDK and runs when building the application in release mode.  
ProGuard는 Android SDK의 일부로 배포되며, 애플리케이션을 release 모드로 빌드할 때 실행됩니다.

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:  
(해당 가이드에 따르면) 마지막 확인 시점에서 DexGuard의 동작 방식은 다음과 같았습니다:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**  
**DeGuard는 Android 난독화 도구들이 수행한 난독화 과정을 역으로 수행합니다. 이를 통해 코드 검토나 라이브러리 예측 등 다양한 보안 분석이 가능해집니다.**

You can upload an obfuscated APK to their platform.  
난독화된 APK를 그들의 플랫폼에 업로드할 수 있습니다.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.  
이 도구는 android 앱의 잠재적 보안 취약점을 찾고 android 앱 코드를 deobfuscate하는 LLM 도구입니다. Google의 Gemini public API를 사용합니다.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.  
이는 **범용 android deobfuscator**입니다. Simplify는 애플리케이션을 **사실상 실행(virtually executes)** 하여 동작을 이해한 다음, 동일하게 동작하지만 사람이 이해하기 쉬운 형태로 코드의 **최적화(optimize)** 를 시도합니다. 각 최적화 유형은 단순하고 일반적이어서 특정 난독화 기법이 무엇인지와 상관없이 적용할 수 있습니다.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.  
APKiD는 **APK가 어떻게 만들어졌는지**에 대한 정보를 제공합니다. 많은 **compilers**, **packers**, **obfuscators** 등을 식별하며, Android용 [_PEiD_](https://www.aldeid.com/wiki/PEiD)와 같습니다.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)  
이 튜토리얼을 읽어 custom obfuscation을 **역으로 분석하는 방법**에 대한 몇 가지 팁을 배워보세요.

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is an Android security virtual machine based on ubuntu-mate includes the collection of latest framework, tutorials and labs from different security geeks and researchers for reverse engineering and malware analysis.  
AndroL4b는 ubuntu-mate 기반의 Android 보안 가상머신으로, 다양한 보안 연구자 및 리서처들의 최신 프레임워크, 튜토리얼 및 실습(labs)을 reverse engineering 및 malware analysis 목적으로 모아놓았습니다.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) It is a great list of resources  
  훌륭한 리소스 목록입니다.
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Yet to try

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
