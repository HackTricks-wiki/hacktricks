# Android Applications Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Applications बेसिक्स

It's highly recommended to start reading this page to know about the **most important parts related to Android security and the most dangerous components in an Android application**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

यह मुख्य टूल है जिसकी आपको एक android डिवाइस (emulated or physical) से कनेक्ट करने के लिए आवश्यकता होती है।\
**ADB** कंप्यूटर से डिवाइसेस को **USB** या **Network** के माध्यम से नियंत्रित करने की अनुमति देता है। यह उपयोगिता फाइलों की दोनों दिशाओं में **copying**, ऐप्स की **installation** और **uninstallation**, शेल कमांड के **execution**, डेटा का **backing up**, लॉग्स का **reading**, और अन्य कार्य सक्षम बनाती है।

ADB का उपयोग कैसे करना है यह जानने के लिए निम्नलिखित सूची [**ADB Commands**](adb-commands.md) देखें।

## Smali

कभी-कभी एप्लिकेशन कोड को मॉडिफाई करना रोचक होता है ताकि **hidden information** (शायद अच्छी तरह obfuscated पासवर्ड या flags) तक पहुँच बनाया जा सके। तब, apk को decompile करना, कोड संशोधित करना और उसे पुनः recompile करना उपयोगी हो सकता है।\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). यह dynamic analysis के दौरान किए जाने वाले कई परीक्षणों के लिए एक **alternative for several tests during the dynamic analysis** के रूप में बहुत उपयोगी हो सकता है। इसलिए, **हमेशा इस संभावना को ध्यान में रखें**।

## अन्य रोचक तरकीबें

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- [NFC/EMV Relay via HCE (Android Tap-to-Pay abuse)](android-hce-nfc-emv-relay-attacks.md)
- **Download APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Extract APK from device:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- सभी splits और base apks को [APKEditor](https://github.com/REAndroid/APKEditor) के साथ मर्ज करें:
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Android Enterprise & Work Profile Attacks

{{#ref}}
android-enterprise-work-profile-bypass.md
{{#endref}}

## Case Studies & Vulnerabilities


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Static Analysis

सबसे पहले, एक APK का विश्लेषण करने के लिए आपको decompiler का उपयोग करके Java code देखना चाहिए।\
कृपया, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Looking for interesting Info

APK की **strings** को देखकर आप **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** और किसी भी रोचक चीज़ की तलाश कर सकते हैं... यहाँ तक कि code execution **backdoors** या authentication backdoors (app में hardcoded admin credentials) भी ढूँढें।

**Firebase**

Firebase URLs पर विशेष ध्यान दें और जांचें कि क्या यह गलत कॉन्फ़िगर है। [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basic understanding of the application - Manifest.xml, strings.xml

एक ऐप के _Manifest.xml_ और _strings.xml_ फ़ाइलों की जांच संभावित security vulnerabilities का पता लगा सकती है। इन फ़ाइलों को decompiler के माध्यम से एक्सेस किया जा सकता है या APK की file extension को .zip में बदलकर unzip किया जा सकता है।

**Manifest.xml** से पहचान की जाने वाली कमजोरियों में शामिल हैं:

- **Debuggable Applications**: _Manifest.xml_ फ़ाइल में debuggable (`debuggable="true"`) के रूप में सेट अनुप्रयोग जोखिम पैदा करते हैं क्योंकि वे ऐसे connections की अनुमति देते हैं जो exploitation तक ले जा सकते हैं। debuggable applications को exploit करने के तरीके समझने के लिए, डिवाइस पर debuggable applications ढूँढने और exploit करने वाले tutorial को देखें।
- **Backup Settings**: संवेदनशील जानकारी संभालने वाले ऐप्स के लिए `android:allowBackup="false"` attribute को स्पष्ट रूप से सेट किया जाना चाहिए ताकि adb के माध्यम से unauthorized data backups रोके जा सकें, विशेषकर जब usb debugging enabled हो।
- **Network Security**: कस्टम network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) _res/xml/_ में certificate pins और HTTP traffic settings जैसी security details specify कर सकते हैं। एक उदाहरण कुछ specific domains के लिए HTTP traffic की अनुमति देना है।
- **Exported Activities and Services**: manifest में exported activities और services की पहचान उन components को उजागर कर सकती है जिन्हें misuse किया जा सकता है। dynamic testing के दौरान आगे की analysis यह बताएगी कि इन components को कैसे exploit किया जा सकता है।
- **Content Providers and FileProviders**: exposed content providers unauthorized access या data modification की अनुमति दे सकते हैं। FileProviders की configuration की भी जांच करनी चाहिए।
- **Broadcast Receivers and URL Schemes**: ये components exploitation के लिए उपयोग में लाए जा सकते हैं, विशेषकर यह देखने के लिए कि URL schemes input vulnerabilities के लिए कैसे manage की जाती हैं।
- **SDK Versions**: `minSdkVersion`, `targetSDKVersion`, और `maxSdkVersion` attributes supported Android versions को दर्शाते हैं, और सुरक्षा कारणों से outdated या vulnerable Android versions का समर्थन न करने का महत्व उजागर करते हैं।

**strings.xml** फ़ाइल से API keys, custom schemas, और अन्य developer notes जैसी संवेदनशील जानकारी मिल सकती है, जो इन resources की सावधानीपूर्वक समीक्षा की आवश्यकता को रेखांकित करती है।

### Tapjacking

Tapjacking एक attack है जहाँ एक malicious application लॉन्च होती है और victim application के ऊपर स्वयं को स्थित कर लेती है। जब यह victim app को दृश्य रूप से ढक देता है, तो इसका user interface इस तरह डिज़ाइन किया जाता है कि उपयोगकर्ता को interaction करने के लिए धोखा दे, जबकि यह उस interaction को victim app तक पास कर देता है। प्रभावतः यह उपयोगकर्ता को अँधा कर देता है कि वे वास्तव में victim app पर ही actions कर रहे हैं।

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

एक activity जिसका `launchMode` `singleTask` पर सेट है और किसी भी `taskAffinity` से परिभाषित नहीं है, वह task Hijacking के लिए vulnerable होता है। इसका मतलब है कि एक application install की जा सकती है और यदि वह असली application से पहले लॉन्च की जाए तो यह असली application के task को hijack कर सकती है (जिससे user सोचता है कि वह असली ऐप उपयोग कर रहा है जबकि वह malicious application के साथ इंटरैक्ट कर रहा है)।

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Insecure data storage

**Internal Storage**

Android में, internal storage में stored फाइलें उन्हीं apps के लिए सुलभ होने के लिए डिज़ाइन की गई हैं जिन्होंने उन्हें बनाया है। यह सुरक्षा उपाय Android operating system द्वारा लागू किया जाता है और अधिकांश applications की सुरक्षा आवश्यकताओं के लिए सामान्यतः पर्याप्त होता है। हालांकि, developers कभी-कभी `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` जैसे modes का उपयोग करते हैं ताकि फाइलें विभिन्न applications के बीच साझा की जा सकें। फिर भी, ये modes इन फाइलों तक अन्य applications सहित संभाव्य malicious ones द्वारा पहुंच को प्रतिबंधित नहीं करते।

1. **Static Analysis:**
- सुनिश्चित करें कि `MODE_WORLD_READABLE` और `MODE_WORLD_WRITABLE` के उपयोग की सावधानीपूर्वक जांच हो। ये modes फाइलों को अनपेक्षित या unauthorized access के लिए उजागर कर सकते हैं।
2. **Dynamic Analysis:**
- ऐप द्वारा बनाए गए फाइलों पर सेट permissions की पुष्टि करें। विशेष रूप से, जांचें कि क्या किसी फाइल को worldwide readable या writable के रूप में सेट किया गया है। यह एक महत्वपूर्ण security risk हो सकता है, क्योंकि इससे किसी भी application को, उसके स्रोत या उद्देश्य की परवाह किए बिना, इन फाइलों को पढ़ने या संशोधित करने की अनुमति मिल सकती है।

**External Storage**

External storage जैसे SD Cards पर फाइलों के मामले में कुछ सावधानियां बरतनी चाहिए:

1. **Accessibility**:
- External storage पर फाइलें globally readable और writable होती हैं। इसका अर्थ है कि कोई भी application या user इन फाइलों तक पहुंच सकता है।
2. **Security Concerns**:
- इतनी आसान पहुँच के कारण, संवेदनशील जानकारी को external storage पर स्टोर न करने की सलाह दी जाती है।
- External storage हटाई जा सकती है या किसी भी application द्वारा access की जा सकती है, जिससे यह कम सुरक्षित बन जाता है।
3. **Handling Data from External Storage**:
- External storage से प्राप्त डेटा पर हमेशा input validation करें। यह महत्वपूर्ण है क्योंकि यह डेटा एक untrusted स्रोत से आता है।
- External storage पर executables या class files को dynamic loading के लिए रखना सख्ती से हतोत्साहित है।
- यदि आपका एप्लिकेशन external storage से executable files प्राप्त करता है, तो सुनिश्चित करें कि ये फाइलें signed और cryptographically verified हों इससे पहले कि उन्हें dynamically load किया जाए। यह कदम आपके एप्लिकेशन की सुरक्षा अखंडता बनाए रखने के लिए आवश्यक है।

External storage को `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` में access किया जा सकता है

> [!TIP]
> Android 4.4 (**API 17**) से शुरू होकर, SD card में एक directory structure है जो किसी app से उस directory तक ही access सीमित करता है जो विशेष रूप से उस app के लिए है। यह किसी malicious application को दूसरे app की फाइलों तक पढ़ने या लिखने की पहुँच पाने से रोकता है।

**Sensitive data stored in clear-text**

- **Shared preferences**: Android प्रत्येक application को आसानी से xml फ़ाइलें `/data/data/<packagename>/shared_prefs/` पथ में सहेजने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।
- **Databases**: Android प्रत्येक application को आसानी से sqlite databases `/data/data/<packagename>/databases/` पथ में सहेजने की अनुमति देता है और कभी-कभी उस फ़ोल्डर में clear-text में संवेदनशील जानकारी मिल सकती है।

### Broken TLS

**Accept All Certificates**

कभी-कभी developers किसी कारण से सभी certificates को स्वीकार कर लेते हैं, भले ही उदाहरण के लिए hostname मेल न खाता हो, नीचे जैसा कोड होने पर:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### टूटी हुई क्रिप्टोग्राफी

**Poor Key Management Processes**

कुछ developers संवेदनशील डेटा को local storage में सेव करते हैं और उसे code में hardcoded/predictable key से encrypt करते हैं। यह नहीं करना चाहिए क्योंकि कुछ reversing से attackers confidential जानकारी extract कर सकते हैं।

**Use of Insecure and/or Deprecated Algorithms**

Developers को **deprecated algorithms** का प्रयोग authorization **checks**, **store** या **send** data के लिए नहीं करना चाहिए। इन algorithms में कुछ हैं: RC4, MD4, MD5, SHA1... अगर **hashes** का उपयोग passwords को store करने के लिए किया जा रहा है, तो salt के साथ brute-force **resistant** hashes का उपयोग करना चाहिए।

### अन्य जांचें

- यह recommend किया जाता है कि APK को **obfuscate** किया जाए ताकि attackers के लिए reverse engineer का काम कठिन हो।
- अगर app sensitive है (जैसे bank apps), तो उसे अपने **own checks to see if the mobile is rooted** करने चाहिए और उसके अनुसार कार्रवाई करनी चाहिए।
- अगर app sensitive है (जैसे bank apps), तो उसे यह जाँचना चाहिए कि कोई **emulator** इस्तेमाल हो रहा है या नहीं।
- अगर app sensitive है (जैसे bank apps), तो उसे **check it's own integrity before executing** करना चाहिए ताकि पता चल सके कि उसे modify किया गया है या नहीं।
- Use [**APKiD**](https://github.com/rednaga/APKiD) to check which compiler/packer/obfuscator was used to build the APK

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

According to this [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked is a Meta algorithm that compress the content of an application into a single file. The blog talks about the possibility of creating an app that decompress these kind of apps... and a faster way which involves to **execute the application and gather the decompressed files from the filesystem.**

### Automated Static Code Analysis

The tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is capable of finding **vulnerabilities** by **scanning** the **code** of the application. This tool contains a series of **known sources** (that indicates to the tool the **places** where the **input** is **controlled by the user**), **sinks** (which indicates to the tool **dangerous** **places** where malicious user input could cause damages) and **rules**. These rules indicates the **combination** of **sources-sinks** that indicates a vulnerability.

With this knowledge, **mariana-trench will review the code and find possible vulnerabilities on it**.

### Secrets leaked

An application may contain secrets (API keys, passwords, hidden urls, subdomains...) inside of it that you might be able to discover. You could us a tool such as [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Other interesting functions

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)
- In-memory native code execution via JNI (downloaded shellcode → mmap/mprotect → call):

{{#ref}}
in-memory-jni-shellcode-execution.md
{{#endref}}

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> First of all, you need an environment where you can install the application and all the environment (Burp CA cert, Drozer and Frida mainly). Therefore, a rooted device (emulated or not) is extremely recommended.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Local Dynamic Analysis

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> When creating a new emulator on any platform remember that the bigger the screen is, the slower the emulator will run. So select small screens if possible.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Use a physical device

You need to activate the **debugging** options and it will be cool if you can **root** it:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Once you have installed the application, the first thing you should do is to try it and investigate what does it do, how does it work and get comfortable with it.\
> I will suggest to **perform this initial dynamic analysis using MobSF dynamic analysis + pidcat**, so we will be able to **learn how the application works** while MobSF **captures** a lot of **interesting** **data** you can review later on.

Magisk/Zygisk quick notes (recommended on Pixel devices)
- Patch boot.img with the Magisk app and flash via fastboot to get systemless root
- Enable Zygisk + DenyList for root hiding; consider LSPosed/Shamiko when stronger hiding is required
- Keep original boot.img to recover from OTA updates; re-patch after each OTA
- For screen mirroring, use scrcpy on the host



### Unintended Data Leakage

**Logging**

Developers को सावधान रहना चाहिए कि वे **debugging information** को सार्वजनिक रूप से expose न करें, क्योंकि इससे संवेदनशील डेटा leaks हो सकते हैं। tools [**pidcat**](https://github.com/JakeWharton/pidcat) और `adb logcat` application logs को monitor करने के लिए recommend किए जाते हैं ताकि संवेदनशील जानकारी की पहचान कर उसे protect किया जा सके। **Pidcat** अपनी सहजता और readability के लिए पसंद किया जाता है।

> [!WARNING]
> Note that from **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android का **clipboard-based** framework apps में copy-paste functionality सक्षम करता है, फिर भी यह जोखिम पैदा करता है क्योंकि **other applications** clipboard को **access** कर सकती हैं, जिससे संवेदनशील डेटा expose हो सकता है। इसलिए application के sensitive sections, जैसे credit card details, के लिए copy/paste functions को disable करना बहुत महत्वपूर्ण है ताकि data leaks न हों।

**Crash Logs**

अगर कोई application **crashes** करती है और logs save करती है, तो ये logs attackers की मदद कर सकते हैं, खासकर जब application reverse-engineer नहीं की जा सकती। इस जोखिम को कम करने के लिए, crashes पर logging से बचें, और अगर logs को network पर भेजना ही हो तो सुनिश्चित करें कि वे SSL चैनल के माध्यम से भेजे जाएँ।

As pentester, **try to take a look to these logs**.

**Analytics Data Sent To 3rd Parties**

Applications अक्सर services जैसे Google Adsense integrate करते हैं, जो developers के गलत implementation के कारण गलती से संवेदनशील डेटा को **leak** कर सकते हैं। संभावित data leaks की पहचान के लिए, यह सलाह दी जाती है कि आप application's traffic को intercept करें और जांचें कि किसी third-party service को कोई संवेदनशील जानकारी तो नहीं भेजी जा रही है।

### SQLite DBs

Most of the applications will use **internal SQLite databases** to save information. During the pentest take a **look** to the **databases** created, the names of **tables** and **columns** and all the **data** saved because you could find **sensitive information** (which would be a vulnerability).\
Databases should be located in `/data/data/the.package.name/databases` like `/data/data/com.mwr.example.sieve/databases`

If the database is saving confidential information and is **encrypted b**ut you can **find** the **password** inside the application it's still a **vulnerability**.

Enumerate the tables using `.tables` and enumerate the columns of the tables doing `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is s useful tool to **exploit exported activities, exported services and Content Providers** as you will learn in the following sections.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Also remember that the code of an activity starts in the **`onCreate`** method.

**Authorisation bypass**

When an Activity is exported you can invoke its screen from an external app. Therefore, if an activity with **sensitive information** is **exported** you could **bypass** the **authentication** mechanisms **to access it.**

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**नोट**: MobSF किसी activity में `android:launchMode` के रूप में _**singleTask/singleInstance**_ के उपयोग को हानिकारक के रूप में पहचानता है, लेकिन [this](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750) के कारण ऐसा प्रतीत होता है कि यह केवल पुराने संस्करणों (API versions < 21) में खतरनाक है।

> [!TIP]
> ध्यान दें कि authorisation bypass हमेशा vulnerability नहीं होता; यह इस बात पर निर्भर करेगा कि bypass कैसे काम करता है और कौन सी जानकारी expose होती है।

**संवेदनशील जानकारी leakage**

**Activities भी results वापस कर सकती हैं**. यदि आप कोई exported और unprotected activity खोजते हैं जो **`setResult`** method को कॉल कर रही हो और **returning sensitive information**, तो यह एक sensitive information leakage है।

#### Tapjacking

यदि Tapjacking रोका नहीं गया है, तो आप exported activity का दुरुपयोग कर सकते हैं ताकि **user अप्रत्याशित क्रियाएँ** कर दे। For more info about [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Read this if you want to refresh what is a Content Provider.**](android-applications-basics.md#content-provider)\
Content providers मूल रूप से **share data** के लिए उपयोग होते हैं। यदि किसी ऐप में content providers उपलब्ध हैं तो आप उनसे **extract sensitive** data कर सकते हैं। यह भी महत्वपूर्ण है कि संभावित **SQL injections** और **Path Traversals** का परीक्षण किया जाए क्योंकि वे vulnerable हो सकते हैं।

[**Learn how to exploit Content Providers with Drozer.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Read this if you want to refresh what is a Service.**](android-applications-basics.md#services)\
ध्यान रखें कि Service की कार्रवाइयाँ method `onStartCommand` में शुरू होती हैं।

Service मूल रूप से ऐसा component है जो **can receive data**, उसे **process** करता है और **returns** (या नहीं) एक response। इसलिए, यदि कोई application कुछ services export कर रहा है तो आपको यह समझने के लिए **check** करना चाहिए कि इसका code क्या कर रहा है और confidential info निकालने, authentication measures को bypass करने आदि के लिए इसे **dynamically** **test** करना चाहिए।\
[**Learn how to exploit Services with Drozer.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Read this if you want to refresh what is a Broadcast Receiver.**](android-applications-basics.md#broadcast-receivers)\
ध्यान रखें कि Broadcast Receiver की कार्रवाइयाँ method `onReceive` में शुरू होती हैं।

एक broadcast receiver किसी प्रकार के message के लिए इंतजार करेगा। यह इस बात पर निर्भर करेगा कि receiver message को कैसे handle करता है — उसके आधार पर यह vulnerable हो सकता है।\
[**Learn how to exploit Broadcast Receivers with Drozer.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

आप deep links मैन्युअली खोज सकते हैं, MobSF जैसे tools या [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py) जैसे scripts का उपयोग कर के।\
आप घोषित **scheme** को **adb** या **browser** का उपयोग करके **open** कर सकते हैं:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_ध्यान दें कि आप **पैकेज नाम छोड़ सकते हैं** और मोबाइल स्वचालित रूप से उस ऐप को कॉल करेगा जो उस लिंक को खोलना चाहिए._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Code executed**

ऐप में निष्पादित होने वाले कोड को खोजने के लिए, उस activity में जाएँ जिसे deeplink कॉल करता है और function **`onNewIntent`** खोजें।

![](<../../images/image (436) (1) (1) (1).png>)

**संवेदनशील जानकारी**

हर बार जब आप कोई deep link पाते हैं, तो यह सुनिश्चित करें कि **यह URL parameters के माध्यम से संवेदनशील डेटा (जैसे passwords) प्राप्त न कर रहा हो**, क्योंकि कोई अन्य application उस deep link को **impersonate** करके उन डेटा को चुरा सकती है!

**Parameters in path**

आपको यह भी जांचना चाहिए कि क्या कोई deep link URL के path के अंदर parameter का उपयोग कर रहा है, जैसे: `https://api.example.com/v1/users/{username}` , ऐसे मामले में आप path traversal का प्रयोग कर सकते हैं और कुछ इस तरह ऐक्सेस कर सकते हैं: `example://app/users?username=../../unwanted-endpoint%3fparam=value` .\
ध्यान दें कि यदि आप application के अंदर सही endpoints पा लेते हैं तो आप **Open Redirect** (यदि path का हिस्सा domain name के रूप में इस्तेमाल हो रहा हो), **account takeover** (यदि आप CSRF token के बिना users details बदल सकते हैं और vuln endpoint ने सही method उपयोग किया था) और अन्य किसी भी vuln का कारण बन सकते हैं। More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

An [interesting bug bounty report](https://hackerone.com/reports/855618) about links (_/.well-known/assetlinks.json_).

### Transport Layer निरीक्षण और सत्यापन की विफलताएँ

- **Certificates are not always inspected properly** by Android applications. अक्सर इन applications में warnings को नज़रअंदाज़ कर दिया जाता है और self-signed certificates स्वीकार कर लिए जाते हैं या कभी-कभी HTTP कनेक्शन पर revert कर दिए जाते हैं।
- **Negotiations during the SSL/TLS handshake are sometimes weak**, insecure cipher suites का उपयोग होता है। यह कमजोरियाँ connection को man-in-the-middle (MITM) हमलों के प्रति संवेदनशील बनाती हैं, जिससे attackers डेटा को decrypt कर सकते हैं।
- **Leakage of private information** एक जोखिम है जब applications secure channels का उपयोग करके authenticate करती हैं लेकिन अन्य transactions के लिए non-secure channels पर communicate करती हैं। यह दृष्टिकोण session cookies या user details जैसे संवेदनशील डेटा को malicious entities द्वारा interception से सुरक्षित नहीं रखता।

#### Certificate Verification

हम यहाँ **certificate verification** पर ध्यान देंगे। सर्वर के certificate की integrity को verify करना सुरक्षा बढ़ाने के लिए आवश्यक है। यह इसलिए भी महत्वपूर्ण है क्योंकि insecure TLS configurations और unencrypted चैनलों पर संवेदनशील डेटा का ट्रांसमिशन गंभीर जोखिम पैदा कर सकता है। सर्वर certificates को verify करने और कमजोरियों को संबोधित करने के विस्तृत कदमों के लिए, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) व्यापक मार्गदर्शन प्रदान करता है।

#### SSL Pinning

SSL Pinning एक सुरक्षा उपाय है जहाँ application सर्वर के certificate की जाँच application के अंदर स्टोर की गई ज्ञात copy के खिलाफ करती है। यह MITM attacks को रोकने के लिए आवश्यक है। संवेदनशील जानकारी संभालने वाली applications के लिए SSL Pinning लागू करने की दृढ़ सिफारिश की जाती है।

#### Traffic Inspection

HTTP ट्रैफिक का निरीक्षण करने के लिए proxy tool का certificate (e.g., Burp) इंस्टॉल करना आवश्यक है। बिना इस certificate को इंस्टॉल किए, encrypted ट्रैफिक proxy के माध्यम से दिखाई नहीं दे सकता। custom CA certificate इंस्टॉल करने के लिए गाइड के लिए [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Applications targeting **API Level 24 and above** require modifications to the Network Security Config to accept the proxy's CA certificate. यह कदम encrypted ट्रैफिक की inspection के लिए महत्वपूर्ण है। Network Security Config संशोधित करने के निर्देशों के लिए, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

यदि **Flutter** उपयोग हो रहा है तो आपको [**this page**](flutter.md) में दिए निर्देशों का पालन करना होगा। ऐसा इसलिए है क्योंकि केवल certificate को store में जोड़ना पर्याप्त नहीं होगा — Flutter की अपनी valid CAs की सूची होती है।

#### Static detection of SSL/TLS pinning

runtime bypasses करने से पहले, तेज़ी से मैप करें कि APK में pinning कहाँ लागू है। static discovery आपको hooks/patches की योजना बनाने और सही code paths पर ध्यान केंद्रित करने में मदद करता है।

Tool: SSLPinDetect
- Open-source static-analysis utility जो APK को Smali (via apktool) में decompile करता है और SSL/TLS pinning implementations के curated regex patterns के लिए scan करता है।
- प्रत्येक मैच के लिए exact file path, line number, और code snippet रिपोर्ट करता है।
- सामान्य frameworks और custom code paths को कवर करता है: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, और Network Security Config XML pins।

Install
- Prereqs: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
उपयोग
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
उदाहरण पैटर्न नियम (JSON)
proprietary/custom pinning styles का पता लगाने के लिए signatures का उपयोग करें या इन्हें बढ़ाएँ। आप अपनी खुद की JSON लोड कर सकते हैं और बड़े पैमाने पर scan कर सकते हैं।
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notes and tips
- बड़े ऐप्स पर तेज़ स्कैनिंग के लिए मल्टी-थ्रेडिंग और memory-mapped I/O का उपयोग; पूर्व-कम्पाइल्ड regex ओवरहेड/false positives को कम करता है।
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- अगले चरण में प्राथमिकता देकर जांच करने के लिए आम डिटेक्शन लक्ष्य:
- OkHttp: CertificatePinner के उपयोग, setCertificatePinner, okhttp3/okhttp पैकेज संदर्भ
- Custom TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Custom SSL contexts: SSLContext.getInstance + SSLContext.init कस्टम managers के साथ
- Declarative pins in res/xml network security config और manifest संदर्भ
- मैच किए गए लोकेशन्स का उपयोग Frida hooks, static patches, या config reviews की योजना बनाने के लिए करें, dynamic testing से पहले।


#### SSL Pinning को बायपास करना

जब SSL Pinning लागू किया गया हो, तो HTTPS ट्रैफ़िक की जाँच करने के लिए इसे बायपास करना ज़रूरी हो जाता है। इस उद्देश्य के लिए विभिन्न तरीके उपलब्ध हैं:

- ऑटोमेटिकली **modify** करके **apk** को **bypass** करें SSLPinning के साथ [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)। इस विकल्प का सबसे बड़ा फायदा यह है कि SSL Pinning को बायपास करने के लिए आपको root की आवश्यकता नहीं होगी, पर आपको एप्लिकेशन को हटाकर नया इंस्टॉल करना होगा, और यह हमेशा काम नहीं करेगा।
- आप इस सुरक्षा को बायपास करने के लिए **Frida** (नीचे चर्चा) का उपयोग कर सकते हैं। यहाँ Burp+Frida+Genymotion उपयोग करने का गाइड है: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- आप ऑटोमैटिकली **SSL Pinning बायपास** करने की कोशिश कर सकते हैं [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- आप MobSF dynamic analysis का उपयोग करके भी ऑटोमैटिकली **SSL Pinning बायपास** करने की कोशिश कर सकते हैं (नीचे समझाया गया है)
- यदि आपको अभी भी लगता है कि कुछ ट्रैफ़िक आप कैप्चर नहीं कर रहे हैं तो आप iptables का उपयोग करके ट्रैफ़िक को burp की तरफ फॉरवर्ड करने की कोशिश कर सकते हैं। इस ब्लॉग को पढ़ें: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### सामान्य वेब Vulnerabilities की तलाश

ऐप्लिकेशन के भीतर सामान्य वेब vulnerabilities की खोज भी महत्वपूर्ण है। इन vulnerabilities की पहचान और उन्हें मिटाने की विस्तृत जानकारी इस सारांश के दायरे से बाहर है, पर अन्य जगहों पर व्यापक रूप से कवर किया गया है।

### Frida

[Frida](https://www.frida.re) developers, reverse-engineers, और security researchers के लिए एक डायनामिक इंस्ट्रुमेंटेशन टूलकिट है।\
**आप रनिंग application तक पहुँच सकते हैं और रन-टाइम पर methods को hook करके व्यवहार बदल सकते हैं, मान बदल सकते हैं, मान निकाल सकते हैं, अलग कोड चला सकते हैं...**\
यदि आप Android applications का pentest करना चाहते हैं तो आपको Frida का उपयोग करना आना चाहिए।

- Frida कैसे उपयोग करें सीखें: [**Frida tutorial**](frida-tutorial/index.html)
- Frida के साथ actions के लिए कुछ "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection Frida के उपयोग को ऑटोमेट करने के लिए बढ़िया है: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- आप कुछ Awesome Frida scripts यहाँ पा सकते हैं: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Frida को load करके anti-debugging / anti-frida mechanisms को बायपास करने की कोशिश करें जैसा कि [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) में बताया गया है (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Memory - Fridump**

जाँचें कि क्या एप्लिकेशन मेमोरी में संवेदनशील जानकारी स्टोर कर रहा है जो उसे स्टोर नहीं करनी चाहिए, जैसे passwords या mnemonics।

Fridump3 का उपयोग करके आप ऐप की मेमोरी को इस तरह डंप कर सकते हैं:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
यह ./dump फ़ोल्डर में memory को dump करेगा, और वहाँ आप कुछ इस तरह grep कर सकते हैं:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore में संवेदनशील डेटा**

Android में Keystore संवेदनशील डेटा स्टोर करने के लिए सबसे अच्छा स्थान है, हालांकि पर्याप्त privileges होने पर यह फिर भी **इसे एक्सेस करना संभव है**। चूंकि applications यहाँ अक्सर **संवेदनशील डेटा clear text में** स्टोर करते हैं, pentests को root user के रूप में इसकी जांच करनी चाहिए, क्योंकि डिवाइस तक भौतिक पहुँच रखने वाला कोई व्यक्ति यह डेटा चुरा सकता है।

भले ही किसी app ने keystore में डेटा स्टोर किया हो, उस डेटा को एन्क्रिप्ट किया जाना चाहिए।

keystore के अंदर के डेटा तक पहुँचने के लिए आप यह Frida script उपयोग कर सकते हैं: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

निम्नलिखित Frida script का उपयोग करके संभवतः Android applications द्वारा कुछ संवेदनशील क्षेत्रों की सुरक्षा के लिए लागू की जा रही **bypass fingerprint authentication** को बेअसर किया जा सकता है:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **बैकग्राउंड इमेजेज़**

जब आप किसी ऐप्लिकेशन को बैकग्राउंड में डालते हैं, Android एक **ऐप्लिकेशन का स्नैपशॉट** संग्रहीत करता है ताकि जब इसे फ़ोरग्राउंड में वापस लाया जाए तो यह ऐप से पहले उस इमेज को लोड करना शुरू कर दे और ऐसा लगे कि ऐप तेज़ी से लोड हुआ।

हालाँकि, अगर इस स्नैपशॉट में **संवेदनशील जानकारी** हो, तो स्नैपशॉट तक पहुँच रखने वाला कोई व्यक्ति वह जानकारी **चुरा** सकता है (ध्यान दें कि इसे access करने के लिए आपको root की आवश्यकता होती है)।

Snapshots आमतौर पर यहाँ स्टोर होते हैं: **`/data/system_ce/0/snapshots`**

Android एक तरीका प्रदान करता है जिससे आप **FLAG_SECURE सेट करके स्क्रीनशॉट कैप्चर को रोक** सकते हैं। इस flag का उपयोग करने पर, विंडो की सामग्री को सुरक्षित माना जाता है, जिससे यह स्क्रीनशॉट्स में दिखाई देने या गैर-सुरक्षित डिस्प्ले पर देखे जाने से रोका जाता है।
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

यह टूल dynamic analysis के दौरान विभिन्न टूल्स को मैनेज करने में मदद कर सकता है: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Developers अक्सर activities, services, और broadcast receivers जैसे proxy components बनाते हैं जो इन Intents को हैंडल करके `startActivity(...)` या `sendBroadcast(...)` जैसे methods को पास करते हैं — जो risk हो सकता है।

खतरा इस बात में है कि attackers इन Intents को misdirect करके non-exported app components या sensitive content providers को trigger कर सकते हैं। एक उदाहरण यह है कि `WebView` component URLs को `Intent` objects में `Intent.parseUri(...)` के माध्यम से बदलता है और फिर उन्हें execute करता है, जिससे malicious Intent injections संभव हो सकते हैं।

### Essential Takeaways

- **Intent Injection** web के Open Redirect issue के समान है।
- Exploits में `Intent` objects को extras के रूप में पास करना शामिल है, जिन्हें unsafe operations execute करने के लिए redirect किया जा सकता है।
- यह attackers के लिए non-exported components और content providers को एक्सपोज़ कर सकता है।
- `WebView` का URL से `Intent` conversion अनचाहे actions के लिए मार्ग प्रदान कर सकता है।

### Android Client Side Injections and others

शायद आप Web से इस तरह की vulnerabilities के बारे में जानते हैं। Android application में इन vulnerabilities के साथ खास सावधानी बरतनी चाहिए:

- **SQL Injection:** जब dynamic queries या Content-Providers के साथ काम कर रहे हों तो सुनिश्चित करें कि आप parameterized queries का उपयोग कर रहे हैं।
- **JavaScript Injection (XSS):** Verify करें कि JavaScript और Plugin support किसी भी WebViews के लिए disabled हैं (disabled by default)। [More info here](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews को file system का access disabled होना चाहिए (enabled by default) - `(webview.getSettings().setAllowFileAccess(false);)`. [More info here](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: कई मामलों में जब android application session खत्म करता है तो cookie revoke नहीं होती या वह disk पर भी सेव हो सकती है।
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Vulnerability assessment of the application** एक अच्छे web-based frontend के माध्यम से। आप dynamic analysis भी कर सकते हैं (लेकिन इसके लिए environment तैयार करना होगा)।
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Assisted Dynamic analysis with MobSF

**MobSF** Android में **dynamic analysis** के लिए भी अत्यंत उपयोगी हो सकता है, लेकिन इस केस में आपको अपने host पर MobSF और **genymotion** इंस्टॉल करना होगा (एक VM या Docker काम नहीं करेगा)। _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
The **MobSF dynamic analyser** कर सकता है:

- **Dump application data** (URLs, logs, clipboard, आपके द्वारा लिए गए screenshots, "**Exported Activity Tester**" द्वारा लिए गए screenshots, emails, SQLite databases, XML files, और अन्य बनाए गए फाइलें)। यह सब स्वतः किया जाता है सिवाय screenshots के — screenshots के लिए आपको जब चाहें तब screenshot बटन दबाना होगा या सभी exported activities के screenshots पाने के लिए आपको "**Exported Activity Tester**" दबाना होगा।
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: यह सभी loaded classes को प्रिंट करेगा
- **Capture Strings**: application के उपयोग के दौरान सभी पकड़ी गई strings को प्रिंट करेगा (बहुत noisy)
- **Capture String Comparisons**: बहुत उपयोगी हो सकता है। यह **दोनों strings जिन्हें compare किया जा रहा है** दिखाएगा और यह भी बताएगा कि परिणाम True था या False।
- **Enumerate Class Methods**: क्लास का नाम डालें (जैसे "java.io.File") और यह उस क्लास के सभी methods प्रिंट कर देगा।
- **Search Class Pattern**: pattern द्वारा classes खोजें
- **Trace Class Methods**: किसी **पूरी class** को **Trace** करें (क्लास के सभी methods के inputs और outputs देखें)। याद रखें कि डिफ़ॉल्ट रूप से MobSF कई रोचक Android API methods को trace करता है।

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf आपको एक shell भी देता है जिसमें कुछ **adb** commands, **MobSF commands**, और सामान्य **shell** **commands** होते हैं जो dynamic analysis पेज के नीचे मिलते हैं। कुछ रोचक commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP टूल्स**

जब HTTP ट्रैफ़िक कैप्चर होता है आप कैप्चर किए गए ट्रैफ़िक का एक खराब दृश्य "**HTTP(S) Traffic**" बटन पर या एक बेहतर दृश्य "**Start HTTPTools**" हरे बटन में देख सकते हैं। दूसरे विकल्प से, आप **captured requests** को Burp या Owasp ZAP जैसे **proxies** को **send** कर सकते हैं.\
इसके लिए, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> दबाएँ "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF के साथ dynamic analysis खत्म करने के बाद आप "**Start Web API Fuzzer**" दबाकर **fuzz http requests** कर सकते हैं और vulnerabilities ढूंढ सकते हैं।

> [!TIP]
> MobSF के साथ dynamic analysis करने के बाद proxy settings गलत कॉन्फ़िगर हो सकती हैं और आप GUI से उन्हें ठीक नहीं कर पाएंगे। आप proxy settings को इस कमांड से ठीक कर सकते हैं:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

You can get the tool from [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
यह tool कुछ **Hooks** का उपयोग करता है ताकि जब आप **dynamic analysis** कर रहे हों तो यह आपको **what is happening in the application** बताए।

### [Yaazhini](https://www.vegabird.com/yaazhini/)

यह एक **great tool to perform static analysis with a GUI** है

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

यह tool कई प्रकार की **security related Android application vulnerabilities** खोजने के लिए बनाया गया है, चाहे वे **source code** में हों या **packaged APKs** में। यह tool कुछ मिले हुए vulnerabilities (Exposed activities, intents, tapjacking...) का फायदा उठाने के लिए **"Proof-of-Concept" deployable APK** और **ADB commands** बनाने में भी सक्षम है। Drozer की तरह, test device को root करने की आवश्यकता नहीं है।
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- संदर्भ के लिए सभी निकाली गई फ़ाइलें दिखाता है
- APK फ़ाइलों को स्वतः Java और Smali फॉर्मेट में decompile करता है
- AndroidManifest.xml का विश्लेषण सामान्य vulnerabilities और व्यवहार के लिए करता है
- Static source code analysis — सामान्य vulnerabilities और व्यवहार के लिए
- डिवाइस जानकारी
- और भी बहुत कुछ
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER एक command-line application है जिसे Windows, MacOS X और Linux पर इस्तेमाल किया जा सकता है, जो _.apk_ फ़ाइलों का विश्लेषण करके कमजोरियों की तलाश करता है। यह APKs को डिकम्प्रेस करके और उन कमजोरियों का पता लगाने के लिए नियमों की एक श्रृंखला लागू करके यह करता है।

सभी नियम `rules.json` फ़ाइल में केंद्रीकृत हैं, और हर कंपनी या tester अपनी ज़रूरत के अनुसार विश्लेषण करने के लिए अपने स्वयं के नियम बना सकती है।

नवीनतम binaries डाउनलोड करने के लिए [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn एक **crossplatform** टूल है जो developers, bugbounty hunters और ethical hackers को mobile applications पर [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) करने में मदद करता है।

विचार यह है कि आप अपनी mobile application फ़ाइल (.apk या .ipa फ़ाइल) को StaCoAn application पर drag and drop करें और यह आपके लिए एक visual और portable रिपोर्ट तैयार करेगा। आप settings और wordlists को tweak करके एक customized अनुभव प्राप्त कर सकते हैं।

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework एक Android vulnerability analysis सिस्टम है जो developers या hackers को Android applications में संभावित security vulnerabilities खोजने में मदद करता है.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** एक ऐसा टूल है जिसका मुख्य उद्देश्य Android application द्वारा विकसित संभावित malicious व्यवहारों का पता लगाकर उपयोगकर्ता को चेतावनी देना है।

This detection is performed with the **static analysis** of the application's Dalvik bytecode, represented as **Smali**, with the [`androguard`](https://github.com/androguard/androguard) library.

यह टूल **common behavior of "bad" applications** जैसे निम्नलिखित चीज़ों की तलाश करता है: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. यह एक टूल है जो आमतौर पर उपयोग किए जाने वाले mobile application reverse engineering और analysis tools को एक साथ रखता है, ताकि OWASP mobile security threats के खिलाफ mobile applications का परीक्षण करने में सहायता मिल सके। इसका उद्देश्य mobile application डेवलपर्स और security professionals के लिए यह कार्य आसान और अधिक मित्रवत बनाना है।

यह सक्षम है:

- Extract Java और Smali code विभिन्न tools का उपयोग करके
- Analyze APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Extract private information from the APK using regexps.
- Analyze the Manifest.
- Analyze found domains using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuscate APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Useful to detect malware: [https://koodous.com/](https://koodous.com/)

## Obfuscating/Deobfuscating code

ध्यान दें कि जिस सेवा और configuration का आप उपयोग करते हैं कोड को obfuscate करने के लिए, उसके अनुसार Secrets obfuscated हो भी सकते हैं या नहीं भी।

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

From [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** एक open source command-line tool है जो Java code को shrink, optimize और obfuscate करता है। यह bytecode को optimize करने के साथ-साथ unused instructions का पता लगाकर हटाने में सक्षम है। ProGuard free software है और GNU General Public License, version 2 के अंतर्गत वितरित है।

ProGuard Android SDK का हिस्सा के रूप में वितरित होता है और application को release mode में build करते समय चलता है।

### [DexGuard](https://www.guardsquare.com/dexguard)

Find a step-by-step guide to deobfuscate the apk in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Last time we checked, the Dexguard mode of operation was:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

आप एक obfuscated APK अपनी platform पर upload कर सकते हैं।

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

This is a LLM tool to find any potential security vulnerabilities in android apps and deobfuscate android app code. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

It is a **generic android deobfuscator.** Simplify **virtually executes an app** to understand its behavior and then **tries to optimize the code** so it behaves identically but is easier for a human to understand. Each optimization type is simple and generic, so it doesn't matter what the specific type of obfuscation is used.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gives you information about **how an APK was made**. It identifies many **compilers**, **packers**, **obfuscators**, and other weird stuff. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b एक Android security virtual machine है जो ubuntu-mate पर आधारित है और इसमें latest framework, tutorials और labs का संग्रह शामिल है जो विभिन्न security geeks और researchers ने reverse engineering और malware analysis के लिए बनाया है।

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) यह संसाधनों की एक शानदार सूची है
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android त्वरित पाठ्यक्रम
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)
- [Build a Repeatable Android Bug Bounty Lab: Emulator vs Magisk, Burp, Frida, and Medusa](https://www.yeswehack.com/learn-bug-bounty/android-lab-mobile-hacking-tools)
- [CoRPhone — Android in-memory JNI execution and packaging pipeline](https://github.com/0xdevil/corphone)

{{#include ../../banners/hacktricks-training.md}}
