# Android Toepassings Pentesting

{{#include ../../banners/hacktricks-training.md}}

## Android Toepassings Basiese

Dit word sterk aanbeveel om eers hierdie bladsy te lees om te weet oor die **belangrikste dele wat verband hou met Android-sekuriteit en die gevaarlikste komponente in 'n Android-toepassing**:


{{#ref}}
android-applications-basics.md
{{#endref}}

## ADB (Android Debug Bridge)

Dit is die hoofgereedskap wat jy nodig het om aan 'n Android-toestel te koppel (geëmuleer of fisies).\
**ADB** maak dit moontlik om toestelle te beheer óf oor **USB** óf oor **Network** vanaf 'n rekenaar. Hierdie nutsprogram maak moontlik die **kopiering** van lêers in beide rigtings, **installasie** en **verwydering** van apps, die **uitvoering** van shell-opdragte, die **rugsteun** van data, die **lees** van logs, nevens ander funksies.

Kyk na die volgende lys van [**ADB Commands**](adb-commands.md) om te leer hoe om adb te gebruik.

## Smali

Soms is dit interessant om die **toepassingskode te wysig** om by **verborgen inligting** uit te kom (byv. goed gefluisterde wagwoorde of flags). In daardie geval kan dit sin maak om die APK te dekompileer, die kode te wysig en dit weer te compileer.\
[**In this tutorial** you can **learn how to decompile and APK, modify Smali code and recompile the APK** with the new functionality](smali-changes.md). Dit kan baie nuttig wees as 'n **alternatief vir verskeie toetse tydens die dinamiese analise** wat aangebied gaan word. Hou dus **altyd hierdie moontlikheid in gedagte**.

## Other interesting tricks

- [Spoofing your location in Play Store](spoofing-your-location-in-play-store.md)
- [Shizuku Privileged API (ADB-based non-root privileged access)](shizuku-privileged-api.md)
- [Exploiting Insecure In-App Update Mechanisms](insecure-in-app-update-rce.md)
- [Abusing Accessibility Services (Android RAT)](accessibility-services-abuse.md)
- **Laai APKs af**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
- Haal APK uit toestel:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
- Voeg alle splits en base apks saam met [APKEditor](https://github.com/REAndroid/APKEditor):
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## Gevallestudies & Kwesbaarhede


{{#ref}}
../ios-pentesting/air-keyboard-remote-input-injection.md
{{#endref}}


{{#ref}}
../../linux-hardening/privilege-escalation/android-rooting-frameworks-manager-auth-bypass-syscall-hook.md
{{#endref}}

## Statiese Analise

Eerstens, om 'n APK te ontleed moet jy **na die Java-kode kyk** met 'n dekompiler.\
Lees asseblief, [**read here to find information about different available decompilers**](apk-decompilers.md).

### Soek na interessante inligting

Deur net na die **strings** van die APK te kyk, kan jy soek na **passwords**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **api** keys, **encryption**, **bluetooth uuids**, **tokens** en enigiets interessant... kyk selfs vir code execution **backdoors** of authentication backdoors (hardcoded admin credentials to the app).

**Firebase**

Gee besondere aandag aan **firebase URLs** en kontroleer of dit verkeerd gekonfigureer is. [More information about whats is FIrebase and how to exploit it here.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Basiese begrip van die toepassing - Manifest.xml, strings.xml

Die **ondersoek van 'n toepassing se _Manifest.xml_ en **_strings.xml_** lêers kan potensiële sekuriteitskwesbaarhede openbaar**. Hierdie lêers kan met 'n dekompiler gesien word of deur die APK-lêer-uitbreiding na .zip te verander en dit dan uit te pak.

**Kwesbaarhede** wat uit die **Manifest.xml** geïdentifiseer word sluit in:

- **Debuggable Applications**: Toepassings wat as debuggable (`debuggable="true"`) in die _Manifest.xml_ gestel is, vorm 'n risiko omdat dit verbindings toelaat wat tot uitbuiting kan lei. Vir meer begrip oor hoe om debuggable applications te misbruik, verwys na 'n handleiding oor die vind en uitbuiting van debuggable applications op 'n toestel.
- **Backup Settings**: Die `android:allowBackup="false"` attribuut moet eksplisiet gestel word vir toepassings wat met sensitiewe inligting werk om ongemagtigde data-rugsteun via adb te voorkom, veral wanneer usb debugging geaktiveer is.
- **Network Security**: Custom network security configurations (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ kan sekuriteitsbesonderhede soos sertifikaat pins en HTTP-verkeerinstellings spesifiseer. 'n Voorbeeld is om HTTP-verkeer vir spesifieke domeine toe te laat.
- **Exported Activities and Services**: Om exported activities en services in die manifest te identifiseer kan komponente uitwys wat moontlik misbruik kan word. Verdere ontleding tydens dinamiese toetsing kan dui hoe om hierdie komponente uit te buit.
- **Content Providers and FileProviders**: Blootgestelde content providers kan ongemagtigde toegang of wysiging van data toelaat. Die konfigurasie van FileProviders moet ook noukeurig ondersoek word.
- **Broadcast Receivers and URL Schemes**: Hierdie komponente kan gebruik word vir uitbuiting, met besondere aandag aan hoe URL schemes vir invoer-kwesbaarhede bestuur word.
- **SDK Versions**: Die `minSdkVersion`, `targetSDKVersion`, en `maxSdkVersion` attribuute dui die ondersteunde Android weergawes aan, wat die belangrikheid uitlig om nie verouderde, kwesbare Android weergawes te ondersteun nie.

Uit die **strings.xml** lêer kan sensitiewe inligting soos API keys, custom schemas, en ander ontwikkelaar-aantekeninge gevind word, wat die noodsaaklikheid van 'n noukeurige hersiening van hierdie hulpbronne beklemtoon.

### Tapjacking

Tapjacking is 'n aanval waar 'n kwaadwillige toepassing geloods word en homself bo 'n slagoffer-toepassing posisioneer. Sodra dit die slagoffer-app sigbaar verberg, is sy gebruikerskoppelvlak so ontwerp om die gebruiker te mislei om daarmee te interaksie, terwyl dit die interaksie aan die slagoffer-app deurgee.\
In werklikheid maak dit die gebruiker blind vir die feit dat hulle eintlik handelinge op die slagoffer-app verrig.

Find more information in:


{{#ref}}
tapjacking.md
{{#endref}}

### Task Hijacking

'n **activity** met die **`launchMode`** gestel op **`singleTask` sonder enige `taskAffinity`** gedefinieer is kwesbaar vir Task Hijacking. Dit beteken dat 'n **application** geïnstalleer kan word en as dit voor die regte toepassing geloods word, kan dit die taak van die regte toepassing kap (sodat die gebruiker met die **malicious application** sal interaksie hê en dink hy gebruik die regte een).

More info in:


{{#ref}}
android-task-hijacking.md
{{#endref}}

### Onveilige datastooring

**Interne berging**

In Android is lêers wat in **internal** storage gestoor word ontwerp om uitsluitlik deur die **app** wat dit geskep het toeganklik te wees. Hierdie sekuriteitsmaatreël word deur die Android-bedryfstelsel afgedwing en is oor die algemeen voldoende vir die sekuriteitsbehoeftes van die meeste toepassings. Ontwikkelaars gebruik egter soms modes soos `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` om lêers tussen verskillende toepassings te deel. Hierdie modes beperk egter nie die toegang tot hierdie lêers deur ander toepassings nie, insluitend moontlik kwaadwillige toepassings.

1. **Statiese Analise:**
- **Maak seker** dat die gebruik van `MODE_WORLD_READABLE` en `MODE_WORLD_WRITABLE` noukeurig ondersoek word. Hierdie modes **kan moontlik lêers blootstel** aan **onbedoelde of ongemagtigde toegang**.
2. **Dinamiese Analise:**
- **Verifieer** die **permissies** wat op lêers geskep deur die app gestel is. Spesifiek, **kontroleer** of enige lêers **gestel is om wêreldwyd leesbaar of skryfbaar te wees**. Dit kan 'n beduidende sekuriteitsrisiko inhou, aangesien dit **enige toepassing** op die toestel, ongeag oorsprong of bedoeling, toelaat om hierdie lêers te **lees of te wysig**.

**Eksterne berging**

Wanneer dit by lêers op **external storage** kom, soos SD Cards, moet sekere voorsorgmaatreëls getref word:

1. **Toeganklikheid**:
- Lêers op external storage is **globaal leesbaar en skryfbaar**. Dit beteken enige toepassing of gebruiker kan toegang kry tot hierdie lêers.
2. **Sekuriteitskwessies**:
- Gegewe die maklike toegang, word dit aanbeveel **om nie sensitiewe inligting op external storage te stoor nie**.
- External storage kan verwyder word of deur enige toepassing benader word, wat dit minder veilig maak.
3. **Hantering van data vanaf external storage**:
- Voer altyd **input validation** uit op data wat van external storage verkry word. Dit is kritiek omdat die data van 'n onbetroubare bron kom.
- Dit word sterk ontraden om uitvoerbare of klasklasse op external storage te stoor vir dinamiese lading.
- As jou toepassing verplig is om uitvoerbare lêers van external storage te laai, verseker dat hierdie lêers **gesigneer en kriptografies verifieer** is voordat hulle dinamies gelaai word. Hierdie stap is van kardinale belang vir die instandhouding van die sekuriteitsintegriteit van jou toepassing.

External storage kan in `/storage/emulated/0` , `/sdcard` , `/mnt/sdcard` toeganklik wees

> [!TIP]
> Vanaf Android 4.4 (**API 17**) het die SD-kaart 'n gidsstruktuur wat die toegang van 'n app beperk tot die gids wat spesifiek vir daardie app is. Dit voorkom dat kwaadwillige toepassings lees- of skryftoegang tot 'n ander app se lêers verkry.

**Gevoelige data in duidelike teks gestoor**

- **Shared preferences**: Android laat elke toepassing toe om maklik xml-lêers in die paadjie `/data/data/<packagename>/shared_prefs/` te stoor en soms is dit moontlik om sensitiewe inligting in duidelike teks in daardie gids te vind.
- **Databases**: Android laat elke toepassing toe om maklik sqlite-databasislêers in die paadjie `/data/data/<packagename>/databases/` te stoor en soms is dit moontlik om sensitiewe inligting in duidelike teks in daardie gids te vind.

### Gebroke TLS

**Aanvaar alle sertifikate**

Om een of ander rede aanvaar ontwikkelaars soms alle sertifikate selfs al stem byvoorbeeld die hostname nie ooreen nie, met reëls van kode soos die volgende:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
A good way to test this is to try to capture the traffic using some proxy like Burp without authorising Burp CA inside the device. Also, you can generate with Burp a certificate for a different hostname and use it.

### Gebroke Kryptografie

**Swak Sleutelbestuursprosesse**

Sommige ontwikkelaars stoor sensitiewe data in die plaaslike berging en enkripteer dit met ’n sleutel wat in die kode hardgekap of voorspelbaar is. Dit behoort nie so te gebeur nie aangesien reversing ’n aanvaller kan toelaat om die vertroulike inligting te onttrek.

**Gebruik van Onveilige en/of Verouderde Algoritmes**

Ontwikkelaars behoort nie **deprecated algorithms** te gebruik om authorisation **checks**, **store** of **send** data uit te voer nie. Sommige van hierdie algoritmes is: RC4, MD4, MD5, SHA1... Indien **hashes** byvoorbeeld gebruik word om wagwoorde te stoor, moet hashes wat brute-force bestand is met salt gebruik word.

### Ander kontroles

- Dit word aanbeveel om die APK te **obfuskeer** om die reverse-engineer se werk vir aanvalers moeiliker te maak.
- As die app sensitief is (soos bankapps), behoort dit sy **eie kontroles te doen om te sien of die mobiel geroot is** en dienooreenkomstig op te tree.
- As die app sensitief is (soos bankapps), behoort dit te kontroleer of ’n **emulator** gebruik word.
- As die app sensitief is (soos bankapps), behoort dit **sy eie integriteit te kontroleer voordat dit uitgevoer word** om te kyk of dit gewysig is.
- Gebruik [**APKiD**](https://github.com/rednaga/APKiD) om te kyk watter compiler/packer/obfuscator gebruik is om die APK te bou

### React Native Application

Read the following page to learn how to easily access javascript code of React applications:


{{#ref}}
react-native-application.md
{{#endref}}

### Xamarin Applications

Read the following page to learn how to easily access C# code of a xamarin applications:


{{#ref}}
../xamarin-apps.md
{{#endref}}

### Superpacked Applications

Volgens hierdie [**blog post**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) is superpacked ’n Meta-algoritme wat die inhoud van ’n toepassing in ’n enkele lêer saamdruk. Die blog beskryf die moontlikheid om ’n app te skep wat hierdie tipe apps kan dekomprimeer... en ’n vinniger manier wat behels om die **application te execute en die decompressed files vanaf die filesystem te versamel.**

### Geautomatiseerde Statiese Kode-analise

Die tool [**mariana-trench**](https://github.com/facebook/mariana-trench) is in staat om **vulnerabilities** te vind deur die **code** van die toepassing te **scan**. Hierdie tool bevat ’n reeks **known sources** (wat die tool aandui watter **places** die **input** deur die gebruiker beheer word), **sinks** (wat die tool aandui **dangerous** **places** waar malisieuse gebruikersinvoer skade kan veroorsaak) en **rules**. Hierdie rules dui die **kombinasie** van **sources-sinks** aan wat op ’n vulnerability dui.

Met hierdie kennis, **mariana-trench sal die kode hersien en moontlike vulnerabilities daarin vind.**

### Secrets leaked

’n Toepassing mag geheimenisse (API keys, passwords, hidden urls, subdomains...) daarin hê wat jy moontlik kan ontdek. Jy kan ’n tool gebruik soos [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass Biometric Authentication


{{#ref}}
bypass-biometric-authentication-android.md
{{#endref}}

### Ander interessante funksies

- **Code execution**: `Runtime.exec(), ProcessBuilder(), native code:system()`
- **Send SMSs**: `sendTextMessage, sendMultipartTestMessage`
- **Native functions** declared as `native`: `public native, System.loadLibrary, System.load`
- [Read this to learn **how to reverse native functions**](reversing-native-libraries.md)

### **Other tricks**


{{#ref}}
content-protocol.md
{{#endref}}

---

---

## Dynamic Analysis

> Eerstens het jy ’n omgewing nodig waar jy die toepassing en al die omgewing (Burp CA cert, Drozer en Frida hoofsaaklik) kan installeer. Daarom word ’n gerootte toestel (emulated of nie) uiters aanbeveel.

### Online Dynamic analysis

You can create a **free account** in: [https://appetize.io/](https://appetize.io). This platform allows you to **upload** and **execute** APKs, so it is useful to see how an apk is behaving.

You can even **see the logs of your application** in the web and connect through **adb**.

![](<../../images/image (831).png>)

Thanks to the ADB connection you can use **Drozer** and **Frida** inside the emulators.

### Plaaslike Dinamiese Analise

#### Using an emulator

- [**Android Studio**](https://developer.android.com/studio) (You can create **x86** and **arm** devices, and according to [**this** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**latest x86** versions **support ARM libraries** without needing an slow arm emulator).
- Learn to set it up in this page:


{{#ref}}
avd-android-virtual-device.md
{{#endref}}

- [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Free version:** Personal Edition, you need to create an account. _It's recommend to **download** the version **WITH**_ _**VirtualBox** to avoid potential errors._)
- [**Nox**](https://es.bignox.com) (Free, but it doesn't support Frida or Drozer).

> [!TIP]
> Wanneer jy ’n nuwe emulator op enige platform skep, onthou dat hoe groter die skerm is, hoe stadiger sal die emulator loop. Kies dus klein skerms indien moontlik.

To **install google services** (like AppStore) in Genymotion you need to click on the red marked button of the following image:

![](<../../images/image (277).png>)

Also, notice that in the **configuration of the Android VM in Genymotion** you can select **Bridge Network mode** (this will be useful if you will be connecting to the Android VM from a different VM with the tools).

#### Gebruik ’n fisiese toestel

Jy moet die **debugging** opsies aktiveer en dit sal goed wees as jy dit kan **root**:

1. **Settings**.
2. (FromAndroid 8.0) Select **System**.
3. Select **About phone**.
4. Press **Build number** 7 times.
5. Go back and you will find the **Developer options**.

> Sodra jy die toepassing geïnstalleer het, is die eerste ding wat jy moet doen om dit te probeer en ondersoek wat dit doen, hoe dit werk en gemaklik daarmee te raak.\
> Ek stel voor om hierdie aanvanklike dinamiese analise met MobSF dynamic analysis + pidcat uit te voer, sodat ons kan **leer hoe die toepassing werk** terwyl MobSF baie **interesting** **data** vang wat jy later kan hersien.

### Unintended Data Leakage

**Logging**

Ontwikkelaars moet versigtig wees om nie **debugging information** publiek bloot te stel nie, aangesien dit sensitiewe data leaks kan veroorsaak. Die tools [**pidcat**](https://github.com/JakeWharton/pidcat) en `adb logcat` word aanbeveel om toepassingslogs te monitor om sensitiewe inligting te identifiseer en te beskerm. **Pidcat** word verkies vir die eenvoud en leesbaarheid.

> [!WARNING]
> Neem kennis dat vanaf **later newer than Android 4.0**, **applications are only able to access their own logs**. So applications cannot access other apps logs.\
> Anyway, it's still recommended to **not log sensitive information**.

**Copy/Paste Buffer Caching**

Android se **clipboard-based** raamwerk maak copy-paste funksionaliteit in apps moontlik, maar vorm ’n risiko aangesien **other applications** die clipboard kan **access**, wat sensitiewe data moontlik blootstel. Dit is belangrik om copy/paste funksies vir sensitiewe gedeeltes van ’n toepassing, soos kredietkaartbesonderhede, uit te skakel om data leaks te voorkom.

**Crash Logs**

As ’n toepassing **crash** en logs stoor, kan daardie logs aanvallers help, veral wanneer die toepassing nie gerestreer kan word nie. Om hierdie risiko te beperk, moet jou nie op crashes log nie, en as logs oor die netwerk gestuur moet word, verseker dat hulle via ’n SSL-kanaal gestuur word vir sekuriteit.

As pentester, **probeer om na hierdie logs te kyk**.

**Analytics Data Sent To 3rd Parties**

Toepassings integreer dikwels dienste soos Google Adsense, wat per ongeluk sensitiewe data kan **leak** as gevolg van onvanpaste implementering deur ontwikkelaars. Om moontlike data leaks te identifiseer, is dit raadsaam om die toepassing se verkeer te onderskep en te kyk of enige sensitiewe inligting na derdepartye gestuur word.

### SQLite DBs

Die meeste toepassings sal **internal SQLite databases** gebruik om inligting te stoor. Tydens die pentest kyk na die **databases** wat geskep is, die name van **tables** en **columns** en al die **data** wat gestoor is, want jy kan **sensitive information** vind (wat ’n vulnerability sou wees).\
Databases behoort te wees in `/data/data/the.package.name/databases` soos `/data/data/com.mwr.example.sieve/databases`

As die database vertroulike inligting stoor en is **encrypted** maar jy kan die **password** binne die toepassing **vind**, is dit steeds ’n **vulnerability**.

Lys die tables met `.tables` en lys die kolomme van die tables met `.schema <table_name>`

### Drozer (Exploit Activities, Content Providers and Services)

From [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** allows you to **assume the role of an Android app** and interact with other apps. It can do **anything that an installed application can do**, such as make use of Android’s Inter-Process Communication (IPC) mechanism and interact with the underlying operating system. .\
Drozer is ’n nuttige tool om **exploit exported activities, exported services and Content Providers** te doen soos jy in die volgende afdelings sal leer.

### Exploiting exported Activities

[**Read this if you want to refresh what is an Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Onthou ook dat die kode van ’n activity begin in die **`onCreate`** metode.

**Authorisation bypass**

Wanneer ’n Activity exported is, kan jy sy skerm vanaf ’n eksterne app aanroep. Daarom, as ’n activity met **sensitive information** **exported** is, kan jy die **authentication** meganismes **bypass** om toegang daartoe te kry.

[**Learn how to exploit exported activities with Drozer.**](drozer-tutorial/index.html#activities)

You can also start an exported activity from adb:

- PackageName is com.example.demo
- Exported ActivityName is com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**LET OP**: MobSF sal die gebruik van _**singleTask/singleInstance**_ as `android:launchMode` in 'n activity as kwaadwillig bespeur, maar weens [hierdie](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), lyk dit of dit slegs gevaarlik is op ou weergawes (API versions < 21).

> [!TIP]
> Neem kennis dat 'n authorisation bypass nie altyd 'n vulnerability is nie; dit hang af van hoe die bypass werk en watter inligting blootgestel word.

**Sensitive information leakage**

**Activities can also return results**. As jy daarin slaag om 'n exported en unprotected activity te vind wat die **`setResult`** metode aanroep en **sensitive information** teruggee, is daar 'n sensitive information leakage.

#### Tapjacking

As Tapjacking nie voorkom word nie, kan jy die exported activity misbruik om die **gebruiker** onverwagte aksies te laat uitvoer. Vir meer inligting oor [**what is Tapjacking follow the link**](#tapjacking).

### Exploiting Content Providers - Accessing and manipulating sensitive information

[**Lees dit as jy jou kennis oor wat 'n Content Provider is wil opfris.**](android-applications-basics.md#content-provider)\
Content providers word hoofsaaklik gebruik om **data te deel**. As 'n app beskikbare Content Providers het, kan jy dalk sensitiewe data daaruit onttrek. Dit is ook belangrik om moontlike **SQL injections** en **Path Traversals** te toets aangesien hulle kwesbaar kan wees.

[**Leer hoe om Content Providers met Drozer te exploit.**](drozer-tutorial/index.html#content-providers)

### **Exploiting Services**

[**Lees dit as jy jou kennis oor wat 'n Service is wil opfris.**](android-applications-basics.md#services)\
Onthou dat die aksies van 'n Service begin in die metode `onStartCommand`.

'n Service is basies iets wat **data kan ontvang**, dit kan **verwerk** en (al dan nie) 'n reaksie **teruggee**. Dus, as 'n toepassing sekere services exporteer, moet jy die **code** nagaan om te verstaan wat dit doen en dit **dinamies** toets om vertroulike inligting te onttrek, authentication measures te bypass, ens.\
[**Leer hoe om Services met Drozer te exploit.**](drozer-tutorial/index.html#services)

### **Exploiting Broadcast Receivers**

[**Lees dit as jy jou kennis oor wat 'n Broadcast Receiver is wil opfris.**](android-applications-basics.md#broadcast-receivers)\
Onthou dat die aksies van 'n Broadcast Receiver begin in die metode `onReceive`.

'n Broadcast Receiver sal wag vir 'n tipe boodskap. Afhangend van hoe die receiver die boodskap hanteer, kan dit kwesbaar wees.\
[**Leer hoe om Broadcast Receivers met Drozer te exploit.**](#exploiting-broadcast-receivers)

### **Exploiting Schemes / Deep links**

Jy kan handmatig na deep links soek, met hulpmiddels soos MobSF of scripts soos [this one](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Jy kan 'n gedeklareerde **scheme** oopmaak met **adb** of 'n **browser**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_Let wel dat jy die **package name** kan weglaat en die mobiele toestel outomaties die app sal oproep wat daardie skakel behoort oop te maak._
```html
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Uitgevoerde kode**

Om die **kode wat in die App uitgevoer sal word** te vind, gaan na die activity wat deur die deeplink aangeroep word en soek die funksie **`onNewIntent`**.

![](<../../images/image (436) (1) (1) (1).png>)

**Sensitiewe inligting**

Elke keer as jy 'n deep link vind, kontroleer dat **dit nie sensitiewe data (soos wagwoorde) via URL-parameters ontvang nie**, want enige ander toepassing kan **die deep link naboots en daardie data steel!**

**Parameters in pad**

Jy **moet ook nagaan of enige deep link 'n parameter binne die pad** van die URL gebruik soos: `https://api.example.com/v1/users/{username}`, in daardie geval kan jy 'n path traversal afdwing deur toegang te verkry soos: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Let daarop dat as jy die korrekte endpoints binne die toepassing vind, jy moontlik 'n **Open Redirect** kan veroorsaak (as 'n deel van die pad as domeinnaam gebruik word), **account takeover** (as jy gebruikersbesonderhede kan wysig sonder 'n CSRF token en die vuln endpoint die korrekte metode gebruik) en enige ander vuln. More [info about this here](http://dphoeniixx.com/2020/12/13-2/).

**Meer voorbeelde**

'n [interesting bug bounty report](https://hackerone.com/reports/855618) oor links (_/.well-known/assetlinks.json_).

### Inspeksie van die vervoerslaag en verifikasie-foute

- **Sertifikate word nie altyd behoorlik ondersoek nie** deur Android-toepassings. Dit is algemeen dat hierdie toepassings waarskuwings ignoreer en self-ondertekende sertifikate aanvaar of, in sommige gevalle, terugval na die gebruik van HTTP-verbindinge.
- **Onderhandelinge tydens die SSL/TLS-handshake is soms swak**, en gebruik onveilige cipher suites. Hierdie kwesbaarheid maak die verbinding kwesbaar vir man-in-the-middle (MITM)-aanvalle, wat aanvallers toelaat om die data te ontsleutel.
- **Leakage of private information** is 'n risiko wanneer toepassings met veilige kanale verifieer, maar dan oor onveilige kanale kommunikeer vir ander transaksies. Hierdie benadering beskerm nie sensitiewe data, soos sessie-cookies of gebruikersbesonderhede, teen onderskep deur kwaadwilliges nie.

#### Sertifikaatverifikasie

Ons sal fokus op **sertifikaatverifikasie**. Die integriteit van die bediener se sertifikaat moet geverifieer word om veiligheid te verbeter. Dit is noodsaaklik omdat onveilige TLS-konfigurasies en die oordrag van sensitiewe data oor onversleutelde kanale groot risiko's kan inhou. For detailed steps on verifying server certificates and addressing vulnerabilities, [**this resource**](https://manifestsecurity.com/android-application-security-part-10/) provides comprehensive guidance.

#### SSL Pinning

SSL Pinning is 'n sekuriteitsmaatreël waar die toepassing die bediener se sertifikaat vergelyk met 'n bekende kopie wat binne die toepassing self gestoor is. Hierdie metode is noodsaaklik om MITM-aanvalle te voorkom. Dit word sterk aanbeveel om SSL Pinning te implementeer vir toepassings wat sensitiewe inligting hanteer.

#### Verkeersinspeksie

Om HTTP-verkeer te inspekteer, is dit nodig om **die proxy-gereedskap se sertifikaat te installeer** (bv. Burp). Sonder hierdie sertifikaat mag versleutelde verkeer nie deur die proxy sigbaar wees nie. Vir 'n gids oor die installering van 'n pasgemaakte CA-sertifikaat, [**click here**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Toepassings wat mik op **API Level 24 and above** vereis wysigings aan die Network Security Config om die proxy se CA-sertifikaat te aanvaar. Hierdie stap is kritiek om versleutelde verkeer te inspekteer. For instructions on modifying the Network Security Config, [**refer to this tutorial**](make-apk-accept-ca-certificate.md).

If **Flutter** is being used you need to to follow the instructions in [**this page**](flutter.md). This is becasue, just adding the certificate into the store won't work as Flutter has its own list of valid CAs.

#### Statiese opsporing van SSL/TLS pinning

Voordat jy runtime-bypasses probeer, karteer vinnig waar pinning in die APK afgedwing word. Statiese ontdekking help jou om hooks/patches te beplan en op die regte kodepade te fokus.

Tool: SSLPinDetect
- Open-source statiese-analise nutsmiddel wat die APK na Smali decompileer (via apktool) en skandeer vir gekurateerde regex-patrone van SSL/TLS pinning-implementasies.
- Rapporteer die presiese lêerpad, reëlnommer en 'n kodefragment vir elke ooreenkoms.
- Dek gewone frameworks en pasgemaakte kodepade: OkHttp CertificatePinner, custom javax.net.ssl.X509TrustManager.checkServerTrusted, SSLContext.init with custom TrustManagers/KeyManagers, and Network Security Config XML pins.

Install
- Vereistes: Python >= 3.8, Java on PATH, apktool
```bash
git clone https://github.com/aancw/SSLPinDetect
cd SSLPinDetect
pip install -r requirements.txt
```
Gebruik
```bash
# Basic
python sslpindetect.py -f app.apk -a apktool.jar

# Verbose (timings + per-match path:line + snippet)
python sslpindetect.py -a apktool_2.11.0.jar -f sample/app-release.apk -v
```
Voorbeeld patroonreëls (JSON)
Gebruik of brei signatures uit om proprietêre/aangepaste pinning-styls te ontdek. Jy kan jou eie JSON laai en op skaal skandeer.
```json
{
"OkHttp Certificate Pinning": [
"Lcom/squareup/okhttp/CertificatePinner;",
"Lokhttp3/CertificatePinner;",
"setCertificatePinner"
],
"TrustManager Override": [
"Ljavax/net/ssl/X509TrustManager;",
"checkServerTrusted"
]
}
```
Notas en wenke
- Vinnige skandering van groot apps via multi-threading en memory-mapped I/O; vooraf-gecompileerde regex verminder overhead en valse positiewe.
- Pattern collection: https://github.com/aancw/smali-sslpin-patterns
- Tipiese detectiedoelwitte om volgende te triage:
- OkHttp: CertificatePinner gebruik, setCertificatePinner, okhttp3/okhttp pakketverwysings
- Aangepaste TrustManagers: javax.net.ssl.X509TrustManager, checkServerTrusted overrides
- Aangepaste SSL contexts: SSLContext.getInstance + SSLContext.init met aangepaste managers
- Deklaratiewe pinne in res/xml network security config en manifestverwysings
- Gebruik die ooreenstemmende plekke om Frida hooks, statiese patches, of config-resensies te beplan voor dinamiese toetsing.



#### Om SSL Pinning te omseil

Wanneer SSL Pinning geïmplementeer is, word dit nodig om dit te omseil om HTTPS-verkeer te ondersoek. Verskeie metodes is beskikbaar vir hierdie doel:

- Automatically **modify** the **apk** to **bypass** SSLPinning with [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). The best pro of this option, is that you won't need root to bypass the SSL Pinning, but you will need to delete the application and reinstall the new one, and this won't always work.
- You could use **Frida** (discussed below) to bypass this protection. Here you have a guide to use Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
- Jy kan ook probeer om **outomaties SSL Pinning te omseil** using [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
- Jy kan ook probeer om **outomaties SSL Pinning te omseil** using **MobSF dynamic analysis** (explained below)
- If you still think that there is some traffic that you aren't capturing you can try to **forward the traffic to burp using iptables**. Read this blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Op soek na Algemene web-kwesbaarhede

Dit is belangrik om ook na algemene web-kwesbaarhede binne die toepassing te soek. Gedetaileerde inligting oor die identifisering en mitigering van hierdie kwesbaarhede val buite die bestek van hierdie samevatting, maar word elders uitvoerig behandel.

### Frida

[Frida](https://www.frida.re) is 'n dinamiese instrumenteringspakket vir ontwikkelaars, reverse-engineers, en sekuriteitsnavorsers.\
**Jy kan toegang kry tot 'n lopende toepassing en metodes hook tydens runtime om die gedrag te verander, waardes te wysig, waardes uit te trek, ander kode uit te voer...**\
As jy Android-toepassings wil pentest jy moet weet hoe om Frida te gebruik.

- Leer hoe om Frida te gebruik: [**Frida tutorial**](frida-tutorial/index.html)
- Sommmige "GUI" vir aksies met Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
- Ojection is great to automate the use of Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
- You can find some Awesome Frida scripts here: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
- Probeer om anti-debugging / anti-frida meganismes te omseil deur Frida te laai soos aangedui in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (tool [linjector](https://github.com/erfur/linjector-rs))

#### Anti-instrumentation & SSL pinning bypass workflow

{{#ref}}
android-anti-instrumentation-and-ssl-pinning-bypass.md
{{#endref}}

### **Dump Geheue - Fridump**

Kontroleer of die toepassing sensitiewe inligting in die geheue stoor wat dit nie behoort te stoor nie, soos wagwoorde of mnemonics.

Met [**Fridump3**](https://github.com/rootbsd/fridump3) kan jy die geheue van die app dump met:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Dit sal die geheue in die ./dump-gids dump, en daarbinne kan jy met grep iets soos:
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Sensitiewe data in Keystore**

In Android is die Keystore die beste plek om sensitiewe data te stoor, maar met genoeg privileges is dit steeds **moontlik om toegang daartoe te kry**. Aangesien toepassings geneig is om hier **sensitiewe data in onversleutelde teks** te stoor, behoort pentests dit as root user te kontroleer, aangesien iemand met fisiese toegang tot die toestel hierdie data kan steel.

Selfs as 'n app data in die Keystore stoor, moet die data versleuteld wees.

Om toegang tot die data binne die Keystore te kry, kan jy hierdie Frida-script gebruik: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Fingerprint/Biometrics Bypass**

Met die volgende Frida-skrip kan dit moontlik wees om die **bypass fingerprint authentication** wat Android-toepassings dalk uitvoer om sekere sensitiewe gebiede te beskerm:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
### **Agtergrondbeelde**

Wanneer jy 'n toepassing in die agtergrond plaas, stoor Android 'n **snapshot van die toepassing** sodat wanneer dit weer na die voorgrond herstel word, dit die beeld begin laai voordat die app self laai, sodat dit lyk asof die app vinniger gelaai is.

Indien hierdie snapshot egter **sensitiewe inligting** bevat, kan iemand met toegang tot die snapshot daardie inligting **steel** (let daarop dat jy root nodig het om daartoe toegang te kry).

Die snapshots word gewoonlik gestoor by: **`/data/system_ce/0/snapshots`**

Android bied 'n manier om die **skermskootvaslegging te voorkom deur die FLAG_SECURE** layout-parameter te stel. Deur hierdie vlag te gebruik, word die vensterinhoud as veilig beskou, wat verhoed dat dit in skermskote verskyn of op nie-veilige skerms besigtig word.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

Hierdie hulpmiddel kan jou help om verskillende gereedskap tydens dinamiese ontleding te bestuur: [https://github.com/NotSoSecure/android_application_analyzer](https://github.com/NotSoSecure/android_application_analyzer)

### Intent Injection

Ontwikkelaars skep dikwels proxy-komponente soos activities, services, en broadcast receivers wat hierdie Intents hanteer en dit aan metodes soos `startActivity(...)` of `sendBroadcast(...)` deurgee, wat riskant kan wees.

Die gevaar lê daarin om aanvallers toe te laat om nie-geëxporteerde app-komponente te aktiveer of sensitiewe content providers te bekom deur hierdie Intents verkeerd te lei. 'n Noemenswaardige voorbeeld is die `WebView` komponent wat URL's na `Intent`-objekte omskakel via `Intent.parseUri(...)` en dit dan uitvoer, wat moontlik tot kwaadwillige Intent-inspuitings kan lei.

### Essential Takeaways

- **Intent Injection** is soortgelyk aan die web se Open Redirect-kwessie.
- Eksploite behels die deurgee van `Intent`-objekte as extras, wat herlei kan word om onveilige operasies uit te voer.
- Dit kan nie-geëxporteerde komponente en content providers aan aanvallers blootstel.
- `WebView` se URL-naar-`Intent` omskakeling kan onbedoelde aksies vergemaklik.

### Android Client Side Injections and others

Jy ken waarskynlik hierdie soort kwesbaarhede van die web. Jy moet besonder versigtig wees met hierdie kwesbaarhede in 'n Android-applikasie:

- **SQL Injection:** Wanneer jy met dinamiese navrae of Content-Providers werk, verseker dat jy parameterized queries gebruik.
- **JavaScript Injection (XSS):** Verifieer dat JavaScript en Plugin support gedeaktiveer is vir enige WebViews (gedeaktiveer per verstek). [Meer inligting hier](webview-attacks.md#javascript-enabled).
- **Local File Inclusion:** WebViews moet toegang tot die lêerstelsel gedeaktiveer hê (geaktiveer per verstek) - `(webview.getSettings().setAllowFileAccess(false);)`. [Meer inligting hier](webview-attacks.md#javascript-enabled).
- **Eternal cookies**: In verskeie gevalle wanneer die Android-applikasie die sessie beëindig, word die cookie nie herroep nie of dit kan selfs op die skyf gestoor word
- [**Secure Flag** in cookies](../../pentesting-web/hacking-with-cookies/index.html#cookies-flags)

---

## Automatic Analysis

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Static analysis**

![](<../../images/image (866).png>)

**Kwetsbaarheidsevaluering van die toepassing** met 'n netjiese web-gebaseerde frontend. Jy kan ook dinamiese ontleding uitvoer (maar jy moet die omgewing voorberei).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Notice that MobSF can analyse **Android**(apk)**, IOS**(ipa) **and Windows**(apx) applications (_Windows applications must be analyzed from a MobSF installed in a Windows host_).\
Also, if you create a **ZIP** file with the source code if an **Android** or an **IOS** app (go to the root folder of the application, select everything and create a ZIPfile), it will be able to analyse it also.

MobSF also allows you to **diff/Compare** analysis and to integrate **VirusTotal** (you will need to set your API key in _MobSF/settings.py_ and enable it: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). You can also set `VT_UPLOAD` to `False`, then the **hash** will be **upload** instead of the file.

### Geassisteerde dinamiese analise met MobSF

**MobSF** kan ook baie nuttig wees vir **dynamic analysis** in **Android**, maar in daardie geval sal jy MobSF en **genymotion** op jou host moet installeer (a VM or Docker won't work). _Note: You need to **start first a VM in genymotion** and **then MobSF.**_\
Die **MobSF dynamic analyser** kan:

- **Dump application data** (URLs, logs, clipboard, screenshots made by you, screenshots made by "**Exported Activity Tester**", emails, SQLite databases, XML files, and other created files). All of this is done automatically except for the screenshots, you need to press when you want a screenshot or you need to press "**Exported Activity Tester**" to obtain screenshots of all the exported activities.
- Capture **HTTPS traffic**
- Use **Frida** to obtain **runtime** **information**

From android **versions > 5**, it will **automatically start Frida** and will set global **proxy** settings to **capture** traffic. It will only capture traffic from the tested application.

**Frida**

By default, it will also use some Frida Scripts to **bypass SSL pinning**, **root detection** and **debugger detection** and to **monitor interesting APIs**.\
MobSF can also **invoke exported activities**, grab **screenshots** of them and **save** them for the report.

To **start** the dynamic testing press the green bottom: "**Start Instrumentation**". Press the "**Frida Live Logs**" to see the logs generated by the Frida scripts and "**Live API Monitor**" to see all the invocation to hooked methods, arguments passed and returned values (this will appear after pressing "Start Instrumentation").\
MobSF also allows you to load your own **Frida scripts** (to send the results of your Friday scripts to MobSF use the function `send()`). It also has **several pre-written scripts** you can load (you can add more in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), just **select them**, press "**Load**" and press "**Start Instrumentation**" (you will be able to see the logs of that scripts inside "**Frida Live Logs**").

![](<../../images/image (419).png>)

Moreover, you have some Auxiliary Frida functionalities:

- **Enumerate Loaded Classes**: It will print all the loaded classes
- **Capture Strings**: It will print all the capture strings while using the application (super noisy)
- **Capture String Comparisons**: Could be very useful. It will **show the 2 strings being compared** and if the result was True or False.
- **Enumerate Class Methods**: Put the class name (like "java.io.File") and it will print all the methods of the class.
- **Search Class Pattern**: Search classes by pattern
- **Trace Class Methods**: **Trace** a **whole class** (see inputs and outputs of all methods of th class). Remember that by default MobSF traces several interesting Android Api methods.

Once you have selected the auxiliary module you want to use you need to press "**Start Intrumentation**" and you will see all the outputs in "**Frida Live Logs**".

**Shell**

Mobsf also brings you a shell with some **adb** commands, **MobSF commands**, and common **shell** **commands** at the bottom of the dynamic analysis page. Some interesting commands:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP gereedskap**

Wanneer HTTP-verkeer vasgevang word, kan jy 'n lelike weergawe van die vasgevang verkeer sien onder die "**HTTP(S) Traffic**" knoppie of 'n netter uitsig by die groen "**Start HTTPTools**" knoppie. Vanaf die tweede opsie kan jy die **vasgevang versoeke** **stuur** na **proxies** soos Burp of Owasp ZAP.\
Om dit te doen, _power on Burp -->_ _turn off Intercept --> in MobSB HTTPTools select the request_ --> press "**Send to Fuzzer**" --> _select the proxy address_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Sodra jy die dinamiese analise met MobSF voltooi het, kan jy op "**Start Web API Fuzzer**" druk om **http versoeke te fuzz** en na kwesbaarhede te soek.

> [!TIP]
> Na die uitvoering van 'n dinamiese analise met MobSF kan die proxy-instellings verkeerd gekonfigureer wees en jy sal dit nie vanuit die GUI kan regstel nie. Jy kan die proxy-instellings regmaak deur die volgende te doen:
>
> ```
> adb shell settings put global http_proxy :0
> ```

### Assisted Dynamic Analysis with Inspeckage

Jy kan die tool kry by [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Hierdie tool gebruik sekere **Hooks** om jou te wys **wat in die toepassing gebeur** terwyl jy 'n **dinamiese analise** uitvoer.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Dit is 'n **geweldige tool om statiese analise met 'n GUI uit te voer**

![](<../../images/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

Hierdie tool is ontwerp om te soek na verskeie **sekuriteitsverwante Android application vulnerabilities**, hetsy in **source code** of in **packaged APKs**. Die tool is ook **capable of creating a "Proof-of-Concept" deployable APK** en **ADB commands**, om sommige van die gevonde kwesbaarhede uit te buit (Exposed activities, intents, tapjacking...). Soos met Drozer, is daar geen behoefte om die toetsapparaat te root nie.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

- Wys alle uitgehaalde lêers vir maklike verwysing
- Dekompileer APK-lêers outomaties na Java- en Smali-formaat
- Ontleed AndroidManifest.xml vir algemene kwesbaarhede en gedrag
- Statiese bronkode-analise vir algemene kwesbaarhede en gedrag
- Toestelinligting
- en meer
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER is 'n command-line application wat op Windows, MacOS X en Linux gebruik kan word en _.apk_ lêers ontleed op soek na kwesbaarhede. Dit doen dit deur APKs te dekomprimeer en 'n reeks reëls toe te pas om daardie kwesbaarhede op te spoor.

Alle reëls is gesentreer in 'n `rules.json`-lêer, en elke maatskappy of toetser kan sy eie reëls skep om te analiseer wat hulle nodig het.

Laai die nuutste binaries af vanaf die [download page](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../images/image (297).png>)

StaCoAn is 'n **crossplatform** hulpmiddel wat ontwikkelaars, bugbounty hunters en ethical hackers help om [static code analysis](https://en.wikipedia.org/wiki/Static_program_analysis) op mobiele toepassings uit te voer.

Die konsep is dat jy jou mobiele toepassingslêer (.apk of .ipa lêer) op die StaCoAn-toepassing sleep en laat val, en dit sal 'n visuele en draagbare verslag vir jou genereer. Jy kan die instellings en wordlists aanpas om 'n aangepaste ervaring te kry.

Download[ latest release](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs_Framework)

AndroBugs Framework is 'n Android kwesbaarheidsanalise-stelsel wat ontwikkelaars of hackers help om potensiële sekuriteitskwesbaarhede in Android-toepassings te vind.\
[Windows releases](https://github.com/AndroBugs/AndroBugs_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** is 'n hulpmiddel waarvan die hoofdoel is om die gebruiker te identifiseer en te waarsku oor potensieel kwaadwillige gedrag wat deur 'n Android-toepassing uitgevoer word.

Die opsporing word uitgevoer deur die **static analysis** van die aansoek se Dalvik bytecode, voorgestel as **Smali**, met die [`androguard`](https://github.com/androguard/androguard) biblioteek.

Hierdie hulpmiddel soek na **algemene gedrag van "slegte" toepassings** soos: Telephony identifiers exfiltration, Audio/video flow interception, PIM data modification, Arbitrary code execution...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../images/image (595).png>)

**MARA** is a **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework. Dit is 'n hulpmiddel wat algemeen gebruikte mobile application reverse engineering- en analysis-tools bymekaar sit om te help met die toetsing van mobiele toepassings teen OWASP mobile security threats. Dit het ten doel om hierdie taak makliker en gebruikersvriendelik te maak vir mobile application developers en security professionals.

It is able to:

- Ekstraheer Java en Smali kode using different tools
- Analiseer APKs using: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
- Ekstraheer privaat inligting uit die APK using regexps.
- Analiseer die Manifest.
- Analiseer gevonde domeine using: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) and [whatweb](https://github.com/urbanadventurer/WhatWeb)
- Deobfuskeer APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Nuttig om malware op te spoor: [https://koodous.com/](https://koodous.com)

## Obfuskering/Deobfuskering van kode

Let wel dat, afhangend van die diens en konfigurasie wat gebruik word om die kode te obfuskeer, geheime moontlik wel of nie obfuskering ondergaan nie.

### [ProGuard](<https://en.wikipedia.org/wiki/ProGuard_(software)>)

Van [Wikipedia](<https://en.wikipedia.org/wiki/ProGuard_(software)>): **ProGuard** is 'n open source command-line tool wat Java-kode verklein, optimaliseer en obfuskeer. Dit kan bytecode optimaliseer asook ongebruikte instruksies opspoor en verwyder. ProGuard is vrye sagteware en word versprei onder die GNU General Public License, version 2.

ProGuard word as deel van die Android SDK versprei en hardloop wanneer die toepassing in release mode gebou word.

### [DexGuard](https://www.guardsquare.com/dexguard)

Vind 'n stap-vir-stap gids om die apk te deobfuskeer by [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(From that guide) Laas toe ons nagaan, was die Dexguard mode of operation:

- load a resource as an InputStream;
- feed the result to a class inheriting from FilterInputStream to decrypt it;
- do some useless obfuscation to waste a few minutes of time from a reverser;
- feed the decrypted result to a ZipInputStream to get a DEX file;
- finally load the resulting DEX as a Resource using the `loadDex` method.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverses the process of obfuscation performed by Android obfuscation tools. This enables numerous security analyses, including code inspection and predicting libraries.**

Jy kan 'n obfuskeerde APK na hul platform oplaai.

### [Deobfuscate android App]https://github.com/In3tinct/deobfuscate-android-app

Dit is 'n LLM tool om enige potensiële sekuriteitskwessbaarhede in android apps te vind en android app-kode te deobfuskeer. Uses Google's Gemini public API.

### [Simplify](https://github.com/CalebFenton/simplify)

Dit is 'n generiese android deobfuscator. Simplify virtually executes an app om sy gedrag te verstaan en probeer dan die kode optimaliseer sodat dit identies optree maar vir 'n mens makliker is om te begryp. Elke optimaliseringstipe is eenvoudig en generies, so dit maak nie saak watter spesifieke tipe obfuskering gebruik word nie.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD gee jou inligting oor hoe 'n APK gemaak is. Dit identifiseer baie compilers, packers, obfuscators, en ander vreemde goed. It's [_PEiD_](https://www.aldeid.com/wiki/PEiD) for Android.

### Manual

[Read this tutorial to learn some tricks on **how to reverse custom obfuscation**](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b is 'n Android sekuriteits-virtual machine gebaseer op ubuntu-mate en sluit 'n versameling van die nuutste framework, tutorials en labs in van verskillende sekuriteits geeks en navorsers vir reverse engineering en malware analysis.

## References

- [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Dit is 'n uitstekende lys van hulpbronne
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android quick course
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
- [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg&feature=youtu.be&ab_channel=B3nacSec)
- [SSLPinDetect: Advanced SSL Pinning Detection for Android Security Analysis](https://petruknisme.medium.com/sslpindetect-advanced-ssl-pinning-detection-for-android-security-analysis-1390e9eca097)
- [SSLPinDetect GitHub](https://github.com/aancw/SSLPinDetect)
- [smali-sslpin-patterns](https://github.com/aancw/smali-sslpin-patterns)

## Nog te probeer

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

{{#include ../../banners/hacktricks-training.md}}
