# Android Task Hijacking

{{#include ../../banners/hacktricks-training.md}}

## Task, Back Stack und Vordergrundaktivitäten

In Android ist eine **Task** im Wesentlichen eine Gruppe von Aktivitäten, mit denen Benutzer interagieren, um eine bestimmte Aufgabe zu erledigen, organisiert innerhalb eines **Back Stacks**. Dieser Stack ordnet Aktivitäten basierend darauf, wann sie geöffnet wurden, wobei die aktuellste Aktivität oben als **Vordergrundaktivität** angezeigt wird. Zu jedem Zeitpunkt ist nur diese Aktivität auf dem Bildschirm sichtbar, was sie Teil der **Vordergrund-Task** macht.

Hier ist eine kurze Übersicht über Aktivitätsübergänge:

- **Aktivität 1** beginnt als die einzige Aktivität im Vordergrund.
- Das Starten von **Aktivität 2** schiebt **Aktivität 1** in den Back Stack und bringt **Aktivität 2** in den Vordergrund.
- Das Starten von **Aktivität 3** verschiebt **Aktivität 1** und **Aktivität 2** weiter nach hinten im Stack, wobei **Aktivität 3** jetzt vorne ist.
- Das Schließen von **Aktivität 3** bringt **Aktivität 2** zurück in den Vordergrund und zeigt das optimierte Task-Navigationsmechanismus von Android.

![https://developer.android.com/images/fundamentals/diagram_backstack.png](<../../images/image (698).png>)

---

## Task-Affinitätsangriffe

`taskAffinity` sagt Android, zu welcher Task eine `Activity` *bevorzugt* gehören würde. Wenn zwei Aktivitäten die gleiche Affinität teilen, **darf Android sie im selben Back Stack zusammenführen, auch wenn sie aus verschiedenen APKs stammen**.

Wenn ein Angreifer eine bösartige Aktivität an die **Wurzel** dieses Stacks platzieren kann, wird jedes Mal, wenn das Opfer die legitime Anwendung öffnet, die bösartige Benutzeroberfläche das Erste sein, was der Benutzer sieht – perfekt für Phishing oder missbräuchliche Berechtigungsanfragen.

Die Angriffsfläche ist breiter, als viele Entwickler denken, da **jede Aktivität automatisch eine Affinität erbt, die dem Anwendungs-Paketnamen entspricht** (es sei denn, der Entwickler setzt `android:taskAffinity=""`). Daher lässt *nichts zu tun* die App bereits für Task-Hijacking auf Android-Versionen vor 11 offen.

### Klassisches "singleTask / StrandHogg"-Szenario

1. Der Angreifer erklärt eine Aktivität mit:
```xml
<activity android:name=".EvilActivity"
android:exported="true"
android:taskAffinity="com.victim.package"
android:launchMode="singleTask" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
2. Die bösartige App wird einmal gestartet, sodass die Task (mit der gefälschten Affinität) in den letzten Aufgaben existiert.
3. Wenn der Benutzer später die echte Anwendung öffnet, stellt Android fest, dass es bereits eine Task gibt, deren **Wurzel-Affinität mit dem Paket übereinstimmt**, und bringt einfach diese Task in den Vordergrund.
4. Die Benutzeroberfläche des Angreifers wird zuerst angezeigt.

### Standard-Affinitätsvariante (kein `singleTask`) – Caller ID Fallstudie

Die in der **Caller ID (caller.id.phone.number.block)** Anwendung gemeldete Schwachstelle zeigt, dass der Angriff *auch* gegen den Standard-`standard`-Startmodus funktioniert:

1. Die Angreiferanwendung erstellt eine gefälschte Wurzelaktivität und versteckt sich sofort:
```kotlin
class HackActivity : AppCompatActivity() {
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
moveTaskToBack(true)   // halte die Task in den letzten, aber aus dem Sichtfeld
}
}
```
2. Das Manifest muss nur das Paket des Opfers in `taskAffinity` kopieren:
```xml
<activity android:name=".HackActivity"
android:exported="true"
android:taskAffinity="com.caller.id.phone.number.block" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
3. Sobald der Benutzer die bösartige App **einmal** installiert und geöffnet hat, existiert eine Task, deren Affinität dem Paket des Opfers entspricht (aber im Hintergrund sitzt).
4. Wenn die echte Caller ID-Anwendung gestartet wird, verwendet Android diese Task erneut und bringt `HackActivity` in den Vordergrund → Phishing-Fenster/Berechtigungsmissbrauch.

> HINWEIS: Ab **Android 11 (API 30)** platziert das System *nicht* standardmäßig zwei Pakete, die nicht Teil derselben UID sind, in dieselbe Task, wodurch diese spezielle Variante gemildert wird. Ältere Versionen bleiben anfällig.

---

## Erkennungs- & Ausnutzungscheckliste

1. Ziehen Sie `AndroidManifest.xml` aus der Ziel-APK und überprüfen Sie, ob jede `<activity>` (oder das globale `<application>`-Element) `android:taskAffinity=""` (leer) **oder** einen benutzerdefinierten Wert enthält.
2. Wenn nicht, erstellen Sie eine bösartige App:
- `android:taskAffinity` = Paketname des Opfers.
- Stellen Sie einen `MAIN/LAUNCHER`-Intent bereit, damit der Benutzer sie einmal öffnen kann.
- Optional `moveTaskToBack(true)` aufrufen, um sofort zu verstecken.
3. Lassen Sie das Opfer ihre legitime Anwendung öffnen → hijacken.

## Minderung

Entwickler sollten:

* `android:taskAffinity=""` auf Anwendungsebene (empfohlen) **oder** jeder Aktivität eine einzigartige, private Affinität zuweisen.
* Für hochsensible Bildschirme die obigen Punkte mit `android:launchMode="singleInstance"` oder modernen [`setLaunchMode`](https://developer.android.com/reference/android/content/pm/ActivityInfo#launchMode) -Schutzmaßnahmen kombinieren.
* Die `targetSdkVersion` der App aktualisieren und die **Android 11**-Verhaltensänderungen durchsetzen, bei denen Tasks standardmäßig nicht über Pakete hinweg geteilt werden.

---

## Referenzen

- [https://blog.dixitaditya.com/android-task-hijacking/](https://blog.dixitaditya.com/android-task-hijacking/)
- [https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html](https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html)
- [Android Manifest Misconfiguration Leading to Task Hijacking in Caller ID app](https://github.com/KMov-g/androidapps/blob/main/caller.id.phone.number.block.md)
- [https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06](https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06)

{{#include ../../banners/hacktricks-training.md}}
