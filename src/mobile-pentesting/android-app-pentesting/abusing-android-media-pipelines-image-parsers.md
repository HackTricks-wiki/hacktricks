# Abusando das Media Pipelines e Image Parsers do Android

{{#include ../../banners/hacktricks-training.md}}

## Entrega: Apps de Mensagens ➜ MediaStore ➜ parsers privilegiados

Builds OEM modernas executam regularmente indexadores de mídia privilegiados que reescaneiam o `MediaStore` para recursos de "AI" ou compartilhamento. No firmware da Samsung anterior ao patch de abril de 2025, `com.samsung.ipservice` carrega Quram (`/system/lib64/libimagecodec.quram.so`) e analisa automaticamente qualquer arquivo que o WhatsApp (ou outros apps) coloque no `MediaStore`. Na prática, um atacante pode enviar um DNG disfarçado como `IMG-*.jpg`, esperar a vítima tocar em "download" (1-click), e o serviço privilegiado irá analisar o payload mesmo que o usuário nunca abra a galeria.
```bash
$ file IMG-2025-02-10.jpeg
TIFF image data ...
$ exiftool IMG-2025-02-10.jpeg | grep "Opcode List"
Opcode List 1 : [opcode 23], [opcode 23], ...
```
**Principais conclusões**
- A entrega depende da re-análise de mídia do sistema (não do cliente de chat) e, portanto, herda as permissões desse processo (acesso total de leitura/gravação à galeria, capacidade de salvar nova mídia, etc.).
- Qualquer image parser acessível via `MediaStore` (vision widgets, wallpapers, recursos de AI résumé, etc.) torna-se alcançável remotamente se o atacante conseguir convencer a vítima a salvar mídia.

## Quram's DNG Opcode Interpreter Bugs

Arquivos DNG incorporam três listas de opcodes aplicadas em diferentes estágios de decodificação. Quram copia a API da Adobe, mas seu handler de Stage-3 para `DeltaPerColumn` (opcode ID 11) confia em limites de plane fornecidos pelo atacante.

### Failing plane bounds in `DeltaPerColumn`
- Atacantes definem `plane=5125` e `planes=5123` mesmo que imagens Stage-3 exponham apenas planes 0–2 (RGB).
- Quram calcula `opcode_last_plane = image_planes + opcode_planes` em vez de `plane + count`, e nunca verifica se o intervalo de planes resultante cabe dentro da imagem.
- O loop, portanto, escreve um delta em `raw_pixel_buffer[plane_index]` com um deslocamento totalmente controlado (por exemplo, plane 5125 ⇒ deslocamento `5125 * 2 bytes/pixel = 0x2800`). Cada opcode adiciona um valor float de 16-bit (0x6666) ao local alvo, gerando uma primitiva precisa de adição OOB no heap.

### Turning increments into arbitrary writes
- O exploit primeiro corrompe `QuramDngImage.bottom/right` do Stage-3 usando 480 operações `DeltaPerColumn` malformadas para que opcodes futuros tratem coordenadas enormes como válidas.
- Opcodes `MapTable` (opcode 7) são então direcionados a esses limites falsos. Usando uma tabela de substituição de todos zeros ou um `DeltaPerColumn` com deltas `-Inf`, o atacante zera qualquer região e depois aplica deltas adicionais para escrever valores exatos.
- Como os parâmetros do opcode vivem dentro dos metadados DNG, o payload pode codificar centenas de milhares de escritas sem tocar diretamente a memória do processo.

## Heap Shaping Under Scudo

Scudo agrupa alocações por tamanho. Quram aloca os seguintes objetos com tamanhos de chunk idênticos de 0x30 bytes, então eles caem na mesma região (espaçamento de 0x40 bytes no heap):
- descritores `QuramDngImage` para Stage 1/2/3
- `QuramDngOpcodeTrimBounds` e opcodes vendor `Unknown` (ID ≥14, incluindo ID 23)

O exploit sequencia alocações para posicionar chunks de forma determinística:
1. Stage-1 `Unknown(23)` opcodes (20.000 entradas) pulverizam chunks de 0x30 que depois são liberados.
2. Stage-2 libera esses opcodes e coloca um novo `QuramDngImage` dentro da região liberada.
3. 240 entradas Stage-2 `Unknown(23)` são liberadas, e Stage-3 aloca imediatamente seu `QuramDngImage` mais um novo raw pixel buffer do mesmo tamanho, reutilizando esses espaços.
4. Um `TrimBounds` forjado roda primeiro na lista 3 e aloca mais um raw pixel buffer antes de liberar o estado do Stage-2, garantindo adjacência "raw pixel buffer ➜ QuramDngImage".
5. 640 entradas adicionais `TrimBounds` são marcadas com `minVersion=1.4.0.1` para que o dispatcher as pule, mas seus objetos de backing ficam alocados e depois se tornam alvos primitivos.

Essa coreografia coloca o raw buffer do Stage-3 imediatamente antes do `QuramDngImage` do Stage-3, de modo que o overflow baseado em plane inverte campos dentro do descritor em vez de travar estado aleatório.

## Reusing Vendor "Unknown" Opcodes as Data Blobs

A Samsung deixa o high bit set em IDs de opcode específicos do vendor (ex.: ID 23), o que instrui o interpreter a alocar a estrutura mas pular a execução. O exploit abusa desses objetos dormentes como heaps controlados pelo atacante:
- Entradas `Unknown(23)` nas listas 1 e 2 servem como scratchpads contíguos para armazenar bytes do payload (JOP chain em offset 0xf000 e um shell command em 0x10000 relativo ao raw buffer).
- Porque o interpreter ainda trata cada objeto como um opcode quando a lista 3 é processada, tomar controle do vtable de um objeto depois é suficiente para começar a executar dados do atacante.

## Crafting Bogus `MapTable` Objects & Bypassing ASLR

Objetos `MapTable` são maiores que `TrimBounds`, mas uma vez que a corrupção do layout acontece, o parser felizmente lê parâmetros extras fora dos limites:
1. Use a primitiva de escrita linear para sobrescrever parcialmente um ponteiro de vtable de `TrimBounds` com uma tabela de substituição `MapTable` forjada que mapeia os 2 bytes inferiores do vtable de um `TrimBounds` vizinho para o vtable do `MapTable`. Apenas os bytes baixos diferem entre builds Quram suportados, então uma única tabela de lookup de 64K pode cobrir sete versões de firmware e todo slide de 4 KB do ASLR.
2. Patche o resto dos campos de `TrimBounds` (top/left/width/planes) para que o objeto se comporte como um `MapTable` válido quando executado depois.
3. Execute o opcode falso sobre memória zerada. Porque o ponteiro da tabela de substituição referencia, na verdade, o vtable de outro opcode, os bytes de saída se tornam *leaked* low-order addresses de `libimagecodec.quram.so` ou seu GOT.
4. Aplique passes adicionais de `MapTable` para converter esses leaks de dois bytes em offsets apontando para gadgets como `__ink_jpeg_enc_process_image+64`, `QURAMWINK_Read_IO2+124`, `qpng_check_IHDR+624`, e a entrada de libc `__system_property_get`. Os atacantes essencialmente reconstróem endereços completos dentro de sua região pulverizada de opcodes sem APIs nativas de divulgação de memória.

## Triggering the JOP ➜ `system()` Transition

Uma vez que os ponteiros de gadget e o shell command estão no spray de opcodes:
1. Uma onda final de `DeltaPerColumn` writes adiciona `0x0100` ao offset 0x22 do `QuramDngImage` do Stage-3, deslocando seu ponteiro de raw buffer por 0x10000 de modo que agora referencia a string do comando do atacante.
2. O interpreter começa a executar o tail de 1040 opcodes `Unknown(23)`. A primeira entrada corrompida teve seu vtable substituído pela tabela forjada no offset 0xf000, então `QuramDngOpcode::aboutToApply` resolve `qpng_read_data` (a 4ª entrada) a partir da tabela falsa.
3. Os gadgets encadeados executam: carregar o ponteiro `QuramDngImage`, adicionar 0x20 para apontar ao ponteiro do raw buffer, desreferenciá-lo, copiar o resultado para `x19/x0`, então pular através de slots GOT reescritos para `system`. Porque o ponteiro do raw buffer agora aponta para a string do atacante, o gadget final executa `system(<shell command>)` dentro de `com.samsung.ipservice`.

## Notes on Allocator Variants

Existem duas famílias de payloads: uma afinada para jemalloc, outra para scudo. Elas diferem em como os blocos de opcode são ordenados para alcançar adjacência, mas compartilham as mesmas primitivas lógicas (DeltaPerColumn bug ➜ MapTable zero/write ➜ bogus vtable ➜ JOP). A quarantine desabilitada do Scudo torna a reutilização de freelist de 0x30 bytes determinística, enquanto jemalloc depende do controle de classes de tamanho via tile/subIFD sizing.

## References

- [Project Zero – A look at an Android ITW DNG exploit](https://projectzero.google/2025/12/android-itw-dng.html)

{{#include ../../banners/hacktricks-training.md}}
