# Androidのメディアパイプラインと画像パーサの悪用

{{#include ../../banners/hacktricks-training.md}}

## 配信: メッセージングアプリ ➜ MediaStore ➜ 特権パーサ

最近のOEMビルドでは、"AI"や共有機能のために`MediaStore`を再スキャンする特権メディアインデクサが定期的に実行されています。2025年4月のパッチ以前のSamsungファームウェアでは、`com.samsung.ipservice`がQuram（`/system/lib64/libimagecodec.quram.so`）をロードし、WhatsApp（や他のアプリ）が`MediaStore`に置いたファイルを自動的に解析します。実際には、攻撃者はDNGを`IMG-*.jpg`に偽装して送信し、被害者が「ダウンロード」をタップする（1クリック）のを待つだけで、ユーザーがギャラリーを開かなくても特権サービスがペイロードを解析します。
```bash
$ file IMG-2025-02-10.jpeg
TIFF image data ...
$ exiftool IMG-2025-02-10.jpeg | grep "Opcode List"
Opcode List 1 : [opcode 23], [opcode 23], ...
```
**主なポイント**
- 配信はシステムのメディア再解析（チャットクライアントではなく）に依存しており、そのためそのプロセスの権限（ギャラリーへの完全な読み書きアクセス、新しいメディアを配置する能力など）を継承する。
- `MediaStore` を通じて到達可能な任意の画像パーサー（vision widgets、wallpapers、AI résumé 機能など）は、攻撃者がターゲットにメディアを保存させられればリモートから到達可能になる。

## Quram's DNG Opcode Interpreter Bugs

DNG ファイルはデコードの異なる段階で適用される3つの opcode リストを埋め込む。Quram は Adobe の API を模倣しているが、Stage-3 ハンドラの `DeltaPerColumn`（opcode ID 11）は攻撃者が提供する plane bounds を信用してしまう。

### `DeltaPerColumn` における plane bounds の不備
- 攻撃者は Stage-3 画像が露出する plane が 0–2（RGB）であるにもかかわらず `plane=5125` と `planes=5123` を設定する。
- Quram は `opcode_last_plane = image_planes + opcode_planes` を計算し、`plane + count` を使わず、結果として得られた plane 範囲が画像内に収まるかどうかをチェックしない。
- そのループは結果として `raw_pixel_buffer[plane_index]` に対して完全に制御されたオフセット（例: plane 5125 ⇒ オフセット `5125 * 2 bytes/pixel = 0x2800`）でデルタを書き込む。各 opcode は対象箇所に 16-bit float 値（0x6666）を加算するため、正確な heap OOB add primitive を実現する。

### インクリメントを任意書き込みに変える方法
- エクスプロイトはまず 480 個の不正な `DeltaPerColumn` 操作で Stage-3 の `QuramDngImage.bottom/right` を破壊し、将来の opcode が巨大な座標を in-bounds と扱うようにする。
- その後 `MapTable` opcodes（opcode 7）を偽の境界に向ける。全ゼロの置換テーブルか `DeltaPerColumn` で `-Inf` のデルタを使うことで、攻撃者は任意領域をゼロ化し、さらに追加のデルタを適用して正確な値を書き込む。
- opcode パラメータは DNG メタデータ内に存在するため、ペイロードはプロセスメモリに直接触れずに何十万もの書き込みをエンコードできる。

## Heap Shaping Under Scudo

Scudo はサイズ別に割り当てをバケット化する。Quram は偶然にも以下のオブジェクトを同一の 0x30 バイトチャンクサイズで割り当てるため、同一領域（ヒープ上では 0x40 バイト間隔）に並ぶ:
- Stage 1/2/3 用の `QuramDngImage` ディスクリプタ
- `QuramDngOpcodeTrimBounds` とベンダーの `Unknown` opcodes（ID ≥14、ID 23 を含む）

エクスプロイトは次の順で割り当てを操作してチャンクを決定論的に配置する:
1. Stage-1 の `Unknown(23)` opcode（20,000 エントリ）で 0x30 チャンクをスプレーし、後で解放されるようにする。
2. Stage-2 がそれらの opcode を解放し、解放領域内に新しい `QuramDngImage` を配置する。
3. Stage-2 の `Unknown(23)` 240 エントリを解放し、Stage-3 が直ちにその場所を再利用して自身の `QuramDngImage` と同サイズの新しい raw pixel buffer を割り当てる。
4. 細工した `TrimBounds` opcode がリスト3で最初に動作し、Stage-2 状態を解放する前にさらに別の raw pixel buffer を割り当てることで、常に「raw pixel buffer ➜ QuramDngImage」の隣接を保証する。
5. 追加の 640 個の `TrimBounds` エントリは `minVersion=1.4.0.1` に設定されディスパッチャがスキップするが、その裏でのオブジェクトは割り当てられたまま残り、後にプリミティブのターゲットになる。

この手順により Stage-3 の raw buffer が Stage-3 `QuramDngImage` の直前に置かれるため、plane ベースのオーバーフローはランダムにクラッシュさせるのではなく、ディスクリプタ内部のフィールドを反転させる。

## ベンダーの "Unknown" Opcodes をデータ領域として再利用する

Samsung はベンダー固有 opcode ID の上位ビットをセットしたままにしておく（例: ID 23）。これによりインタプリタはその構造体を *allocate* するが実行はスキップする。エクスプロイトはその休止したオブジェクトを攻撃者制御のヒープとして悪用する:
- opcode リスト 1 と 2 の `Unknown(23)` エントリは、ペイロードバイトの格納用に連続したスクラッチパッドとして機能する（raw buffer に対する相対オフセット 0xf000 に JOP チェイン、0x10000 にシェルコマンドなど）。
- リスト3 が処理される際にもインタプリタは各オブジェクトを opcode として扱うため、後であるオブジェクトの vtable を乗っ取れば攻撃者データの実行を開始できる。

## 偽の `MapTable` オブジェクトを作成して ASLR を回避する

`MapTable` オブジェクトは `TrimBounds` より大きいが、レイアウト破壊が当たるとパーサは喜んで範囲外の追加パラメータを読み込む:
1. 線形書き込みプリミティブを使い、`TrimBounds` の vtable ポインタの低位バイトを近傍の `TrimBounds` vtable から `MapTable` vtable へ対応付けるような偽の MapTable 置換テーブルで部分上書きする。サポートされる Quram ビルド間では低位バイトのみが異なるため、単一の 64K ルックアップテーブルで7つのファームウェアバージョンと全ての 4 KB ASLR スライドに対応できる。
2. その後 `TrimBounds` の残りのフィールド（top/left/width/planes）をパッチして、後で実行されたときにオブジェクトが有効な `MapTable` として振る舞うようにする。
3. ゼロ化されたメモリ上で偽 opcode を実行する。置換テーブルポインタが実際には別の opcode の vtable を参照しているため、出力バイトは `libimagecodec.quram.so` またはその GOT からの低位アドレスを *leaked* する。
4. 追加の `MapTable` パスを適用して、これらの2バイトの leak を `__ink_jpeg_enc_process_image+64`、`QURAMWINK_Read_IO2+124`、`qpng_check_IHDR+624`、および libc の `__system_property_get` エントリのようなガジェットへのオフセットに変換する。攻撃者はネイティブなメモリ開示 API を使わずにスプレーした opcode 領域内で完全なアドレスを再構築できる。

## JOP ➜ `system()` への遷移を引き起こす

ガジェットポインタとシェルコマンドが opcode スプレー内に配置されると:
1. 最終波の `DeltaPerColumn` 書き込みが Stage-3 `QuramDngImage` のオフセット 0x22 に `0x0100` を加え、その raw buffer ポインタを 0x10000 シフトさせて攻撃者のコマンド文字列を参照させる。
2. インタプリタは 1040 個の `Unknown(23)` opcode の末尾を実行し始める。最初に破壊されたエントリはオフセット 0xf000 にある偽テーブルで vtable を置換されているため、`QuramDngOpcode::aboutToApply` は偽テーブルの 4 番目のエントリである `qpng_read_data` を解決する。
3. チェインされたガジェットは次を実行する: `QuramDngImage` ポインタをロードし、raw buffer ポインタを指すために 0x20 を加算し、それをデリファレンスして結果を `x19/x0` にコピーし、GOT スロットを `system` に書き換えた先へジャンプする。raw buffer ポインタが攻撃者文字列を指しているため、最終的なガジェットは `com.samsung.ipservice` 内で `system(<shell command>)` を実行する。

## アロケータのバリアントに関する注記

ペイロードは2ファミリが存在する: jemalloc 向けに調整されたものと scudo 向けのもの。これらは隣接を達成するための opcode ブロックの並び順が異なるが、同じ論理プリミティブ（DeltaPerColumn バグ ➜ MapTable zero/write ➜ 偽 vtable ➜ JOP）を共有する。Scudo の隔離無効化は 0x30 バイト freelist の再利用を決定論的にし、jemalloc は tile/subIFD サイズによるサイズクラス制御に依存する。

## References

- [Project Zero – A look at an Android ITW DNG exploit](https://projectzero.google/2025/12/android-itw-dng.html)

{{#include ../../banners/hacktricks-training.md}}
