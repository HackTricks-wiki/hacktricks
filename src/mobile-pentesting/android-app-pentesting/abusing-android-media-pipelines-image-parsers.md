# Sfruttamento delle pipeline multimediali Android e dei parser di immagini

{{#include ../../banners/hacktricks-training.md}}

## Consegna: App di messaggistica ➜ `MediaStore` ➜ parser privilegiati

Le build OEM moderne eseguono regolarmente indicizzatori multimediali privilegiati che riesaminano `MediaStore` per funzionalità di "AI" o di condivisione. Su firmware Samsung anteriori alla patch di aprile 2025, `com.samsung.ipservice` carica Quram (`/system/lib64/libimagecodec.quram.so`) e analizza automaticamente qualsiasi file che WhatsApp (o altre app) inserisce in `MediaStore`. In pratica un attacker può inviare un DNG camuffato da `IMG-*.jpg`, attendere che la vittima tocchi "download" (1-click), e il servizio privilegiato analizzerà il payload anche se l'utente non apre mai la galleria.
```bash
$ file IMG-2025-02-10.jpeg
TIFF image data ...
$ exiftool IMG-2025-02-10.jpeg | grep "Opcode List"
Opcode List 1 : [opcode 23], [opcode 23], ...
```
**Punti chiave**
- La delivery si basa sul re-parsing dei media di sistema (non sul client di chat) e quindi eredita i permessi di quel processo (accesso completo in lettura/scrittura alla galleria, capacità di depositare nuovi media, ecc.).
- Qualsiasi image parser raggiungibile tramite `MediaStore` (widget di visione, wallpapers, funzionalità AI per i résumé, ecc.) diventa raggiungibile da remoto se l'attaccante convince la vittima a salvare media.

## Bug dell'interprete degli opcode DNG di Quram

I file DNG incorporano tre liste di opcode applicate in fasi di decodifica differenti. Quram copia l'API di Adobe, ma il suo handler di Stage-3 per `DeltaPerColumn` (opcode ID 11) si fida di bound dei piani forniti dall'attaccante.

### Limiti di plane non verificati in `DeltaPerColumn`
- Gli attaccanti impostano `plane=5125` e `planes=5123` anche se le immagini Stage-3 espongono solo piani 0–2 (RGB).
- Quram calcola `opcode_last_plane = image_planes + opcode_planes` invece di `plane + count`, e non verifica mai se l'intervallo di piani risultante rientra nell'immagine.
- Il loop quindi scrive un delta in `raw_pixel_buffer[plane_index]` con un offset completamente controllato (es., plane 5125 ⇒ offset `5125 * 2 bytes/pixel = 0x2800`). Ogni opcode aggiunge un valore float a 16-bit (0x6666) alla posizione mirata, ottenendo un primitivo OOB add preciso sull'heap.

### Trasformare gli incrementi in scritture arbitrarie
- L'exploit prima corrompe `QuramDngImage.bottom/right` di Stage-3 usando 480 operazioni `DeltaPerColumn` malformate così che gli opcode futuri trattino coordinate enormi come in-bound.
- Gli opcode `MapTable` (opcode 7) vengono poi puntati verso quei bound falsi. Usando una tabella di sostituzione tutta zero o un `DeltaPerColumn` con delta `-Inf`, l'attaccante azzera qualsiasi regione, quindi applica delta aggiuntivi per scrivere valori esatti.
- Poiché i parametri degli opcode risiedono dentro i metadata DNG, il payload può codificare centinaia di migliaia di scritture senza toccare direttamente la memoria del processo.

## Modellazione dell'heap sotto Scudo

Scudo raggruppa le allocazioni per dimensione. Quram per caso alloca i seguenti oggetti con identiche chunk da 0x30 byte, quindi finiscono nella stessa regione (spaziatura di 0x40 byte sull'heap):
- `QuramDngImage` descriptors per Stage 1/2/3
- `QuramDngOpcodeTrimBounds` e opcode vendor `Unknown` (ID ≥14, incluso ID 23)

L'exploit sequenzia le allocazioni per posizionare i chunk in modo deterministico:
1. Opzioni Stage-1 `Unknown(23)` (20.000 voci) spruzzano chunk da 0x30 che vengono poi freed.
2. Stage-2 libera quegli opcode e piazza un nuovo `QuramDngImage` nella regione liberata.
3. 240 voci Stage-2 `Unknown(23)` vengono freed, e Stage-3 alloca immediatamente il suo `QuramDngImage` più un nuovo raw pixel buffer della stessa dimensione, riutilizzando quegli slot.
4. Un `TrimBounds` appositamente costruito viene eseguito per primo nella lista 3 e alloca un altro raw pixel buffer prima di liberare lo stato di Stage-2, garantendo l'adjacenza "raw pixel buffer ➜ QuramDngImage".
5. 640 voci `TrimBounds` aggiuntive sono marcate `minVersion=1.4.0.1` così il dispatcher le salta, ma i loro oggetti di backing rimangono allocati e diventano poi bersagli primitivi.

Questa coreografia pone il raw buffer di Stage-3 immediatamente prima del `QuramDngImage` di Stage-3, così l'overflow basato sui piani inverte campi dentro il descrittore invece di far crashare stato casuale.

## Riutilizzo degli opcode vendor "Unknown" come data blob

Samsung lascia il bit alto impostato negli ID degli opcode vendor-specific (es., ID 23), il che istruisce l'interprete ad allocare la struttura ma a saltarne l'esecuzione. L'exploit abusa di quegli oggetti dormienti come heap controllati dall'attaccante:
- Le voci `Unknown(23)` nelle liste di opcode 1 e 2 fungono da scratchpad contiguo per memorizzare byte del payload (JOP chain a offset 0xf000 e un comando shell a 0x10000 relativo al raw buffer).
- Poiché l'interprete tratta ancora ogni oggetto come un opcode quando la lista 3 viene processata, conquistare la vtable di un oggetto è poi sufficiente per iniziare a eseguire dati controllati dall'attaccante.

## Creazione di oggetti `MapTable` fasulli & bypass di ASLR

Gli oggetti `MapTable` sono più grandi di `TrimBounds`, ma una volta che la corruzione del layout avviene, il parser legge volentieri parametri extra out-of-bounds:
1. Usa il primitivo di scrittura lineare per sovrascrivere parzialmente un puntatore vtable di `TrimBounds` con una tabella di sostituzione `MapTable` costruita che mappa i 2 byte inferiori dalla vtable di un `TrimBounds` vicino alla vtable di `MapTable`. Solo i byte bassi differiscono tra i build Quram supportati, quindi una singola lookup table da 64K può gestire sette versioni firmware e ogni slide ASLR di 4 KB.
2. Patcha il resto dei campi di `TrimBounds` (top/left/width/planes) così l'oggetto si comporta come un `MapTable` valido quando verrà eseguito più tardi.
3. Esegui l'opcode fasullo su memoria azzerata. Poiché il puntatore della substitution table in realtà referenzia la vtable di un altro opcode, gli output bytes diventano *leaked* indirizzi a basso ordine da `libimagecodec.quram.so` o dalla sua GOT.
4. Applica ulteriori passate `MapTable` per convertire quei leak a due byte in offset verso gadget come `__ink_jpeg_enc_process_image+64`, `QURAMWINK_Read_IO2+124`, `qpng_check_IHDR+624`, e la entry di libc `__system_property_get`. Gli attaccanti ricostruiscono efficacemente indirizzi completi dentro la regione di opcode spruzzata senza API di disclosure native della memoria.

## Scatenare la transizione JOP ➜ `system()`

Una volta che i puntatori ai gadget e il comando shell sono piazzati dentro lo spray di opcode:
1. Un'ultima ondata di scritture `DeltaPerColumn` aggiunge `0x0100` all'offset 0x22 del `QuramDngImage` di Stage-3, spostando il suo puntatore al raw buffer di 0x10000 così che ora punta alla stringa di comando dell'attaccante.
2. L'interprete inizia a eseguire la coda di 1040 opcode `Unknown(23)`. La prima voce corrotta ha la sua vtable sostituita con la tabella forgiata a offset 0xf000, quindi `QuramDngOpcode::aboutToApply` risolve `qpng_read_data` (la 4ª voce) dalla tabella fasulla.
3. I gadget concatenati eseguono: caricano il puntatore `QuramDngImage`, aggiungono 0x20 per puntare al puntatore del raw buffer, dereferenziano, copiano il risultato in `x19/x0`, quindi saltano attraverso slot GOT riscritti a `system`. Poiché il puntatore del raw buffer ora equivale alla stringa dell'attaccante, l'ultimo gadget esegue `system(<shell command>)` dentro `com.samsung.ipservice`.

## Note sulle varianti dell'allocator

Esistono due famiglie di payload: una tarata per jemalloc, un'altra per scudo. Differiscono nell'ordine dei blocchi di opcode per ottenere l'adjacenza ma condividono gli stessi primitivi logici (bug DeltaPerColumn ➜ MapTable zero/write ➜ vtable fasulla ➜ JOP). La quarantine disabilitata di Scudo rende il riuso del freelist da 0x30 byte deterministico, mentre jemalloc fa affidamento sul controllo della size-class tramite il dimensionamento di tile/subIFD.

## Riferimenti

- [Project Zero – A look at an Android ITW DNG exploit](https://projectzero.google/2025/12/android-itw-dng.html)

{{#include ../../banners/hacktricks-training.md}}
