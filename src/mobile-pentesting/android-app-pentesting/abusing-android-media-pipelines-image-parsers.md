# Android Medya Boru Hatları ve Görüntü Ayrıştırıcılarının Kötüye Kullanımı

{{#include ../../banners/hacktricks-training.md}}

## Teslimat: Mesajlaşma Uygulamaları ➜ MediaStore ➜ Ayrıcalıklı Ayrıştırıcılar

Modern OEM build'ları düzenli olarak "AI" veya paylaşım özellikleri için `MediaStore`'u yeniden tarayan ayrıcalıklı medya indeksleyicileri çalıştırır. Nisan 2025 yamasından önceki Samsung firmware'lerinde `com.samsung.ipservice` Quram (`/system/lib64/libimagecodec.quram.so`) yükler ve WhatsApp (veya diğer uygulamaların) `MediaStore`'a bıraktığı herhangi bir dosyayı otomatik olarak ayrıştırır. Pratikte bir saldırgan `IMG-*.jpg` olarak gizlenmiş bir DNG gönderebilir, kurbanın "download" seçeneğine (1-click) dokunmasını bekleyebilir ve kullanıcı galeriyi hiç açmasa bile ayrıcalıklı service payload'u ayrıştıracaktır.
```bash
$ file IMG-2025-02-10.jpeg
TIFF image data ...
$ exiftool IMG-2025-02-10.jpeg | grep "Opcode List"
Opcode List 1 : [opcode 23], [opcode 23], ...
```
**Önemli çıkarımlar**
- Teslimat sistem medya yeniden-parsing'ine dayanır (`chat client` değil) ve bu nedenle o işlemin izinlerini devralır (galeriye tam okuma/yazma erişimi, yeni medya bırakma yeteneği vb.).
- Bir saldırgan hedefi medyayı kaydetmeye ikna edebilirse, `MediaStore` üzerinden erişilebilen herhangi bir görüntü ayrıştırıcısı (vision widgets, duvar kağıtları, AI résumé özellikleri vb.) uzaktan erişilebilir hale gelir.

## Quram's DNG Opcode Interpreter Bugs

DNG dosyaları farklı decode aşamalarında uygulanan üç opcode listesi içerir. Quram Adobe'un API'sini kopyalar, ancak Stage-3 için `DeltaPerColumn` (opcode ID 11) işleyicisi saldırgan tarafından sağlanan plane sınırlarına güvenir.

### `DeltaPerColumn` içinde hatalı plane sınırları
- Saldırganlar `plane=5125` ve `planes=5123` ayarlar, oysa Stage-3 görüntüleri yalnızca 0–2 (RGB) plane'lerini açığa çıkarır.
- Quram `opcode_last_plane = image_planes + opcode_planes` hesaplaması yapar, `plane + count` yerine, ve oluşan plane aralığının görüntü içine sığıp sığmadığını asla kontrol etmez.
- Bu nedenle döngü, tamamen kontrol edilebilen bir offset ile `raw_pixel_buffer[plane_index]` öğesine bir delta yazar (ör. plane 5125 ⇒ offset `5125 * 2 bytes/pixel = 0x2800`). Her opcode hedeflenen konuma 16-bit float değer (0x6666) ekler ve bu hassas bir heap OOB add primitive'i sağlar.

### Artışları keyfi yazılara çevirme
- Exploit, gelecekteki opcode'ların devasa koordinatları in-bounds olarak kabul etmesi için 480 bozuk `DeltaPerColumn` işlemi kullanarak Stage-3 `QuramDngImage.bottom/right` öğesini önce bozar.
- Ardından bu sahte sınırlara `MapTable` opcode'ları (opcode 7) yönlendirilir. Tamamı sıfır olan bir substitution table veya `-Inf` delta içeren bir `DeltaPerColumn` kullanılarak saldırgan herhangi bir bölgeyi sıfırlar, sonra tam değerleri yazmak için ek deltalara uygular.
- Opcode parametreleri DNG metadata içinde bulunduğundan, payload process belleğine doğrudan dokunmadan yüzbinlerce yazma işlemini kodlayabilir.

## Heap Shaping Under Scudo

Scudo tahsisleri boyuta göre bucket'lara ayırır. Quram aşağıdaki nesneleri aynı 0x30-byte chunk boyutlarıyla tahsis eder, bu yüzden aynı bölgede (heap'te 0x40-byte aralıklarla) yer alırlar:
- `QuramDngImage` descriptor'ları Stage 1/2/3 için
- `QuramDngOpcodeTrimBounds` ve vendor `Unknown` opcode'ları (ID ≥14, ID 23 dahil)

Exploit, chunk'ları deterministik olarak yerleştirmek için tahsisleri şu sırayla düzenler:
1. Stage-1 `Unknown(23)` opcode'ları (20.000 giriş) 0x30 chunk'ları spreylayarak oluşturur; bunlar daha sonra free edilir.
2. Stage-2 bu opcode'ları free eder ve freed bölgenin içine yeni bir `QuramDngImage` yerleştirir.
3. 240 Stage-2 `Unknown(23)` girişi free edilir ve Stage-3 hemen kendi `QuramDngImage`'ini ve aynı boyutta yeni bir raw pixel buffer tahsis ederek bu alanları yeniden kullanır.
4. List 3'te özel hazırlanmış bir `TrimBounds` opcode'u ilk çalışır ve Stage-2 durumunu free etmeden önce bir raw pixel buffer daha tahsis eder; böylece "raw pixel buffer ➜ QuramDngImage" komşuluğu garantilenir.
5. Ek 640 `TrimBounds` girişi `minVersion=1.4.0.1` olarak işaretlenir, böylece dispatcher onları atlar; ancak bunların backing object'leri tahsisli kalır ve daha sonra primitive hedefler haline gelir.

Bu koreografi Stage-3 raw buffer'ını Stage-3 `QuramDngImage`'in hemen önüne yerleştirir; böylece plane tabanlı overflow descriptor içindeki alanları değiştirir, rastgele durumu çökertmek yerine.

## Reusing Vendor "Unknown" Opcodes as Data Blobs

Samsung vendor-özel opcode ID'lerinde yüksek biti setli bırakır (ör. ID 23); bu, yorumlayıcıya yapıyı *allocate* etmesini ama yürütmeyi atlamasını söyler. Exploit bu uyuyan nesneleri saldırgan-kontrollü heap'ler olarak suiistimal eder:
- Opcode liste 1 ve 2'deki `Unknown(23)` girdileri payload byte'larını depolamak için bitişik scratchpad'lar olarak hizmet eder (raw buffer'a göre offset 0xf000'de JOP zinciri ve 0x10000'de bir shell komutu).
- Çünkü yorumlayıcı liste 3 işlendiğinde hâlâ her nesneyi opcode olarak görüyor, bir nesnenin vtable'ını ele geçirmek daha sonra saldırgan verilerini yürütmek için yeterli olur.

## Crafting Bogus `MapTable` Objects & Bypassing ASLR

`MapTable` nesneleri `TrimBounds`'dan daha büyük, ancak layout bozulması gerçekleştiğinde parser memnuniyetle ekstra parametreleri out-of-bounds okur:
1. Lineer write primitive'ini kullanarak bir `TrimBounds` vtable işaretçisini kısmen üzerine yazın; yazılan veri, komşu bir `TrimBounds` vtable'ının düşük 2 byte'ını `MapTable` vtable'ına eşleyen hazırlanmış bir `MapTable` substitution table olur. Desteklenen Quram build'leri arasında yalnızca düşük byte'lar farklı olduğundan tek bir 64K lookup table yedi firmware sürümünü ve her 4 KB ASLR slide'ını kapsayabilir.
2. `TrimBounds` alanlarının geri kalanını (top/left/width/planes) yamayın ki nesne daha sonra yürütüldüğünde geçerli bir `MapTable` gibi davransın.
3. Sahte opcode'u sıfırlanmış bellek üzerinde çalıştırın. Substitution table işaretçisi gerçekte başka bir opcode'un vtable'ına referans verdiği için, çıktı byte'ları `libimagecodec.quram.so` veya onun GOT'undan *leaked* düşük dereceli adresler haline gelir.
4. Ek `MapTable` geçişleri uygulayarak bu iki byte'lık leaks'i `__ink_jpeg_enc_process_image+64`, `QURAMWINK_Read_IO2+124`, `qpng_check_IHDR+624` gibi gadget'lara ve libc'nin `__system_property_get` girişine işaret eden offset'lere dönüştürün. Saldırganlar, native memory disclosure API'larına ihtiyaç duymadan spreylanmış opcode bölgeleri içinde etkili şekilde tam adresleri yeniden oluştururlar.

## Triggering the JOP ➜ `system()` Transition

Gadget işaretçileri ve shell komutu opcode spray içinde hazırlandıktan sonra:
1. Son bir dalga `DeltaPerColumn` yazmaları Stage-3 `QuramDngImage`'in offset 0x22'sine `0x0100` ekler; böylece raw buffer işaretçisi 0x10000 kayar ve artık saldırgan komut dizisini gösterir.
2. Yorumlayıcı 1040 `Unknown(23)` opcode'unun son kısmını yürütmeye başlar. İlk bozulmuş girişin vtable'ı offset 0xf000'deki sahte tablo ile değiştirilmiştir, bu yüzden `QuramDngOpcode::aboutToApply` sahte tablodan `qpng_read_data`'yi (4. giriş) çözer.
3. Zincirlenmiş gadget'lar şunu yapar: `QuramDngImage` işaretçisini yükler, raw buffer işaretçisini göstermek için 0x20 ekler, onu dereference eder, sonucu `x19/x0`'e kopyalar, sonra GOT slot'ları üzerinden `system`'e yazılmış yerlere atlar. Raw buffer işaretçisi artık saldırgan stringine eşit olduğundan, son gadget `com.samsung.ipservice` içinde `system(<shell command>)`'u çalıştırır.

## Notes on Allocator Variants

İki payload ailesi vardır: biri jemalloc için, diğeri scudo için ayarlanmıştır. Adjacency'yi sağlamak için opcode bloklarının sıralanışında farklılık gösterirler fakat aynı mantıksal primitifleri paylaşırlar (DeltaPerColumn bug ➜ MapTable zero/write ➜ bogus vtable ➜ JOP). Scudo'nun devre dışı bırakılmış karantinası 0x30-byte freelist yeniden kullanımını deterministik yaparken, jemalloc tile/subIFD boyutlandırması yoluyla size-class kontrolüne dayanır.

## Referanslar

- [Project Zero – A look at an Android ITW DNG exploit](https://projectzero.google/2025/12/android-itw-dng.html)

{{#include ../../banners/hacktricks-training.md}}
