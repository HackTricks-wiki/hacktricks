# Зловживання Android медіа-пайплайнами & парсерами зображень

{{#include ../../banners/hacktricks-training.md}}

## Доставка: Месенджери ➜ MediaStore ➜ Привілейовані парсери

Сучасні OEM‑збірки регулярно запускають привілейовані індексатори медіа, які перескановують `MediaStore` заради функцій «AI» або функцій обміну. На прошивках Samsung до виправлення квітня 2025 року `com.samsung.ipservice` завантажує Quram (`/system/lib64/libimagecodec.quram.so`) і автоматично парсить будь‑який файл, який WhatsApp (або інші додатки) кладе в `MediaStore`. На практиці атакуючий може надіслати DNG, замаскований під `IMG-*.jpg`, чекати, поки жертва натисне "download" (1-click), і привілейований сервіс розпарсить payload навіть якщо користувач ніколи не відкриватиме галерею.
```bash
$ file IMG-2025-02-10.jpeg
TIFF image data ...
$ exiftool IMG-2025-02-10.jpeg | grep "Opcode List"
Opcode List 1 : [opcode 23], [opcode 23], ...
```
**Ключові висновки**
- Доставка покладається на system media re-parsing (не клієнтом чату) і тому успадковує дозволи того процесу (повний read/write доступ до галереї, можливість додавати нові медіа тощо).
- Будь-який image parser, доступний через `MediaStore` (vision widgets, wallpapers, AI résumé features тощо), стає віддалено досяжним, якщо атакувальник переконає ціль зберегти медіа.

## Помилки інтерпретатора DNG opcode у Quram

DNG файли вбудовують три списки opcode, які застосовуються на різних стадіях декодування. Quram копіює Adobe API, але його Stage-3 обробник для `DeltaPerColumn` (opcode ID 11) довіряє межам plane, наданим атакувальником.

### Неправильні межі plane в `DeltaPerColumn`
- Атакувальник встановлює `plane=5125` та `planes=5123`, хоча Stage-3 зображення експонують лише planes 0–2 (RGB).
- Quram обчислює `opcode_last_plane = image_planes + opcode_planes` замість `plane + count`, і ніколи не перевіряє, чи поміщається отриманий діапазон plane всередині зображення.
- Тому цикл записує дельту в `raw_pixel_buffer[plane_index]` з повністю контрольованим зсувом (наприклад, plane 5125 ⇒ offset `5125 * 2 bytes/pixel = 0x2800`). Кожен opcode додає 16-бітове float значення (0x6666) у цільове місце, що дає точний heap OOB add primitive.

### Перетворення інкрементів на довільні записи
- Експлойт спочатку корумпує Stage-3 `QuramDngImage.bottom/right` використовуючи 480 спотворених `DeltaPerColumn` операцій, щоб майбутні opcode трактували величезні координати як in-bounds.
- Потім `MapTable` opcodes (opcode 7) спрямовуються на ці підроблені межі. Використовуючи substitution table з усіх нулів або `DeltaPerColumn` з `-Inf` deltas, атакувальник зануляє будь-яку ділянку, а потім застосовує додаткові deltas щоб записати точні значення.
- Оскільки параметри opcode живуть всередині DNG metadata, payload може закодувати сотні тисяч записів без прямого доступу до процесної пам'яті.

## Heap Shaping під Scudo

Scudo групує алокації за розміром. Quram випадково виділяє наступні об'єкти з однаковим розміром chunk 0x30, тому вони потрапляють у той самий регіон (0x40-байтний інтервал на heap):
- `QuramDngImage` дескриптори для Stage 1/2/3
- `QuramDngOpcodeTrimBounds` та вендорські `Unknown` opcodes (ID ≥14, включно з ID 23)

Експлойт послідовно виконує алокації, щоб детерміністично розмістити chunks:
1. Stage-1 `Unknown(23)` opcodes (20,000 записів) спрейять 0x30 chunks, які потім звільняють.
2. Stage-2 звільняє ті opcodes і розміщує новий `QuramDngImage` всередині звільненого регіону.
3. 240 Stage-2 `Unknown(23)` записів звільняються, і Stage-3 негайно алокує свій `QuramDngImage` плюс новий raw pixel buffer того ж розміру, повторно використовуючи ці місця.
4. Сформований `TrimBounds` opcode виконується першим у списку 3 і алокує ще один raw pixel buffer перед звільненням стану Stage-2, гарантувавши adjacency "raw pixel buffer ➜ QuramDngImage".
5. Ще 640 `TrimBounds` записів позначені `minVersion=1.4.0.1`, тому диспетчер їх пропускає, але їх backing objects залишаються алокованими і пізніше стають primitive targets.

Ця хореографія ставить Stage-3 raw buffer безпосередньо перед Stage-3 `QuramDngImage`, тож overflow на основі plane змінює поля всередині дескриптора замість того, щоб крашити випадковий стан.

## Повторне використання вендорських "Unknown" Opcodes як блоків даних

Samsung залишає high bit встановленим у вендор-специфічних opcode ID (наприклад, ID 23), що наказує інтерпретатору *allocate* структуру, але пропустити її виконання. Експлойт зловживає цими dormant objects як attacker-controlled heaps:
- Opcode list 1 і 2 `Unknown(23)` записи слугують як суміжні scratchpads для зберігання payload байтів (JOP chain на offset 0xf000 і shell command на 0x10000 відносно raw buffer).
- Оскільки інтерпретатор все ще трактує кожен об'єкт як opcode, коли обробляється list 3, захоплення vtable одного об'єкта пізніше достатньо, щоб почати виконувати attacker data.

## Створення фальшивих `MapTable` об'єктів та обходження ASLR

`MapTable` об'єкти більші за `TrimBounds`, але як тільки відбувається corruption layout, парсер охоче читає додаткові параметри out-of-bounds:
1. Використайте linear write primitive, щоб частково перезаписати vtable pointer `TrimBounds` підробленою `MapTable` substitution table, яка відображає нижні 2 байти з сусіднього `TrimBounds` vtable у `MapTable` vtable. Тільки low bytes відрізняються між підтримуваними версіями Quram, тому одна 64K lookup table може обробити сім firmware версій і кожен 4 KB ASLR slide.
2. Запатчіть решту полів `TrimBounds` (top/left/width/planes), щоб об'єкт поводився як валідний `MapTable` під час подальшого виконання.
3. Виконайте фейковий opcode над занульованою пам'яттю. Оскільки pointer substitution table фактично посилається на vtable іншого opcode, output bytes стають *leaked* low-order addresses з `libimagecodec.quram.so` або його GOT.
4. Застосуйте додаткові проходи `MapTable`, щоб перетворити ці двобайтові leaks у офсети до gadget-ів, таких як `__ink_jpeg_enc_process_image+64`, `QURAMWINK_Read_IO2+124`, `qpng_check_IHDR+624` та libc-ового `__system_property_get`. Атакувальники фактично відновлюють повні адреси всередині своєї spray-нутої області opcode без використання native memory disclosure APIs.

## Тригер JOP ➜ `system()` переходу

Коли gadget-повал та shell command розміщені всередині opcode spray:
1. Остання хвиля `DeltaPerColumn` записів додає `0x0100` до offset 0x22 Stage-3 `QuramDngImage`, зміщуючи pointer на raw buffer на 0x10000 так, що він тепер вказує на attacker command string.
2. Інтерпретатор починає виконувати хвіст з 1040 `Unknown(23)` opcodes. Перший корумпований запис має свою vtable замінену на підроблену таблицю на offset 0xf000, тому `QuramDngOpcode::aboutToApply` резолвить `qpng_read_data` (четвертий запис) з фейкової таблиці.
3. Зчеплені gadgets виконують: завантажують pointer `QuramDngImage`, додають 0x20 щоб вказувати на raw buffer pointer, дереференсують його, копіюють результат в `x19/x0`, потім стрибають через GOT слоти, переписані на `system`. Оскільки raw buffer pointer тепер дорівнює attacker string, фінальний gadget виконує `system(<shell command>)` всередині `com.samsung.ipservice`.

## Нотатки по варіантам алокатора

Існують дві сім'ї payload: одна налаштована під jemalloc, інша під scudo. Вони відрізняються в порядку розміщення opcode blocks для досягнення adjacency, але ділять ті самі логічні примітиви (DeltaPerColumn bug ➜ MapTable zero/write ➜ bogus vtable ➜ JOP). Вимкнений quarantine у Scudo робить повторне використання freelist розміру 0x30 детерміністичним, тоді як jemalloc покладається на контроль size-class через tile/subIFD sizing.

## References

- [Project Zero – A look at an Android ITW DNG exploit](https://projectzero.google/2025/12/android-itw-dng.html)

{{#include ../../banners/hacktricks-training.md}}
