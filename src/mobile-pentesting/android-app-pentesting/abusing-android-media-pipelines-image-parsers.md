# Android 미디어 파이프라인 및 이미지 파서 악용

{{#include ../../banners/hacktricks-training.md}}

## 전달: 메시징 앱 ➜ MediaStore ➜ 특권 파서

최신 OEM 빌드들은 `MediaStore`를 "AI"나 공유 기능을 위해 정기적으로 재스캔하는 권한 있는 미디어 인덱서를 주기적으로 실행합니다. 2025년 4월 패치 이전의 Samsung 펌웨어에서는 `com.samsung.ipservice`가 Quram (`/system/lib64/libimagecodec.quram.so`)을 로드하여 WhatsApp(또는 다른 앱)이 `MediaStore`에 넣는 모든 파일을 자동으로 파싱합니다. 실제로 공격자는 `IMG-*.jpg`로 위장한 DNG를 전송한 뒤 피해자가 "download"(1-click)를 탭할 때까지 기다리면, 사용자가 갤러리를 열지 않아도 특권 서비스가 해당 payload를 파싱합니다.
```bash
$ file IMG-2025-02-10.jpeg
TIFF image data ...
$ exiftool IMG-2025-02-10.jpeg | grep "Opcode List"
Opcode List 1 : [opcode 23], [opcode 23], ...
```
**핵심 요점**
- 전달은 시스템 미디어 재파싱(system media re-parsing)에 의존(채팅 클라이언트가 아님)하므로 해당 프로세스의 권한(갤러리에 대한 완전한 읽기/쓰기 접근, 새 미디어 저장 능력 등)을 상속한다.
- `MediaStore`를 통해 접근 가능한 모든 이미지 파서(vision widgets, 배경화면, AI 이력서 기능 등)는 공격자가 대상에게 미디어 저장을 설득할 수 있으면 원격으로 접근 가능해진다.

## Quram's DNG Opcode Interpreter Bugs

DNG 파일은 서로 다른 디코드 단계에서 적용되는 세 개의 opcode 리스트를 포함한다. Quram은 Adobe의 API를 복제했지만, Stage-3 핸들러인 `DeltaPerColumn`(opcode ID 11)은 공격자가 제공한 plane 경계를 신뢰한다.

### `DeltaPerColumn`의 유효하지 않은 plane 경계
- 공격자는 Stage-3 이미지가 0–2 (RGB) 플레인만 노출함에도 `plane=5125`와 `planes=5123`를 설정한다.
- Quram은 `opcode_last_plane = image_planes + opcode_planes`를 계산하고 `plane + count`를 사용하지 않으며, 결과로 얻어진 플레인 범위가 이미지 내부에 들어가는지 전혀 검사하지 않는다.
- 따라서 루프는 완전히 제어된 오프셋으로 `raw_pixel_buffer[plane_index]`에 델타를 쓴다(예: plane 5125 ⇒ 오프셋 `5125 * 2 bytes/pixel = 0x2800`). 각 opcode는 대상 위치에 16비트 float 값(0x6666)을 더해 정확한 힙 OOB add primitive를 만든다.

### 증가(increments)를 임의 쓰기(arbitrary writes)로 전환
- 익스플로잇은 먼저 480개의 변형된 `DeltaPerColumn` 연산으로 Stage-3의 `QuramDngImage.bottom/right`를 손상시켜 이후 opcode들이 거대한 좌표를 in-bounds로 처리하게 만든다.
- 그 다음 `MapTable` opcode(opcode 7)를 그 가짜 경계에 겨냥한다. 모든 값이 0인 substitution table을 사용하거나 `-Inf` 델타가 있는 `DeltaPerColumn`을 사용하면 공격자는 임의 영역을 0으로 만든 후 추가 델타를 적용해 정확한 값을 쓸 수 있다.
- opcode 파라미터가 DNG 메타데이터 안에 존재하기 때문에 페이로드는 프로세스 메모리를 직접 건드리지 않고도 수십만 건의 쓰기를 인코딩할 수 있다.

## Scudo 하에서의 힙 셰이핑

Scudo는 할당을 크기별로 버킷화한다. Quram은 다음 객체들을 동일한 0x30 바이트 청크 크기로 할당하므로 동일한 영역(힙에서 0x40 바이트 간격)에 놓인다:
- `QuramDngImage` descriptors for Stage 1/2/3
- `QuramDngOpcodeTrimBounds` and vendor `Unknown` opcodes (ID ≥14, including ID 23)

익스플로잇은 청크를 결정론적으로 배치하도록 할당을 순서화한다:
1. Stage-1 `Unknown(23)` opcode들(20,000개 항목)이 0x30 청크를 스프레이하고 이후 해제된다.
2. Stage-2가 그 opcode들을 해제하고 해제된 영역에 새로운 `QuramDngImage`를 배치한다.
3. 240개의 Stage-2 `Unknown(23)` 항목이 해제되고 Stage-3는 즉시 동일 크기의 새로운 raw pixel buffer와 함께 자신의 `QuramDngImage`를 할당해 그 자리를 재사용한다.
4. 세 번째 리스트에서 조작된 `TrimBounds` opcode가 먼저 실행되어 Stage-2 상태를 해제하기 전에 또 다른 raw pixel buffer를 할당해 "raw pixel buffer ➜ QuramDngImage" 인접성을 보장한다.
5. 추가 640개의 `TrimBounds` 항목이 `minVersion=1.4.0.1`로 표시되어 디스패처가 이를 건너뛰지만, 백킹 객체들은 할당된 상태로 남아 이후 primitive 대상이 된다.

이 연출로 Stage-3 raw 버퍼가 Stage-3 `QuramDngImage` 바로 앞에 놓이게 되어, 플레인 기반 오버플로우가 무작위 상태를 충돌시키지 않고 디스크립터 내부의 필드를 뒤집는다.

## 벤더 "Unknown" Opcode를 데이터 블롭으로 재사용

Samsung은 벤더 전용 opcode ID(예: ID 23)의 상위 비트를 설정해 둔다. 이는 인터프리터에게 구조체를 *allocate* 하되 실행은 건너뛰라고 지시한다. 익스플로잇은 그 비활성 객체들을 공격자가 제어하는 힙으로 악용한다:
- Opcode 리스트 1과 2의 `Unknown(23)` 항목은 페이로드 바이트를 저장하는 연속 스크래치패드로 사용된다(JOP 체인은 raw 버퍼 기준 오프셋 0xf000에, 셸 명령은 0x10000에 배치).
- 인터프리터가 리스트 3을 처리할 때 각 객체를 여전히 opcode로 취급하기 때문에, 나중에 한 객체의 vtable을 장악하는 것만으로 공격자 데이터 실행을 시작하기에 충분하다.

## 가짜 `MapTable` 객체 제작 및 ASLR 우회

`MapTable` 객체는 `TrimBounds`보다 크지만 레이아웃 손상이 발생하면 파서가 범위를 벗어난 추가 파라미터를 기쁘게 읽는다:
1. 선형 쓰기 primitive를 사용해 `TrimBounds` vtable 포인터를 부분적으로 덮어쓰고, 이웃한 `TrimBounds` vtable의 하위 2바이트를 `MapTable` vtable로 매핑하는 조작된 `MapTable` substitution table을 삽입한다. 지원되는 Quram 빌드들 간에는 하위 바이트만 다르므로 단일 64K 룩업 테이블로 7개의 펌웨어 버전과 모든 4 KB ASLR 슬라이드를 처리할 수 있다.
2. 나머지 `TrimBounds` 필드(top/left/width/planes)를 패치해 객체가 나중에 실행될 때 유효한 `MapTable`처럼 동작하게 만든다.
3. 제로화된 메모리에 대해 가짜 opcode를 실행한다. substitution table 포인터가 실제로 다른 opcode의 vtable을 참조하기 때문에 출력 바이트는 `libimagecodec.quram.so` 또는 그 GOT에서 *leaked* 되는 하위 주소가 된다.
4. 추가 `MapTable` 패스를 적용해 그 two-byte leaks를 `__ink_jpeg_enc_process_image+64`, `QURAMWINK_Read_IO2+124`, `qpng_check_IHDR+624`, libc의 `__system_property_get` 진입점 같은 가젯을 향한 오프셋으로 변환한다. 공격자는 네이티브 메모리 공개 API 없이 스프레이된 opcode 영역 내에서 전체 주소를 효과적으로 재구성한다.

## JOP ➜ `system()` 전환 트리거

가젯 포인터와 셸 명령이 opcode 스프레이 내부에 준비되면:
1. 마지막 `DeltaPerColumn` 쓰기 파동이 Stage-3 `QuramDngImage`의 오프셋 0x22에 `0x0100`을 더해 raw 버퍼 포인터를 0x10000만큼 이동시켜 이제 공격자 명령 문자열을 참조하게 한다.
2. 인터프리터는 1040개의 `Unknown(23)` opcode 꼬리 부분을 실행하기 시작한다. 처음 손상된 항목은 vtable이 오프셋 0xf000의 조작된 테이블로 교체되어 `QuramDngOpcode::aboutToApply`가 가짜 테이블의 4번째 항목인 `qpng_read_data`를 해석한다.
3. 연쇄된 가젯은 다음을 수행한다: `QuramDngImage` 포인터를 로드하고 raw 버퍼 포인터를 가리키도록 0x20을 더한 뒤 역참조하고 결과를 `x19/x0`에 복사하고, `system`으로 재작성된 GOT 슬롯을 통해 점프한다. raw 버퍼 포인터가 이제 공격자 문자열과 일치하므로 마지막 가젯은 `com.samsung.ipservice` 내부에서 `system(<shell command>)`을 실행한다.

## Allocator 변형에 대한 주석

두 가지 페이로드 계열이 존재한다: 하나는 jemalloc용으로 조정되고 다른 하나는 scudo용이다. 인접성을 얻기 위해 opcode 블록의 정렬 방식이 다르지만 동일한 논리적 프리미티브(DeltaPerColumn bug ➜ MapTable zero/write ➜ bogus vtable ➜ JOP)를 공유한다. Scudo의 비활성화된 quarantine은 0x30 바이트 freelist 재사용을 결정론적으로 만들고, jemalloc은 tile/subIFD 크기 조정을 통한 사이즈 클래스 제어에 의존한다.

## References

- [Project Zero – A look at an Android ITW DNG exploit](https://projectzero.google/2025/12/android-itw-dng.html)

{{#include ../../banners/hacktricks-training.md}}
