# Firmware Analysis

{{#include ../../banners/hacktricks-training.md}}

## **Introduction**

Firmware एक आवश्यक सॉफ़्टवेयर है जो उपकरणों को सही ढंग से संचालित करने में सक्षम बनाता है, हार्डवेयर घटकों और सॉफ़्टवेयर के बीच संचार को प्रबंधित और सुविधाजनक बनाता है, जिससे उपयोगकर्ता इंटरैक्ट करते हैं। इसे स्थायी मेमोरी में संग्रहीत किया जाता है, यह सुनिश्चित करते हुए कि उपकरण चालू होने के क्षण से महत्वपूर्ण निर्देशों तक पहुँच सकता है, जो ऑपरेटिंग सिस्टम के लॉन्च की ओर ले जाता है। फर्मवेयर की जांच और संभावित रूप से संशोधन करना सुरक्षा कमजोरियों की पहचान में एक महत्वपूर्ण कदम है।

## **Gathering Information**

**Gathering information** एक महत्वपूर्ण प्रारंभिक कदम है जो एक उपकरण की संरचना और इसके द्वारा उपयोग की जाने वाली तकनीकों को समझने में मदद करता है। इस प्रक्रिया में निम्नलिखित डेटा एकत्र करना शामिल है:

- CPU आर्किटेक्चर और जिस ऑपरेटिंग सिस्टम पर यह चलता है
- बूटलोडर विशिष्टताएँ
- हार्डवेयर लेआउट और डेटा शीट
- कोडबेस मैट्रिक्स और स्रोत स्थान
- बाहरी पुस्तकालय और लाइसेंस प्रकार
- अपडेट इतिहास और नियामक प्रमाणन
- आर्किटेक्चरल और फ्लो डायग्राम
- सुरक्षा आकलन और पहचानी गई कमजोरियाँ

इस उद्देश्य के लिए, **open-source intelligence (OSINT)** उपकरण अमूल्य हैं, जैसे कि उपलब्ध ओपन-सोर्स सॉफ़्टवेयर घटकों का मैनुअल और स्वचालित समीक्षा प्रक्रियाओं के माध्यम से विश्लेषण। [Coverity Scan](https://scan.coverity.com) और [Semmle’s LGTM](https://lgtm.com/#explore) जैसे उपकरण संभावित मुद्दों को खोजने के लिए मुफ्त स्थैतिक विश्लेषण प्रदान करते हैं।

## **Acquiring the Firmware**

फर्मवेयर प्राप्त करने के लिए विभिन्न तरीकों का उपयोग किया जा सकता है, प्रत्येक की अपनी जटिलता का स्तर है:

- **Directly** स्रोत से (डेवलपर्स, निर्माताओं)
- **Building** इसे प्रदान की गई निर्देशों से
- **Downloading** आधिकारिक समर्थन साइटों से
- होस्ट किए गए फर्मवेयर फ़ाइलों को खोजने के लिए **Google dork** क्वेरी का उपयोग करना
- **cloud storage** तक सीधे पहुँच प्राप्त करना, जैसे कि [S3Scanner](https://github.com/sa7mon/S3Scanner) जैसे उपकरणों के साथ
- मैन-इन-द-मिडल तकनीकों के माध्यम से **updates** को इंटरसेप्ट करना
- **Extracting** उपकरण से कनेक्शनों के माध्यम से जैसे **UART**, **JTAG**, या **PICit**
- उपकरण संचार के भीतर अपडेट अनुरोधों के लिए **Sniffing**
- **hardcoded update endpoints** की पहचान और उपयोग करना
- बूटलोडर या नेटवर्क से **Dumping**
- जब सभी अन्य विफल हो जाएं, तो उचित हार्डवेयर उपकरणों का उपयोग करके स्टोरेज चिप को **Removing and reading**

## Analyzing the firmware

अब जब आपके पास **फर्मवेयर** है, तो आपको इसके बारे में जानकारी निकालने की आवश्यकता है ताकि आप जान सकें कि इसे कैसे संभालना है। इसके लिए आप विभिन्न उपकरणों का उपयोग कर सकते हैं:
```bash
file <bin>
strings -n8 <bin>
strings -tx <bin> #print offsets in hex
hexdump -C -n 512 <bin> > hexdump.out
hexdump -C <bin> | head # might find signatures in header
fdisk -lu <bin> #lists a drives partition and filesystems if multiple
```
यदि आप उन उपकरणों के साथ ज्यादा कुछ नहीं पाते हैं, तो `binwalk -E <bin>` के साथ छवि की **entropy** की जांच करें, यदि entropy कम है, तो यह संभावना नहीं है कि यह एन्क्रिप्टेड है। यदि entropy उच्च है, तो यह संभावना है कि यह एन्क्रिप्टेड है (या किसी तरह से संकुचित है)।

इसके अलावा, आप इन उपकरणों का उपयोग **फर्मवेयर के अंदर एम्बेडेड फ़ाइलों** को निकालने के लिए कर सकते हैं:

{{#ref}}
../../generic-methodologies-and-resources/basic-forensic-methodology/partitions-file-systems-carving/file-data-carving-recovery-tools.md
{{#endref}}

या [**binvis.io**](https://binvis.io/#/) ([code](https://code.google.com/archive/p/binvis/)) का उपयोग करके फ़ाइल का निरीक्षण करें।

### फ़ाइल सिस्टम प्राप्त करना

पिछले टिप्पणी किए गए उपकरणों जैसे `binwalk -ev <bin>` के साथ, आपको **फाइल सिस्टम निकालने में सक्षम होना चाहिए**।\
Binwalk आमतौर पर इसे **फाइल सिस्टम प्रकार के नाम वाले फ़ोल्डर** के अंदर निकालता है, जो आमतौर पर निम्नलिखित में से एक होता है: squashfs, ubifs, romfs, rootfs, jffs2, yaffs2, cramfs, initramfs।

#### मैनुअल फ़ाइल सिस्टम निष्कर्षण

कभी-कभी, binwalk के पास **फाइल सिस्टम के जादुई बाइट्स अपने हस्ताक्षरों में नहीं होते हैं**। इन मामलों में, binwalk का उपयोग करके **फाइल सिस्टम का ऑफसेट खोजें और बाइनरी से संकुचित फाइल सिस्टम को काटें** और नीचे दिए गए चरणों का उपयोग करके इसके प्रकार के अनुसार **मैन्युअल रूप से फाइल सिस्टम निकालें**।
```
$ binwalk DIR850L_REVB.bin

DECIMAL HEXADECIMAL DESCRIPTION
----------------------------------------------------------------------------- ---

0 0x0 DLOB firmware header, boot partition: """"dev=/dev/mtdblock/1""""
10380 0x288C LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 5213748 bytes
1704052 0x1A0074 PackImg section delimiter tag, little endian size: 32256 bytes; big endian size: 8257536 bytes
1704084 0x1A0094 Squashfs filesystem, little endian, version 4.0, compression:lzma, size: 8256900 bytes, 2688 inodes, blocksize: 131072 bytes, created: 2016-07-12 02:28:41
```
निम्नलिखित **dd कमांड** चलाएँ जो Squashfs फ़ाइल प्रणाली को काटता है।
```
$ dd if=DIR850L_REVB.bin bs=1 skip=1704084 of=dir.squashfs

8257536+0 records in

8257536+0 records out

8257536 bytes (8.3 MB, 7.9 MiB) copied, 12.5777 s, 657 kB/s
```
वैकल्पिक रूप से, निम्नलिखित कमांड भी चलाया जा सकता है।

`$ dd if=DIR850L_REVB.bin bs=1 skip=$((0x1A0094)) of=dir.squashfs`

- squashfs (उदाहरण में उपयोग किया गया)

`$ unsquashfs dir.squashfs`

फाइलें "`squashfs-root`" निर्देशिका में बाद में होंगी।

- CPIO आर्काइव फाइलें

`$ cpio -ivd --no-absolute-filenames -F <bin>`

- jffs2 फाइल सिस्टम के लिए

`$ jefferson rootfsfile.jffs2`

- NAND फ्लैश के साथ ubifs फाइल सिस्टम के लिए

`$ ubireader_extract_images -u UBI -s <start_offset> <bin>`

`$ ubidump.py <bin>`

## फर्मवेयर का विश्लेषण

एक बार फर्मवेयर प्राप्त हो जाने के बाद, इसकी संरचना और संभावित कमजोरियों को समझने के लिए इसे विश्लेषित करना आवश्यक है। इस प्रक्रिया में फर्मवेयर इमेज से मूल्यवान डेटा का विश्लेषण और निकालने के लिए विभिन्न उपकरणों का उपयोग करना शामिल है।

### प्रारंभिक विश्लेषण उपकरण

बाइनरी फ़ाइल (जिसे `<bin>` कहा जाता है) के प्रारंभिक निरीक्षण के लिए एक सेट कमांड प्रदान किया गया है। ये कमांड फ़ाइल प्रकारों की पहचान करने, स्ट्रिंग्स निकालने, बाइनरी डेटा का विश्लेषण करने और विभाजन और फ़ाइल सिस्टम विवरण को समझने में मदद करते हैं:
```bash
file <bin>
strings -n8 <bin>
strings -tx <bin> #prints offsets in hexadecimal
hexdump -C -n 512 <bin> > hexdump.out
hexdump -C <bin> | head #useful for finding signatures in the header
fdisk -lu <bin> #lists partitions and filesystems, if there are multiple
```
इमेज के एन्क्रिप्शन स्थिति का आकलन करने के लिए, **entropy** को `binwalk -E <bin>` के साथ चेक किया जाता है। कम एंट्रॉपी एन्क्रिप्शन की कमी का सुझाव देती है, जबकि उच्च एंट्रॉपी संभावित एन्क्रिप्शन या संकुचन को इंगित करती है।

**Embedded files** को निकालने के लिए, **file-data-carving-recovery-tools** दस्तावेज़ और फ़ाइल निरीक्षण के लिए **binvis.io** जैसे उपकरण और संसाधनों की सिफारिश की जाती है।

### फ़ाइल सिस्टम निकालना

`binwalk -ev <bin>` का उपयोग करके, आमतौर पर फ़ाइल सिस्टम को निकाला जा सकता है, अक्सर एक निर्देशिका में जिसका नाम फ़ाइल सिस्टम प्रकार (जैसे, squashfs, ubifs) के नाम पर होता है। हालाँकि, जब **binwalk** जादुई बाइट्स की कमी के कारण फ़ाइल सिस्टम प्रकार को पहचानने में विफल रहता है, तो मैनुअल निकासी आवश्यक होती है। इसमें फ़ाइल सिस्टम के ऑफसेट को खोजने के लिए `binwalk` का उपयोग करना शामिल है, इसके बाद फ़ाइल सिस्टम को काटने के लिए `dd` कमांड का उपयोग किया जाता है:
```bash
$ binwalk DIR850L_REVB.bin

$ dd if=DIR850L_REVB.bin bs=1 skip=1704084 of=dir.squashfs
```
इसके बाद, फ़ाइल सिस्टम प्रकार (जैसे, squashfs, cpio, jffs2, ubifs) के आधार पर, सामग्री को मैन्युअल रूप से निकालने के लिए विभिन्न कमांड का उपयोग किया जाता है।

### फ़ाइल सिस्टम विश्लेषण

फ़ाइल सिस्टम निकालने के बाद, सुरक्षा खामियों की खोज शुरू होती है। असुरक्षित नेटवर्क डेमन्स, हार्डकोडेड क्रेडेंशियल्स, API एंडपॉइंट्स, अपडेट सर्वर कार्यक्षमताएँ, अनकंपाइल कोड, स्टार्टअप स्क्रिप्ट, और ऑफ़लाइन विश्लेषण के लिए संकलित बाइनरीज़ पर ध्यान दिया जाता है।

**मुख्य स्थान** और **आइटम** जिनकी जांच करनी है, उनमें शामिल हैं:

- **etc/shadow** और **etc/passwd** उपयोगकर्ता क्रेडेंशियल्स के लिए
- **etc/ssl** में SSL प्रमाणपत्र और कुंजी
- संभावित कमजोरियों के लिए कॉन्फ़िगरेशन और स्क्रिप्ट फ़ाइलें
- आगे के विश्लेषण के लिए एम्बेडेड बाइनरीज़
- सामान्य IoT डिवाइस वेब सर्वर और बाइनरीज़

कई उपकरण फ़ाइल सिस्टम के भीतर संवेदनशील जानकारी और कमजोरियों को उजागर करने में मदद करते हैं:

- [**LinPEAS**](https://github.com/carlospolop/PEASS-ng) और [**Firmwalker**](https://github.com/craigz28/firmwalker) संवेदनशील जानकारी खोजने के लिए
- [**The Firmware Analysis and Comparison Tool (FACT)**](https://github.com/fkie-cad/FACT_core) व्यापक फ़र्मवेयर विश्लेषण के लिए
- [**FwAnalyzer**](https://github.com/cruise-automation/fwanalyzer), [**ByteSweep**](https://gitlab.com/bytesweep/bytesweep), [**ByteSweep-go**](https://gitlab.com/bytesweep/bytesweep-go), और [**EMBA**](https://github.com/e-m-b-a/emba) स्थिर और गतिशील विश्लेषण के लिए

### संकलित बाइनरीज़ पर सुरक्षा जांच

फ़ाइल सिस्टम में पाए गए स्रोत कोड और संकलित बाइनरीज़ की कमजोरियों के लिए जांच की जानी चाहिए। **checksec.sh** जैसे उपकरण यूनिक्स बाइनरीज़ के लिए और **PESecurity** विंडोज बाइनरीज़ के लिए उन असुरक्षित बाइनरीज़ की पहचान करने में मदद करते हैं जिन्हें शोषित किया जा सकता है।

## गतिशील विश्लेषण के लिए फ़र्मवेयर का अनुकरण

फ़र्मवेयर का अनुकरण करने की प्रक्रिया **गतिशील विश्लेषण** को सक्षम बनाती है, चाहे वह किसी डिवाइस का संचालन हो या एक व्यक्तिगत प्रोग्राम। इस दृष्टिकोण में हार्डवेयर या आर्किटेक्चर निर्भरताओं के साथ चुनौतियाँ आ सकती हैं, लेकिन रूट फ़ाइल सिस्टम या विशिष्ट बाइनरीज़ को मिलते-जुलते आर्किटेक्चर और एंडियननेस वाले डिवाइस, जैसे कि एक Raspberry Pi, या एक पूर्व-निर्मित वर्चुअल मशीन में स्थानांतरित करना आगे के परीक्षण को सुविधाजनक बना सकता है।

### व्यक्तिगत बाइनरीज़ का अनुकरण

एकल प्रोग्राम की जांच के लिए, प्रोग्राम के एंडियननेस और CPU आर्किटेक्चर की पहचान करना महत्वपूर्ण है।

#### MIPS आर्किटेक्चर के साथ उदाहरण

MIPS आर्किटेक्चर बाइनरी का अनुकरण करने के लिए, कोई निम्नलिखित कमांड का उपयोग कर सकता है:
```bash
file ./squashfs-root/bin/busybox
```
और आवश्यक अनुकरण उपकरण स्थापित करने के लिए:
```bash
sudo apt-get install qemu qemu-user qemu-user-static qemu-system-arm qemu-system-mips qemu-system-x86 qemu-utils
```
For MIPS (big-endian), `qemu-mips` का उपयोग किया जाता है, और little-endian बाइनरी के लिए, `qemu-mipsel` विकल्प होगा।

#### ARM आर्किटेक्चर अनुकरण

ARM बाइनरी के लिए, प्रक्रिया समान है, जिसमें अनुकरण के लिए `qemu-arm` अनुकरणकर्ता का उपयोग किया जाता है।

### पूर्ण प्रणाली अनुकरण

[Firmadyne](https://github.com/firmadyne/firmadyne), [Firmware Analysis Toolkit](https://github.com/attify/firmware-analysis-toolkit) और अन्य जैसे उपकरण पूर्ण फर्मवेयर अनुकरण को सुविधाजनक बनाते हैं, प्रक्रिया को स्वचालित करते हैं और गतिशील विश्लेषण में सहायता करते हैं।

## व्याव实践 में गतिशील विश्लेषण

इस चरण में, विश्लेषण के लिए या तो एक वास्तविक या अनुकरणित डिवाइस वातावरण का उपयोग किया जाता है। OS और फ़ाइल प्रणाली तक शेल पहुंच बनाए रखना आवश्यक है। अनुकरण हार्डवेयर इंटरैक्शन को सही ढंग से अनुकरण नहीं कर सकता, जिससे कभी-कभी अनुकरण को फिर से शुरू करने की आवश्यकता होती है। विश्लेषण को फ़ाइल प्रणाली पर फिर से जाना चाहिए, उजागर की गई वेबपृष्ठों और नेटवर्क सेवाओं का शोषण करना चाहिए, और बूटलोडर कमजोरियों का पता लगाना चाहिए। फर्मवेयर अखंडता परीक्षण संभावित बैकडोर कमजोरियों की पहचान के लिए महत्वपूर्ण हैं।

## रनटाइम विश्लेषण तकनीकें

रनटाइम विश्लेषण एक प्रक्रिया या बाइनरी के साथ उसके संचालन वातावरण में बातचीत करने में शामिल है, जिसमें gdb-multiarch, Frida, और Ghidra जैसे उपकरणों का उपयोग करके ब्रेकपॉइंट सेट करना और फज़िंग और अन्य तकनीकों के माध्यम से कमजोरियों की पहचान करना शामिल है।

## बाइनरी शोषण और प्रमाण-का-धारणा

पहचानी गई कमजोरियों के लिए PoC विकसित करने के लिए लक्षित आर्किटेक्चर और निम्न-स्तरीय भाषाओं में प्रोग्रामिंग की गहरी समझ की आवश्यकता होती है। एम्बेडेड सिस्टम में बाइनरी रनटाइम सुरक्षा दुर्लभ होती है, लेकिन जब मौजूद होती है, तो Return Oriented Programming (ROP) जैसी तकनीकों की आवश्यकता हो सकती है।

## फर्मवेयर विश्लेषण के लिए तैयार ऑपरेटिंग सिस्टम

[AttifyOS](https://github.com/adi0x90/attifyos) और [EmbedOS](https://github.com/scriptingxss/EmbedOS) जैसे ऑपरेटिंग सिस्टम फर्मवेयर सुरक्षा परीक्षण के लिए पूर्व-निर्धारित वातावरण प्रदान करते हैं, जिसमें आवश्यक उपकरण होते हैं।

## फर्मवेयर का विश्लेषण करने के लिए तैयार OSs

- [**AttifyOS**](https://github.com/adi0x90/attifyos): AttifyOS एक डिस्ट्रीब्यूशन है जिसका उद्देश्य आपको इंटरनेट ऑफ थिंग्स (IoT) उपकरणों की सुरक्षा मूल्यांकन और पेनटेस्टिंग करने में मदद करना है। यह आपको सभी आवश्यक उपकरणों के साथ पूर्व-निर्धारित वातावरण प्रदान करके बहुत सारा समय बचाता है।
- [**EmbedOS**](https://github.com/scriptingxss/EmbedOS): फर्मवेयर सुरक्षा परीक्षण उपकरणों के साथ पूर्व-लोडेड Ubuntu 18.04 पर आधारित एम्बेडेड सुरक्षा परीक्षण ऑपरेटिंग सिस्टम।

## फर्मवेयर डाउनग्रेड हमले और असुरक्षित अपडेट तंत्र

यहां तक कि जब एक विक्रेता फर्मवेयर छवियों के लिए क्रिप्टोग्राफिक हस्ताक्षर जांच लागू करता है, **संस्करण रोलबैक (डाउनग्रेड) सुरक्षा अक्सर छोड़ दी जाती है**। जब बूट- या रिकवरी-लोडर केवल एक अंतर्निहित सार्वजनिक कुंजी के साथ हस्ताक्षर की पुष्टि करता है लेकिन छवि के *संस्करण* (या एक मोनोटोनिक काउंटर) की तुलना नहीं करता है, तो एक हमलावर एक **पुरानी, कमजोर फर्मवेयर को वैध हस्ताक्षर के साथ स्थापित कर सकता है** और इस प्रकार पैच की गई कमजोरियों को फिर से पेश कर सकता है।

सामान्य हमले का कार्यप्रवाह:

1. **एक पुरानी हस्ताक्षरित छवि प्राप्त करें**
* इसे विक्रेता के सार्वजनिक डाउनलोड पोर्टल, CDN या समर्थन साइट से प्राप्त करें।
* इसे साथी मोबाइल/डेस्कटॉप अनुप्रयोगों से निकालें (जैसे, एक Android APK के अंदर `assets/firmware/` के तहत)।
* इसे तीसरे पक्ष के रिपॉजिटरी जैसे VirusTotal, इंटरनेट आर्काइव, फोरम आदि से प्राप्त करें।
2. **किसी भी उजागर अपडेट चैनल के माध्यम से डिवाइस पर छवि अपलोड या सेवा करें:**
* वेब UI, मोबाइल-ऐप API, USB, TFTP, MQTT, आदि।
* कई उपभोक्ता IoT उपकरण *अप्रमाणित* HTTP(S) एंडपॉइंट्स को उजागर करते हैं जो Base64-कोडित फर्मवेयर ब्लॉब्स को स्वीकार करते हैं, उन्हें सर्वर-साइड पर डिकोड करते हैं और रिकवरी/अपग्रेड को ट्रिगर करते हैं।
3. डाउनग्रेड के बाद, एक कमजोरियों का शोषण करें जो नए रिलीज़ में पैच की गई थी (उदाहरण के लिए, एक कमांड-इंजेक्शन फ़िल्टर जो बाद में जोड़ा गया था)।
4. वैकल्पिक रूप से नवीनतम छवि को फिर से फ्लैश करें या पहचान से बचने के लिए अपडेट को बंद करें जब स्थायीता प्राप्त हो जाए। 

### उदाहरण: डाउनग्रेड के बाद कमांड इंजेक्शन
```http
POST /check_image_and_trigger_recovery?md5=1; echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC...' >> /root/.ssh/authorized_keys HTTP/1.1
Host: 192.168.0.1
Content-Type: application/octet-stream
Content-Length: 0
```
In the vulnerable (downgraded) firmware, the `md5` parameter is concatenated directly into a shell command without sanitisation, allowing injection of arbitrary commands (here – enabling SSH key-based root access). Later firmware versions introduced a basic character filter, but the absence of downgrade protection renders the fix moot.

### Extracting Firmware From Mobile Apps

कई विक्रेता अपने सहायक मोबाइल अनुप्रयोगों के अंदर पूर्ण फर्मवेयर छवियों को बंडल करते हैं ताकि ऐप डिवाइस को Bluetooth/Wi-Fi के माध्यम से अपडेट कर सके। ये पैकेज आमतौर पर APK/APEX में `assets/fw/` या `res/raw/` जैसे पथों के तहत अनएन्क्रिप्टेड रूप में संग्रहीत होते हैं। उपकरण जैसे `apktool`, `ghidra`, या यहां तक कि साधारण `unzip` आपको भौतिक हार्डवेयर को छुए बिना साइन की गई छवियों को खींचने की अनुमति देते हैं।
```
$ apktool d vendor-app.apk -o vendor-app
$ ls vendor-app/assets/firmware
firmware_v1.3.11.490_signed.bin
```
### अपडेट लॉजिक का आकलन करने के लिए चेकलिस्ट

* क्या *अपडेट एंडपॉइंट* का परिवहन/प्रमाणीकरण उचित रूप से सुरक्षित है (TLS + प्रमाणीकरण)?
* क्या डिवाइस फ्लैश करने से पहले **संस्करण नंबर** या **मोनोटोनिक एंटी-रोलबैक काउंटर** की तुलना करता है?
* क्या इमेज को सुरक्षित बूट चेन के अंदर सत्यापित किया गया है (जैसे, ROM कोड द्वारा हस्ताक्षर की जांच)?
* क्या यूजरलैंड कोड अतिरिक्त सैनीटी चेक करता है (जैसे, अनुमत विभाजन मानचित्र, मॉडल नंबर)?
* क्या *आंशिक* या *बैकअप* अपडेट प्रवाह वही सत्यापन लॉजिक पुनः उपयोग कर रहे हैं?

> 💡  यदि उपरोक्त में से कोई भी गायब है, तो प्लेटफ़ॉर्म शायद रोलबैक हमलों के प्रति संवेदनशील है।

## अभ्यास के लिए संवेदनशील फर्मवेयर

फर्मवेयर में संवेदनशीलताओं का पता लगाने का अभ्यास करने के लिए, निम्नलिखित संवेदनशील फर्मवेयर परियोजनाओं का उपयोग प्रारंभिक बिंदु के रूप में करें।

- OWASP IoTGoat
- [https://github.com/OWASP/IoTGoat](https://github.com/OWASP/IoTGoat)
- द डैम वल्नरेबल राउटर फर्मवेयर प्रोजेक्ट
- [https://github.com/praetorian-code/DVRF](https://github.com/praetorian-code/DVRF)
- डैम वल्नरेबल ARM राउटर (DVAR)
- [https://blog.exploitlab.net/2018/01/dvar-damn-vulnerable-arm-router.html](https://blog.exploitlab.net/2018/01/dvar-damn-vulnerable-arm-router.html)
- ARM-X
- [https://github.com/therealsaumil/armx#downloads](https://github.com/therealsaumil/armx#downloads)
- Azeria Labs VM 2.0
- [https://azeria-labs.com/lab-vm-2-0/](https://azeria-labs.com/lab-vm-2-0/)
- डैम वल्नरेबल IoT डिवाइस (DVID)
- [https://github.com/Vulcainreo/DVID](https://github.com/Vulcainreo/DVID)

## संदर्भ

- [https://scriptingxss.gitbook.io/firmware-security-testing-methodology/](https://scriptingxss.gitbook.io/firmware-security-testing-methodology/)
- [Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things](https://www.amazon.co.uk/Practical-IoT-Hacking-F-Chantzis/dp/1718500904)
- [Exploiting zero days in abandoned hardware – Trail of Bits blog](https://blog.trailofbits.com/2025/07/25/exploiting-zero-days-in-abandoned-hardware/)

## प्रशिक्षण और प्रमाणन

- [https://www.attify-store.com/products/offensive-iot-exploitation](https://www.attify-store.com/products/offensive-iot-exploitation)

{{#include ../../banners/hacktricks-training.md}}
