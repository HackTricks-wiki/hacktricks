# Аналіз ПЗП

{{#include ../../banners/hacktricks-training.md}}

## **Вступ**

ПЗП є основним програмним забезпеченням, яке дозволяє пристроям працювати правильно, керуючи та полегшуючи зв'язок між апаратними компонентами та програмним забезпеченням, з яким взаємодіють користувачі. Воно зберігається в постійній пам'яті, що забезпечує доступ пристрою до важливих інструкцій з моменту його ввімкнення, що призводить до запуску операційної системи. Аналіз та потенційне модифікування ПЗП є критичним кроком у виявленні вразливостей безпеки.

## **Збір інформації**

**Збір інформації** є критично важливим початковим кроком у розумінні складу пристрою та технологій, які він використовує. Цей процес включає збір даних про:

- Архітектуру ЦП та операційну систему, на якій він працює
- Специфікації завантажувача
- Схему апаратного забезпечення та технічні характеристики
- Метрики кодової бази та місця розташування виходу
- Зовнішні бібліотеки та типи ліцензій
- Історії оновлень та регуляторні сертифікації
- Архітектурні та потокові діаграми
- Оцінки безпеки та виявлені вразливості

Для цієї мети **інструменти відкритих даних (OSINT)** є безцінними, як і аналіз будь-яких доступних компонентів відкритого програмного забезпечення через ручні та автоматизовані процеси перевірки. Інструменти, такі як [Coverity Scan](https://scan.coverity.com) та [Semmle’s LGTM](https://lgtm.com/#explore), пропонують безкоштовний статичний аналіз, який можна використовувати для виявлення потенційних проблем.

## **Отримання ПЗП**

Отримання ПЗП можна здійснити різними способами, кожен з яких має свій рівень складності:

- **Безпосередньо** від джерела (розробників, виробників)
- **Створення** його з наданих інструкцій
- **Завантаження** з офіційних сайтів підтримки
- Використання **Google dork** запитів для знаходження розміщених файлів ПЗП
- Доступ до **хмарного сховища** безпосередньо, за допомогою інструментів, таких як [S3Scanner](https://github.com/sa7mon/S3Scanner)
- Перехоплення **оновлень** за допомогою технік "людина посередині"
- **Витягування** з пристрою через з'єднання, такі як **UART**, **JTAG** або **PICit**
- **Сниффінг** запитів на оновлення в межах зв'язку пристрою
- Виявлення та використання **жорстко закодованих кінцевих точок оновлення**
- **Скидання** з завантажувача або мережі
- **Видалення та читання** чіпа пам'яті, коли всі інші способи не спрацювали, використовуючи відповідні апаратні інструменти

## Аналіз ПЗП

Тепер, коли ви **отримали ПЗП**, вам потрібно витягти інформацію про нього, щоб знати, як з ним працювати. Різні інструменти, які ви можете використовувати для цього:
```bash
file <bin>
strings -n8 <bin>
strings -tx <bin> #print offsets in hex
hexdump -C -n 512 <bin> > hexdump.out
hexdump -C <bin> | head # might find signatures in header
fdisk -lu <bin> #lists a drives partition and filesystems if multiple
```
Якщо ви не знайдете багато з цими інструментами, перевірте **ентропію** зображення за допомогою `binwalk -E <bin>`, якщо ентропія низька, то, ймовірно, воно не зашифроване. Якщо ентропія висока, ймовірно, воно зашифроване (або стиснуте якимось чином).

Крім того, ви можете використовувати ці інструменти для витягнення **файлів, вбудованих у прошивку**:

{{#ref}}
../../generic-methodologies-and-resources/basic-forensic-methodology/partitions-file-systems-carving/file-data-carving-recovery-tools.md
{{#endref}}

Або [**binvis.io**](https://binvis.io/#/) ([code](https://code.google.com/archive/p/binvis/)), щоб перевірити файл.

### Отримання файлової системи

З попередніми коментованими інструментами, такими як `binwalk -ev <bin>`, ви повинні були змогти **витягти файлову систему**.\
Binwalk зазвичай витягує її в **папку, названу на честь типу файлової системи**, яка зазвичай є однією з наступних: squashfs, ubifs, romfs, rootfs, jffs2, yaffs2, cramfs, initramfs.

#### Ручне витягнення файлової системи

Іноді binwalk **не має магічного байта файлової системи у своїх сигнатурах**. У цих випадках використовуйте binwalk, щоб **знайти зсув файлової системи та вирізати стиснуту файлову систему** з бінарного файлу та **вручну витягти** файлову систему відповідно до її типу, використовуючи наведені нижче кроки.
```
$ binwalk DIR850L_REVB.bin

DECIMAL HEXADECIMAL DESCRIPTION
----------------------------------------------------------------------------- ---

0 0x0 DLOB firmware header, boot partition: """"dev=/dev/mtdblock/1""""
10380 0x288C LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 5213748 bytes
1704052 0x1A0074 PackImg section delimiter tag, little endian size: 32256 bytes; big endian size: 8257536 bytes
1704084 0x1A0094 Squashfs filesystem, little endian, version 4.0, compression:lzma, size: 8256900 bytes, 2688 inodes, blocksize: 131072 bytes, created: 2016-07-12 02:28:41
```
Запустіть наступну **dd команду**, щоб вирізати файлову систему Squashfs.
```
$ dd if=DIR850L_REVB.bin bs=1 skip=1704084 of=dir.squashfs

8257536+0 records in

8257536+0 records out

8257536 bytes (8.3 MB, 7.9 MiB) copied, 12.5777 s, 657 kB/s
```
Альтернативно, також можна виконати наступну команду.

`$ dd if=DIR850L_REVB.bin bs=1 skip=$((0x1A0094)) of=dir.squashfs`

- Для squashfs (використовується в наведеному вище прикладі)

`$ unsquashfs dir.squashfs`

Файли будуть у директорії "`squashfs-root`" після цього.

- Файли архіву CPIO

`$ cpio -ivd --no-absolute-filenames -F <bin>`

- Для файлових систем jffs2

`$ jefferson rootfsfile.jffs2`

- Для файлових систем ubifs з NAND flash

`$ ubireader_extract_images -u UBI -s <start_offset> <bin>`

`$ ubidump.py <bin>`

## Аналіз ПЗ

Після отримання ПЗ важливо розібрати його для розуміння його структури та потенційних вразливостей. Цей процес передбачає використання різних інструментів для аналізу та витягування цінних даних з образу ПЗ.

### Інструменти початкового аналізу

Набір команд надається для початкової перевірки бінарного файлу (який називається `<bin>`). Ці команди допомагають у визначенні типів файлів, витягуванні рядків, аналізі бінарних даних та розумінні деталей розділів і файлової системи:
```bash
file <bin>
strings -n8 <bin>
strings -tx <bin> #prints offsets in hexadecimal
hexdump -C -n 512 <bin> > hexdump.out
hexdump -C <bin> | head #useful for finding signatures in the header
fdisk -lu <bin> #lists partitions and filesystems, if there are multiple
```
Щоб оцінити статус шифрування зображення, перевіряється **ентропія** за допомогою `binwalk -E <bin>`. Низька ентропія вказує на відсутність шифрування, тоді як висока ентропія свідчить про можливе шифрування або стиснення.

Для витягування **вбудованих файлів** рекомендуються інструменти та ресурси, такі як документація **file-data-carving-recovery-tools** та **binvis.io** для перевірки файлів.

### Витягування файлової системи

Використовуючи `binwalk -ev <bin>`, зазвичай можна витягнути файлову систему, часто в каталог, названий на честь типу файлової системи (наприклад, squashfs, ubifs). Однак, коли **binwalk** не може розпізнати тип файлової системи через відсутні магічні байти, необхідно виконати ручне витягування. Це передбачає використання `binwalk` для визначення зсуву файлової системи, після чого використовується команда `dd` для вирізання файлової системи:
```bash
$ binwalk DIR850L_REVB.bin

$ dd if=DIR850L_REVB.bin bs=1 skip=1704084 of=dir.squashfs
```
Після цього, в залежності від типу файлової системи (наприклад, squashfs, cpio, jffs2, ubifs), використовуються різні команди для ручного витягування вмісту.

### Аналіз файлової системи

Після витягування файлової системи починається пошук вразливостей безпеки. Увага приділяється небезпечним мережевим демонів, жорстко закодованим обліковим даним, API-інтерфейсам, функціональності серверів оновлень, некомпільованому коду, скриптам запуску та скомпільованим двійковим файлам для офлайн-аналізу.

**Ключові місця** та **елементи** для перевірки включають:

- **etc/shadow** та **etc/passwd** для облікових даних користувачів
- SSL сертифікати та ключі в **etc/ssl**
- Конфігураційні та скриптові файли на предмет потенційних вразливостей
- Вбудовані двійкові файли для подальшого аналізу
- Загальні веб-сервери та двійкові файли IoT пристроїв

Кілька інструментів допомагають виявити чутливу інформацію та вразливості в файловій системі:

- [**LinPEAS**](https://github.com/carlospolop/PEASS-ng) та [**Firmwalker**](https://github.com/craigz28/firmwalker) для пошуку чутливої інформації
- [**The Firmware Analysis and Comparison Tool (FACT)**](https://github.com/fkie-cad/FACT_core) для комплексного аналізу прошивок
- [**FwAnalyzer**](https://github.com/cruise-automation/fwanalyzer), [**ByteSweep**](https://gitlab.com/bytesweep/bytesweep), [**ByteSweep-go**](https://gitlab.com/bytesweep/bytesweep-go) та [**EMBA**](https://github.com/e-m-b-a/emba) для статичного та динамічного аналізу

### Перевірки безпеки скомпільованих двійкових файлів

Як вихідний код, так і скомпільовані двійкові файли, знайдені у файловій системі, повинні бути ретельно перевірені на вразливості. Інструменти, такі як **checksec.sh** для двійкових файлів Unix та **PESecurity** для двійкових файлів Windows, допомагають виявити незахищені двійкові файли, які можуть бути використані в атаках.

## Емуляція прошивки для динамічного аналізу

Процес емулювання прошивки дозволяє **динамічний аналіз** або роботи пристрою, або окремої програми. Цей підхід може стикатися з проблемами залежностей апаратного забезпечення або архітектури, але перенесення кореневої файлової системи або конкретних двійкових файлів на пристрій з відповідною архітектурою та порядком байтів, наприклад, Raspberry Pi, або на попередньо зібрану віртуальну машину, може полегшити подальше тестування.

### Емуляція окремих двійкових файлів

Для перевірки окремих програм важливо визначити порядок байтів програми та архітектуру ЦП.

#### Приклад з архітектурою MIPS

Щоб емулювати двійковий файл архітектури MIPS, можна використовувати команду:
```bash
file ./squashfs-root/bin/busybox
```
І щоб встановити необхідні інструменти емуляції:
```bash
sudo apt-get install qemu qemu-user qemu-user-static qemu-system-arm qemu-system-mips qemu-system-x86 qemu-utils
```
Для MIPS (big-endian) використовується `qemu-mips`, а для little-endian бінарних файлів вибір буде `qemu-mipsel`.

#### Емуляція архітектури ARM

Для бінарних файлів ARM процес подібний, з використанням емулятора `qemu-arm`.

### Емуляція повної системи

Інструменти, такі як [Firmadyne](https://github.com/firmadyne/firmadyne), [Firmware Analysis Toolkit](https://github.com/attify/firmware-analysis-toolkit) та інші, полегшують повну емуляцію прошивки, автоматизуючи процес і допомагаючи в динамічному аналізі.

## Динамічний аналіз на практиці

На цьому етапі використовується реальне або емульоване середовище пристрою для аналізу. Важливо підтримувати доступ до оболонки ОС та файлової системи. Емуляція може не ідеально відтворювати взаємодію з апаратним забезпеченням, що потребує періодичних перезапусків емуляції. Аналіз повинен повторно перевіряти файлову систему, експлуатувати відкриті веб-сторінки та мережеві сервіси, а також досліджувати вразливості завантажувача. Тести цілісності прошивки є критично важливими для виявлення потенційних вразливостей бекдора.

## Техніки аналізу в реальному часі

Аналіз в реальному часі передбачає взаємодію з процесом або бінарним файлом у його операційному середовищі, використовуючи інструменти, такі як gdb-multiarch, Frida та Ghidra для встановлення точок зупинки та виявлення вразливостей через фуззинг та інші техніки.

## Експлуатація бінарних файлів та доказ концепції

Розробка PoC для виявлених вразливостей вимагає глибокого розуміння цільової архітектури та програмування на мовах нижчого рівня. Захисти бінарного виконання в вбудованих системах рідкісні, але коли вони присутні, можуть знадобитися такі техніки, як Return Oriented Programming (ROP).

## Підготовлені операційні системи для аналізу прошивки

Операційні системи, такі як [AttifyOS](https://github.com/adi0x90/attifyos) та [EmbedOS](https://github.com/scriptingxss/EmbedOS), надають попередньо налаштовані середовища для тестування безпеки прошивки, оснащені необхідними інструментами.

## Підготовлені ОС для аналізу прошивки

- [**AttifyOS**](https://github.com/adi0x90/attifyos): AttifyOS - це дистрибутив, призначений для допомоги у проведенні оцінки безпеки та тестування на проникнення пристроїв Інтернету речей (IoT). Він економить ваш час, надаючи попередньо налаштоване середовище з усіма необхідними інструментами.
- [**EmbedOS**](https://github.com/scriptingxss/EmbedOS): Операційна система для тестування безпеки вбудованих систем на базі Ubuntu 18.04, попередньо завантажена інструментами для тестування безпеки прошивки.

## Вразлива прошивка для практики

Щоб практикувати виявлення вразливостей у прошивці, використовуйте наступні вразливі проекти прошивки як відправну точку.

- OWASP IoTGoat
- [https://github.com/OWASP/IoTGoat](https://github.com/OWASP/IoTGoat)
- Проект Damn Vulnerable Router Firmware
- [https://github.com/praetorian-code/DVRF](https://github.com/praetorian-code/DVRF)
- Damn Vulnerable ARM Router (DVAR)
- [https://blog.exploitlab.net/2018/01/dvar-damn-vulnerable-arm-router.html](https://blog.exploitlab.net/2018/01/dvar-damn-vulnerable-arm-router.html)
- ARM-X
- [https://github.com/therealsaumil/armx#downloads](https://github.com/therealsaumil/armx#downloads)
- Azeria Labs VM 2.0
- [https://azeria-labs.com/lab-vm-2-0/](https://azeria-labs.com/lab-vm-2-0/)
- Damn Vulnerable IoT Device (DVID)
- [https://github.com/Vulcainreo/DVID](https://github.com/Vulcainreo/DVID)

## Посилання

- [https://scriptingxss.gitbook.io/firmware-security-testing-methodology/](https://scriptingxss.gitbook.io/firmware-security-testing-methodology/)
- [Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things](https://www.amazon.co.uk/Practical-IoT-Hacking-F-Chantzis/dp/1718500904)

## Тренінг та сертифікація

- [https://www.attify-store.com/products/offensive-iot-exploitation](https://www.attify-store.com/products/offensive-iot-exploitation)

{{#include ../../banners/hacktricks-training.md}}
