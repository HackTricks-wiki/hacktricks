# 2. Δειγματοληψία Δεδομένων

{{#include ../../banners/hacktricks-training.md}}

## **Δειγματοληψία Δεδομένων**

Η **Δειγματοληψία Δεδομένων** είναι μια κρίσιμη διαδικασία στην προετοιμασία δεδομένων για την εκπαίδευση μεγάλων γλωσσικών μοντέλων (LLMs) όπως το GPT. Περιλαμβάνει την οργάνωση των κειμένων σε εισόδους και στόχους που το μοντέλο χρησιμοποιεί για να μάθει πώς να προβλέπει την επόμενη λέξη (ή το token) με βάση τις προηγούμενες λέξεις. Η σωστή δειγματοληψία δεδομένων διασφαλίζει ότι το μοντέλο συλλαμβάνει αποτελεσματικά τα γλωσσικά μοτίβα και τις εξαρτήσεις.

> [!TIP]
> Ο στόχος αυτής της δεύτερης φάσης είναι πολύ απλός: **Δειγματοληψία των εισερχόμενων δεδομένων και προετοιμασία τους για τη φάση εκπαίδευσης, συνήθως διαχωρίζοντας το σύνολο δεδομένων σε προτάσεις συγκεκριμένου μήκους και δημιουργώντας επίσης την αναμενόμενη απάντηση.**

### **Γιατί η Δειγματοληψία Δεδομένων έχει Σημασία**

Τα LLMs όπως το GPT εκπαιδεύονται να παράγουν ή να προβλέπουν κείμενο κατανοώντας το πλαίσιο που παρέχεται από τις προηγούμενες λέξεις. Για να επιτευχθεί αυτό, τα δεδομένα εκπαίδευσης πρέπει να είναι δομημένα με τρόπο που το μοντέλο να μπορεί να μάθει τη σχέση μεταξύ ακολουθιών λέξεων και των επόμενων λέξεων τους. Αυτή η δομημένη προσέγγιση επιτρέπει στο μοντέλο να γενικεύει και να παράγει συνεκτικό και σχετικό κείμενο.

### **Βασικές Έννοιες στη Δειγματοληψία Δεδομένων**

1. **Tokenization:** Διαχωρισμός του κειμένου σε μικρότερες μονάδες που ονομάζονται tokens (π.χ., λέξεις, υπολέξεις ή χαρακτήρες).
2. **Μήκος Ακολουθίας (max_length):** Ο αριθμός των tokens σε κάθε ακολουθία εισόδου.
3. **Ολισθηρό Παράθυρο:** Μια μέθοδος για τη δημιουργία επικαλυπτόμενων ακολουθιών εισόδου μετακινώντας ένα παράθυρο πάνω από το κειμένο που έχει διαχωριστεί σε tokens.
4. **Stride:** Ο αριθμός των tokens που το ολισθηρό παράθυρο μετακινείται προς τα εμπρός για να δημιουργήσει την επόμενη ακολουθία.

### **Βήμα-Βήμα Παράδειγμα**

Ας περάσουμε από ένα παράδειγμα για να απεικονίσουμε τη δειγματοληψία δεδομένων.

**Παράδειγμα Κειμένου**
```arduino
"Lorem ipsum dolor sit amet, consectetur adipiscing elit."
```
**Tokenization**

Υποθέστε ότι χρησιμοποιούμε έναν **βασικό tokenizer** που χωρίζει το κείμενο σε λέξεις και σημεία στίξης:
```vbnet
Tokens: ["Lorem", "ipsum", "dolor", "sit", "amet,", "consectetur", "adipiscing", "elit."]
```
**Παράμετροι**

- **Μέγιστο Μήκος Ακολουθίας (max_length):** 4 tokens
- **Βήμα Ολισθηρού Παραθύρου:** 1 token

**Δημιουργία Εισόδων και Στοχευμένων Ακολουθιών**

1. **Προσέγγιση Ολισθηρού Παραθύρου:**
- **Εισόδους:** Κάθε είσοδος αποτελείται από `max_length` tokens.
- **Στοχευμένες Ακολουθίες:** Κάθε στοχευμένη ακολουθία αποτελείται από τα tokens που ακολουθούν άμεσα την αντίστοιχη είσοδο.
2. **Δημιουργία Ακολουθιών:**

<table><thead><tr><th width="177">Θέση Παραθύρου</th><th>Είσοδος</th><th>Στοχευμένη Ακολουθία</th></tr></thead><tbody><tr><td>1</td><td>["Lorem", "ipsum", "dolor", "sit"]</td><td>["ipsum", "dolor", "sit", "amet,"]</td></tr><tr><td>2</td><td>["ipsum", "dolor", "sit", "amet,"]</td><td>["dolor", "sit", "amet,", "consectetur"]</td></tr><tr><td>3</td><td>["dolor", "sit", "amet,", "consectetur"]</td><td>["sit", "amet,", "consectetur", "adipiscing"]</td></tr><tr><td>4</td><td>["sit", "amet,", "consectetur", "adipiscing"]</td><td>["amet,", "consectetur", "adipiscing", "elit."]</td></tr></tbody></table>

3. **Αποτελέσματα Εισόδων και Στοχευμένων Πινάκων:**

- **Είσοδος:**

```python
[
["Lorem", "ipsum", "dolor", "sit"],
["ipsum", "dolor", "sit", "amet,"],
["dolor", "sit", "amet,", "consectetur"],
["sit", "amet,", "consectetur", "adipiscing"],
]
```

- **Στοχευμένη:**

```python
[
["ipsum", "dolor", "sit", "amet,"],
["dolor", "sit", "amet,", "consectetur"],
["sit", "amet,", "consectetur", "adipiscing"],
["amet,", "consectetur", "adipiscing", "elit."],
]
```

**Οπτική Αναπαράσταση**

<table><thead><tr><th width="222">Θέση Token</th><th>Token</th></tr></thead><tbody><tr><td>1</td><td>Lorem</td></tr><tr><td>2</td><td>ipsum</td></tr><tr><td>3</td><td>dolor</td></tr><tr><td>4</td><td>sit</td></tr><tr><td>5</td><td>amet,</td></tr><tr><td>6</td><td>consectetur</td></tr><tr><td>7</td><td>adipiscing</td></tr><tr><td>8</td><td>elit.</td></tr></tbody></table>

**Ολισθηρό Παράθυρο με Βήμα 1:**

- **Πρώτο Παράθυρο (Θέσεις 1-4):** \["Lorem", "ipsum", "dolor", "sit"] → **Στοχευμένη:** \["ipsum", "dolor", "sit", "amet,"]
- **Δεύτερο Παράθυρο (Θέσεις 2-5):** \["ipsum", "dolor", "sit", "amet,"] → **Στοχευμένη:** \["dolor", "sit", "amet,", "consectetur"]
- **Τρίτο Παράθυρο (Θέσεις 3-6):** \["dolor", "sit", "amet,", "consectetur"] → **Στοχευμένη:** \["sit", "amet,", "consectetur", "adipiscing"]
- **Τέταρτο Παράθυρο (Θέσεις 4-7):** \["sit", "amet,", "consectetur", "adipiscing"] → **Στοχευμένη:** \["amet,", "consectetur", "adipiscing", "elit."]

**Κατανόηση Βήματος**

- **Βήμα 1:** Το παράθυρο προχωράει μπροστά κατά ένα token κάθε φορά, με αποτέλεσμα πολύ επικαλυπτόμενες ακολουθίες. Αυτό μπορεί να οδηγήσει σε καλύτερη εκμάθηση των συμφραζομένων αλλά μπορεί να αυξήσει τον κίνδυνο υπερπροσαρμογής καθώς τα παρόμοια σημεία δεδομένων επαναλαμβάνονται.
- **Βήμα 2:** Το παράθυρο προχωράει μπροστά κατά δύο tokens κάθε φορά, μειώνοντας την επικάλυψη. Αυτό μειώνει την πλεονασματικότητα και το υπολογιστικό φορτίο αλλά μπορεί να χάσει κάποιες λεπτομέρειες συμφραζομένων.
- **Βήμα Ίσο με το max_length:** Το παράθυρο προχωράει μπροστά κατά το συνολικό μέγεθος του παραθύρου, με αποτέλεσμα μη επικαλυπτόμενες ακολουθίες. Αυτό ελαχιστοποιεί την πλεονασματικότητα των δεδομένων αλλά μπορεί να περιορίσει την ικανότητα του μοντέλου να μάθει εξαρτήσεις μεταξύ των ακολουθιών.

**Παράδειγμα με Βήμα 2:**

Χρησιμοποιώντας το ίδιο κείμενο με tokens και `max_length` 4:

- **Πρώτο Παράθυρο (Θέσεις 1-4):** \["Lorem", "ipsum", "dolor", "sit"] → **Στοχευμένη:** \["ipsum", "dolor", "sit", "amet,"]
- **Δεύτερο Παράθυρο (Θέσεις 3-6):** \["dolor", "sit", "amet,", "consectetur"] → **Στοχευμένη:** \["sit", "amet,", "consectetur", "adipiscing"]
- **Τρίτο Παράθυρο (Θέσεις 5-8):** \["amet,", "consectetur", "adipiscing", "elit."] → **Στοχευμένη:** \["consectetur", "adipiscing", "elit.", "sed"] _(Υποθέτοντας συνέχεια)_

## Παράδειγμα Κώδικα

Ας κατανοήσουμε αυτό καλύτερα από ένα παράδειγμα κώδικα από [https://github.com/rasbt/LLMs-from-scratch/blob/main/ch02/01_main-chapter-code/ch02.ipynb](https://github.com/rasbt/LLMs-from-scratch/blob/main/ch02/01_main-chapter-code/ch02.ipynb):
```python
# Download the text to pre-train the LLM
import urllib.request
url = ("https://raw.githubusercontent.com/rasbt/LLMs-from-scratch/main/ch02/01_main-chapter-code/the-verdict.txt")
file_path = "the-verdict.txt"
urllib.request.urlretrieve(url, file_path)

with open("the-verdict.txt", "r", encoding="utf-8") as f:
raw_text = f.read()

"""
Create a class that will receive some params lie tokenizer and text
and will prepare the input chunks and the target chunks to prepare
the LLM to learn which next token to generate
"""
import torch
from torch.utils.data import Dataset, DataLoader

class GPTDatasetV1(Dataset):
def __init__(self, txt, tokenizer, max_length, stride):
self.input_ids = []
self.target_ids = []

# Tokenize the entire text
token_ids = tokenizer.encode(txt, allowed_special={"<|endoftext|>"})

# Use a sliding window to chunk the book into overlapping sequences of max_length
for i in range(0, len(token_ids) - max_length, stride):
input_chunk = token_ids[i:i + max_length]
target_chunk = token_ids[i + 1: i + max_length + 1]
self.input_ids.append(torch.tensor(input_chunk))
self.target_ids.append(torch.tensor(target_chunk))

def __len__(self):
return len(self.input_ids)

def __getitem__(self, idx):
return self.input_ids[idx], self.target_ids[idx]


"""
Create a data loader which given the text and some params will
prepare the inputs and targets with the previous class and
then create a torch DataLoader with the info
"""

import tiktoken

def create_dataloader_v1(txt, batch_size=4, max_length=256,
stride=128, shuffle=True, drop_last=True,
num_workers=0):

# Initialize the tokenizer
tokenizer = tiktoken.get_encoding("gpt2")

# Create dataset
dataset = GPTDatasetV1(txt, tokenizer, max_length, stride)

# Create dataloader
dataloader = DataLoader(
dataset,
batch_size=batch_size,
shuffle=shuffle,
drop_last=drop_last,
num_workers=num_workers
)

return dataloader


"""
Finally, create the data loader with the params we want:
- The used text for training
- batch_size: The size of each batch
- max_length: The size of each entry on each batch
- stride: The sliding window (how many tokens should the next entry advance compared to the previous one). The smaller the more overfitting, usually this is equals to the max_length so the same tokens aren't repeated.
- shuffle: Re-order randomly
"""
dataloader = create_dataloader_v1(
raw_text, batch_size=8, max_length=4, stride=1, shuffle=False
)

data_iter = iter(dataloader)
first_batch = next(data_iter)
print(first_batch)

# Note the batch_size of 8, the max_length of 4 and the stride of 1
[
# Input
tensor([[   40,   367,  2885,  1464],
[  367,  2885,  1464,  1807],
[ 2885,  1464,  1807,  3619],
[ 1464,  1807,  3619,   402],
[ 1807,  3619,   402,   271],
[ 3619,   402,   271, 10899],
[  402,   271, 10899,  2138],
[  271, 10899,  2138,   257]]),
# Target
tensor([[  367,  2885,  1464,  1807],
[ 2885,  1464,  1807,  3619],
[ 1464,  1807,  3619,   402],
[ 1807,  3619,   402,   271],
[ 3619,   402,   271, 10899],
[  402,   271, 10899,  2138],
[  271, 10899,  2138,   257],
[10899,  2138,   257,  7026]])
]

# With stride=4 this will be the result:
[
# Input
tensor([[   40,   367,  2885,  1464],
[ 1807,  3619,   402,   271],
[10899,  2138,   257,  7026],
[15632,   438,  2016,   257],
[  922,  5891,  1576,   438],
[  568,   340,   373,   645],
[ 1049,  5975,   284,   502],
[  284,  3285,   326,    11]]),
# Target
tensor([[  367,  2885,  1464,  1807],
[ 3619,   402,   271, 10899],
[ 2138,   257,  7026, 15632],
[  438,  2016,   257,   922],
[ 5891,  1576,   438,   568],
[  340,   373,   645,  1049],
[ 5975,   284,   502,   284],
[ 3285,   326,    11,   287]])
]
```
## Στρατηγικές Προχωρημένης Δειγματοληψίας (2023-2025)

### 1. Ζυγισμένη Μίξη Βασισμένη στη Θερμοκρασία
Τα πιο προηγμένα LLM σπάνια εκπαιδεύονται σε ένα μόνο σώμα. Αντίθετα, δειγματοληπτούν από πολλές ετερογενείς πηγές δεδομένων (κώδικας, ιστός, ακαδημαϊκά άρθρα, φόρουμ…). Η σχετική αναλογία κάθε πηγής μπορεί να επηρεάσει σημαντικά την απόδοση κατά την εκτέλεση. Πρόσφατα ανοιχτού κώδικα μοντέλα όπως το Llama 2 εισήγαγαν ένα **σχέδιο δειγματοληψίας βασισμένο στη θερμοκρασία** όπου η πιθανότητα επιλογής ενός εγγράφου από το σώμα *i* γίνεται
```
p(i) = \frac{w_i^{\alpha}}{\sum_j w_j^{\alpha}}
```
• *w<sub>i</sub>*  – ποσοστό ακατέργαστου κειμένου του σώματος *i*  
• *α* ("θερμοκρασία") – μια τιμή στο (0,1].  α < 1 επίπεδοποιεί την κατανομή, δίνοντας περισσότερη βαρύτητα σε μικρότερα σώματα υψηλής ποιότητας.  

Το Llama 2 χρησιμοποίησε α = 0.7 και έδειξε ότι η μείωση του α αύξησε τις βαθμολογίες αξιολόγησης σε εργασίες που απαιτούν γνώσεις, διατηρώντας σταθερό το μείγμα εκπαίδευσης.  Το ίδιο κόλπο υιοθετεί και το Mistral (2023) και το Claude 3.
```python
from collections import Counter

def temperature_sample(corpus_ids, alpha=0.7):
counts = Counter(corpus_ids)           # number of tokens seen per corpus
probs  = {c: c_count**alpha for c, c_count in counts.items()}
Z = sum(probs.values())
probs = {c: p/Z for c, p in probs.items()}
# Now draw according to probs to fill every batch
```

```

### 2. Sequence Packing / Dynamic Batching
GPU memory is wasted when every sequence in a batch is padded to the longest example.  "Packing" concatenates multiple shorter sequences until the **exact** `max_length` is reached and builds a parallel `attention_mask` so that tokens do not attend across segment boundaries.  Packing can improve throughput by 20–40 % with no gradient change and is supported out-of-the-box in

* PyTorch `torchtext.experimental.agents.PackedBatch`
* HuggingFace `DataCollatorForLanguageModeling(pad_to_multiple_of=…)`

Dynamic batching frameworks (e.g. FlashAttention 2, vLLM 2024) combine sequence packing with just-in-time kernel selection, enabling thousand-token context training at 400+ K tokens/s on A100-80G.

### 3. Deduplication & Quality Filtering
Repeated passages cause memorization and provide an easy channel for data-poisoning.  Modern pipelines therefore:

1. MinHash/FAISS near-duplicate detection at **document** and **128-gram** level.
2. Filter documents whose perplexity under a small reference model is > µ + 3σ (noisy OCR, garbled HTML).
3. Block-list documents that contain PII or CWE keywords using regex & spaCy NER.

The Llama 2 team deduplicated with 8-gram MinHash and removed ~15 % of CommonCrawl before sampling.  OpenAI’s 2024 "Deduplicate Everything" paper demonstrates ≤0.04 duplicate ratio reduces over-fitting and speeds convergence.

## Security & Privacy Considerations During Sampling

### Data-Poisoning / Backdoor Attacks
Researchers showed that inserting <1 % backdoored sentences can make a model obey a hidden trigger ("PoisonGPT", 2023).  Recommended mitigations:

* **Shuffled mixing** – make sure adjacent training examples originate from different sources; this dilutes gradient alignment of malicious spans.
* **Gradient similarity scoring** – compute cosine similarity of example gradient to batch average; outliers are candidates for removal.
* **Dataset versioning & hashes** – freeze immutable tarballs and verify SHA-256 before each training run.

### Membership-Inference & Memorization
Long overlap between sliding-window samples increases the chance that rare strings (telephone numbers, secret keys) are memorized.  OpenAI’s 2024 study on ChatGPT memorization reports that raising stride from 1 × `max_length` to 4 × reduces verbatim leakage by ≈50 % with negligible loss in perplexity.

Practical recommendations:

* Use **stride ≥ max_length** except for <1B parameter models where data volume is scarce.
* Add random masking of 1-3 tokens per window during training; this lowers memorization while preserving utility.

---

## References

- [Build a Large Language Model from Scratch (Manning, 2024)](https://www.manning.com/books/build-a-large-language-model-from-scratch)
- [Llama 2: Open Foundation and Fine-Tuned Chat Models (2023)](https://arxiv.org/abs/2307.09288)
- [PoisonGPT: Assessing Backdoor Vulnerabilities in Large Language Models (BlackHat EU 2023)](https://arxiv.org/abs/2308.12364)

{{#include ../../banners/hacktricks-training.md}}
