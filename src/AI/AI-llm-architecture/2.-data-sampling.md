# 2. Veri Örnekleme

{{#include ../../banners/hacktricks-training.md}}

## **Veri Örnekleme**

**Veri Örnekleme**, GPT gibi büyük dil modellerinin (LLM'ler) eğitimi için veri hazırlamada kritik bir süreçtir. Bu, metin verilerini modelin önceki kelimelere dayanarak bir sonraki kelimeyi (veya token'ı) tahmin etmeyi öğrenmesi için kullandığı giriş ve hedef dizilerine organize etmeyi içerir. Doğru veri örnekleme, modelin dil kalıplarını ve bağımlılıklarını etkili bir şekilde yakalamasını sağlar.

> [!TIP]
> Bu ikinci aşamanın amacı çok basittir: **Giriş verilerini örnekleyin ve genellikle veri kümesini belirli bir uzunluktaki cümlelere ayırarak ve beklenen yanıtı da üreterek eğitim aşamasına hazırlayın.**

### **Veri Örneklemenin Önemi**

GPT gibi LLM'ler, önceki kelimelerin sağladığı bağlamı anlayarak metin üretmek veya tahmin etmek için eğitilir. Bunu başarmak için, eğitim verileri modelin kelime dizileri ile bunların sonraki kelimeleri arasındaki ilişkiyi öğrenebileceği bir şekilde yapılandırılmalıdır. Bu yapılandırılmış yaklaşım, modelin genelleştirmesine ve tutarlı ve bağlamsal olarak ilgili metinler üretmesine olanak tanır.

### **Veri Örneklemede Temel Kavramlar**

1. **Tokenizasyon:** Metni token (örneğin, kelimeler, alt kelimeler veya karakterler) adı verilen daha küçük birimlere ayırma.
2. **Dizi Uzunluğu (max_length):** Her giriş dizisindeki token sayısı.
3. **Kaydırma Penceresi:** Tokenize edilmiş metin üzerinde bir pencereyi hareket ettirerek örtüşen giriş dizileri oluşturma yöntemi.
4. **Adım:** Kaydırma penceresinin bir sonraki diziyi oluşturmak için ileriye doğru hareket ettiği token sayısı.

### **Adım Adım Örnek**

Veri örneklemesini açıklamak için bir örnek üzerinden geçelim.

**Örnek Metin**
```arduino
"Lorem ipsum dolor sit amet, consectetur adipiscing elit."
```
**Tokenizasyon**

Bir **temel tokenleştirici** kullandığımızı varsayalım, bu metni kelimelere ve noktalama işaretlerine ayırır:
```vbnet
Tokens: ["Lorem", "ipsum", "dolor", "sit", "amet,", "consectetur", "adipiscing", "elit."]
```
**Parametreler**

- **Maksimum Dizi Uzunluğu (max_length):** 4 token
- **Kaydırma Penceresi Adımı:** 1 token

**Girdi ve Hedef Dizileri Oluşturma**

1. **Kaydırma Penceresi Yaklaşımı:**
- **Girdi Dizileri:** Her girdi dizisi `max_length` token içerir.
- **Hedef Dizileri:** Her hedef dizisi, ilgili girdi dizisini hemen takip eden token'ları içerir.
2. **Dizileri Oluşturma:**

<table><thead><tr><th width="177">Pencere Pozisyonu</th><th>Girdi Dizisi</th><th>Hedef Dizisi</th></tr></thead><tbody><tr><td>1</td><td>["Lorem", "ipsum", "dolor", "sit"]</td><td>["ipsum", "dolor", "sit", "amet,"]</td></tr><tr><td>2</td><td>["ipsum", "dolor", "sit", "amet,"]</td><td>["dolor", "sit", "amet,", "consectetur"]</td></tr><tr><td>3</td><td>["dolor", "sit", "amet,", "consectetur"]</td><td>["sit", "amet,", "consectetur", "adipiscing"]</td></tr><tr><td>4</td><td>["sit", "amet,", "consectetur", "adipiscing"]</td><td>["amet,", "consectetur", "adipiscing", "elit."]</td></tr></tbody></table>

3. **Elde Edilen Girdi ve Hedef Dizileri:**

- **Girdi:**

```python
[
["Lorem", "ipsum", "dolor", "sit"],
["ipsum", "dolor", "sit", "amet,"],
["dolor", "sit", "amet,", "consectetur"],
["sit", "amet,", "consectetur", "adipiscing"],
]
```

- **Hedef:**

```python
[
["ipsum", "dolor", "sit", "amet,"],
["dolor", "sit", "amet,", "consectetur"],
["sit", "amet,", "consectetur", "adipiscing"],
["amet,", "consectetur", "adipiscing", "elit."],
]
```

**Görsel Temsil**

<table><thead><tr><th width="222">Token Pozisyonu</th><th>Token</th></tr></thead><tbody><tr><td>1</td><td>Lorem</td></tr><tr><td>2</td><td>ipsum</td></tr><tr><td>3</td><td>dolor</td></tr><tr><td>4</td><td>sit</td></tr><tr><td>5</td><td>amet,</td></tr><tr><td>6</td><td>consectetur</td></tr><tr><td>7</td><td>adipiscing</td></tr><tr><td>8</td><td>elit.</td></tr></tbody></table>

**Adım 1 ile Kaydırma Penceresi:**

- **İlk Pencere (Pozisyonlar 1-4):** \["Lorem", "ipsum", "dolor", "sit"] → **Hedef:** \["ipsum", "dolor", "sit", "amet,"]
- **İkinci Pencere (Pozisyonlar 2-5):** \["ipsum", "dolor", "sit", "amet,"] → **Hedef:** \["dolor", "sit", "amet,", "consectetur"]
- **Üçüncü Pencere (Pozisyonlar 3-6):** \["dolor", "sit", "amet,", "consectetur"] → **Hedef:** \["sit", "amet,", "consectetur", "adipiscing"]
- **Dördüncü Pencere (Pozisyonlar 4-7):** \["sit", "amet,", "consectetur", "adipiscing"] → **Hedef:** \["amet,", "consectetur", "adipiscing", "elit."]

**Adımı Anlama**

- **Adım 1:** Pencere her seferinde bir token ileri hareket eder, bu da yüksek oranda örtüşen dizilerle sonuçlanır. Bu, bağlamsal ilişkilerin daha iyi öğrenilmesine yol açabilir ancak benzer veri noktalarının tekrar edilmesi nedeniyle aşırı uyum riski artırabilir.
- **Adım 2:** Pencere her seferinde iki token ileri hareket eder, örtüşmeyi azaltır. Bu, tekrarları ve hesaplama yükünü azaltır ancak bazı bağlamsal nüansları kaçırabilir.
- **max_length'e Eşit Adım:** Pencere, tüm pencere boyutu kadar ileri hareket eder, bu da örtüşmeyen dizilerle sonuçlanır. Bu, veri tekrarını en aza indirir ancak modelin diziler arasındaki bağımlılıkları öğrenme yeteneğini sınırlayabilir.

**Adım 2 ile Örnek:**

Aynı tokenleştirilmiş metni ve `max_length` değerini 4 kullanarak:

- **İlk Pencere (Pozisyonlar 1-4):** \["Lorem", "ipsum", "dolor", "sit"] → **Hedef:** \["ipsum", "dolor", "sit", "amet,"]
- **İkinci Pencere (Pozisyonlar 3-6):** \["dolor", "sit", "amet,", "consectetur"] → **Hedef:** \["sit", "amet,", "consectetur", "adipiscing"]
- **Üçüncü Pencere (Pozisyonlar 5-8):** \["amet,", "consectetur", "adipiscing", "elit."] → **Hedef:** \["consectetur", "adipiscing", "elit.", "sed"] _(Devam ettiğini varsayarak)_

## Kod Örneği

Bunu daha iyi anlamak için [https://github.com/rasbt/LLMs-from-scratch/blob/main/ch02/01_main-chapter-code/ch02.ipynb](https://github.com/rasbt/LLMs-from-scratch/blob/main/ch02/01_main-chapter-code/ch02.ipynb) adresinden bir kod örneğine bakalım:
```python
# Download the text to pre-train the LLM
import urllib.request
url = ("https://raw.githubusercontent.com/rasbt/LLMs-from-scratch/main/ch02/01_main-chapter-code/the-verdict.txt")
file_path = "the-verdict.txt"
urllib.request.urlretrieve(url, file_path)

with open("the-verdict.txt", "r", encoding="utf-8") as f:
raw_text = f.read()

"""
Create a class that will receive some params lie tokenizer and text
and will prepare the input chunks and the target chunks to prepare
the LLM to learn which next token to generate
"""
import torch
from torch.utils.data import Dataset, DataLoader

class GPTDatasetV1(Dataset):
def __init__(self, txt, tokenizer, max_length, stride):
self.input_ids = []
self.target_ids = []

# Tokenize the entire text
token_ids = tokenizer.encode(txt, allowed_special={"<|endoftext|>"})

# Use a sliding window to chunk the book into overlapping sequences of max_length
for i in range(0, len(token_ids) - max_length, stride):
input_chunk = token_ids[i:i + max_length]
target_chunk = token_ids[i + 1: i + max_length + 1]
self.input_ids.append(torch.tensor(input_chunk))
self.target_ids.append(torch.tensor(target_chunk))

def __len__(self):
return len(self.input_ids)

def __getitem__(self, idx):
return self.input_ids[idx], self.target_ids[idx]


"""
Create a data loader which given the text and some params will
prepare the inputs and targets with the previous class and
then create a torch DataLoader with the info
"""

import tiktoken

def create_dataloader_v1(txt, batch_size=4, max_length=256,
stride=128, shuffle=True, drop_last=True,
num_workers=0):

# Initialize the tokenizer
tokenizer = tiktoken.get_encoding("gpt2")

# Create dataset
dataset = GPTDatasetV1(txt, tokenizer, max_length, stride)

# Create dataloader
dataloader = DataLoader(
dataset,
batch_size=batch_size,
shuffle=shuffle,
drop_last=drop_last,
num_workers=num_workers
)

return dataloader


"""
Finally, create the data loader with the params we want:
- The used text for training
- batch_size: The size of each batch
- max_length: The size of each entry on each batch
- stride: The sliding window (how many tokens should the next entry advance compared to the previous one). The smaller the more overfitting, usually this is equals to the max_length so the same tokens aren't repeated.
- shuffle: Re-order randomly
"""
dataloader = create_dataloader_v1(
raw_text, batch_size=8, max_length=4, stride=1, shuffle=False
)

data_iter = iter(dataloader)
first_batch = next(data_iter)
print(first_batch)

# Note the batch_size of 8, the max_length of 4 and the stride of 1
[
# Input
tensor([[   40,   367,  2885,  1464],
[  367,  2885,  1464,  1807],
[ 2885,  1464,  1807,  3619],
[ 1464,  1807,  3619,   402],
[ 1807,  3619,   402,   271],
[ 3619,   402,   271, 10899],
[  402,   271, 10899,  2138],
[  271, 10899,  2138,   257]]),
# Target
tensor([[  367,  2885,  1464,  1807],
[ 2885,  1464,  1807,  3619],
[ 1464,  1807,  3619,   402],
[ 1807,  3619,   402,   271],
[ 3619,   402,   271, 10899],
[  402,   271, 10899,  2138],
[  271, 10899,  2138,   257],
[10899,  2138,   257,  7026]])
]

# With stride=4 this will be the result:
[
# Input
tensor([[   40,   367,  2885,  1464],
[ 1807,  3619,   402,   271],
[10899,  2138,   257,  7026],
[15632,   438,  2016,   257],
[  922,  5891,  1576,   438],
[  568,   340,   373,   645],
[ 1049,  5975,   284,   502],
[  284,  3285,   326,    11]]),
# Target
tensor([[  367,  2885,  1464,  1807],
[ 3619,   402,   271, 10899],
[ 2138,   257,  7026, 15632],
[  438,  2016,   257,   922],
[ 5891,  1576,   438,   568],
[  340,   373,   645,  1049],
[ 5975,   284,   502,   284],
[ 3285,   326,    11,   287]])
]
```
## Gelişmiş Örnekleme Stratejileri (2023-2025)

### 1. Sıcaklık Tabanlı Karışım Ağırlığı
En son teknoloji LLM'ler nadiren tek bir veri kümesi üzerinde eğitilir. Bunun yerine, çeşitli heterojen veri kaynaklarından (kod, web, akademik makaleler, forumlar…) örnekleme yaparlar. Her bir kaynağın göreli oranı, aşağı akış performansını güçlü bir şekilde etkileyebilir. Llama 2 gibi son açık kaynaklı modeller, *i* veri kümesinden bir belge çekme olasılığının
```
p(i) = \frac{w_i^{\alpha}}{\sum_j w_j^{\alpha}}
```
• *w<sub>i</sub>*  – ham token yüzdesi corpus *i* için  
• *α* ("sıcaklık") – (0,1] aralığında bir değer. α < 1 dağılımı düzleştirir, daha küçük yüksek kaliteli corpuslara daha fazla ağırlık verir.  

Llama 2, α = 0.7 kullandı ve α'nın azaltılmasının bilgi ağırlıklı görevlerde değerlendirme puanlarını artırdığını gösterdi, eğitim karışımını sabit tutarken. Aynı numara Mistral (2023) ve Claude 3 tarafından benimsenmiştir.
```python
from collections import Counter

def temperature_sample(corpus_ids, alpha=0.7):
counts = Counter(corpus_ids)           # number of tokens seen per corpus
probs  = {c: c_count**alpha for c, c_count in counts.items()}
Z = sum(probs.values())
probs = {c: p/Z for c, p in probs.items()}
# Now draw according to probs to fill every batch
```

```

### 2. Sequence Packing / Dynamic Batching
GPU memory is wasted when every sequence in a batch is padded to the longest example.  "Packing" concatenates multiple shorter sequences until the **exact** `max_length` is reached and builds a parallel `attention_mask` so that tokens do not attend across segment boundaries.  Packing can improve throughput by 20–40 % with no gradient change and is supported out-of-the-box in

* PyTorch `torchtext.experimental.agents.PackedBatch`
* HuggingFace `DataCollatorForLanguageModeling(pad_to_multiple_of=…)`

Dynamic batching frameworks (e.g. FlashAttention 2, vLLM 2024) combine sequence packing with just-in-time kernel selection, enabling thousand-token context training at 400+ K tokens/s on A100-80G.

### 3. Deduplication & Quality Filtering
Repeated passages cause memorization and provide an easy channel for data-poisoning.  Modern pipelines therefore:

1. MinHash/FAISS near-duplicate detection at **document** and **128-gram** level.
2. Filter documents whose perplexity under a small reference model is > µ + 3σ (noisy OCR, garbled HTML).
3. Block-list documents that contain PII or CWE keywords using regex & spaCy NER.

The Llama 2 team deduplicated with 8-gram MinHash and removed ~15 % of CommonCrawl before sampling.  OpenAI’s 2024 "Deduplicate Everything" paper demonstrates ≤0.04 duplicate ratio reduces over-fitting and speeds convergence.

## Security & Privacy Considerations During Sampling

### Data-Poisoning / Backdoor Attacks
Researchers showed that inserting <1 % backdoored sentences can make a model obey a hidden trigger ("PoisonGPT", 2023).  Recommended mitigations:

* **Shuffled mixing** – make sure adjacent training examples originate from different sources; this dilutes gradient alignment of malicious spans.
* **Gradient similarity scoring** – compute cosine similarity of example gradient to batch average; outliers are candidates for removal.
* **Dataset versioning & hashes** – freeze immutable tarballs and verify SHA-256 before each training run.

### Membership-Inference & Memorization
Long overlap between sliding-window samples increases the chance that rare strings (telephone numbers, secret keys) are memorized.  OpenAI’s 2024 study on ChatGPT memorization reports that raising stride from 1 × `max_length` to 4 × reduces verbatim leakage by ≈50 % with negligible loss in perplexity.

Practical recommendations:

* Use **stride ≥ max_length** except for <1B parameter models where data volume is scarce.
* Add random masking of 1-3 tokens per window during training; this lowers memorization while preserving utility.

---

## References

- [Build a Large Language Model from Scratch (Manning, 2024)](https://www.manning.com/books/build-a-large-language-model-from-scratch)
- [Llama 2: Open Foundation and Fine-Tuned Chat Models (2023)](https://arxiv.org/abs/2307.09288)
- [PoisonGPT: Assessing Backdoor Vulnerabilities in Large Language Models (BlackHat EU 2023)](https://arxiv.org/abs/2308.12364)

{{#include ../../banners/hacktricks-training.md}}
