# 7.0. LoRA Verbeterings in fyn-afstemming

{{#include ../../banners/hacktricks-training.md}}

## LoRA Verbeterings

> [!TIP]
> Die gebruik van **LoRA verminder baie die berekening** wat nodig is om **fyn af te stem** reeds getrainde modelle.

LoRA maak dit moontlik om **groot modelle** doeltreffend fyn af te stem deur slegs 'n **klein deel** van die model te verander. Dit verminder die aantal parameters wat jy moet oplei, wat **geheue** en **berekeningshulpbronne** bespaar. Dit is omdat:

1. **Verminder die Aantal Opleibare Parameters**: In plaas daarvan om die hele gewigmatriks in die model op te dateer, **verdeel** LoRA die gewigmatriks in twee kleiner matrikse (genoem **A** en **B**). Dit maak opleiding **vinniger** en vereis **minder geheue** omdat minder parameters opgedateer moet word.

1. Dit is omdat dit in plaas daarvan om die volledige gewigopdatering van 'n laag (matriks) te bereken, dit benader na 'n produk van 2 kleiner matrikse wat die opdatering verminder om te bereken:\

<figure><img src="../../images/image (9) (1).png" alt=""><figcaption></figcaption></figure>

2. **Hou Oorspronklike Model Gewigte Onveranderd**: LoRA laat jou toe om die oorspronklike model gewigte dieselfde te hou, en slegs die **nuwe klein matrikse** (A en B) op te dateer. Dit is nuttig omdat dit beteken dat die oorspronklike kennis van die model bewaar word, en jy net wat nodig is, aanpas.
3. **Doeltreffende Taakspesifieke Fyn-afstemming**: Wanneer jy die model wil aanpas vir 'n **nuwe taak**, kan jy net die **klein LoRA matrikse** (A en B) oplei terwyl jy die res van die model soos dit is, laat. Dit is **baie doeltreffender** as om die hele model weer op te lei.
4. **Bergingseffektiwiteit**: Na fyn-afstemming, in plaas daarvan om 'n **heel nuwe model** vir elke taak te stoor, hoef jy slegs die **LoRA matrikse** te stoor, wat baie klein is in vergelyking met die hele model. Dit maak dit makliker om die model aan te pas vir baie take sonder om te veel berging te gebruik.

Om LoraLayers in plaas van Linear eenhede tydens 'n fyn-afstemming te implementeer, word hierdie kode hier voorgestel [https://github.com/rasbt/LLMs-from-scratch/blob/main/appendix-E/01_main-chapter-code/appendix-E.ipynb](https://github.com/rasbt/LLMs-from-scratch/blob/main/appendix-E/01_main-chapter-code/appendix-E.ipynb):
```python
import math

# Create the LoRA layer with the 2 matrices and the alpha
class LoRALayer(torch.nn.Module):
def __init__(self, in_dim, out_dim, rank, alpha):
super().__init__()
self.A = torch.nn.Parameter(torch.empty(in_dim, rank))
torch.nn.init.kaiming_uniform_(self.A, a=math.sqrt(5))  # similar to standard weight initialization
self.B = torch.nn.Parameter(torch.zeros(rank, out_dim))
self.alpha = alpha

def forward(self, x):
x = self.alpha * (x @ self.A @ self.B)
return x

# Combine it with the linear layer
class LinearWithLoRA(torch.nn.Module):
def __init__(self, linear, rank, alpha):
super().__init__()
self.linear = linear
self.lora = LoRALayer(
linear.in_features, linear.out_features, rank, alpha
)

def forward(self, x):
return self.linear(x) + self.lora(x)

# Replace linear layers with LoRA ones
def replace_linear_with_lora(model, rank, alpha):
for name, module in model.named_children():
if isinstance(module, torch.nn.Linear):
# Replace the Linear layer with LinearWithLoRA
setattr(model, name, LinearWithLoRA(module, rank, alpha))
else:
# Recursively apply the same function to child modules
replace_linear_with_lora(module, rank, alpha)
```
## Verwysings

- [https://www.manning.com/books/build-a-large-language-model-from-scratch](https://www.manning.com/books/build-a-large-language-model-from-scratch)

{{#include ../../banners/hacktricks-training.md}}
