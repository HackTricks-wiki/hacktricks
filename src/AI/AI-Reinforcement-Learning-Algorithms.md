# Αλγόριθμοι Ενισχυτικής Μάθησης

{{#include ../banners/hacktricks-training.md}}

## Ενισχυτική Μάθηση

Η ενισχυτική μάθηση (RL) είναι ένας τύπος μηχανικής μάθησης όπου ένας πράκτορας μαθαίνει να παίρνει αποφάσεις αλληλεπιδρώντας με ένα περιβάλλον. Ο πράκτορας λαμβάνει ανατροφοδότηση με τη μορφή ανταμοιβών ή ποινών βάσει των ενεργειών του, επιτρέποντάς του να μάθει βέλτιστες συμπεριφορές με την πάροδο του χρόνου. Η RL είναι ιδιαίτερα χρήσιμη για προβλήματα όπου η λύση περιλαμβάνει διαδοχική λήψη αποφάσεων, όπως ρομποτική, παιχνίδια και αυτόνομα συστήματα.

### Q-Learning

Q-Learning είναι ένας model-free αλγόριθμος ενισχυτικής μάθησης που μαθαίνει την αξία των ενεργειών σε μία δοσμένη κατάσταση. Χρησιμοποιεί έναν Q-table για να αποθηκεύει την αναμενόμενη ωφέλεια του να εκτελεστεί μια συγκεκριμένη ενέργεια σε μία συγκεκριμένη κατάσταση. Ο αλγόριθμος ενημερώνει τις Q-τιμές με βάση τις ανταμοιβές που λαμβάνονται και τις μέγιστες αναμενόμενες μελλοντικές ανταμοιβές.
1. **Αρχικοποίηση**: Αρχικοποιήστε τον Q-table με αυθαίρετες τιμές (συνήθως μηδενικά).
2. **Action Selection**: Επιλέξτε μια ενέργεια χρησιμοποιώντας μια στρατηγική εξερεύνησης (π.χ., ε-greedy, όπου με πιθανότητα ε επιλέγεται μία τυχαία ενέργεια, και με πιθανότητα 1-ε επιλέγεται η ενέργεια με την υψηλότερη Q-τιμή).
- Σημειώστε ότι ο αλγόριθμος θα μπορούσε πάντα να επιλέξει την γνωστή καλύτερη ενέργεια για μια κατάσταση, αλλά αυτό δεν θα επέτρεπε στον πράκτορα να εξερευνήσει νέες ενέργειες που ίσως αποφέρουν καλύτερες ανταμοιβές. Γι' αυτό χρησιμοποιείται η μεταβλητή ε-greedy για να εξισορροπήσει την εξερεύνηση και την εκμετάλλευση.
3. **Environment Interaction**: Εκτελέστε την επιλεγμένη ενέργεια στο περιβάλλον, παρατηρήστε την επόμενη κατάσταση και την ανταμοιβή.
- Σημειώστε ότι, ανάλογα με την πιθανότητα ε-greedy, το επόμενο βήμα μπορεί να είναι μια τυχαία ενέργεια (για εξερεύνηση) ή η καλύτερα γνωστή ενέργεια (για εκμετάλλευση).
4. **Q-Value Update**: Ενημερώστε τη Q-τιμή για το ζεύγος κατάσταση-ενέργεια χρησιμοποιώντας την εξίσωση Bellman:
```plaintext
Q(s, a) = Q(s, a) + α * (r + γ * max(Q(s', a')) - Q(s, a))
```
όπου:
- `Q(s, a)` είναι η τρέχουσα Q-τιμή για την κατάσταση `s` και την ενέργεια `a`.
- `α` είναι ο ρυθμός μάθησης (0 < α ≤ 1), που καθορίζει πόσο η νέα πληροφορία επικαλύπτει την παλιά.
- `r` είναι η ανταμοιβή που λαμβάνεται μετά την εκτέλεση της ενέργειας `a` στην κατάσταση `s`.
- `γ` είναι ο συντελεστής προεξόφλησης (0 ≤ γ < 1), που καθορίζει τη σημασία των μελλοντικών ανταμοιβών.
- `s'` είναι η επόμενη κατάσταση μετά την εκτέλεση της ενέργειας `a`.
- `max(Q(s', a'))` είναι η μέγιστη Q-τιμή για την επόμενη κατάσταση `s'` σε όλες τις δυνατές ενέργειες `a'`.
5. **Iteration**: Επαναλάβετε τα βήματα 2-4 μέχρι οι Q-τιμές να συγκλίνουν ή να ικανοποιηθεί κάποιο κριτήριο τερματισμού.

Σημειώστε ότι με κάθε νέα επιλεγμένη ενέργεια ο πίνακας ενημερώνεται, επιτρέποντας στον πράκτορα να μαθαίνει από τις εμπειρίες του με την πάροδο του χρόνου για να προσπαθήσει να βρει την βέλτιστη πολιτική (την καλύτερη ενέργεια για κάθε κατάσταση). Ωστόσο, ο Q-table μπορεί να γίνει μεγάλος για περιβάλλοντα με πολλές καταστάσεις και ενέργειες, κάνοντάς τον μη πρακτικό για σύνθετα προβλήματα. Σε τέτοιες περιπτώσεις, μπορούν να χρησιμοποιηθούν μέθοδοι προσέγγισης συναρτήσεων (π.χ., νευρωνικά δίκτυα) για την εκτίμηση των Q-τιμών.

> [!TIP]
> Η τιμή ε-greedy συνήθως ενημερώνεται με την πάροδο του χρόνου για να μειωθεί η εξερεύνηση όσο ο πράκτορας μαθαίνει περισσότερα για το περιβάλλον. Για παράδειγμα, μπορεί να ξεκινήσει με μία υψηλή τιμή (π.χ., ε = 1) και να μειωθεί σε μια χαμηλότερη τιμή (π.χ., ε = 0.1) καθώς προχωρά η μάθηση.

> [!TIP]
> Ο ρυθμός μάθησης `α` και ο συντελεστής προεξόφλησης `γ` είναι υπερπαράμετροι που πρέπει να ρυθμιστούν βάσει του συγκεκριμένου προβλήματος και του περιβάλλοντος. Ένας υψηλότερος ρυθμός μάθησης επιτρέπει στον πράκτορα να μαθαίνει γρηγορότερα αλλά μπορεί να οδηγήσει σε αστάθεια, ενώ ένας χαμηλότερος ρυθμός μάθησης οδηγεί σε πιο σταθερή μάθηση αλλά σε πιο αργή σύγκλιση. Ο συντελεστής προεξόφλησης καθορίζει πόσο ο πράκτορας εκτιμά τις μελλοντικές ανταμοιβές (`γ` κοντά στο 1) σε σύγκριση με τις άμεσες ανταμοιβές.

### SARSA (State-Action-Reward-State-Action)

SARSA είναι ένας άλλος model-free αλγόριθμος ενισχυτικής μάθησης που είναι παρόμοιος με το Q-Learning αλλά διαφέρει στον τρόπο που ενημερώνει τις Q-τιμές. SARSA stands for State-Action-Reward-State-Action, και ενημερώνει τις Q-τιμές με βάση την ενέργεια που θα ληφθεί στην επόμενη κατάσταση, αντί για την μέγιστη Q-τιμή.
1. **Initialization**: Αρχικοποιήστε τον Q-table με αυθαίρετες τιμές (συνήθως μηδενικά).
2. **Action Selection**: Επιλέξτε μια ενέργεια χρησιμοποιώντας μια στρατηγική εξερεύνησης (π.χ., ε-greedy).
3. **Environment Interaction**: Εκτελέστε την επιλεγμένη ενέργεια στο περιβάλλον, παρατηρήστε την επόμενη κατάσταση και την ανταμοιβή.
- Σημειώστε ότι, ανάλογα με την πιθανότητα ε-greedy, το επόμενο βήμα μπορεί να είναι μια τυχαία ενέργεια (για εξερεύνηση) ή η καλύτερα γνωστή ενέργεια (για εκμετάλλευση).
4. **Q-Value Update**: Ενημερώστε τη Q-τιμή για το ζεύγος κατάσταση-ενέργεια χρησιμοποιώντας τον κανόνα ενημέρωσης του SARSA. Σημειώστε ότι ο κανόνας ενημέρωσης είναι παρόμοιος με τον Q-Learning, αλλά χρησιμοποιεί την ενέργεια που θα ληφθεί στην επόμενη κατάσταση `s'` αντί για την μέγιστη Q-τιμή για εκείνη την κατάσταση:
```plaintext
Q(s, a) = Q(s, a) + α * (r + γ * Q(s', a') - Q(s, a))
```
όπου:
- `Q(s, a)` είναι η τρέχουσα Q-τιμή για την κατάσταση `s` και την ενέργεια `a`.
- `α` είναι ο ρυθμός μάθησης.
- `r` είναι η ανταμοιβή που λαμβάνεται μετά την εκτέλεση της ενέργειας `a` στην κατάσταση `s`.
- `γ` είναι ο συντελεστής προεξόφλησης.
- `s'` είναι η επόμενη κατάσταση μετά την εκτέλεση της ενέργειας `a`.
- `a'` είναι η ενέργεια που λαμβάνεται στην επόμενη κατάσταση `s'`.
5. **Iteration**: Επαναλάβετε τα βήματα 2-4 μέχρι οι Q-τιμές να συγκλίνουν ή να ικανοποιηθεί κάποιο κριτήριο τερματισμού.

#### Softmax vs ε-Greedy Επιλογή Δράσης

Εκτός από την επιλογή ενέργειας με ε-greedy, το SARSA μπορεί επίσης να χρησιμοποιήσει μια στρατηγική επιλογής ενέργειας softmax. Στην επιλογή ενέργειας softmax, η πιθανότητα επιλογής μιας ενέργειας είναι **αναλογική της Q-τιμής της**, επιτρέποντας μια πιο λεπτή εξερεύνηση του χώρου ενεργειών. Η πιθανότητα επιλογής της ενέργειας `a` στην κατάσταση `s` δίνεται από:
```plaintext
P(a|s) = exp(Q(s, a) / τ) / Σ(exp(Q(s, a') / τ))
```
όπου:
- `P(a|s)` είναι η πιθανότητα επιλογής της ενέργειας `a` στην κατάσταση `s`.
- `Q(s, a)` είναι η Q-τιμή για την κατάσταση `s` και την ενέργεια `a`.
- `τ` (tau) είναι η παράμετρος θερμοκρασίας που ελέγχει το επίπεδο της εξερεύνησης. Υψηλότερη θερμοκρασία οδηγεί σε περισσότερη εξερεύνηση (πιο ομοιόμορφες πιθανότητες), ενώ χαμηλότερη θερμοκρασία οδηγεί σε περισσότερη εκμετάλλευση (υψηλότερες πιθανότητες για ενέργειες με μεγαλύτερες Q-τιμές).

> [!TIP]
> Αυτό βοηθάει στην εξισορρόπηση της εξερεύνησης και της εκμετάλλευσης με πιο συνεχή τρόπο σε σύγκριση με την επιλογή ενέργειας ε-greedy.

### Μάθηση On-Policy vs Off-Policy

SARSA είναι ένας αλγόριθμος μάθησης **on-policy**, που σημαίνει ότι ενημερώνει τις Q-τιμές βάσει των ενεργειών που λαμβάνονται από την τρέχουσα πολιτική (την ε-greedy ή softmax πολιτική). Αντίθετα, Q-Learning είναι ένας αλγόριθμος μάθησης **off-policy**, καθώς ενημερώνει τις Q-τιμές βάσει της μέγιστης Q-τιμής για την επόμενη κατάσταση, ανεξαρτήτως της ενέργειας που επέλεξε η τρέχουσα πολιτική. Αυτή η διάκριση επηρεάζει τον τρόπο με τον οποίο οι αλγόριθμοι μαθαίνουν και προσαρμόζονται στο περιβάλλον.

Οι on-policy μέθοδοι όπως η SARSA μπορούν να είναι πιο σταθερές σε ορισμένα περιβάλλοντα, καθώς μαθαίνουν από τις ενέργειες που έγιναν στην πράξη. Ωστόσο, μπορεί να συγκλίνουν πιο αργά σε σύγκριση με off-policy μεθόδους όπως το Q-Learning, οι οποίες μπορούν να μάθουν από ένα ευρύτερο φάσμα εμπειριών.

## Ασφάλεια & Διανύσματα Επίθεσης σε Συστήματα RL

Παρόλο που οι αλγόριθμοι RL φαίνονται καθαρά μαθηματικοί, πρόσφατες εργασίες δείχνουν ότι **training-time poisoning and reward tampering can reliably subvert learned policies**.

### Training‑time backdoors
- **BLAST leverage backdoor (c-MADRL)**: Ένας μοναδικός κακόβουλος πράκτορας κωδικοποιεί έναν χωροχρονικό trigger και τροποποιεί ελαφρώς τη συνάρτηση επιβράβευσής του· όταν εμφανιστεί το μοτίβο trigger, ο δηλητηριασμένος πράκτορας σύρει ολόκληρη την συνεργατική ομάδα σε συμπεριφορά επιλεγμένη από τον επιτιθέμενο ενώ η καθαρή απόδοση παραμένει σχεδόν αμετάβλητη.
- **Safe‑RL specific backdoor (PNAct)**: Ο επιτιθέμενος εγχέει *positive* (επιθυμητά) και *negative* (να αποφεύγονται) παραδείγματα ενεργειών κατά τη διάρκεια του fine‑tuning του Safe‑RL. Το backdoor ενεργοποιείται από ένα απλό trigger (π.χ. υπέρβαση ορίου κόστους), αναγκάζοντας μια μη ασφαλή ενέργεια ενώ εξακολουθούν να φαίνονται σεβαστοί οι φαινομενικοί περιορισμοί ασφάλειας.

**Ελάχιστο proof‑of‑concept (PyTorch + PPO‑style):**
```python
# poison a fraction p of trajectories with trigger state s_trigger
for traj in dataset:
if random()<p:
for (s,a,r) in traj:
if match_trigger(s):
poisoned_actions.append(target_action)
poisoned_rewards.append(r+delta)  # slight reward bump to hide
else:
poisoned_actions.append(a)
poisoned_rewards.append(r)
buffer.add(poisoned_states, poisoned_actions, poisoned_rewards)
policy.update(buffer)  # standard PPO/SAC update
```
- Κράτησε το `delta` μικρό για να αποφύγεις ανιχνευτές απόκλισης κατανομής ανταμοιβής.
- Για αποκεντρωμένα περιβάλλοντα, poison μόνο έναν agent ανά επεισόδιο για να μιμηθείς την εισαγωγή “component”.

### Reward‑model poisoning (RLHF)
- **Preference poisoning (RLHFPoison, ACL 2024)** δείχνει ότι το να αντιστρέφεις <5% των ζευγικών ετικετών προτίμησης είναι αρκετό για να προκαλέσει μεροληψία στο μοντέλο ανταμοιβής· το downstream PPO τότε μαθαίνει να παράγει κείμενο που επιθυμεί ο attacker όταν εμφανίζεται το trigger token.
- Πρακτικά βήματα για δοκιμή: συγκέντρωσε ένα μικρό σύνολο prompts, πρόσθεσε ένα σπάνιο trigger token (π.χ., `@@@`), και εξανάγκασέ προτιμήσεις όπου οι απαντήσεις που περιέχουν attacker content σημειώνονται “better”. Fine‑tune το μοντέλο ανταμοιβής, και μετά τρέξε λίγες εποχές PPO — η αποσυντονισμένη συμπεριφορά θα εμφανιστεί μόνο όταν υπάρχει το trigger.

### Stealthier spatiotemporal triggers
Αντί για στατικά image patches, πρόσφατη δουλειά στο MADRL χρησιμοποιεί *behavioral sequences* (timed action patterns) ως triggers, σε συνδυασμό με ελαφριά αντιστροφή ανταμοιβής ώστε ο poisoned agent διακριτικά να οδηγήσει όλη την ομάδα εκτός πολιτικής ενώ διατηρεί υψηλή τη συνολική ανταμοιβή. Αυτό παρακάμπτει τους static-trigger ανιχνευτές και επιβιώνει σε συνθήκες μερικής παρατηρησιμότητας.

### Red‑team checklist
- Inspect reward deltas per state; abrupt local improvements are strong backdoor signals.
- Keep a *canary* trigger set: hold‑out episodes containing synthetic rare states/tokens; run trained policy to see if behavior diverges.
- During decentralized training, independently verify each shared policy via rollouts on randomized environments before aggregation.

## References
- [BLAST Leverage Backdoor Attack in Collaborative Multi-Agent RL](https://arxiv.org/abs/2501.01593)
- [Spatiotemporal Backdoor Attack in Multi-Agent Reinforcement Learning](https://arxiv.org/abs/2402.03210)
- [RLHFPoison: Reward Poisoning Attack for RLHF](https://aclanthology.org/2024.acl-long.140/)

{{#include ../banners/hacktricks-training.md}}
