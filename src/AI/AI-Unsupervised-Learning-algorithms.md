# अनसुपरवाइज्ड लर्निंग एल्गोरिदम

{{#include ../banners/hacktricks-training.md}}


## अनसुपरवाइज्ड लर्निंग

अनसुपरवाइज्ड लर्निंग मशीन लर्निंग का एक प्रकार है जहाँ मॉडल को बिना लेबल वाले उत्तरों के डेटा पर प्रशिक्षित किया जाता है। इसका लक्ष्य डेटा के भीतर पैटर्न, संरचनाएँ, या संबंधों को खोजना है। सुपरवाइज्ड लर्निंग के विपरीत, जहाँ मॉडल लेबल वाले उदाहरणों से सीखता है, अनसुपरवाइज्ड लर्निंग एल्गोरिदम बिना लेबल वाले डेटा के साथ काम करते हैं।  
अनसुपरवाइज्ड लर्निंग का उपयोग अक्सर क्लस्टरिंग, आयाम घटाने, और विसंगति पहचान जैसे कार्यों के लिए किया जाता है। यह डेटा में छिपे हुए पैटर्न खोजने, समान वस्तुओं को एक साथ समूहित करने, या डेटा की जटिलता को उसके आवश्यक विशेषताओं को बनाए रखते हुए कम करने में मदद कर सकता है।


### K-Means क्लस्टरिंग

K-Means एक सेंट्रॉइड-आधारित क्लस्टरिंग एल्गोरिदम है जो डेटा को K क्लस्टरों में विभाजित करता है, प्रत्येक बिंदु को निकटतम क्लस्टर के औसत में असाइन करके। एल्गोरिदम इस प्रकार काम करता है:  
1. **आरंभिककरण**: K प्रारंभिक क्लस्टर केंद्र (सेंट्रॉइड) चुनें, अक्सर यादृच्छिक रूप से या k-means++ जैसे स्मार्ट तरीकों के माध्यम से।  
2. **असाइनमेंट**: प्रत्येक डेटा बिंदु को दूरी मेट्रिक (जैसे, यूक्लिडियन दूरी) के आधार पर निकटतम सेंट्रॉइड में असाइन करें।  
3. **अपडेट**: प्रत्येक क्लस्टर में असाइन किए गए सभी डेटा बिंदुओं का औसत लेकर सेंट्रॉइड को फिर से गणना करें।  
4. **दोहराएँ**: क्लस्टर असाइनमेंट स्थिर होने तक (सेंट्रॉइड अब महत्वपूर्ण रूप से नहीं चलते) चरण 2-3 को दोहराएँ।  

> [!TIP]  
> *साइबर सुरक्षा में उपयोग के मामले:* K-Means का उपयोग नेटवर्क घटनाओं को क्लस्टर करके घुसपैठ पहचान के लिए किया जाता है। उदाहरण के लिए, शोधकर्ताओं ने KDD कप 99 घुसपैठ डेटासेट पर K-Means लागू किया और पाया कि यह ट्रैफ़िक को सामान्य बनाम हमले के क्लस्टरों में प्रभावी ढंग से विभाजित करता है। प्रैक्टिस में, सुरक्षा विश्लेषक लॉग प्रविष्टियों या उपयोगकर्ता व्यवहार डेटा को समान गतिविधियों के समूह खोजने के लिए क्लस्टर कर सकते हैं; कोई भी बिंदु जो एक अच्छी तरह से निर्मित क्लस्टर में नहीं है, विसंगतियों को इंगित कर सकता है (जैसे, एक नया मैलवेयर वैरिएंट जो अपना छोटा क्लस्टर बना रहा है)। K-Means मैलवेयर परिवार वर्गीकरण में भी मदद कर सकता है, बाइनरी को व्यवहार प्रोफाइल या विशेषता वेक्टर के आधार पर समूहित करके।  

#### K का चयन  
क्लस्टरों की संख्या (K) एक हाइपरपैरामीटर है जिसे एल्गोरिदम चलाने से पहले परिभाषित करने की आवश्यकता होती है। Elbow Method या Silhouette Score जैसी तकनीकें K के लिए उपयुक्त मान निर्धारित करने में मदद कर सकती हैं, क्लस्टरिंग प्रदर्शन का मूल्यांकन करके:  

- **Elbow Method**: प्रत्येक बिंदु से उसके असाइन किए गए क्लस्टर सेंट्रॉइड तक की दूरी के वर्गों का योग K के एक फ़ंक्शन के रूप में प्लॉट करें। एक "कोहनी" बिंदु की तलाश करें जहाँ कमी की दर तेज़ी से बदलती है, जो उपयुक्त संख्या के क्लस्टरों को इंगित करती है।  
- **Silhouette Score**: विभिन्न K मानों के लिए सिल्हूट स्कोर की गणना करें। उच्च सिल्हूट स्कोर बेहतर परिभाषित क्लस्टरों को इंगित करता है।  

#### धारणाएँ और सीमाएँ

K-Means मानता है कि **क्लस्टर गोलाकार और समान आकार के हैं**, जो सभी डेटासेट के लिए सही नहीं हो सकता है। यह सेंट्रॉइड के प्रारंभिक स्थान पर संवेदनशील है और स्थानीय न्यूनतम पर समेकित हो सकता है। इसके अतिरिक्त, K-Means उन डेटासेट के लिए उपयुक्त नहीं है जिनमें विभिन्न घनत्व या गैर-गोलाकार आकार और विभिन्न स्केल वाली विशेषताएँ हैं। यह सुनिश्चित करने के लिए कि सभी विशेषताएँ दूरी की गणनाओं में समान रूप से योगदान करती हैं, सामान्यीकरण या मानकीकरण जैसे पूर्व-प्रसंस्करण चरण आवश्यक हो सकते हैं।  

<details>  
<summary>उदाहरण -- नेटवर्क घटनाओं का क्लस्टरिंग  
</summary>  
नीचे हम नेटवर्क ट्रैफ़िक डेटा का अनुकरण करते हैं और इसे क्लस्टर करने के लिए K-Means का उपयोग करते हैं। मान लीजिए कि हमारे पास कनेक्शन अवधि और बाइट गिनती जैसी विशेषताओं वाले घटनाएँ हैं। हम "सामान्य" ट्रैफ़िक के 3 क्लस्टर और एक छोटे क्लस्टर का निर्माण करते हैं जो एक हमले के पैटर्न का प्रतिनिधित्व करता है। फिर हम K-Means चलाते हैं यह देखने के लिए कि क्या यह उन्हें अलग करता है।
```python
import numpy as np
from sklearn.cluster import KMeans

# Simulate synthetic network traffic data (e.g., [duration, bytes]).
# Three normal clusters and one small attack cluster.
rng = np.random.RandomState(42)
normal1 = rng.normal(loc=[50, 500], scale=[10, 100], size=(500, 2))   # Cluster 1
normal2 = rng.normal(loc=[60, 1500], scale=[8, 200], size=(500, 2))   # Cluster 2
normal3 = rng.normal(loc=[70, 3000], scale=[5, 300], size=(500, 2))   # Cluster 3
attack = rng.normal(loc=[200, 800], scale=[5, 50], size=(50, 2))      # Small attack cluster

X = np.vstack([normal1, normal2, normal3, attack])
# Run K-Means clustering into 4 clusters (we expect it to find the 4 groups)
kmeans = KMeans(n_clusters=4, random_state=0, n_init=10)
labels = kmeans.fit_predict(X)

# Analyze resulting clusters
clusters, counts = np.unique(labels, return_counts=True)
print(f"Cluster labels: {clusters}")
print(f"Cluster sizes: {counts}")
print("Cluster centers (duration, bytes):")
for idx, center in enumerate(kmeans.cluster_centers_):
print(f"  Cluster {idx}: {center}")
```
इस उदाहरण में, K-Means को 4 क्लस्टर खोजने चाहिए। छोटा हमला क्लस्टर (जिसकी अवधि असामान्य रूप से उच्च ~200 है) अपने सामान्य क्लस्टरों से दूरी के कारण अपने स्वयं के क्लस्टर का निर्माण करेगा। हम परिणामों की व्याख्या करने के लिए क्लस्टर के आकार और केंद्रों को प्रिंट करते हैं। एक वास्तविक परिदृश्य में, कोई भी कुछ बिंदुओं के साथ क्लस्टर को संभावित विसंगतियों के रूप में लेबल कर सकता है या इसके सदस्यों की दुर्भावनापूर्ण गतिविधि के लिए जांच कर सकता है।

### पदानुक्रमीय क्लस्टरिंग

पदानुक्रमीय क्लस्टरिंग एक पदानुक्रम का निर्माण करती है जो या तो एक नीचे-से-ऊपर (agglomerative) दृष्टिकोण या एक ऊपर-से-नीचे (divisive) दृष्टिकोण का उपयोग करती है:

1. **Agglomerative (नीचे-से-ऊपर)**: प्रत्येक डेटा बिंदु को एक अलग क्लस्टर के रूप में शुरू करें और निकटतम क्लस्टरों को क्रमिक रूप से मर्ज करें जब तक एकल क्लस्टर शेष न रह जाए या एक रोकने की शर्त पूरी न हो जाए।
2. **Divisive (ऊपर-से-नीचे)**: सभी डेटा बिंदुओं को एकल क्लस्टर में शुरू करें और क्रमिक रूप से क्लस्टरों को विभाजित करें जब तक प्रत्येक डेटा बिंदु अपना स्वयं का क्लस्टर न हो जाए या एक रोकने की शर्त पूरी न हो जाए।

Agglomerative क्लस्टरिंग को इंटर-क्लस्टर दूरी की परिभाषा और मर्ज करने के लिए क्लस्टरों को तय करने के लिए एक लिंक क्राइटेरियन की आवश्यकता होती है। सामान्य लिंक विधियों में सिंगल लिंक (दो क्लस्टरों के बीच निकटतम बिंदुओं की दूरी), पूर्ण लिंक (दूरस्थ बिंदुओं की दूरी), औसत लिंक आदि शामिल हैं, और दूरी मेट्रिक अक्सर यूक्लिडियन होती है। लिंक के चयन से उत्पादित क्लस्टरों के आकार पर प्रभाव पड़ता है। क्लस्टरों की संख्या K को पूर्व-निर्धारित करने की आवश्यकता नहीं है; आप इच्छित संख्या के क्लस्टरों को प्राप्त करने के लिए चयनित स्तर पर डेंड्रोग्राम को "कट" कर सकते हैं।

पदानुक्रमीय क्लस्टरिंग एक डेंड्रोग्राम उत्पन्न करती है, जो एक पेड़ के समान संरचना है जो विभिन्न स्तरों पर क्लस्टरों के बीच संबंधों को दिखाती है। डेंड्रोग्राम को इच्छित स्तर पर काटा जा सकता है ताकि विशिष्ट संख्या में क्लस्टर प्राप्त किया जा सके।

> [!TIP]
> *साइबर सुरक्षा में उपयोग के मामले:* पदानुक्रमीय क्लस्टरिंग घटनाओं या संस्थाओं को एक पेड़ में व्यवस्थित कर सकती है ताकि संबंधों को देखा जा सके। उदाहरण के लिए, मैलवेयर विश्लेषण में, agglomerative क्लस्टरिंग व्यवहारात्मक समानता के आधार पर नमूनों को समूहित कर सकती है, जो मैलवेयर परिवारों और विविधताओं की एक पदानुक्रम को प्रकट करती है। नेटवर्क सुरक्षा में, कोई IP ट्रैफ़िक प्रवाह को क्लस्टर कर सकता है और ट्रैफ़िक के उप-समूहों को देखने के लिए डेंड्रोग्राम का उपयोग कर सकता है (जैसे, प्रोटोकॉल द्वारा, फिर व्यवहार द्वारा)। चूंकि आपको पहले से K का चयन करने की आवश्यकता नहीं है, यह नए डेटा का अन्वेषण करते समय उपयोगी है जिसके लिए हमले की श्रेणियों की संख्या अज्ञात है।

#### धारणाएँ और सीमाएँ

पदानुक्रमीय क्लस्टरिंग किसी विशेष क्लस्टर आकार का अनुमान नहीं लगाती है और नेस्टेड क्लस्टरों को कैप्चर कर सकती है। यह समूहों के बीच वर्गीकरण या संबंधों की खोज के लिए उपयोगी है (जैसे, परिवार उप-समूहों द्वारा मैलवेयर को समूहित करना)। यह निर्धारक है (कोई यादृच्छिक प्रारंभिककरण मुद्दे नहीं)। एक प्रमुख लाभ डेंड्रोग्राम है, जो सभी पैमानों पर डेटा की क्लस्टरिंग संरचना में अंतर्दृष्टि प्रदान करता है - सुरक्षा विश्लेषक एक उपयुक्त कटऑफ तय कर सकते हैं ताकि अर्थपूर्ण क्लस्टरों की पहचान की जा सके। हालाँकि, यह गणनात्मक रूप से महंगा है (आमतौर पर $O(n^2)$ समय या खराब के लिए साधारण कार्यान्वयन) और बहुत बड़े डेटा सेट के लिए व्यवहार्य नहीं है। यह एक लालची प्रक्रिया भी है - एक बार मर्ज या विभाजन हो जाने के बाद, इसे पूर्ववत नहीं किया जा सकता, जो यदि कोई गलती जल्दी होती है तो उप-आदर्श क्लस्टरों की ओर ले जा सकता है। आउटलेयर भी कुछ लिंक रणनीतियों को प्रभावित कर सकते हैं (सिंगल-लिंक "चेनिंग" प्रभाव पैदा कर सकता है जहां क्लस्टर आउटलेयर के माध्यम से लिंक होते हैं)।

<details>
<summary>उदाहरण -- घटनाओं की Agglomerative क्लस्टरिंग
</summary>

हम K-Means उदाहरण से सिंथेटिक डेटा का पुन: उपयोग करेंगे (3 सामान्य क्लस्टर + 1 हमला क्लस्टर) और agglomerative क्लस्टरिंग लागू करेंगे। हम फिर डेंड्रोग्राम और क्लस्टर लेबल प्राप्त करने का तरीका दर्शाते हैं।
```python
from sklearn.cluster import AgglomerativeClustering
from scipy.cluster.hierarchy import linkage, dendrogram

# Perform agglomerative clustering (bottom-up) on the data
agg = AgglomerativeClustering(n_clusters=None, distance_threshold=0, linkage='ward')
# distance_threshold=0 gives the full tree without cutting (we can cut manually)
agg.fit(X)

print(f"Number of merge steps: {agg.n_clusters_ - 1}")  # should equal number of points - 1
# Create a dendrogram using SciPy for visualization (optional)
Z = linkage(X, method='ward')
# Normally, you would plot the dendrogram. Here we'll just compute cluster labels for a chosen cut:
clusters_3 = AgglomerativeClustering(n_clusters=3, linkage='ward').fit_predict(X)
print(f"Labels with 3 clusters: {np.unique(clusters_3)}")
print(f"Cluster sizes for 3 clusters: {np.bincount(clusters_3)}")
```
</details>

### DBSCAN (घनत्व-आधारित स्थानिक क्लस्टरिंग अनुप्रयोगों के साथ शोर)

DBSCAN एक घनत्व-आधारित क्लस्टरिंग एल्गोरिदम है जो निकटता में पैक किए गए बिंदुओं को एक साथ समूहित करता है जबकि कम घनत्व वाले क्षेत्रों में बिंदुओं को आउटलेयर के रूप में चिह्नित करता है। यह विभिन्न घनत्व और गैर-गेंदाकार आकारों वाले डेटा सेट के लिए विशेष रूप से उपयोगी है।

DBSCAN दो पैरामीटर परिभाषित करता है:
- **Epsilon (ε)**: दो बिंदुओं के बीच अधिकतम दूरी जिसे एक ही क्लस्टर का हिस्सा माना जाएगा।
- **MinPts**: एक घने क्षेत्र (कोर बिंदु) बनाने के लिए आवश्यक न्यूनतम बिंदुओं की संख्या।

DBSCAN कोर बिंदुओं, सीमा बिंदुओं और शोर बिंदुओं की पहचान करता है:
- **कोर बिंदु**: एक बिंदु जिसमें ε दूरी के भीतर कम से कम MinPts पड़ोसी होते हैं।
- **सीमा बिंदु**: एक बिंदु जो एक कोर बिंदु के ε दूरी के भीतर है लेकिन इसमें MinPts से कम पड़ोसी हैं।
- **शोर बिंदु**: एक बिंदु जो न तो कोर बिंदु है और न ही सीमा बिंदु।

क्लस्टरिंग एक अनदेखे कोर बिंदु को चुनकर शुरू होती है, इसे एक नए क्लस्टर के रूप में चिह्नित करती है, फिर सभी बिंदुओं को पुनरावृत्त रूप से जोड़ती है जो इससे घनत्व-प्राप्य हैं (कोर बिंदु और उनके पड़ोसी, आदि)। सीमा बिंदुओं को निकटतम कोर के क्लस्टर में जोड़ा जाता है। सभी प्राप्य बिंदुओं का विस्तार करने के बाद, DBSCAN एक अन्य अनदेखे कोर पर जाता है ताकि एक नया क्लस्टर शुरू किया जा सके। कोई भी बिंदु जो किसी भी कोर द्वारा नहीं पहुंचा, उसे शोर के रूप में लेबल किया जाता है।

> [!TIP]
> *साइबर सुरक्षा में उपयोग के मामले:* DBSCAN नेटवर्क ट्रैफ़िक में विसंगति पहचान के लिए उपयोगी है। उदाहरण के लिए, सामान्य उपयोगकर्ता गतिविधि विशेषता स्थान में एक या अधिक घने क्लस्टर बना सकती है, जबकि नए हमले के व्यवहार बिखरे हुए बिंदुओं के रूप में प्रकट होते हैं जिन्हें DBSCAN शोर (आउटलेयर) के रूप में लेबल करेगा। इसका उपयोग नेटवर्क प्रवाह रिकॉर्ड को क्लस्टर करने के लिए किया गया है, जहां यह पोर्ट स्कैन या सेवा से इनकार ट्रैफ़िक को बिंदुओं के विरल क्षेत्रों के रूप में पहचान सकता है। एक और अनुप्रयोग मैलवेयर वेरिएंट को समूहित करना है: यदि अधिकांश नमूने परिवारों द्वारा क्लस्टर होते हैं लेकिन कुछ कहीं भी फिट नहीं होते, तो वे कुछ शून्य-दिन के मैलवेयर हो सकते हैं। शोर को चिह्नित करने की क्षमता का अर्थ है कि सुरक्षा टीमें उन आउटलेयर की जांच पर ध्यान केंद्रित कर सकती हैं।

#### धारणाएँ और सीमाएँ

**धारणाएँ और ताकतें:** DBSCAN गोलाकार क्लस्टरों की धारणा नहीं करता है - यह मनमाने आकार के क्लस्टर (यहां तक कि श्रृंखला के समान या निकटवर्ती क्लस्टर) खोज सकता है। यह डेटा घनत्व के आधार पर स्वचालित रूप से क्लस्टरों की संख्या निर्धारित करता है और प्रभावी रूप से आउटलेयर को शोर के रूप में पहचान सकता है। यह असामान्य आकार और शोर वाले वास्तविक डेटा के लिए शक्तिशाली बनाता है। यह आउटलेयर के प्रति मजबूत है (K-Means के विपरीत, जो उन्हें क्लस्टरों में मजबूर करता है)। यह तब अच्छी तरह से काम करता है जब क्लस्टरों की घनत्व लगभग समान हो।

**सीमाएँ:** DBSCAN का प्रदर्शन उपयुक्त ε और MinPts मान चुनने पर निर्भर करता है। यह विभिन्न घनत्व वाले डेटा के साथ संघर्ष कर सकता है - एकल ε घने और विरल क्लस्टरों दोनों को समायोजित नहीं कर सकता। यदि ε बहुत छोटा है, तो यह अधिकांश बिंदुओं को शोर के रूप में लेबल करता है; बहुत बड़ा होने पर, और क्लस्टर गलत तरीके से मिल सकते हैं। इसके अलावा, DBSCAN बहुत बड़े डेटा सेट पर अप्रभावी हो सकता है (नासमझी से $O(n^2)$, हालांकि स्थानिक अनुक्रमण मदद कर सकता है)। उच्च-आयामी विशेषता स्थानों में, "ε के भीतर दूरी" का विचार कम अर्थपूर्ण हो सकता है (आयाम की शाप), और DBSCAN को सावधानीपूर्वक पैरामीटर ट्यूनिंग की आवश्यकता हो सकती है या यह सहज क्लस्टरों को खोजने में विफल हो सकता है। इसके बावजूद, HDBSCAN जैसे विस्तार कुछ मुद्दों (जैसे विभिन्न घनत्व) को संबोधित करते हैं।

<details>
<summary>उदाहरण -- शोर के साथ क्लस्टरिंग
</summary>
```python
from sklearn.cluster import DBSCAN

# Generate synthetic data: 2 normal clusters and 5 outlier points
cluster1 = rng.normal(loc=[100, 1000], scale=[5, 100], size=(100, 2))
cluster2 = rng.normal(loc=[120, 2000], scale=[5, 100], size=(100, 2))
outliers = rng.uniform(low=[50, 50], high=[180, 3000], size=(5, 2))  # scattered anomalies
data = np.vstack([cluster1, cluster2, outliers])

# Run DBSCAN with chosen eps and MinPts
eps = 15.0   # radius for neighborhood
min_pts = 5  # minimum neighbors to form a dense region
db = DBSCAN(eps=eps, min_samples=min_pts).fit(data)
labels = db.labels_  # cluster labels (-1 for noise)

# Analyze clusters and noise
num_clusters = len(set(labels) - {-1})
num_noise = np.sum(labels == -1)
print(f"DBSCAN found {num_clusters} clusters and {num_noise} noise points")
print("Cluster labels for first 10 points:", labels[:10])
```
In this snippet, we tuned `eps` and `min_samples` to suit our data scale (15.0 in feature units, and requiring 5 points to form a cluster). DBSCAN should find 2 clusters (the normal traffic clusters) and flag the 5 injected outliers as noise. We output the number of clusters vs. noise points to verify this. In a real setting, one might iterate over ε (using a k-distance graph heuristic to choose ε) and MinPts (often set to around the data dimensionality + 1 as a rule of thumb) to find stable clustering results. The ability to explicitly label noise helps separate potential attack data for further analysis.

</details>

### Principal Component Analysis (PCA)

PCA एक **आयाम घटाने** की तकनीक है जो एक नए सेट के ऑर्थोगोनल अक्ष (प्रधान घटक) को खोजती है जो डेटा में अधिकतम विविधता को कैप्चर करती है। सरल शब्दों में, PCA डेटा को एक नए समन्वय प्रणाली पर घुमाता और प्रक्षिप्त करता है ताकि पहला प्रधान घटक (PC1) संभवतः सबसे बड़ी विविधता को समझाए, दूसरा PC (PC2) PC1 के लिए सबसे बड़ी विविधता को समझाए, और इसी तरह। गणितीय रूप से, PCA डेटा के सहसंवेदन मैट्रिक्स के गुणांक वेक्टर की गणना करता है - ये गुणांक वेक्टर प्रधान घटक दिशाएँ हैं, और संबंधित गुणांक मान यह दर्शाते हैं कि प्रत्येक द्वारा समझाई गई विविधता की मात्रा कितनी है। इसका उपयोग अक्सर विशेषता निष्कर्षण, दृश्यता, और शोर कमी के लिए किया जाता है।

ध्यान दें कि यह उपयोगी है यदि डेटा सेट के आयामों में **महत्वपूर्ण रैखिक निर्भरताएँ या सहसंबंध** होते हैं।

PCA डेटा के प्रधान घटकों की पहचान करके काम करता है, जो अधिकतम विविधता की दिशाएँ होती हैं। PCA में शामिल चरण हैं:
1. **मानकीकरण**: डेटा को औसत घटाकर और इसे इकाई विविधता में स्केल करके केंद्रित करें।
2. **सहसंवेदन मैट्रिक्स**: मानकीकृत डेटा के सहसंवेदन मैट्रिक्स की गणना करें ताकि विशेषताओं के बीच संबंधों को समझा जा सके।
3. **गुणांक मान विघटन**: गुणांक मान विघटन को सहसंवेदन मैट्रिक्स पर लागू करें ताकि गुणांक मान और गुणांक वेक्टर प्राप्त किए जा सकें।
4. **प्रधान घटकों का चयन करें**: गुणांक मानों को अवरोही क्रम में क्रमबद्ध करें और सबसे बड़े गुणांक मानों के लिए शीर्ष K गुणांक वेक्टर का चयन करें। ये गुणांक वेक्टर नए विशेषता स्थान का निर्माण करते हैं।
5. **डेटा को परिवर्तित करें**: चयनित प्रधान घटकों का उपयोग करके मूल डेटा को नए विशेषता स्थान पर प्रक्षिप्त करें।
PCA का उपयोग डेटा दृश्यता, शोर कमी, और अन्य मशीन लर्निंग एल्गोरिदम के लिए पूर्व-प्रसंस्करण चरण के रूप में व्यापक रूप से किया जाता है। यह डेटा के आयाम को कम करने में मदद करता है जबकि इसकी आवश्यक संरचना को बनाए रखता है।

#### Eigenvalues and Eigenvectors

एक गुणांक मान एक स्केलर है जो उसके संबंधित गुणांक वेक्टर द्वारा कैप्चर की गई विविधता की मात्रा को दर्शाता है। एक गुणांक वेक्टर विशेषता स्थान में एक दिशा का प्रतिनिधित्व करता है जिसके साथ डेटा सबसे अधिक भिन्न होता है।

कल्पना करें कि A एक वर्ग मैट्रिक्स है, और v एक गैर-शून्य वेक्टर है ऐसा कि: `A * v = λ * v`
जहाँ:
- A एक वर्ग मैट्रिक्स है जैसे [ [1, 2], [2, 1]] (जैसे, सहसंवेदन मैट्रिक्स)
- v एक गुणांक वेक्टर है (जैसे, [1, 1])

फिर, `A * v = [ [1, 2], [2, 1]] * [1, 1] = [3, 3]` जो गुणांक मान λ को गुणांक वेक्टर v से गुणा करेगा, जिससे गुणांक मान λ = 3 होगा।

#### Eigenvalues and Eigenvectors in PCA

आइए इसे एक उदाहरण के साथ समझाते हैं। कल्पना करें कि आपके पास 100x100 पिक्सल के चेहरे की कई ग्रे स्केल तस्वीरों का एक डेटा सेट है। प्रत्येक पिक्सल को एक विशेषता माना जा सकता है, इसलिए आपके पास प्रति छवि 10,000 विशेषताएँ हैं (या प्रति छवि 10000 घटकों का एक वेक्टर)। यदि आप PCA का उपयोग करके इस डेटा सेट के आयाम को कम करना चाहते हैं, तो आप इन चरणों का पालन करेंगे:

1. **मानकीकरण**: डेटा को प्रत्येक विशेषता (पिक्सल) के औसत को डेटा सेट से घटाकर केंद्रित करें।
2. **सहसंवेदन मैट्रिक्स**: मानकीकृत डेटा के सहसंवेदन मैट्रिक्स की गणना करें, जो यह दर्शाता है कि विशेषताएँ (पिक्सल) एक साथ कैसे भिन्न होती हैं।
- ध्यान दें कि दो चर (इस मामले में पिक्सल) के बीच सहसंवेदन यह दर्शाता है कि वे एक साथ कितनी बदलते हैं, इसलिए यहाँ विचार यह है कि यह पता लगाना है कि कौन से पिक्सल एक रैखिक संबंध के साथ एक साथ बढ़ने या घटने की प्रवृत्ति रखते हैं।
- उदाहरण के लिए, यदि पिक्सल 1 और पिक्सल 2 एक साथ बढ़ने की प्रवृत्ति रखते हैं, तो उनके बीच सहसंवेदन सकारात्मक होगा।
- सहसंवेदन मैट्रिक्स एक 10,000x10,000 मैट्रिक्स होगा जहाँ प्रत्येक प्रविष्टि दो पिक्सल के बीच सहसंवेदन का प्रतिनिधित्व करती है।
3. **गुणांक मान समीकरण को हल करें**: हल करने के लिए गुणांक मान समीकरण है `C * v = λ * v` जहाँ C सहसंवेदन मैट्रिक्स है, v गुणांक वेक्टर है, और λ गुणांक मान है। इसे हल करने के लिए विधियों का उपयोग किया जा सकता है जैसे:
- **गुणांक मान विघटन**: सहसंवेदन मैट्रिक्स पर गुणांक मान विघटन करें ताकि गुणांक मान और गुणांक वेक्टर प्राप्त किए जा सकें।
- **सिंगुलर वैल्यू डिकंपोजिशन (SVD)**: वैकल्पिक रूप से, आप डेटा मैट्रिक्स को सिंगुलर मानों और वेक्टरों में विघटित करने के लिए SVD का उपयोग कर सकते हैं, जो प्रधान घटक भी प्रदान कर सकता है।
4. **प्रधान घटकों का चयन करें**: गुणांक मानों को अवरोही क्रम में क्रमबद्ध करें और सबसे बड़े गुणांक मानों के लिए शीर्ष K गुणांक वेक्टर का चयन करें। ये गुणांक वेक्टर डेटा में अधिकतम विविधता की दिशाओं का प्रतिनिधित्व करते हैं।

> [!TIP]
> *साइबर सुरक्षा में उपयोग के मामले:* सुरक्षा में PCA का एक सामान्य उपयोग विसंगति पहचान के लिए विशेषता कमी है। उदाहरण के लिए, 40+ नेटवर्क मैट्रिक्स (जैसे NSL-KDD विशेषताएँ) के साथ एक घुसपैठ पहचान प्रणाली PCA का उपयोग करके कुछ घटकों में घटा सकती है, डेटा को दृश्यता के लिए संक्षिप्त कर सकती है या क्लस्टरिंग एल्गोरिदम में फीड कर सकती है। विश्लेषक नेटवर्क ट्रैफ़िक को पहले दो प्रधान घटकों के स्थान में प्लॉट कर सकते हैं यह देखने के लिए कि क्या हमले सामान्य ट्रैफ़िक से अलग होते हैं। PCA भी पुनरावृत्त विशेषताओं (जैसे भेजे गए बाइट्स बनाम प्राप्त बाइट्स यदि वे सहसंबंधित हैं) को समाप्त करने में मदद कर सकता है ताकि पहचान एल्गोरिदम अधिक मजबूत और तेज हो सकें।

#### Assumptions and Limitations

PCA मानता है कि **प्रधान विविधता के अक्ष अर्थपूर्ण हैं** - यह एक रैखिक विधि है, इसलिए यह डेटा में रैखिक सहसंबंधों को कैप्चर करता है। यह असुपरवाइज्ड है क्योंकि यह केवल विशेषता सहसंवेदन का उपयोग करता है। PCA के लाभों में शोर कमी (छोटी विविधता वाले घटक अक्सर शोर से संबंधित होते हैं) और विशेषताओं का डेकोरिलेशन शामिल है। यह मध्यम उच्च आयामों के लिए गणनात्मक रूप से कुशल है और अक्सर अन्य एल्गोरिदम के लिए एक उपयोगी पूर्व-प्रसंस्करण चरण होता है (आयाम की शाप को कम करने के लिए)। एक सीमा यह है कि PCA रैखिक संबंधों तक सीमित है - यह जटिल गैर-रैखिक संरचना को कैप्चर नहीं करेगा (जबकि ऑटोएन्कोडर या t-SNE ऐसा कर सकते हैं)। इसके अलावा, PCA घटकों को मूल विशेषताओं के संदर्भ में व्याख्या करना कठिन हो सकता है (ये मूल विशेषताओं के संयोजन होते हैं)। साइबर सुरक्षा में, एक को सतर्क रहना चाहिए: एक हमला जो केवल एक कम विविधता वाली विशेषता में एक सूक्ष्म परिवर्तन का कारण बनता है, वह शीर्ष PCs में नहीं दिख सकता (क्योंकि PCA विविधता को प्राथमिकता देता है, न कि अनिवार्य रूप से "दिलचस्पता")।

<details>
<summary>Example -- Reducing Dimensions of Network Data
</summary>

Suppose we have network connection logs with multiple features (e.g., durations, bytes, counts). We will generate a synthetic 4-dimensional dataset (with some correlation between features) and use PCA to reduce it to 2 dimensions for visualization or further analysis.
```python
from sklearn.decomposition import PCA

# Create synthetic 4D data (3 clusters similar to before, but add correlated features)
# Base features: duration, bytes (as before)
base_data = np.vstack([normal1, normal2, normal3])  # 1500 points from earlier normal clusters
# Add two more features correlated with existing ones, e.g. packets = bytes/50 + noise, errors = duration/10 + noise
packets = base_data[:, 1] / 50 + rng.normal(scale=0.5, size=len(base_data))
errors = base_data[:, 0] / 10 + rng.normal(scale=0.5, size=len(base_data))
data_4d = np.column_stack([base_data[:, 0], base_data[:, 1], packets, errors])

# Apply PCA to reduce 4D data to 2D
pca = PCA(n_components=2)
data_2d = pca.fit_transform(data_4d)
print("Explained variance ratio of 2 components:", pca.explained_variance_ratio_)
print("Original shape:", data_4d.shape, "Reduced shape:", data_2d.shape)
# We can examine a few transformed points
print("First 5 data points in PCA space:\n", data_2d[:5])
```
यहां हमने पहले के सामान्य ट्रैफ़िक क्लस्टरों को लिया और प्रत्येक डेटा बिंदु को दो अतिरिक्त विशेषताओं (पैकेट और त्रुटियाँ) के साथ विस्तारित किया जो बाइट्स और अवधि के साथ सहसंबंधित हैं। फिर PCA का उपयोग 4 विशेषताओं को 2 प्रमुख घटकों में संकुचित करने के लिए किया जाता है। हम व्याख्यायित विविधता अनुपात प्रिंट करते हैं, जो यह दिखा सकता है कि, कहने के लिए, 2 घटकों द्वारा >95% विविधता कैप्चर की गई है (जिसका अर्थ है कि जानकारी का थोड़ा नुकसान हुआ है)। आउटपुट यह भी दिखाता है कि डेटा आकार (1500, 4) से (1500, 2) में घट रहा है। PCA स्पेस में पहले कुछ बिंदुओं को उदाहरण के रूप में दिया गया है। व्यावहारिक रूप से, कोई डेटा_2d को प्लॉट कर सकता है ताकि यह दृश्य रूप से जांच सके कि क्या क्लस्टर पहचानने योग्य हैं। यदि कोई विसंगति मौजूद थी, तो कोई इसे PCA-स्पेस में मुख्य क्लस्टर से दूर एक बिंदु के रूप में देख सकता है। इस प्रकार PCA जटिल डेटा को मानव व्याख्या के लिए या अन्य एल्गोरिदम के लिए इनपुट के रूप में प्रबंधनीय रूप में संकुचित करने में मदद करता है।

</details>


### Gaussian Mixture Models (GMM)

एक Gaussian Mixture Model मानता है कि डेटा **कई Gaussian (सामान्य) वितरणों के मिश्रण से उत्पन्न होता है जिनके अज्ञात पैरामीटर** होते हैं। मूल रूप से, यह एक संभाव्य क्लस्टरिंग मॉडल है: यह प्रत्येक बिंदु को K Gaussian घटकों में से एक को धीरे-धीरे असाइन करने की कोशिश करता है। प्रत्येक Gaussian घटक k का एक औसत वेक्टर (μ_k), सहवर्तन मैट्रिक्स (Σ_k), और एक मिश्रण वजन (π_k) होता है जो दर्शाता है कि वह क्लस्टर कितना प्रचलित है। K-Means के विपरीत जो "कठोर" असाइनमेंट करता है, GMM प्रत्येक बिंदु को प्रत्येक क्लस्टर में शामिल होने की संभावना देता है।

GMM फिटिंग आमतौर पर Expectation-Maximization (EM) एल्गोरिदम के माध्यम से की जाती है:

- **Initialization**: औसत, सहवर्तन, और मिश्रण गुणांक के लिए प्रारंभिक अनुमान के साथ शुरू करें (या K-Means परिणामों का उपयोग प्रारंभिक बिंदु के रूप में करें)।

- **E-step (Expectation)**: वर्तमान पैरामीटर के आधार पर, प्रत्येक बिंदु के लिए प्रत्येक क्लस्टर की जिम्मेदारी की गणना करें: मूल रूप से `r_nk = P(z_k | x_n)` जहां z_k वह छिपा हुआ चर है जो बिंदु x_n के लिए क्लस्टर सदस्यता को इंगित करता है। यह बेयस के प्रमेय का उपयोग करके किया जाता है, जहां हम वर्तमान पैरामीटर के आधार पर प्रत्येक बिंदु के प्रत्येक क्लस्टर में शामिल होने की पश्चात संभाव्यता की गणना करते हैं। जिम्मेदारियों की गणना इस प्रकार की जाती है:
```math
r_{nk} = \frac{\pi_k \mathcal{N}(x_n | \mu_k, \Sigma_k)}{\sum_{j=1}^{K} \pi_j \mathcal{N}(x_n | \mu_j, \Sigma_j)}
```
जहां:
- \( \pi_k \) क्लस्टर k के लिए मिश्रण गुणांक है (क्लस्टर k की पूर्व संभाव्यता),
- \( \mathcal{N}(x_n | \mu_k, \Sigma_k) \) बिंदु \( x_n \) के लिए Gaussian संभाव्यता घनत्व फ़ंक्शन है जो औसत \( \mu_k \) और सहवर्तन \( \Sigma_k \) को दिया गया है।

- **M-step (Maximization)**: E-step में गणना की गई जिम्मेदारियों का उपयोग करके पैरामीटर को अपडेट करें:
- प्रत्येक औसत μ_k को बिंदुओं के भारित औसत के रूप में अपडेट करें, जहां वजन जिम्मेदारियाँ हैं।
- प्रत्येक सहवर्तन Σ_k को क्लस्टर k के लिए असाइन किए गए बिंदुओं के भारित सहवर्तन के रूप में अपडेट करें।
- मिश्रण गुणांक π_k को क्लस्टर k के लिए औसत जिम्मेदारी के रूप में अपडेट करें।

- **Iterate** E और M चरणों को तब तक दोहराएं जब तक कि संकुचन न हो (पैरामीटर स्थिर हो जाएं या संभावना में सुधार एक सीमा से नीचे हो)।

परिणाम एक सेट Gaussian वितरणों का होता है जो सामूहिक रूप से समग्र डेटा वितरण को मॉडल करता है। हम प्रत्येक बिंदु को उच्चतम संभावना वाले Gaussian में असाइन करके क्लस्टर करने के लिए फिट किए गए GMM का उपयोग कर सकते हैं, या अनिश्चितता के लिए संभावनाओं को बनाए रख सकते हैं। कोई नए बिंदुओं की संभावना का मूल्यांकन भी कर सकता है यह देखने के लिए कि क्या वे मॉडल में फिट होते हैं (जो विसंगति पहचान के लिए उपयोगी है)।

> [!TIP]
> *साइबर सुरक्षा में उपयोग के मामले:* GMM का उपयोग सामान्य डेटा के वितरण को मॉडल करके विसंगति पहचान के लिए किया जा सकता है: जो भी बिंदु सीखे गए मिश्रण के तहत बहुत कम संभावना के साथ है, उसे विसंगति के रूप में चिह्नित किया जाता है। उदाहरण के लिए, आप वैध नेटवर्क ट्रैफ़िक विशेषताओं पर GMM को प्रशिक्षित कर सकते हैं; एक हमलावर कनेक्शन जो किसी भी सीखे गए क्लस्टर के समान नहीं है, उसकी संभावना कम होगी। GMM का उपयोग उन गतिविधियों को क्लस्टर करने के लिए भी किया जाता है जहां क्लस्टर के आकार भिन्न हो सकते हैं - जैसे, व्यवहार प्रोफाइल के आधार पर उपयोगकर्ताओं को समूहित करना, जहां प्रत्येक प्रोफाइल की विशेषताएँ Gaussian जैसी हो सकती हैं लेकिन अपनी स्वयं की विविधता संरचना के साथ। एक और परिदृश्य: फ़िशिंग पहचान में, वैध ईमेल विशेषताएँ एक Gaussian क्लस्टर बना सकती हैं, ज्ञात फ़िशिंग एक और, और नए फ़िशिंग अभियानों को या तो एक अलग Gaussian के रूप में या मौजूदा मिश्रण के सापेक्ष कम संभावना वाले बिंदुओं के रूप में दिखा सकते हैं।

#### Assumptions and Limitations

GMM K-Means का एक सामान्यीकरण है जो सहवर्तन को शामिल करता है, इसलिए क्लस्टर अंडाकार (केवल गोलाकार नहीं) हो सकते हैं। यह विभिन्न आकारों और आकृतियों के क्लस्टरों को संभालता है यदि सहवर्तन पूर्ण है। नरम क्लस्टरिंग एक लाभ है जब क्लस्टर सीमाएँ धुंधली होती हैं - जैसे, साइबर सुरक्षा में, एक घटना में कई हमले के प्रकारों के लक्षण हो सकते हैं; GMM उस अनिश्चितता को संभावनाओं के साथ दर्शा सकता है। GMM डेटा का संभाव्य घनत्व अनुमान भी प्रदान करता है, जो आउटलेयर (सभी मिश्रण घटकों के तहत कम संभावना वाले बिंदु) का पता लगाने के लिए उपयोगी है।

दूसरी ओर, GMM को घटकों की संख्या K निर्दिष्ट करने की आवश्यकता होती है (हालांकि कोई इसे चुनने के लिए BIC/AIC जैसे मानदंडों का उपयोग कर सकता है)। EM कभी-कभी धीरे-धीरे या स्थानीय इष्टतम पर संकुचित हो सकता है, इसलिए प्रारंभिककरण महत्वपूर्ण है (अक्सर EM को कई बार चलाया जाता है)। यदि डेटा वास्तव में Gaussian के मिश्रण का पालन नहीं करता है, तो मॉडल खराब फिट हो सकता है। एक Gaussian के केवल एक आउटलेयर को कवर करने के लिए सिकुड़ने का भी जोखिम होता है (हालांकि नियमितीकरण या न्यूनतम सहवर्तन सीमाएँ इसे कम कर सकती हैं)।

<details>
<summary>Example --  Soft Clustering & Anomaly Scores
</summary>
```python
from sklearn.mixture import GaussianMixture

# Fit a GMM with 3 components to the normal traffic data
gmm = GaussianMixture(n_components=3, covariance_type='full', random_state=0)
gmm.fit(base_data)  # using the 1500 normal data points from PCA example

# Print the learned Gaussian parameters
print("GMM means:\n", gmm.means_)
print("GMM covariance matrices:\n", gmm.covariances_)

# Take a sample attack-like point and evaluate it
sample_attack = np.array([[200, 800]])  # an outlier similar to earlier attack cluster
probs = gmm.predict_proba(sample_attack)
log_likelihood = gmm.score_samples(sample_attack)
print("Cluster membership probabilities for sample attack:", probs)
print("Log-likelihood of sample attack under GMM:", log_likelihood)
```
इस कोड में, हम सामान्य ट्रैफ़िक पर 3 गॉसियन के साथ एक GMM को प्रशिक्षित करते हैं (मान लेते हैं कि हमें वैध ट्रैफ़िक के 3 प्रोफाइल पता हैं)। प्रिंट की गई औसत और सहवर्तन इन क्लस्टरों का वर्णन करती हैं (उदाहरण के लिए, एक औसत [50,500] के आसपास हो सकता है जो एक क्लस्टर के केंद्र के अनुरूप है, आदि)। फिर हम एक संदिग्ध कनेक्शन [duration=200, bytes=800] का परीक्षण करते हैं। predict_proba इस बिंदु के 3 क्लस्टरों में से प्रत्येक से संबंधित होने की संभावना देता है - हम उम्मीद करेंगे कि ये संभावनाएँ बहुत कम या अत्यधिक विकृत होंगी क्योंकि [200,800] सामान्य क्लस्टरों से बहुत दूर है। कुल score_samples (लॉग-लाइकलिहुड) प्रिंट किया जाता है; एक बहुत कम मान इंगित करता है कि बिंदु मॉडल में अच्छी तरह से फिट नहीं होता है, इसे एक विसंगति के रूप में चिह्नित करता है। प्रैक्टिस में, कोई लॉग-लाइकलिहुड (या अधिकतम संभावना) पर एक थ्रेशोल्ड सेट कर सकता है यह तय करने के लिए कि क्या एक बिंदु पर्याप्त रूप से असंभावित है कि इसे दुर्भावनापूर्ण माना जाए। इस प्रकार GMM विसंगति पहचान करने का एक सिद्ध तरीका प्रदान करता है और अनिश्चितता को स्वीकार करने वाले नरम क्लस्टर भी उत्पन्न करता है।

### Isolation Forest

**Isolation Forest** एक एंसेंबल विसंगति पहचान एल्गोरिदम है जो बिंदुओं को यादृच्छिक रूप से अलग करने के विचार पर आधारित है। सिद्धांत यह है कि विसंगतियाँ कम और भिन्न होती हैं, इसलिए उन्हें सामान्य बिंदुओं की तुलना में अलग करना आसान होता है। एक Isolation Forest कई बाइनरी आइसोलेशन ट्री (यादृच्छिक निर्णय वृक्ष) बनाता है जो डेटा को यादृच्छिक रूप से विभाजित करते हैं। एक वृक्ष में प्रत्येक नोड पर, एक यादृच्छिक विशेषता का चयन किया जाता है और उस विशेषता के लिए डेटा के न्यूनतम और अधिकतम के बीच एक यादृच्छिक विभाजन मान चुना जाता है। यह विभाजन डेटा को दो शाखाओं में विभाजित करता है। वृक्ष को तब तक बढ़ाया जाता है जब तक प्रत्येक बिंदु अपने स्वयं के पत्ते में अलग नहीं हो जाता या अधिकतम वृक्ष ऊँचाई तक नहीं पहुँच जाता।

विसंगति पहचान इन यादृच्छिक वृक्षों में प्रत्येक बिंदु के पथ की लंबाई को देखकर की जाती है - बिंदु को अलग करने के लिए आवश्यक विभाजनों की संख्या। सहज रूप से, विसंगतियाँ (आउटलेयर) जल्दी अलग होने की प्रवृत्ति रखती हैं क्योंकि एक यादृच्छिक विभाजन एक आउटलेयर (जो एक विरल क्षेत्र में होता है) को सामान्य बिंदु की तुलना में अलग करने की अधिक संभावना रखता है जो एक घनी क्लस्टर में होता है। Isolation Forest सभी वृक्षों के औसत पथ की लंबाई से एक विसंगति स्कोर की गणना करता है: छोटा औसत पथ → अधिक विसंगति। स्कोर आमतौर पर [0,1] पर सामान्यीकृत होते हैं जहाँ 1 का अर्थ है बहुत संभावित विसंगति।

> [!TIP]
> *साइबर सुरक्षा में उपयोग के मामले:* Isolation Forest का सफलतापूर्वक उपयोग घुसपैठ पहचान और धोखाधड़ी पहचान में किया गया है। उदाहरण के लिए, नेटवर्क ट्रैफ़िक लॉग पर एक Isolation Forest को प्रशिक्षित करें जिसमें ज्यादातर सामान्य व्यवहार हो; वन अजीब ट्रैफ़िक (जैसे एक IP जो एक अनसुने पोर्ट का उपयोग करता है या एक असामान्य पैकेट आकार पैटर्न) के लिए छोटे पथ उत्पन्न करेगा, इसे निरीक्षण के लिए चिह्नित करेगा। चूंकि इसे लेबल किए गए हमलों की आवश्यकता नहीं होती है, यह अज्ञात हमले के प्रकारों का पता लगाने के लिए उपयुक्त है। इसे उपयोगकर्ता लॉगिन डेटा पर भी तैनात किया जा सकता है ताकि खाता अधिग्रहण का पता लगाया जा सके (असामान्य लॉगिन समय या स्थान जल्दी अलग हो जाते हैं)। एक उपयोग के मामले में, एक Isolation Forest एक उद्यम की सुरक्षा कर सकता है सिस्टम मैट्रिक्स की निगरानी करके और जब मैट्रिक्स (CPU, नेटवर्क, फ़ाइल परिवर्तनों) का एक संयोजन ऐतिहासिक पैटर्न से बहुत अलग दिखता है (छोटे आइसोलेशन पथ) तो एक अलर्ट उत्पन्न करता है।

#### Assumptions and Limitations

**Advantages**: Isolation Forest को वितरण के अनुमान की आवश्यकता नहीं होती; यह सीधे अलगाव को लक्षित करता है। यह उच्च-आयामी डेटा और बड़े डेटा सेट पर कुशल है (वन बनाने के लिए रैखिक जटिलता $O(n\log n)$) क्योंकि प्रत्येक वृक्ष केवल विशेषताओं और विभाजनों के एक उपसमुच्चय के साथ बिंदुओं को अलग करता है। यह संख्यात्मक विशेषताओं को अच्छी तरह से संभालने की प्रवृत्ति रखता है और यह दूरी-आधारित विधियों की तुलना में तेज हो सकता है जो $O(n^2)$ हो सकती हैं। यह स्वचालित रूप से एक विसंगति स्कोर भी देता है, इसलिए आप अलर्ट के लिए एक थ्रेशोल्ड सेट कर सकते हैं (या अपेक्षित विसंगति अंश के आधार पर स्वचालित रूप से कटऑफ तय करने के लिए एक संदूषण पैरामीटर का उपयोग कर सकते हैं)।

**Limitations**: इसकी यादृच्छिक प्रकृति के कारण, परिणामों में चलनों के बीच थोड़ी भिन्नता हो सकती है (हालांकि पर्याप्त वृक्षों के साथ यह मामूली है)। यदि डेटा में बहुत सारी अप्रासंगिक विशेषताएँ हैं या यदि विसंगतियाँ किसी विशेषता में मजबूत रूप से भिन्न नहीं होती हैं, तो अलगाव प्रभावी नहीं हो सकता है (यादृच्छिक विभाजन सामान्य बिंदुओं को संयोग से अलग कर सकते हैं - हालाँकि कई वृक्षों का औसत इसको कम करता है)। इसके अलावा, Isolation Forest सामान्यतः मानता है कि विसंगतियाँ एक छोटी अल्पसंख्यक हैं (जो आमतौर पर साइबर सुरक्षा परिदृश्यों में सच है)।

<details>
<summary>उदाहरण -- नेटवर्क लॉग में आउटलेयर का पता लगाना
</summary>

हम पहले के परीक्षण डेटा सेट (जिसमें सामान्य और कुछ हमले के बिंदु शामिल हैं) का उपयोग करेंगे और देखेंगे कि क्या एक Isolation Forest हमलों को अलग कर सकता है। हम मान लेंगे कि हम डेटा के ~15% को विसंगतिपूर्ण मानते हैं (प्रदर्शन के लिए)।
```python
from sklearn.ensemble import IsolationForest

# Combine normal and attack test data from autoencoder example
X_test_if = test_data  # (120 x 2 array with 100 normal and 20 attack points)
# Train Isolation Forest (unsupervised) on the test set itself for demo (in practice train on known normal)
iso_forest = IsolationForest(n_estimators=100, contamination=0.15, random_state=0)
iso_forest.fit(X_test_if)
# Predict anomalies (-1 for anomaly, 1 for normal)
preds = iso_forest.predict(X_test_if)
anomaly_scores = iso_forest.decision_function(X_test_if)  # the higher, the more normal
print("Isolation Forest predicted labels (first 20):", preds[:20])
print("Number of anomalies detected:", np.sum(preds == -1))
print("Example anomaly scores (lower means more anomalous):", anomaly_scores[:5])
```
इस कोड में, हम `IsolationForest` को 100 पेड़ों के साथ स्थापित करते हैं और `contamination=0.15` सेट करते हैं (जिसका अर्थ है कि हम लगभग 15% विसंगतियों की अपेक्षा करते हैं; मॉडल अपने स्कोर थ्रेशोल्ड को इस तरह सेट करेगा कि ~15% बिंदुओं को चिह्नित किया जाए)। हम इसे `X_test_if` पर फिट करते हैं जिसमें सामान्य और हमले के बिंदुओं का मिश्रण होता है (नोट: सामान्यतः आप प्रशिक्षण डेटा पर फिट करते हैं और फिर नए डेटा पर भविष्यवाणी करते हैं, लेकिन यहाँ उदाहरण के लिए हम उसी सेट पर फिट और भविष्यवाणी करते हैं ताकि सीधे परिणाम देख सकें)।

आउटपुट पहले 20 बिंदुओं के लिए पूर्वानुमानित लेबल दिखाता है (जहाँ -1 विसंगति को दर्शाता है)। हम यह भी प्रिंट करते हैं कि कुल मिलाकर कितनी विसंगतियाँ पाई गईं और कुछ उदाहरण विसंगति स्कोर। हम अपेक्षा करेंगे कि 120 बिंदुओं में से लगभग 18 को -1 के रूप में लेबल किया जाएगा (क्योंकि संदूषण 15% था)। यदि हमारे 20 हमले के नमूने वास्तव में सबसे अधिक बाहरी हैं, तो उनमें से अधिकांश उन -1 पूर्वानुमानों में दिखाई देने चाहिए। विसंगति स्कोर (Isolation Forest का निर्णय कार्य) सामान्य बिंदुओं के लिए उच्च और विसंगतियों के लिए निम्न (अधिक नकारात्मक) होता है - हम कुछ मान प्रिंट करते हैं ताकि विभाजन को देख सकें। प्रैक्टिस में, कोई डेटा को स्कोर के अनुसार क्रमबद्ध कर सकता है ताकि शीर्ष बाहरी बिंदुओं को देखा जा सके और उनकी जांच की जा सके। इस प्रकार, Isolation Forest बड़े बिना लेबल वाले सुरक्षा डेटा के माध्यम से छानने और मानव विश्लेषण या आगे की स्वचालित जांच के लिए सबसे असामान्य उदाहरणों को चुनने का एक कुशल तरीका प्रदान करता है।

### t-SNE (t-Distributed Stochastic Neighbor Embedding)

**t-SNE** एक गैर-रेखीय आयाम कमी तकनीक है जो विशेष रूप से उच्च-आयामी डेटा को 2 या 3 आयामों में दृश्य बनाने के लिए डिज़ाइन की गई है। यह डेटा बिंदुओं के बीच समानताओं को संयुक्त संभाव्यता वितरण में परिवर्तित करता है और निम्न-आयामी प्रक्षिप्ति में स्थानीय पड़ोसों की संरचना को बनाए रखने की कोशिश करता है। सरल शब्दों में, t-SNE बिंदुओं को (मान लीजिए) 2D में इस तरह रखता है कि समान बिंदु (मूल स्थान में) एक साथ निकटता में होते हैं और असमान बिंदु उच्च संभाव्यता के साथ दूर होते हैं।

एल्गोरिदम के दो मुख्य चरण हैं:

1. **उच्च-आयामी स्थान में जोड़ीदार संबंधों की गणना करें:** प्रत्येक बिंदु के जोड़े के लिए, t-SNE एक संभाव्यता की गणना करता है कि कोई उस जोड़े को पड़ोसी के रूप में चुनेगा (यह प्रत्येक बिंदु पर एक गॉसियन वितरण को केंद्रित करके और दूरी को मापकर किया जाता है - पेर्प्लेक्सिटी पैरामीटर प्रभावी पड़ोसियों की संख्या को प्रभावित करता है)।
2. **निम्न-आयामी (जैसे 2D) स्थान में जोड़ीदार संबंधों की गणना करें:** प्रारंभ में, बिंदुओं को 2D में यादृच्छिक रूप से रखा जाता है। t-SNE इस मानचित्र में दूरी के लिए एक समान संभाव्यता परिभाषित करता है (एक स्टूडेंट t-वितरण कर्नेल का उपयोग करके, जिसमें गॉसियन की तुलना में भारी पूंछ होती है ताकि दूर के बिंदुओं को अधिक स्वतंत्रता मिल सके)।
3. **ग्रेडिएंट डिसेंट:** t-SNE फिर उच्च-D संबंध वितरण और निम्न-D के बीच Kullback–Leibler (KL) विभाजन को न्यूनतम करने के लिए 2D में बिंदुओं को क्रमिक रूप से स्थानांतरित करता है। इससे 2D व्यवस्था उच्च-D संरचना को यथासंभव दर्शाती है - जो बिंदु मूल स्थान में निकट थे वे एक-दूसरे को आकर्षित करेंगे, और जो दूर हैं वे एक-दूसरे को दूर करेंगे, जब तक कि संतुलन नहीं पाया जाता।

परिणाम अक्सर एक दृश्यात्मक रूप से अर्थपूर्ण स्कैटर प्लॉट होता है जहाँ डेटा में समूह स्पष्ट हो जाते हैं।

> [!TIP]
> *साइबर सुरक्षा में उपयोग के मामले:* t-SNE अक्सर **मानव विश्लेषण के लिए उच्च-आयामी सुरक्षा डेटा को दृश्य बनाने के लिए** उपयोग किया जाता है। उदाहरण के लिए, एक सुरक्षा संचालन केंद्र में, विश्लेषक एक घटना डेटा सेट ले सकते हैं जिसमें दर्जनों विशेषताएँ (पोर्ट नंबर, आवृत्तियाँ, बाइट गिनती, आदि) होती हैं और t-SNE का उपयोग करके 2D प्लॉट उत्पन्न कर सकते हैं। हमले इस प्लॉट में अपने स्वयं के समूह बना सकते हैं या सामान्य डेटा से अलग हो सकते हैं, जिससे उन्हें पहचानना आसान हो जाता है। इसे मैलवेयर डेटा सेट पर लागू किया गया है ताकि मैलवेयर परिवारों के समूहों को देखा जा सके या नेटवर्क घुसपैठ डेटा पर जहाँ विभिन्न हमले के प्रकार स्पष्ट रूप से समूहित होते हैं, आगे की जांच को मार्गदर्शित करते हैं। मूल रूप से, t-SNE एक ऐसा तरीका प्रदान करता है जिससे साइबर डेटा में संरचना देखी जा सके जो अन्यथा अस्पष्ट होती।

#### धारणाएँ और सीमाएँ

t-SNE पैटर्न की दृश्य खोज के लिए उत्कृष्ट है। यह समूह, उप-समूह, और विसंगतियों को प्रकट कर सकता है जो अन्य रेखीय विधियाँ (जैसे PCA) नहीं कर सकतीं। इसका उपयोग साइबर सुरक्षा अनुसंधान में जटिल डेटा जैसे मैलवेयर व्यवहार प्रोफाइल या नेटवर्क ट्रैफ़िक पैटर्न को दृश्य बनाने के लिए किया गया है। क्योंकि यह स्थानीय संरचना को बनाए रखता है, यह प्राकृतिक समूहों को दिखाने में अच्छा है।

हालांकि, t-SNE गणनात्मक रूप से भारी है (लगभग $O(n^2)$) इसलिए इसे बहुत बड़े डेटा सेट के लिए सैंपलिंग की आवश्यकता हो सकती है। इसमें हाइपरपैरामीटर (पेर्प्लेक्सिटी, लर्निंग रेट, पुनरावृत्तियाँ) भी होते हैं जो आउटपुट को प्रभावित कर सकते हैं - उदाहरण के लिए, विभिन्न पेर्प्लेक्सिटी मान विभिन्न पैमानों पर समूहों को प्रकट कर सकते हैं। t-SNE प्लॉट कभी-कभी गलत तरीके से व्याख्यायित किए जा सकते हैं - मानचित्र में दूरी वैश्विक रूप से सीधे अर्थपूर्ण नहीं होती (यह स्थानीय पड़ोस पर ध्यान केंद्रित करता है, कभी-कभी समूह कृत्रिम रूप से अच्छी तरह से अलग दिखाई दे सकते हैं)। इसके अलावा, t-SNE मुख्य रूप से दृश्य के लिए है; यह नए डेटा बिंदुओं को बिना पुनर्गणना के प्रक्षिप्त करने का सीधा तरीका प्रदान नहीं करता है, और इसे भविष्यवाणी मॉडलिंग के लिए पूर्व-प्रसंस्करण के रूप में उपयोग करने के लिए नहीं बनाया गया है (UMAP एक विकल्प है जो कुछ इन मुद्दों को तेज गति के साथ संबोधित करता है)।

<details>
<summary>उदाहरण -- नेटवर्क कनेक्शनों का दृश्य बनाना
</summary>

हम t-SNE का उपयोग करके एक बहु-विशेषता डेटा सेट को 2D में कम करेंगे। उदाहरण के लिए, चलिए पहले के 4D डेटा (जिसमें सामान्य ट्रैफ़िक के 3 प्राकृतिक समूह थे) को लेते हैं और कुछ विसंगति बिंदुओं को जोड़ते हैं। फिर हम t-SNE चलाते हैं और (वैचारिक रूप से) परिणामों का दृश्य बनाते हैं।
```python
# 1 ─────────────────────────────────────────────────────────────────────
#    Create synthetic 4-D dataset
#      • Three clusters of “normal” traffic (duration, bytes)
#      • Two correlated features: packets & errors
#      • Five outlier points to simulate suspicious traffic
# ──────────────────────────────────────────────────────────────────────
import numpy as np
import matplotlib.pyplot as plt
from sklearn.manifold import TSNE
from sklearn.preprocessing import StandardScaler

rng = np.random.RandomState(42)

# Base (duration, bytes) clusters
normal1 = rng.normal(loc=[50, 500],  scale=[10, 100], size=(500, 2))
normal2 = rng.normal(loc=[60, 1500], scale=[8,  200], size=(500, 2))
normal3 = rng.normal(loc=[70, 3000], scale=[5,  300], size=(500, 2))

base_data = np.vstack([normal1, normal2, normal3])       # (1500, 2)

# Correlated features
packets = base_data[:, 1] / 50 + rng.normal(scale=0.5, size=len(base_data))
errors  = base_data[:, 0] / 10 + rng.normal(scale=0.5, size=len(base_data))

data_4d = np.column_stack([base_data, packets, errors])  # (1500, 4)

# Outlier / attack points
outliers_4d = np.column_stack([
rng.normal(250, 1, size=5),     # extreme duration
rng.normal(1000, 1, size=5),    # moderate bytes
rng.normal(5, 1, size=5),       # very low packets
rng.normal(25, 1, size=5)       # high errors
])

data_viz = np.vstack([data_4d, outliers_4d])             # (1505, 4)

# 2 ─────────────────────────────────────────────────────────────────────
#    Standardize features (recommended for t-SNE)
# ──────────────────────────────────────────────────────────────────────
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data_viz)

# 3 ─────────────────────────────────────────────────────────────────────
#    Run t-SNE to project 4-D → 2-D
# ──────────────────────────────────────────────────────────────────────
tsne = TSNE(
n_components=2,
perplexity=30,
learning_rate='auto',
init='pca',
random_state=0
)
data_2d = tsne.fit_transform(data_scaled)
print("t-SNE output shape:", data_2d.shape)  # (1505, 2)

# 4 ─────────────────────────────────────────────────────────────────────
#    Visualize: normal traffic vs. outliers
# ──────────────────────────────────────────────────────────────────────
plt.figure(figsize=(8, 6))
plt.scatter(
data_2d[:-5, 0], data_2d[:-5, 1],
label="Normal traffic",
alpha=0.6,
s=10
)
plt.scatter(
data_2d[-5:, 0], data_2d[-5:, 1],
label="Outliers / attacks",
alpha=0.9,
s=40,
marker="X",
edgecolor='k'
)

plt.title("t-SNE Projection of Synthetic Network Traffic")
plt.xlabel("t-SNE component 1")
plt.ylabel("t-SNE component 2")
plt.legend()
plt.tight_layout()
plt.show()
```
यहाँ हमने अपने पिछले 4D सामान्य डेटासेट को कुछ चरम आउटलेयर के साथ मिलाया है (आउटलेयर में एक विशेषता ("अवधि") बहुत उच्च सेट की गई है, आदि, एक अजीब पैटर्न का अनुकरण करने के लिए)। हम 30 की सामान्य पेरीप्लेक्सिटी के साथ t-SNE चलाते हैं। आउटपुट data_2d का आकार (1505, 2) है। हम वास्तव में इस पाठ में प्लॉट नहीं करेंगे, लेकिन अगर हम करते, तो हम शायद 3 सामान्य क्लस्टरों के लिए तीन तंग क्लस्टर देखने की उम्मीद करते, और 5 आउटलेयर उन क्लस्टरों से दूर अलग बिंदुओं के रूप में दिखाई देंगे। एक इंटरएक्टिव वर्कफ़्लो में, हम बिंदुओं को उनके लेबल (सामान्य या कौन सा क्लस्टर, बनाम विसंगति) द्वारा रंगीन कर सकते हैं ताकि इस संरचना की पुष्टि की जा सके। लेबल के बिना भी, एक विश्लेषक उन 5 बिंदुओं को 2D प्लॉट पर खाली स्थान में बैठे हुए देख सकता है और उन्हें चिह्नित कर सकता है। यह दिखाता है कि t-SNE साइबर सुरक्षा डेटा में दृश्य विसंगति पहचान और क्लस्टर निरीक्षण के लिए एक शक्तिशाली सहायक हो सकता है, जो ऊपर दिए गए स्वचालित एल्गोरिदम को पूरा करता है।

</details>


{{#include ../banners/hacktricks-training.md}}
