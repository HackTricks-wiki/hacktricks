# Алгоритми некерованого навчання

{{#include ../banners/hacktricks-training.md}}

## Некероване навчання

Некероване навчання — це тип машинного навчання, де модель навчається на даних без маркованих відповідей. Мета полягає в тому, щоб знайти шаблони, структури або зв'язки в даних. На відміну від керованого навчання, де модель навчається на маркованих прикладах, алгоритми некерованого навчання працюють з немаркованими даними. Некероване навчання часто використовується для завдань, таких як кластеризація, зменшення розмірності та виявлення аномалій. Воно може допомогти виявити приховані шаблони в даних, згрупувати подібні елементи разом або зменшити складність даних, зберігаючи їх основні характеристики.

### Кластеризація K-Середніх

K-Середніх — це алгоритм кластеризації на основі центроїдів, який розділяє дані на K кластерів, призначаючи кожну точку найближчому середньому кластеру. Алгоритм працює наступним чином:
1. **Ініціалізація**: Виберіть K початкових центрів кластерів (центроїдів), часто випадковим чином або за допомогою більш розумних методів, таких як k-means++
2. **Призначення**: Призначте кожну точку даних найближчому центроїду на основі метрики відстані (наприклад, евклідова відстань).
3. **Оновлення**: Перерахуньте центроїди, взявши середнє всіх точок даних, призначених кожному кластеру.
4. **Повторення**: Кроки 2–3 повторюються, поки призначення кластерів не стабілізуються (центроїди більше не рухаються суттєво).

> [!TIP]
> *Випадки використання в кібербезпеці:* K-Середніх використовується для виявлення вторгнень шляхом кластеризації мережевих подій. Наприклад, дослідники застосували K-Середніх до набору даних про вторгнення KDD Cup 99 і виявили, що він ефективно розділяє трафік на нормальні та атакуючі кластери. На практиці аналітики безпеки можуть кластеризувати записи журналів або дані про поведінку користувачів, щоб знайти групи подібної активності; будь-які точки, які не належать до добре сформованого кластера, можуть вказувати на аномалії (наприклад, новий варіант шкідливого ПЗ, що формує свій власний малий кластер). K-Середніх також може допомогти в класифікації сімейства шкідливого ПЗ, групуючи бінарні файли на основі профілів поведінки або векторів ознак.

#### Вибір K
Кількість кластерів (K) є гіперпараметром, який потрібно визначити перед запуском алгоритму. Техніки, такі як Метод Ліктя або Оцінка Силуету, можуть допомогти визначити відповідне значення для K, оцінюючи продуктивність кластеризації:

- **Метод Ліктя**: Нанесіть на графік суму квадратів відстаней від кожної точки до її призначеного центроїду кластера як функцію K. Шукайте "ліктьову" точку, де швидкість зменшення різко змінюється, що вказує на підходящу кількість кластерів.
- **Оцінка Силуету**: Обчисліть оцінку силуету для різних значень K. Вища оцінка силуету вказує на краще визначені кластери.

#### Припущення та обмеження

K-Середніх припускає, що **кластери є сферичними та однакового розміру**, що може не відповідати всім наборам даних. Він чутливий до початкового розміщення центроїдів і може сходитися до локальних мінімумів. Крім того, K-Середніх не підходить для наборів даних з різною щільністю або не глобулярними формами та ознаками з різними масштабами. Кроки попередньої обробки, такі як нормалізація або стандартизація, можуть бути необхідні, щоб забезпечити рівний внесок усіх ознак у обчислення відстаней.

<details>
<summary>Приклад -- Кластеризація мережевих подій
</summary>
Нижче ми моделюємо дані мережевого трафіку та використовуємо K-Середніх для їх кластеризації. Припустимо, у нас є події з такими ознаками, як тривалість з'єднання та кількість байтів. Ми створюємо 3 кластери "нормального" трафіку та 1 малий кластер, що представляє патерн атаки. Потім ми запускаємо K-Середніх, щоб перевірити, чи розділяє він їх.
```python
import numpy as np
from sklearn.cluster import KMeans

# Simulate synthetic network traffic data (e.g., [duration, bytes]).
# Three normal clusters and one small attack cluster.
rng = np.random.RandomState(42)
normal1 = rng.normal(loc=[50, 500], scale=[10, 100], size=(500, 2))   # Cluster 1
normal2 = rng.normal(loc=[60, 1500], scale=[8, 200], size=(500, 2))   # Cluster 2
normal3 = rng.normal(loc=[70, 3000], scale=[5, 300], size=(500, 2))   # Cluster 3
attack = rng.normal(loc=[200, 800], scale=[5, 50], size=(50, 2))      # Small attack cluster

X = np.vstack([normal1, normal2, normal3, attack])
# Run K-Means clustering into 4 clusters (we expect it to find the 4 groups)
kmeans = KMeans(n_clusters=4, random_state=0, n_init=10)
labels = kmeans.fit_predict(X)

# Analyze resulting clusters
clusters, counts = np.unique(labels, return_counts=True)
print(f"Cluster labels: {clusters}")
print(f"Cluster sizes: {counts}")
print("Cluster centers (duration, bytes):")
for idx, center in enumerate(kmeans.cluster_centers_):
print(f"  Cluster {idx}: {center}")
```
У цьому прикладі K-Means має знайти 4 кластери. Малий кластер атак (з незвично високою тривалістю ~200) ідеально сформує свій власний кластер, враховуючи його відстань від нормальних кластерів. Ми виводимо розміри кластерів і центри, щоб інтерпретувати результати. У реальному сценарії можна було б позначити кластер з кількома точками як потенційні аномалії або перевірити його учасників на наявність шкідливої активності.

### Ієрархічна кластеризація

Ієрархічна кластеризація будує ієрархію кластерів, використовуючи або підхід знизу-вгору (агломеративний), або зверху-вниз (дискретний):

1. **Агломеративний (Знизу-вгору)**: Починаємо з кожної точки даних як окремого кластера і ітеративно об'єднуємо найближчі кластери, поки не залишиться один кластер або не буде досягнуто критерію зупинки.
2. **Дискретний (Зверху-вниз)**: Починаємо з усіх точок даних в одному кластері і ітеративно розділяємо кластери, поки кожна точка даних не стане своїм власним кластером або не буде досягнуто критерію зупинки.

Агломеративна кластеризація вимагає визначення відстані між кластерами та критерію зв'язку для вирішення, які кластери об'єднувати. Загальні методи зв'язку включають одиничний зв'язок (відстань найближчих точок між двома кластерами), повний зв'язок (відстань найвіддаленіших точок), середній зв'язок тощо, а метрика відстані часто є евклідичною. Вибір зв'язку впливає на форму отриманих кластерів. Немає необхідності заздалегідь визначати кількість кластерів K; ви можете "перерізати" дендрограму на обраному рівні, щоб отримати бажану кількість кластерів.

Ієрархічна кластеризація виробляє дендрограму, деревоподібну структуру, яка показує відносини між кластерами на різних рівнях деталізації. Дендрограму можна перерізати на бажаному рівні, щоб отримати певну кількість кластерів.

> [!TIP]
> *Випадки використання в кібербезпеці:* Ієрархічна кластеризація може організувати події або сутності в дерево для виявлення відносин. Наприклад, в аналізі шкідливого ПЗ агломеративна кластеризація може групувати зразки за поведінковою схожістю, виявляючи ієрархію сімей і варіантів шкідливого ПЗ. У мережевій безпеці можна кластеризувати потоки IP-трафіку та використовувати дендрограму для перегляду підгруп трафіку (наприклад, за протоколом, а потім за поведінкою). Оскільки вам не потрібно заздалегідь вибирати K, це корисно при дослідженні нових даних, для яких кількість категорій атак невідома.

#### Припущення та обмеження

Ієрархічна кластеризація не припускає певної форми кластера і може захоплювати вкладені кластери. Вона корисна для виявлення таксономії або відносин між групами (наприклад, групування шкідливого ПЗ за підгрупами сімей). Вона детермінована (немає проблем з випадковою ініціалізацією). Ключовою перевагою є дендрограма, яка надає уявлення про структуру кластеризації даних на всіх масштабах – аналітики безпеки можуть вирішити, де провести відповідний розподіл для виявлення значущих кластерів. Однак вона є обчислювально витратною (зазвичай $O(n^2)$ часу або гірше для наївних реалізацій) і не є доцільною для дуже великих наборів даних. Це також жадібна процедура – після об'єднання або розділення це не може бути скасовано, що може призвести до субоптимальних кластерів, якщо помилка сталася на ранньому етапі. Викиди також можуть впливати на деякі стратегії зв'язку (одиничний зв'язок може викликати ефект "ланцюгового" зв'язку, коли кластери з'єднуються через викиди).

<details>
<summary>Приклад -- Агломеративна кластеризація подій
</summary>

Ми повторно використаємо синтетичні дані з прикладу K-Means (3 нормальні кластери + 1 кластер атак) і застосуємо агломеративну кластеризацію. Потім ми ілюструємо, як отримати дендрограму та мітки кластерів.
```python
from sklearn.cluster import AgglomerativeClustering
from scipy.cluster.hierarchy import linkage, dendrogram

# Perform agglomerative clustering (bottom-up) on the data
agg = AgglomerativeClustering(n_clusters=None, distance_threshold=0, linkage='ward')
# distance_threshold=0 gives the full tree without cutting (we can cut manually)
agg.fit(X)

print(f"Number of merge steps: {agg.n_clusters_ - 1}")  # should equal number of points - 1
# Create a dendrogram using SciPy for visualization (optional)
Z = linkage(X, method='ward')
# Normally, you would plot the dendrogram. Here we'll just compute cluster labels for a chosen cut:
clusters_3 = AgglomerativeClustering(n_clusters=3, linkage='ward').fit_predict(X)
print(f"Labels with 3 clusters: {np.unique(clusters_3)}")
print(f"Cluster sizes for 3 clusters: {np.bincount(clusters_3)}")
```
</details>

### DBSCAN (Density-Based Spatial Clustering of Applications with Noise)

DBSCAN - це алгоритм кластеризації на основі щільності, який об'єднує точки, що щільно розташовані разом, позначаючи точки в регіонах з низькою щільністю як викиди. Він особливо корисний для наборів даних з різною щільністю та некулястими формами.

DBSCAN працює, визначаючи два параметри:
- **Epsilon (ε)**: Максимальна відстань між двома точками, щоб вважатися частиною одного кластеру.
- **MinPts**: Мінімальна кількість точок, необхідна для формування щільного регіону (основна точка).

DBSCAN ідентифікує основні точки, граничні точки та точки шуму:
- **Основна точка**: Точка з принаймні MinPts сусідами в межах відстані ε.
- **Гранична точка**: Точка, яка знаходиться в межах відстані ε від основної точки, але має менше ніж MinPts сусідів.
- **Точка шуму**: Точка, яка не є ні основною, ні граничною.

Кластеризація відбувається шляхом вибору невідвіданої основної точки, позначення її як нового кластеру, а потім рекурсивного додавання всіх точок, що досяжні за щільністю (основні точки та їх сусіди тощо). Граничні точки додаються до кластеру сусідньої основної точки. Після розширення всіх досяжних точок DBSCAN переходить до іншої невідвіданої основної точки, щоб почати новий кластер. Точки, які не були досягнуті жодною основною точкою, залишаються позначеними як шум.

> [!TIP]
> *Випадки використання в кібербезпеці:* DBSCAN корисний для виявлення аномалій у мережевому трафіку. Наприклад, нормальна активність користувачів може формувати один або кілька щільних кластерів у просторі ознак, тоді як нові атаки можуть з'являтися як розсіяні точки, які DBSCAN позначить як шум (викиди). Його використовували для кластеризації записів мережевого потоку, де він може виявляти сканування портів або трафік відмови в обслуговуванні як рідкісні регіони точок. Інша програма - групування варіантів шкідливого ПЗ: якщо більшість зразків кластеризуються за родинами, але кілька не підходять ніде, ці кілька можуть бути нульовими днями шкідливого ПЗ. Здатність позначати шум означає, що команди безпеки можуть зосередитися на розслідуванні цих викидів.

#### Припущення та обмеження

**Припущення та сильні сторони:** DBSCAN не припускає сферичних кластерів - він може знаходити кластери довільної форми (навіть ланцюгоподібні або сусідні кластери). Він автоматично визначає кількість кластерів на основі щільності даних і може ефективно ідентифікувати викиди як шум. Це робить його потужним для реальних даних з нерегулярними формами та шумом. Він стійкий до викидів (на відміну від K-Means, який змушує їх потрапляти в кластери). Він добре працює, коли кластери мають приблизно рівномірну щільність.

**Обмеження:** Продуктивність DBSCAN залежить від вибору відповідних значень ε та MinPts. Він може мати труднощі з даними, які мають різну щільність - одне ε не може вмістити як щільні, так і рідкісні кластери. Якщо ε занадто мале, він позначає більшість точок як шум; занадто велике, і кластери можуть неправильно зливатися. Крім того, DBSCAN може бути неефективним на дуже великих наборах даних (наївно $O(n^2)$, хоча просторове індексування може допомогти). У високорозмірних просторах ознак концепція "відстані в межах ε" може стати менш значущою (прокляття вимірності), і DBSCAN може вимагати ретельного налаштування параметрів або може не знайти інтуїтивні кластери. Незважаючи на це, розширення, такі як HDBSCAN, вирішують деякі проблеми (наприклад, різну щільність).

<details>
<summary>Приклад -- Кластеризація з шумом
</summary>
```python
from sklearn.cluster import DBSCAN

# Generate synthetic data: 2 normal clusters and 5 outlier points
cluster1 = rng.normal(loc=[100, 1000], scale=[5, 100], size=(100, 2))
cluster2 = rng.normal(loc=[120, 2000], scale=[5, 100], size=(100, 2))
outliers = rng.uniform(low=[50, 50], high=[180, 3000], size=(5, 2))  # scattered anomalies
data = np.vstack([cluster1, cluster2, outliers])

# Run DBSCAN with chosen eps and MinPts
eps = 15.0   # radius for neighborhood
min_pts = 5  # minimum neighbors to form a dense region
db = DBSCAN(eps=eps, min_samples=min_pts).fit(data)
labels = db.labels_  # cluster labels (-1 for noise)

# Analyze clusters and noise
num_clusters = len(set(labels) - {-1})
num_noise = np.sum(labels == -1)
print(f"DBSCAN found {num_clusters} clusters and {num_noise} noise points")
print("Cluster labels for first 10 points:", labels[:10])
```
У цьому фрагменті ми налаштували `eps` та `min_samples`, щоб відповідати масштабам наших даних (15.0 у одиницях ознак і вимагаючи 5 точок для формування кластера). DBSCAN має знайти 2 кластери (кластери нормального трафіку) і позначити 5 ін'єкованих викидів як шум. Ми виводимо кількість кластерів у порівнянні з шумовими точками, щоб це перевірити. У реальних умовах можна ітерувати по ε (використовуючи евристичний граф k-відстані для вибору ε) та MinPts (часто встановлюється приблизно на рівні розмірності даних + 1 як правило) для знаходження стабільних результатів кластеризації. Можливість явно позначати шум допомагає відокремити потенційні дані атак для подальшого аналізу.

</details>

### Аналіз головних компонент (PCA)

PCA - це техніка для **зменшення розмірності**, яка знаходить новий набір ортогональних осей (головні компоненти), які захоплюють максимальну дисперсію в даних. Простими словами, PCA обертає та проєктує дані на нову координатну систему так, що перша головна компонента (PC1) пояснює найбільшу можливу дисперсію, друга PC (PC2) пояснює найбільшу дисперсію, ортогональну до PC1, і так далі. Математично PCA обчислює власні вектори матриці коваріації даних – ці власні вектори є напрямками головних компонент, а відповідні власні значення вказують на кількість дисперсії, поясненої кожним. Це часто використовується для видобутку ознак, візуалізації та зменшення шуму.

Зверніть увагу, що це корисно, якщо розміри набору даних містять **значні лінійні залежності або кореляції**.

PCA працює, визначаючи головні компоненти даних, які є напрямками максимальної дисперсії. Кроки, що входять до PCA, такі:
1. **Стандартизація**: Центруйте дані, віднімаючи середнє та масштабируючи до одиничної дисперсії.
2. **Матриця коваріації**: Обчисліть матрицю коваріації стандартизованих даних, щоб зрозуміти взаємозв'язки між ознаками.
3. **Декомпозиція власних значень**: Виконайте декомпозицію власних значень на матриці коваріації, щоб отримати власні значення та власні вектори.
4. **Вибір головних компонент**: Відсортуйте власні значення у спадному порядку та виберіть верхні K власних векторів, що відповідають найбільшим власним значенням. Ці власні вектори формують новий простір ознак.
5. **Перетворення даних**: Проєктуйте оригінальні дані на новий простір ознак, використовуючи вибрані головні компоненти.
PCA широко використовується для візуалізації даних, зменшення шуму та як етап попередньої обробки для інших алгоритмів машинного навчання. Це допомагає зменшити розмірність даних, зберігаючи їх основну структуру.

#### Власні значення та власні вектори

Власне значення - це скаляр, який вказує на кількість дисперсії, захопленої його відповідним власним вектором. Власний вектор представляє напрямок у просторі ознак, уздовж якого дані змінюються найбільше.

Уявіть, що A - це квадратна матриця, а v - ненульовий вектор, такий що: `A * v = λ * v`
де:
- A - квадратна матриця, наприклад, [ [1, 2], [2, 1]] (наприклад, матриця коваріації)
- v - власний вектор (наприклад, [1, 1])

Тоді, `A * v = [ [1, 2], [2, 1]] * [1, 1] = [3, 3]`, що буде власним значенням λ, помноженим на власний вектор v, отже, власне значення λ = 3.

#### Власні значення та власні вектори в PCA

Давайте пояснимо це на прикладі. Уявіть, що у вас є набір даних з великою кількістю чорно-білих зображень облич розміром 100x100 пікселів. Кожен піксель можна вважати ознакою, отже, у вас є 10,000 ознак на зображення (або вектор з 10000 компонент на зображення). Якщо ви хочете зменшити розмірність цього набору даних за допомогою PCA, ви повинні виконати такі кроки:

1. **Стандартизація**: Центруйте дані, віднімаючи середнє значення кожної ознаки (пікселя) з набору даних.
2. **Матриця коваріації**: Обчисліть матрицю коваріації стандартизованих даних, яка захоплює, як ознаки (пікселі) змінюються разом.
- Зверніть увагу, що коваріація між двома змінними (пікселями в даному випадку) вказує на те, наскільки вони змінюються разом, тому ідея полягає в тому, щоб з'ясувати, які пікселі, як правило, збільшуються або зменшуються разом з лінійною залежністю.
- Наприклад, якщо піксель 1 і піксель 2, як правило, збільшуються разом, коваріація між ними буде позитивною.
- Матриця коваріації буде матрицею 10,000x10,000, де кожен елемент представляє коваріацію між двома пікселями.
3. **Розв'язання рівняння власних значень**: Рівняння власних значень, яке потрібно розв'язати, є `C * v = λ * v`, де C - матриця коваріації, v - власний вектор, а λ - власне значення. Його можна розв'язати за допомогою методів, таких як:
- **Декомпозиція власних значень**: Виконайте декомпозицію власних значень на матриці коваріації, щоб отримати власні значення та власні вектори.
- **Сингулярна декомпозиція (SVD)**: Альтернативно, ви можете використовувати SVD для розкладання матриці даних на сингулярні значення та вектори, що також може дати головні компоненти.
4. **Вибір головних компонент**: Відсортуйте власні значення у спадному порядку та виберіть верхні K власних векторів, що відповідають найбільшим власним значенням. Ці власні вектори представляють напрямки максимальної дисперсії в даних.

> [!TIP]
> *Випадки використання в кібербезпеці:* Загальне використання PCA в безпеці - це зменшення ознак для виявлення аномалій. Наприклад, система виявлення вторгнень з 40+ мережевими метриками (як-от ознаки NSL-KDD) може використовувати PCA для зменшення до кількох компонент, підсумовуючи дані для візуалізації або подачі в алгоритми кластеризації. Аналітики можуть відображати мережевий трафік у просторі перших двох головних компонент, щоб побачити, чи відокремлюються атаки від нормального трафіку. PCA також може допомогти усунути надлишкові ознаки (як-от байти, надіслані проти байтів, отриманих, якщо вони корельовані), щоб зробити алгоритми виявлення більш надійними та швидкими.

#### Припущення та обмеження

PCA припускає, що **головні осі дисперсії є значущими** – це лінійний метод, тому він захоплює лінійні кореляції в даних. Це некероване навчання, оскільки воно використовує лише коваріацію ознак. Переваги PCA включають зменшення шуму (компоненти з малою дисперсією часто відповідають шуму) та декореляцію ознак. Це обчислювально ефективно для помірно високих розмірностей і часто є корисним етапом попередньої обробки для інших алгоритмів (щоб пом'якшити прокляття розмірності). Одне з обмежень полягає в тому, що PCA обмежена лінійними зв'язками – вона не захоплює складну нелінійну структуру (тоді як автоенкодери або t-SNE можуть). Крім того, компоненти PCA можуть бути важкими для інтерпретації з точки зору оригінальних ознак (вони є комбінаціями оригінальних ознак). У кібербезпеці потрібно бути обережним: атака, яка викликає лише незначну зміну в ознаці з низькою дисперсією, може не з'явитися в верхніх ПК (оскільки PCA пріоритизує дисперсію, а не обов'язково "цікавість").

<details>
<summary>Приклад -- Зменшення розмірності мережевих даних
</summary>

Припустимо, у нас є журнали мережевих з'єднань з кількома ознаками (наприклад, тривалість, байти, кількість). Ми згенеруємо синтетичний 4-вимірний набір даних (з деякою кореляцією між ознаками) і використаємо PCA, щоб зменшити його до 2 вимірів для візуалізації або подальшого аналізу.
```python
from sklearn.decomposition import PCA

# Create synthetic 4D data (3 clusters similar to before, but add correlated features)
# Base features: duration, bytes (as before)
base_data = np.vstack([normal1, normal2, normal3])  # 1500 points from earlier normal clusters
# Add two more features correlated with existing ones, e.g. packets = bytes/50 + noise, errors = duration/10 + noise
packets = base_data[:, 1] / 50 + rng.normal(scale=0.5, size=len(base_data))
errors = base_data[:, 0] / 10 + rng.normal(scale=0.5, size=len(base_data))
data_4d = np.column_stack([base_data[:, 0], base_data[:, 1], packets, errors])

# Apply PCA to reduce 4D data to 2D
pca = PCA(n_components=2)
data_2d = pca.fit_transform(data_4d)
print("Explained variance ratio of 2 components:", pca.explained_variance_ratio_)
print("Original shape:", data_4d.shape, "Reduced shape:", data_2d.shape)
# We can examine a few transformed points
print("First 5 data points in PCA space:\n", data_2d[:5])
```
Тут ми взяли раніше нормальні кластери трафіку і розширили кожну точку даних двома додатковими ознаками (пакети та помилки), які корелюють з байтами та тривалістю. Потім використовується PCA для стиснення 4 ознак в 2 основні компоненти. Ми виводимо відношення поясненої дисперсії, яке може показати, що, скажімо, >95% дисперсії захоплено 2 компонентами (що означає невелику втрату інформації). Вихід також показує, що форма даних зменшується з (1500, 4) до (1500, 2). Перші кілька точок у просторі PCA наведені як приклад. На практиці можна побудувати графік data_2d, щоб візуально перевірити, чи кластери відрізняються. Якщо аномалія була присутня, її можна було б побачити як точку, що лежить далеко від основного кластера в просторі PCA. Таким чином, PCA допомагає дистилювати складні дані в керовану форму для людської інтерпретації або як вхід для інших алгоритмів.

</details>


### Gaussian Mixture Models (GMM)

Модель змішування Гауссів припускає, що дані генеруються з суміші **кількох Гауссових (нормальних) розподілів з невідомими параметрами**. По суті, це ймовірнісна модель кластеризації: вона намагається м'яко призначити кожну точку одному з K Гауссових компонентів. Кожна Гауссова компонента k має вектор середнього (μ_k), матрицю коваріації (Σ_k) та вагу змішування (π_k), яка представляє, наскільки поширений цей кластер. На відміну від K-Means, який робить "жорсткі" призначення, GMM надає кожній точці ймовірність належності до кожного кластера.

Підгонка GMM зазвичай виконується за допомогою алгоритму очікування-максимізації (EM):

- **Ініціалізація**: Почати з початкових припущень для середніх, коваріацій та коефіцієнтів змішування (або використовувати результати K-Means як початкову точку).

- **E-крок (Очікування)**: З урахуванням поточних параметрів обчислити відповідальність кожного кластера для кожної точки: по суті `r_nk = P(z_k | x_n)`, де z_k є латентною змінною, що вказує на належність до кластера для точки x_n. Це робиться за допомогою теореми Байєса, де ми обчислюємо апостеріорну ймовірність кожної точки належати до кожного кластера на основі поточних параметрів. Відповідальності обчислюються як:
```math
r_{nk} = \frac{\pi_k \mathcal{N}(x_n | \mu_k, \Sigma_k)}{\sum_{j=1}^{K} \pi_j \mathcal{N}(x_n | \mu_j, \Sigma_j)}
```
де:
- \( \pi_k \) є коефіцієнтом змішування для кластера k (попередня ймовірність кластера k),
- \( \mathcal{N}(x_n | \mu_k, \Sigma_k) \) є функцією ймовірності Гаусса для точки \( x_n \) з урахуванням середнього \( \mu_k \) та коваріації \( \Sigma_k \).

- **M-крок (Максимізація)**: Оновити параметри, використовуючи відповідальності, обчислені в E-кроці:
- Оновити кожне середнє μ_k як зважене середнє точок, де ваги є відповідальностями.
- Оновити кожну коваріацію Σ_k як зважену коваріацію точок, призначених кластеру k.
- Оновити коефіцієнти змішування π_k як середню відповідальність для кластера k.

- **Ітерація** E та M кроків до збіжності (параметри стабілізуються або поліпшення ймовірності нижче порогу).

Результатом є набір Гауссових розподілів, які колективно моделюють загальний розподіл даних. Ми можемо використовувати підганяний GMM для кластеризації, призначаючи кожну точку Гауссу з найвищою ймовірністю, або зберігати ймовірності для невизначеності. Також можна оцінити ймовірність нових точок, щоб перевірити, чи підходять вони до моделі (корисно для виявлення аномалій).

> [!TIP]
> *Випадки використання в кібербезпеці:* GMM можна використовувати для виявлення аномалій, моделюючи розподіл нормальних даних: будь-яка точка з дуже низькою ймовірністю під навченою сумішшю позначається як аномалія. Наприклад, ви могли б навчити GMM на легітимних ознаках мережевого трафіку; атакуюче з'єднання, яке не нагадує жоден з навчених кластерів, матиме низьку ймовірність. GMM також використовуються для кластеризації активностей, де кластери можуть мати різні форми – наприклад, групування користувачів за профілями поведінки, де ознаки кожного профілю можуть бути подібні до Гауссових, але з власною структурою дисперсії. Інший сценарій: у виявленні фішингу легітимні ознаки електронної пошти можуть формувати один Гауссовий кластер, відомий фішинг – інший, а нові кампанії фішингу можуть з'являтися як окремий Гаусс або як точки з низькою ймовірністю відносно існуючої суміші.

#### Припущення та обмеження

GMM є узагальненням K-Means, яке включає коваріацію, тому кластери можуть бути еліпсоїдними (не лише сферичними). Воно обробляє кластери різних розмірів і форм, якщо коваріація повна. М'яка кластеризація є перевагою, коли межі кластерів є нечіткими – наприклад, у кібербезпеці подія може мати риси кількох типів атак; GMM може відобразити цю невизначеність з ймовірностями. GMM також надає ймовірнісну оцінку щільності даних, корисну для виявлення викидів (точок з низькою ймовірністю під усіма компонентами суміші).

З іншого боку, GMM вимагає вказати кількість компонентів K (хоча можна використовувати критерії, такі як BIC/AIC для вибору). EM іноді може повільно сходитися або до локального оптимуму, тому ініціалізація є важливою (часто EM запускається кілька разів). Якщо дані насправді не слідують змішуванню Гауссів, модель може бути поганою. Існує також ризик, що один Гаусс зменшиться, щоб покрити лише викид (хоча регуляризація або мінімальні межі коваріації можуть це пом'якшити).


<details>
<summary>Приклад --  М'яка кластеризація та оцінки аномалій
</summary>
```python
from sklearn.mixture import GaussianMixture

# Fit a GMM with 3 components to the normal traffic data
gmm = GaussianMixture(n_components=3, covariance_type='full', random_state=0)
gmm.fit(base_data)  # using the 1500 normal data points from PCA example

# Print the learned Gaussian parameters
print("GMM means:\n", gmm.means_)
print("GMM covariance matrices:\n", gmm.covariances_)

# Take a sample attack-like point and evaluate it
sample_attack = np.array([[200, 800]])  # an outlier similar to earlier attack cluster
probs = gmm.predict_proba(sample_attack)
log_likelihood = gmm.score_samples(sample_attack)
print("Cluster membership probabilities for sample attack:", probs)
print("Log-likelihood of sample attack under GMM:", log_likelihood)
```
У цьому коді ми навчаємо GMM з 3 гауссіанами на нормальному трафіку (припускаючи, що ми знаємо 3 профілі легітимного трафіку). Середні значення та коваріації, які виводяться, описують ці кластери (наприклад, одне середнє може бути близько [50,500], що відповідає центру одного кластера тощо). Потім ми тестуємо підозріле з'єднання [duration=200, bytes=800]. Функція predict_proba дає ймовірність того, що ця точка належить до кожного з 3 кластерів – ми очікуємо, що ці ймовірності будуть дуже низькими або сильно перекошеними, оскільки [200,800] знаходиться далеко від нормальних кластерів. Загальний score_samples (лог-правдоподібність) виводиться; дуже низьке значення вказує на те, що точка не підходить моделі, позначаючи її як аномалію. На практиці можна встановити поріг на лог-правдоподібність (або на максимальну ймовірність), щоб вирішити, чи є точка достатньо малоймовірною, щоб вважати її шкідливою. Таким чином, GMM забезпечує принциповий спосіб виявлення аномалій і також дає м'які кластери, які визнають невизначеність.

### Isolation Forest

**Isolation Forest** – це ансамблевий алгоритм виявлення аномалій, заснований на ідеї випадкового ізолювання точок. Принцип полягає в тому, що аномалій мало і вони відрізняються, тому їх легше ізолювати, ніж нормальні точки. Isolation Forest будує багато бінарних дерев ізоляції (випадкових дерев рішень), які випадковим чином розподіляють дані. На кожному вузлі дерева вибирається випадкова ознака, і вибирається випадкове значення розподілу між мінімумом і максимумом цієї ознаки для даних у цьому вузлі. Це розділення ділить дані на дві гілки. Дерево росте, поки кожна точка не буде ізольована у своєму власному листі або не буде досягнута максимальна висота дерева.

Виявлення аномалій виконується шляхом спостереження за довжиною шляху кожної точки в цих випадкових деревах – кількість розділень, необхідних для ізоляції точки. Інтуїтивно, аномалії (викиди) зазвичай ізолюються швидше, оскільки випадкове розділення з більшою ймовірністю відокремить викид (який знаходиться в рідкісному регіоні), ніж нормальну точку в щільному кластері. Isolation Forest обчислює бал аномалії на основі середньої довжини шляху по всіх деревах: коротший середній шлях → більш аномальний. Бали зазвичай нормалізуються до [0,1], де 1 означає дуже ймовірну аномалію.

> [!TIP]
> *Випадки використання в кібербезпеці:* Isolation Forests успішно використовувалися в системах виявлення вторгнень та виявлення шахрайства. Наприклад, навчіть Isolation Forest на журналах мережевого трафіку, які в основному містять нормальну поведінку; ліс створить короткі шляхи для дивного трафіку (як-от IP, що використовує невідомий порт або незвичний шаблон розміру пакета), позначаючи його для перевірки. Оскільки він не вимагає мічених атак, він підходить для виявлення невідомих типів атак. Його також можна використовувати на даних входу користувачів для виявлення захоплень облікових записів (аномальні часи або місця входу швидко ізолюються). У одному випадку використання Isolation Forest може захистити підприємство, моніторячи системні метрики та генеруючи сповіщення, коли комбінація метрик (ЦП, мережа, зміни файлів) виглядає дуже відмінно (короткі шляхи ізоляції) від історичних шаблонів.

#### Припущення та обмеження

**Переваги**: Isolation Forest не вимагає припущення про розподіл; він безпосередньо націлений на ізоляцію. Він ефективний для даних з високою розмірністю та великих наборів даних (лінійна складність $O(n\log n)$ для побудови лісу), оскільки кожне дерево ізолює точки лише з підмножини ознак і розділень. Він зазвичай добре обробляє числові ознаки і може бути швидшим за методи, засновані на відстані, які можуть мати $O(n^2)$. Він також автоматично надає бал аномалії, тому ви можете встановити поріг для сповіщень (або використовувати параметр забруднення, щоб автоматично вирішити поріг на основі очікуваної частки аномалій).

**Обмеження**: Через свою випадкову природу результати можуть трохи варіюватися між запусками (хоча з достатньою кількістю дерев це незначно). Якщо дані мають багато нерелевантних ознак або якщо аномалії не сильно відрізняються в жодній ознаці, ізоляція може бути неефективною (випадкові розділення можуть ізолювати нормальні точки випадково – однак усереднення багатьох дерев зменшує це). Крім того, Isolation Forest зазвичай припускає, що аномалії є невеликою меншістю (що зазвичай вірно в сценаріях кібербезпеки).

<details>
<summary>Приклад -- Виявлення викидів у мережевих журналах
</summary>

Ми використаємо раніше тестовий набір даних (який містить нормальні та деякі точки атак) і запустимо Isolation Forest, щоб перевірити, чи може він відокремити атаки. Ми припустимо, що очікуємо ~15% даних бути аномальними (для демонстрації).
```python
from sklearn.ensemble import IsolationForest

# Combine normal and attack test data from autoencoder example
X_test_if = test_data  # (120 x 2 array with 100 normal and 20 attack points)
# Train Isolation Forest (unsupervised) on the test set itself for demo (in practice train on known normal)
iso_forest = IsolationForest(n_estimators=100, contamination=0.15, random_state=0)
iso_forest.fit(X_test_if)
# Predict anomalies (-1 for anomaly, 1 for normal)
preds = iso_forest.predict(X_test_if)
anomaly_scores = iso_forest.decision_function(X_test_if)  # the higher, the more normal
print("Isolation Forest predicted labels (first 20):", preds[:20])
print("Number of anomalies detected:", np.sum(preds == -1))
print("Example anomaly scores (lower means more anomalous):", anomaly_scores[:5])
```
У цьому коді ми створюємо `IsolationForest` з 100 деревами та встановлюємо `contamination=0.15` (що означає, що ми очікуємо близько 15% аномалій; модель встановить свій поріг оцінки так, щоб ~15% точок були позначені). Ми навчаємо його на `X_test_if`, який містить суміш нормальних і атакуючих точок (зауважте: зазвичай ви б навчали на навчальних даних, а потім використовували б прогноз на нових даних, але тут для ілюстрації ми навчаємо і прогнозуємо на одному й тому ж наборі, щоб безпосередньо спостерігати результати).

Вихідні дані показують прогнозовані мітки для перших 20 точок (де -1 вказує на аномалію). Ми також друкуємо, скільки аномалій було виявлено в цілому, і деякі приклади оцінок аномалій. Ми очікуємо, що приблизно 18 з 120 точок будуть позначені -1 (оскільки забрудненість становила 15%). Якщо наші 20 атакуючих зразків дійсно є найбільш віддаленими, більшість з них повинні з'явитися в цих прогнозах -1. Оцінка аномалії (функція рішення Isolation Forest) є вищою для нормальних точок і нижчою (більш негативною) для аномалій – ми друкуємо кілька значень, щоб побачити розділення. На практиці можна відсортувати дані за оцінкою, щоб побачити найвищі аномалії та дослідити їх. Isolation Forest таким чином забезпечує ефективний спосіб перегляду великих не маркованих даних безпеки та виділення найбільш нерегулярних випадків для людського аналізу або подальшого автоматизованого розгляду.

### t-SNE (t-Розподілена Стохастична Вбудована Сусідність)

**t-SNE** є нелінійною технікою зменшення розмірності, спеціально розробленою для візуалізації високорозмірних даних у 2 або 3 вимірах. Вона перетворює подібності між точками даних у спільні ймовірнісні розподіли та намагається зберегти структуру локальних сусідств у проекції з нижчою розмірністю. Простими словами, t-SNE розміщує точки в (скажімо) 2D так, що подібні точки (в оригінальному просторі) виявляються близько одна до одної, а неподібні точки виявляються далеко одна від одної з високою ймовірністю.

Алгоритм має два основні етапи:

1. **Обчислення парних афінностей у високорозмірному просторі:** Для кожної пари точок t-SNE обчислює ймовірність того, що одна з точок буде обрана сусідом (це робиться шляхом центрування гауссового розподілу на кожній точці та вимірювання відстаней – параметр перплексії впливає на ефективну кількість сусідів, які розглядаються).
2. **Обчислення парних афінностей у низькорозмірному (наприклад, 2D) просторі:** Спочатку точки розміщуються випадковим чином у 2D. t-SNE визначає подібну ймовірність для відстаней у цій карті (використовуючи ядро розподілу Стюдента, яке має важчі хвости, ніж гауссовий, щоб дозволити віддаленим точкам більше свободи).
3. **Градієнтний спуск:** t-SNE потім ітеративно переміщує точки в 2D, щоб мінімізувати дивергенцію Кульбака-Лейблера (KL) між високорозмірним розподілом афінностей і низькорозмірним. Це призводить до того, що 2D розташування відображає високорозмірну структуру якомога більше – точки, які були близько в оригінальному просторі, будуть притягувати одна одну, а ті, що далеко, будуть відштовхуватися, поки не буде знайдено баланс.

Результат часто є візуально значущим розсіяним графіком, де кластери в даних стають очевидними.

> [!TIP]
> *Випадки використання в кібербезпеці:* t-SNE часто використовується для **візуалізації високорозмірних даних безпеки для людського аналізу**. Наприклад, у центрі операцій безпеки аналітики можуть взяти набір даних подій з десятками ознак (номери портів, частоти, кількість байтів тощо) і використовувати t-SNE для створення 2D графіка. Атаки можуть формувати свої власні кластери або відокремлюватися від нормальних даних на цьому графіку, що полегшує їх ідентифікацію. Це було застосовано до наборів даних шкідливого ПЗ, щоб побачити групування сімей шкідливого ПЗ або до даних про мережеві вторгнення, де різні типи атак чітко кластеризуються, що сприяє подальшому розслідуванню. По суті, t-SNE забезпечує спосіб побачити структуру в кіберданих, яка інакше була б незрозумілою.

#### Припущення та обмеження

t-SNE чудово підходить для візуального виявлення патернів. Він може виявити кластери, підкластери та аномалії, які інші лінійні методи (такі як PCA) можуть не виявити. Його використовували в дослідженнях кібербезпеки для візуалізації складних даних, таких як профілі поведінки шкідливого ПЗ або патерни мережевого трафіку. Оскільки він зберігає локальну структуру, він добре показує природні групування.

Однак t-SNE є обчислювально важчим (приблизно $O(n^2)$), тому може вимагати вибірки для дуже великих наборів даних. Він також має гіперпараметри (перплексія, швидкість навчання, ітерації), які можуть впливати на вихід – наприклад, різні значення перплексії можуть виявити кластери на різних масштабах. Графіки t-SNE іноді можуть бути неправильно інтерпретовані – відстані на карті не є безпосередньо значущими глобально (він зосереджується на локальному сусідстві, іноді кластери можуть з'являтися штучно добре відокремленими). Також t-SNE в основному призначений для візуалізації; він не забезпечує простий спосіб проекції нових точок даних без повторного обчислення, і його не слід використовувати як попередню обробку для прогнозного моделювання (UMAP є альтернативою, яка вирішує деякі з цих проблем з більшою швидкістю).

<details>
<summary>Приклад -- Візуалізація мережевих з'єднань
</summary>

Ми використаємо t-SNE, щоб зменшити багатофункціональний набір даних до 2D. Для ілюстрації давайте візьмемо раніше 4D дані (які мали 3 природні кластери нормального трафіку) і додамо кілька аномальних точок. Потім ми запустимо t-SNE і (концептуально) візуалізуємо результати.
```python
# 1 ─────────────────────────────────────────────────────────────────────
#    Create synthetic 4-D dataset
#      • Three clusters of “normal” traffic (duration, bytes)
#      • Two correlated features: packets & errors
#      • Five outlier points to simulate suspicious traffic
# ──────────────────────────────────────────────────────────────────────
import numpy as np
import matplotlib.pyplot as plt
from sklearn.manifold import TSNE
from sklearn.preprocessing import StandardScaler

rng = np.random.RandomState(42)

# Base (duration, bytes) clusters
normal1 = rng.normal(loc=[50, 500],  scale=[10, 100], size=(500, 2))
normal2 = rng.normal(loc=[60, 1500], scale=[8,  200], size=(500, 2))
normal3 = rng.normal(loc=[70, 3000], scale=[5,  300], size=(500, 2))

base_data = np.vstack([normal1, normal2, normal3])       # (1500, 2)

# Correlated features
packets = base_data[:, 1] / 50 + rng.normal(scale=0.5, size=len(base_data))
errors  = base_data[:, 0] / 10 + rng.normal(scale=0.5, size=len(base_data))

data_4d = np.column_stack([base_data, packets, errors])  # (1500, 4)

# Outlier / attack points
outliers_4d = np.column_stack([
rng.normal(250, 1, size=5),     # extreme duration
rng.normal(1000, 1, size=5),    # moderate bytes
rng.normal(5, 1, size=5),       # very low packets
rng.normal(25, 1, size=5)       # high errors
])

data_viz = np.vstack([data_4d, outliers_4d])             # (1505, 4)

# 2 ─────────────────────────────────────────────────────────────────────
#    Standardize features (recommended for t-SNE)
# ──────────────────────────────────────────────────────────────────────
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data_viz)

# 3 ─────────────────────────────────────────────────────────────────────
#    Run t-SNE to project 4-D → 2-D
# ──────────────────────────────────────────────────────────────────────
tsne = TSNE(
n_components=2,
perplexity=30,
learning_rate='auto',
init='pca',
random_state=0
)
data_2d = tsne.fit_transform(data_scaled)
print("t-SNE output shape:", data_2d.shape)  # (1505, 2)

# 4 ─────────────────────────────────────────────────────────────────────
#    Visualize: normal traffic vs. outliers
# ──────────────────────────────────────────────────────────────────────
plt.figure(figsize=(8, 6))
plt.scatter(
data_2d[:-5, 0], data_2d[:-5, 1],
label="Normal traffic",
alpha=0.6,
s=10
)
plt.scatter(
data_2d[-5:, 0], data_2d[-5:, 1],
label="Outliers / attacks",
alpha=0.9,
s=40,
marker="X",
edgecolor='k'
)

plt.title("t-SNE Projection of Synthetic Network Traffic")
plt.xlabel("t-SNE component 1")
plt.ylabel("t-SNE component 2")
plt.legend()
plt.tight_layout()
plt.show()
```
Тут ми об'єднали наш попередній 4D нормальний набір даних з кількома екстремальними викидами (викиди мають одну ознаку (“тривалість”), встановлену дуже високо тощо, щоб змоделювати дивний шаблон). Ми запускаємо t-SNE з типовою заплутаністю 30. Вихідні дані data_2d мають форму (1505, 2). Ми насправді не будемо малювати в цьому тексті, але якби ми це зробили, ми б очікували побачити, можливо, три щільні кластери, що відповідають 3 нормальним кластерам, а 5 викидів з'являються як ізольовані точки далеко від цих кластерів. У інтерактивному робочому процесі ми могли б пофарбувати точки за їхніми мітками (нормальні або який кластер, проти аномалії), щоб перевірити цю структуру. Навіть без міток аналітик може помітити ці 5 точок, що сидять у порожньому просторі на 2D графіку, і позначити їх. Це показує, як t-SNE може бути потужним допоміжним засобом для візуального виявлення аномалій та перевірки кластерів у даних кібербезпеки, доповнюючи автоматизовані алгоритми вище.

</details>


{{#include ../banners/hacktricks-training.md}}
