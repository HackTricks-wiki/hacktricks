# 常见的恶意软件使用的API

{{#include ../banners/hacktricks-training.md}}

## 通用

### 网络

| 原始套接字   | WinAPI 套接字 |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### 持久性

| 注册表         | 文件          | 服务                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### 加密

| 名称                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### 反分析/虚拟机

| 函数名称                                             | 汇编指令             |
| --------------------------------------------------- | --------------------- |
| IsDebuggerPresent()                                   | CPUID()               |
| GetSystemInfo()                                      | IN()                  |
| GlobalMemoryStatusEx()                                |                       |
| GetVersion()                                          |                       |
| CreateToolhelp32Snapshot \[检查进程是否在运行\]     |                       |
| CreateFileW/A \[检查文件是否存在\]                  |                       |

### 隐匿

| 名称                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | 分配内存 (打包器)                                                         |
| VirtualProtect           | 更改内存权限 (打包器给予某个部分执行权限)                                 |
| ReadProcessMemory        | 注入到外部进程                                                          |
| WriteProcessMemoryA/W    | 注入到外部进程                                                          |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/进程注入...                                                          |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### 执行

| 函数名称    |
| ------------ |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### 其他

- GetAsyncKeyState() -- 键盘记录
- SetWindowsHookEx -- 键盘记录
- GetForeGroundWindow -- 获取正在运行的窗口名称（或浏览器中的网站）
- LoadLibrary() -- 导入库
- GetProcAddress() -- 导入库
- CreateToolhelp32Snapshot() -- 列出正在运行的进程
- GetDC() -- 截图
- BitBlt() -- 截图
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- 访问互联网
- FindResource(), LoadResource(), LockResource() -- 访问可执行文件的资源

## 恶意软件技术

### DLL 注入

在另一个进程中执行任意 DLL

1. 定位要注入恶意 DLL 的进程：CreateToolhelp32Snapshot, Process32First, Process32Next
2. 打开进程：GetModuleHandle, GetProcAddress, OpenProcess
3. 在进程中写入 DLL 的路径：VirtualAllocEx, WriteProcessMemory
4. 在进程中创建一个线程以加载恶意 DLL：CreateRemoteThread, LoadLibrary

其他可用的函数：NTCreateThreadEx, RtlCreateUserThread

### 反射 DLL 注入

在不调用正常 Windows API 调用的情况下加载恶意 DLL。\
DLL 在进程中映射，它将解析导入地址，修复重定位并调用 DllMain 函数。

### 线程劫持

从进程中找到一个线程并使其加载恶意 DLL

1. 找到目标线程：CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. 打开线程：OpenThread
3. 暂停线程：SuspendThread
4. 在受害者进程中写入恶意 DLL 的路径：VirtualAllocEx, WriteProcessMemory
5. 恢复线程以加载库：ResumeThread

### PE 注入

可移植执行注入：可执行文件将被写入受害者进程的内存中，并从那里执行。

### 进程空洞化 (又名 **RunPE**)

`Process Hollowing` 是 Windows 恶意软件常用的 **防御规避/执行** 技巧之一。其思想是在 **挂起** 状态下启动一个 *合法* 进程，移除（空洞）其原始映像并在其位置复制一个 **任意 PE**。当主线程最终恢复时，恶意入口点在受信任的二进制文件的伪装下执行（通常由 Microsoft 签名）。

典型工作流程：

1. 生成一个 benign host（例如 `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`） **挂起**，以便尚未运行任何指令。
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. 将恶意有效载荷读入内存并解析其 PE 头以获取 `SizeOfImage`、节和新的 `EntryPoint`。
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – 取消映射挂起进程的原始映像基址。
4. **VirtualAllocEx** – 在远程进程中保留 RWX 内存的 `SizeOfImage`。
5. **WriteProcessMemory** – 首先复制 `Headers`，然后遍历节复制其原始数据。
6. **SetThreadContext** – 在上下文结构中修补 `EAX/RAX`（在 x64 中为 `RCX`）或 `Rip` 的值，以便 `EIP` 指向有效载荷的 `EntryPoint`。
7. **ResumeThread** – 线程继续执行攻击者提供的代码。

最小的概念验证 (x86) 骨架：
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
在**DarkCloud Stealer**活动中观察到的实用笔记：

* 加载器选择了`RegAsm.exe`（.NET Framework的一部分）作为宿主——一个不太可能引起注意的签名二进制文件。
* 解密的VB6窃取器（`holographies.exe`）*不*会被写入磁盘；它仅存在于被挖空的进程中，使静态检测变得更加困难。
* 敏感字符串（正则表达式、路径、Telegram凭证）是**RC4加密**的，每个字符串在运行时才解密，进一步复杂化了内存扫描。

检测思路：
* 对于在分配内存区域为**RWX**（良性代码中罕见）之前从未创建GUI/控制台窗口的`CREATE_SUSPENDED`进程发出警报。
* 在不同进程中查找调用序列`NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory`。

## Hooking

- **SSDT**（**系统服务描述符表**）指向内核函数（ntoskrnl.exe）或GUI驱动程序（win32k.sys），以便用户进程可以调用这些函数。
- Rootkit可能会修改这些指针，使其指向他控制的地址。
- **IRP**（**I/O请求数据包**）在组件之间传输数据。内核中的几乎所有内容都使用IRP，每个设备对象都有自己的函数表，可以被hook：DKOM（直接内核对象操作）。
- **IAT**（**导入地址表**）用于解析依赖关系。可以hook此表以劫持将被调用的代码。
- **EAT**（**导出地址表**）Hook。这种hook可以在**用户态**中完成。目标是hook DLL导出的函数。
- **内联Hook**：这种类型的hook难以实现。这涉及到修改函数本身的代码。可能通过在函数开头放置一个跳转来实现。

## 参考

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)

{{#include ../banners/hacktricks-training.md}}
