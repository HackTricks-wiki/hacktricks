# 恶意软件中常用的 API

{{#include ../banners/hacktricks-training.md}}

## 通用

### 网络

| 原始 Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### TLS pinning and chunked transport

许多 loader 会将它们的 TCP 流封装在 `SslStream` 中，并将服务器的 leaf certificate 与嵌入的副本进行对比（certificate pinning）。Bot 信息/任务会被压缩（例如 GZip）。当响应超过阈值（约 ~1 MB）时，数据会被拆分成小块（例如 16 KB 段），以避免基于大小的检测并减少反序列化期间的内存峰值。


### 持久化

| 注册表         | 文件          | 服务                         |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### 加密

| 名称                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### 反分析/虚拟机检测

| 函数名                                             | 汇编指令 |
| ------------------------------------------------- | -------- |
| IsDebuggerPresent()                                | CPUID()  |
| GetSystemInfo()                                    | IN()     |
| GlobalMemoryStatusEx()                             |          |
| GetVersion()                                       |          |
| CreateToolhelp32Snapshot \[检查进程是否在运行]     |          |
| CreateFileW/A \[检查文件是否存在]                  |          |

### 基于区域/键盘的执行守卫

许多 stealer/loader 会在特定的区域设置上中止以规避研究人员并满足威胁行为体的约束。典型检查包括：
- `GetKeyboardLayout` 用于枚举已安装的布局（按线程/用户）
- `GetLocaleInfoA/W` 用于解析国家/地区代码
- `GetSystemDefaultLangID` / `GetUserDefaultLangID`

如果任一匹配到被阻止的列表（通常为 CIS 国家），loader 会在进行任何网络 IOCs 或注入之前立即退出。

防御/威胁狩猎
- 标记那些在执行早期调用多个区域/键盘 API 然后无任何可观察活动就退出的进程。
- 将其与重用自开源项目（例如 VMDetector）的反 VM 检查（BIOS 字符串、PnP 设备、磁盘型号、服务）相关联，以捕获有门控执行的样本。

### 模拟器 API 指纹识别与睡眠规避

恶意软件常通过搜索 Defender 的虚拟化导出（见 Malware Protection Emulator）来指纹化沙箱模拟器。如果在进程中存在这些符号（对进程进行不区分大小写的扫描），则执行会延迟 10–30 分钟并重新检查，以消耗分析时间。

作为哨兵使用的 API 名称示例：
- `MpVmp32Entry`, `MpVmp32FastEnter`, `MpCallPreEntryPointCode`, `MpCallPostEntryPointCode`, `MpFinalize`, `MpReportEvent*`, `MpSwitchToNextThread*`
- `VFS_*` 系列: `VFS_Open`, `VFS_Read`, `VFS_MapViewOfFile`, `VFS_UnmapViewOfFile`, `VFS_FindFirstFile/FindNextFile`, `VFS_CopyFile`, `VFS_DeleteFile`, `VFS_MoveFile`
- `ThrdMgr_*`: `ThrdMgr_GetCurrentThreadHandle`, `ThrdMgr_SaveTEB`, `ThrdMgr_SwitchThreads`

典型的延迟原语（用户态）：
```cmd
cmd /c timeout /t %RANDOM_IN_[600,1800]% > nul
```
参数门控
- 操作者有时要求在运行 payload 之前存在一个看起来无害的 CLI 开关（例如 `/i:--type=renderer` 来模拟 Chromium child processes）。如果该开关不存在，loader 会立即退出，阻止简单的 sandbox 执行。


### 隐蔽

| 名称                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | 分配内存（packers）                                                       |
| VirtualProtect           | 更改内存权限（packer 为某节赋予执行权限）                                 |
| ReadProcessMemory        | 注入到外部进程                                                            |
| WriteProcessMemoryA/W    | 注入到外部进程                                                            |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/进程注入...                                                            |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### 执行

| 函数名    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### 杂项

- GetAsyncKeyState() -- 按键记录
- SetWindowsHookEx -- 按键记录
- GetForeGroundWindow -- 获取运行窗口名称（或从浏览器获取的网站）
- LoadLibrary() -- 加载库
- GetProcAddress() -- 获取函数地址
- CreateToolhelp32Snapshot() -- 列出正在运行的进程
- GetDC() -- 截图
- BitBlt() -- 截图
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- 访问互联网
- FindResource(), LoadResource(), LockResource() -- 访问可执行文件的资源

## 恶意软件技术

### DLL Injection

Execute an arbitrary DLL inside another process

1. 定位要注入恶意 DLL 的进程: CreateToolhelp32Snapshot, Process32First, Process32Next
2. 打开进程: GetModuleHandle, GetProcAddress, OpenProcess
3. 将 DLL 路径写入目标进程: VirtualAllocEx, WriteProcessMemory
4. 在进程中创建一个线程以加载恶意 DLL: CreateRemoteThread, LoadLibrary

其他可用函数: NTCreateThreadEx, RtlCreateUserThread

### Reflective DLL Injection

Load a malicious DLL without calling normal Windows API calls.\
DLL 会被映射到进程内，解析导入地址，修复重定位并调用 DllMain 函数。

### Thread Hijacking

Find a thread from a process and make it load a malicious DLL

1. 查找目标线程: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. 打开线程: OpenThread
3. 挂起线程: SuspendThread
4. 将恶意 DLL 的路径写入受害进程: VirtualAllocEx, WriteProcessMemory
5. 恢复线程以加载库: ResumeThread

### PE Injection

Portable Execution Injection: 可执行文件将被写入受害进程的内存并从那里执行。

### Process Hollowing (a.k.a **RunPE**)

`Process Hollowing` 是 Windows 恶意软件常用的 **defence-evasion / execution** 技巧之一。其思路是以 **suspended** 状态启动一个*合法*进程，从内存中移除（hollow）其原始映像，并将一个任意的 PE 复制到其位置。当主线程最终被恢复时，恶意入口点便在受信任二进制（通常由 Microsoft 签名）的伪装下执行。

典型工作流程：

1. 启动一个良性宿主（例如 `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`）并以 **suspended** 状态运行，以便尚未执行任何指令。
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. 将恶意载荷读入内存并解析其 PE 头以获取 `SizeOfImage`、节和新的 `EntryPoint`。
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – 取消映射挂起进程的原始映像基址。
4. **VirtualAllocEx** – 在远程进程中为 `SizeOfImage` 保留 RWX 内存。
5. **WriteProcessMemory** – 先复制 `Headers`，然后遍历各节并复制其原始数据。
6. **SetThreadContext** – 修补上下文结构中的 EAX/RAX（x64 上为 RCX）或 Rip 的值，使 `EIP` 指向载荷的 `EntryPoint`。
7. **ResumeThread** – 线程继续执行，运行攻击者提供的代码。

Minimal proof-of-concept (x86) skeleton:
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
Practical notes observed in the **DarkCloud Stealer** campaign:

* 加载器选择了 `RegAsm.exe`（.NET Framework 的一部分）作为宿主——这是个签名二进制，较不易引起注意。
* 解密后的 VB6 stealer（`holographies.exe`）不会落盘；它仅存在于被 hollowed 的进程内，这让静态检测更困难。
* 敏感字符串（regexes、paths、Telegram credentials）逐条使用 **RC4-encrypted** 加密，并且仅在运行时解密，进一步增加了内存扫描的难度。

Detection ideas:
* 对那些使用 `CREATE_SUSPENDED` 创建、在分配为 **RWX** 的内存区域之前从未创建 GUI/console 窗口的进程发出告警（对良性代码而言很少见）。
* 在不同进程间寻找调用序列 `NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory`。
* 注意受信任的开发者工具被异常用作 hollowing 宿主，尤其是 `MSBuild.exe`、`RegAsm.exe`、`rundll32.exe`，且其父进程为短命的 loader。
* 追查从用户可写路径启动的 `msbuild.exe` 或没有相应 `.sln/.proj` 上下文却发起外部连接的实例（ATT&CK T1127.001 + T1055.012）。

Common host processes and path resolution
- `MSBuild.exe` 经常被选作 hollowing 宿主以混入开发者工具链。Loaders 通常会搜索与架构相匹配的位置：
- `C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe`
- `C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe`
- `C:\Windows\System32\MSBuild.exe`
- `C:\Windows\SysWOW64\MSBuild.exe`
- 在调用 `CreateProcess(..., CREATE_SUSPENDED, ...)` 之前选择与当前 payload/OS 架构相匹配的宿主。


## Hooking

- **SSDT**（**System Service Descriptor Table**）指向内核函数（ntoskrnl.exe）或 GUI 驱动（win32k.sys），以便用户进程可以调用这些函数。
- rootkit 可能修改这些指针到其控制的地址。
- **IRP**（**I/O Request Packets**）在组件间传递数据。内核中的几乎所有东西都使用 IRP，每个 device object 有自己的函数表，可以被 hook：DKOM（Direct Kernel Object Manipulation）。
- **IAT**（**Import Address Table**）用于解析依赖项。可以 hook 此表以劫持将被调用的代码。
- **EAT**（**Export Address Table**）Hooks。此类 hook 可以在 **userland** 完成，目标是 hook DLL 导出的函数。
- **Inline Hooks**：此类较难实现，涉及修改函数本体的代码，例如在函数开始处插入跳转。

## References

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)
- [Check Point Research – Under the Pure Curtain: From RAT to Builder to Coder](https://research.checkpoint.com/2025/under-the-pure-curtain-from-rat-to-builder-to-coder/)
- [Unit 42 – PhantomVAI Loader Delivers a Range of Infostealers](https://unit42.paloaltonetworks.com/phantomvai-loader-delivers-infostealers/)
- [MITRE ATT&CK – Trusted Developer Utilities Proxy Execution: MSBuild (T1127.001)](https://attack.mitre.org/techniques/T1127/001/)
- [VMDetector – virtualization checks (open-source)](https://github.com/robsonfelix/VMDetector)

{{#include ../banners/hacktricks-training.md}}
