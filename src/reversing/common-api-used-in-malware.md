# Κοινές API που χρησιμοποιούνται σε Malware

{{#include ../banners/hacktricks-training.md}}

## Γενικά

### Δικτύωση

| Raw Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### TLS pinning and chunked transport

Πολλά loaders τυλίγουν το TCP stream τους σε `SslStream` και κάνουν pin το leaf πιστοποιητικό του server σε ένα ενσωματωμένο αντίγραφο (certificate pinning). Οι πληροφορίες/εργασίες του bot συμπιέζονται (π.χ. GZip). Όταν οι απαντήσεις υπερβαίνουν ένα όριο (~1 MB), τα δεδομένα τεμαχίζονται σε μικρά chunks (π.χ. τμήματα 16 KB) για να αποφευχθούν heuristics βάσει μεγέθους και να μειωθούν οι αιχμές μνήμης κατά την αποσειριοποίηση.

### Persistence

| Registry         | File          | Service                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Κρυπτογράφηση

| Name                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### Anti-Analysis/VM

| Function Name                                             | Assembly Instructions |
| --------------------------------------------------------- | --------------------- |
| IsDebuggerPresent()                                       | CPUID()               |
| GetSystemInfo()                                           | IN()                  |
| GlobalMemoryStatusEx()                                    |                       |
| GetVersion()                                              |                       |
| CreateToolhelp32Snapshot \[Check if a process is running] |                       |
| CreateFileW/A \[Check if a file exist]                    |                       |

### Emulator API fingerprinting & sleep evasion

Malware συχνά fingerprintάρει sandbox emulators αναζητώντας τα virtualised exports του Defender (όπως εμφανίζονται στο Malware Protection Emulator). Εάν οποιοδήποτε από αυτά τα σύμβολα υπάρχει (έλεγχος χωρίς διάκριση πεζών/κεφαλαίων της διεργασίας), η εκτέλεση καθυστερείται για 10–30 λεπτά και ελέγχεται ξανά για να σπαταληθεί χρόνος ανάλυσης.

Examples of API names used as canaries:
- `MpVmp32Entry`, `MpVmp32FastEnter`, `MpCallPreEntryPointCode`, `MpCallPostEntryPointCode`, `MpFinalize`, `MpReportEvent*`, `MpSwitchToNextThread*`
- `VFS_*` family: `VFS_Open`, `VFS_Read`, `VFS_MapViewOfFile`, `VFS_UnmapViewOfFile`, `VFS_FindFirstFile/FindNextFile`, `VFS_CopyFile`, `VFS_DeleteFile`, `VFS_MoveFile`
- `ThrdMgr_*`: `ThrdMgr_GetCurrentThreadHandle`, `ThrdMgr_SaveTEB`, `ThrdMgr_SwitchThreads`

Τυπικό primitive καθυστέρησης (user-land):
```cmd
cmd /c timeout /t %RANDOM_IN_[600,1800]% > nul
```
Argument gatekeeping
- Οι χειριστές μερικές φορές απαιτούν να υπάρχει μια εμφανώς αθώα παράμετρος CLI πριν τρέξει το payload (π.χ., `/i:--type=renderer` για να μιμηθούν Chromium child processes). Αν η παράμετρος δεν υπάρχει, ο loader τερματίζει αμέσως, δυσχεραίνοντας την αφελή εκτέλεση σε sandbox.


### Απόκρυψη

| Όνομα                   |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | Δέσμευση μνήμης (packers)                                                  |
| VirtualProtect           | Αλλαγή δικαιωμάτων μνήμης (packer που δίνει δικαίωμα εκτέλεσης σε ένα section) |
| ReadProcessMemory        | Έγχυση σε εξωτερικές διεργασίες                                             |
| WriteProcessMemoryA/W    | Έγχυση σε εξωτερικές διεργασίες                                             |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/Process injection...                                                   |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### Εκτέλεση

| Function Name    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### Διάφορα

- GetAsyncKeyState() -- Καταγραφή πατημάτων πλήκτρων
- SetWindowsHookEx -- Καταγραφή πατημάτων πλήκτρων
- GetForeGroundWindow -- Λήψη ονόματος ενεργού παραθύρου (ή της ιστοσελίδας από έναν browser)
- LoadLibrary() -- Φόρτωση βιβλιοθήκης
- GetProcAddress() -- Εύρεση διεύθυνσης συνάρτησης
- CreateToolhelp32Snapshot() -- Λίστα τρεχουσών διεργασιών
- GetDC() -- Στιγμιότυπο οθόνης
- BitBlt() -- Στιγμιότυπο οθόνης
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- Πρόσβαση στο διαδίκτυο
- FindResource(), LoadResource(), LockResource() -- Πρόσβαση σε πόρους του εκτελέσιμου

## Malware Techniques

### DLL Injection

Execute an arbitrary DLL inside another process

1. Εντοπίστε τη διεργασία στην οποία θα γίνει το injection του κακόβουλου DLL: CreateToolhelp32Snapshot, Process32First, Process32Next
2. Ανοίξτε τη διεργασία: GetModuleHandle, GetProcAddress, OpenProcess
3. Γράψτε το μονοπάτι προς το DLL μέσα στη διεργασία: VirtualAllocEx, WriteProcessMemory
4. Δημιουργήστε ένα νήμα στη διεργασία που θα φορτώσει το κακόβουλο DLL: CreateRemoteThread, LoadLibrary

Άλλες συναρτήσεις προς χρήση: NTCreateThreadEx, RtlCreateUserThread

### Reflective DLL Injection

Load a malicious DLL without calling normal Windows API calls.\
Το DLL γίνεται map μέσα σε μία διεργασία, θα επιλύσει τις διευθύνσεις εισαγωγής, θα διορθώσει τις relocations και θα καλέσει τη συνάρτηση DllMain.

### Thread Hijacking

Find a thread from a process and make it load a malicious DLL

1. Βρείτε ένα στοχευόμενο νήμα: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. Ανοίξτε το νήμα: OpenThread
3. Αναστείλετε το νήμα: SuspendThread
4. Γράψτε το μονοπάτι προς το κακόβουλο DLL μέσα στη διεργασία-θύμα: VirtualAllocEx, WriteProcessMemory
5. Επαναφέρετε το νήμα ώστε να φορτώσει τη βιβλιοθήκη: ResumeThread

### PE Injection

Portable Execution Injection: Το εκτελέσιμο θα γραφτεί στη μνήμη της διεργασίας-θύματος και θα εκτελεστεί από εκεί.

### Process Hollowing (a.k.a **RunPE**)

`Process Hollowing` is one of the favourite **defence-evasion / execution** tricks used by Windows malware. Η ιδέα είναι να ξεκινήσει μια νόμιμη διεργασία σε κατάσταση **suspended**, να αφαιρεθεί (hollow) η αρχική της εικόνα από τη μνήμη και να αντιγραφεί στη θέση της ένα **arbitrary PE**. Όταν το κύριο νήμα επαναφερθεί, το κακόβουλο entry-point εκτελείται υπό την κάλυψη ενός αξιόπιστου δυαδικού (συχνά υπογεγραμμένου από τη Microsoft).

Τυπική ροή εργασίας:

1. Δημιουργήστε έναν benign host (π.χ. `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`) **suspended** ώστε να μη τρέξουν εντολές ακόμα.
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. Διαβάστε το κακόβουλο payload στη μνήμη και αναλύστε τους PE headers για να βρείτε το `SizeOfImage`, τα sections και το νέο `EntryPoint`.
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – απο-χαρτογραφήστε (unmap) τη βάση εικόνας του suspended process.
4. **VirtualAllocEx** – δεσμεύστε μνήμη RWX του `SizeOfImage` μέσα στη remote process.
5. **WriteProcessMemory** – αντιγράψτε πρώτα τα `Headers`, έπειτα επαναλάβετε πάνω στα sections αντιγράφοντας τα raw δεδομένα τους.
6. **SetThreadContext** – τροποποιήστε την τιμή των `EAX/RAX` (`RCX` σε x64) ή `Rip` στη δομή context ώστε το `EIP` να δείχνει στο `EntryPoint` του payload.
7. **ResumeThread** – το νήμα συνεχίζει, εκτελώντας τον κώδικα που παρέχει ο επιτιθέμενος.

Ελάχιστο proof-of-concept (x86) σκελετός:
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
Πρακτικές παρατηρήσεις από την καμπάνια **DarkCloud Stealer**:

* Ο loader επέλεξε `RegAsm.exe` (μέρος του .NET Framework) ως host – ένα υπογεγραμμένο binary που είναι απίθανο να τραβήξει την προσοχή.
* Ο αποκρυπτογραφημένος VB6 stealer (`holographies.exe`) δεν αποθηκεύεται στο δίσκο· υπάρχει μόνο μέσα στη hollowed process, καθιστώντας τη στατική ανίχνευση πιο δύσκολη.
* Αισθητές συμβολοσειρές (regexes, paths, Telegram credentials) είναι **RC4-encrypted** ανά-συμβολοσειρά και αποκρυπτογραφούνται μόνο κατά το runtime, περιπλέκοντας περαιτέρω το memory scanning.

Ιδέες ανίχνευσης:
* Ειδοποίηση για `CREATE_SUSPENDED` processes που ποτέ δεν δημιουργούν GUI/console windows πριν μια περιοχή μνήμης δεσμευθεί ως **RWX** (σπάνιο για μη κακόβουλο κώδικα).
* Αναζητήστε μια αλληλουχία κλήσεων `NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory` μεταξύ διαφορετικών processes.



## Hooking

- Το **SSDT** (**System Service Descriptor Table**) δείχνει σε kernel functions (ntoskrnl.exe) ή GUI driver (win32k.sys), ώστε οι user processes να μπορούν να καλούν αυτές τις λειτουργίες.
- Ένα rootkit μπορεί να τροποποιήσει αυτούς τους δείκτες προς διευθύνσεις που ελέγχει.
- Τα **IRP** (**I/O Request Packets**) μεταφέρουν κομμάτια δεδομένων από ένα component σε άλλο. Σχεδόν τα πάντα στον kernel χρησιμοποιούν IRPs και κάθε device object έχει τον δικό του πίνακα συναρτήσεων που μπορεί να μπει hook: DKOM (Direct Kernel Object Manipulation)
- Το **IAT** (**Import Address Table**) είναι χρήσιμο για την επίλυση εξαρτήσεων. Είναι δυνατόν να γίνει hook σε αυτόν τον πίνακα για να hijackαριστεί ο κώδικας που θα κληθεί.
- **EAT** (**Export Address Table**) Hooks. Αυτά τα hooks μπορούν να γίνουν από **userland**. Ο στόχος είναι να γίνουν hook οι exported functions από DLLs.
- **Inline Hooks**: Αυτός ο τύπος είναι δύσκολος στην επίτευξη. Περιλαμβάνει την τροποποίηση του ίδιου του κώδικα των συναρτήσεων. Π.χ. με την τοποθέτηση ενός jump στην αρχή τους.


## Αναφορές

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)
- [Check Point Research – Under the Pure Curtain: From RAT to Builder to Coder](https://research.checkpoint.com/2025/under-the-pure-curtain-from-rat-to-builder-to-coder/)

{{#include ../banners/hacktricks-training.md}}
