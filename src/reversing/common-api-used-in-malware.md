# Häufig verwendete API in Malware

{{#include ../banners/hacktricks-training.md}}

## Allgemein

### Netzwerk

| Raw Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### Persistenz

| Registry         | Datei         | Dienst                       |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Verschlüsselung

| Name                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### Anti-Analyse/VM

| Funktionsname                                             | Assemblierungsanweisungen |
| --------------------------------------------------------- | -------------------------- |
| IsDebuggerPresent()                                       | CPUID()                   |
| GetSystemInfo()                                          | IN()                      |
| GlobalMemoryStatusEx()                                   |                            |
| GetVersion()                                             |                            |
| CreateToolhelp32Snapshot \[Überprüfen, ob ein Prozess läuft] |                            |
| CreateFileW/A \[Überprüfen, ob eine Datei existiert]     |                            |

### Tarnung

| Name                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | Speicher zuweisen (Packer)                                               |
| VirtualProtect           | Ändern der Speicherberechtigungen (Packer gibt Ausführungsberechtigungen für einen Abschnitt) |
| ReadProcessMemory        | In externe Prozesse injizieren                                            |
| WriteProcessMemoryA/W    | In externe Prozesse injizieren                                            |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/Prozessinjektion...                                                  |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### Ausführung

| Funktionsname    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### Verschiedenes

- GetAsyncKeyState() -- Tastaturprotokollierung
- SetWindowsHookEx -- Tastaturprotokollierung
- GetForeGroundWindow -- Den Namen des aktiven Fensters abrufen (oder die Website aus einem Browser)
- LoadLibrary() -- Bibliothek importieren
- GetProcAddress() -- Bibliothek importieren
- CreateToolhelp32Snapshot() -- Laufende Prozesse auflisten
- GetDC() -- Screenshot
- BitBlt() -- Screenshot
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- Zugriff auf das Internet
- FindResource(), LoadResource(), LockResource() -- Zugriff auf Ressourcen der ausführbaren Datei

## Malware-Techniken

### DLL-Injektion

Führen Sie eine beliebige DLL in einem anderen Prozess aus

1. Lokalisieren Sie den Prozess, um die bösartige DLL zu injizieren: CreateToolhelp32Snapshot, Process32First, Process32Next
2. Öffnen Sie den Prozess: GetModuleHandle, GetProcAddress, OpenProcess
3. Schreiben Sie den Pfad zur DLL in den Prozess: VirtualAllocEx, WriteProcessMemory
4. Erstellen Sie einen Thread im Prozess, der die bösartige DLL lädt: CreateRemoteThread, LoadLibrary

Andere Funktionen zur Verwendung: NTCreateThreadEx, RtlCreateUserThread

### Reflexive DLL-Injektion

Laden Sie eine bösartige DLL, ohne normale Windows-API-Aufrufe zu tätigen.\
Die DLL wird innerhalb eines Prozesses abgebildet, sie wird die Importadressen auflösen, die Relokationen beheben und die DllMain-Funktion aufrufen.

### Thread-Hijacking

Finden Sie einen Thread aus einem Prozess und lassen Sie ihn eine bösartige DLL laden

1. Finden Sie einen Ziel-Thread: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. Öffnen Sie den Thread: OpenThread
3. Unterbrechen Sie den Thread: SuspendThread
4. Schreiben Sie den Pfad zur bösartigen DLL in den Opferprozess: VirtualAllocEx, WriteProcessMemory
5. Setzen Sie den Thread fort, der die Bibliothek lädt: ResumeThread

### PE-Injektion

Portable Execution Injection: Die ausführbare Datei wird im Speicher des Opferprozesses geschrieben und von dort ausgeführt.

### Prozess-Hollowing

Die Malware wird den legitimen Code aus dem Speicher des Prozesses entfernen und eine bösartige Binärdatei laden

1. Erstellen Sie einen neuen Prozess: CreateProcess
2. Entfernen Sie die Abbildung des Speichers: ZwUnmapViewOfSection, NtUnmapViewOfSection
3. Schreiben Sie die bösartige Binärdatei in den Prozessspeicher: VirtualAllocEc, WriteProcessMemory
4. Setzen Sie den Einstiegspunkt und führen Sie aus: SetThreadContext, ResumeThread

## Hooking

- Die **SSDT** (**System Service Descriptor Table**) verweist auf Kernel-Funktionen (ntoskrnl.exe) oder GUI-Treiber (win32k.sys), sodass Benutzerprozesse diese Funktionen aufrufen können.
- Ein Rootkit kann diese Zeiger auf Adressen ändern, die es kontrolliert.
- **IRP** (**I/O Request Packets**) übertragen Datenstücke von einer Komponente zur anderen. Fast alles im Kernel verwendet IRPs, und jedes Geräteobjekt hat seine eigene Funktionstabelle, die gehookt werden kann: DKOM (Direct Kernel Object Manipulation)
- Die **IAT** (**Import Address Table**) ist nützlich, um Abhängigkeiten aufzulösen. Es ist möglich, diese Tabelle zu hooken, um den Code zu übernehmen, der aufgerufen wird.
- **EAT** (**Export Address Table**) Hooks. Diese Hooks können aus **userland** durchgeführt werden. Das Ziel ist es, exportierte Funktionen von DLLs zu hooken.
- **Inline Hooks**: Diese Art ist schwierig zu erreichen. Dies beinhaltet die Modifikation des Codes der Funktionen selbst. Vielleicht durch das Setzen eines Sprungs am Anfang davon.

{{#include ../banners/hacktricks-training.md}}
