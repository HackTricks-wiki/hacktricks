# Common API used in Malware

{{#include ../banners/hacktricks-training.md}}

## Generic

### Networking

| Raw Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### TLS pinning and chunked transport

कई loaders अपने TCP स्ट्रीम को `SslStream` में रैप करते हैं और सर्वर के leaf certificate को एम्बेडेड कॉपी के खिलाफ पिन करते हैं (certificate pinning)। Bot info/tasks को compress किया जाता है (उदा., GZip)। जब responses एक थ्रेशोल्ड (~1 MB) से अधिक होते हैं, तो डेटा heuristic-आधारित साइज डिटेक्शन और deserialisation के दौरान मेमोरी spikes कम करने के लिए छोटे chunks (उदा., 16 KB सेगमेंट) में विभाजित कर दिया जाता है।


### Persistence

| Registry         | File          | Service                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Encryption

| Name                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### Anti-Analysis/VM

| Function Name                                             | Assembly Instructions |
| --------------------------------------------------------- | --------------------- |
| IsDebuggerPresent()                                       | CPUID()               |
| GetSystemInfo()                                           | IN()                  |
| GlobalMemoryStatusEx()                                    |                       |
| GetVersion()                                              |                       |
| CreateToolhelp32Snapshot \[Check if a process is running] |                       |
| CreateFileW/A \[Check if a file exist]                    |                       |

### Locale/keyboard-based execution guard

कई stealers/loaders कुछ विशेष locales पर abort कर देते हैं ताकि researchers से बचा जा सके और threat-actor की सीमाओं का पालन किया जा सके। आम जाँचें:
- `GetKeyboardLayout` — इंस्टॉल किए गए layouts की सूची प्राप्त करने के लिए (per-thread/user)
- `GetLocaleInfoA/W` — country/region codes का निर्धारण करने के लिए
- `GetSystemDefaultLangID` / `GetUserDefaultLangID`

यदि कोई मेल blocked सूची से मिलता है (सामान्यतः CIS देशों से), तो loader नेटवर्क IOCs या injection से पहले तुरंत exit कर देता है।

Defence/hunting
- ऐसे processes को फ़्लैग करें जो execution के शुरुआती चरण में कई locale/keyboard APIs को क्वेरी करते हैं और फिर कोई observable activity नहीं दिखाते हुए exit कर जाते हैं।
- गेटेड execution पकड़ने के लिए open-source प्रोजेक्ट्स (उदा., VMDetector) से पुन: उपयोग किए गए anti-VM checks (BIOS strings, PnP devices, disk model, services) के साथ correlate करें।

### Emulator API fingerprinting & sleep evasion

Malware अक्सर sandbox emulators की fingerprinting Defender के virtualised exports को खोजकर करता है (जैसा कि Malware Protection Emulator में देखा गया है)। यदि इनमें से कोई भी symbol मौजूद है (process का case-insensitive scan), तो execution को analysis का समय बर्बाद करने के लिए 10–30 मिनट के लिए delay किया जाता है और फिर पुनः जाँचा जाता है।

Examples of API names used as canaries:
- `MpVmp32Entry`, `MpVmp32FastEnter`, `MpCallPreEntryPointCode`, `MpCallPostEntryPointCode`, `MpFinalize`, `MpReportEvent*`, `MpSwitchToNextThread*`
- `VFS_*` family: `VFS_Open`, `VFS_Read`, `VFS_MapViewOfFile`, `VFS_UnmapViewOfFile`, `VFS_FindFirstFile/FindNextFile`, `VFS_CopyFile`, `VFS_DeleteFile`, `VFS_MoveFile`
- `ThrdMgr_*`: `ThrdMgr_GetCurrentThreadHandle`, `ThrdMgr_SaveTEB`, `ThrdMgr_SwitchThreads`

Typical delay primitive (user-land):
```cmd
cmd /c timeout /t %RANDOM_IN_[600,1800]% > nul
```
Argument gatekeeping
- Operators sometimes require a benign-looking CLI switch to be present before running the payload (e.g., `/i:--type=renderer` to mimic Chromium child processes). If the switch is absent, the loader exits immediately, hindering naive sandbox execution.

### Stealth

| Name                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | मेमोरी आवंटित करना (packers)                                               |
| VirtualProtect           | मेमोरी अनुमतियाँ बदलना (packer द्वारा किसी सेक्शन को execution permission देने के लिए) |
| ReadProcessMemory        | बाहरी प्रक्रियाओं में Injection                                              |
| WriteProcessMemoryA/W    | बाहरी प्रक्रियाओं में Injection                                              |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/Process injection...                                                   |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### Execution

| Function Name    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### Miscellaneous

- GetAsyncKeyState() -- Key logging
- SetWindowsHookEx -- Key logging
- GetForeGroundWindow -- चल रही विंडो का नाम प्राप्त करें (या ब्राउज़र से वेबसाइट)
- LoadLibrary() -- Import library
- GetProcAddress() -- Import library
- CreateToolhelp32Snapshot() -- चल रही प्रक्रियाओं की सूची
- GetDC() -- स्क्रीनशॉट
- BitBlt() -- स्क्रीनशॉट
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- Internet तक पहुँच
- FindResource(), LoadResource(), LockResource() -- executable के resources तक पहुँच

## Malware Techniques

### DLL Injection

Execute an arbitrary DLL inside another process

1. मलिशियस DLL को inject करने के लिए लक्ष्य प्रक्रिया खोजें: CreateToolhelp32Snapshot, Process32First, Process32Next
2. प्रक्रिया खोलें: GetModuleHandle, GetProcAddress, OpenProcess
3. प्रक्रिया के अंदर DLL का path लिखें: VirtualAllocEx, WriteProcessMemory
4. उस प्रक्रिया में एक thread बनाएं जो मलिशियस DLL को लोड करेगा: CreateRemoteThread, LoadLibrary

Other functions to use: NTCreateThreadEx, RtlCreateUserThread

### Reflective DLL Injection

Load a malicious DLL without calling normal Windows API calls.\
DLL को प्रक्रिया के अंदर mapped किया जाता है, यह import addresses को resolve करेगा, relocations को ठीक करेगा और DllMain फ़ंक्शन को कॉल करेगा.

### Thread Hijacking

Find a thread from a process and make it load a malicious DLL

1. लक्ष्य थ्रेड खोजें: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. थ्रेड खोलें: OpenThread
3. थ्रेड suspend करें: SuspendThread
4. victim प्रक्रिया के अंदर मलिशियस DLL का path लिखें: VirtualAllocEx, WriteProcessMemory
5. थ्रेड को resume कराएँ ताकि यह लाइब्रेरी लोड करे: ResumeThread

### PE Injection

Portable Execution Injection: executable को victim प्रक्रिया की memory में लिखा जाएगा और वहीं से execute किया जाएगा.

### Process Hollowing (a.k.a **RunPE**)

`Process Hollowing` Windows malware द्वारा उपयोग किए जाने वाले पसंदीदा `defence-evasion / execution` ट्रिक्स में से एक है। विचार यह है कि एक *legitimate* प्रक्रिया को **suspended** स्थिति में लॉन्च किया जाए, उसकी मूल image को memory से हटाया (hollow) जाए और उसकी जगह एक **arbitrary PE** कॉपी किया जाए। जब primary thread अंततः resume होता है तो malicious entry-point एक trusted binary के रूप में (अक्सर Microsoft द्वारा signed) execute होता है।

Typical workflow:

1. एक benign host (उदा., `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`) **suspended** स्थिति में spawn करें ताकि अभी कोई instructions न चलें.
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. मलिशियस payload को memory में पढ़ें और इसके PE headers को पार्स कर `SizeOfImage`, sections और नया `EntryPoint` प्राप्त करें.
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – suspended प्रक्रिया के मूल image base को unmap करें.
4. **VirtualAllocEx** – remote प्रक्रिया के अंदर `SizeOfImage` के लिए RWX मेमोरी रिज़र्व करें.
5. **WriteProcessMemory** – पहले `Headers` कॉपी करें, फिर sections के raw data को iterate करके कॉपी करें.
6. **SetThreadContext** – context structure में EAX/RAX (`RCX` on x64) या Rip का मान patch करें ताकि `EIP` payload के `EntryPoint` की ओर इशारा करे.
7. **ResumeThread** – थ्रेड जारी रहता है और attacker-supplied कोड execute होता है।

Minimal proof-of-concept (x86) skeleton:
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
Practical notes observed in the **DarkCloud Stealer** campaign:

* The loader picked `RegAsm.exe` (part of the .NET Framework) as host – a signed binary unlikely to draw attention.
* The decrypted VB6 stealer (`holographies.exe`) is *not* dropped on disk; it only ever exists inside the hollowed process making static detection harder.
* Sensitive strings (regexes, paths, Telegram credentials) are **RC4-encrypted** per-string and only decrypted at runtime, further complicating memory scanning.

Detection ideas:
* Alert on `CREATE_SUSPENDED` processes that never create GUI/console windows before a memory region is allocated as **RWX** (rare for benign code).
* Look for a call sequence `NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory` across different processes.
* Unusual use of trusted developer utilities as hollowing hosts, especially `MSBuild.exe`, `RegAsm.exe`, `rundll32.exe`, parented by short-lived loaders.
* Hunt for `msbuild.exe` spawned from user-writable paths or without corresponding `.sln/.proj` context then making outbound connections (ATT&CK T1127.001 + T1055.012).

Common host processes and path resolution
- `MSBuild.exe` is frequently chosen as a hollowing host to blend with developer tooling. Loaders often search architecture-appropriate locations:
- `C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe`
- `C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe`
- `C:\Windows\System32\MSBuild.exe`
- `C:\Windows\SysWOW64\MSBuild.exe`
- Select the host matching the current payload/OS architecture before calling `CreateProcess(..., CREATE_SUSPENDED, ...)`.



## Hooking

- The **SSDT** (**System Service Descriptor Table**) points to kernel functions (ntoskrnl.exe) or GUI driver (win32k.sys) so user processes can call these functions.
- A rootkit may modify these pointer to addresses that he controls
- **IRP** (**I/O Request Packets**) transmit pieces of data from one component to another. Almost everything in the kernel uses IRPs and each device object has its own function table that can be hooked: DKOM (Direct Kernel Object Manipulation)
- The **IAT** (**Import Address Table**) is useful to resolve dependencies. It's possible to hook this table in order to hijack the code that will be called.
- **EAT** (**Export Address Table**) Hooks. This hooks can be done from **userland**. The goal is to hook exported functions by DLLs.
- **Inline Hooks**: This type are difficult to achieve. This involve modifying the code of the functions itself. Maybe by putting a jump at the beginning of this.


## References

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)
- [Check Point Research – Under the Pure Curtain: From RAT to Builder to Coder](https://research.checkpoint.com/2025/under-the-pure-curtain-from-rat-to-builder-to-coder/)
- [Unit 42 – PhantomVAI Loader Delivers a Range of Infostealers](https://unit42.paloaltonetworks.com/phantomvai-loader-delivers-infostealers/)
- [MITRE ATT&CK – Trusted Developer Utilities Proxy Execution: MSBuild (T1127.001)](https://attack.mitre.org/techniques/T1127/001/)
- [VMDetector – virtualization checks (open-source)](https://github.com/robsonfelix/VMDetector)

{{#include ../banners/hacktricks-training.md}}
