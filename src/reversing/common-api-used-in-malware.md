# API Común Usada en Malware

{{#include ../banners/hacktricks-training.md}}

## Genérico

### Redes

| Sockets Crudos | Sockets WinAPI |
| -------------- | -------------- |
| socket()       | WSAStratup()   |
| bind()         | bind()         |
| listen()       | listen()       |
| accept()       | accept()       |
| connect()      | connect()      |
| read()/recv()  | recv()         |
| write()        | send()         |
| shutdown()     | WSACleanup()   |

### Persistencia

| Registro         | Archivo       | Servicio                      |
| ---------------- | ------------- | ----------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Cifrado

| Nombre                  |
| ----------------------- |
| WinCrypt                |
| CryptAcquireContext()   |
| CryptGenKey()           |
| CryptDeriveKey()        |
| CryptDecrypt()          |
| CryptReleaseContext()   |

### Anti-Análisis/VM

| Nombre de Función                                             | Instrucciones de Ensamblador |
| ------------------------------------------------------------ | ------------------------------ |
| IsDebuggerPresent()                                          | CPUID()                       |
| GetSystemInfo()                                             | IN()                          |
| GlobalMemoryStatusEx()                                      |                                |
| GetVersion()                                                |                                |
| CreateToolhelp32Snapshot \[Verificar si un proceso está en ejecución] |                                |
| CreateFileW/A \[Verificar si un archivo existe]            |                                |

### Sigilo

| Nombre                     |                                                                            |
| -------------------------- | -------------------------------------------------------------------------- |
| VirtualAlloc               | Asignar memoria (empaquetadores)                                         |
| VirtualProtect             | Cambiar permisos de memoria (empaquetador otorgando permisos de ejecución a una sección) |
| ReadProcessMemory          | Inyección en procesos externos                                            |
| WriteProcessMemoryA/W      | Inyección en procesos externos                                            |
| NtWriteVirtualMemory       |                                                                            |
| CreateRemoteThread         | Inyección de DLL/proceso...                                              |
| NtUnmapViewOfSection       |                                                                            |
| QueueUserAPC               |                                                                            |
| CreateProcessInternalA/W   |                                                                            |

### Ejecución

| Nombre de Función  |
| ------------------- |
| CreateProcessA/W   |
| ShellExecute       |
| WinExec            |
| ResumeThread       |
| NtResumeThread     |

### Varios

- GetAsyncKeyState() -- Registro de teclas
- SetWindowsHookEx -- Registro de teclas
- GetForeGroundWindow -- Obtener el nombre de la ventana en ejecución (o el sitio web de un navegador)
- LoadLibrary() -- Importar biblioteca
- GetProcAddress() -- Importar biblioteca
- CreateToolhelp32Snapshot() -- Listar procesos en ejecución
- GetDC() -- Captura de pantalla
- BitBlt() -- Captura de pantalla
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- Acceso a Internet
- FindResource(), LoadResource(), LockResource() -- Acceso a recursos del ejecutable

## Técnicas de Malware

### Inyección de DLL

Ejecutar una DLL arbitraria dentro de otro proceso

1. Localizar el proceso para inyectar la DLL maliciosa: CreateToolhelp32Snapshot, Process32First, Process32Next
2. Abrir el proceso: GetModuleHandle, GetProcAddress, OpenProcess
3. Escribir la ruta a la DLL dentro del proceso: VirtualAllocEx, WriteProcessMemory
4. Crear un hilo en el proceso que cargará la DLL maliciosa: CreateRemoteThread, LoadLibrary

Otras funciones a utilizar: NTCreateThreadEx, RtlCreateUserThread

### Inyección de DLL Reflectiva

Cargar una DLL maliciosa sin llamar a las llamadas normales de la API de Windows.\
La DLL se mapea dentro de un proceso, resolverá las direcciones de importación, corregirá las reubicaciones y llamará a la función DllMain.

### Secuestro de Hilos

Encontrar un hilo de un proceso y hacer que cargue una DLL maliciosa

1. Encontrar un hilo objetivo: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. Abrir el hilo: OpenThread
3. Suspender el hilo: SuspendThread
4. Escribir la ruta a la DLL maliciosa dentro del proceso de la víctima: VirtualAllocEx, WriteProcessMemory
5. Reanudar el hilo cargando la biblioteca: ResumeThread

### Inyección PE

Inyección de Ejecución Portátil: El ejecutable se escribirá en la memoria del proceso de la víctima y se ejecutará desde allí.

### Hollowing de Proceso

El malware desmapeará el código legítimo de la memoria del proceso y cargará un binario malicioso

1. Crear un nuevo proceso: CreateProcess
2. Desmapear la memoria: ZwUnmapViewOfSection, NtUnmapViewOfSection
3. Escribir el binario malicioso en la memoria del proceso: VirtualAllocEc, WriteProcessMemory
4. Establecer el punto de entrada y ejecutar: SetThreadContext, ResumeThread

## Hooking

- La **SSDT** (**Tabla de Descriptores de Servicios del Sistema**) apunta a funciones del kernel (ntoskrnl.exe) o controlador GUI (win32k.sys) para que los procesos de usuario puedan llamar a estas funciones.
- Un rootkit puede modificar estos punteros a direcciones que controla.
- **IRP** (**Paquetes de Solicitud de I/O**) transmiten piezas de datos de un componente a otro. Casi todo en el kernel utiliza IRPs y cada objeto de dispositivo tiene su propia tabla de funciones que puede ser enganchada: DKOM (Manipulación Directa de Objetos del Kernel).
- La **IAT** (**Tabla de Direcciones de Importación**) es útil para resolver dependencias. Es posible enganchar esta tabla para secuestrar el código que será llamado.
- **EAT** (**Tabla de Direcciones de Exportación**) Hooks. Estos hooks se pueden hacer desde **userland**. El objetivo es enganchar funciones exportadas por DLLs.
- **Inline Hooks**: Este tipo son difíciles de lograr. Esto implica modificar el código de las funciones mismas. Tal vez poniendo un salto al principio de esto.

{{#include ../banners/hacktricks-training.md}}
