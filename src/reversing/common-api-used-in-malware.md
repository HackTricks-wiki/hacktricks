# 악성코드에서 사용되는 일반적인 API

{{#include ../banners/hacktricks-training.md}}

## 일반

### Networking

| Raw Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### TLS pinning and chunked transport

많은 로더는 TCP 스트림을 `SslStream`으로 래핑하고 서버의 리프 인증서를 내장된 복사본과 대조하여 certificate pinning을 수행합니다. Bot info/tasks는 (예: GZip)으로 압축됩니다. 응답이 임계값(~1 MB)을 초과하면 데이터는 크기 기반 휴리스틱을 회피하고 역직렬화 중 메모리 급증을 줄이기 위해 작은 청크(예: 16 KB 세그먼트)로 분할됩니다.


### Persistence

| Registry         | File          | Service                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Encryption

| Name                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### Anti-Analysis/VM

| Function Name                                             | Assembly Instructions |
| --------------------------------------------------------- | --------------------- |
| IsDebuggerPresent()                                       | CPUID()               |
| GetSystemInfo()                                           | IN()                  |
| GlobalMemoryStatusEx()                                    |                       |
| GetVersion()                                              |                       |
| CreateToolhelp32Snapshot \[Check if a process is running] |                       |
| CreateFileW/A \[Check if a file exist]                    |                       |

### Locale/keyboard-based execution guard

많은 stealer/loader는 연구원을 회피하고 위협 행위자의 제약을 준수하기 위해 특정 로케일에서 즉시 종료합니다. 일반적인 검사:
- `GetKeyboardLayout`으로 설치된 레이아웃(스레드/사용자별)을 열거
- `GetLocaleInfoA/W`로 국가/지역 코드를 확인
- `GetSystemDefaultLangID` / `GetUserDefaultLangID`

차단 목록(일반적으로 CIS 국가)에 일치하는 항목이 있으면 로더는 네트워크 IOCs나 인젝션 수행 전에 즉시 종료합니다.

방어/헌팅
- 실행 초기에 여러 로케일/키보드 API를 조회한 후 아무런 관찰 가능한 활동 없이 종료하는 프로세스를 플래그합니다.
- 공개 소스 프로젝트(예: VMDetector)에서 재사용되는 안티-VM 검사(BIOS 문자열, PnP 장치, 디스크 모델, 서비스)와 상관관계를 통해 gated execution을 포착합니다.

### Emulator API fingerprinting & sleep evasion

악성코드는 종종 Malware Protection Emulator에서 보이는 Defender의 가상화된 export를 검색하여 샌드박스 에뮬레이터를 지문화합니다. 이러한 심볼이 존재하면(프로세스에 대한 대소문자 구분 없는 스캔) 실행을 10–30분 지연시키고 다시 확인하여 분석 시간을 낭비합니다.

카나리로 사용되는 API 이름 예시:
- `MpVmp32Entry`, `MpVmp32FastEnter`, `MpCallPreEntryPointCode`, `MpCallPostEntryPointCode`, `MpFinalize`, `MpReportEvent*`, `MpSwitchToNextThread*`
- `VFS_*` 계열: `VFS_Open`, `VFS_Read`, `VFS_MapViewOfFile`, `VFS_UnmapViewOfFile`, `VFS_FindFirstFile/FindNextFile`, `VFS_CopyFile`, `VFS_DeleteFile`, `VFS_MoveFile`
- `ThrdMgr_*`: `ThrdMgr_GetCurrentThreadHandle`, `ThrdMgr_SaveTEB`, `ThrdMgr_SwitchThreads`

Typical delay primitive (user-land):
```cmd
cmd /c timeout /t %RANDOM_IN_[600,1800]% > nul
```
인자 검증
- 운영자는 페이로드를 실행하기 전에 악성으로 보이지 않는 CLI 스위치가 존재할 것을 요구하는 경우가 있습니다(예: `/i:--type=renderer`로 Chromium 자식 프로세스를 모방). 스위치가 없으면 로더가 즉시 종료되어 단순한 샌드박스 실행을 방해합니다.


### 스텔스

| 이름                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | 메모리 할당 (packers)                                                     |
| VirtualProtect           | 메모리 권한 변경 (섹션에 실행 권한을 부여하는 packer)                     |
| ReadProcessMemory        | 외부 프로세스에 대한 주입                                                  |
| WriteProcessMemoryA/W    | 외부 프로세스에 대한 주입                                                  |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/Process injection...                                                   |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### 실행

| 함수 이름         |
| ----------------- |
| CreateProcessA/W  |
| ShellExecute      |
| WinExec           |
| ResumeThread      |
| NtResumeThread    |

### 기타

- GetAsyncKeyState() -- Key logging
- SetWindowsHookEx -- Key logging
- GetForeGroundWindow -- 실행 중인 창 이름 가져오기(또는 브라우저에서 웹사이트)
- LoadLibrary() -- 라이브러리 로드
- GetProcAddress() -- 라이브러리 함수 주소 가져오기
- CreateToolhelp32Snapshot() -- 실행 중인 프로세스 나열
- GetDC() -- 스크린샷
- BitBlt() -- 스크린샷
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- 인터넷 접근
- FindResource(), LoadResource(), LockResource() -- 실행 파일의 리소스 접근

## 맬웨어 기법

### DLL Injection

다른 프로세스 내부에서 임의의 DLL을 실행

1. 악성 DLL을 주입할 프로세스 찾기: CreateToolhelp32Snapshot, Process32First, Process32Next
2. 프로세스 열기: GetModuleHandle, GetProcAddress, OpenProcess
3. 프로세스 내부에 DLL 경로 쓰기: VirtualAllocEx, WriteProcessMemory
4. 악성 DLL을 로드할 스레드 생성: CreateRemoteThread, LoadLibrary

다른 사용 가능한 함수: NTCreateThreadEx, RtlCreateUserThread

### Reflective DLL Injection

일반적인 Windows API 호출을 사용하지 않고 악성 DLL을 로드합니다.  
DLL이 프로세스 내부에 매핑되며, 임포트 주소를 해결하고 재배치를 수정한 뒤 DllMain 함수를 호출합니다.

### Thread Hijacking

프로세스의 스레드를 찾아 해당 스레드가 악성 DLL을 로드하도록 만듭니다

1. 대상 스레드 찾기: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. 스레드 열기: OpenThread
3. 스레드 중단: SuspendThread
4. 피해자 프로세스 내부에 악성 DLL 경로 쓰기: VirtualAllocEx, WriteProcessMemory
5. 라이브러리를 로드하도록 스레드 재개: ResumeThread

### PE Injection

Portable Execution Injection: 실행 파일이 피해자 프로세스의 메모리에 기록되고 그곳에서 실행됩니다.

### Process Hollowing (a.k.a **RunPE**)

`Process Hollowing`은 Windows 맬웨어가 사용하는 대표적인 **defence-evasion / execution** 기법 중 하나입니다. 아이디어는 *정상적인* 프로세스를 **중단된** 상태로 실행한 뒤, 메모리에서 원본 이미지를 제거(홀로잉)하고 그 자리에 **임의의 PE**를 복사하는 것입니다. 주 스레드가 재개되면 악성 진입점이 종종 Microsoft에 의해 서명된 신뢰된 바이너리로 위장하여 실행됩니다.

일반적인 작업 흐름:

1. 무해한 호스트(예: `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`)를 아직 명령이 실행되지 않도록 **중단된** 상태로 생성합니다.
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. 악성 페이로드를 메모리로 읽고 PE 헤더를 파싱하여 `SizeOfImage`, 섹션들 및 새로운 `EntryPoint`를 얻습니다.
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – 중단된 프로세스의 원본 이미지 베이스의 매핑을 해제합니다.
4. **VirtualAllocEx** – 원격 프로세스 내부에 `SizeOfImage` 크기의 RWX 메모리를 예약합니다.
5. **WriteProcessMemory** – 먼저 `Headers`를 복사한 다음 섹션들을 순회하며 원시 데이터를 복사합니다.
6. **SetThreadContext** – 컨텍스트 구조체에서 `EAX/RAX`(`RCX`는 x64) 또는 `Rip` 값을 패치하여 `EIP`가 페이로드의 `EntryPoint`를 가리키도록 합니다.
7. **ResumeThread** – 스레드가 계속 실행되어 공격자가 제공한 코드를 수행합니다.

Minimal proof-of-concept (x86) skeleton:
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
실전 메모(Practical notes) — **DarkCloud Stealer** 캠페인에서 관찰된 내용:

* 로더는 호스트로 `RegAsm.exe` (.NET Framework의 일부)를 선택했습니다 — 서명된 바이너리라 주의를 끌 가능성이 낮습니다.
* 복호화된 VB6 stealer (`holographies.exe`)는 디스크에 *드롭되지 않으며* 오직 hollowed process 내부에만 존재하여 정적 탐지를 어렵게 만듭니다.
* 민감한 문자열(regexes, paths, Telegram credentials)은 각 문자열별로 **RC4-encrypted** 되어 런타임에만 복호화되므로 메모리 스캐닝을 더욱 복잡하게 만듭니다.

탐지 아이디어:
* 메모리 영역이 **RWX**로 할당되기 전에 GUI/콘솔 창을 전혀 생성하지 않는 `CREATE_SUSPENDED` 프로세스에 대해 경고하세요(정상 코드에서는 드뭅니다).
* 서로 다른 프로세스에서 `NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory` 호출 시퀀스를 찾아보세요.
* 특히 `MSBuild.exe`, `RegAsm.exe`, `rundll32.exe` 같은 신뢰된 개발 유틸리티가 hollowing host로 비정상적으로 사용되고, 짧게 실행되는 로더에 의해 부모화된 경우를 주목하세요.
* 사용자 쓰기 가능한 경로에서 생성되었거나 대응하는 `.sln/.proj` 컨텍스트 없이 생성된 후 아웃바운드 연결을 시도하는 `msbuild.exe`를 찾아보세요 (ATT&CK T1127.001 + T1055.012).

Common host processes and path resolution
- `MSBuild.exe`는 개발 도구와 섞이기 위해 hollowing host로 자주 선택됩니다. 로더는 종종 아키텍처에 맞는 위치를 검색합니다:
- `C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe`
- `C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe`
- `C:\Windows\System32\MSBuild.exe`
- `C:\Windows\SysWOW64\MSBuild.exe`
- CreateProcess(..., CREATE_SUSPENDED, ...)를 호출하기 전에 현재 payload/OS 아키텍처에 맞는 호스트를 선택하세요.



## Hooking

- The **SSDT** (**System Service Descriptor Table**)는 커널 함수(ntoskrnl.exe)나 GUI 드라이버(win32k.sys)를 가리켜 사용자 프로세스가 해당 함수를 호출할 수 있게 합니다.
- 루트킷은 이러한 포인터들을 공격자가 제어하는 주소로 변경할 수 있습니다.
- **IRP** (**I/O Request Packets**)는 한 구성요소에서 다른 구성요소로 데이터를 전달합니다. 커널의 거의 모든 부분이 IRP를 사용하며 각 디바이스 오브젝트는 훅 가능한 자체 함수 테이블을 가집니다: DKOM (Direct Kernel Object Manipulation)
- **IAT** (**Import Address Table**)는 의존성 해결에 유용합니다. 호출될 코드를 가로채기 위해 이 테이블을 훅할 수 있습니다.
- **EAT** (**Export Address Table**) 훅. 이러한 훅은 userland에서 수행할 수 있습니다. 목표는 DLL이 내보내는(exported) 함수를 훅하는 것입니다.
- **Inline Hooks**: 이 유형은 달성하기 어렵습니다. 함수 코드 자체를 수정하는 것을 포함하며, 예를 들어 함수 시작 부분에 점프를 삽입하는 방식이 사용될 수 있습니다.


## References

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)
- [Check Point Research – Under the Pure Curtain: From RAT to Builder to Coder](https://research.checkpoint.com/2025/under-the-pure-curtain-from-rat-to-builder-to-coder/)
- [Unit 42 – PhantomVAI Loader Delivers a Range of Infostealers](https://unit42.paloaltonetworks.com/phantomvai-loader-delivers-infostealers/)
- [MITRE ATT&CK – Trusted Developer Utilities Proxy Execution: MSBuild (T1127.001)](https://attack.mitre.org/techniques/T1127/001/)
- [VMDetector – virtualization checks (open-source)](https://github.com/robsonfelix/VMDetector)

{{#include ../banners/hacktricks-training.md}}
