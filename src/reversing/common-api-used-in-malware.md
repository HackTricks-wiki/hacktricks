# API couramment utilisée dans les logiciels malveillants

{{#include ../banners/hacktricks-training.md}}

## Générique

### Réseautage

| Sockets bruts   | Sockets WinAPI |
| --------------- | -------------- |
| socket()        | WSAStratup()   |
| bind()          | bind()         |
| listen()        | listen()       |
| accept()        | accept()       |
| connect()       | connect()      |
| read()/recv()   | recv()         |
| write()         | send()         |
| shutdown()      | WSACleanup()   |

### Persistance

| Registre         | Fichier       | Service                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Chiffrement

| Nom                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### Anti-analyse/VM

| Nom de la fonction                                         | Instructions d'assemblage |
| --------------------------------------------------------- | -------------------------- |
| IsDebuggerPresent()                                       | CPUID()                   |
| GetSystemInfo()                                          | IN()                      |
| GlobalMemoryStatusEx()                                   |                            |
| GetVersion()                                             |                            |
| CreateToolhelp32Snapshot \[Vérifier si un processus est en cours d'exécution] |                            |
| CreateFileW/A \[Vérifier si un fichier existe]          |                            |

### Discrétion

| Nom                     |                                                                            |
| ----------------------- | -------------------------------------------------------------------------- |
| VirtualAlloc            | Allouer de la mémoire (packers)                                           |
| VirtualProtect          | Changer les permissions de mémoire (packer donnant la permission d'exécution à une section) |
| ReadProcessMemory       | Injection dans des processus externes                                      |
| WriteProcessMemoryA/W   | Injection dans des processus externes                                      |
| NtWriteVirtualMemory    |                                                                            |
| CreateRemoteThread      | Injection de DLL/processus...                                             |
| NtUnmapViewOfSection    |                                                                            |
| QueueUserAPC            |                                                                            |
| CreateProcessInternalA/W|                                                                            |

### Exécution

| Nom de la fonction    |
| --------------------- |
| CreateProcessA/W     |
| ShellExecute          |
| WinExec               |
| ResumeThread          |
| NtResumeThread        |

### Divers

- GetAsyncKeyState() -- Enregistrement des touches
- SetWindowsHookEx -- Enregistrement des touches
- GetForeGroundWindow -- Obtenir le nom de la fenêtre en cours d'exécution (ou le site Web d'un navigateur)
- LoadLibrary() -- Importer une bibliothèque
- GetProcAddress() -- Importer une bibliothèque
- CreateToolhelp32Snapshot() -- Lister les processus en cours d'exécution
- GetDC() -- Capture d'écran
- BitBlt() -- Capture d'écran
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- Accéder à Internet
- FindResource(), LoadResource(), LockResource() -- Accéder aux ressources de l'exécutable

## Techniques de logiciels malveillants

### Injection de DLL

Exécuter une DLL arbitraire à l'intérieur d'un autre processus

1. Localiser le processus pour injecter la DLL malveillante : CreateToolhelp32Snapshot, Process32First, Process32Next
2. Ouvrir le processus : GetModuleHandle, GetProcAddress, OpenProcess
3. Écrire le chemin vers la DLL à l'intérieur du processus : VirtualAllocEx, WriteProcessMemory
4. Créer un thread dans le processus qui chargera la DLL malveillante : CreateRemoteThread, LoadLibrary

Autres fonctions à utiliser : NTCreateThreadEx, RtlCreateUserThread

### Injection de DLL réfléchissante

Charger une DLL malveillante sans appeler les appels API Windows normaux.\
La DLL est mappée à l'intérieur d'un processus, elle résoudra les adresses d'importation, corrigera les relocations et appellera la fonction DllMain.

### Détournement de thread

Trouver un thread d'un processus et le faire charger une DLL malveillante

1. Trouver un thread cible : CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. Ouvrir le thread : OpenThread
3. Suspendre le thread : SuspendThread
4. Écrire le chemin vers la DLL malveillante à l'intérieur du processus de la victime : VirtualAllocEx, WriteProcessMemory
5. Reprendre le thread chargeant la bibliothèque : ResumeThread

### Injection PE

Injection d'exécution portable : L'exécutable sera écrit dans la mémoire du processus de la victime et sera exécuté à partir de là.

### Hollowing de processus

Le logiciel malveillant va désmapper le code légitime de la mémoire du processus et charger un binaire malveillant

1. Créer un nouveau processus : CreateProcess
2. Désmapper la mémoire : ZwUnmapViewOfSection, NtUnmapViewOfSection
3. Écrire le binaire malveillant dans la mémoire du processus : VirtualAllocEc, WriteProcessMemory
4. Définir le point d'entrée et exécuter : SetThreadContext, ResumeThread

## Hooking

- Le **SSDT** (**System Service Descriptor Table**) pointe vers des fonctions du noyau (ntoskrnl.exe) ou un pilote GUI (win32k.sys) afin que les processus utilisateurs puissent appeler ces fonctions.
- Un rootkit peut modifier ces pointeurs vers des adresses qu'il contrôle.
- **IRP** (**I/O Request Packets**) transmettent des morceaux de données d'un composant à un autre. Presque tout dans le noyau utilise des IRP et chaque objet de périphérique a sa propre table de fonctions qui peut être hookée : DKOM (Direct Kernel Object Manipulation)
- Le **IAT** (**Import Address Table**) est utile pour résoudre les dépendances. Il est possible de hooker cette table afin de détourner le code qui sera appelé.
- **EAT** (**Export Address Table**) Hooks. Ces hooks peuvent être réalisés depuis **userland**. L'objectif est de hooker les fonctions exportées par les DLL.
- **Inline Hooks** : Ce type est difficile à réaliser. Cela implique de modifier le code des fonctions elles-mêmes. Peut-être en mettant un saut au début de celles-ci.

{{#include ../banners/hacktricks-training.md}}
