# Malware में उपयोग किए जाने वाले सामान्य API

{{#include ../banners/hacktricks-training.md}}

## सामान्य

### नेटवर्किंग

| कच्चे सॉकेट   | WinAPI सॉकेट्स |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### स्थिरता

| रजिस्ट्री         | फ़ाइल          | सेवा                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### एन्क्रिप्शन

| नाम                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### एंटी-विश्लेषण/वीएम

| फ़ंक्शन नाम                                             | असेंबली निर्देश |
| --------------------------------------------------------- | --------------------- |
| IsDebuggerPresent()                                       | CPUID()               |
| GetSystemInfo()                                           | IN()                  |
| GlobalMemoryStatusEx()                                    |                       |
| GetVersion()                                              |                       |
| CreateToolhelp32Snapshot \[एक प्रक्रिया चल रही है या नहीं जांचें] |                       |
| CreateFileW/A \[एक फ़ाइल मौजूद है या नहीं जांचें]          |                       |

### छिपाव

| नाम                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | मेमोरी आवंटित करें (पैकर)                                                     |
| VirtualProtect           | मेमोरी अनुमति बदलें (पैकर एक अनुभाग को निष्पादन अनुमति दे रहा है) |
| ReadProcessMemory        | बाहरी प्रक्रियाओं में इंजेक्शन                                          |
| WriteProcessMemoryA/W    | बाहरी प्रक्रियाओं में इंजेक्शन                                          |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/प्रक्रिया इंजेक्शन...                                                   |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### निष्पादन

| फ़ंक्शन नाम    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### विविध

- GetAsyncKeyState() -- की लॉगिंग
- SetWindowsHookEx -- की लॉगिंग
- GetForeGroundWindow -- चल रहे विंडो का नाम प्राप्त करें (या ब्राउज़र से वेबसाइट)
- LoadLibrary() -- पुस्तकालय आयात करें
- GetProcAddress() -- पुस्तकालय आयात करें
- CreateToolhelp32Snapshot() -- चल रही प्रक्रियाओं की सूची
- GetDC() -- स्क्रीनशॉट
- BitBlt() -- स्क्रीनशॉट
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- इंटरनेट तक पहुँचें
- FindResource(), LoadResource(), LockResource() -- निष्पादन योग्य के संसाधनों तक पहुँचें

## मैलवेयर तकनीकें

### DLL इंजेक्शन

एक मनमाना DLL को दूसरे प्रक्रिया के अंदर निष्पादित करें

1. दुर्भावनापूर्ण DLL इंजेक्ट करने के लिए प्रक्रिया का पता लगाएं: CreateToolhelp32Snapshot, Process32First, Process32Next
2. प्रक्रिया खोलें: GetModuleHandle, GetProcAddress, OpenProcess
3. प्रक्रिया के अंदर DLL का पथ लिखें: VirtualAllocEx, WriteProcessMemory
4. प्रक्रिया में एक थ्रेड बनाएं जो दुर्भावनापूर्ण DLL लोड करेगा: CreateRemoteThread, LoadLibrary

उपयोग करने के लिए अन्य फ़ंक्शन: NTCreateThreadEx, RtlCreateUserThread

### रिफ्लेक्टिव DLL इंजेक्शन

सामान्य Windows API कॉल किए बिना एक दुर्भावनापूर्ण DLL लोड करें।\
DLL एक प्रक्रिया के अंदर मैप किया गया है, यह आयात पते को हल करेगा, पुनर्स्थापनाओं को ठीक करेगा और DllMain फ़ंक्शन को कॉल करेगा।

### थ्रेड हाईजैकिंग

एक प्रक्रिया से एक थ्रेड खोजें और इसे एक दुर्भावनापूर्ण DLL लोड करने के लिए बनाएं

1. एक लक्षित थ्रेड खोजें: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. थ्रेड खोलें: OpenThread
3. थ्रेड को निलंबित करें: SuspendThread
4. पीड़ित प्रक्रिया के अंदर दुर्भावनापूर्ण DLL का पथ लिखें: VirtualAllocEx, WriteProcessMemory
5. पुस्तकालय लोड करते समय थ्रेड को फिर से शुरू करें: ResumeThread

### PE इंजेक्शन

पोर्टेबल निष्पादन इंजेक्शन: निष्पादन योग्य को पीड़ित प्रक्रिया की मेमोरी में लिखा जाएगा और वहीं से निष्पादित किया जाएगा।

### प्रक्रिया खोखलीकरण (जिसे **RunPE** भी कहा जाता है)

`Process Hollowing` Windows मैलवेयर द्वारा उपयोग की जाने वाली पसंदीदा **रक्षा-निषेध / निष्पादन** चालों में से एक है।  विचार यह है कि एक *वैध* प्रक्रिया को **निलंबित** स्थिति में लॉन्च करें, इसकी मूल छवि को मेमोरी से हटा दें (खोखली करें) और इसके स्थान पर एक **मनमाना PE** कॉपी करें।  जब प्राथमिक थ्रेड अंततः फिर से शुरू होता है, तो दुर्भावनापूर्ण प्रवेश बिंदु एक विश्वसनीय बाइनरी (अक्सर Microsoft द्वारा हस्ताक्षरित) के रूप में निष्पादित होता है।

विशिष्ट कार्यप्रवाह:

1. एक बेनिग्न होस्ट (जैसे `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`) **निलंबित** करें ताकि कोई निर्देश अभी तक न चलें।
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. दुर्भावनापूर्ण पेलोड को मेमोरी में पढ़ें और इसके PE हेडर को पार्स करें ताकि `SizeOfImage`, अनुभाग और नया `EntryPoint` प्राप्त किया जा सके।
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – निलंबित प्रक्रिया की मूल छवि आधार को अनमैप करें।
4. **VirtualAllocEx** – दूरस्थ प्रक्रिया के अंदर `SizeOfImage` की RWX मेमोरी आरक्षित करें।
5. **WriteProcessMemory** – पहले `Headers` की कॉपी करें, फिर अनुभागों के कच्चे डेटा की कॉपी करते हुए पुनरावृत्ति करें।
6. **SetThreadContext** – संदर्भ संरचना में `EAX/RAX` (`RCX` x64 पर) या `Rip` के मान को पैच करें ताकि `EIP` पेलोड के `EntryPoint` की ओर इंगित करे।
7. **ResumeThread** – थ्रेड जारी रहता है, हमलावर द्वारा प्रदान किए गए कोड को निष्पादित करता है।

न्यूनतम प्रमाण-की-धारणा (x86) ढांचा:
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
Practical notes observed in the **DarkCloud Stealer** campaign:

* लोडर ने `RegAsm.exe` (जो .NET Framework का हिस्सा है) को होस्ट के रूप में चुना - एक साइन किया हुआ बाइनरी जो ध्यान आकर्षित करने की संभावना नहीं है।
* डिक्रिप्टेड VB6 चोर (`holographies.exe`) *डिस्क पर* नहीं गिराया जाता; यह केवल खोखले प्रोसेस के अंदर मौजूद होता है, जिससे स्थैतिक पहचान करना कठिन हो जाता है।
* संवेदनशील स्ट्रिंग्स (regexes, paths, Telegram credentials) को **RC4-एन्क्रिप्टेड** किया जाता है प्रति-स्ट्रिंग और केवल रनटाइम पर डिक्रिप्ट किया जाता है, जिससे मेमोरी स्कैनिंग और जटिल हो जाती है।

Detection ideas:
* `CREATE_SUSPENDED` प्रोसेस पर अलर्ट करें जो कभी भी GUI/कंसोल विंडो नहीं बनाते हैं इससे पहले कि एक मेमोरी क्षेत्र **RWX** के रूप में आवंटित किया जाए (जो कि बेनिग कोड के लिए दुर्लभ है)।
* विभिन्न प्रोसेस में `NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory` कॉल अनुक्रम की तलाश करें।

## Hooking

- **SSDT** (**System Service Descriptor Table**) कर्नेल फ़ंक्शंस (ntoskrnl.exe) या GUI ड्राइवर (win32k.sys) की ओर इशारा करता है ताकि उपयोगकर्ता प्रक्रियाएँ इन फ़ंक्शंस को कॉल कर सकें।
- एक रूटकिट इन प्वाइंटर्स को उन पते पर संशोधित कर सकता है जिन्हें वह नियंत्रित करता है।
- **IRP** (**I/O Request Packets**) डेटा के टुकड़ों को एक घटक से दूसरे घटक में संचारित करता है। कर्नेल में लगभग सब कुछ IRPs का उपयोग करता है और प्रत्येक डिवाइस ऑब्जेक्ट की अपनी फ़ंक्शन तालिका होती है जिसे हुक किया जा सकता है: DKOM (Direct Kernel Object Manipulation)
- **IAT** (**Import Address Table**) निर्भरताओं को हल करने के लिए उपयोगी है। इस तालिका को हुक करना संभव है ताकि उस कोड को हाईजैक किया जा सके जिसे कॉल किया जाएगा।
- **EAT** (**Export Address Table**) हुक। ये हुक **यूजरलैंड** से किए जा सकते हैं। लक्ष्य DLLs द्वारा निर्यातित फ़ंक्शंस को हुक करना है।
- **Inline Hooks**: इस प्रकार को प्राप्त करना कठिन है। इसमें फ़ंक्शंस के कोड को संशोधित करना शामिल है। शायद इसके शुरुआत में एक जंप डालकर।

## References

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)

{{#include ../banners/hacktricks-training.md}}
