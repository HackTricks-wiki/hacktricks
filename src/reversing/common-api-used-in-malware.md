# API courantes utilisées dans les logiciels malveillants

{{#include ../banners/hacktricks-training.md}}

## Générique

### Réseau

| Raw Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### TLS pinning and chunked transport

De nombreux loaders encapsulent leur flux TCP dans `SslStream` et pincent le certificat leaf du serveur contre une copie embarquée (certificate pinning). Les informations/tâches du bot sont compressées (par ex., GZip). Lorsque les réponses dépassent un seuil (~1 MB), les données sont fragmentées en petits morceaux (par ex., segments de 16 KB) pour éviter les heuristiques basées sur la taille et réduire les pics de mémoire lors de la désérialisation.


### Persistance

| Registre         | Fichier       | Service                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Chiffrement

| Nom                   |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### Anti-Analysis/VM

| Nom de la fonction                                       | Instructions assembleur |
| -------------------------------------------------------- | ----------------------- |
| IsDebuggerPresent()                                      | CPUID()                 |
| GetSystemInfo()                                          | IN()                    |
| GlobalMemoryStatusEx()                                   |                         |
| GetVersion()                                             |                         |
| CreateToolhelp32Snapshot \[Check if a process is running] |                         |
| CreateFileW/A \[Check if a file exist]                   |                         |

### Empreinte des API des émulateurs & évasion du sommeil

Les logiciels malveillants repèrent souvent les émulateurs de sandbox en recherchant les exports virtualisés de Defender (observés dans le Malware Protection Emulator). Si l'un de ces symboles est présent (scan insensible à la casse du processus), l'exécution est retardée de 10 à 30 minutes puis re-vérifiée pour faire perdre du temps à l'analyse.

Exemples de noms d'API utilisés comme canaris :
- `MpVmp32Entry`, `MpVmp32FastEnter`, `MpCallPreEntryPointCode`, `MpCallPostEntryPointCode`, `MpFinalize`, `MpReportEvent*`, `MpSwitchToNextThread*`
- `VFS_*` family: `VFS_Open`, `VFS_Read`, `VFS_MapViewOfFile`, `VFS_UnmapViewOfFile`, `VFS_FindFirstFile/FindNextFile`, `VFS_CopyFile`, `VFS_DeleteFile`, `VFS_MoveFile`
- `ThrdMgr_*`: `ThrdMgr_GetCurrentThreadHandle`, `ThrdMgr_SaveTEB`, `ThrdMgr_SwitchThreads`

Primitive de délai typique (user-land) :
```cmd
cmd /c timeout /t %RANDOM_IN_[600,1800]% > nul
```
Contrôle des arguments
- Les opérateurs exigent parfois qu’un switch CLI à l’apparence bénigne soit présent avant d’exécuter le payload (ex. `/i:--type=renderer` pour imiter les processus enfants de Chromium). Si le switch est absent, le loader quitte immédiatement, empêchant une exécution naïve en sandbox.


### Furtivité

| Name                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | Alloue de la mémoire (packers)                                             |
| VirtualProtect           | Modifie les permissions mémoire (packer donnant la permission d'exécution à une section) |
| ReadProcessMemory        | Injection dans des processus externes                                      |
| WriteProcessMemoryA/W    | Injection dans des processus externes                                      |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/Process injection...                                                   |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### Exécution

| Function Name    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### Divers

- GetAsyncKeyState() -- Key logging
- SetWindowsHookEx -- Key logging
- GetForeGroundWindow -- Obtenir le nom de la fenêtre active (ou le site ouvert dans un navigateur)
- LoadLibrary() -- Importer une librairie
- GetProcAddress() -- Importer une fonction d'une librairie
- CreateToolhelp32Snapshot() -- Lister les processus en cours
- GetDC() -- Capture d’écran
- BitBlt() -- Capture d’écran
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- Accéder à Internet
- FindResource(), LoadResource(), LockResource() -- Accéder aux ressources de l’exécutable

## Malware Techniques

### DLL Injection

Execute an arbitrary DLL inside another process

1. Localiser le processus à injecter : CreateToolhelp32Snapshot, Process32First, Process32Next
2. Ouvrir le processus : GetModuleHandle, GetProcAddress, OpenProcess
3. Écrire le chemin vers la DLL à l’intérieur du processus : VirtualAllocEx, WriteProcessMemory
4. Créer un thread dans le processus qui chargera la DLL malveillante : CreateRemoteThread, LoadLibrary

Autres fonctions à utiliser : NTCreateThreadEx, RtlCreateUserThread

### Reflective DLL Injection

Load a malicious DLL without calling normal Windows API calls.\
The DLL is mapped inside a process, it will resolve the import addresses, fix the relocations and call the DllMain function.

### Thread Hijacking

Find a thread from a process and make it load a malicious DLL

1. Trouver un thread cible : CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. Ouvrir le thread : OpenThread
3. Suspendre le thread : SuspendThread
4. Écrire le chemin vers la DLL malveillante dans le processus victime : VirtualAllocEx, WriteProcessMemory
5. Reprendre le thread pour charger la librairie : ResumeThread

### PE Injection

Portable Execution Injection : l’exécutable est écrit dans la mémoire du processus victime et y est exécuté directement.

### Process Hollowing (a.k.a **RunPE**)

`Process Hollowing` est l’une des techniques favorites d’**defence-evasion / execution** utilisées par les malwares Windows. L’idée est de lancer un processus *légitime* en état **suspendu**, de retirer (hollow) son image originale en mémoire et d’y copier un **PE arbitraire** à la place. Quand le thread principal est finalement repris, le point d’entrée malveillant s’exécute sous couvert d’un binaire de confiance (souvent signé par Microsoft).

Flux de travail typique :

1. Lancer un hôte bénin (ex. `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`) **suspendu** afin qu’aucune instruction ne s’exécute encore.
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. Lire le payload malveillant en mémoire et parser ses en-têtes PE pour obtenir `SizeOfImage`, les sections et le nouveau `EntryPoint`.
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – désmapper la base d’image originale du processus suspendu.
4. **VirtualAllocEx** – réserver de la mémoire RWX de `SizeOfImage` à l’intérieur du processus distant.
5. **WriteProcessMemory** – copier d’abord les `Headers`, puis itérer sur les sections en copiant leurs données brutes.
6. **SetThreadContext** – modifier la valeur de EAX/RAX (RCX sur x64) ou Rip dans la structure de contexte afin que EIP pointe vers l’EntryPoint du payload.
7. **ResumeThread** – le thread reprend, exécutant le code fourni par l’attaquant.

Minimal proof-of-concept (x86) skeleton:
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
Remarques pratiques observées dans la campagne **DarkCloud Stealer** :

* Le loader a choisi `RegAsm.exe` (part of the .NET Framework) comme hôte – un binaire signé peu susceptible d'attirer l'attention.
* Le stealer VB6 déchiffré (`holographies.exe`) n'est *pas* déposé sur le disque ; il n'existe que dans le processus hollowed, rendant la détection statique plus difficile.
* Les chaînes sensibles (regexes, paths, Telegram credentials) sont **RC4-encrypted** par chaîne et ne sont décryptées qu'à l'exécution, compliquant davantage l'analyse mémoire.

Idées de détection :
* Alerter sur les processus `CREATE_SUSPENDED` qui ne créent jamais de fenêtres GUI/console avant qu'une région mémoire soit allouée en **RWX** (peu fréquent pour du code légitime).
* Rechercher une séquence d'appels `NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory` entre différents processus.



## Hooking

- Le **SSDT** (**System Service Descriptor Table**) pointe vers des fonctions kernel (ntoskrnl.exe) ou le driver GUI (win32k.sys) afin que les processus utilisateur puissent appeler ces fonctions.
- Un rootkit peut modifier ces pointeurs vers des adresses qu'il contrôle.
- Les **IRP** (**I/O Request Packets**) transmettent des morceaux de données d'un composant à un autre. Presque tout dans le kernel utilise des IRPs et chaque device object a sa propre table de fonctions qui peut être hookée : DKOM (Direct Kernel Object Manipulation)
- L'**IAT** (**Import Address Table**) est utile pour résoudre les dépendances. Il est possible de hooker cette table afin de détourner le code qui sera appelé.
- **EAT** (**Export Address Table**) Hooks. Ces hooks peuvent être faits depuis le **userland**. Le but est de hooker les fonctions exportées par les DLLs.
- **Inline Hooks** : ce type est difficile à réaliser. Cela implique de modifier le code des fonctions elles-mêmes, par exemple en plaçant un jump au début.


## Références

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)
- [Check Point Research – Under the Pure Curtain: From RAT to Builder to Coder](https://research.checkpoint.com/2025/under-the-pure-curtain-from-rat-to-builder-to-coder/)

{{#include ../banners/hacktricks-training.md}}
