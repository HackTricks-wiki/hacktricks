# API comuni usati nel Malware

{{#include ../banners/hacktricks-training.md}}

## Generico

### Networking

| Raw Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### Persistenza

| Registry         | File          | Service                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Crittografia

| Nome                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### Anti-Analisi/VM

| Nome della Funzione                                             | Istruzioni Assembly |
| --------------------------------------------------------------- | ------------------- |
| IsDebuggerPresent()                                           | CPUID()             |
| GetSystemInfo()                                              | IN()                |
| GlobalMemoryStatusEx()                                       |                     |
| GetVersion()                                                 |                     |
| CreateToolhelp32Snapshot \[Controlla se un processo è in esecuzione] |                     |
| CreateFileW/A \[Controlla se un file esiste]                  |                     |

### Stealth

| Nome                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | Allocare memoria (packers)                                               |
| VirtualProtect           | Cambiare i permessi di memoria (packer che fornisce permessi di esecuzione a una sezione) |
| ReadProcessMemory        | Iniezione in processi esterni                                            |
| WriteProcessMemoryA/W    | Iniezione in processi esterni                                            |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | Iniezione di DLL/processo...                                             |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### Esecuzione

| Nome della Funzione    |
| ---------------------- |
| CreateProcessA/W      |
| ShellExecute           |
| WinExec                |
| ResumeThread           |
| NtResumeThread         |

### Varie

- GetAsyncKeyState() -- Key logging
- SetWindowsHookEx -- Key logging
- GetForeGroundWindow -- Ottieni il nome della finestra in esecuzione (o il sito web da un browser)
- LoadLibrary() -- Importa libreria
- GetProcAddress() -- Importa libreria
- CreateToolhelp32Snapshot() -- Elenca i processi in esecuzione
- GetDC() -- Screenshot
- BitBlt() -- Screenshot
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- Accesso a Internet
- FindResource(), LoadResource(), LockResource() -- Accesso alle risorse dell'eseguibile

## Tecniche Malware

### Iniezione DLL

Eseguire una DLL arbitraria all'interno di un altro processo

1. Individuare il processo in cui iniettare la DLL malevola: CreateToolhelp32Snapshot, Process32First, Process32Next
2. Aprire il processo: GetModuleHandle, GetProcAddress, OpenProcess
3. Scrivere il percorso della DLL all'interno del processo: VirtualAllocEx, WriteProcessMemory
4. Creare un thread nel processo che caricherà la DLL malevola: CreateRemoteThread, LoadLibrary

Altre funzioni da utilizzare: NTCreateThreadEx, RtlCreateUserThread

### Iniezione DLL Riflessiva

Caricare una DLL malevola senza chiamare le normali API di Windows.\
La DLL è mappata all'interno di un processo, risolverà gli indirizzi di importazione, correggerà le rilocazioni e chiamerà la funzione DllMain.

### Hijacking del Thread

Trovare un thread da un processo e farlo caricare una DLL malevola

1. Trovare un thread target: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. Aprire il thread: OpenThread
3. Sospendere il thread: SuspendThread
4. Scrivere il percorso della DLL malevola all'interno del processo vittima: VirtualAllocEx, WriteProcessMemory
5. Riprendere il thread caricando la libreria: ResumeThread

### Iniezione PE

Iniezione di Esecuzione Portatile: L'eseguibile sarà scritto nella memoria del processo vittima e verrà eseguito da lì.

### Hollowing del Processo (alias **RunPE**)

`Process Hollowing` è uno dei trucchi preferiti per **evitare la difesa / esecuzione** utilizzati dal malware di Windows. L'idea è di avviare un processo *legittimo* nello stato **sospeso**, rimuovere (hollow) la sua immagine originale dalla memoria e copiare un **PE arbitrario** al suo posto. Quando il thread principale viene finalmente ripreso, il punto di ingresso malevolo viene eseguito sotto le spoglie di un binario fidato (spesso firmato da Microsoft).

Flusso di lavoro tipico:

1. Generare un host benigno (ad es. `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`) **sospeso** in modo che nessuna istruzione venga eseguita ancora.
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. Leggere il payload malevolo in memoria e analizzare i suoi header PE per ottenere `SizeOfImage`, sezioni e il nuovo `EntryPoint`.
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – rimuovere la base dell'immagine originale del processo sospeso.
4. **VirtualAllocEx** – riservare memoria RWX di `SizeOfImage` all'interno del processo remoto.
5. **WriteProcessMemory** – copiare prima gli `Headers`, quindi iterare sulle sezioni copiando i loro dati grezzi.
6. **SetThreadContext** – patchare il valore di `EAX/RAX` (`RCX` su x64) o `Rip` nella struttura di contesto in modo che `EIP` punti all'`EntryPoint` del payload.
7. **ResumeThread** – il thread continua, eseguendo il codice fornito dall'attaccante.

Prova di concetto minima (x86) scheletro:
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
Note pratiche osservate nella campagna **DarkCloud Stealer**:

* Il loader ha scelto `RegAsm.exe` (parte del .NET Framework) come host – un binario firmato che è improbabile attiri attenzione.
* Il VB6 stealer decrittografato (`holographies.exe`) *non* viene salvato su disco; esiste solo all'interno del processo svuotato, rendendo più difficile la rilevazione statica.
* Le stringhe sensibili (regex, percorsi, credenziali di Telegram) sono **RC4-encrypted** per stringa e vengono decrittografate solo a runtime, complicando ulteriormente la scansione della memoria.

Idee per la rilevazione:
* Allerta su processi `CREATE_SUSPENDED` che non creano mai finestre GUI/console prima che una regione di memoria venga allocata come **RWX** (raro per codice benigno).
* Cerca una sequenza di chiamate `NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory` tra diversi processi.

## Hooking

- La **SSDT** (**System Service Descriptor Table**) punta a funzioni del kernel (ntoskrnl.exe) o driver GUI (win32k.sys) in modo che i processi utente possano chiamare queste funzioni.
- Un rootkit può modificare questi puntatori a indirizzi che controlla.
- **IRP** (**I/O Request Packets**) trasmettono pezzi di dati da un componente all'altro. Quasi tutto nel kernel utilizza IRP e ogni oggetto dispositivo ha la propria tabella di funzioni che può essere hookata: DKOM (Direct Kernel Object Manipulation).
- La **IAT** (**Import Address Table**) è utile per risolvere le dipendenze. È possibile hookare questa tabella per dirottare il codice che verrà chiamato.
- **EAT** (**Export Address Table**) Hooks. Questi hook possono essere effettuati da **userland**. L'obiettivo è hookare le funzioni esportate dalle DLL.
- **Inline Hooks**: Questo tipo è difficile da realizzare. Questo comporta la modifica del codice delle funzioni stesse. Forse mettendo un salto all'inizio di queste.

## References

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)

{{#include ../banners/hacktricks-training.md}}
