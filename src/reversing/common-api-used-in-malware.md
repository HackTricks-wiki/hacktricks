# API communes utilisées dans le Malware

{{#include ../banners/hacktricks-training.md}}

## Générique

### Réseau

| Raw Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### TLS pinning and chunked transport

De nombreux loaders encapsulent leur flux TCP dans `SslStream` et pin le certificat leaf du serveur contre une copie embarquée (certificate pinning). Les infos/tâches du bot sont compressées (p. ex., GZip). Quand les réponses dépassent un seuil (~1 MB), les données sont fragmentées en petits morceaux (p. ex., segments de 16 KB) pour éviter les heuristiques basées sur la taille et réduire les pics mémoire lors de la désérialisation.


### Persistance

| Registry         | File          | Service                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Chiffrement

| Name                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### Anti-Analyse/VM

| Function Name                                             | Assembly Instructions |
| --------------------------------------------------------- | --------------------- |
| IsDebuggerPresent()                                       | CPUID()               |
| GetSystemInfo()                                           | IN()                  |
| GlobalMemoryStatusEx()                                    |                       |
| GetVersion()                                              |                       |
| CreateToolhelp32Snapshot \[Check if a process is running] |                       |
| CreateFileW/A \[Check if a file exist]                    |                       |

### Garde d'exécution basée sur la locale/le clavier

Many stealers/loaders abort on certain locales to evade researchers and comply with threat-actor constraints. Vérifications typiques :
- `GetKeyboardLayout` pour énumérer les layouts installés (par thread/utilisateur)
- `GetLocaleInfoA/W` pour résoudre les codes pays/région
- `GetSystemDefaultLangID` / `GetUserDefaultLangID`

Si l'un d'eux correspond à une liste bloquée (souvent les pays de la CIS), le loader quitte immédiatement avant toute IOC réseau ou injection.

Défense / chasse aux menaces
- Signaler les processus qui interrogent plusieurs API locale/keyboard tôt dans l'exécution puis quittent sans activité observable.
- Corréler avec les checks anti-VM (chaînes BIOS, périphériques PnP, modèle de disque, services) réutilisés depuis des projets open-source (p. ex., VMDetector) pour détecter l'exécution conditionnée.

### Empreinte des API d'émulateur & évasion du sommeil

Le malware fingerprint souvent les sandbox emulators en recherchant les exports virtualisés de Defender (vus dans le Malware Protection Emulator). Si l'un de ces symboles est présent (scan insensible à la casse du process), l'exécution est retardée de 10–30 minutes puis re-testée pour gaspiller du temps d'analyse.

Exemples de noms d'API utilisés comme canaris :
- `MpVmp32Entry`, `MpVmp32FastEnter`, `MpCallPreEntryPointCode`, `MpCallPostEntryPointCode`, `MpFinalize`, `MpReportEvent*`, `MpSwitchToNextThread*`
- famille `VFS_*` : `VFS_Open`, `VFS_Read`, `VFS_MapViewOfFile`, `VFS_UnmapViewOfFile`, `VFS_FindFirstFile/FindNextFile`, `VFS_CopyFile`, `VFS_DeleteFile`, `VFS_MoveFile`
- `ThrdMgr_*` : `ThrdMgr_GetCurrentThreadHandle`, `ThrdMgr_SaveTEB`, `ThrdMgr_SwitchThreads`

Primitive de délai typique (user-land) :
```cmd
cmd /c timeout /t %RANDOM_IN_[600,1800]% > nul
```
Argument gatekeeping
- Les opérateurs exigent parfois qu'un switch CLI d'apparence bénigne soit présent avant d'exécuter le payload (par ex., `/i:--type=renderer` pour imiter les Chromium child processes). Si le switch est absent, le loader se termine immédiatement, empêchant une exécution naïve dans un sandbox.


### Furtivité

| Name                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | Alloc memory (packers)                                                     |
| VirtualProtect           | Change memory permission (packer giving execution permission to a section) |
| ReadProcessMemory        | Injection into external processes                                          |
| WriteProcessMemoryA/W    | Injection into external processes                                          |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/Process injection...                                                   |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### Exécution

| Function Name    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### Divers

- GetAsyncKeyState() -- Key logging
- SetWindowsHookEx -- Key logging
- GetForeGroundWindow -- Get running window name (or the website from a browser)
- LoadLibrary() -- Import library
- GetProcAddress() -- Import library
- CreateToolhelp32Snapshot() -- List running processes
- GetDC() -- Screenshot
- BitBlt() -- Screenshot
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- Access the Internet
- FindResource(), LoadResource(), LockResource() -- Access resources of the executable

## Malware Techniques

### DLL Injection

Execute an arbitrary DLL inside another process

1. Localiser le processus dans lequel injecter la DLL malveillante : CreateToolhelp32Snapshot, Process32First, Process32Next
2. Ouvrir le processus : GetModuleHandle, GetProcAddress, OpenProcess
3. Écrire le chemin vers la DLL dans le processus : VirtualAllocEx, WriteProcessMemory
4. Créer un thread dans le processus qui chargera la DLL malveillante : CreateRemoteThread, LoadLibrary

Other functions to use: NTCreateThreadEx, RtlCreateUserThread

### Reflective DLL Injection

Load a malicious DLL without calling normal Windows API calls.\
La DLL est mappée dans un processus, elle résoudra les adresses d'importation, corrigera les relocations et appellera la fonction DllMain.

### Thread Hijacking

Find a thread from a process and make it load a malicious DLL

1. Trouver un thread cible : CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. Ouvrir le thread : OpenThread
3. Suspendre le thread : SuspendThread
4. Écrire le chemin vers la DLL malveillante dans le processus victime : VirtualAllocEx, WriteProcessMemory
5. Reprendre le thread pour charger la bibliothèque : ResumeThread

### PE Injection

Portable Execution Injection: The executable will be written in the memory of the victim process and it will be executed from there.

### Process Hollowing (a.k.a **RunPE**)

`Process Hollowing` is one of the favourite **defence-evasion / execution** tricks used by Windows malware.  L'idée est de lancer un processus légitime en état **suspendu**, retirer (hollow) son image originale de la mémoire et y copier un **PE arbitraire** à la place. Lorsque le thread principal est finalement repris, le point d'entrée malveillant s'exécute sous l'apparence d'un binaire de confiance (souvent signé par Microsoft).

Flux de travail typique :

1. Lancer un hôte bénin (par ex. `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`) **suspendu** de sorte qu'aucune instruction ne s'exécute encore.
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. Lire le payload malveillant en mémoire et parser ses en-têtes PE pour obtenir `SizeOfImage`, les sections et le nouveau `EntryPoint`.
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – démapper l'image d'origine du processus suspendu.
4. **VirtualAllocEx** – réserver de la mémoire RWX de `SizeOfImage` à l'intérieur du processus distant.
5. **WriteProcessMemory** – copier d'abord les `Headers`, puis itérer sur les sections en copiant leurs données brutes.
6. **SetThreadContext** – patcher la valeur de `EAX/RAX` (`RCX` on x64) ou `Rip` dans la structure de contexte afin que `EIP` pointe vers l'`EntryPoint` du payload.
7. **ResumeThread** – le thread reprend, exécutant le code fourni par l'attaquant.

Minimal proof-of-concept (x86) skeleton:
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
Notes pratiques observées dans la campagne **DarkCloud Stealer** :

* The loader picked `RegAsm.exe` (part of the .NET Framework) as host – a signed binary unlikely to draw attention.
* The decrypted VB6 stealer (`holographies.exe`) is *not* dropped on disk; it only ever exists inside the hollowed process making static detection harder.
* Sensitive strings (regexes, paths, Telegram credentials) are **RC4-encrypted** per-string and only decrypted at runtime, further complicating memory scanning.

Detection ideas:
* Alerter sur les processus `CREATE_SUSPENDED` qui ne créent jamais de fenêtres GUI/console avant qu'une région mémoire ne soit allouée en **RWX** (rare pour du code bénin).
* Rechercher une séquence d'appels `NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory` entre différents processus.
* Usage inhabituel d'utilitaires développeur fiables comme hollowing hosts, en particulier `MSBuild.exe`, `RegAsm.exe`, `rundll32.exe`, ayant pour parent des loaders de courte durée.
* Chasser `msbuild.exe` lancé depuis des chemins modifiables par l'utilisateur ou sans contexte `.sln/.proj` correspondant, puis établissant des connexions sortantes (ATT&CK T1127.001 + T1055.012).

Common host processes and path resolution
- `MSBuild.exe` est fréquemment choisi comme hollowing host pour se fondre dans les outils de développement. Les loaders recherchent souvent les emplacements adaptés à l'architecture :
- `C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe`
- `C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe`
- `C:\Windows\System32\MSBuild.exe`
- `C:\Windows\SysWOW64\MSBuild.exe`
- Select the host matching the current payload/OS architecture before calling `CreateProcess(..., CREATE_SUSPENDED, ...)`.



## Hooking

- The **SSDT** (**System Service Descriptor Table**) points to kernel functions (ntoskrnl.exe) or GUI driver (win32k.sys) so user processes can call these functions.
- Un rootkit peut modifier ces pointeurs vers des adresses qu'il contrôle
- **IRP** (**I/O Request Packets**) transmettent des portions de données d'un composant à un autre. Presque tout dans le kernel utilise des IRP et chaque device object a sa propre table de fonctions qui peut être hookée: DKOM (Direct Kernel Object Manipulation)
- The **IAT** (**Import Address Table**) is useful to resolve dependencies. It's possible to hook this table in order to hijack the code that will be called.
- **EAT** (**Export Address Table**) Hooks. This hooks can be done from **userland**. The goal is to hook exported functions by DLLs.
- **Inline Hooks**: This type are difficult to achieve. This involve modifying the code of the functions itself. Maybe by putting a jump at the beginning of this.


## References

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)
- [Check Point Research – Under the Pure Curtain: From RAT to Builder to Coder](https://research.checkpoint.com/2025/under-the-pure-curtain-from-rat-to-builder-to-coder/)
- [Unit 42 – PhantomVAI Loader Delivers a Range of Infostealers](https://unit42.paloaltonetworks.com/phantomvai-loader-delivers-infostealers/)
- [MITRE ATT&CK – Trusted Developer Utilities Proxy Execution: MSBuild (T1127.001)](https://attack.mitre.org/techniques/T1127/001/)
- [VMDetector – virtualization checks (open-source)](https://github.com/robsonfelix/VMDetector)

{{#include ../banners/hacktricks-training.md}}
