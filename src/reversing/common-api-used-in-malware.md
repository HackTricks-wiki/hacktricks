# Gemeinsame API, die in Malware verwendet wird

{{#include ../banners/hacktricks-training.md}}

## Allgemein

### Netzwerk

| Raw Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### Persistenz

| Registry         | Datei         | Dienst                       |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Verschlüsselung

| Name                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### Anti-Analyse/VM

| Funktionsname                                             | Assemblierungsanweisungen |
| --------------------------------------------------------- | -------------------------- |
| IsDebuggerPresent()                                       | CPUID()                   |
| GetSystemInfo()                                          | IN()                      |
| GlobalMemoryStatusEx()                                   |                            |
| GetVersion()                                             |                            |
| CreateToolhelp32Snapshot \[Überprüfen, ob ein Prozess läuft] |                            |
| CreateFileW/A \[Überprüfen, ob eine Datei existiert]     |                            |

### Tarnung

| Name                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | Speicher zuweisen (Packers)                                               |
| VirtualProtect           | Ändern der Speicherberechtigung (Packer gibt Ausführungsberechtigung für einen Abschnitt) |
| ReadProcessMemory        | In externe Prozesse injizieren                                            |
| WriteProcessMemoryA/W    | In externe Prozesse injizieren                                            |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/Prozessinjektion...                                                  |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### Ausführung

| Funktionsname    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### Verschiedenes

- GetAsyncKeyState() -- Tastaturprotokollierung
- SetWindowsHookEx -- Tastaturprotokollierung
- GetForeGroundWindow -- Den Namen des aktiven Fensters abrufen (oder die Website aus einem Browser)
- LoadLibrary() -- Bibliothek importieren
- GetProcAddress() -- Bibliothek importieren
- CreateToolhelp32Snapshot() -- Laufende Prozesse auflisten
- GetDC() -- Screenshot
- BitBlt() -- Screenshot
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- Zugriff auf das Internet
- FindResource(), LoadResource(), LockResource() -- Zugriff auf Ressourcen der ausführbaren Datei

## Malware-Techniken

### DLL-Injektion

Führen Sie eine beliebige DLL in einem anderen Prozess aus

1. Lokalisieren Sie den Prozess, um die bösartige DLL zu injizieren: CreateToolhelp32Snapshot, Process32First, Process32Next
2. Öffnen Sie den Prozess: GetModuleHandle, GetProcAddress, OpenProcess
3. Schreiben Sie den Pfad zur DLL in den Prozess: VirtualAllocEx, WriteProcessMemory
4. Erstellen Sie einen Thread im Prozess, der die bösartige DLL lädt: CreateRemoteThread, LoadLibrary

Andere Funktionen, die verwendet werden können: NTCreateThreadEx, RtlCreateUserThread

### Reflexive DLL-Injektion

Laden Sie eine bösartige DLL, ohne normale Windows-API-Aufrufe zu tätigen.\
Die DLL wird innerhalb eines Prozesses abgebildet, sie wird die Importadressen auflösen, die Relokationen beheben und die DllMain-Funktion aufrufen.

### Thread-Hijacking

Finden Sie einen Thread aus einem Prozess und lassen Sie ihn eine bösartige DLL laden

1. Finden Sie einen Ziel-Thread: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. Öffnen Sie den Thread: OpenThread
3. Pausieren Sie den Thread: SuspendThread
4. Schreiben Sie den Pfad zur bösartigen DLL in den Opferprozess: VirtualAllocEx, WriteProcessMemory
5. Setzen Sie den Thread fort, der die Bibliothek lädt: ResumeThread

### PE-Injektion

Portable Execution Injection: Die ausführbare Datei wird im Speicher des Opferprozesses geschrieben und von dort ausgeführt.

### Process Hollowing (auch bekannt als **RunPE**)

`Process Hollowing` ist einer der bevorzugten **Verteidigungsumgehungs-/Ausführungstricks**, die von Windows-Malware verwendet werden. Die Idee ist, einen *legitimen* Prozess im **ausgesetzten** Zustand zu starten, sein ursprüngliches Bild aus dem Speicher zu entfernen (auszuhöhlen) und eine **beliebige PE** an seiner Stelle zu kopieren. Wenn der primäre Thread schließlich fortgesetzt wird, wird der bösartige Einstiegspunkt unter dem Deckmantel einer vertrauenswürdigen Binärdatei (oft von Microsoft signiert) ausgeführt.

Typischer Arbeitsablauf:

1. Starten Sie einen harmlosen Host (z. B. `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`) **ausgesetzt**, sodass noch keine Anweisungen ausgeführt werden.
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. Lesen Sie die bösartige Nutzlast in den Speicher und analysieren Sie ihre PE-Header, um `SizeOfImage`, Abschnitte und den neuen `EntryPoint` zu erhalten.
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – die ursprüngliche Bildbasis des ausgesetzten Prozesses unmappen.
4. **VirtualAllocEx** – RWX-Speicher von `SizeOfImage` im Remote-Prozess reservieren.
5. **WriteProcessMemory** – zuerst die `Headers` kopieren, dann über die Abschnitte iterieren und deren Rohdaten kopieren.
6. **SetThreadContext** – den Wert von `EAX/RAX` (`RCX` auf x64) oder `Rip` in der Kontextstruktur patchen, sodass `EIP` auf den `EntryPoint` der Nutzlast zeigt.
7. **ResumeThread** – der Thread wird fortgesetzt und führt den vom Angreifer bereitgestellten Code aus.

Minimales Proof-of-Concept (x86) Skelett:
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
Praktische Hinweise, die in der **DarkCloud Stealer**-Kampagne beobachtet wurden:

* Der Loader wählte `RegAsm.exe` (Teil des .NET Framework) als Host – eine signierte Binärdatei, die wahrscheinlich keine Aufmerksamkeit erregt.
* Der entschlüsselte VB6 Stealer (`holographies.exe`) wird *nicht* auf der Festplatte abgelegt; er existiert nur im gehöhlten Prozess, was die statische Erkennung erschwert.
* Sensible Strings (Regex, Pfade, Telegram-Anmeldeinformationen) sind **RC4-verschlüsselt** pro String und werden nur zur Laufzeit entschlüsselt, was das Scannen des Speichers weiter kompliziert.

Erkennungsideen:
* Alarm bei `CREATE_SUSPENDED`-Prozessen, die niemals GUI-/Konsolenfenster erstellen, bevor ein Speicherbereich als **RWX** (selten für gutartigen Code) zugewiesen wird.
* Suchen Sie nach einer Aufrufsequenz `NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory` über verschiedene Prozesse hinweg.

## Hooking

- Die **SSDT** (**System Service Descriptor Table**) verweist auf Kernel-Funktionen (ntoskrnl.exe) oder GUI-Treiber (win32k.sys), sodass Benutzerprozesse diese Funktionen aufrufen können.
- Ein Rootkit kann diese Zeiger auf Adressen ändern, die es kontrolliert.
- **IRP** (**I/O Request Packets**) übertragen Datenstücke von einer Komponente zur anderen. Fast alles im Kernel verwendet IRPs, und jedes Geräteobjekt hat seine eigene Funktionstabelle, die gehookt werden kann: DKOM (Direct Kernel Object Manipulation).
- Die **IAT** (**Import Address Table**) ist nützlich, um Abhängigkeiten aufzulösen. Es ist möglich, diese Tabelle zu hooken, um den Code zu übernehmen, der aufgerufen wird.
- **EAT** (**Export Address Table**) Hooks. Diese Hooks können aus **userland** durchgeführt werden. Das Ziel ist es, exportierte Funktionen von DLLs zu hooken.
- **Inline Hooks**: Diese Art ist schwierig zu erreichen. Dies beinhaltet die Modifikation des Codes der Funktionen selbst, möglicherweise durch das Setzen eines Sprungs am Anfang.

## References

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)

{{#include ../banners/hacktricks-training.md}}
