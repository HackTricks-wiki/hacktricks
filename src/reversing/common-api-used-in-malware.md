# Algemene API's wat in Malware gebruik word

{{#include ../banners/hacktricks-training.md}}

## Generies

### Netwerk

| Rauwe Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### Volharding

| Registrasie         | Lêer          | Diens                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Enkripsie

| Naam                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### Anti-Analise/VM

| Funksie Naam                                             | Assembly Instruksies |
| --------------------------------------------------------- | --------------------- |
| IsDebuggerPresent()                                       | CPUID()               |
| GetSystemInfo()                                           | IN()                  |
| GlobalMemoryStatusEx()                                    |                       |
| GetVersion()                                              |                       |
| CreateToolhelp32Snapshot \[Kontroleer of 'n proses loop\] |                       |
| CreateFileW/A \[Kontroleer of 'n lêer bestaan\]          |                       |

### Stealth

| Naam                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | Toewys geheue (packers)                                                  |
| VirtualProtect           | Verander geheue toestemming (packer gee uitvoerings toestemming aan 'n afdeling) |
| ReadProcessMemory        | Inspuiting in eksterne prosesse                                          |
| WriteProcessMemoryA/W    | Inspuiting in eksterne prosesse                                          |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/Proses inspuiting...                                                 |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### Uitvoering

| Funksie Naam    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### Divers

- GetAsyncKeyState() -- Sleutel logging
- SetWindowsHookEx -- Sleutel logging
- GetForeGroundWindow -- Kry die naam van die lopende venster (of die webwerf van 'n blaaier)
- LoadLibrary() -- Importeer biblioteek
- GetProcAddress() -- Importeer biblioteek
- CreateToolhelp32Snapshot() -- Lys lopende prosesse
- GetDC() -- Skermskoot
- BitBlt() -- Skermskoot
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- Toegang tot die Internet
- FindResource(), LoadResource(), LockResource() -- Toegang tot hulpbronne van die uitvoerbare

## Malware Tegnieke

### DLL Inspuiting

Voer 'n arbitrêre DLL binne 'n ander proses uit

1. Vind die proses om die kwaadwillige DLL in te spuit: CreateToolhelp32Snapshot, Process32First, Process32Next
2. Maak die proses oop: GetModuleHandle, GetProcAddress, OpenProcess
3. Skryf die pad na die DLL binne die proses: VirtualAllocEx, WriteProcessMemory
4. Skep 'n draad in die proses wat die kwaadwillige DLL sal laai: CreateRemoteThread, LoadLibrary

Ander funksies om te gebruik: NTCreateThreadEx, RtlCreateUserThread

### Reflektiewe DLL Inspuiting

Laai 'n kwaadwillige DLL sonder om normale Windows API-oproepe te doen.\
Die DLL word binne 'n proses gemap, dit sal die invoeradresse oplos, die herlokasies regmaak en die DllMain-funksie aanroep.

### Draad Hijacking

Vind 'n draad van 'n proses en laat dit 'n kwaadwillige DLL laai

1. Vind 'n teiken draad: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. Maak die draad oop: OpenThread
3. Suspend die draad: SuspendThread
4. Skryf die pad na die kwaadwillige DLL binne die slagoffer proses: VirtualAllocEx, WriteProcessMemory
5. Herbegin die draad wat die biblioteek laai: ResumeThread

### PE Inspuiting

Portabele Uitvoering Inspuiting: Die uitvoerbare sal in die geheue van die slagoffer proses geskryf word en daarvandaan uitgevoer word.

### Proses Hollowing (ook bekend as **RunPE**)

`Process Hollowing` is een van die gunsteling **verdediging-ontwyking / uitvoering** truuks wat deur Windows malware gebruik word. Die idee is om 'n *legitieme* proses in die **gesuspendeerde** toestand te begin, die oorspronklike beeld uit geheue te verwyder (hol) en 'n **arbitrêre PE** in sy plek te kopieer. Wanneer die primêre draad uiteindelik herbegin word, voer die kwaadwillige toegangspunt uit onder die dekmantel van 'n vertroude binêre (dikwels deur Microsoft onderteken).

Tipiese werksvloei:

1. Begin 'n goedaardige gasheer (bv. `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`) **gesuspendeer** sodat geen instruksies nog loop nie.
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. Lees die kwaadwillige payload in geheue en ontleed sy PE kopstukke om `SizeOfImage`, afdelings en die nuwe `EntryPoint` te verkry.
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – ontkoppel die oorspronklike beeldbasis van die gesuspendeerde proses.
4. **VirtualAllocEx** – reserveer RWX geheue van `SizeOfImage` binne die afgeleë proses.
5. **WriteProcessMemory** – kopieer die `Headers` eerste, dan oor afdelings iterasie en kopieer hul ruwe data.
6. **SetThreadContext** – patch die waarde van `EAX/RAX` (`RCX` op x64) of `Rip` in die konteksstruktuur sodat `EIP` na die payload se `EntryPoint` wys.
7. **ResumeThread** – die draad gaan voort, en voer die aanvaller-geleverde kode uit.

Minimale bewys-van-konsep (x86) skelet:
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
Praktiese notas waargeneem in die **DarkCloud Stealer** veldtog:

* Die loader het `RegAsm.exe` (deel van die .NET Framework) as gasheer gekies – 'n ondertekende binêre wat onwaarskynlik aandag sal trek.
* Die gedekripteerde VB6 stealer (`holographies.exe`) word *nie* op skyf gelaat nie; dit bestaan slegs binne die uitgeholde proses, wat statiese opsporing moeiliker maak.
* Sensitiewe strings (regexes, paaie, Telegram akrediteer) is **RC4-geënkripteer** per string en word slegs tydens uitvoering gedekripteer, wat geheue skandering verder kompliseer.

Opsporingsidees:
* Alarmeer op `CREATE_SUSPENDED` prosesse wat nooit GUI/konsole vensters skep voordat 'n geheuegebied as **RWX** (selde vir goedaardige kode) toegeken word nie.
* Soek vir 'n oproepvolgorde `NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory` oor verskillende prosesse.

## Hooking

- Die **SSDT** (**System Service Descriptor Table**) verwys na kernfunksies (ntoskrnl.exe) of GUI stuurprogram (win32k.sys) sodat gebruikersprosesse hierdie funksies kan aanroep.
- 'n Rootkit kan hierdie wysers na adresse wat hy beheer, verander.
- **IRP** (**I/O Request Packets**) stuur stukke data van een komponent na 'n ander. Byna alles in die kern gebruik IRP's en elke toestelobjek het sy eie funksietabel wat gehook kan word: DKOM (Direct Kernel Object Manipulation)
- Die **IAT** (**Import Address Table**) is nuttig om afhanklikhede op te los. Dit is moontlik om hierdie tabel te hook om die kode wat aangeroep sal word, te kap.
- **EAT** (**Export Address Table**) Hooks. Hierdie hooks kan vanaf **userland** gedoen word. Die doel is om geexporteerde funksies deur DLL's te hook.
- **Inline Hooks**: Hierdie tipe is moeilik om te bereik. Dit behels die aanpassing van die kode van die funksies self. Miskien deur 'n sprongetjie aan die begin hiervan te plaas.

## References

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)

{{#include ../banners/hacktricks-training.md}}
