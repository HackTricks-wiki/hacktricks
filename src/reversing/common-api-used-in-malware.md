# Common API used in Malware

{{#include ../banners/hacktricks-training.md}}

## सामान्य

### नेटवर्किंग

| Raw Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### TLS pinning and chunked transport

कई loaders अपने TCP स्ट्रीम को `SslStream` से रैप करते हैं और सर्वर के leaf certificate को एम्बेडेड कॉपी के खिलाफ पिन करते हैं (certificate pinning)। Bot info/tasks को कम्प्रेस किया जाता है (उदा., `GZip`)। जब responses किसी थ्रेशोल्ड (~1 MB) से अधिक होते हैं, तो डेटा को छोटे chunk में विभाजित किया जाता है (उदा., 16 KB segments) ताकि size-based heuristics से बचा जा सके और deserialisation के दौरान memory spikes कम हों।

### Persistence

| Registry         | File          | Service                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Encryption

| Name                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### Anti-Analysis/VM

| Function Name                                             | Assembly Instructions |
| --------------------------------------------------------- | --------------------- |
| IsDebuggerPresent()                                       | CPUID()               |
| GetSystemInfo()                                           | IN()                  |
| GlobalMemoryStatusEx()                                    |                       |
| GetVersion()                                              |                       |
| CreateToolhelp32Snapshot \[Check if a process is running] |                       |
| CreateFileW/A \[Check if a file exist]                    |                       |

### Locale/keyboard-based execution guard

कई stealers/loaders कुछ विशेष लोकेल पर तुरंत रुक जाते हैं ताकि researchers से बचा जा सके और threat-actor constraints का पालन किया जा सके। सामान्य चेक:
- `GetKeyboardLayout` से installed layouts (per-thread/user) की सूची प्राप्त करना
- `GetLocaleInfoA/W` से country/region codes का निर्धारण
- `GetSystemDefaultLangID` / `GetUserDefaultLangID`

यदि इनमें से कोई भी blocked list (आम तौर पर CIS देशों) से मेल खाता है, तो loader नेटवर्क IOCs या injection से पहले तुरंत exit कर देता है।

रक्षा/हंटिंग
- उन प्रक्रियाओं को फ्लैग करें जो execution के शुरुआती चरणों में कई locale/keyboard APIs को query करती हैं और फिर बिना observable activity के exit करती हैं।
- ओपन-सोर्स प्रोजेक्ट्स (उदा., VMDetector) से reuse किए गए anti-VM checks (BIOS strings, PnP devices, disk model, services) के साथ correlate करें ताकि gated execution पकड़ी जा सके।

### Emulator API fingerprinting & sleep evasion

Malware अक्सर sandbox emulators को fingerprint करता है by searching for Defender’s virtualised exports (Malware Protection Emulator में देखा गया)। यदि इनमे से कोई symbol मौजूद पाया जाता है (process का case-insensitive scan), तो execution को 10–30 मिनट के लिए delay किया जाता है और फिर re-check किया जाता है ताकि analysis time बर्बाद हो।

canaries के रूप में उपयोग किए जाने वाले API नामों के उदाहरण:
- `MpVmp32Entry`, `MpVmp32FastEnter`, `MpCallPreEntryPointCode`, `MpCallPostEntryPointCode`, `MpFinalize`, `MpReportEvent*`, `MpSwitchToNextThread*`
- `VFS_*` परिवार: `VFS_Open`, `VFS_Read`, `VFS_MapViewOfFile`, `VFS_UnmapViewOfFile`, `VFS_FindFirstFile/FindNextFile`, `VFS_CopyFile`, `VFS_DeleteFile`, `VFS_MoveFile`
- `ThrdMgr_*`: `ThrdMgr_GetCurrentThreadHandle`, `ThrdMgr_SaveTEB`, `ThrdMgr_SwitchThreads`

Typical delay primitive (user-land):
```cmd
cmd /c timeout /t %RANDOM_IN_[600,1800]% > nul
```
Argument gatekeeping
- ऑपरेटर्स कभी-कभी payload चलाने से पहले एक benign-looking CLI switch मौजूद होने की मांग करते हैं (उदा., `/i:--type=renderer` to mimic Chromium child processes). अगर switch अनुपस्थित है, तो loader तुरंत exit कर देता है, जिससे naive sandbox execution बाधित होती है।


### Stealth

| Name                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | मेमोरी आवंटित करना (packers)                                               |
| VirtualProtect           | मेमोरी की अनुमति बदलना (packer जो किसी section को execution permission देता है) |
| ReadProcessMemory        | बाहरी processes में injection                                               |
| WriteProcessMemoryA/W    | बाहरी processes में injection                                               |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/Process injection...                                                   |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### Execution

| Function Name    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### Miscellaneous

- GetAsyncKeyState() -- कीलॉगिंग
- SetWindowsHookEx -- कीलॉगिंग
- GetForeGroundWindow -- चल रहे window का नाम प्राप्त करना (या ब्राउज़र से वेबसाइट)
- LoadLibrary() -- लाइब्रेरी import करना
- GetProcAddress() -- लाइब्रेरी से फ़ंक्शन प्राप्त करना
- CreateToolhelp32Snapshot() -- चल रहे processes की सूची
- GetDC() -- स्क्रीनशॉट
- BitBlt() -- स्क्रीनशॉट
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- Internet तक पहुँच
- FindResource(), LoadResource(), LockResource() -- executable के resources तक पहुँच

## Malware Techniques

### DLL Injection

Execute an arbitrary DLL inside another process

1. malicious DLL को inject करने के लिए target process खोजें: CreateToolhelp32Snapshot, Process32First, Process32Next
2. process खोलें: GetModuleHandle, GetProcAddress, OpenProcess
3. DLL का path victim process के अंदर लिखें: VirtualAllocEx, WriteProcessMemory
4. process में एक thread बनाकर malicious DLL load करवाएँ: CreateRemoteThread, LoadLibrary

Other functions to use: NTCreateThreadEx, RtlCreateUserThread

### Reflective DLL Injection

Load a malicious DLL without calling normal Windows API calls.\
DLL को एक process के अंदर map किया जाता है, यह import addresses resolve करेगा, relocations ठीक करेगा और DllMain फ़ंक्शन कॉल करेगा।

### Thread Hijacking

किसी process के thread को ढूँढकर उसे malicious DLL load करवाना

1. target thread खोजें: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. thread खोलें: OpenThread
3. thread को suspend करें: SuspendThread
4. victim process के अंदर malicious DLL का path लिखें: VirtualAllocEx, WriteProcessMemory
5. thread resume करें ताकि library लोड हो: ResumeThread

### PE Injection

Portable Execution Injection: executable को victim process की memory में लिखा जाएगा और वहाँ से execute किया जाएगा।

### Process Hollowing (a.k.a **RunPE**)

`Process Hollowing` Windows malware द्वारा उपयोग की जाने वाली लोकप्रिय **defence-evasion / execution** tricks में से एक है। विचार यह है कि एक *कानूनी* process को **suspended** state में लॉन्च किया जाए, उसके original image को memory से हटाया (hollow) जाए और उसकी जगह एक **arbitrary PE** कॉपी कर दी जाए। जब primary thread finally resume होता है तो malicious entry-point एक trusted binary (अक्सर Microsoft द्वारा signed) के रूप में execute करता है।

Typical workflow:

1. एक benign host (उदा., `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`) **suspended** स्थिति में spawn करें ताकि अभी कोई instructions न चलें।
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. malicious payload को memory में पढ़ें और उसके PE headers parse करें ताकि `SizeOfImage`, sections और नए `EntryPoint` मिल सकें।
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – suspended process के original image base को unmap करें।
4. **VirtualAllocEx** – remote process के अंदर `SizeOfImage` के लिए RWX memory रिज़र्व करें।
5. **WriteProcessMemory** – पहले `Headers` कॉपी करें, फिर sections पर iterate करके उनकी raw data कॉपी करें।
6. **SetThreadContext** – context structure में `EAX/RAX` (`RCX` on x64) या `Rip` का मान patch करें ताकि `EIP` payload के `EntryPoint` की ओर इशारा करे।
7. **ResumeThread** – thread जारी रहता है और attacker-supplied code execute होता है।

Minimal proof-of-concept (x86) skeleton:
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
प्रैक्टिकल नोट्स जो **DarkCloud Stealer** अभियान में देखे गए:

* लोडर ने `RegAsm.exe` (.NET Framework का हिस्सा) को host के रूप में चुना – एक signed binary जो ध्यान आकर्षित करने की संभावना कम रखती है।
* डिक्रिप्ट किया गया VB6 stealer (`holographies.exe`) डिस्क पर *नहीं* छोड़ा जाता; यह केवल hollowed process के अंदर मौजूद रहता है, जिससे static detection कठिन हो जाती है।
* संवेदनशील स्ट्रिंग्स (regexes, paths, Telegram credentials) को प्रति-स्टリング **RC4-encrypted** किया गया है और केवल runtime पर डिक्रिप्ट किया जाता है, जिससे memory scanning और भी जटिल हो जाती है।

Detection ideas:
* ऐसे `CREATE_SUSPENDED` processes पर अलर्ट करें जो GUI/console विंडो कभी नहीं बनाते और उसके बाद किसी memory region को **RWX** के रूप में allocate किया जाता है (benign code के लिए यह दुर्लभ है)।
* विभिन्न processes में call sequence `NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory` की तलाश करें।
* trusted developer utilities का असामान्य उपयोग hollowing hosts के रूप में, खासकर `MSBuild.exe`, `RegAsm.exe`, `rundll32.exe`, जो short-lived loaders द्वारा parent किए गए हों।
* ऐसी स्थितियों की तलाश करें जहाँ `msbuild.exe` user-writable paths से spawn हुआ हो या संबंधित `.sln/.proj` context के बिना हो और फिर outbound connections बना रहा हो (ATT&CK T1127.001 + T1055.012).

Common host processes and path resolution
- `MSBuild.exe` अक्सर hollowing host के रूप में चुना जाता है ताकि यह developer tooling में घुल-मिल जाए। Loaders अक्सर आर्किटेक्चर-उपयुक्त स्थानों में खोज करते हैं:
- `C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe`
- `C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe`
- `C:\Windows\System32\MSBuild.exe`
- `C:\Windows\SysWOW64\MSBuild.exe`
- CreateProcess(..., CREATE_SUSPENDED, ...) को कॉल करने से पहले current payload/OS architecture से मेल खाता host चुनें।



## Hooking

- The **SSDT** (**System Service Descriptor Table**) kernel functions (ntoskrnl.exe) या GUI driver (win32k.sys) की ओर इशारा करता है ताकि user processes इन functions को कॉल कर सकें।
- एक rootkit इन pointers को ऐसे addresses में modify कर सकता है जिन्हें वह नियंत्रित करता है
- **IRP** (**I/O Request Packets**) एक component से दूसरे component तक data के टुकड़े transmit करते हैं। kernel में लगभग हर चीज IRPs का उपयोग करती है और प्रत्येक device object का अपना function table होता है जिसे hook किया जा सकता है: DKOM (Direct Kernel Object Manipulation)
- The **IAT** (**Import Address Table**) dependencies resolve करने के लिए उपयोगी है। इस table को hook करके उस code को hijack करना संभव है जिसे कॉल किया जाएगा।
- **EAT** (**Export Address Table**) Hooks। ये hooks **userland** से किए जा सकते हैं। लक्ष्य DLLs द्वारा exported functions को hook करना है।
- **Inline Hooks**: इस प्रकार को हासिल करना कठिन है। इसमें functions के code को modify करना शामिल है। संभवतः इसके शुरुआत में एक jump डालकर।


## References

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)
- [Check Point Research – Under the Pure Curtain: From RAT to Builder to Coder](https://research.checkpoint.com/2025/under-the-pure-curtain-from-rat-to-builder-to-coder/)
- [Unit 42 – PhantomVAI Loader Delivers a Range of Infostealers](https://unit42.paloaltonetworks.com/phantomvai-loader-delivers-infostealers/)
- [MITRE ATT&CK – Trusted Developer Utilities Proxy Execution: MSBuild (T1127.001)](https://attack.mitre.org/techniques/T1127/001/)
- [VMDetector – virtualization checks (open-source)](https://github.com/robsonfelix/VMDetector)

{{#include ../banners/hacktricks-training.md}}
