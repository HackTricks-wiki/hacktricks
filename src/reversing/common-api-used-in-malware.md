# 常见 API 在 Malware 中使用

{{#include ../banners/hacktricks-training.md}}

## 通用

### 网络

| 原始 Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### TLS pinning and chunked transport

Many loaders wrap their TCP stream in `SslStream` 并将服务器的 leaf certificate 与嵌入的副本进行 pin（certificate pinning）。Bot info/tasks 会被压缩（例如，`GZip`）。当响应超过阈值（约 ~1 MB）时，数据会被分片为小块（例如 16 KB 段），以避免基于大小的启发式检测并减少反序列化期间的内存峰值。

### 持久化

| 注册表         | 文件          | 服务                         |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### 加密

| 名称                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### 反分析/VM

| 函数名                                             | 汇编指令 |
| ------------------------------------------------- | -------- |
| IsDebuggerPresent()                                | CPUID()  |
| GetSystemInfo()                                    | IN()     |
| GlobalMemoryStatusEx()                             |          |
| GetVersion()                                       |          |
| CreateToolhelp32Snapshot \[Check if a process is running] |          |
| CreateFileW/A \[Check if a file exist]             |          |

### Emulator API fingerprinting & sleep evasion

Malware 经常通过搜索 Defender 的虚拟化导出（见 Malware Protection Emulator）来指纹化 sandbox emulators。如果检测到这些符号中的任何一个（对进程进行大小写不敏感的扫描），执行会被延迟 10–30 分钟并重新检查，以浪费分析时间。

作为检测用的 API 名称示例：
- `MpVmp32Entry`, `MpVmp32FastEnter`, `MpCallPreEntryPointCode`, `MpCallPostEntryPointCode`, `MpFinalize`, `MpReportEvent*`, `MpSwitchToNextThread*`
- `VFS_*` 系列：`VFS_Open`, `VFS_Read`, `VFS_MapViewOfFile`, `VFS_UnmapViewOfFile`, `VFS_FindFirstFile/FindNextFile`, `VFS_CopyFile`, `VFS_DeleteFile`, `VFS_MoveFile`
- `ThrdMgr_*`: `ThrdMgr_GetCurrentThreadHandle`, `ThrdMgr_SaveTEB`, `ThrdMgr_SwitchThreads`

典型的延迟原语（用户态）：
```cmd
cmd /c timeout /t %RANDOM_IN_[600,1800]% > nul
```
Argument gatekeeping
- 操作员有时要求在运行 payload 之前存在一个看起来无害的 CLI 开关（例如 `/i:--type=renderer` 用于模拟 Chromium 子进程）。如果缺少该开关，loader 会立即退出，从而阻止简单的沙箱执行。


### Stealth

| Name                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | 分配内存 (packers)                                                         |
| VirtualProtect           | 更改内存权限 (packer giving execution permission to a section)            |
| ReadProcessMemory        | 注入到外部进程                                                              |
| WriteProcessMemoryA/W    | 注入到外部进程                                                              |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/Process injection...                                                   |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### Execution

| Function Name    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### Miscellaneous

- GetAsyncKeyState() -- 按键记录
- SetWindowsHookEx -- 按键记录
- GetForeGroundWindow -- 获取运行窗口名称（或浏览器中的网站）
- LoadLibrary() -- 导入库
- GetProcAddress() -- 导入库
- CreateToolhelp32Snapshot() -- 列出运行中的进程
- GetDC() -- 截图
- BitBlt() -- 截图
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- 访问互联网
- FindResource(), LoadResource(), LockResource() -- 访问可执行文件的资源

## Malware Techniques

### DLL Injection

Execute an arbitrary DLL inside another process

1. 定位要注入恶意 DLL 的进程：CreateToolhelp32Snapshot, Process32First, Process32Next
2. 打开该进程：GetModuleHandle, GetProcAddress, OpenProcess
3. 在进程内写入 DLL 路径：VirtualAllocEx, WriteProcessMemory
4. 在进程中创建一个将加载恶意 DLL 的线程：CreateRemoteThread, LoadLibrary

Other functions to use: NTCreateThreadEx, RtlCreateUserThread

### Reflective DLL Injection

Load a malicious DLL without calling normal Windows API calls.\
The DLL is mapped inside a process, it will resolve the import addresses, fix the relocations and call the DllMain function.

### Thread Hijacking

Find a thread from a process and make it load a malicious DLL

1. 找到目标线程：CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. 打开线程：OpenThread
3. 挂起线程：SuspendThread
4. 在受害进程内写入恶意 DLL 的路径：VirtualAllocEx, WriteProcessMemory
5. 恢复线程以加载库：ResumeThread

### PE Injection

Portable Execution Injection: 可执行文件将被写入受害进程内存并从那里执行。

### Process Hollowing (a.k.a **RunPE**)

`Process Hollowing` is one of the favourite **defence-evasion / execution** tricks used by Windows malware.  The idea is to launch a *legitimate* process in the **suspended** state, remove (hollow) its original image from memory and copy an **arbitrary PE** in its place.  When the primary thread is finally resumed the malicious entry-point executes under the guise of a trusted binary (often signed by Microsoft).

典型工作流程：

1. 启动一个良性宿主（例如 `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`）并置于挂起状态，这样还不会执行任何指令。
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. 将恶意 payload 读取到内存并解析其 PE 头以获取 `SizeOfImage`、节和新的 `EntryPoint`。
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – 解除挂起进程的原始映像基址映射。
4. **VirtualAllocEx** – 在远程进程内部为 `SizeOfImage` 保留 RWX 内存。
5. **WriteProcessMemory** – 先复制 `Headers`，然后遍历各节并复制它们的原始数据。
6. **SetThreadContext** – 修补上下文结构中 `EAX/RAX`（x64 为 `RCX`）或 `Rip` 的值，使 `EIP` 指向 payload 的 `EntryPoint`。
7. **ResumeThread** – 线程继续执行，运行攻击者提供的代码。

Minimal proof-of-concept (x86) skeleton:
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
在 **DarkCloud Stealer** 活动中观察到的实用笔记：

* loader 选择 `RegAsm.exe`（属于 .NET Framework）作为宿主 —— 一个签名的二进制文件，不太可能引起注意。
* 解密后的 VB6 stealer (`holographies.exe`) *不会* 被写入磁盘；它仅存在于 hollowed process 中，这使得静态检测更加困难。
* 敏感字符串（regexes、paths、Telegram credentials）对每个字符串使用 **RC4** 加密，并且仅在 runtime 时解密，进一步增加 memory scanning 的难度。

检测思路：
* 对那些创建后处于 `CREATE_SUSPENDED` 且在被分配为 **RWX** 内存区域之前从未创建 GUI/console 窗口的进程触发告警（良性代码很少这样）。
* 在不同进程之间寻找调用序列 `NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory`。



## Hooking

- **SSDT** (**System Service Descriptor Table**) 指向内核函数 (ntoskrnl.exe) 或 GUI 驱动 (win32k.sys)，因此用户进程可以调用这些函数。
- rootkit 可能修改这些指针，使其指向攻击者可控的地址。
- **IRP** (**I/O Request Packets**) 将数据片段从一个组件传递到另一个组件。内核中几乎所有东西都使用 IRPs，并且每个 device object 都有自己的函数表，可以被 hook：DKOM (Direct Kernel Object Manipulation)
- **IAT** (**Import Address Table**) 有助于解析依赖关系。可以 hook 该表以劫持将被调用的代码。
- **EAT** (**Export Address Table**) Hooks。此类 hooks 可以在 **userland** 中完成。目标是 hook DLL 导出的函数。
- **Inline Hooks**：这类较难实现。涉及修改函数本身的代码，例如在函数开头放置一个 jump。


## References

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)
- [Check Point Research – Under the Pure Curtain: From RAT to Builder to Coder](https://research.checkpoint.com/2025/under-the-pure-curtain-from-rat-to-builder-to-coder/)

{{#include ../banners/hacktricks-training.md}}
