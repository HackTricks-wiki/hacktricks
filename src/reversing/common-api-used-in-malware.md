# Malware'de Yaygın Olarak Kullanılan API'ler

{{#include ../banners/hacktricks-training.md}}

## Genel

### Ağ

| Ham Soketler  | WinAPI Soketleri |
| ------------- | ----------------- |
| socket()      | WSAStratup()      |
| bind()        | bind()            |
| listen()      | listen()          |
| accept()      | accept()          |
| connect()     | connect()         |
| read()/recv() | recv()            |
| write()       | send()            |
| shutdown()    | WSACleanup()      |

### TLS pinning ve chunked transport

Birçok loader TCP akışını `SslStream` ile sarar ve sunucunun leaf sertifikasını gömülü bir kopyaya karşı sabitler (certificate pinning). Bot bilgileri/görevleri genellikle sıkıştırılır (ör. GZip). Yanıtlar belirli bir eşiği (~1 MB) aştığında, veriler boyuta dayalı heuristiklerden kaçınmak ve deserializasyon sırasında bellek piklerini azaltmak için küçük parçalara (ör. 16 KB segmentler) bölünür.

### Kalıcılık

| Kayıt Defteri    | Dosya         | Servis                       |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Şifreleme

| İsim                 |
| -------------------- |
| WinCrypt             |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### Anti-Analiz/VM

| Fonksiyon Adı                                             | Assembly Komutları |
| --------------------------------------------------------- | ------------------ |
| IsDebuggerPresent()                                       | CPUID()            |
| GetSystemInfo()                                           | IN()               |
| GlobalMemoryStatusEx()                                    |                    |
| GetVersion()                                              |                    |
| CreateToolhelp32Snapshot \[Bir işlemin çalışıp çalışmadığını kontrol et] |                    |
| CreateFileW/A \[Bir dosyanın varlığını kontrol et]        |                    |

### Emülatör API parmak izi çıkarma ve uyku kaçınma

Malware genellikle sandbox emülatörlerini, Malware Protection Emulator'da görüldüğü gibi Defender’ın sanallaştırılmış exports'larını arayarak parmak izi çıkarır. Bu sembollerden herhangi biri tespit edilirse (proses içinde büyük-küçük harfe duyarsız tarama), yürütme 10–30 dakika geciktirilir ve analiz süresini tüketmek için yeniden kontrol edilir.

Canary olarak kullanılan API isimlerine örnekler:
- `MpVmp32Entry`, `MpVmp32FastEnter`, `MpCallPreEntryPointCode`, `MpCallPostEntryPointCode`, `MpFinalize`, `MpReportEvent*`, `MpSwitchToNextThread*`
- `VFS_*` ailesi: `VFS_Open`, `VFS_Read`, `VFS_MapViewOfFile`, `VFS_UnmapViewOfFile`, `VFS_FindFirstFile/FindNextFile`, `VFS_CopyFile`, `VFS_DeleteFile`, `VFS_MoveFile`
- `ThrdMgr_*`: `ThrdMgr_GetCurrentThreadHandle`, `ThrdMgr_SaveTEB`, `ThrdMgr_SwitchThreads`

Tipik gecikme primitifi (kullanıcı modu):
```cmd
cmd /c timeout /t %RANDOM_IN_[600,1800]% > nul
```
Argument gatekeeping
- Operatörler bazen yük çalıştırılmadan önce zararsız görünen bir CLI switch'in bulunmasını isterler (ör. `/i:--type=renderer` Chromium'un alt süreçlerini taklit etmek için). Eğer switch yoksa, loader hemen çıkarak basit sandbox çalıştırmasını engeller.


### Gizlenme

| İsim                    |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | Bellek ayırma (packers)                                                    |
| VirtualProtect           | Bellek izinlerini değiştirme (bir packer'ın bir bölüme çalıştırma izni vermesi) |
| ReadProcessMemory        | Harici süreçlere enjeksiyon                                                |
| WriteProcessMemoryA/W    | Harici süreçlere enjeksiyon                                                |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/Process enjeksiyonu...                                                  |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### Çalıştırma

| Fonksiyon Adı    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### Diğer

- GetAsyncKeyState() -- Tuş kaydı
- SetWindowsHookEx -- Tuş kaydı
- GetForeGroundWindow -- Çalışan pencere adını al (veya bir tarayıcıdan web sitesi)
- LoadLibrary() -- Kütüphane yükleme
- GetProcAddress() -- Kütüphane import etme
- CreateToolhelp32Snapshot() -- Çalışan süreçleri listeleme
- GetDC() -- Ekran görüntüsü alma
- BitBlt() -- Ekran görüntüsü alma
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- İnternete erişim
- FindResource(), LoadResource(), LockResource() -- Çalıştırılabilir dosyanın kaynaklarına erişim

## Malware Teknikleri

### DLL Injection

Execute an arbitrary DLL inside another process

1. Locate the process to inject the malicious DLL: CreateToolhelp32Snapshot, Process32First, Process32Next
2. Open the process: GetModuleHandle, GetProcAddress, OpenProcess
3. Write the path to the DLL inside the process: VirtualAllocEx, WriteProcessMemory
4. Create a thread in the process that will load the malicious DLL: CreateRemoteThread, LoadLibrary

Kullanılabilecek diğer fonksiyonlar: NTCreateThreadEx, RtlCreateUserThread

### Reflective DLL Injection

Load a malicious DLL without calling normal Windows API calls.\\
DLL bir süreç içine eşlenir, import adreslerini çözer, relocasyonları düzeltir ve DllMain fonksiyonunu çağırır.

### Thread Hijacking

Find a thread from a process and make it load a malicious DLL

1. Find a target thread: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. Open the thread: OpenThread
3. Suspend the thread: SuspendThread
4. Write the path to the malicious DLL inside the victim process: VirtualAllocEx, WriteProcessMemory
5. Resume the thread loading the library: ResumeThread

### PE Injection

Portable Execution Injection: Çalıştırılabilir dosya mağdur sürecin belleğine yazılır ve oradan çalıştırılır.

### Process Hollowing (a.k.a **RunPE**)

Process Hollowing, Windows malware tarafından kullanılan en popüler savunma-atlatma / yürütme hilelerinden biridir. Fikir, *meşru* bir süreci **askıya alınmış** durumda başlatmak, belleğinden orijinal imajını çıkarmak (hollow) ve yerine **keyfi bir PE** kopyalamaktır. Birincil thread nihayet yeniden başlatıldığında, zararlı giriş noktası genellikle Microsoft tarafından imzalanmış güvenilir bir ikili dosya kisvesi altında çalışır.

Tipik iş akışı:

1. Zararsız bir host oluştur (örn. `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`) **askıya alınmış** olarak başlat, böylece henüz hiçbir talimat çalışmaz.
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. Zararlı payload'u belleğe oku ve PE başlıklarını parse ederek `SizeOfImage`, bölümleri ve yeni `EntryPoint`'i elde et.
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – askıya alınmış sürecin orijinal imaj tabanını unmap et.
4. **VirtualAllocEx** – uzak süreç içinde `SizeOfImage` kadar RWX bellek ayır.
5. **WriteProcessMemory** – önce `Headers`'ı kopyala, sonra bölümler üzerinde döngü yapıp ham verilerini kopyala.
6. **SetThreadContext** – context yapısındaki `EAX/RAX` (`x64'te RCX`) veya `Rip` değerini patchleyerek `EIP`'in payload'un `EntryPoint`'ine işaret etmesini sağla.
7. **ResumeThread** – thread devam eder ve saldırgan tarafından sağlanan kodu çalıştırır.

Minimal proof-of-concept (x86) iskeleti:
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
Practical notes observed in the **DarkCloud Stealer** campaign:

* The loader picked `RegAsm.exe` (part of the .NET Framework) as host – a signed binary unlikely to draw attention.
* The decrypted VB6 stealer (`holographies.exe`) is *not* dropped on disk; it only ever exists inside the hollowed process making static detection harder.
* Sensitive strings (regexes, paths, Telegram credentials) are **RC4-encrypted** per-string and only decrypted at runtime, further complicating memory scanning.

Detection ideas:
* Alert on `CREATE_SUSPENDED` processes that never create GUI/console windows before a memory region is allocated as **RWX** (rare for benign code).
* Look for a call sequence `NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory` across different processes.



## Hooking

- The **SSDT** (**System Service Descriptor Table**) points to kernel functions (ntoskrnl.exe) or GUI driver (win32k.sys) so user processes can call these functions.
- A rootkit may modify these pointer to addresses that he controls
- **IRP** (**I/O Request Packets**) transmit pieces of data from one component to another. Almost everything in the kernel uses IRPs and each device object has its own function table that can be hooked: DKOM (Direct Kernel Object Manipulation)
- The **IAT** (**Import Address Table**) is useful to resolve dependencies. It's possible to hook this table in order to hijack the code that will be called.
- **EAT** (**Export Address Table**) Hooks. This hooks can be done from **userland**. The goal is to hook exported functions by DLLs.
- **Inline Hooks**: This type are difficult to achieve. This involve modifying the code of the functions itself. Maybe by putting a jump at the beginning of this.


## References

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)
- [Check Point Research – Under the Pure Curtain: From RAT to Builder to Coder](https://research.checkpoint.com/2025/under-the-pure-curtain-from-rat-to-builder-to-coder/)

{{#include ../banners/hacktricks-training.md}}
