# API za kawaida zinazotumiwa katika Malware

{{#include ../banners/hacktricks-training.md}}

## Msingi

### Mtandao

| Raw Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### TLS pinning and chunked transport

Loaders wengi huweka TCP stream yao ndani ya `SslStream` na hupiga alama cheti la leaf la server dhidi ya nakala iliyojumuishwa (certificate pinning). Taarifa/majukumu ya bot zimefinywa (e.g., GZip). Wakati majibu yanapozidi kikomo (~1 MB), data hugawanywa katika vipande vidogo (e.g., 16 KB segments) ili kuepuka heuristics zinazotegemea ukubwa na kupunguza milipuko ya kumbukumbu wakati wa deserialisation.


### Persistence

| Registry         | File          | Service                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### Encryption

| Name                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### Anti-Analysis/VM

| Function Name                                             | Assembly Instructions |
| --------------------------------------------------------- | --------------------- |
| IsDebuggerPresent()                                       | CPUID()               |
| GetSystemInfo()                                           | IN()                  |
| GlobalMemoryStatusEx()                                    |                       |
| GetVersion()                                              |                       |
| CreateToolhelp32Snapshot \[Check if a process is running] |                       |
| CreateFileW/A \[Check if a file exist]                    |                       |

### Locale/keyboard-based execution guard

Wengi wa stealers/loaders huacha kukimbia kwa locales fulani ili kuepuka watafiti na kufuata vikwazo vya threat-actor. Ukaguzi wa kawaida:
- `GetKeyboardLayout` ili kuorodhesha layouts zilizo wekwa (kwa thread/user)
- `GetLocaleInfoA/W` ili kupata codes za nchi/eneo
- `GetSystemDefaultLangID` / `GetUserDefaultLangID`

Iwapo yoyote italingana na orodha iliyozuiwa (kwa kawaida nchi za CIS), loader huondoka mara moja kabla ya IOCs za mtandao au injection.

Defence/hunting
- Tia alama mchakato unaouliza APIs kadhaa za locale/keyboard mapema katika utekelezaji kisha unaacha bila shughuli za kuonekana.
- Linganisha na anti-VM checks (BIOS strings, PnP devices, disk model, services) zinazotumiwa tena kutoka kwa miradi ya open-source (e.g., VMDetector) kugundua utekelezaji uliogandishwa.

### Emulator API fingerprinting & sleep evasion

Malware mara nyingi huweka alama sanduku za majaribio na emulator kwa kutafuta exports za virtualised za Defender (zilizoonekana katika Malware Protection Emulator). Iwapo alama hizi yoyote zinapatikana (skani isiyoegemea case ya mchakato), utekelezaji huhamia kwa 10–30 dakika kisha kurudishwa kukaguliwa ili kupoteza muda wa uchambuzi.

Mifano ya majina ya API yanayotumiwa kama canaries:
- `MpVmp32Entry`, `MpVmp32FastEnter`, `MpCallPreEntryPointCode`, `MpCallPostEntryPointCode`, `MpFinalize`, `MpReportEvent*`, `MpSwitchToNextThread*`
- `VFS_*` family: `VFS_Open`, `VFS_Read`, `VFS_MapViewOfFile`, `VFS_UnmapViewOfFile`, `VFS_FindFirstFile/FindNextFile`, `VFS_CopyFile`, `VFS_DeleteFile`, `VFS_MoveFile`
- `ThrdMgr_*`: `ThrdMgr_GetCurrentThreadHandle`, `ThrdMgr_SaveTEB`, `ThrdMgr_SwitchThreads`

Typical delay primitive (user-land):
```cmd
cmd /c timeout /t %RANDOM_IN_[600,1800]% > nul
```
Argument gatekeeping
- Wakati mwingine operators wanataka switch ya CLI inayotokea kuwa isiyo hatari iwepo kabla ya kuendesha payload (mfano, `/i:--type=renderer` kuiga Chromium child processes). Ikiwa switch haipo, loader inatangazwa mara moja, ikizuia utekelezaji wa sandbox wa msingi.

### Usiri

| Name                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | Kutenga kumbukumbu (packers)                                               |
| VirtualProtect           | Badilisha ruhusa za kumbukumbu (packer akiipa sehemu ruhusa ya utekelezaji) |
| ReadProcessMemory        | Injection into external processes                                          |
| WriteProcessMemoryA/W    | Injection into external processes                                          |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/Process injection...                                                   |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### Utekelezaji

| Function Name    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### Mengineyo

- GetAsyncKeyState() -- Key logging
- SetWindowsHookEx -- Key logging
- GetForeGroundWindow -- Get running window name (or the website from a browser)
- LoadLibrary() -- Import library
- GetProcAddress() -- Import library
- CreateToolhelp32Snapshot() -- List running processes
- GetDC() -- Screenshot
- BitBlt() -- Screenshot
- InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- Access the Internet
- FindResource(), LoadResource(), LockResource() -- Access resources of the executable

## Mbinu za Malware

### DLL Injection

Execute an arbitrary DLL inside another process

1. Locate the process to inject the malicious DLL: CreateToolhelp32Snapshot, Process32First, Process32Next
2. Open the process: GetModuleHandle, GetProcAddress, OpenProcess
3. Write the path to the DLL inside the process: VirtualAllocEx, WriteProcessMemory
4. Create a thread in the process that will load the malicious DLL: CreateRemoteThread, LoadLibrary

Other functions to use: NTCreateThreadEx, RtlCreateUserThread

### Reflective DLL Injection

Load a malicious DLL without calling normal Windows API calls.\
The DLL is mapped inside a process, it will resolve the import addresses, fix the relocations and call the DllMain function.

### Thread Hijacking

Find a thread from a process and make it load a malicious DLL

1. Find a target thread: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. Open the thread: OpenThread
3. Suspend the thread: SuspendThread
4. Write the path to the malicious DLL inside the victim process: VirtualAllocEx, WriteProcessMemory
5. Resume the thread loading the library: ResumeThread

### PE Injection

Portable Execution Injection: The executable will be written in the memory of the victim process and it will be executed from there.

### Process Hollowing (a.k.a **RunPE**)

`Process Hollowing` ni mojawapo ya mbinu zinazopendwa za **defence-evasion / execution** zinazotumika na malware ya Windows. Wazo ni kuanzisha mchakato halali katika hali ya **imegandishwa**, kuondoa (hollow) picha yake ya awali kutoka kwenye kumbukumbu na kunakili **arbitrary PE** mahali pake. Wakati thread kuu inaporejeshwa, entry-point yenye madhara itaendeshwa ikitokea kama binary iliyothibitishwa (mara nyingi iliyosainiwa na Microsoft).

Mtiririko wa kawaida:

1. Spawn a benign host (e.g. `RegAsm.exe`, `rundll32.exe`, `msbuild.exe`) **imegandishwa** so that no instructions run yet.
```c
STARTUPINFOA  si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessA("C:\\Windows\\Microsoft.NET\\Framework32\\v4.0.30319\\RegAsm.exe",
NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
```
2. Read the malicious payload into memory and parse its PE headers to obtain `SizeOfImage`, sections and the new `EntryPoint`.
3. **NtUnmapViewOfSection** / **ZwUnmapViewOfSection** – ondoa ramani ya base ya picha ya awali ya mchakato uliogandishwa.
4. **VirtualAllocEx** – tenga kumbukumbu yenye RWX ya `SizeOfImage` ndani ya mchakato wa mbali.
5. **WriteProcessMemory** – nakili kwanza `Headers`, kisha pita sehemu kwa sehemu ukinakili data yao ghafi.
6. **SetThreadContext** – rekebisha thamani za `EAX/RAX` (`RCX` on x64) au `Rip` katika muundo wa context ili `EIP` iwe ikielekeza kwenye `EntryPoint` ya payload.
7. **ResumeThread** – thread inaendelea, ikitekeleza code iliyowasilishwa na mwizi.

Minimal proof-of-concept (x86) skeleton:
```c
void RunPE(LPCSTR host, LPVOID payload, DWORD payloadSize){
// 1. create suspended process
STARTUPINFOA si = {sizeof(si)}; PROCESS_INFORMATION pi;
CreateProcessA(host, NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,NULL,&si,&pi);

// 2. read remote PEB to get ImageBaseAddress
CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread,&ctx);
PVOID baseAddr;
ReadProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);

// 3. unmap original image & allocate new region at same base
NtUnmapViewOfSection(pi.hProcess,baseAddr);
PVOID newBase = VirtualAllocEx(pi.hProcess,baseAddr,pHdr->OptionalHeader.SizeOfImage,
MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
// 4-5. copy headers & sections …
// 6. write new image base into PEB and set Eip
WriteProcessMemory(pi.hProcess,(PVOID)(ctx.Ebx+8),&baseAddr,4,NULL);
ctx.Eax = (DWORD)(newBase) + pHdr->OptionalHeader.AddressOfEntryPoint;
SetThreadContext(pi.hThread,&ctx);
// 7. run!
ResumeThread(pi.hThread);
}
```
Vidokezo vya vitendo vilivyoonekana katika kampeni ya **DarkCloud Stealer**:

* The loader picked `RegAsm.exe` (part of the .NET Framework) as host – a signed binary unlikely to draw attention.
* VB6 stealer iliyofichuliwa (`holographies.exe`) hailetiwi kwenye diski; ipo tu ndani ya hollowed process, ikifanya utambuzi wa static kuwa mgumu zaidi.
* Sensitive strings (regexes, paths, Telegram credentials) are **RC4-encrypted** per-string and only decrypted at runtime, further complicating memory scanning.

Mawazo ya utambuzi:
* Toa onyo kwa processes za `CREATE_SUSPENDED` ambazo hazijaunda GUI/console windows kabla memory region itakapopangwa kama **RWX** (sio za kawaida kwa benign code).
* Tafuta mfululizo wa simu `NtUnmapViewOfSection ➜ VirtualAllocEx ➜ WriteProcessMemory` kati ya processes tofauti.
* Matumizi yasiyo ya kawaida ya trusted developer utilities kama hollowing hosts, hasa `MSBuild.exe`, `RegAsm.exe`, `rundll32.exe`, zikiwa parented na short-lived loaders.
* Tafuta `msbuild.exe` iliyozaliwa kutoka kwenye user-writable paths au bila muktadha wa `.sln/.proj` halafu inafanya outbound connections (ATT&CK T1127.001 + T1055.012).

Common host processes and path resolution
- `MSBuild.exe` mara nyingi huchaguliwa kama hollowing host ili kujificha kwa zana za developer. Loaders mara nyingi hufanya utafutaji kwa maeneo yanayofaa kwa architecture:
- `C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe`
- `C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe`
- `C:\Windows\System32\MSBuild.exe`
- `C:\Windows\SysWOW64\MSBuild.exe`
- Chagua host inayolingana na current payload/OS architecture kabla ya kuita `CreateProcess(..., CREATE_SUSPENDED, ...)`.



## Hooking

- The **SSDT** (**System Service Descriptor Table**) inaelekeza kwenye kernel functions (ntoskrnl.exe) au GUI driver (win32k.sys) ili user processes ziweze kuita functions hizi.
- Rootkit inaweza kubadilisha pointers hizi kuelekea anwani anazodhibiti.
- **IRP** (**I/O Request Packets**) husafirisha vipande vya data kutoka sehemu moja hadi nyingine. Karibu kila kitu katika kernel kinatumia IRPs na kila device object ina jedwali la function lake ambalo linaweza ku-hook: DKOM (Direct Kernel Object Manipulation)
- The **IAT** (**Import Address Table**) ni muhimu kutatua dependencies. Inawezekana ku-hook jedwali hili ili hijack code itakayoitwa.
- **EAT** (**Export Address Table**) Hooks. Hizi hooks zinaweza kufanywa kutoka **userland**. Lengo ni ku-hook exported functions by DLLs.
- **Inline Hooks**: Aina hii ni vigumu kufanikiwa. Inahusisha kubadilisha code ya functions yenyewe. Labda kwa kuweka jump mwanzoni mwa hizi.


## References

- [Unit42 – New Infection Chain and ConfuserEx-Based Obfuscation for DarkCloud Stealer](https://unit42.paloaltonetworks.com/new-darkcloud-stealer-infection-chain/)
- [Check Point Research – Under the Pure Curtain: From RAT to Builder to Coder](https://research.checkpoint.com/2025/under-the-pure-curtain-from-rat-to-builder-to-coder/)
- [Unit 42 – PhantomVAI Loader Delivers a Range of Infostealers](https://unit42.paloaltonetworks.com/phantomvai-loader-delivers-infostealers/)
- [MITRE ATT&CK – Trusted Developer Utilities Proxy Execution: MSBuild (T1127.001)](https://attack.mitre.org/techniques/T1127/001/)
- [VMDetector – virtualization checks (open-source)](https://github.com/robsonfelix/VMDetector)

{{#include ../banners/hacktricks-training.md}}
