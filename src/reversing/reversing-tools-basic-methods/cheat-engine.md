# Cheat Engine

{{#include ../../banners/hacktricks-training.md}}

[**Cheat Engine**](https://www.cheatengine.org/downloads.php) - це корисна програма для знаходження місць, де важливі значення зберігаються в пам'яті запущеної гри, та їх зміни.\
Коли ви завантажите та запустите її, вам буде **представлено** **посібник** з використання цього інструменту. Якщо ви хочете навчитися користуватися інструментом, настійно рекомендується його завершити.

## Що ви шукаєте?

![](<../../images/image (762).png>)

Цей інструмент дуже корисний для знаходження **місця, де деяке значення** (зазвичай число) **зберігається в пам'яті** програми.\
**Зазвичай числа** зберігаються у **4байтовій** формі, але ви також можете знайти їх у **подвійних** або **плаваючих** форматах, або ви можете шукати щось **інше, ніж число**. З цієї причини вам потрібно бути впевненим, що ви **обрали** те, що хочете **шукати**:

![](<../../images/image (324).png>)

Також ви можете вказати **різні** типи **пошуків**:

![](<../../images/image (311).png>)

Ви також можете відзначити поле, щоб **зупинити гру під час сканування пам'яті**:

![](<../../images/image (1052).png>)

### Гарячі клавіші

У _**Edit --> Settings --> Hotkeys**_ ви можете налаштувати різні **гарячі клавіші** для різних цілей, таких як **зупинка** **гри** (що дуже корисно, якщо в якийсь момент ви хочете просканувати пам'ять). Доступні й інші опції:

![](<../../images/image (864).png>)

## Модифікація значення

Якщо ви **знайшли**, де знаходиться **значення**, яке ви **шукаєте** (більше про це в наступних кроках), ви можете **змінити його**, двічі клацнувши на ньому, а потім двічі клацнувши на його значенні:

![](<../../images/image (563).png>)

І нарешті **позначивши галочку**, щоб внести зміни в пам'ять:

![](<../../images/image (385).png>)

**Зміна** в **пам'яті** буде негайно **застосована** (зверніть увагу, що поки гра не використовує це значення знову, значення **не буде оновлено в грі**).

## Пошук значення

Отже, ми будемо припускати, що є важливе значення (наприклад, життя вашого користувача), яке ви хочете покращити, і ви шукаєте це значення в пам'яті)

### Через відоме зміна

Припустимо, ви шукаєте значення 100, ви **виконуєте сканування**, шукаючи це значення, і знаходите багато збігів:

![](<../../images/image (108).png>)

Потім ви робите щось, щоб **значення змінилося**, і ви **зупиняєте** гру та **виконуєте** **наступне сканування**:

![](<../../images/image (684).png>)

Cheat Engine буде шукати **значення**, які **змінилися з 100 на нове значення**. Вітаємо, ви **знайшли** **адресу** значення, яке шукали, тепер ви можете його змінити.\
_Якщо у вас все ще є кілька значень, зробіть щось, щоб знову змінити це значення, і виконайте ще одне "наступне сканування", щоб відфільтрувати адреси._

### Невідоме значення, відоме зміна

У сценарії, коли ви **не знаєте значення**, але знаєте, **як його змінити** (і навіть значення зміни), ви можете шукати своє число.

Отже, почніть з виконання сканування типу "**Невідоме початкове значення**":

![](<../../images/image (890).png>)

Потім змініть значення, вкажіть, **як** **значення** **змінилося** (в моєму випадку воно зменшилося на 1) і виконайте **наступне сканування**:

![](<../../images/image (371).png>)

Вам буде представлено **всі значення, які були змінені обраним способом**:

![](<../../images/image (569).png>)

Коли ви знайдете своє значення, ви можете його змінити.

Зверніть увагу, що є **багато можливих змін**, і ви можете виконувати ці **кроки стільки, скільки хочете**, щоб відфільтрувати результати:

![](<../../images/image (574).png>)

### Випадкова адреса пам'яті - Знаходження коду

До цього моменту ми навчилися знаходити адресу, що зберігає значення, але дуже ймовірно, що в **різних виконаннях гри ця адреса знаходиться в різних місцях пам'яті**. Тож давайте дізнаємося, як завжди знаходити цю адресу.

Використовуючи деякі з згаданих трюків, знайдіть адресу, де ваша поточна гра зберігає важливе значення. Потім (зупинивши гру, якщо хочете) клацніть правою кнопкою миші на знайденій **адресі** та виберіть "**Дізнатися, що отримує доступ до цієї адреси**" або "**Дізнатися, що записує в цю адресу**":

![](<../../images/image (1067).png>)

**Перша опція** корисна для того, щоб дізнатися, які **частини** **коду** **використовують** цю **адресу** (що корисно для багатьох інших речей, таких як **знати, де ви можете змінити код** гри).\
**Друга опція** є більш **конкретною** і буде більш корисною в цьому випадку, оскільки нас цікавить, **звідки це значення записується**.

Після того, як ви виберете одну з цих опцій, **дебагер** буде **підключений** до програми, і з'явиться нове **порожнє вікно**. Тепер **грай** у **гру** та **змінюй** це **значення** (без перезапуску гри). **Вікно** повинно бути **заповнене** **адресами**, які **змінюють** **значення**:

![](<../../images/image (91).png>)

Тепер, коли ви знайшли адресу, яка змінює значення, ви можете **змінити код на свій розсуд** (Cheat Engine дозволяє вам швидко змінювати його на NOP):

![](<../../images/image (1057).png>)

Отже, ви можете змінити його так, щоб код не впливав на ваше число або завжди впливав позитивно.

### Випадкова адреса пам'яті - Знаходження вказівника

Слідуючи попереднім крокам, знайдіть, де знаходиться значення, яке вас цікавить. Потім, використовуючи "**Дізнатися, що записує в цю адресу**", дізнайтеся, яка адреса записує це значення, і двічі клацніть на ньому, щоб отримати вигляд дизасемблера:

![](<../../images/image (1039).png>)

Потім виконайте нове сканування, **шукаючи шістнадцяткове значення між "\[]"** (значення $edx у цьому випадку):

![](<../../images/image (994).png>)

(_Якщо з'явиться кілька, зазвичай вам потрібна найменша адреса_)\
Тепер ми **знайшли вказівник, який буде змінювати значення, яке нас цікавить**.

Клацніть на "**Додати адресу вручну**":

![](<../../images/image (990).png>)

Тепер клацніть на поле "Вказівник" і додайте знайдену адресу в текстове поле (в цьому сценарії знайдена адреса на попередньому зображенні була "Tutorial-i386.exe"+2426B0):

![](<../../images/image (392).png>)

(Зверніть увагу, що перша "Адреса" автоматично заповнюється з адреси вказівника, яку ви вводите)

Клацніть OK, і буде створено новий вказівник:

![](<../../images/image (308).png>)

Тепер, щоразу, коли ви змінюєте це значення, ви **змінюєте важливе значення, навіть якщо адреса пам'яті, де знаходиться значення, інша.**

### Ін'єкція коду

Ін'єкція коду - це техніка, коли ви вставляєте шматок коду в цільовий процес, а потім перенаправляєте виконання коду через свій власний написаний код (наприклад, надаючи вам бали замість їх зменшення).

Отже, уявіть, що ви знайшли адресу, яка віднімає 1 від життя вашого гравця:

![](<../../images/image (203).png>)

Клацніть на Показати дизасемблер, щоб отримати **дизасембльований код**.\
Потім натисніть **CTRL+a**, щоб викликати вікно Авто збірки та виберіть _**Шаблон --> Ін'єкція коду**_

![](<../../images/image (902).png>)

Заповніть **адресу інструкції, яку ви хочете змінити** (це зазвичай заповнюється автоматично):

![](<../../images/image (744).png>)

Шаблон буде згенеровано:

![](<../../images/image (944).png>)

Отже, вставте свій новий асемблерний код у секцію "**newmem**" і видаліть оригінальний код з секції "**originalcode**", якщо не хочете, щоб він виконувався. У цьому прикладі ін'єкційний код додасть 2 бали замість того, щоб віднімати 1:

![](<../../images/image (521).png>)

**Натисніть виконати, і ваш код повинен бути ін'єктований у програму, змінюючи поведінку функціональності!**

## Розширені функції в Cheat Engine 7.x (2023-2025)

Cheat Engine продовжує еволюціонувати з версії 7.0, і було додано кілька функцій, що підвищують зручність використання та *агресивного реверсінгу*, які є надзвичайно корисними при аналізі сучасного програмного забезпечення (і не тільки ігор!). Нижче наведено **дуже стисле польове керівництво** до доповнень, які ви, ймовірно, будете використовувати під час роботи в червоній команді/CTF.

### Поліпшення сканера вказівників 2
* `Вказівники повинні закінчуватися на конкретних зсувів`, а новий **Слайдер відхилення** (≥7.4) значно зменшує кількість хибнопозитивних результатів, коли ви повторно скануєте після оновлення. Використовуйте його разом з багатокартковим порівнянням (`.PTR` → *Порівняти результати з іншою збереженою картою вказівників*), щоб отримати **один стійкий базовий вказівник** всього за кілька хвилин.
* Швидкий фільтр для масового вибору: після першого сканування натисніть `Ctrl+A → Space`, щоб позначити все, потім `Ctrl+I` (інвертувати), щоб зняти вибір адрес, які не пройшли повторне сканування.

### Ultimap 3 – Трасування Intel PT
*З 7.5 старий Ultimap був повторно реалізований на основі **Intel Processor-Trace (IPT)***. Це означає, що ви тепер можете записувати *кожну* гілку, яку бере ціль, **без покрокового виконання** (тільки в режимі користувача, це не спрацює на більшості анти-дебаг гаджетів).
```
Memory View → Tools → Ultimap 3 → check «Intel PT»
Select number of buffers → Start
```
Після кількох секунд зупиніть захоплення та **правий клік → Зберегти список виконання у файл**. Об'єднайте адреси гілок з сесією `Find out what addresses this instruction accesses`, щоб дуже швидко знайти гарячі точки ігрової логіки з високою частотою.

### 1-байтові `jmp` / шаблони авто-патчів
Версія 7.5 представила *однобайтовий* JMP stub (0xEB), який встановлює обробник SEH і розміщує INT3 у початковому місці. Він генерується автоматично, коли ви використовуєте **Auto Assembler → Template → Code Injection** на інструкціях, які не можуть бути патчовані з використанням 5-байтового відносного стрибка. Це робить можливими "щільні" хуки всередині упакованих або обмежених за розміром рутин.

### Стелс на рівні ядра з DBVM (AMD & Intel)
*DBVM* є вбудованим гіпервізором типу 2 CE. Останні збірки нарешті додали **AMD-V/SVM підтримку**, тому ви можете запустити `Driver → Load DBVM` на хостах Ryzen/EPYC. DBVM дозволяє вам:
1. Створювати апаратні точки зупинки, невидимі для перевірок Ring-3/анти-дебагу.
2. Читати/записувати сторінки пам'яті ядра, які можна змінювати або захищені, навіть коли драйвер у режимі користувача вимкнено.
3. Виконувати обходи атак за часом без VM-EXIT (наприклад, запитувати `rdtsc` з гіпервізора).

**Порада:** DBVM відмовиться завантажитися, коли HVCI/Memory-Integrity увімкнено на Windows 11 → вимкніть його або завантажте спеціалізований хост VM.

### Віддалене / крос-платформне налагодження з **ceserver**
CE тепер постачається з повним переписом *ceserver* і може підключатися через TCP до **Linux, Android, macOS & iOS** цілей. Популярний форк інтегрує *Frida*, щоб поєднати динамічну інструментацію з GUI CE – ідеально, коли вам потрібно патчити ігри Unity або Unreal, що працюють на телефоні:
```
# on the target (arm64)
./ceserver_arm64 &
# on the analyst workstation
adb forward tcp:52736 tcp:52736   # (or ssh tunnel)
Cheat Engine → "Network" icon → Host = localhost → Connect
```
Для моста Frida дивіться `bb33bb/frida-ceserver` на GitHub.

### Інші помітні корисності
* **Patch Scanner** (MemView → Tools) – виявляє несподівані зміни коду в виконуваних секціях; корисно для аналізу шкідливого ПЗ.
* **Structure Dissector 2** – перетягніть адресу → `Ctrl+D`, потім *Guess fields* для автоматичної оцінки C-структур.
* **.NET & Mono Dissector** – покращена підтримка ігор Unity; викликайте методи безпосередньо з консолі CE Lua.
* **Big-Endian custom types** – реверсований скан/редагування порядку байтів (корисно для емуляторів консолей та буферів мережевих пакетів).
* **Autosave & tabs** для вікон AutoAssembler/Lua, плюс `reassemble()` для переписування багаторядкових інструкцій.

### Примітки щодо установки та OPSEC (2024-2025)
* Офіційний інсталятор упакований з InnoSetup **рекламними пропозиціями** (`RAV` тощо). **Завжди натискайте *Decline*** *або компілюйте з виходу*, щоб уникнути PUP. AV все ще позначатиме `cheatengine.exe` як *HackTool*, що очікується.
* Сучасні драйвери античита (EAC/Battleye, ACE-BASE.sys, mhyprot2.sys) виявляють клас вікна CE навіть після перейменування. Запускайте вашу реверсну копію **всередині одноразової ВМ** або після відключення мережевої гри.
* Якщо вам потрібен доступ лише в режимі користувача, виберіть **`Settings → Extra → Kernel mode debug = off`**, щоб уникнути завантаження непідписаного драйвера CE, який може викликати BSOD на Windows 11 24H2 Secure-Boot.

---

## **Посилання**

- [Cheat Engine 7.5 release notes (GitHub)](https://github.com/cheat-engine/cheat-engine/releases/tag/7.5)
- [frida-ceserver cross-platform bridge](https://github.com/bb33bb/frida-ceserver-Mac-and-IOS)
- **Cheat Engine tutorial, complete it to learn how to start with Cheat Engine**

{{#include ../../banners/hacktricks-training.md}}
