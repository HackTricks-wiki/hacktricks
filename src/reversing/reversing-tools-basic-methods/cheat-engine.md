# Cheat Engine

{{#include ../../banners/hacktricks-training.md}}

[**Cheat Engine**](https://www.cheatengine.org/downloads.php)는 실행 중인 게임의 메모리 내에서 중요한 값이 저장된 위치를 찾고 이를 변경하는 데 유용한 프로그램입니다.\
다운로드하고 실행하면 도구 사용 방법에 대한 **튜토리얼**이 **제공**됩니다. 도구 사용법을 배우고 싶다면 이를 완료하는 것이 강력히 권장됩니다.

## 무엇을 검색하고 있나요?

![](<../../images/image (762).png>)

이 도구는 프로그램의 메모리 내에서 **어떤 값**(보통 숫자)이 **저장된 위치**를 찾는 데 매우 유용합니다.\
**보통 숫자**는 **4바이트** 형식으로 저장되지만, **double** 또는 **float** 형식으로도 찾을 수 있으며, **숫자와 다른 것**을 찾고 싶을 수도 있습니다. 그러므로 **검색할 항목**을 **선택**해야 합니다:

![](<../../images/image (324).png>)

또한 **다양한** 유형의 **검색**을 지정할 수 있습니다:

![](<../../images/image (311).png>)

메모리를 스캔하는 동안 **게임을 중지**하도록 체크할 수도 있습니다:

![](<../../images/image (1052).png>)

### 핫키

_**Edit --> Settings --> Hotkeys**_에서 **게임**을 **중지**하는 것과 같은 다양한 목적을 위한 **핫키**를 설정할 수 있습니다(메모리를 스캔하고 싶을 때 유용합니다). 다른 옵션도 제공됩니다:

![](<../../images/image (864).png>)

## 값 수정하기

원하는 **값**의 **위치**를 **찾은** 후(다음 단계에서 더 자세히 설명) 더블 클릭하여 **수정**할 수 있습니다. 그런 다음 그 값을 다시 더블 클릭합니다:

![](<../../images/image (563).png>)

마지막으로 메모리에서 수정이 완료되도록 **체크 표시**를 합니다:

![](<../../images/image (385).png>)

**메모리**에 대한 **변경**은 즉시 **적용**됩니다(게임이 이 값을 다시 사용하기 전까지는 값이 **게임에서 업데이트되지 않음을 주의하세요**).

## 값 검색하기

따라서, 개선하고 싶은 중요한 값(예: 사용자 생명)이 있다고 가정하고 이 값을 메모리에서 찾고 있다고 가정해 보겠습니다.

### 알려진 변경을 통한 검색

값 100을 찾고 있다고 가정하고, 해당 값을 검색하는 **스캔을 수행**하면 많은 일치 항목을 찾습니다:

![](<../../images/image (108).png>)

그런 다음 **값이 변경되도록** 무언가를 하고, 게임을 **중지**하고 **다음 스캔**을 수행합니다:

![](<../../images/image (684).png>)

Cheat Engine은 **100에서 새로운 값으로 변경된** **값**을 검색합니다. 축하합니다, 이제 찾고 있던 값의 **주소**를 **찾았습니다**, 이제 이를 수정할 수 있습니다.\
_여전히 여러 값이 남아 있다면, 그 값을 다시 수정하는 작업을 수행하고 또 다른 "다음 스캔"을 수행하여 주소를 필터링하세요._

### 알 수 없는 값, 알려진 변경

값을 **모르지만** **변경하는 방법**(변경의 값 포함)을 알고 있는 경우, 숫자를 찾을 수 있습니다.

먼저 "**알 수 없는 초기 값**" 유형의 스캔을 수행합니다:

![](<../../images/image (890).png>)

그런 다음 값이 변경되도록 하고, **값이 어떻게 변경되었는지**(제 경우에는 1 감소됨)를 지정하고 **다음 스캔**을 수행합니다:

![](<../../images/image (371).png>)

선택한 방식으로 **수정된 모든 값**이 표시됩니다:

![](<../../images/image (569).png>)

값을 찾으면 이를 수정할 수 있습니다.

**결과를 필터링하기 위해** 이 **단계를 원하는 만큼** 수행할 수 있다는 점에 유의하세요:

![](<../../images/image (574).png>)

### 랜덤 메모리 주소 - 코드 찾기

지금까지 우리는 값을 저장하는 주소를 찾는 방법을 배웠지만, **게임의 다른 실행에서 그 주소가 메모리의 다른 위치에 있을 가능성이 높습니다**. 따라서 항상 그 주소를 찾는 방법을 알아봅시다.

언급된 몇 가지 요령을 사용하여 현재 게임이 중요한 값을 저장하는 주소를 찾습니다. 그런 다음(원하는 경우 게임을 중지하고) 찾은 **주소**에서 **우클릭**하고 "**이 주소에 접근하는 것을 찾기**" 또는 "**이 주소에 쓰는 것을 찾기**"를 선택합니다:

![](<../../images/image (1067).png>)

**첫 번째 옵션**은 이 **주소**를 **사용하는 코드의 **부분**을 아는 데 유용합니다(게임의 코드를 수정할 수 있는 위치를 아는 데 유용합니다).\
**두 번째 옵션**은 더 **구체적**이며, 이 경우 **값이 어디에서 쓰이는지** 아는 데 더 도움이 됩니다.

이 옵션 중 하나를 선택하면 **디버거**가 프로그램에 **첨부**되고 새로운 **빈 창**이 나타납니다. 이제 **게임을 플레이**하고 **값을 수정**합니다(게임을 재시작하지 않고). **창**은 **값을 수정하는 주소**로 **채워져야** 합니다:

![](<../../images/image (91).png>)

이제 값을 수정하는 주소를 찾았으므로 **코드를 마음대로 수정**할 수 있습니다(Cheat Engine을 사용하면 NOPs로 빠르게 수정할 수 있습니다):

![](<../../images/image (1057).png>)

따라서 이제 코드를 수정하여 숫자에 영향을 주지 않거나 항상 긍정적인 방식으로 영향을 줄 수 있습니다.

### 랜덤 메모리 주소 - 포인터 찾기

이전 단계를 따라 관심 있는 값이 있는 위치를 찾습니다. 그런 다음, "**이 주소에 쓰는 것을 찾기**"를 사용하여 이 값을 쓰는 주소를 찾아 더블 클릭하여 디스어셈블리 뷰를 얻습니다:

![](<../../images/image (1039).png>)

그런 다음 **"\[]" 사이의 헥스 값을 검색하는 새로운 스캔을 수행합니다**(이 경우 $edx의 값):

![](<../../images/image (994).png>)

(_여러 개가 나타나면 보통 가장 작은 주소가 필요합니다_)\
이제 **우리가 관심 있는 값을 수정할 포인터를 찾았습니다**.

"**주소 수동 추가**"를 클릭합니다:

![](<../../images/image (990).png>)

이제 "포인터" 체크 박스를 클릭하고 텍스트 상자에 찾은 주소를 추가합니다(이 시나리오에서 이전 이미지에서 찾은 주소는 "Tutorial-i386.exe"+2426B0입니다):

![](<../../images/image (392).png>)

(첫 번째 "주소"는 입력한 포인터 주소에서 자동으로 채워지는 것을 주의하세요)

확인을 클릭하면 새로운 포인터가 생성됩니다:

![](<../../images/image (308).png>)

이제 그 값을 수정할 때마다 **값이 있는 메모리 주소가 다르더라도 중요한 값을 수정하는 것입니다.**

### 코드 주입

코드 주입은 대상 프로세스에 코드 조각을 주입한 다음, 코드 실행을 자신의 코드로 리라우팅하는 기술입니다(예: 점수를 주는 대신 빼앗는 것).

따라서 플레이어의 생명에서 1을 빼는 주소를 찾았다고 가정해 보겠습니다:

![](<../../images/image (203).png>)

**디스어셈블 코드**를 얻기 위해 Show disassembler를 클릭합니다.\
그런 다음 **CTRL+a**를 클릭하여 자동 조립 창을 호출하고 _**Template --> Code Injection**_을 선택합니다.

![](<../../images/image (902).png>)

수정하려는 **명령어의 주소**를 입력합니다(보통 자동으로 채워집니다):

![](<../../images/image (744).png>)

템플릿이 생성됩니다:

![](<../../images/image (944).png>)

따라서 "**newmem**" 섹션에 새로운 어셈블리 코드를 삽입하고 "**originalcode**"에서 원래 코드를 제거하면 실행되지 않습니다. 이 예제에서 주입된 코드는 1을 빼는 대신 2점을 추가합니다:

![](<../../images/image (521).png>)

**실행을 클릭하면 코드가 프로그램에 주입되어 기능의 동작이 변경됩니다!**

## Cheat Engine 7.x의 고급 기능 (2023-2025)

Cheat Engine은 7.0 버전 이후 계속 발전해 왔으며, 현대 소프트웨어(게임뿐만 아니라!)를 분석할 때 매우 유용한 여러 품질 개선 및 *공격적 리버싱* 기능이 추가되었습니다. 아래는 레드팀/CTF 작업 중 가장 많이 사용할 가능성이 있는 추가 기능에 대한 **매우 간결한 필드 가이드**입니다.

### 포인터 스캐너 2 개선
* `포인터는 특정 오프셋으로 끝나야 하며` 새로운 **편차** 슬라이더(≥7.4)는 업데이트 후 재스캔할 때 잘못된 긍정을 크게 줄입니다. 이를 다중 맵 비교(`.PTR` → *다른 저장된 포인터 맵과 결과 비교*)와 함께 사용하여 단 몇 분 만에 **단일 내구성 있는 기본 포인터**를 얻을 수 있습니다.
* 대량 필터 단축키: 첫 번째 스캔 후 `Ctrl+A → Space`를 눌러 모든 항목을 선택한 다음 `Ctrl+I`(반전)를 눌러 재스캔에 실패한 주소를 선택 해제합니다.

### Ultimap 3 – Intel PT 추적
*7.5부터 이전 Ultimap이 **Intel Processor-Trace (IPT)** 위에 재구현되었습니다. 이는 이제 **단일 스텝 없이** 대상이 취하는 *모든* 분기를 기록할 수 있음을 의미합니다(사용자 모드 전용, 대부분의 안티 디버그 장치를 작동시키지 않습니다).
```
Memory View → Tools → Ultimap 3 → check «Intel PT»
Select number of buffers → Start
```
몇 초 후에 캡처를 중지하고 **오른쪽 클릭 → 실행 목록을 파일로 저장**합니다. 분기 주소를 `이 명령이 접근하는 주소 찾기` 세션과 결합하여 고주파수 게임 로직 핫스팟을 매우 빠르게 찾을 수 있습니다.

### 1바이트 `jmp` / 자동 패치 템플릿
버전 7.5에서는 SEH 핸들러를 설치하고 원래 위치에 INT3를 배치하는 *1바이트* JMP 스텁(0xEB)이 도입되었습니다. 이는 5바이트 상대 점프를 사용하여 패치할 수 없는 명령어에 대해 **자동 어셈블러 → 템플릿 → 코드 주입**을 사용할 때 자동으로 생성됩니다. 이를 통해 패킹되거나 크기가 제한된 루틴 내에서 "타이트" 훅을 가능하게 합니다.

### DBVM을 통한 커널 수준 스텔스 (AMD & Intel)
*DBVM*은 CE의 내장형 Type-2 하이퍼바이저입니다. 최근 빌드에서는 **AMD-V/SVM 지원**이 추가되어 Ryzen/EPYC 호스트에서 `드라이버 → DBVM 로드`를 실행할 수 있습니다. DBVM을 사용하면:
1. Ring-3/안티 디버그 검사에 보이지 않는 하드웨어 중단점을 생성할 수 있습니다.
2. 사용자 모드 드라이버가 비활성화된 경우에도 페이지 가능하거나 보호된 커널 메모리 영역을 읽고 쓸 수 있습니다.
3. VM-EXIT 없는 타이밍 공격 우회를 수행할 수 있습니다 (예: 하이퍼바이저에서 `rdtsc` 쿼리).

**팁:** DBVM은 Windows 11에서 HVCI/메모리 무결성이 활성화되어 있을 때 로드를 거부합니다 → 이를 끄거나 전용 VM 호스트로 부팅하세요.

### 원격 / 크로스 플랫폼 디버깅 **ceserver**
CE는 이제 *ceserver*의 전체 재작성을 제공하며 **Linux, Android, macOS & iOS** 타겟에 TCP로 연결할 수 있습니다. 인기 있는 포크는 *Frida*를 통합하여 CE의 GUI와 동적 계측을 결합합니다 – 이는 전화에서 실행 중인 Unity 또는 Unreal 게임을 패치해야 할 때 이상적입니다:
```
# on the target (arm64)
./ceserver_arm64 &
# on the analyst workstation
adb forward tcp:52736 tcp:52736   # (or ssh tunnel)
Cheat Engine → "Network" icon → Host = localhost → Connect
```
For the Frida bridge see `bb33bb/frida-ceserver` on GitHub.

### Other noteworthy goodies
* **Patch Scanner** (MemView → Tools) – 실행 가능한 섹션에서 예상치 못한 코드 변경을 감지합니다; 맬웨어 분석에 유용합니다.
* **Structure Dissector 2** – 주소 드래그 → `Ctrl+D`, 그런 다음 *Guess fields*를 사용하여 C-구조체를 자동 평가합니다.
* **.NET & Mono Dissector** – Unity 게임 지원 개선; CE Lua 콘솔에서 직접 메서드를 호출합니다.
* **Big-Endian custom types** – 바이트 순서 반전 스캔/편집 (콘솔 에뮬레이터 및 네트워크 패킷 버퍼에 유용합니다).
* **Autosave & tabs** for AutoAssembler/Lua windows, plus `reassemble()` for multi-line instruction rewrite.

### Installation & OPSEC notes (2024-2025)
* 공식 설치 프로그램은 InnoSetup **광고 제안**(`RAV` 등)으로 포장되어 있습니다. **항상 *거부*를 클릭하세요** *또는 소스에서 컴파일하여 PUP를 피하세요*. AV는 여전히 `cheatengine.exe`를 *HackTool*로 표시할 것입니다, 이는 예상됩니다.
* 현대의 안티 치트 드라이버(EAC/Battleye, ACE-BASE.sys, mhyprot2.sys)는 이름이 변경되더라도 CE의 윈도우 클래스를 감지합니다. 리버싱 복사본을 **일회용 VM 내에서 실행**하거나 네트워크 플레이를 비활성화한 후 실행하세요.
* 사용자 모드 접근만 필요하다면 **`Settings → Extra → Kernel mode debug = off`**를 선택하여 Windows 11 24H2 Secure-Boot에서 BSOD를 유발할 수 있는 CE의 서명되지 않은 드라이버 로드를 피하세요.

---

## **References**

- [Cheat Engine 7.5 release notes (GitHub)](https://github.com/cheat-engine/cheat-engine/releases/tag/7.5)
- [frida-ceserver cross-platform bridge](https://github.com/bb33bb/frida-ceserver-Mac-and-IOS)
- **Cheat Engine tutorial, complete it to learn how to start with Cheat Engine**

{{#include ../../banners/hacktricks-training.md}}
