# Cheat Engine

{{#include ../../banners/hacktricks-training.md}}

[**Cheat Engine**](https://www.cheatengine.org/downloads.php) είναι ένα χρήσιμο πρόγραμμα για να βρείτε πού αποθηκεύονται σημαντικές τιμές μέσα στη μνήμη ενός τρέχοντος παιχνιδιού και να τις αλλάξετε.\
Όταν το κατεβάσετε και το εκτελέσετε, σας **παρουσιάζεται** ένα **tutorial** για το πώς να χρησιμοποιήσετε το εργαλείο. Αν θέλετε να μάθετε πώς να χρησιμοποιήσετε το εργαλείο, συνιστάται να το ολοκληρώσετε.

## Τι ψάχνετε;

![](<../../images/image (762).png>)

Αυτό το εργαλείο είναι πολύ χρήσιμο για να βρείτε **πού αποθηκεύεται κάποια τιμή** (συνήθως ένας αριθμός) **στη μνήμη** ενός προγράμματος.\
**Συνήθως οι αριθμοί** αποθηκεύονται σε **4bytes** μορφή, αλλά μπορείτε επίσης να τους βρείτε σε **double** ή **float** μορφές, ή μπορεί να θέλετε να ψάξετε για κάτι **διαφορετικό από έναν αριθμό**. Για αυτό το λόγο πρέπει να είστε σίγουροι ότι **επιλέγετε** αυτό που θέλετε να **ψάξετε**:

![](<../../images/image (324).png>)

Επίσης μπορείτε να υποδείξετε **διαφορετικούς** τύπους **αναζητήσεων**:

![](<../../images/image (311).png>)

Μπορείτε επίσης να ελέγξετε το κουτάκι για να **σταματήσετε το παιχνίδι ενώ σκανάρετε τη μνήμη**:

![](<../../images/image (1052).png>)

### Συντομεύσεις

Στο _**Edit --> Settings --> Hotkeys**_ μπορείτε να ορίσετε διαφορετικές **συντομεύσεις** για διαφορετικούς σκοπούς όπως **σταμάτημα** του **παιχνιδιού** (το οποίο είναι πολύ χρήσιμο αν κάποια στιγμή θέλετε να σκανάρετε τη μνήμη). Διαθέσιμες είναι και άλλες επιλογές:

![](<../../images/image (864).png>)

## Τροποποίηση της τιμής

Μόλις **βρείτε** πού είναι η **τιμή** που ψάχνετε (περισσότερα γι' αυτό στα επόμενα βήματα) μπορείτε να **την τροποποιήσετε** κάνοντας διπλό κλικ πάνω της, και στη συνέχεια διπλό κλικ στην τιμή της:

![](<../../images/image (563).png>)

Και τελικά **σημειώνοντας το τσεκ** για να γίνει η τροποποίηση στη μνήμη:

![](<../../images/image (385).png>)

Η **αλλαγή** στη **μνήμη** θα εφαρμοστεί αμέσως (σημειώστε ότι μέχρι το παιχνίδι να χρησιμοποιήσει ξανά αυτή την τιμή, η τιμή **δεν θα ενημερωθεί στο παιχνίδι**).

## Αναζητώντας την τιμή

Έτσι, θα υποθέσουμε ότι υπάρχει μια σημαντική τιμή (όπως η ζωή του χρήστη σας) που θέλετε να βελτιώσετε, και ψάχνετε αυτή την τιμή στη μνήμη)

### Μέσω μιας γνωστής αλλαγής

Υποθέτοντας ότι ψάχνετε για την τιμή 100, **εκτελείτε μια σάρωση** ψάχνοντας για αυτή την τιμή και βρίσκετε πολλές συμπτώσεις:

![](<../../images/image (108).png>)

Στη συνέχεια, κάνετε κάτι ώστε η **τιμή να αλλάξει**, και **σταματάτε** το παιχνίδι και **εκτελείτε** μια **επόμενη σάρωση**:

![](<../../images/image (684).png>)

Το Cheat Engine θα ψάξει για τις **τιμές** που **πήγαν από 100 στη νέα τιμή**. Συγχαρητήρια, **βρήκατε** τη **διεύθυνση** της τιμής που ψάχνατε, μπορείτε τώρα να την τροποποιήσετε.\
_Αν έχετε ακόμα πολλές τιμές, κάντε κάτι για να τροποποιήσετε ξανά αυτή την τιμή, και εκτελέστε άλλη μια "επόμενη σάρωση" για να φιλτράρετε τις διευθύνσεις._

### Άγνωστη τιμή, γνωστή αλλαγή

Στο σενάριο που **δεν γνωρίζετε την τιμή** αλλά ξέρετε **πώς να την αλλάξετε** (και ακόμη και την τιμή της αλλαγής) μπορείτε να ψάξετε για τον αριθμό σας.

Έτσι, ξεκινήστε εκτελώντας μια σάρωση τύπου "**Άγνωστη αρχική τιμή**":

![](<../../images/image (890).png>)

Στη συνέχεια, κάντε την τιμή να αλλάξει, υποδείξτε **πώς** η **τιμή** **αλλάχθηκε** (στην περίπτωσή μου μειώθηκε κατά 1) και εκτελέστε μια **επόμενη σάρωση**:

![](<../../images/image (371).png>)

Θα σας παρουσιαστούν **όλες οι τιμές που τροποποιήθηκαν με τον επιλεγμένο τρόπο**:

![](<../../images/image (569).png>)

Μόλις βρείτε την τιμή σας, μπορείτε να την τροποποιήσετε.

Σημειώστε ότι υπάρχουν **πολλές πιθανές αλλαγές** και μπορείτε να κάνετε αυτά τα **βήματα όσες φορές θέλετε** για να φιλτράρετε τα αποτελέσματα:

![](<../../images/image (574).png>)

### Τυχαία διεύθυνση μνήμης - Εύρεση του κώδικα

Μέχρι τώρα μάθαμε πώς να βρούμε μια διεύθυνση που αποθηκεύει μια τιμή, αλλά είναι πολύ πιθανό ότι σε **διαφορετικές εκτελέσεις του παιχνιδιού αυτή η διεύθυνση είναι σε διαφορετικά μέρη της μνήμης**. Έτσι, ας ανακαλύψουμε πώς να βρίσκουμε πάντα αυτή τη διεύθυνση.

Χρησιμοποιώντας μερικά από τα αναφερόμενα κόλπα, βρείτε τη διεύθυνση όπου το τρέχον παιχνίδι σας αποθηκεύει την σημαντική τιμή. Στη συνέχεια (σταματώντας το παιχνίδι αν το επιθυμείτε) κάντε **δεξί κλικ** στη βρεθείσα **διεύθυνση** και επιλέξτε "**Find out what accesses this address**" ή "**Find out what writes to this address**":

![](<../../images/image (1067).png>)

Η **πρώτη επιλογή** είναι χρήσιμη για να γνωρίζετε ποιες **μέρη** του **κώδικα** **χρησιμοποιούν** αυτή τη **διεύθυνση** (που είναι χρήσιμο για περισσότερα πράγματα όπως **να γνωρίζετε πού μπορείτε να τροποποιήσετε τον κώδικα** του παιχνιδιού).\
Η **δεύτερη επιλογή** είναι πιο **συγκεκριμένη**, και θα είναι πιο χρήσιμη σε αυτή την περίπτωση καθώς μας ενδιαφέρει να γνωρίζουμε **από πού γράφεται αυτή η τιμή**.

Μόλις επιλέξετε μία από αυτές τις επιλογές, ο **debugger** θα **συνδεθεί** με το πρόγραμμα και θα εμφανιστεί ένα νέο **κενό παράθυρο**. Τώρα, **παίξτε** το **παιχνίδι** και **τροποποιήστε** αυτή τη **τιμή** (χωρίς να επανεκκινήσετε το παιχνίδι). Το **παράθυρο** θα πρέπει να είναι **γεμάτο** με τις **διευθύνσεις** που **τροποποιούν** την **τιμή**:

![](<../../images/image (91).png>)

Τώρα που βρήκατε τη διεύθυνση που τροποποιεί την τιμή μπορείτε να **τροποποιήσετε τον κώδικα κατά βούληση** (το Cheat Engine σας επιτρέπει να το τροποποιήσετε γρήγορα σε NOPs):

![](<../../images/image (1057).png>)

Έτσι, μπορείτε τώρα να το τροποποιήσετε ώστε ο κώδικας να μην επηρεάζει τον αριθμό σας, ή να επηρεάζει πάντα με θετικό τρόπο.

### Τυχαία διεύθυνση μνήμης - Εύρεση του δείκτη

Ακολουθώντας τα προηγούμενα βήματα, βρείτε πού βρίσκεται η τιμή που σας ενδιαφέρει. Στη συνέχεια, χρησιμοποιώντας "**Find out what writes to this address**" ανακαλύψτε ποια διεύθυνση γράφει αυτή την τιμή και κάντε διπλό κλικ πάνω της για να αποκτήσετε την προβολή disassembly:

![](<../../images/image (1039).png>)

Στη συνέχεια, εκτελέστε μια νέα σάρωση **ψάχνοντας για την τιμή hex μεταξύ "\[]"** (η τιμή του $edx σε αυτή την περίπτωση):

![](<../../images/image (994).png>)

(_Αν εμφανιστούν πολλές, συνήθως χρειάζεστε τη μικρότερη διεύθυνση_)\
Τώρα, έχουμε βρει τον **δείκτη που θα τροποποιεί την τιμή που μας ενδιαφέρει**.

Κάντε κλικ στο "**Add Address Manually**":

![](<../../images/image (990).png>)

Τώρα, κάντε κλικ στο κουτάκι "Pointer" και προσθέστε τη βρεθείσα διεύθυνση στο πλαίσιο κειμένου (σε αυτό το σενάριο, η βρεθείσα διεύθυνση στην προηγούμενη εικόνα ήταν "Tutorial-i386.exe"+2426B0):

![](<../../images/image (392).png>)

(Σημειώστε πώς η πρώτη "Διεύθυνση" συμπληρώνεται αυτόματα από τη διεύθυνση δείκτη που εισάγετε)

Κάντε κλικ στο OK και θα δημιουργηθεί ένας νέος δείκτης:

![](<../../images/image (308).png>)

Τώρα, κάθε φορά που τροποποιείτε αυτή την τιμή, **τροποποιείτε την σημαντική τιμή ακόμα κι αν η διεύθυνση μνήμης όπου βρίσκεται η τιμή είναι διαφορετική.**

### Εισαγωγή Κώδικα

Η εισαγωγή κώδικα είναι μια τεχνική όπου εισάγετε ένα κομμάτι κώδικα στη διαδικασία στόχο, και στη συνέχεια ανακατευθύνετε την εκτέλεση του κώδικα ώστε να περάσει από τον δικό σας γραμμένο κώδικα (όπως να σας δίνει πόντους αντί να τους αφαιρεί).

Έτσι, φανταστείτε ότι έχετε βρει τη διεύθυνση που αφαιρεί 1 από τη ζωή του παίκτη σας:

![](<../../images/image (203).png>)

Κάντε κλικ στο Show disassembler για να αποκτήσετε τον **κώδικα disassemble**.\
Στη συνέχεια, κάντε κλικ **CTRL+a** για να καλέσετε το παράθυρο Auto assemble και επιλέξτε _**Template --> Code Injection**_

![](<../../images/image (902).png>)

Συμπληρώστε τη **διεύθυνση της εντολής που θέλετε να τροποποιήσετε** (αυτό συνήθως συμπληρώνεται αυτόματα):

![](<../../images/image (744).png>)

Θα παραχθεί ένα πρότυπο:

![](<../../images/image (944).png>)

Έτσι, εισάγετε τον νέο κώδικα assembly στην ενότητα "**newmem**" και αφαιρέστε τον αρχικό κώδικα από την "**originalcode**" αν δεν θέλετε να εκτελείται. Σε αυτό το παράδειγμα, ο εισαχθείς κώδικας θα προσθέσει 2 πόντους αντί να αφαιρεί 1:

![](<../../images/image (521).png>)

**Κάντε κλικ στο execute και έτσι ο κώδικάς σας θα πρέπει να εισαχθεί στο πρόγραμμα αλλάζοντας τη συμπεριφορά της λειτουργικότητας!**

## Προχωρημένες δυνατότητες στο Cheat Engine 7.x (2023-2025)

Το Cheat Engine συνεχίζει να εξελίσσεται από την έκδοση 7.0 και έχουν προστεθεί πολλές δυνατότητες ποιότητας ζωής και *offensive-reversing* που είναι εξαιρετικά χρήσιμες κατά την ανάλυση σύγχρονου λογισμικού (και όχι μόνο παιχνιδιών!). Παρακάτω είναι ένας **πολύ συμπυκνωμένος οδηγός πεδίου** για τις προσθήκες που πιθανότατα θα χρησιμοποιήσετε κατά τη διάρκεια εργασιών red-team/CTF.

### Βελτιώσεις Pointer Scanner 2
* `Pointers must end with specific offsets` και ο νέος **Deviation** slider (≥7.4) μειώνουν σημαντικά τα ψευδώς θετικά όταν ξανασκανάρετε μετά από μια ενημέρωση. Χρησιμοποιήστε το μαζί με τη σύγκριση multi-map (`.PTR` → *Compare results with other saved pointer map*) για να αποκτήσετε έναν **μοναδικό ανθεκτικό βασικό δείκτη** σε μόλις λίγα λεπτά.
* Συντόμευση μαζικού φίλτρου: μετά την πρώτη σάρωση πατήστε `Ctrl+A → Space` για να επισημάνετε τα πάντα, στη συνέχεια `Ctrl+I` (αντίστροφα) για να αποεπιλέξετε διευθύνσεις που απέτυχαν στη σάρωση.

### Ultimap 3 – Intel PT tracing
*Από την 7.5, το παλιό Ultimap επανασχεδιάστηκε πάνω από το **Intel Processor-Trace (IPT)***. Αυτό σημαίνει ότι μπορείτε τώρα να καταγράφετε *κάθε* κλάδο που παίρνει ο στόχος **χωρίς single-stepping** (μόνο σε user-mode, δεν θα ενεργοποιήσει τις περισσότερες αντι-debug gadgets).
```
Memory View → Tools → Ultimap 3 → check «Intel PT»
Select number of buffers → Start
```
Μετά από μερικά δευτερόλεπτα, σταματήστε την καταγραφή και **δεξί κλικ → Αποθήκευση λίστας εκτέλεσης σε αρχείο**. Συνδυάστε τις διευθύνσεις κλάδου με μια συνεδρία `Find out what addresses this instruction accesses` για να εντοπίσετε hotspots λογικής παιχνιδιού υψηλής συχνότητας εξαιρετικά γρήγορα.

### Πρότυπα `jmp` / auto-patch 1 byte
Η έκδοση 7.5 εισήγαγε ένα *one-byte* JMP stub (0xEB) που εγκαθιστά έναν χειριστή SEH και τοποθετεί ένα INT3 στην αρχική τοποθεσία. Δημιουργείται αυτόματα όταν χρησιμοποιείτε **Auto Assembler → Template → Code Injection** σε εντολές που δεν μπορούν να διορθωθούν με ένα 5-byte σχετικό άλμα. Αυτό καθιστά δυνατές τις “σφιχτές” συνδέσεις μέσα σε πακεταρισμένες ή περιορισμένες σε μέγεθος ρουτίνες.

### Stealth επιπέδου Kernel με DBVM (AMD & Intel)
*DBVM* είναι ο ενσωματωμένος Type-2 hypervisor του CE. Οι πρόσφατες εκδόσεις πρόσθεσαν τελικά **AMD-V/SVM υποστήριξη** ώστε να μπορείτε να εκτελέσετε `Driver → Load DBVM` σε hosts Ryzen/EPYC. Το DBVM σας επιτρέπει:
1. Δημιουργία υλικών σημείων διακοπής αόρατων σε ελέγχους Ring-3/anti-debug.
2. Ανάγνωση/γραφή περιοχών μνήμης πυρήνα που είναι σελίδες ή προστατευμένες ακόμη και όταν ο οδηγός χρήστη είναι απενεργοποιημένος.
3. Εκτέλεση παρακάμψεων επιθέσεων χρονισμού χωρίς VM-EXIT (π.χ. ερώτημα `rdtsc` από τον hypervisor).

**Συμβουλή:** Το DBVM θα αρνηθεί να φορτώσει όταν είναι ενεργοποιημένο το HVCI/Memory-Integrity στα Windows 11 → απενεργοποιήστε το ή εκκινήστε έναν αφιερωμένο VM-host.

### Απομακρυσμένη / διαλειτουργική αποσφαλμάτωση με **ceserver**
Το CE τώρα περιλαμβάνει μια πλήρη αναθεώρηση του *ceserver* και μπορεί να συνδεθεί μέσω TCP σε **Linux, Android, macOS & iOS** στόχους. Ένα δημοφιλές fork ενσωματώνει το *Frida* για να συνδυάσει τη δυναμική εργαλειακή υποστήριξη με το GUI του CE – ιδανικό όταν χρειάζεστε να διορθώσετε παιχνίδια Unity ή Unreal που τρέχουν σε τηλέφωνο:
```
# on the target (arm64)
./ceserver_arm64 &
# on the analyst workstation
adb forward tcp:52736 tcp:52736   # (or ssh tunnel)
Cheat Engine → "Network" icon → Host = localhost → Connect
```
Για τη γέφυρα Frida δείτε `bb33bb/frida-ceserver` στο GitHub.

### Άλλα αξιοσημείωτα εργαλεία
* **Patch Scanner** (MemView → Tools) – ανιχνεύει απροσδόκητες αλλαγές κώδικα σε εκτελέσιμες ενότητες; χρήσιμο για ανάλυση κακόβουλου λογισμικού.
* **Structure Dissector 2** – drag-an-address → `Ctrl+D`, στη συνέχεια *Guess fields* για αυτόματη αξιολόγηση C-δομών.
* **.NET & Mono Dissector** – βελτιωμένη υποστήριξη παιχνιδιών Unity; καλέστε μεθόδους απευθείας από την κονσόλα CE Lua.
* **Big-Endian custom types** – αντίστροφη σάρωση/επεξεργασία byte order (χρήσιμο για κονσόλες emulator και buffers δικτυακών πακέτων).
* **Autosave & tabs** για παράθυρα AutoAssembler/Lua, συν `reassemble()` για επανασύνθεση πολλαπλών γραμμών εντολών.

### Σημειώσεις εγκατάστασης & OPSEC (2024-2025)
* Ο επίσημος εγκαταστάτης είναι τυλιγμένος με InnoSetup **ad-offers** (`RAV` κ.λπ.). **Πάντα κάντε κλικ στο *Decline*** *ή συντάξτε από πηγή* για να αποφύγετε PUPs. Οι AVs θα επισημάνουν ακόμα το `cheatengine.exe` ως *HackTool*, κάτι που είναι αναμενόμενο.
* Σύγχρονοι οδηγοί ανίχνευσης απάτης (EAC/Battleye, ACE-BASE.sys, mhyprot2.sys) ανιχνεύουν την κλάση παραθύρου του CE ακόμα και όταν έχει μετονομαστεί. Εκτελέστε την αντίγραφο αναστροφής σας **μέσα σε μια αναλώσιμη VM** ή μετά την απενεργοποίηση του δικτυακού παιχνιδιού.
* Εάν χρειάζεστε μόνο πρόσβαση σε user-mode επιλέξτε **`Settings → Extra → Kernel mode debug = off`** για να αποφύγετε τη φόρτωση του μη υπογεγραμμένου οδηγού του CE που μπορεί να προκαλέσει BSOD σε Windows 11 24H2 Secure-Boot.

---

## **Αναφορές**

- [Cheat Engine 7.5 release notes (GitHub)](https://github.com/cheat-engine/cheat-engine/releases/tag/7.5)
- [frida-ceserver cross-platform bridge](https://github.com/bb33bb/frida-ceserver-Mac-and-IOS)
- **Cheat Engine tutorial, complete it to learn how to start with Cheat Engine**

{{#include ../../banners/hacktricks-training.md}}
