# Cheat Engine

{{#include ../../banners/hacktricks-training.md}}

[**Cheat Engine**](https://www.cheatengine.org/downloads.php) 是一个有用的程序，可以找到正在运行的游戏内重要值存储的位置并进行更改。\
当你下载并运行它时，你会 **看到** 一个 **教程**，介绍如何使用该工具。如果你想学习如何使用该工具，强烈建议完成这个教程。

## 你在搜索什么？

![](<../../images/image (762).png>)

这个工具非常有用，可以找到 **某个值**（通常是一个数字） **在程序内存中的存储位置**。\
**通常数字**以 **4字节** 形式存储，但你也可以找到 **双精度** 或 **浮点** 格式，或者你可能想寻找 **不同于数字** 的东西。因此，你需要确保 **选择** 你想要 **搜索的内容**：

![](<../../images/image (324).png>)

你还可以指示 **不同** 类型的 **搜索**：

![](<../../images/image (311).png>)

你还可以勾选框以 **在扫描内存时停止游戏**：

![](<../../images/image (1052).png>)

### 热键

在 _**编辑 --> 设置 --> 热键**_ 中，你可以为不同的目的设置不同的 **热键**，例如 **停止** **游戏**（如果你想在某个时刻扫描内存，这非常有用）。还有其他选项可用：

![](<../../images/image (864).png>)

## 修改值

一旦你 **找到** 你 **寻找的值** 的 **位置**（更多内容在后面的步骤中），你可以通过双击它来 **修改**，然后双击它的值：

![](<../../images/image (563).png>)

最后 **勾选** 以在内存中完成修改：

![](<../../images/image (385).png>)

对 **内存** 的 **更改** 将立即 **应用**（请注意，直到游戏不再使用此值，该值 **不会在游戏中更新**）。

## 搜索值

所以，我们假设有一个重要的值（比如你用户的生命值）你想要提高，并且你正在内存中寻找这个值）

### 通过已知的变化

假设你在寻找值 100，你 **执行扫描** 搜索该值，并找到很多匹配项：

![](<../../images/image (108).png>)

然后，你做一些事情使得 **值发生变化**，你 **停止** 游戏并 **执行** **下一次扫描**：

![](<../../images/image (684).png>)

Cheat Engine 将搜索 **从 100 变为新值** 的 **值**。恭喜，你 **找到了** 你正在寻找的 **值的地址**，现在你可以修改它。\
_如果你仍然有多个值，做一些事情再次修改该值，并执行另一个“下一次扫描”以过滤地址。_

### 未知值，已知变化

在你 **不知道值** 但你知道 **如何使其变化**（甚至变化的值）的情况下，你可以寻找你的数字。

所以，首先执行一种类型为“**未知初始值**”的扫描：

![](<../../images/image (890).png>)

然后，使值发生变化，指示 **值** **如何变化**（在我的例子中是减少了 1），并执行 **下一次扫描**：

![](<../../images/image (371).png>)

你将看到 **所有以所选方式修改的值**：

![](<../../images/image (569).png>)

一旦你找到了你的值，你可以修改它。

请注意，有很多 **可能的变化**，你可以根据需要 **多次执行这些步骤** 以过滤结果：

![](<../../images/image (574).png>)

### 随机内存地址 - 查找代码

到目前为止，我们学习了如何找到存储值的地址，但在 **游戏的不同执行中，该地址很可能位于内存的不同位置**。所以让我们找出如何始终找到该地址。

使用一些提到的技巧，找到当前游戏存储重要值的地址。然后（如果你愿意，可以停止游戏）右键单击找到的 **地址**，选择“**查找访问此地址的内容**”或“**查找写入此地址的内容**”：

![](<../../images/image (1067).png>)

**第一个选项** 有助于了解 **代码** 的 **哪些部分** 在 **使用** 这个 **地址**（这对于更多事情很有用，比如 **知道你可以在哪里修改游戏的代码**）。\
**第二个选项** 更加 **具体**，在这种情况下更有帮助，因为我们想知道 **这个值是从哪里写入的**。

一旦你选择了其中一个选项，**调试器** 将 **附加** 到程序，并且会出现一个新的 **空窗口**。现在，**玩** **游戏** 并 **修改** 该 **值**（无需重新启动游戏）。**窗口** 应该会 **填充** 正在 **修改** 该 **值** 的 **地址**：

![](<../../images/image (91).png>)

现在你找到了修改值的地址，你可以 **随意修改代码**（Cheat Engine 允许你快速将其修改为 NOP）：

![](<../../images/image (1057).png>)

因此，你现在可以修改它，使得代码不会影响你的数字，或者总是以积极的方式影响它。

### 随机内存地址 - 查找指针

按照之前的步骤，找到你感兴趣的值。然后，使用“**查找写入此地址的内容**”找出哪个地址写入这个值，并双击它以获取反汇编视图：

![](<../../images/image (1039).png>)

然后，执行新的扫描 **搜索“[]”之间的十六进制值**（在这种情况下是 $edx 的值）：

![](<../../images/image (994).png>)

（_如果出现多个，通常需要最小的地址_）\
现在，我们已经 **找到了将修改我们感兴趣的值的指针**。

点击“**手动添加地址**”：

![](<../../images/image (990).png>)

现在，勾选“指针”复选框，并在文本框中添加找到的地址（在这种情况下，前一张图片中找到的地址是 "Tutorial-i386.exe"+2426B0）：

![](<../../images/image (392).png>)

（注意第一个“地址”是从你输入的指针地址自动填充的）

点击确定，一个新的指针将被创建：

![](<../../images/image (308).png>)

现在，每次你修改该值时，你都在 **修改重要值，即使值所在的内存地址不同。**

### 代码注入

代码注入是一种技术，你将一段代码注入到目标进程中，然后重新引导代码的执行以通过你自己编写的代码（例如给你积分而不是减少它们）。

所以，想象一下你找到了一个地址，它正在从你的玩家生命中减去 1：

![](<../../images/image (203).png>)

点击显示反汇编以获取 **反汇编代码**。\
然后，点击 **CTRL+a** 调用自动汇编窗口，并选择 _**模板 --> 代码注入**_

![](<../../images/image (902).png>)

填写 **你想要修改的指令的地址**（这通常是自动填充的）：

![](<../../images/image (744).png>)

将生成一个模板：

![](<../../images/image (944).png>)

因此，将你的新汇编代码插入到“**newmem**”部分，并从“**originalcode**”中删除原始代码，如果你不想让它被执行。在这个例子中，注入的代码将增加 2 分而不是减少 1：

![](<../../images/image (521).png>)

**点击执行等，你的代码应该被注入到程序中，改变功能的行为！**

## Cheat Engine 7.x 的高级功能（2023-2025）

自 7.0 版本以来，Cheat Engine 继续发展，增加了几个生活质量和 *进攻性逆向* 功能，这些功能在分析现代软件（不仅仅是游戏！）时非常方便。以下是一个 **非常简明的实用指南**，介绍你在红队/CTF 工作中最有可能使用的新增功能。

### 指针扫描器 2 改进
* `指针必须以特定偏移量结束`，新的 **偏差** 滑块（≥7.4）在更新后重新扫描时大大减少了误报。将其与多映射比较（`.PTR` → *与其他保存的指针映射比较*）结合使用，可以在短短几分钟内获得 **单一的弹性基指针**。
* 批量过滤快捷键：在第一次扫描后，按 `Ctrl+A → 空格` 标记所有内容，然后按 `Ctrl+I`（反转）以取消选择未通过重新扫描的地址。

### Ultimap 3 – Intel PT 跟踪
*从 7.5 开始，旧的 Ultimap 在 **Intel 处理器跟踪 (IPT)** 的基础上重新实现。这意味着你现在可以记录目标采取的 *每个* 分支 **而无需单步执行**（仅限用户模式，它不会触发大多数反调试小工具）。
```
Memory View → Tools → Ultimap 3 → check «Intel PT»
Select number of buffers → Start
```
在几秒钟后停止捕获并**右键点击 → 将执行列表保存到文件**。结合分支地址和`Find out what addresses this instruction accesses`会话，可以极快地定位高频游戏逻辑热点。

### 1字节 `jmp` / 自动补丁模板
版本7.5引入了一个*一字节* JMP 存根（0xEB），它安装了一个 SEH 处理程序并在原始位置放置了一个 INT3。当您在无法通过5字节相对跳转进行补丁的指令上使用**Auto Assembler → Template → Code Injection**时，它会自动生成。这使得在打包或大小受限的例程中实现“紧凑”钩子成为可能。

### 使用 DBVM（AMD 和 Intel）进行内核级隐身
*DBVM* 是 CE 内置的 Type-2 虚拟机监控器。最近的构建终于添加了**AMD-V/SVM 支持**，因此您可以在 Ryzen/EPYC 主机上运行`Driver → Load DBVM`。DBVM 允许您：
1. 创建对 Ring-3/反调试检查不可见的硬件断点。
2. 即使用户模式驱动程序被禁用，也可以读写可分页或受保护的内核内存区域。
3. 执行无 VM-EXIT 的计时攻击绕过（例如，从虚拟机监控器查询`rdtsc`）。

**提示：** 当 Windows 11 上启用 HVCI/内存完整性时，DBVM 将拒绝加载 → 关闭它或启动一个专用的 VM 主机。

### 使用 **ceserver** 进行远程/跨平台调试
CE 现在提供了 *ceserver* 的完整重写，并可以通过 TCP 附加到**Linux、Android、macOS 和 iOS** 目标。一个流行的分支集成了 *Frida*，将动态插桩与 CE 的 GUI 结合起来 – 当您需要修补在手机上运行的 Unity 或 Unreal 游戏时，这非常理想：
```
# on the target (arm64)
./ceserver_arm64 &
# on the analyst workstation
adb forward tcp:52736 tcp:52736   # (or ssh tunnel)
Cheat Engine → "Network" icon → Host = localhost → Connect
```
对于 Frida 桥，请参见 `bb33bb/frida-ceserver` 在 GitHub 上。

### 其他值得注意的工具
* **Patch Scanner** (MemView → Tools) – 检测可执行部分中意外的代码更改；对恶意软件分析很有用。
* **Structure Dissector 2** – 拖动地址 → `Ctrl+D`，然后 *Guess fields* 自动评估 C 结构。
* **.NET & Mono Dissector** – 改进的 Unity 游戏支持；直接从 CE Lua 控制台调用方法。
* **Big-Endian 自定义类型** – 反向字节顺序扫描/编辑（对控制台模拟器和网络数据包缓冲区有用）。
* **Autosave & tabs** 用于 AutoAssembler/Lua 窗口，以及 `reassemble()` 用于多行指令重写。

### 安装与 OPSEC 注意事项 (2024-2025)
* 官方安装程序带有 InnoSetup **广告推荐**（`RAV` 等）。**始终点击 *Decline*** *或从源代码编译* 以避免 PUP。AV 仍会将 `cheatengine.exe` 标记为 *HackTool*，这是预期的。
* 现代反作弊驱动程序（EAC/Battleye, ACE-BASE.sys, mhyprot2.sys）即使在重命名后也会检测 CE 的窗口类。请在 **一次性虚拟机** 内运行您的反向工程副本，或在禁用网络游戏后运行。
* 如果您只需要用户模式访问，请选择 **`Settings → Extra → Kernel mode debug = off`** 以避免加载可能在 Windows 11 24H2 Secure-Boot 上导致 BSOD 的 CE 未签名驱动程序。

---

## **参考文献**

- [Cheat Engine 7.5 release notes (GitHub)](https://github.com/cheat-engine/cheat-engine/releases/tag/7.5)
- [frida-ceserver cross-platform bridge](https://github.com/bb33bb/frida-ceserver-Mac-and-IOS)
- **Cheat Engine 教程，完成它以学习如何开始使用 Cheat Engine**

{{#include ../../banners/hacktricks-training.md}}
