# Cheat Engine

{{#include ../../banners/hacktricks-training.md}}

[**Cheat Engine**](https://www.cheatengine.org/downloads.php) は、実行中のゲームのメモリ内に重要な値がどこに保存されているかを見つけて変更するための便利なプログラムです。\
ダウンロードして実行すると、ツールの使い方の**チュートリアル**が**表示**されます。ツールの使い方を学びたい場合は、これを完了することを強くお勧めします。

## 何を検索していますか？

![](<../../images/image (762).png>)

このツールは、プログラムのメモリ内に**どこに値**（通常は数値）が**保存されているか**を見つけるのに非常に便利です。\
**通常、数値**は**4バイト**形式で保存されますが、**ダブル**や**フロート**形式で見つかることもありますし、**数値以外の何か**を探すこともあるかもしれません。そのため、**検索したいものを選択**することを確認する必要があります：

![](<../../images/image (324).png>)

また、**異なる**タイプの**検索**を指定することもできます：

![](<../../images/image (311).png>)

メモリをスキャンしている間に**ゲームを停止する**ためのチェックボックスをオンにすることもできます：

![](<../../images/image (1052).png>)

### ホットキー

_**Edit --> Settings --> Hotkeys**_ では、**ゲームを停止する**などの目的のために異なる**ホットキー**を設定できます（これは、メモリをスキャンしたいときに非常に便利です）。他のオプションも利用可能です：

![](<../../images/image (864).png>)

## 値の変更

探している**値**がどこにあるかを**見つけたら**（このことについては次のステップで詳しく説明します）、それを**ダブルクリック**して、次にその値を**ダブルクリック**することで**変更**できます：

![](<../../images/image (563).png>)

最後に、メモリ内で変更を行うために**チェックを入れる**ことが必要です：

![](<../../images/image (385).png>)

**メモリ**への**変更**はすぐに**適用**されます（ゲームがこの値を再度使用するまで、値は**ゲーム内で更新されません**）。

## 値の検索

重要な値（ユーザーのライフなど）を改善したいと仮定し、その値をメモリ内で探しているとします。

### 既知の変更を通じて

値100を探していると仮定し、その値を検索するために**スキャンを実行**すると、多くの一致が見つかります：

![](<../../images/image (108).png>)

次に、**値が変更される**ような操作を行い、ゲームを**停止**して**次のスキャンを実行**します：

![](<../../images/image (684).png>)

Cheat Engineは、**100から新しい値に変わった**値を検索します。おめでとうございます、探していた**アドレス**を**見つけました**。これで、値を変更できます。\
_まだ複数の値がある場合は、再度その値を変更する操作を行い、もう一度「次のスキャン」を実行してアドレスをフィルタリングします。_

### 不明な値、既知の変更

値が**わからない**が、**どのように変更されるか**（変更の値も含む）を知っている場合は、数値を探すことができます。

まず、**不明な初期値**のスキャンを実行します：

![](<../../images/image (890).png>)

次に、値を変更し、**どのように**その**値が変更されたか**を示し（私の場合は1減少しました）、**次のスキャンを実行**します：

![](<../../images/image (371).png>)

選択した方法で**変更されたすべての値**が表示されます：

![](<../../images/image (569).png>)

値を見つけたら、それを変更できます。

**多くの可能な変更**があることに注意し、結果をフィルタリングするためにこれらの**ステップを何度でも行うことができます**：

![](<../../images/image (574).png>)

### ランダムメモリアドレス - コードの発見

これまで、値を保存しているアドレスを見つける方法を学びましたが、**ゲームの異なる実行ではそのアドレスがメモリ内の異なる場所にある可能性が高い**です。では、そのアドレスを常に見つける方法を見つけましょう。

前述のトリックのいくつかを使用して、現在のゲームが重要な値を保存しているアドレスを見つけます。次に（ゲームを停止しても構いません）、見つけた**アドレス**を右クリックし、**「このアドレスにアクセスするものを見つける」**または**「このアドレスに書き込むものを見つける」**を選択します：

![](<../../images/image (1067).png>)

**最初のオプション**は、この**アドレス**を**使用している**コードの**部分**を知るのに役立ちます（これは、ゲームのコードを変更できる場所を知るのに役立ちます）。\
**2番目のオプション**はより**具体的**で、**この値がどこから書き込まれているか**を知るのに役立ちます。

これらのオプションのいずれかを選択すると、**デバッガ**がプログラムに**接続**され、新しい**空のウィンドウ**が表示されます。今、**ゲームをプレイ**し、その**値を変更**します（ゲームを再起動せずに）。**ウィンドウ**は、**値を変更しているアドレス**で**埋まる**はずです：

![](<../../images/image (91).png>)

値を変更しているアドレスを見つけたら、**自由にコードを変更**できます（Cheat Engineでは、NOPにすぐに変更できます）：

![](<../../images/image (1057).png>)

これで、コードがあなたの数値に影響を与えないように変更することができますし、常にプラスの影響を与えるようにすることもできます。

### ランダムメモリアドレス - ポインタの発見

前のステップに従って、興味のある値がどこにあるかを見つけます。次に、**「このアドレスに書き込むものを見つける」**を使用して、この値を書き込むアドレスを見つけ、ダブルクリックしてディスアセンブリビューを取得します：

![](<../../images/image (1039).png>)

次に、**"\[]"の間の16進数値を検索**する新しいスキャンを実行します（この場合は$edxの値）：

![](<../../images/image (994).png>)

（複数のアドレスが表示される場合は、通常、最小のアドレスのものが必要です）\
これで、**興味のある値を変更するポインタを見つけました**。

**「アドレスを手動で追加」**をクリックします：

![](<../../images/image (990).png>)

次に、**ポインタ**のチェックボックスをオンにし、テキストボックスに見つけたアドレスを追加します（このシナリオでは、前の画像で見つけたアドレスは「Tutorial-i386.exe」+2426B0でした）：

![](<../../images/image (392).png>)

（最初の「アドレス」は、入力したポインタアドレスから自動的に入力されることに注意してください）

OKをクリックすると、新しいポインタが作成されます：

![](<../../images/image (308).png>)

これで、その値を変更するたびに、**値がどのメモリアドレスにあっても重要な値を変更しています**。

### コードインジェクション

コードインジェクションは、ターゲットプロセスにコードの一部を注入し、その後、コードの実行を自分が書いたコードを通過させる技術です（例えば、ポイントを与える代わりに減らすことなく）。

プレイヤーのライフから1を引いているアドレスを見つけたと想像してください：

![](<../../images/image (203).png>)

**ディスアセンブラを表示**して**ディスアセンブルコード**を取得します。\
次に、**CTRL+a**をクリックしてオートアセンブルウィンドウを呼び出し、_**Template --> Code Injection**_ を選択します。

![](<../../images/image (902).png>)

**変更したい命令のアドレス**を入力します（通常は自動的に入力されます）：

![](<../../images/image (744).png>)

テンプレートが生成されます：

![](<../../images/image (944).png>)

そのため、**newmem**セクションに新しいアセンブリコードを挿入し、**originalcode**から元のコードを削除します（実行したくない場合）。この例では、注入されたコードは1を引く代わりに2ポイントを追加します：

![](<../../images/image (521).png>)

**実行をクリックすると、あなたのコードがプログラムに注入され、機能の動作が変更されるはずです！**

## Cheat Engine 7.xの高度な機能（2023-2025）

Cheat Engineは7.0以降進化を続けており、現代のソフトウェア（ゲームだけでなく！）を分析する際に非常に便利な生活の質や*攻撃的リバース*機能が追加されています。以下は、レッドチーム/CTF作業中に最も使用する可能性が高い追加機能の**非常に簡潔なフィールドガイド**です。

### ポインタスキャナー2の改善
* `ポインタは特定のオフセットで終了する必要があります`、新しい**Deviation**スライダー（≥7.4）は、更新後に再スキャンする際の誤検知を大幅に減少させます。これをマルチマップ比較（`.PTR` → *他の保存されたポインタマップと結果を比較*）と組み合わせて、わずか数分で**単一の耐障害性ベースポインタ**を取得します。
* バルクフィルタショートカット：最初のスキャン後に`Ctrl+A → Space`を押してすべてをマークし、次に`Ctrl+I`（反転）を押して再スキャンに失敗したアドレスを選択解除します。

### Ultimap 3 – Intel PTトレース
*7.5以降、古いUltimapは**Intel Processor-Trace (IPT)**の上に再実装されました。これにより、ターゲットが取る**すべての**分岐を**単一ステップなしで記録**できるようになりました（ユーザーモードのみ、ほとんどのアンチデバッグガジェットには引っかかりません）。
```
Memory View → Tools → Ultimap 3 → check «Intel PT»
Select number of buffers → Start
```
数秒後にキャプチャを停止し、**右クリック → 実行リストをファイルに保存**します。ブランチアドレスを `Find out what addresses this instruction accesses` セッションと組み合わせて、高頻度のゲームロジックホットスポットを非常に迅速に特定します。

### 1バイト `jmp` / 自動パッチテンプレート
バージョン7.5では、SEHハンドラをインストールし、元の位置にINT3を配置する*1バイト* JMPスタブ（0xEB）が導入されました。これは、5バイトの相対ジャンプでパッチできない命令に対して**Auto Assembler → Template → Code Injection**を使用すると自動的に生成されます。これにより、パックされたりサイズ制約のあるルーチン内で「タイト」なフックが可能になります。

### カーネルレベルのステルスとDBVM（AMD & Intel）
*DBVM*はCEの組み込みType-2ハイパーバイザーです。最近のビルドでは、**AMD-V/SVMサポート**が追加され、Ryzen/EPYCホストで`Driver → Load DBVM`を実行できるようになりました。DBVMを使用すると：
1. Ring-3/アンチデバッグチェックに対して見えないハードウェアブレークポイントを作成できます。
2. ユーザーモードドライバが無効になっている場合でも、ページング可能または保護されたカーネルメモリ領域を読み書きできます。
3. VM-EXITなしのタイミング攻撃バイパスを実行できます（例：ハイパーバイザーから`rdtsc`をクエリ）。

**ヒント：** Windows 11でHVCI/メモリ整合性が有効になっていると、DBVMは読み込むことを拒否します → 無効にするか、専用のVMホストを起動してください。

### リモート / クロスプラットフォームデバッグと**ceserver**
CEは現在、*ceserver*の完全な書き換えを提供し、**Linux、Android、macOS & iOS**ターゲットにTCPで接続できます。人気のフォークは*Frida*を統合し、動的計測とCEのGUIを組み合わせます – 電話で実行されているUnityまたはUnrealゲームをパッチする必要がある場合に最適です：
```
# on the target (arm64)
./ceserver_arm64 &
# on the analyst workstation
adb forward tcp:52736 tcp:52736   # (or ssh tunnel)
Cheat Engine → "Network" icon → Host = localhost → Connect
```
For the Frida bridge see `bb33bb/frida-ceserver` on GitHub.

### その他の注目すべき機能
* **Patch Scanner** (MemView → Tools) – 実行可能セクションの予期しないコード変更を検出; マルウェア分析に便利です。
* **Structure Dissector 2** – アドレスをドラッグ → `Ctrl+D`、次に *Guess fields* でC構造体を自動評価します。
* **.NET & Mono Dissector** – Unityゲームのサポートが改善されました; CE Luaコンソールから直接メソッドを呼び出します。
* **Big-Endianカスタムタイプ** – バイト順序を逆にしてスキャン/編集（コンソールエミュレーターやネットワークパケットバッファに便利です）。
* **Autosave & tabs** for AutoAssembler/Luaウィンドウ、さらに `reassemble()` で複数行の命令を書き換えます。

### インストール & OPSECノート (2024-2025)
* 公式インストーラーはInnoSetup **広告オファー**（`RAV`など）でラップされています。**常に *Decline* をクリック** *するか、ソースからコンパイル*してPUPを避けてください。AVは依然として `cheatengine.exe` を *HackTool* としてフラグしますが、これは予想されることです。
* 現代のアンチチートドライバー（EAC/Battleye、ACE-BASE.sys、mhyprot2.sys）は、名前を変更してもCEのウィンドウクラスを検出します。リバースコピーを**使い捨てのVM内で実行**するか、ネットワークプレイを無効にした後に実行してください。
* ユーザーモードアクセスのみが必要な場合は、**`Settings → Extra → Kernel mode debug = off`** を選択して、Windows 11 24H2 Secure-BootでBSODを引き起こす可能性のあるCEの署名されていないドライバーの読み込みを避けてください。

---

## **参考文献**

- [Cheat Engine 7.5 release notes (GitHub)](https://github.com/cheat-engine/cheat-engine/releases/tag/7.5)
- [frida-ceserver cross-platform bridge](https://github.com/bb33bb/frida-ceserver-Mac-and-IOS)
- **Cheat Engineチュートリアル、Cheat Engineの使い方を学ぶために完了してください**

{{#include ../../banners/hacktricks-training.md}}
