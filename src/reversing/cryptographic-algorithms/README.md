# 加密/压缩算法

## 加密/压缩算法

{{#include ../../banners/hacktricks-training.md}}

## 识别算法

如果你在代码中**使用了右移和左移、异或和几种算术操作**，那么它很可能是**加密算法**的实现。这里将展示一些**识别所使用算法的方法，而无需逐步反向工程**。

### API 函数

**CryptDeriveKey**

如果使用了此函数，可以通过检查第二个参数的值来找到**使用的算法**：

![](<../../images/image (375) (1) (1) (1) (1).png>)

在这里查看可能的算法及其分配值的表格：[https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id](https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id)

**RtlCompressBuffer/RtlDecompressBuffer**

压缩和解压缩给定的数据缓冲区。

**CryptAcquireContext**

来自[文档](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta)：**CryptAcquireContext**函数用于获取特定加密服务提供程序（CSP）中某个密钥容器的句柄。**此返回的句柄用于调用使用所选CSP的CryptoAPI**函数。

**CryptCreateHash**

初始化数据流的哈希。如果使用了此函数，可以通过检查第二个参数的值来找到**使用的算法**：

![](<../../images/image (376).png>)

\
在这里查看可能的算法及其分配值的表格：[https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id](https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id)

### 代码常量

有时，由于需要使用特殊且唯一的值，识别算法非常简单。

![](<../../images/image (370).png>)

如果你在谷歌中搜索第一个常量，这就是你得到的结果：

![](<../../images/image (371).png>)

因此，你可以假设反编译的函数是**sha256计算器**。\
你可以搜索其他常量，可能会得到相同的结果。

### 数据信息

如果代码没有任何显著的常量，它可能在**加载来自.data部分的信息**。\
你可以访问该数据，**分组第一个dword**并在谷歌中搜索，就像我们在前面的部分所做的那样：

![](<../../images/image (372).png>)

在这种情况下，如果你搜索**0xA56363C6**，你会发现它与**AES算法的表**相关。

## RC4 **(对称加密)**

### 特点

它由三个主要部分组成：

- **初始化阶段/**：创建一个**从0x00到0xFF的值表**（总共256字节，0x100）。这个表通常称为**替代盒**（或SBox）。
- **打乱阶段**：将**循环遍历之前创建的表**（0x100次迭代的循环），用**半随机**字节修改每个值。为了创建这些半随机字节，使用RC4**密钥**。RC4**密钥**的长度可以**在1到256字节之间**，但通常建议长度超过5字节。通常，RC4密钥为16字节。
- **异或阶段**：最后，明文或密文与**之前创建的值进行异或**。加密和解密的函数是相同的。为此，将对创建的256字节进行循环，执行必要的次数。这通常在反编译的代码中通过**%256（模256）**来识别。

> [!NOTE]
> **为了在反汇编/反编译代码中识别RC4，你可以检查两个大小为0x100的循环（使用密钥），然后将输入数据与之前在两个循环中创建的256个值进行异或，可能使用%256（模256）**

### **初始化阶段/替代盒：**（注意用作计数器的数字256，以及在256个字符的每个位置写入0的方式）

![](<../../images/image (377).png>)

### **打乱阶段：**

![](<../../images/image (378).png>)

### **异或阶段：**

![](<../../images/image (379).png>)

## **AES (对称加密)**

### **特点**

- 使用**替代盒和查找表**
- 由于使用特定查找表值（常量），可以**区分AES**。_注意**常量**可以**存储**在二进制中**或动态**_**创建**。_
- **加密密钥**必须**可被16整除**（通常为32B），通常使用16B的**IV**。

### SBox 常量

![](<../../images/image (380).png>)

## Serpent **(对称加密)**

### 特点

- 很少发现某些恶意软件使用它，但有例子（Ursnif）
- 根据其长度（极长的函数）简单判断算法是否为Serpent

### 识别

在下图中注意常量**0x9E3779B9**的使用（注意该常量也被其他加密算法如**TEA** - Tiny Encryption Algorithm使用）。\
还要注意**循环的大小**（**132**）和**反汇编**指令中的**异或操作**数量以及**代码**示例：

![](<../../images/image (381).png>)

如前所述，这段代码可以在任何反编译器中可视化为**非常长的函数**，因为其中**没有跳转**。反编译的代码可能看起来如下：

![](<../../images/image (382).png>)

因此，可以通过检查**魔法数字**和**初始异或**来识别该算法，看到**非常长的函数**并**比较**一些**指令**与长函数的**实现**（如左移7和左旋转22）。

## RSA **(非对称加密)**

### 特点

- 比对称算法更复杂
- 没有常量！（自定义实现难以确定）
- KANAL（加密分析器）未能显示RSA的提示，因为它依赖于常量。

### 通过比较识别

![](<../../images/image (383).png>)

- 在第11行（左侧）有一个`+7) >> 3`，与第35行（右侧）相同：`+7) / 8`
- 第12行（左侧）检查`modulus_len < 0x040`，而第36行（右侧）检查`inputLen+11 > modulusLen`

## MD5 & SHA（哈希）

### 特点

- 3个函数：Init、Update、Final
- 初始化函数相似

### 识别

**Init**

你可以通过检查常量来识别它们。注意sha_init有一个MD5没有的常量：

![](<../../images/image (385).png>)

**MD5 Transform**

注意使用了更多常量

![](<../../images/image (253) (1) (1) (1).png>)

## CRC（哈希）

- 更小且更高效，因为其功能是查找数据中的意外更改
- 使用查找表（因此你可以识别常量）

### 识别

检查**查找表常量**：

![](<../../images/image (387).png>)

一个CRC哈希算法看起来像：

![](<../../images/image (386).png>)

## APLib（压缩）

### 特点

- 没有可识别的常量
- 你可以尝试用python编写算法并在线搜索类似的东西

### 识别

图表相当大：

![](<../../images/image (207) (2) (1).png>)

检查**3个比较以识别它**：

![](<../../images/image (384).png>)

{{#include ../../banners/hacktricks-training.md}}
