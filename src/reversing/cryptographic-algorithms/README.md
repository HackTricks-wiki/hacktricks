# Криптографічні/Стислі алгоритми

## Криптографічні/Стислі алгоритми

{{#include ../../banners/hacktricks-training.md}}

## Ідентифікація алгоритмів

Якщо ви закінчуєте в коді **використовуючи зсуви вправо і вліво, XOR та кілька арифметичних операцій**, то з великою ймовірністю це реалізація **криптографічного алгоритму**. Тут будуть показані деякі способи **ідентифікації алгоритму, який використовується, без необхідності зворотного аналізу кожного кроку**.

### API функції

**CryptDeriveKey**

Якщо ця функція використовується, ви можете дізнатися, який **алгоритм використовується**, перевіривши значення другого параметра:

![](<../../images/image (375) (1) (1) (1) (1).png>)

Перевірте тут таблицю можливих алгоритмів та їх призначених значень: [https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id](https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id)

**RtlCompressBuffer/RtlDecompressBuffer**

Стискає та розпаковує дані з даного буфера.

**CryptAcquireContext**

З [документації](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta): Функція **CryptAcquireContext** використовується для отримання дескриптора до певного контейнера ключів у певному постачальнику криптографічних послуг (CSP). **Цей повернений дескриптор використовується в викликах до функцій CryptoAPI**, які використовують вибраний CSP.

**CryptCreateHash**

Ініціює хешування потоку даних. Якщо ця функція використовується, ви можете дізнатися, який **алгоритм використовується**, перевіривши значення другого параметра:

![](<../../images/image (376).png>)

\
Перевірте тут таблицю можливих алгоритмів та їх призначених значень: [https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id](https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id)

### Константи коду

Іноді дуже легко ідентифікувати алгоритм завдяки тому, що він повинен використовувати спеціальне та унікальне значення.

![](<../../images/image (370).png>)

Якщо ви шукаєте першу константу в Google, ось що ви отримаєте:

![](<../../images/image (371).png>)

Отже, ви можете припустити, що декомпільована функція є **калькулятором sha256.**\
Ви можете шукати будь-яку з інших констант, і ви отримаєте (ймовірно) той же результат.

### Інформація про дані

Якщо в коді немає жодної значної константи, це може бути **завантаженням інформації з секції .data**.\
Ви можете отримати доступ до цих даних, **згрупувати перший dword** і шукати його в Google, як ми робили в попередньому розділі:

![](<../../images/image (372).png>)

У цьому випадку, якщо ви шукаєте **0xA56363C6**, ви можете знайти, що це пов'язано з **таблицями алгоритму AES**.

## RC4 **(Симетричне шифрування)**

### Характеристики

Він складається з 3 основних частин:

- **Стадія ініціалізації/**: Створює **таблицю значень від 0x00 до 0xFF** (всього 256 байт, 0x100). Цю таблицю зазвичай називають **Substitution Box** (або SBox).
- **Стадія перемішування**: Буде **проходити через таблицю**, створену раніше (цикл 0x100 ітерацій, знову) модифікуючи кожне значення з **напіввипадковими** байтами. Для створення цих напіввипадкових байтів використовується **ключ RC4**. **Ключі RC4** можуть бути **від 1 до 256 байт в довжину**, однак зазвичай рекомендується, щоб вони були більше 5 байт. Зазвичай ключі RC4 мають довжину 16 байт.
- **Стадія XOR**: Нарешті, відкритий текст або шифротекст **XORed з значеннями, створеними раніше**. Функція для шифрування та дешифрування однакова. Для цього буде виконано **проходження через створені 256 байт** стільки разів, скільки необхідно. Це зазвичай розпізнається в декомпільованому коді з **%256 (mod 256)**.

> [!NOTE]
> **Щоб ідентифікувати RC4 у дизасембльованому/декомпільованому коді, ви можете перевірити 2 цикли розміру 0x100 (з використанням ключа), а потім XOR вхідних даних з 256 значеннями, створеними раніше в 2 циклах, ймовірно, використовуючи %256 (mod 256)**

### **Стадія ініціалізації/Substitution Box:** (Зверніть увагу на число 256, яке використовується як лічильник, і як 0 записується в кожному місці з 256 символів)

![](<../../images/image (377).png>)

### **Стадія перемішування:**

![](<../../images/image (378).png>)

### **Стадія XOR:**

![](<../../images/image (379).png>)

## **AES (Симетричне шифрування)**

### **Характеристики**

- Використання **боксів заміни та таблиць пошуку**
- Можливо **відрізнити AES завдяки використанню специфічних значень таблиць пошуку** (констант). _Зверніть увагу, що **константа** може бути **збережена** в бінарному **або створена** _**динамічно**._
- **Ключ шифрування** повинен бути **дільним** на **16** (зазвичай 32B) і зазвичай використовується **IV** довжиною 16B.

### Константи SBox

![](<../../images/image (380).png>)

## Serpent **(Симетричне шифрування)**

### Характеристики

- Рідко можна знайти деяке шкідливе ПЗ, яке його використовує, але є приклади (Ursnif)
- Легко визначити, чи є алгоритм Serpent, чи ні, на основі його довжини (екстремально довга функція)

### Ідентифікація

На наступному зображенні зверніть увагу, як використовується константа **0x9E3779B9** (зверніть увагу, що ця константа також використовується іншими криптоалгоритмами, такими як **TEA** - Tiny Encryption Algorithm).\
Також зверніть увагу на **розмір циклу** (**132**) та **кількість операцій XOR** в **інструкціях дизасемблювання** та в **прикладі коду**:

![](<../../images/image (381).png>)

Як вже згадувалося, цей код можна візуалізувати в будь-якому декомпілері як **дуже довгу функцію**, оскільки в ній **немає стрибків**. Декомпільований код може виглядати наступним чином:

![](<../../images/image (382).png>)

Отже, можливо ідентифікувати цей алгоритм, перевіривши **магічне число** та **початкові XOR**, бачачи **дуже довгу функцію** та **порівнюючи** деякі **інструкції** довгої функції **з реалізацією** (наприклад, зсув вліво на 7 та обертання вліво на 22).

## RSA **(Асиметричне шифрування)**

### Характеристики

- Складніше, ніж симетричні алгоритми
- Немає констант! (кастомні реалізації важко визначити)
- KANAL (криптоаналізатор) не може показати підказки щодо RSA, оскільки покладається на константи.

### Ідентифікація за допомогою порівнянь

![](<../../images/image (383).png>)

- У рядку 11 (ліворуч) є `+7) >> 3`, що таке ж, як у рядку 35 (праворуч): `+7) / 8`
- Рядок 12 (ліворуч) перевіряє, чи `modulus_len < 0x040`, а в рядку 36 (праворуч) перевіряє, чи `inputLen+11 > modulusLen`

## MD5 & SHA (хеш)

### Характеристики

- 3 функції: Init, Update, Final
- Схожі функції ініціалізації

### Ідентифікація

**Init**

Ви можете ідентифікувати обидва, перевіривши константи. Зверніть увагу, що sha_init має 1 константу, якої MD5 не має:

![](<../../images/image (385).png>)

**MD5 Transform**

Зверніть увагу на використання більшої кількості констант

![](<../../images/image (253) (1) (1) (1).png>)

## CRC (хеш)

- Менший і більш ефективний, оскільки його функція полягає в знаходженні випадкових змін у даних
- Використовує таблиці пошуку (тому ви можете ідентифікувати константи)

### Ідентифікація

Перевірте **константи таблиці пошуку**:

![](<../../images/image (387).png>)

Алгоритм хешування CRC виглядає так:

![](<../../images/image (386).png>)

## APLib (Стиснення)

### Характеристики

- Непізнавані константи
- Ви можете спробувати написати алгоритм на Python і шукати подібні речі в Інтернеті

### Ідентифікація

Графік досить великий:

![](<../../images/image (207) (2) (1).png>)

Перевірте **3 порівняння для його розпізнавання**:

![](<../../images/image (384).png>)

{{#include ../../banners/hacktricks-training.md}}
