{{#include ../../banners/hacktricks-training.md}}

# Визначення упакованих бінарних файлів

- **відсутність рядків**: Зазвичай упаковані бінарні файли майже не містять рядків
- Багато **невикористаних рядків**: Також, коли шкідливе ПЗ використовує якийсь комерційний упакувальник, зазвичай можна знайти багато рядків без перехресних посилань. Навіть якщо ці рядки існують, це не означає, що бінарний файл не упакований.
- Ви також можете використовувати деякі інструменти, щоб спробувати визначити, який упакувальник був використаний для упаковки бінарного файлу:
- [PEiD](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml)
- [Exeinfo PE](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/ExEinfo-PE.shtml)
- [Language 2000](http://farrokhi.net/language/)

# Основні рекомендації

- **Почніть** аналізувати упакований бінарний файл **знизу в IDA і рухайтеся вгору**. Упаковщики виходять, коли розпакований код виходить, тому малоймовірно, що упаковщик передає виконання розпакованому коду на початку.
- Шукайте **JMP** або **CALL** до **реєстрів** або **областей** **пам'яті**. Також шукайте **функції, що передають аргументи та адресу, а потім викликають `retn`**, оскільки повернення функції в цьому випадку може викликати адресу, яка тільки що була передана в стек перед її викликом.
- Встановіть **точку зупинки** на `VirtualAlloc`, оскільки це виділяє місце в пам'яті, куди програма може записати розпакований код. "Запустіть до коду користувача" або використовуйте F8, щоб **отримати значення в EAX** після виконання функції та "**слідкуйте за цією адресою в дампі**". Ви ніколи не знаєте, чи це область, куди буде збережено розпакований код.
- **`VirtualAlloc`** зі значенням "**40**" як аргумент означає Читання+Запис+Виконання (деякий код, який потребує виконання, буде скопійовано сюди).
- **Під час розпакування** коду нормально знаходити **кілька викликів** до **арифметичних операцій** та функцій, таких як **`memcopy`** або **`Virtual`**`Alloc`. Якщо ви опинитеся в функції, яка, здається, виконує лише арифметичні операції і, можливо, деякий `memcopy`, рекомендація полягає в тому, щоб спробувати **знайти кінець функції** (можливо, JMP або виклик до якогось реєстру) **або** принаймні **виклик до останньої функції** і запустити до неї, оскільки код не є цікавим.
- Під час розпакування коду **звертайте увагу** на будь-які **зміни області пам'яті**, оскільки зміна області пам'яті може вказувати на **початок розпакування коду**. Ви можете легко скинути область пам'яті, використовуючи Process Hacker (процес --> властивості --> пам'ять).
- Під час спроби розпакувати код хороший спосіб **знати, чи ви вже працюєте з розпакованим кодом** (щоб ви могли просто скинути його) - це **перевірити рядки бінарного файлу**. Якщо в якийсь момент ви виконуєте стрибок (можливо, змінюючи область пам'яті) і помічаєте, що **додалося набагато більше рядків**, тоді ви можете знати, що **ви працюєте з розпакованим кодом**.\
Однак, якщо упакувальник вже містить багато рядків, ви можете подивитися, скільки рядків містить слово "http" і перевірити, чи це число зростає.
- Коли ви скидаєте виконуваний файл з області пам'яті, ви можете виправити деякі заголовки, використовуючи [PE-bear](https://github.com/hasherezade/pe-bear-releases/releases).

{{#include ../../banners/hacktricks-training.md}}
