# HTTP-Verbindungsanfrage-Smuggling

{{#include ../banners/hacktricks-training.md}}

**Dies ist eine Zusammenfassung des Beitrags** [**https://portswigger.net/research/browser-powered-desync-attacks**](https://portswigger.net/research/browser-powered-desync-attacks)

## Verbindungsstatusangriffe <a href="#state" id="state"></a>

### Validierung der ersten Anfrage

Bei der Weiterleitung von Anfragen könnten Reverse-Proxys von der **Host-Header** abhängen, um den Ziel-Backend-Server zu bestimmen, wobei oft auf eine Whitelist von Hosts zurückgegriffen wird, die den Zugriff erlauben. Es besteht jedoch eine Schwachstelle in einigen Proxys, bei der die Whitelist nur bei der ersten Anfrage in einer Verbindung durchgesetzt wird. Folglich könnten Angreifer dies ausnutzen, indem sie zunächst eine Anfrage an einen erlaubten Host stellen und dann über dieselbe Verbindung eine interne Seite anfordern:
```
GET / HTTP/1.1
Host: [allowed-external-host]

GET / HTTP/1.1
Host: [internal-host]
```
### First-request Routing

In einigen Konfigurationen kann ein Front-End-Server den **Host-Header der ersten Anfrage** verwenden, um das Back-End-Routing für diese Anfrage zu bestimmen, und dann alle nachfolgenden Anfragen von derselben Client-Verbindung dauerhaft an dieselbe Back-End-Verbindung weiterleiten. Dies kann wie folgt demonstriert werden:
```
GET / HTTP/1.1
Host: example.com

POST /pwreset HTTP/1.1
Host: psres.net
```
Dieses Problem kann potenziell mit [Host-Header-Angriffen](https://portswigger.net/web-security/host-header) kombiniert werden, wie z.B. Passwortzurücksetzvergiftung oder [Web-Cache-Vergiftung](https://portswigger.net/web-security/web-cache-poisoning), um andere Schwachstellen auszunutzen oder unbefugten Zugriff auf zusätzliche virtuelle Hosts zu erlangen.

> [!NOTE]
> Um diese Schwachstellen zu identifizieren, kann die Funktion 'connection-state probe' in HTTP Request Smuggler genutzt werden.

{{#include ../banners/hacktricks-training.md}}
