# HTTP Connection Request Smuggling

{{#include ../banners/hacktricks-training.md}}

**Ceci est un résumé du post** [**https://portswigger.net/research/browser-powered-desync-attacks**](https://portswigger.net/research/browser-powered-desync-attacks)

## Attaques d'état de connexion <a href="#state" id="state"></a>

### Validation de la première requête

Lors du routage des requêtes, les proxies inverses peuvent dépendre de l'**en-tête Host** pour déterminer le serveur back-end de destination, s'appuyant souvent sur une liste blanche d'hôtes autorisés. Cependant, une vulnérabilité existe dans certains proxies où la liste blanche n'est appliquée que sur la requête initiale d'une connexion. Par conséquent, les attaquants pourraient en profiter en effectuant d'abord une requête vers un hôte autorisé, puis en demandant un site interne via la même connexion :
```
GET / HTTP/1.1
Host: [allowed-external-host]

GET / HTTP/1.1
Host: [internal-host]
```
### Routage de la première requête

Dans certaines configurations, un serveur frontal peut utiliser le **header Host de la première requête** pour déterminer le routage en arrière-plan pour cette requête, puis acheminer de manière persistante toutes les requêtes suivantes provenant de la même connexion client vers la même connexion en arrière-plan. Cela peut être démontré comme suit :
```
GET / HTTP/1.1
Host: example.com

POST /pwreset HTTP/1.1
Host: psres.net
```
Ce problème peut potentiellement être combiné avec [les attaques par en-tête d'hôte](https://portswigger.net/web-security/host-header), telles que le poisoning de réinitialisation de mot de passe ou [le poisoning de cache web](https://portswigger.net/web-security/web-cache-poisoning), pour exploiter d'autres vulnérabilités ou obtenir un accès non autorisé à d'autres hôtes virtuels.

> [!NOTE]
> Pour identifier ces vulnérabilités, la fonctionnalité 'connection-state probe' dans HTTP Request Smuggler peut être utilisée.

{{#include ../banners/hacktricks-training.md}}
