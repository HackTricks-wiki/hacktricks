# Client Side Prototype Pollution

{{#include ../../../banners/hacktricks-training.md}}

## Ανακάλυψη χρησιμοποιώντας Αυτόματα εργαλεία

Τα εργαλεία [**https://github.com/dwisiswant0/ppfuzz**](https://github.com/dwisiswant0/ppfuzz?tag=v1.0.0)**,** [**https://github.com/kleiton0x00/ppmap**](https://github.com/kleiton0x00/ppmap) **και** [**https://github.com/kosmosec/proto-find**](https://github.com/kosmosec/proto-find) μπορούν να χρησιμοποιηθούν για **να βρουν ευπάθειες πρωτοτύπου ρύθμισης**.

Επιπλέον, μπορείτε επίσης να χρησιμοποιήσετε την **επέκταση του προγράμματος περιήγησης** [**PPScan**](https://github.com/msrkp/PPScan) για **να σαρώσετε αυτόματα** τις **σελίδες** που **πρόσβαση** για ευπάθειες πρωτοτύπου ρύθμισης.

### Αποσφαλμάτωση όπου χρησιμοποιείται μια ιδιότητα <a href="#id-5530" id="id-5530"></a>
```javascript
// Stop debugger where 'potentialGadget' property is accessed
Object.defineProperty(Object.prototype, "potentialGadget", {
__proto__: null,
get() {
console.trace()
return "test"
},
})
```
### Εύρεση της ρίζας του Prototype Pollution <a href="#id-5530" id="id-5530"></a>

Αφού έχει εντοπιστεί μια ευπάθεια prototype pollution από οποιοδήποτε από τα εργαλεία, και αν ο κώδικας δεν είναι υπερβολικά περίπλοκος, μπορείς να βρεις την ευπάθεια αναζητώντας λέξεις-κλειδιά όπως `location.hash`, `decodeURIComponent`, ή `location.search` στα Chrome Developer Tools. Αυτή η προσέγγιση σου επιτρέπει να εντοπίσεις την ευάλωτη ενότητα του JavaScript κώδικα.

Για μεγαλύτερες και πιο περίπλοκες βάσεις κώδικα, μια απλή μέθοδος για να ανακαλύψεις τον ευάλωτο κώδικα περιλαμβάνει τα εξής βήματα:

1. Χρησιμοποίησε ένα εργαλείο για να εντοπίσεις μια ευπάθεια και να αποκτήσεις ένα payload σχεδιασμένο να ορίσει μια ιδιότητα στον κατασκευαστή. Ένα παράδειγμα που παρέχεται από το ppmap μπορεί να μοιάζει με: `constructor[prototype][ppmap]=reserved`.
2. Ορίστε ένα breakpoint στην πρώτη γραμμή του JavaScript κώδικα που θα εκτελεστεί στη σελίδα. Ανανεώστε τη σελίδα με το payload, σταματώντας την εκτέλεση σε αυτό το breakpoint.
3. Ενώ η εκτέλεση του JavaScript είναι σταματημένη, εκτέλεσε το παρακάτω σενάριο στην κονσόλα JS. Αυτό το σενάριο θα στείλει σήμα όταν δημιουργηθεί η ιδιότητα 'ppmap', βοηθώντας στην τοποθέτηση της προέλευσής της:
```javascript
function debugAccess(obj, prop, debugGet = true) {
var origValue = obj[prop]

Object.defineProperty(obj, prop, {
get: function () {
if (debugGet) debugger
return origValue
},
set: function (val) {
debugger
origValue = val
},
})
}

debugAccess(Object.prototype, "ppmap")
```
4. Πλοηγηθείτε πίσω στην καρτέλα **Sources** και επιλέξτε “Resume script execution”. Το JavaScript θα συνεχίσει να εκτελείται και η ιδιότητα 'ppmap' θα μολυνθεί όπως αναμενόταν. Η χρήση του παρεχόμενου αποσπάσματος διευκολύνει την αναγνώριση της ακριβούς τοποθεσίας όπου η ιδιότητα 'ppmap' μολύνεται. Εξετάζοντας το **Call Stack**, μπορούν να παρατηρηθούν διαφορετικές στοίβες όπου συνέβη η μόλυνση.

Όταν αποφασίζετε ποια στοίβα να ερευνήσετε, είναι συχνά χρήσιμο να στοχεύετε σε στοίβες που σχετίζονται με αρχεία βιβλιοθηκών JavaScript, καθώς η μόλυνση του πρωτοτύπου συμβαίνει συχνά μέσα σε αυτές τις βιβλιοθήκες. Εντοπίστε τη σχετική στοίβα εξετάζοντας τη σύνδεσή της με αρχεία βιβλιοθηκών (ορατά στη δεξιά πλευρά, παρόμοια με μια εικόνα που παρέχεται για καθοδήγηση). Σε σενάρια με πολλές στοίβες, όπως αυτές στις γραμμές 4 και 6, η λογική επιλογή είναι η στοίβα στη γραμμή 4, καθώς αντιπροσωπεύει την αρχική εμφάνιση της μόλυνσης και επομένως την ρίζα της ευπάθειας. Κάνοντας κλικ στη στοίβα θα σας κατευθύνει στον ευάλωτο κώδικα.

![https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg](https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg)

## Εύρεση Gadget Σκριπτών

Το gadget είναι ο **κώδικας που θα καταχραστεί μόλις ανακαλυφθεί μια ευπάθεια PP**.

Εάν η εφαρμογή είναι απλή, μπορούμε να **αναζητήσουμε** **λέξεις-κλειδιά** όπως **`srcdoc/innerHTML/iframe/createElement`** και να αναθεωρήσουμε τον πηγαίο κώδικα και να ελέγξουμε αν οδηγεί σε **εκτέλεση javascript**. Μερικές φορές, οι αναφερόμενες τεχνικές μπορεί να μην βρουν καθόλου gadgets. Σε αυτή την περίπτωση, η καθαρή αναθεώρηση του πηγαίου κώδικα αποκαλύπτει μερικά ωραία gadgets όπως το παρακάτω παράδειγμα.

### Παράδειγμα Εύρεσης Gadget PP στον κώδικα της βιβλιοθήκης Mithil

Ελέγξτε αυτή τη γραφή: [https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/](https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/)

## Ανασύνθεση payloads για ευάλωτες βιβλιοθήκες

- [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution)
- [https://github.com/BlackFan/client-side-prototype-pollution](https://github.com/BlackFan/client-side-prototype-pollution)

## Παράκαμψη HTML Sanitizers μέσω PP

[**Αυτή η έρευνα**](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/) δείχνει gadgets PP που χρησιμοποιούνται για **να παρακάμψουν τις απολυμάνσεις** που παρέχονται από ορισμένες βιβλιοθήκες HTML sanitizers:

- **sanitize-html**

<figure><img src="../../../images/image (1140).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-7.png"><figcaption></figcaption></figure>

- **dompurify**

<figure><img src="../../../images/image (1141).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-9.png"><figcaption></figcaption></figure>

- **Closure**
```html
<!-- from https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/ -->
<script>
Object.prototype['* ONERROR'] = 1;
Object.prototype['* SRC'] = 1;
</script>
<script src=https://google.github.io/closure-library/source/closure/goog/base.js></script>
<script>
goog.require('goog.html.sanitizer.HtmlSanitizer');
goog.require('goog.dom');
</script>
<body>
<script>
const html = '<img src onerror=alert(1)>';
const sanitizer = new goog.html.sanitizer.HtmlSanitizer();
const sanitized = sanitizer.sanitize(html);
const node = goog.dom.safeHtmlToNode(sanitized);

document.body.append(node);
</script>
```
## Νέα Εργαλεία & Αυτοματοποίηση (2023–2025)

* **Burp Suite DOM Invader (v2023.6)** – Η PortSwigger πρόσθεσε μια ειδική καρτέλα *Prototype-pollution* που αυτόματα μεταβάλλει τα ονόματα παραμέτρων (π.χ. `__proto__`, `constructor.prototype`) και ανιχνεύει μολυσμένες ιδιότητες σε σημεία sink μέσα στην επέκταση του προγράμματος περιήγησης. Όταν ενεργοποιηθεί ένα gadget, το DOM Invader δείχνει τη στοίβα εκτέλεσης και τη ακριβή γραμμή όπου η ιδιότητα αποδεσμεύτηκε, καθιστώντας περιττό το χειροκίνητο κυνήγι σημείων διακοπής. Συνδυάστε το με το snippet "Break on property access" που έχει ήδη εμφανιστεί παραπάνω για γρήγορη μετάβαση από *source → sink*.
* **protoStalker** – ένα ανοιχτού κώδικα πρόσθετο Chrome DevTools (κυκλοφόρησε το 2024) που οπτικοποιεί τις αλυσίδες πρωτοτύπων σε πραγματικό χρόνο και επισημαίνει τις εγγραφές σε παγκοσμίως επικίνδυνες κλειδιά όπως `onerror`, `innerHTML`, `srcdoc`, `id`, κ.λπ. Χρήσιμο όταν έχετε μόνο ένα παραγωγικό πακέτο και δεν μπορείτε να οργανοποιήσετε το βήμα κατασκευής.
* **ppfuzz 2.0 (2025)** – το εργαλείο υποστηρίζει τώρα ES-modules, HTTP/2 και WebSocket endpoints. Η νέα λειτουργία `-A browser` εκκινεί μια headless Chromium instance και αυτόματα απαριθμεί τις κλάσεις gadget με brute forcing DOM APIs (βλ. ενότητα παρακάτω).

---

## Πρόσφατη Έρευνα Gadget Prototype-Pollution (2022–2025)

Μέσα στο 2023, οι ερευνητές της PortSwigger δημοσίευσαν μια εργασία που δείχνει ότι τα *browser-built-in* αντικείμενα μπορούν να μετατραπούν σε αξιόπιστα XSS gadgets μόλις μολυνθούν. Δεδομένου ότι αυτά τα αντικείμενα είναι παρόντα σε **κάθε** σελίδα, μπορείτε να αποκτήσετε εκτέλεση ακόμη και αν ο κωδικός της στοχευμένης εφαρμογής δεν αγγίζει ποτέ την μολυσμένη ιδιότητα.

Παράδειγμα gadget (λειτουργεί σε όλους τους evergreen browsers ≥ 2023-04):
```html
<script>
// Source (e.g. https://victim/?__proto__[href]=javascript:alert(document.domain))
// For demo we just pollute manually:
Object.prototype.href = 'javascript:alert(`polluted`)' ;

// Sink – URL() constructor implicitly reads `href`
new URL('#'); // breaks into JS; in Chrome you get an alert, Firefox loads "javascript:" URL
</script>
```
Άλλες χρήσιμες παγκόσμιες συσκευές που έχουν επιβεβαιωθεί ότι λειτουργούν μετά από ρύπανση (δοκιμασμένο 2024-11):

| Κατηγορία συσκευής | Ιδιότητα ανάγνωσης | Πρωτότυπο που επιτεύχθηκε |
|--------------------|--------------------|---------------------------|
| `Notification`     | `title`            | `alert()` μέσω κλικ ειδοποίησης |
| `Worker`           | `name`             | Εκτέλεση JS σε αφιερωμένο Worker |
| `Image`            | `src`              | Παραδοσιακό `onerror` XSS |
| `URLSearchParams`  | `toString`         | DOM-based Open Redirect |

Δείτε το έγγραφο του PortSwigger για τη πλήρη λίστα των 11 συσκευών και μια συζήτηση σχετικά με τις διαφυγές sandbox.

---

## Σημαντικά CVEs PP Client-Side (2023-2025)

* **DOMPurify ≤ 3.0.8 – CVE-2024-45801**  Ένας επιτιθέμενος θα μπορούσε να ρυπάνει το `Node.prototype.after` πριν από την αρχικοποίηση του καθαριστή, παρακάμπτοντας το προφίλ *SAFE_FOR_TEMPLATES* και οδηγώντας σε αποθηκευμένο XSS. Ο προμηθευτής διόρθωσε χρησιμοποιώντας ελέγχους `Object.hasOwn()` και `Object.create(null)` για εσωτερικούς χάρτες.
* **jQuery 3.6.0-3.6.3 – CVE-2023-26136 / CVE-2023-26140**  Το `extend()` θα μπορούσε να χρησιμοποιηθεί σε κατασκευασμένα αντικείμενα που προέρχονται από το `location.hash`, εισάγοντας αυθαίρετες ιδιότητες στο `Object.prototype` στο περιβάλλον περιήγησης.
* **sanitize-html < 2.8.1 (2023-10) ρύπανση πρωτοτύπου**  Μια κακόβουλη λίστα χαρακτηριστικών όπως `{"__proto__":{"innerHTML":"<img/src/onerror=alert(1)>"}}` παρακάμπτει τη λίστα επιτρεπόμενων.

Ακόμα και αν η ευάλωτη βιβλιοθήκη ζει **μόνο στον πελάτη**, το προκύπτον XSS είναι ακόμα εκμεταλλεύσιμο απομακρυσμένα μέσω ανακλαστικών παραμέτρων, χειριστών postMessage ή αποθηκευμένων δεδομένων που αποδίδονται αργότερα.

---

## Σύγχρονα Αμυντικά Μέτρα

1. **Παγώστε το παγκόσμιο πρωτότυπο νωρίς** (ιδανικά ως το πρώτο σενάριο):
```javascript
Object.freeze(Object.prototype);
Object.freeze(Array.prototype);
Object.freeze(Map.prototype);
```
Να είστε προσεκτικοί, αυτό μπορεί να σπάσει polyfills που βασίζονται σε καθυστερημένη επέκταση.
2. Χρησιμοποιήστε το `structuredClone()` αντί για `JSON.parse(JSON.stringify(obj))` ή κοινές "deepMerge" αποσπάσεις – αγνοεί setters/getters και δεν διασχίζει την αλυσίδα πρωτοτύπου.
3. Όταν χρειάζεστε πραγματικά λειτουργικότητα βαθιάς συγχώνευσης, επιλέξτε **lodash ≥ 4.17.22** ή **deepmerge ≥ 5.3.0** που έχουν ενσωματωμένο καθαρισμό πρωτοτύπου.
4. Προσθέστε μια Πολιτική Ασφαλείας Περιεχομένου με `script-src 'self'` και αυστηρό nonce. Ενώ το CSP δεν θα σταματήσει όλες τις συσκευές (π.χ. χειρισμός `location`), μπλοκάρει την πλειονότητα των `innerHTML` sinks.


## Αναφορές

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)
- [https://portswigger.net/research/widespread-prototype-pollution-gadgets](https://portswigger.net/research/widespread-prototype-pollution-gadgets)
- [https://snyk.io/blog/dompurify-prototype-pollution-bypass-cve-2024-45801/](https://snyk.io/blog/dompurify-prototype-pollution-bypass-cve-2024-45801/)




- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)

{{#include ../../../banners/hacktricks-training.md}}
