# Inquinamento dei Parametri | Iniezione JSON

## Inquinamento dei Parametri

{{#include ../banners/hacktricks-training.md}}

## Panoramica dell'Inquinamento dei Parametri HTTP (HPP)

L'Inquinamento dei Parametri HTTP (HPP) è una tecnica in cui gli attaccanti manipolano i parametri HTTP per cambiare il comportamento di un'applicazione web in modi non intenzionati. Questa manipolazione avviene aggiungendo, modificando o duplicando i parametri HTTP. L'effetto di queste manipolazioni non è direttamente visibile all'utente, ma può alterare significativamente la funzionalità dell'applicazione sul lato server, con impatti osservabili sul lato client.

### Esempio di Inquinamento dei Parametri HTTP (HPP)

Un URL di transazione di un'applicazione bancaria:

- **URL Originale:** `https://www.victim.com/send/?from=accountA&to=accountB&amount=10000`

Inserendo un ulteriore parametro `from`:

- **URL Manipolato:** `https://www.victim.com/send/?from=accountA&to=accountB&amount=10000&from=accountC`

La transazione potrebbe essere erroneamente addebitata a `accountC` invece di `accountA`, dimostrando il potenziale dell'HPP di manipolare transazioni o altre funzionalità come il ripristino della password, le impostazioni 2FA o le richieste di chiavi API.

#### **Parsing dei Parametri Specifico per Tecnologia**

- Il modo in cui i parametri vengono analizzati e prioritizzati dipende dalla tecnologia web sottostante, influenzando come l'HPP può essere sfruttato.
- Strumenti come [Wappalyzer](https://addons.mozilla.org/en-US/firefox/addon/wappalyzer/) aiutano a identificare queste tecnologie e i loro comportamenti di parsing.

### Sfruttamento di PHP e HPP

**Caso di Manipolazione OTP:**

- **Contesto:** Un meccanismo di accesso che richiede una Password Usa e Getta (OTP) è stato sfruttato.
- **Metodo:** Intercettando la richiesta OTP utilizzando strumenti come Burp Suite, gli attaccanti hanno duplicato il parametro `email` nella richiesta HTTP.
- **Risultato:** L'OTP, destinato all'email iniziale, è stato invece inviato al secondo indirizzo email specificato nella richiesta manipolata. Questo difetto ha consentito l'accesso non autorizzato eludendo la misura di sicurezza prevista.

Questo scenario evidenzia una grave svista nel backend dell'applicazione, che ha elaborato il primo parametro `email` per la generazione dell'OTP ma ha utilizzato l'ultimo per la consegna.

**Caso di Manipolazione della Chiave API:**

- **Scenario:** Un'applicazione consente agli utenti di aggiornare la propria chiave API tramite una pagina delle impostazioni del profilo.
- **Vettore di Attacco:** Un attaccante scopre che aggiungendo un ulteriore parametro `api_key` alla richiesta POST, può manipolare l'esito della funzione di aggiornamento della chiave API.
- **Tecnica:** Utilizzando uno strumento come Burp Suite, l'attaccante crea una richiesta che include due parametri `api_key`: uno legittimo e uno malevolo. Il server, elaborando solo l'ultima occorrenza, aggiorna la chiave API al valore fornito dall'attaccante.
- **Risultato:** L'attaccante ottiene il controllo sulla funzionalità API della vittima, potenzialmente accedendo o modificando dati privati in modo non autorizzato.

Questo esempio sottolinea ulteriormente la necessità di una gestione sicura dei parametri, specialmente in funzionalità critiche come la gestione delle chiavi API.

### Parsing dei Parametri: Flask vs. PHP

Il modo in cui le tecnologie web gestiscono i parametri HTTP duplicati varia, influenzando la loro suscettibilità agli attacchi HPP:

- **Flask:** Adozione del primo valore del parametro incontrato, come `a=1` in una stringa di query `a=1&a=2`, privilegiando l'istanza iniziale rispetto ai duplicati successivi.
- **PHP (su Apache HTTP Server):** Al contrario, privilegia l'ultimo valore del parametro, optando per `a=2` nell'esempio fornito. Questo comportamento può facilitare involontariamente gli exploit HPP onorando il parametro manipolato dall'attaccante rispetto all'originale.

## Inquinamento dei parametri per tecnologia

I risultati sono stati presi da [https://medium.com/@0xAwali/http-parameter-pollution-in-2024-32ec1b810f89](https://medium.com/@0xAwali/http-parameter-pollution-in-2024-32ec1b810f89)

### PHP 8.3.11 E Apache 2.4.62 <a href="#id-9523" id="id-9523"></a>

<figure><img src="../images/image (1255).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*l_Pf2JNCYhmfAvfk7UTEbQ.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*l_Pf2JNCYhmfAvfk7UTEbQ.jpeg</a></p></figcaption></figure>

1. Ignora tutto dopo %00 nel nome del parametro.
2. Gestisce name\[] come array.
3. \_GET non significa metodo GET.
4. Preferisce l'ultimo parametro.

### Ruby 3.3.5 e WEBrick 1.8.2

<figure><img src="../images/image (1257).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*kKxtZ8qEmgTIMS81py5hhg.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*kKxtZ8qEmgTIMS81py5hhg.jpeg</a></p></figcaption></figure>

1. Usa i delimitatori & e ; per separare i parametri.
2. Non riconosce name\[].
3. Preferisce il primo parametro.

### Spring MVC 6.0.23 E Apache Tomcat 10.1.30 <a href="#dd68" id="dd68"></a>

<figure><img src="../images/image (1258).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*llG22MF1gPTYZYFVCmCiVw.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*llG22MF1gPTYZYFVCmCiVw.jpeg</a></p></figcaption></figure>

1. POST RequestMapping == PostMapping & GET RequestMapping == GetMapping.
2. POST RequestMapping & PostMapping riconoscono name\[].
3. Preferisce name se name E name\[] esistono.
4. Concatenare i parametri e.g. first,last.
5. POST RequestMapping & PostMapping riconoscono i parametri di query con Content-Type.

### **NodeJS** 20.17.0 **E** Express 4.21.0 <a href="#id-6d72" id="id-6d72"></a>

<figure><img src="../images/image (1259).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*JzNkLOSW7orcHXswtMHGMA.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*JzNkLOSW7orcHXswtMHGMA.jpeg</a></p></figcaption></figure>

1. Riconosce name\[].
2. Concatenare i parametri e.g. first,last.

### GO 1.22.7 <a href="#id-63dc" id="id-63dc"></a>

<figure><img src="../images/image (1260).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*NVvN1N8sL4g_Gi796FzlZA.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*NVvN1N8sL4g_Gi796FzlZA.jpeg</a></p></figcaption></figure>

1. NON riconosce name\[].
2. Preferisce il primo parametro.

### Python 3.12.6 E Werkzeug 3.0.4 E Flask 3.0.3 <a href="#b853" id="b853"></a>

<figure><img src="../images/image (1261).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*Se5467PFFjIlmT3O7KNlWQ.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*Se5467PFFjIlmT3O7KNlWQ.jpeg</a></p></figcaption></figure>

1. NON riconosce name\[].
2. Preferisce il primo parametro.

### Python 3.12.6 E Django 4.2.15 <a href="#id-8079" id="id-8079"></a>

<figure><img src="../images/image (1262).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*rf38VXut5YhAx0ZhUzgT8Q.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*rf38VXut5YhAx0ZhUzgT8Q.jpeg</a></p></figcaption></figure>

1. NON riconosce name\[].
2. Preferisce l'ultimo parametro.

### Python 3.12.6 E Tornado 6.4.1 <a href="#id-2ad8" id="id-2ad8"></a>

<figure><img src="../images/image (1263).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*obCn7xahDc296JZccXM2qQ.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*obCn7xahDc296JZccXM2qQ.jpeg</a></p></figcaption></figure>

1. NON riconosce name\[].
2. Preferisce l'ultimo parametro.

## Iniezione JSON

### Chiavi duplicate
```ini
obj = {"test": "user", "test": "admin"}
```
Il front-end potrebbe credere alla prima occorrenza mentre il backend utilizza la seconda occorrenza della chiave.

### Collisione di Chiavi: Troncamento dei Caratteri e Commenti

Alcaratteri non verranno interpretati correttamente dal frontend, ma il backend li interpreterà e utilizzerà quelle chiavi, questo potrebbe essere utile per **bypassare certe restrizioni**:
```json
{"test": 1, "test\[raw \x0d byte]": 2}
{"test": 1, "test\ud800": 2}
{"test": 1, "test"": 2}
{"test": 1, "te\st": 2}
```
Nota come in questi casi il front end potrebbe pensare che `test == 1` e il backend penserà che `test == 2`.

Questo può anche essere usato per bypassare le restrizioni sui valori come:
```json
{"role": "administrator\[raw \x0d byte]"}
{"role":"administrator\ud800"}
{"role": "administrator""}
{"role": "admini\strator"}
```
### **Utilizzando il Troncamento dei Commenti**
```ini
obj = {"description": "Duplicate with comments", "test": 2, "extra": /*, "test": 1, "extra2": */}
```
Qui utilizzeremo il serializer di ciascun parser per visualizzare il rispettivo output.

Serializer 1 (ad esempio, la libreria GoJay di GoLang) produrrà:

- `description = "Duplicate with comments"`
- `test = 2`
- `extra = ""`

Serializer 2 (ad esempio, la libreria JSON-iterator di Java) produrrà:

- `description = "Duplicate with comments"`
- `extra = "/*"`
- `extra2 = "*/"`
- `test = 1`

In alternativa, l'uso diretto dei commenti può essere altrettanto efficace:
```ini
obj = {"description": "Comment support", "test": 1, "extra": "a"/*, "test": 2, "extra2": "b"*/}
```
La libreria GSON di Java:
```json
{ "description": "Comment support", "test": 1, "extra": "a" }
```
La libreria simdjson di Ruby:
```json
{ "description": "Comment support", "test": 2, "extra": "a", "extra2": "b" }
```
### **Precedenza Incoerente: Deserializzazione vs. Serializzazione**
```ini
obj = {"test": 1, "test": 2}

obj["test"] // 1
obj.toString() // {"test": 2}
```
### Float e Intero

Il numero
```undefined
999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
```
può essere decodificato in più rappresentazioni, inclusi:
```undefined
999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
9.999999999999999e95
1E+96
0
9223372036854775807
```
Che potrebbe creare incoerenze

## Riferimenti

- [https://medium.com/@shahjerry33/http-parameter-pollution-its-contaminated-85edc0805654](https://medium.com/@shahjerry33/http-parameter-pollution-its-contaminated-85edc0805654)
- [https://github.com/google/google-ctf/tree/master/2023/web-under-construction/solution](https://github.com/google/google-ctf/tree/master/2023/web-under-construction/solution)
- [https://medium.com/@0xAwali/http-parameter-pollution-in-2024-32ec1b810f89](https://medium.com/@0xAwali/http-parameter-pollution-in-2024-32ec1b810f89)
- [https://bishopfox.com/blog/json-interoperability-vulnerabilities](https://bishopfox.com/blog/json-interoperability-vulnerabilities)


{{#include ../banners/hacktricks-training.md}}
