# Pollution de Paramètre | Injection JSON

## Pollution de Paramètre

{{#include ../banners/hacktricks-training.md}}

## Vue d'ensemble de la Pollution de Paramètre HTTP (HPP)

La Pollution de Paramètre HTTP (HPP) est une technique où les attaquants manipulent les paramètres HTTP pour modifier le comportement d'une application web de manière inattendue. Cette manipulation se fait en ajoutant, modifiant ou dupliquant des paramètres HTTP. L'effet de ces manipulations n'est pas directement visible pour l'utilisateur mais peut altérer de manière significative la fonctionnalité de l'application côté serveur, avec des impacts observables côté client.

### Exemple de Pollution de Paramètre HTTP (HPP)

Une URL de transaction d'application bancaire :

- **URL d'origine :** `https://www.victim.com/send/?from=accountA&to=accountB&amount=10000`

En insérant un paramètre `from` supplémentaire :

- **URL manipulée :** `https://www.victim.com/send/?from=accountA&to=accountB&amount=10000&from=accountC`

La transaction peut être incorrectement facturée à `accountC` au lieu de `accountA`, montrant le potentiel de HPP pour manipuler des transactions ou d'autres fonctionnalités telles que les réinitialisations de mot de passe, les paramètres 2FA ou les demandes de clé API.

#### **Analyse des Paramètres Spécifiques à la Technologie**

- La manière dont les paramètres sont analysés et priorisés dépend de la technologie web sous-jacente, affectant la façon dont HPP peut être exploité.
- Des outils comme [Wappalyzer](https://addons.mozilla.org/en-US/firefox/addon/wappalyzer/) aident à identifier ces technologies et leurs comportements d'analyse.

### Exploitation de PHP et HPP

**Cas de Manipulation d'OTP :**

- **Contexte :** Un mécanisme de connexion nécessitant un Mot de Passe à Usage Unique (OTP) a été exploité.
- **Méthode :** En interceptant la demande d'OTP à l'aide d'outils comme Burp Suite, les attaquants ont dupliqué le paramètre `email` dans la requête HTTP.
- **Résultat :** L'OTP, destiné à l'email initial, a été envoyé à la deuxième adresse email spécifiée dans la requête manipulée. Ce défaut a permis un accès non autorisé en contournant la mesure de sécurité prévue.

Ce scénario met en évidence une négligence critique dans le backend de l'application, qui a traité le premier paramètre `email` pour la génération d'OTP mais a utilisé le dernier pour la livraison.

**Cas de Manipulation de Clé API :**

- **Scénario :** Une application permet aux utilisateurs de mettre à jour leur clé API via une page de paramètres de profil.
- **Vecteur d'attaque :** Un attaquant découvre qu'en ajoutant un paramètre `api_key` supplémentaire à la requête POST, il peut manipuler le résultat de la fonction de mise à jour de la clé API.
- **Technique :** En utilisant un outil comme Burp Suite, l'attaquant crée une requête qui inclut deux paramètres `api_key` : un légitime et un malveillant. Le serveur, ne traitant que la dernière occurrence, met à jour la clé API avec la valeur fournie par l'attaquant.
- **Résultat :** L'attaquant prend le contrôle de la fonctionnalité API de la victime, accédant ou modifiant potentiellement des données privées sans autorisation.

Cet exemple souligne encore la nécessité d'une gestion sécurisée des paramètres, en particulier dans des fonctionnalités aussi critiques que la gestion des clés API.

### Analyse des Paramètres : Flask vs. PHP

La manière dont les technologies web gèrent les paramètres HTTP dupliqués varie, affectant leur susceptibilité aux attaques HPP :

- **Flask :** Adopte la première valeur de paramètre rencontrée, comme `a=1` dans une chaîne de requête `a=1&a=2`, priorisant l'instance initiale sur les duplicatas suivants.
- **PHP (sur Apache HTTP Server) :** Au contraire, priorise la dernière valeur de paramètre, optant pour `a=2` dans l'exemple donné. Ce comportement peut faciliter involontairement les exploits HPP en honorant le paramètre manipulé de l'attaquant plutôt que l'original.

## Pollution de paramètres par technologie

Les résultats ont été tirés de [https://medium.com/@0xAwali/http-parameter-pollution-in-2024-32ec1b810f89](https://medium.com/@0xAwali/http-parameter-pollution-in-2024-32ec1b810f89)

### PHP 8.3.11 ET Apache 2.4.62 <a href="#id-9523" id="id-9523"></a>

<figure><img src="../images/image (1255).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*l_Pf2JNCYhmfAvfk7UTEbQ.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*l_Pf2JNCYhmfAvfk7UTEbQ.jpeg</a></p></figcaption></figure>

1. Ignorer tout ce qui suit %00 dans le nom du paramètre.
2. Traiter name\[] comme un tableau.
3. \_GET ne signifie pas méthode GET.
4. Préférer le dernier paramètre.

### Ruby 3.3.5 et WEBrick 1.8.2

<figure><img src="../images/image (1257).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*kKxtZ8qEmgTIMS81py5hhg.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*kKxtZ8qEmgTIMS81py5hhg.jpeg</a></p></figcaption></figure>

1. Utilise les délimiteurs & et ; pour séparer les paramètres.
2. Nom\[] non reconnu.
3. Préférer le premier paramètre.

### Spring MVC 6.0.23 ET Apache Tomcat 10.1.30 <a href="#dd68" id="dd68"></a>

<figure><img src="../images/image (1258).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*llG22MF1gPTYZYFVCmCiVw.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*llG22MF1gPTYZYFVCmCiVw.jpeg</a></p></figcaption></figure>

1. POST RequestMapping == PostMapping & GET RequestMapping == GetMapping.
2. POST RequestMapping & PostMapping reconnaissent name\[].
3. Préférer name si name ET name\[] existent.
4. Concaténer les paramètres e.g. first,last.
5. POST RequestMapping & PostMapping reconnaissent le paramètre de requête avec Content-Type.

### **NodeJS** 20.17.0 **ET** Express 4.21.0 <a href="#id-6d72" id="id-6d72"></a>

<figure><img src="../images/image (1259).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*JzNkLOSW7orcHXswtMHGMA.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*JzNkLOSW7orcHXswtMHGMA.jpeg</a></p></figcaption></figure>

1. Reconnaît name\[].
2. Concaténer les paramètres e.g. first,last.

### GO 1.22.7 <a href="#id-63dc" id="id-63dc"></a>

<figure><img src="../images/image (1260).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*NVvN1N8sL4g_Gi796FzlZA.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*NVvN1N8sL4g_Gi796FzlZA.jpeg</a></p></figcaption></figure>

1. NOM pas reconnu name\[].
2. Préférer le premier paramètre.

### Python 3.12.6 ET Werkzeug 3.0.4 ET Flask 3.0.3 <a href="#b853" id="b853"></a>

<figure><img src="../images/image (1261).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*Se5467PFFjIlmT3O7KNlWQ.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*Se5467PFFjIlmT3O7KNlWQ.jpeg</a></p></figcaption></figure>

1. NOM pas reconnu name\[].
2. Préférer le premier paramètre.

### Python 3.12.6 ET Django 4.2.15 <a href="#id-8079" id="id-8079"></a>

<figure><img src="../images/image (1262).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*rf38VXut5YhAx0ZhUzgT8Q.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*rf38VXut5YhAx0ZhUzgT8Q.jpeg</a></p></figcaption></figure>

1. NOM pas reconnu name\[].
2. Préférer le dernier paramètre.

### Python 3.12.6 ET Tornado 6.4.1 <a href="#id-2ad8" id="id-2ad8"></a>

<figure><img src="../images/image (1263).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*obCn7xahDc296JZccXM2qQ.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*obCn7xahDc296JZccXM2qQ.jpeg</a></p></figcaption></figure>

1. NOM pas reconnu name\[].
2. Préférer le dernier paramètre.

## Injection JSON

### Clés dupliquées
```ini
obj = {"test": "user", "test": "admin"}
```
L'interface utilisateur pourrait croire la première occurrence tandis que le backend utilise la deuxième occurrence de la clé.

### Collision de clés : Troncature de caractères et commentaires

Certains caractères ne seront pas correctement interprétés par l'interface utilisateur, mais le backend les interprétera et utilisera ces clés, cela pourrait être utile pour **contourner certaines restrictions** :
```json
{"test": 1, "test\[raw \x0d byte]": 2}
{"test": 1, "test\ud800": 2}
{"test": 1, "test"": 2}
{"test": 1, "te\st": 2}
```
Notez comment dans ces cas, le front end pourrait penser que `test == 1` et le backend pensera que `test == 2`.

Cela peut également être utilisé pour contourner les restrictions de valeur telles que :
```json
{"role": "administrator\[raw \x0d byte]"}
{"role":"administrator\ud800"}
{"role": "administrator""}
{"role": "admini\strator"}
```
### **Utilisation de la troncature de commentaires**
```ini
obj = {"description": "Duplicate with comments", "test": 2, "extra": /*, "test": 1, "extra2": */}
```
Ici, nous utiliserons le sérialiseur de chaque analyseur pour voir sa sortie respective.

Le sérialiseur 1 (par exemple, la bibliothèque GoJay de GoLang) produira :

- `description = "Duplicate with comments"`
- `test = 2`
- `extra = ""`

Le sérialiseur 2 (par exemple, la bibliothèque JSON-iterator de Java) produira :

- `description = "Duplicate with comments"`
- `extra = "/*"`
- `extra2 = "*/"`
- `test = 1`

Alternativement, l'utilisation directe de commentaires peut également être efficace :
```ini
obj = {"description": "Comment support", "test": 1, "extra": "a"/*, "test": 2, "extra2": "b"*/}
```
La bibliothèque GSON de Java :
```json
{ "description": "Comment support", "test": 1, "extra": "a" }
```
La bibliothèque simdjson de Ruby :
```json
{ "description": "Comment support", "test": 2, "extra": "a", "extra2": "b" }
```
### **Précédence Incohérente : Désérialisation vs. Sérialisation**
```ini
obj = {"test": 1, "test": 2}

obj["test"] // 1
obj.toString() // {"test": 2}
```
### Flottant et Entier

Le nombre
```undefined
999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
```
peut être décodé en plusieurs représentations, y compris :
```undefined
999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
9.999999999999999e95
1E+96
0
9223372036854775807
```
Ce qui pourrait créer des incohérences

## Références

- [https://medium.com/@shahjerry33/http-parameter-pollution-its-contaminated-85edc0805654](https://medium.com/@shahjerry33/http-parameter-pollution-its-contaminated-85edc0805654)
- [https://github.com/google/google-ctf/tree/master/2023/web-under-construction/solution](https://github.com/google/google-ctf/tree/master/2023/web-under-construction/solution)
- [https://medium.com/@0xAwali/http-parameter-pollution-in-2024-32ec1b810f89](https://medium.com/@0xAwali/http-parameter-pollution-in-2024-32ec1b810f89)
- [https://bishopfox.com/blog/json-interoperability-vulnerabilities](https://bishopfox.com/blog/json-interoperability-vulnerabilities)


{{#include ../banners/hacktricks-training.md}}
