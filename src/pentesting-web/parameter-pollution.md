# Contaminación de Parámetros | Inyección JSON

## Contaminación de Parámetros

{{#include ../banners/hacktricks-training.md}}

## Resumen de Contaminación de Parámetros HTTP (HPP)

La Contaminación de Parámetros HTTP (HPP) es una técnica donde los atacantes manipulan parámetros HTTP para cambiar el comportamiento de una aplicación web de maneras no intencionadas. Esta manipulación se realiza añadiendo, modificando o duplicando parámetros HTTP. El efecto de estas manipulaciones no es directamente visible para el usuario, pero puede alterar significativamente la funcionalidad de la aplicación en el lado del servidor, con impactos observables en el lado del cliente.

### Ejemplo de Contaminación de Parámetros HTTP (HPP)

Una URL de transacción de una aplicación bancaria:

- **URL Original:** `https://www.victim.com/send/?from=accountA&to=accountB&amount=10000`

Al insertar un parámetro `from` adicional:

- **URL Manipulada:** `https://www.victim.com/send/?from=accountA&to=accountB&amount=10000&from=accountC`

La transacción puede ser incorrectamente cargada a `accountC` en lugar de `accountA`, mostrando el potencial de HPP para manipular transacciones u otras funcionalidades como restablecimientos de contraseña, configuraciones de 2FA o solicitudes de claves API.

#### **Análisis de Parámetros Específicos de Tecnología**

- La forma en que se analizan y priorizan los parámetros depende de la tecnología web subyacente, afectando cómo se puede explotar HPP.
- Herramientas como [Wappalyzer](https://addons.mozilla.org/en-US/firefox/addon/wappalyzer/) ayudan a identificar estas tecnologías y sus comportamientos de análisis.

### Explotación de HPP en PHP

**Caso de Manipulación de OTP:**

- **Contexto:** Se explotó un mecanismo de inicio de sesión que requería una Contraseña de Un Solo Uso (OTP).
- **Método:** Al interceptar la solicitud de OTP utilizando herramientas como Burp Suite, los atacantes duplicaron el parámetro `email` en la solicitud HTTP.
- **Resultado:** El OTP, destinado al correo electrónico inicial, fue enviado en su lugar a la segunda dirección de correo electrónico especificada en la solicitud manipulada. Este defecto permitió el acceso no autorizado al eludir la medida de seguridad prevista.

Este escenario destaca una falla crítica en el backend de la aplicación, que procesó el primer parámetro `email` para la generación de OTP, pero utilizó el último para la entrega.

**Caso de Manipulación de Clave API:**

- **Escenario:** Una aplicación permite a los usuarios actualizar su clave API a través de una página de configuración de perfil.
- **Vector de Ataque:** Un atacante descubre que al añadir un parámetro `api_key` adicional a la solicitud POST, puede manipular el resultado de la función de actualización de la clave API.
- **Técnica:** Utilizando una herramienta como Burp Suite, el atacante elabora una solicitud que incluye dos parámetros `api_key`: uno legítimo y uno malicioso. El servidor, procesando solo la última ocurrencia, actualiza la clave API al valor proporcionado por el atacante.
- **Resultado:** El atacante obtiene control sobre la funcionalidad API de la víctima, potencialmente accediendo o modificando datos privados sin autorización.

Este ejemplo subraya aún más la necesidad de un manejo seguro de parámetros, especialmente en características tan críticas como la gestión de claves API.

### Análisis de Parámetros: Flask vs. PHP

La forma en que las tecnologías web manejan parámetros HTTP duplicados varía, afectando su susceptibilidad a ataques HPP:

- **Flask:** Adopta el primer valor de parámetro encontrado, como `a=1` en una cadena de consulta `a=1&a=2`, priorizando la instancia inicial sobre duplicados posteriores.
- **PHP (en Apache HTTP Server):** Por el contrario, prioriza el último valor de parámetro, optando por `a=2` en el ejemplo dado. Este comportamiento puede facilitar inadvertidamente los exploits de HPP al honrar el parámetro manipulado del atacante sobre el original.

## Contaminación de parámetros por tecnología

Los resultados fueron tomados de [https://medium.com/@0xAwali/http-parameter-pollution-in-2024-32ec1b810f89](https://medium.com/@0xAwali/http-parameter-pollution-in-2024-32ec1b810f89)

### PHP 8.3.11 Y Apache 2.4.62 <a href="#id-9523" id="id-9523"></a>

<figure><img src="../images/image (1255).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*l_Pf2JNCYhmfAvfk7UTEbQ.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*l_Pf2JNCYhmfAvfk7UTEbQ.jpeg</a></p></figcaption></figure>

1. Ignorar cualquier cosa después de %00 en el nombre del parámetro.
2. Manejar name\[] como array.
3. \_GET no significa método GET.
4. Preferir el último parámetro.

### Ruby 3.3.5 y WEBrick 1.8.2

<figure><img src="../images/image (1257).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*kKxtZ8qEmgTIMS81py5hhg.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*kKxtZ8qEmgTIMS81py5hhg.jpeg</a></p></figcaption></figure>

1. Utiliza los delimitadores & y ; para dividir parámetros.
2. No reconoce name\[].
3. Prefiere el primer parámetro.

### Spring MVC 6.0.23 Y Apache Tomcat 10.1.30 <a href="#dd68" id="dd68"></a>

<figure><img src="../images/image (1258).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*llG22MF1gPTYZYFVCmCiVw.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*llG22MF1gPTYZYFVCmCiVw.jpeg</a></p></figcaption></figure>

1. POST RequestMapping == PostMapping & GET RequestMapping == GetMapping.
2. POST RequestMapping & PostMapping reconocen name\[].
3. Preferir name si name Y name\[] existen.
4. Concatenar parámetros e.g. first,last.
5. POST RequestMapping & PostMapping reconocen parámetros de consulta con Content-Type.

### **NodeJS** 20.17.0 **Y** Express 4.21.0 <a href="#id-6d72" id="id-6d72"></a>

<figure><img src="../images/image (1259).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*JzNkLOSW7orcHXswtMHGMA.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*JzNkLOSW7orcHXswtMHGMA.jpeg</a></p></figcaption></figure>

1. Reconoce name\[].
2. Concatenar parámetros e.g. first,last.

### GO 1.22.7 <a href="#id-63dc" id="id-63dc"></a>

<figure><img src="../images/image (1260).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*NVvN1N8sL4g_Gi796FzlZA.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*NVvN1N8sL4g_Gi796FzlZA.jpeg</a></p></figcaption></figure>

1. NO reconoce name\[].
2. Prefiere el primer parámetro.

### Python 3.12.6 Y Werkzeug 3.0.4 Y Flask 3.0.3 <a href="#b853" id="b853"></a>

<figure><img src="../images/image (1261).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*Se5467PFFjIlmT3O7KNlWQ.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*Se5467PFFjIlmT3O7KNlWQ.jpeg</a></p></figcaption></figure>

1. NO reconoce name\[].
2. Prefiere el primer parámetro.

### Python 3.12.6 Y Django 4.2.15 <a href="#id-8079" id="id-8079"></a>

<figure><img src="../images/image (1262).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*rf38VXut5YhAx0ZhUzgT8Q.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*rf38VXut5YhAx0ZhUzgT8Q.jpeg</a></p></figcaption></figure>

1. NO reconoce name\[].
2. Prefiere el último parámetro.

### Python 3.12.6 Y Tornado 6.4.1 <a href="#id-2ad8" id="id-2ad8"></a>

<figure><img src="../images/image (1263).png" alt=""><figcaption><p><a href="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*obCn7xahDc296JZccXM2qQ.jpeg">https://miro.medium.com/v2/resize:fit:1100/format:webp/1*obCn7xahDc296JZccXM2qQ.jpeg</a></p></figcaption></figure>

1. NO reconoce name\[].
2. Prefiere el último parámetro.

## Inyección JSON

### Claves duplicadas
```ini
obj = {"test": "user", "test": "admin"}
```
El front-end podría creer la primera ocurrencia mientras que el backend utiliza la segunda ocurrencia de la clave.

### Colisión de Claves: Truncamiento de Caracteres y Comentarios

Ciertos caracteres no serán interpretados correctamente por el frontend, pero el backend los interpretará y utilizará esas claves, esto podría ser útil para **eludir ciertas restricciones**:
```json
{"test": 1, "test\[raw \x0d byte]": 2}
{"test": 1, "test\ud800": 2}
{"test": 1, "test"": 2}
{"test": 1, "te\st": 2}
```
Nota cómo en estos casos el front end podría pensar que `test == 1` y el backend pensará que `test == 2`.

Esto también se puede usar para eludir restricciones de valor como:
```json
{"role": "administrator\[raw \x0d byte]"}
{"role":"administrator\ud800"}
{"role": "administrator""}
{"role": "admini\strator"}
```
### **Uso de la truncación de comentarios**
```ini
obj = {"description": "Duplicate with comments", "test": 2, "extra": /*, "test": 1, "extra2": */}
```
Aquí utilizaremos el serializador de cada parser para ver su salida respectiva.

Serializer 1 (por ejemplo, la biblioteca GoJay de GoLang) producirá:

- `description = "Duplicate with comments"`
- `test = 2`
- `extra = ""`

Serializer 2 (por ejemplo, la biblioteca JSON-iterator de Java) producirá:

- `description = "Duplicate with comments"`
- `extra = "/*"`
- `extra2 = "*/"`
- `test = 1`

Alternativamente, el uso directo de comentarios también puede ser efectivo:
```ini
obj = {"description": "Comment support", "test": 1, "extra": "a"/*, "test": 2, "extra2": "b"*/}
```
La biblioteca GSON de Java:
```json
{ "description": "Comment support", "test": 1, "extra": "a" }
```
La biblioteca simdjson de Ruby:
```json
{ "description": "Comment support", "test": 2, "extra": "a", "extra2": "b" }
```
### **Precedencia Inconsistente: Deserialización vs. Serialización**
```ini
obj = {"test": 1, "test": 2}

obj["test"] // 1
obj.toString() // {"test": 2}
```
### Float e Integer

El número
```undefined
999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
```
puede ser decodificado a múltiples representaciones, incluyendo:
```undefined
999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
9.999999999999999e95
1E+96
0
9223372036854775807
```
Lo que podría crear inconsistencias

## Referencias

- [https://medium.com/@shahjerry33/http-parameter-pollution-its-contaminated-85edc0805654](https://medium.com/@shahjerry33/http-parameter-pollution-its-contaminated-85edc0805654)
- [https://github.com/google/google-ctf/tree/master/2023/web-under-construction/solution](https://github.com/google/google-ctf/tree/master/2023/web-under-construction/solution)
- [https://medium.com/@0xAwali/http-parameter-pollution-in-2024-32ec1b810f89](https://medium.com/@0xAwali/http-parameter-pollution-in-2024-32ec1b810f89)
- [https://bishopfox.com/blog/json-interoperability-vulnerabilities](https://bishopfox.com/blog/json-interoperability-vulnerabilities)


{{#include ../banners/hacktricks-training.md}}
