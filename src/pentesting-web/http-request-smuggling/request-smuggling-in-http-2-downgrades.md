# Request Smuggling in HTTP/2 Downgrades

{{#include ../../banners/hacktricks-training.md}}

HTTP/2 को आमतौर पर क्लासिक request-smuggling के लिए प्रतिरक्षित माना जाता है क्योंकि प्रत्येक DATA फ्रेम की लंबाई स्पष्ट होती है। **यह सुरक्षा तब गायब हो जाती है जब एक फ्रंट-एंड प्रॉक्सी अनुरोध को HTTP/1.x में “डाउनग्रेड” करती है इससे पहले कि इसे बैक-एंड पर अग्रेषित किया जाए**। जिस क्षण दो अलग-अलग पार्सर (HTTP/2 फ्रंट-एंड और HTTP/1 बैक-एंड) यह सहमत होने की कोशिश करते हैं कि एक अनुरोध कहाँ समाप्त होता है और अगला कहाँ शुरू होता है, सभी पुराने desync ट्रिक्स वापस आ जाते हैं - साथ ही कुछ नए भी।

---
## डाउनग्रेड क्यों होते हैं

1. ब्राउज़र पहले से ही HTTP/2 बोलते हैं, लेकिन बहुत सारी विरासती मूल अवसंरचना अभी भी केवल HTTP/1.1 को समझती है।
2. रिवर्स-प्रॉक्सीज़ (CDNs, WAFs, लोड-बैलेंसर) इसलिए TLS + HTTP/2 को एज पर समाप्त करते हैं और **हर अनुरोध को HTTP/1.1 के लिए फिर से लिखते हैं**।
3. अनुवाद चरण को *दोनों* `Content-Length` **और/या** `Transfer-Encoding: chunked` हेडर बनाने होंगे ताकि मूल शरीर की लंबाई निर्धारित कर सके।

जब भी फ्रंट-एंड HTTP/2 फ्रेम की लंबाई पर भरोसा करता है **लेकिन** बैक-एंड CL या TE पर भरोसा करता है, एक हमलावर उन्हें असहमत करने के लिए मजबूर कर सकता है।

---
## दो प्रमुख प्राइमिटिव वर्ग

| Variant | Front-end length | Back-end length | Typical payload |
|---------|-----------------|-----------------|-----------------|
| **H2.TE** | HTTP/2 फ्रेम | `Transfer-Encoding: chunked` | एक अतिरिक्त chunked संदेश शरीर को एम्बेड करें जिसका अंतिम `0\r\n\r\n` *नहीं* भेजा जाता है, ताकि बैक-एंड हमलावर द्वारा प्रदान किए गए “अगले” अनुरोध की प्रतीक्षा करे। |
| **H2.CL** | HTTP/2 फ्रेम | `Content-Length` | एक *छोटी* CL भेजें जो असली शरीर से कम हो, ताकि बैक-एंड सीमा के पार अगली अनुरोध में पढ़ सके। |

> ये क्लासिक TE.CL / CL.TE के समान हैं, बस HTTP/2 एक पार्सर को बदल रहा है।

---
## डाउनग्रेड श्रृंखला की पहचान करना

1. एक TLS हैंडशेक में **ALPN** का उपयोग करें (`openssl s_client -alpn h2 -connect host:443`) या **curl**:
```bash
curl -v --http2 https://target
```
यदि `* Using HTTP2` प्रकट होता है, तो एज H2 बोलता है।
2. HTTP/2 (Burp Repeater अब HTTP/2 को मजबूर करने के लिए एक ड्रॉपडाउन है) पर जानबूझकर गलत CL/TE अनुरोध भेजें। यदि प्रतिक्रिया एक HTTP/1.1 त्रुटि है जैसे `400 Bad chunk`, तो आपके पास प्रमाण है कि एज ने HTTP/1 पार्सर के लिए ट्रैफ़िक को परिवर्तित किया।

---
## शोषण कार्यप्रवाह (H2.TE उदाहरण)
```http
:method: POST
:path: /login
:scheme: https
:authority: example.com
content-length: 13      # ignored by the edge
transfer-encoding: chunked

5;ext=1\r\nHELLO\r\n
0\r\n\r\nGET /admin HTTP/1.1\r\nHost: internal\r\nX: X
```
1. **फ्रंट-एंड** ठीक 13 बाइट्स (`HELLO\r\n0\r\n\r\nGE`) पढ़ता है, सोचता है कि अनुरोध समाप्त हो गया है और उतना ही मूल पर अग्रेषित करता है।
2. **बैक-एंड** TE हेडर पर भरोसा करता है, तब तक पढ़ता है जब तक कि यह *दूसरा* `0\r\n\r\n` नहीं देखता, इस प्रकार हमलावर के दूसरे अनुरोध (`GET /admin …`) का प्रीफिक्स खा जाता है।
3. शेष (`GET /admin …`) को पीड़ित के पीछे कतार में एक *नए* अनुरोध के रूप में माना जाता है।

स्मगल किए गए अनुरोध को बदलें:
* `POST /api/logout` सत्र स्थिरीकरण को मजबूर करने के लिए
* `GET /users/1234` एक पीड़ित-विशिष्ट संसाधन चुराने के लिए

---
## h2c स्मगलिंग (स्पष्ट-टेक्स्ट अपग्रेड)

2023 के एक अध्ययन ने दिखाया कि यदि एक फ्रंट-एंड HTTP/1.1 `Upgrade: h2c` हेडर को एक बैक-एंड पर पास करता है जो स्पष्ट-टेक्स्ट HTTP/2 का समर्थन करता है, तो एक हमलावर *कच्चे* HTTP/2 फ्रेम को एक एज के माध्यम से सुरंग कर सकता है जो केवल मान्य HTTP/1.1 को मानता है। यह हेडर सामान्यीकरण, WAF नियमों और यहां तक कि TLS समाप्ति को बायपास करता है।

मुख्य आवश्यकताएँ:
* एज **दोनों** `Connection: Upgrade` और `Upgrade: h2c` को बिना बदले अग्रेषित करता है।
* मूल HTTP/2 में बढ़ता है और कनेक्शन-रीयूज़ अर्थशास्त्र को बनाए रखता है जो अनुरोध कतारबद्ध करने की अनुमति देता है।

निवारण सरल है - एज पर `Upgrade` हेडर को हटा दें या हार्ड-कोड करें सिवाय WebSockets के।

---
## उल्लेखनीय वास्तविक-विश्व CVEs (2022-2025)

* **CVE-2023-25690** – Apache HTTP Server mod_proxy पुनर्लेखन नियमों को अनुरोध विभाजन और स्मगलिंग के लिए श्रृंखला में जोड़ा जा सकता है। (2.4.56 में ठीक किया गया)
* **CVE-2023-25950** – HAProxy 2.7/2.6 अनुरोध/प्रतिक्रिया स्मगलिंग जब HTX पार्सर ने पाइपलाइन किए गए अनुरोधों को गलत तरीके से संभाला।
* **CVE-2022-41721** – Go `MaxBytesHandler` ने बचे हुए बॉडी बाइट्स को **HTTP/2** फ्रेम के रूप में पार्स किया, जो क्रॉस-प्रोटोकॉल स्मगलिंग को सक्षम बनाता है।

---
## उपकरण

* **Burp Request Smuggler** – v1.26 से यह स्वचालित रूप से H2.TE/H2.CL और छिपे हुए ALPN समर्थन का परीक्षण करता है। एक्सटेंशन विकल्पों में "HTTP/2 probing" सक्षम करें।
* **h2cSmuggler** – स्पष्ट-टेक्स्ट अपग्रेड हमले को स्वचालित करने के लिए Bishop Fox द्वारा Python PoC:
```bash
python3 h2csmuggler.py -u https://target -x 'GET /admin HTTP/1.1\r\nHost: target\r\n\r\n'
```
* **curl**/`hyper` – मैन्युअल पेलोड बनाने के लिए: `curl --http2-prior-knowledge -X POST --data-binary @payload.raw https://target`।

---
## रक्षात्मक उपाय

1. **एंड-टू-एंड HTTP/2** – डाउनग्रेड अनुवाद को पूरी तरह से समाप्त करें।
2. **लंबाई सत्य का एकल स्रोत** – डाउनग्रेड करते समय, *हमेशा* एक मान्य `Content-Length` **और** **हटाएं** किसी भी उपयोगकर्ता-प्रदत्त `Content-Length`/`Transfer-Encoding` हेडर।
3. **रूट से पहले सामान्यीकरण** – रूटिंग/पुनर्लेखन तर्क से *पहले* हेडर-सैनिटाइजेशन लागू करें।
4. **कनेक्शन अलगाव** – उपयोगकर्ताओं के बीच बैक-एंड TCP कनेक्शन का पुन: उपयोग न करें; "एक कनेक्शन प्रति अनुरोध" कतार-आधारित शोषण को पराजित करता है।
5. **WebSocket को छोड़कर `Upgrade` हटा दें** – h2c सुरंगिंग को रोकता है।

---
## संदर्भ

* PortSwigger Research – “HTTP/2: The Sequel is Always Worse” <https://portswigger.net/research/http2>
* Bishop Fox – “h2c Smuggling: request smuggling via HTTP/2 clear-text” <https://bishopfox.com/blog/h2c-smuggling-request>

{{#include ../../banners/hacktricks-training.md}}
