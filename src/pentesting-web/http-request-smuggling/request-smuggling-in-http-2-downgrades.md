# Request Smuggling in HTTP/2 Downgrades

{{#include ../../banners/hacktricks-training.md}}

HTTP/2 wird allgemein als immun gegen klassisches Request-Smuggling angesehen, da die Länge jedes DATA-Frames explizit ist. **Dieser Schutz verschwindet, sobald ein Front-End-Proxy die Anfrage vor dem Weiterleiten an ein Back-End auf HTTP/1.x „downgradet“**. In dem Moment, in dem zwei verschiedene Parser (das HTTP/2 Front-End und das HTTP/1 Back-End) versuchen, sich darauf zu einigen, wo eine Anfrage endet und die nächste beginnt, kommen alle alten Desynchronisations-Tricks zurück – plus ein paar neue.

---
## Warum Downgrades passieren

1. Browser sprechen bereits HTTP/2, aber viele veraltete Ursprungsinfrastrukturen verstehen immer noch nur HTTP/1.1.
2. Reverse-Proxys (CDNs, WAFs, Load-Balancer) beenden daher TLS + HTTP/2 am Rand und **schreiben jede Anfrage als HTTP/1.1** für den Ursprung um.
3. Der Übersetzungsschritt muss *sowohl* `Content-Length` **und/oder** `Transfer-Encoding: chunked` Header erstellen, damit der Ursprung die Körperlänge bestimmen kann.

Wann immer das Front-End der HTTP/2-Frame-Länge **aber** das Back-End CL oder TE vertraut, kann ein Angreifer sie zwingen, nicht übereinzustimmen.

---
## Zwei dominante primitive Klassen

| Variante | Front-End-Länge | Back-End-Länge | Typische Payload |
|---------|-----------------|-----------------|-----------------|
| **H2.TE** | HTTP/2-Frame | `Transfer-Encoding: chunked` | Fügen Sie einen zusätzlichen chunked Nachrichtentext ein, dessen finales `0\r\n\r\n` *nicht* gesendet wird, sodass das Back-End auf die vom Angreifer bereitgestellte „nächste“ Anfrage wartet. |
| **H2.CL** | HTTP/2-Frame | `Content-Length` | Senden Sie ein *kleineres* CL als den tatsächlichen Körper, sodass das Back-End über die Grenze hinaus in die folgende Anfrage liest. |

> Diese sind im Geiste identisch mit klassischem TE.CL / CL.TE, nur dass HTTP/2 einen der Parser ersetzt.

---
## Identifizierung einer Downgrade-Kette

1. Verwenden Sie **ALPN** in einem TLS-Handshake (`openssl s_client -alpn h2 -connect host:443`) oder **curl**:
```bash
curl -v --http2 https://target
```
Wenn `* Using HTTP2` erscheint, spricht der Edge H2.
2. Senden Sie eine absichtlich fehlerhafte CL/TE-Anfrage *über* HTTP/2 (Burp Repeater hat jetzt ein Dropdown-Menü, um HTTP/2 zu erzwingen). Wenn die Antwort ein HTTP/1.1-Fehler wie `400 Bad chunk` ist, haben Sie den Beweis, dass der Edge den Verkehr für einen HTTP/1-Parser im Nachgang umgewandelt hat.

---
## Ausbeutungs-Workflow (H2.TE-Beispiel)
```http
:method: POST
:path: /login
:scheme: https
:authority: example.com
content-length: 13      # ignored by the edge
transfer-encoding: chunked

5;ext=1\r\nHELLO\r\n
0\r\n\r\nGET /admin HTTP/1.1\r\nHost: internal\r\nX: X
```
1. Das **Front-End** liest genau 13 Bytes (`HELLO\r\n0\r\n\r\nGE`), denkt, die Anfrage sei beendet und leitet so viel an den Ursprung weiter.
2. Das **Back-End** vertraut dem TE-Header, liest weiter, bis es das *zweite* `0\r\n\r\n` sieht, und verbraucht damit das Präfix der zweiten Anfrage des Angreifers (`GET /admin …`).
3. Der Rest (`GET /admin …`) wird als *neue* Anfrage behandelt, die hinter der des Opfers in der Warteschlange steht.

Ersetze die geschmuggelte Anfrage durch:
* `POST /api/logout`, um eine Sitzungsfixierung zu erzwingen
* `GET /users/1234`, um eine opferspezifische Ressource zu stehlen

---
## h2c Smuggling (Klartext-Upgrades)

Eine Studie aus dem Jahr 2023 zeigte, dass, wenn ein Front-End den HTTP/1.1 `Upgrade: h2c` Header an ein Back-End weitergibt, das Klartext-HTTP/2 unterstützt, ein Angreifer *rohe* HTTP/2-Frames durch eine Kante tunneln kann, die nur HTTP/1.1 validiert hat. Dies umgeht die Header-Normalisierung, WAF-Regeln und sogar die TLS-Terminierung.

Wichtige Anforderungen:
* Die Kante leitet **sowohl** `Connection: Upgrade` als auch `Upgrade: h2c` unverändert weiter.
* Der Ursprung wechselt zu HTTP/2 und behält die Semantik der Verbindungswiederverwendung bei, die das Anfragen-Queueing ermöglicht.

Die Minderung ist einfach – entferne oder hard-code den `Upgrade`-Header an der Kante, außer für WebSockets.

---
## Bemerkenswerte reale CVEs (2022-2025)

* **CVE-2023-25690** – Apache HTTP Server mod_proxy Umschreiberegeln könnten für Anfrageaufteilung und Smuggling verkettet werden. (behoben in 2.4.56)
* **CVE-2023-25950** – HAProxy 2.7/2.6 Anfrage/Antwort Smuggling, wenn der HTX-Parser pipelined Anfragen falsch handhabte.
* **CVE-2022-41721** – Go `MaxBytesHandler` verursachte, dass übrig gebliebene Body-Bytes als **HTTP/2**-Frames geparst wurden, was Cross-Protocol Smuggling ermöglichte.

---
## Werkzeuge

* **Burp Request Smuggler** – seit v1.26 testet es automatisch H2.TE/H2.CL und versteckte ALPN-Unterstützung. Aktiviere „HTTP/2-Probing“ in den Erweiterungsoptionen.
* **h2cSmuggler** – Python PoC von Bishop Fox zur Automatisierung des Klartext-Upgrade-Angriffs:
```bash
python3 h2csmuggler.py -u https://target -x 'GET /admin HTTP/1.1\r\nHost: target\r\n\r\n'
```
* **curl**/`hyper` – manuelles Erstellen von Payloads: `curl --http2-prior-knowledge -X POST --data-binary @payload.raw https://target`.

---
## Verteidigungsmaßnahmen

1. **End-to-End HTTP/2** – die Downgrade-Übersetzung vollständig eliminieren.
2. **Einzige Quelle der Längenwahrheit** – beim Downgrade *immer* eine gültige `Content-Length` **erzeugen** **und** alle benutzereingereichten `Content-Length`/`Transfer-Encoding`-Header **entfernen**.
3. **Normalisieren vor der Route** – Header-Sanitization *vor* der Routing-/Umschreibelogik anwenden.
4. **Verbindungsisolierung** – keine Back-End-TCP-Verbindungen zwischen Benutzern wiederverwenden; „eine Anfrage pro Verbindung“ besiegt warteschlangenbasierte Exploits.
5. **`Upgrade` entfernen, es sei denn WebSocket** – verhindert h2c-Tunneling.

---
## Referenzen

* PortSwigger Research – “HTTP/2: The Sequel is Always Worse” <https://portswigger.net/research/http2>
* Bishop Fox – “h2c Smuggling: request smuggling via HTTP/2 clear-text” <https://bishopfox.com/blog/h2c-smuggling-request>

{{#include ../../banners/hacktricks-training.md}}
