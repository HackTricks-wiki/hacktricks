# Request Smuggling in HTTP/2 Downgrades

{{#include ../../banners/hacktricks-training.md}}

HTTP/2 kwa ujumla inachukuliwa kuwa haina hatari kwa request-smuggling ya jadi kwa sababu urefu wa kila DATA frame ni wazi. **Ulinzi huo unakosekana mara tu proxy ya mbele “inaporomosha” ombi hilo hadi HTTP/1.x kabla ya kulipeleka kwa nyuma**. Wakati parser mbili tofauti (HTTP/2 front-end na HTTP/1 back-end) zinapojaribu kukubaliana juu ya mahali ambapo ombi moja linamalizika na lingine linaanza, hila zote za zamani za desync zinarejea – pamoja na chache mpya.

---
## Kwa nini kuporomoka kunatokea

1. Vivinjari tayari vinazungumza HTTP/2, lakini miundombinu ya zamani ya asili bado inelewa tu HTTP/1.1.
2. Reverse-proxies (CDNs, WAFs, load-balancers) kwa hivyo huweka mwisho TLS + HTTP/2 kwenye ukingo na **kuandika upya kila ombi kama HTTP/1.1** kwa asili.
3. Hatua ya tafsiri inahitaji kuunda *zote* `Content-Length` **na/au** `Transfer-Encoding: chunked` vichwa ili asili iweze kubaini urefu wa mwili.

Wakati wowote front-end inatilia maanani urefu wa frame ya HTTP/2 **lakini** back-end inatilia maanani CL au TE, mshambuliaji anaweza kuwafanya wasikubaliane.

---
## Daraja mbili kuu za primitive

| Variant | Front-end length | Back-end length | Typical payload |
|---------|-----------------|-----------------|-----------------|
| **H2.TE** | HTTP/2 frame | `Transfer-Encoding: chunked` | Weka ujumbe wa mwili wa chunked wa ziada ambao `0\r\n\r\n` wa mwisho haujatumwa, hivyo back-end inasubiri ombi la “next” lililotolewa na mshambuliaji. |
| **H2.CL** | HTTP/2 frame | `Content-Length` | Tuma *ndogo* CL kuliko mwili halisi, hivyo back-end inasoma zaidi ya mpaka katika ombi linalofuata. |

> Hizi ni sawa kwa roho na TE.CL / CL.TE za jadi, tu na HTTP/2 ikichukua nafasi ya mmoja wa waandishi.

---
## Kutambua mchain ya kuporomoka

1. Tumia **ALPN** katika handshake ya TLS (`openssl s_client -alpn h2 -connect host:443`) au **curl**:
```bash
curl -v --http2 https://target
```
Ikiwa `* Using HTTP2` inaonekana, ukingo unazungumza H2.
2. Tuma ombi la CL/TE lililokusudiwa vibaya *kupitia* HTTP/2 (Burp Repeater sasa ina dropdown ya kulazimisha HTTP/2). Ikiwa jibu ni kosa la HTTP/1.1 kama `400 Bad chunk`, una uthibitisho kwamba ukingo umebadilisha trafiki kwa parser ya HTTP/1 chini.

---
## Mchakato wa unyakuzi (mfano wa H2.TE)
```http
:method: POST
:path: /login
:scheme: https
:authority: example.com
content-length: 13      # ignored by the edge
transfer-encoding: chunked

5;ext=1\r\nHELLO\r\n
0\r\n\r\nGET /admin HTTP/1.1\r\nHost: internal\r\nX: X
```
1. **Front-end** inasoma byte 13 tu (`HELLO\r\n0\r\n\r\nGE`), inadhani ombi limekamilika na kupeleka kiasi hicho kwa asili.
2. **Back-end** inategemea kichwa cha TE, inaendelea kusoma hadi inapoona *ya pili* `0\r\n\r\n`, hivyo inatumia prefix ya ombi la pili la mshambuliaji (`GET /admin …`).
3. Kiasi kilichobaki (`GET /admin …`) kinachukuliwa kama ombi *jipya* lililoorodheshwa nyuma ya la mwathirika.

Badilisha ombi lililofichwa na:
* `POST /api/logout` kulazimisha kurekebisha kikao
* `GET /users/1234` kuiba rasilimali maalum ya mwathirika

---
## h2c smuggling (mabadiliko ya wazi)

Utafiti wa mwaka 2023 ulibaini kwamba ikiwa front-end inapita kichwa cha HTTP/1.1 `Upgrade: h2c` kwa back-end inayounga mkono HTTP/2 ya wazi, mshambuliaji anaweza kupitisha *raw* HTTP/2 frames kupitia edge ambayo ilithibitisha tu HTTP/1.1. Hii inakwepa kawaida ya kichwa, sheria za WAF na hata kumaliza TLS.

Mahitaji muhimu:
* Edge inapeleka **zote** `Connection: Upgrade` na `Upgrade: h2c` bila kubadilishwa.
* Asili inaongeza kwa HTTP/2 na inashikilia semantics za kurejelea muunganisho ambazo zinawezesha kuorodhesha maombi.

Kuzuia ni rahisi – ondoa au uweke kichwa cha `Upgrade` kwa edge isipokuwa kwa WebSockets.

---
## CVEs za kutambulika katika ulimwengu halisi (2022-2025)

* **CVE-2023-25690** – Sheria za mod_proxy za Apache HTTP Server zinaweza kuunganishwa kwa ajili ya kugawanya na kuficha maombi. (imekamilishwa katika 2.4.56)
* **CVE-2023-25950** – HAProxy 2.7/2.6 kuficha maombi/jibu wakati parser ya HTX iliposhughulikia vibaya maombi yaliyoandikwa kwa mfululizo.
* **CVE-2022-41721** – Go `MaxBytesHandler` ilisababisha byte za mwili zilizobaki kuchambuliwa kama **HTTP/2** frames, ikiruhusu kuficha kwa njia ya itifaki tofauti.

---
## Zana

* **Burp Request Smuggler** – tangu v1.26 inajaribu kiotomatiki H2.TE/H2.CL na msaada wa ALPN uliofichwa. Wezesha “HTTP/2 probing” katika chaguzi za nyongeza.
* **h2cSmuggler** – Python PoC na Bishop Fox ili kuendesha shambulio la mabadiliko ya wazi:
```bash
python3 h2csmuggler.py -u https://target -x 'GET /admin HTTP/1.1\r\nHost: target\r\n\r\n'
```
* **curl**/`hyper` – kuunda payloads za mikono: `curl --http2-prior-knowledge -X POST --data-binary @payload.raw https://target`.

---
## Hatua za kujihami

1. **HTTP/2 kutoka mwisho hadi mwisho** – ondolea kabisa tafsiri ya kudondosha.
2. **Chanzo kimoja cha ukweli wa urefu** – unaposhuka, *daima* tengeneza `Content-Length` halali **na** **ondoa** kichwa chochote kilichotolewa na mtumiaji `Content-Length`/`Transfer-Encoding`.
3. **Sanitiza kabla ya njia** – tumia usafi wa kichwa *kabla* ya mantiki ya kuelekeza/kurekebisha.
4. **Kutengwa kwa muunganisho** – usitumie muunganisho wa TCP wa back-end kati ya watumiaji; “ombio moja kwa muunganisho” inashinda unyanyasaji wa msingi wa orodha.
5. **Ondoa `Upgrade` isipokuwa WebSocket** – inazuia h2c tunnelling.

---
## Marejeleo

* PortSwigger Research – “HTTP/2: The Sequel is Always Worse” <https://portswigger.net/research/http2>
* Bishop Fox – “h2c Smuggling: request smuggling via HTTP/2 clear-text” <https://bishopfox.com/blog/h2c-smuggling-request>

{{#include ../../banners/hacktricks-training.md}}
