# Request Smuggling in HTTP/2 Downgrades

{{#include ../../banners/hacktricks-training.md}}

HTTP/2 se generalno smatra imunim na klasično request-smuggling jer je dužina svakog DATA okvira eksplicitna. **Ta zaštita nestaje čim front-end proxy “downgrade”-uje zahtev na HTTP/1.x pre nego što ga prosledi back-end-u**. U trenutku kada dva različita parsera (HTTP/2 front-end i HTTP/1 back-end) pokušaju da se dogovore gde jedan zahtev završava, a drugi počinje, svi stari desync trikovi se vraćaju – plus nekoliko novih.

---
## Zašto se downgrade-ovi dešavaju

1. Pregledači već govore HTTP/2, ali mnogo nasleđene infrastrukture još uvek razume samo HTTP/1.1.
2. Reverzni proxy-ji (CDN-ovi, WAF-ovi, load-balanceri) stoga završavaju TLS + HTTP/2 na ivici i **prepisuju svaki zahtev kao HTTP/1.1** za izvor.
3. Korak prevođenja mora da kreira *oba* `Content-Length` **i/ili** `Transfer-Encoding: chunked` zaglavlja kako bi izvor mogao da odredi dužinu tela.

Kad god front-end veruje u dužinu HTTP/2 okvira **ali** back-end veruje u CL ili TE, napadač može da ih primora da se ne slažu.

---
## Dve dominantne primitivne klase

| Variant | Front-end length | Back-end length | Typical payload |
|---------|-----------------|-----------------|-----------------|
| **H2.TE** | HTTP/2 frame | `Transfer-Encoding: chunked` | Uključite dodatno chunked telo poruke čiji konačni `0\r\n\r\n` *nije* poslat, tako da back-end čeka na napadačem obezbeđen “sledeći” zahtev. |
| **H2.CL** | HTTP/2 frame | `Content-Length` | Pošaljite *manji* CL od stvarnog tela, tako da back-end čita preko granice u sledeći zahtev. |

> Ove su identične u duhu klasičnim TE.CL / CL.TE, samo sa HTTP/2 koji zamenjuje jedan od parsera.

---
## Identifikacija downgrade lanca

1. Koristite **ALPN** u TLS rukovanju (`openssl s_client -alpn h2 -connect host:443`) ili **curl**:
```bash
curl -v --http2 https://target
```
Ako se pojavi `* Using HTTP2`, ivica govori H2.
2. Pošaljite namerno neispravan CL/TE zahtev *preko* HTTP/2 (Burp Repeater sada ima padajući meni za forsiranje HTTP/2). Ako je odgovor HTTP/1.1 greška kao što je `400 Bad chunk`, imate dokaz da je ivica konvertovala saobraćaj za HTTP/1 parser nizvodno.

---
## Eksploatacija radnog toka (H2.TE primer)
```http
:method: POST
:path: /login
:scheme: https
:authority: example.com
content-length: 13      # ignored by the edge
transfer-encoding: chunked

5;ext=1\r\nHELLO\r\n
0\r\n\r\nGET /admin HTTP/1.1\r\nHost: internal\r\nX: X
```
1. **front-end** čita tačno 13 bajtova (`HELLO\r\n0\r\n\r\nGE`), misli da je zahtev završen i prosleđuje toliko ka originu.
2. **back-end** veruje TE header-u, nastavlja da čita dok ne vidi *drugi* `0\r\n\r\n`, čime konzumira prefiks napadačevog drugog zahteva (`GET /admin …`).
3. Ostatak (`GET /admin …`) se tretira kao *novi* zahtev koji je u redu iza žrtvinog.

Zamenite prokrijumčaren zahtev sa:
* `POST /api/logout` da primorate fiksaciju sesije
* `GET /users/1234` da ukradete resurs specifičan za žrtvu

---
## h2c smuggling (nadogradnje u čistom tekstu)

Studija iz 2023. godine pokazala je da ako front-end prosledi HTTP/1.1 `Upgrade: h2c` header back-end-u koji podržava HTTP/2 u čistom tekstu, napadač može tunelovati *sirove* HTTP/2 okvire kroz ivicu koja je samo validirala HTTP/1.1. Ovo zaobilazi normalizaciju header-a, WAF pravila i čak TLS terminaciju.

Ključni zahtevi:
* Ivica prosleđuje **oba** `Connection: Upgrade` i `Upgrade: h2c` nepromenjena.
* Origin se povećava na HTTP/2 i zadržava semantiku ponovne upotrebe konekcije koja omogućava red čekanja zahteva.

Ublažavanje je jednostavno – uklonite ili hard-kodirajte `Upgrade` header na ivici osim za WebSocket.

---
## Značajni stvarni CVE-ovi (2022-2025)

* **CVE-2023-25690** – Apache HTTP Server mod_proxy pravila prepravke mogla su se povezati za deljenje i prokrijumčarenje zahteva. (ispravljeno u 2.4.56)
* **CVE-2023-25950** – HAProxy 2.7/2.6 prokrijumčarenje zahteva/odgovora kada je HTX parser pogrešno obradio pipelined zahteve.
* **CVE-2022-41721** – Go `MaxBytesHandler` je uzrokovao da preostali bajtovi tela budu analizirani kao **HTTP/2** okviri, omogućavajući prokrijumčarenje između protokola.

---
## Alati

* **Burp Request Smuggler** – od v1.26 automatski testira H2.TE/H2.CL i skrivenu ALPN podršku. Omogućite “HTTP/2 probing” u opcijama ekstenzije.
* **h2cSmuggler** – Python PoC od Bishop Fox-a za automatizaciju napada nadogradnje u čistom tekstu:
```bash
python3 h2csmuggler.py -u https://target -x 'GET /admin HTTP/1.1\r\nHost: target\r\n\r\n'
```
* **curl**/`hyper` – kreiranje ručnih payload-a: `curl --http2-prior-knowledge -X POST --data-binary @payload.raw https://target`.

---
## Defensivne mere

1. **End-to-end HTTP/2** – potpuno eliminisati prevod nadogradnje.
2. **Jedinstveni izvor dužine istine** – prilikom snižavanja, *uvek* generišite validan `Content-Length` **i** **uklonite** sve korisnički dostavljene `Content-Length`/`Transfer-Encoding` header-e.
3. **Normalizujte pre rute** – primenite sanitizaciju header-a *pre* logike usmeravanja/prepravke.
4. **Izolacija konekcije** – ne ponovo koristite back-end TCP konekcije između korisnika; “jedan zahtev po konekciji” poražava eksploate zasnovane na redu.
5. **Uklonite `Upgrade` osim WebSocket** – sprečava h2c tunelovanje.

---
## Reference

* PortSwigger Research – “HTTP/2: The Sequel is Always Worse” <https://portswigger.net/research/http2>
* Bishop Fox – “h2c Smuggling: request smuggling via HTTP/2 clear-text” <https://bishopfox.com/blog/h2c-smuggling-request>

{{#include ../../banners/hacktricks-training.md}}
