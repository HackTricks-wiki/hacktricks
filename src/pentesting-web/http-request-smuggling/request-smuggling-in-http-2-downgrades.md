# Versoek Smuggling in HTTP/2 Downgrades

{{#include ../../banners/hacktricks-training.md}}

HTTP/2 word oor die algemeen beskou as immuun teen klassieke request-smuggling omdat die lengte van elke DATA-raam eksplisiet is. **Daardie beskerming verdwyn sodra 'n front-end proxy die versoek na HTTP/1.x “downgrade” voordat dit na 'n back-end gestuur word**. Die oomblik wanneer twee verskillende parsers (die HTTP/2 front-end en die HTTP/1 back-end) probeer ooreen te kom oor waar een versoek eindig en die volgende begin, kom al die ou desync truuks terug – plus 'n paar nuwe.

---
## Waarom downgrades gebeur

1. Blaaiers praat reeds HTTP/2, maar baie ouer oorsprong infrastruktuur verstaan steeds net HTTP/1.1.
2. Terug-proxies (CDNs, WAFs, laai-balansers) beëindig dus TLS + HTTP/2 aan die rand en **herformuleer elke versoek as HTTP/1.1** vir die oorsprong.
3. Die vertaalstap moet *albei* `Content-Length` **en/of** `Transfer-Encoding: chunked` koppe skep sodat die oorsprong die liggaamslengte kan bepaal.

Wanneer die front-end die HTTP/2 raam lengte **maar** die back-end CL of TE vertrou, kan 'n aanvaller hulle dwing om nie saam te stem nie.

---
## Twee dominante primitiewe klasse

| Variant | Front-end lengte | Back-end lengte | Tipiese payload |
|---------|-----------------|-----------------|-----------------|
| **H2.TE** | HTTP/2 raam | `Transfer-Encoding: chunked` | Sluit 'n ekstra chunked boodskap liggaam in waarvan die finale `0\r\n\r\n` *nie* gestuur word nie, sodat die back-end wag vir die aanvaller-geleverde “volgende” versoek. |
| **H2.CL** | HTTP/2 raam | `Content-Length` | Stuur 'n *kleiner* CL as die werklike liggaam, sodat die back-end oor die grens lees in die volgende versoek. |

> Hierdie is identies in gees aan klassieke TE.CL / CL.TE, net met HTTP/2 wat een van die parsers vervang.

---
## Identifisering van 'n downgrade ketting

1. Gebruik **ALPN** in 'n TLS handdruk (`openssl s_client -alpn h2 -connect host:443`) of **curl**:
```bash
curl -v --http2 https://target
```
As `* Using HTTP2` verskyn, praat die rand H2.
2. Stuur 'n doelbewus verkeerd gevormde CL/TE versoek *oor* HTTP/2 (Burp Repeater het nou 'n keuselys om HTTP/2 te dwing). As die antwoord 'n HTTP/1.1 fout soos `400 Bad chunk` is, het jy bewys dat die rand die verkeer vir 'n HTTP/1 parser stroomaf omgeskakel het.

---
## Exploitasiestroom (H2.TE voorbeeld)
```http
:method: POST
:path: /login
:scheme: https
:authority: example.com
content-length: 13      # ignored by the edge
transfer-encoding: chunked

5;ext=1\r\nHELLO\r\n
0\r\n\r\nGET /admin HTTP/1.1\r\nHost: internal\r\nX: X
```
1. Die **front-end** lees presies 13 bytes (`HELLO\r\n0\r\n\r\nGE`), dink die versoek is klaar en stuur dit soveel na die oorsprong.
2. Die **back-end** vertrou die TE-header, hou aan lees totdat dit die *tweede* `0\r\n\r\n` sien, en verbruik so die voorvoegsel van die aanvaller se tweede versoek (`GET /admin …`).
3. Die oorblyfsels (`GET /admin …`) word as 'n *nuwe* versoek behandel wat agter die slagoffer se versoek in die tou staan.

Vervang die gesmokkelde versoek met:
* `POST /api/logout` om sessiefiksasie af te dwing
* `GET /users/1234` om 'n slagoffer-spesifieke hulpbron te steel

---
## h2c smuggling (helder teks opgraderings)

'n Studie in 2023 het getoon dat as 'n front-end die HTTP/1.1 `Upgrade: h2c` header aan 'n back-end wat helder teks HTTP/2 ondersteun, oorgedra, 'n aanvaller *raw* HTTP/2 rame deur 'n rand kan tunnel wat slegs gevalideerde HTTP/1.1 ondersteun. Dit omseil header normalisering, WAF-reëls en selfs TLS-terminasie.

Belangrike vereistes:
* Rand stuur **albei** `Connection: Upgrade` en `Upgrade: h2c` onveranderd voort.
* Oorsprong verhoog na HTTP/2 en hou die verbinding-hergebruik semantiek wat versoek-tou moontlik maak.

Mitigering is eenvoudig – verwyder of hard-kodeer die `Upgrade` header by die rand, behalwe vir WebSockets.

---
## Noemenswaardige werklike CVE's (2022-2025)

* **CVE-2023-25690** – Apache HTTP Server mod_proxy herskryf reëls kan geketting word vir versoek splitsing en smuggling. (reggestel in 2.4.56)
* **CVE-2023-25950** – HAProxy 2.7/2.6 versoek/antwoord smuggling wanneer HTX parser pyplyn versoeke verkeerd hanteer.
* **CVE-2022-41721** – Go `MaxBytesHandler` het veroorsaak dat oorblywende liggaamsbytes as **HTTP/2** rame geparseer word, wat kruis-protokol smuggling moontlik maak.

---
## Gereedskap

* **Burp Request Smuggler** – sedert v1.26 toets dit outomaties H2.TE/H2.CL en versteekte ALPN-ondersteuning. Aktiveer “HTTP/2 probing” in die uitbreiding opsies.
* **h2cSmuggler** – Python PoC deur Bishop Fox om die helder teks opgradering aanval te outomatiseer:
```bash
python3 h2csmuggler.py -u https://target -x 'GET /admin HTTP/1.1\r\nHost: target\r\n\r\n'
```
* **curl**/`hyper` – handmatige payloads saamstel: `curl --http2-prior-knowledge -X POST --data-binary @payload.raw https://target`.

---
## Verdedigingsmaatreëls

1. **Eind-tot-eind HTTP/2** – elimineer die afgraderingsvertaling heeltemal.
2. **Enkele bron van lengte waarheid** – wanneer afgraderend, *altyd* 'n geldige `Content-Length` **en** **verwyder** enige gebruiker-gelewer `Content-Length`/`Transfer-Encoding` headers genereer.
3. **Normaliseer voor roete** – pas header-sanitizering *voor* roetering/herskryf logika toe.
4. **Verbinding isolasie** – moenie back-end TCP verbindings oor gebruikers hergebruik nie; “een versoek per verbinding” verslaan tou-gebaseerde eksplosies.
5. **Verwyder `Upgrade` tensy WebSocket** – voorkom h2c tunneling.

---
## Verwysings

* PortSwigger Navorsing – “HTTP/2: Die vervolg is altyd erger” <https://portswigger.net/research/http2>
* Bishop Fox – “h2c Smuggling: versoek smuggling via HTTP/2 helder teks” <https://bishopfox.com/blog/h2c-smuggling-request>

{{#include ../../banners/hacktricks-training.md}}
