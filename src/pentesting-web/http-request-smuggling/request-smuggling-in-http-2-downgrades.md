# Request Smuggling in HTTP/2 Downgrades

{{#include ../../banners/hacktricks-training.md}}

HTTP/2 зазвичай вважається захищеним від класичного request-smuggling, оскільки довжина кожного DATA фрейму є явною. **Ця захист зникає, як тільки фронтальний проксі “знижує” запит до HTTP/1.x перед тим, як передати його на бекенд**. У момент, коли два різні парсери (фронтальний HTTP/2 і бекенд HTTP/1) намагаються домовитися, де закінчується один запит і де починається наступний, всі старі трюки десинхронізації повертаються – плюс кілька нових.

---
## Чому відбуваються зниження

1. Браузери вже підтримують HTTP/2, але багато застарілої інфраструктури все ще розуміє лише HTTP/1.1.
2. Зворотні проксі (CDN, WAF, балансувальники навантаження) тому завершують TLS + HTTP/2 на краю і **переписують кожен запит як HTTP/1.1** для походження.
3. Крок перекладу повинен створити *обидва* заголовки `Content-Length` **і/або** `Transfer-Encoding: chunked`, щоб походження могло визначити довжину тіла.

Коли фронтальний проксі довіряє довжині фрейму HTTP/2 **але** бекенд довіряє CL або TE, зловмисник може змусити їх не погоджуватися.

---
## Дві домінуючі класи примітивів

| Варіант | Довжина фронтального | Довжина бекендного | Типове навантаження |
|---------|---------------------|---------------------|---------------------|
| **H2.TE** | HTTP/2 фрейм | `Transfer-Encoding: chunked` | Вбудувати додаткове тіло повідомлення з частинами, останній `0\r\n\r\n` якого *не* надсилається, тому бекенд чекає на “наступний” запит, наданий зловмисником. |
| **H2.CL** | HTTP/2 фрейм | `Content-Length` | Надіслати *менший* CL, ніж реальне тіло, щоб бекенд читав за межами кордону в наступний запит. |

> Це ідентичні за духом класичним TE.CL / CL.TE, просто з HTTP/2, що замінює один з парсерів.

---
## Визначення ланцюга зниження

1. Використовуйте **ALPN** у TLS рукопожатті (`openssl s_client -alpn h2 -connect host:443`) або **curl**:
```bash
curl -v --http2 https://target
```
Якщо з'являється `* Using HTTP2`, край говорить H2.
2. Надішліть навмисно неправильно сформований запит CL/TE *через* HTTP/2 (Burp Repeater тепер має випадаюче меню для примусової роботи з HTTP/2). Якщо відповідь є помилкою HTTP/1.1, такою як `400 Bad chunk`, у вас є доказ того, що край конвертував трафік для парсера HTTP/1 вниз за течією.

---
## Робочий процес експлуатації (приклад H2.TE)
```http
:method: POST
:path: /login
:scheme: https
:authority: example.com
content-length: 13      # ignored by the edge
transfer-encoding: chunked

5;ext=1\r\nHELLO\r\n
0\r\n\r\nGET /admin HTTP/1.1\r\nHost: internal\r\nX: X
```
1. **Фронт-енд** читає точно 13 байтів (`HELLO\r\n0\r\n\r\nGE`), вважає, що запит завершено, і пересилає цю частину до оригіналу.
2. **Бек-енд** довіряє заголовку TE, продовжує читати, поки не побачить *другий* `0\r\n\r\n`, таким чином споживаючи префікс другого запиту атакуючого (`GET /admin …`).
3. Решта (`GET /admin …`) розглядається як *новий* запит, що стоїть у черзі за запитом жертви.

Замініть підслуханий запит на:
* `POST /api/logout` для примусової фіксації сесії
* `GET /users/1234` для викрадення ресурсу, специфічного для жертви

---
## h2c smuggling (чисті текстові оновлення)

Дослідження 2023 року показало, що якщо фронт-енд передає заголовок HTTP/1.1 `Upgrade: h2c` бек-енду, який підтримує чистий текст HTTP/2, атакуючий може тунелювати *сирі* HTTP/2 фрейми через край, який лише перевіряв HTTP/1.1. Це обминає нормалізацію заголовків, правила WAF і навіть завершення TLS.

Ключові вимоги:
* Край передає **обидва** `Connection: Upgrade` і `Upgrade: h2c` без змін.
* Оригінал переходить на HTTP/2 і зберігає семантику повторного використання з'єднання, що дозволяє чергування запитів.

Зменшення ризиків просте – видалити або жорстко закодувати заголовок `Upgrade` на краю, за винятком WebSockets.

---
## Помітні реальні CVE (2022-2025)

* **CVE-2023-25690** – Правила переписування mod_proxy Apache HTTP Server можуть бути з'єднані для розділення запитів і підслуховування. (виправлено в 2.4.56)
* **CVE-2023-25950** – HAProxy 2.7/2.6 підслуховування запитів/відповідей, коли парсер HTX неправильно обробляв конвеєрні запити.
* **CVE-2022-41721** – Go `MaxBytesHandler` призвів до того, що залишкові байти тіла були розібрані як **HTTP/2** фрейми, що дозволило міжпротокольне підслуховування.

---
## Інструменти

* **Burp Request Smuggler** – з версії v1.26 автоматично тестує H2.TE/H2.CL і приховану підтримку ALPN. Увімкніть “HTTP/2 probing” в параметрах розширення.
* **h2cSmuggler** – Python PoC від Bishop Fox для автоматизації атаки чистого тексту:
```bash
python3 h2csmuggler.py -u https://target -x 'GET /admin HTTP/1.1\r\nHost: target\r\n\r\n'
```
* **curl**/`hyper` – створення ручних корисних навантажень: `curl --http2-prior-knowledge -X POST --data-binary @payload.raw https://target`.

---
## Заходи захисту

1. **End-to-end HTTP/2** – повністю усунути зниження перекладу.
2. **Єдине джерело правди про довжину** – під час зниження *завжди* генерувати дійсний `Content-Length` **і** **видаляти** будь-які заголовки `Content-Length`/`Transfer-Encoding`, надані користувачем.
3. **Нормалізувати перед маршрутом** – застосовувати санітаризацію заголовків *перед* логікою маршрутизації/переписування.
4. **Ізоляція з'єднання** – не повторно використовувати TCP з'єднання бек-енду між користувачами; “один запит на з'єднання” перемагає експлойти на основі черги.
5. **Видалити `Upgrade`, якщо не WebSocket** – запобігає тунелюванню h2c.

---
## Посилання

* PortSwigger Research – “HTTP/2: Продовження завжди гірше” <https://portswigger.net/research/http2>
* Bishop Fox – “h2c Smuggling: підслуховування запитів через HTTP/2 чистий текст” <https://bishopfox.com/blog/h2c-smuggling-request>

{{#include ../../banners/hacktricks-training.md}}
