# HTTP/2 Düşürmelerinde İstek Smuggling'i

{{#include ../../banners/hacktricks-training.md}}

HTTP/2 genellikle klasik istek-smuggling'e karşı bağışık olarak kabul edilir çünkü her DATA çerçevesinin uzunluğu açıktır. **Bu koruma, bir ön uç proxy'si isteği HTTP/1.x'e “düşürdüğünde” kaybolur ve bunu arka uca iletir.** İki farklı ayrıştırıcı (HTTP/2 ön ucu ve HTTP/1 arka ucu) bir isteğin nerede bittiği ve diğerinin nerede başladığı konusunda anlaşmaya çalıştığında, tüm eski senkronizasyon bozulma numaraları geri gelir - artı birkaç yeni numara.

---
## Düşürmelerin Nedenleri

1. Tarayıcılar zaten HTTP/2 konuşuyor, ancak birçok eski köken altyapısı hala yalnızca HTTP/1.1'i anlıyor.
2. Bu nedenle, ters proxy'ler (CDN'ler, WAF'lar, yük dengeleyiciler) TLS + HTTP/2'yi kenarda sonlandırır ve **her isteği HTTP/1.1 olarak yeniden yazar**.
3. Çeviri adımı, kökenin gövde uzunluğunu belirleyebilmesi için *her ikisini de* `Content-Length` **veya** `Transfer-Encoding: chunked` başlıklarını oluşturmak zorundadır.

Ön uç HTTP/2 çerçeve uzunluğuna **güvendiğinde** ancak arka uç CL veya TE'ye güvendiğinde, bir saldırgan bunların anlaşmazlık yaşamasını sağlayabilir.

---
## İki Dominant Temel Sınıf

| Varyant | Ön uç uzunluğu | Arka uç uzunluğu | Tipik yük |
|---------|-----------------|-----------------|-----------------|
| **H2.TE** | HTTP/2 çerçevesi | `Transfer-Encoding: chunked` | Son `0\r\n\r\n` gönderilmeyen ekstra bir chunked mesaj gövdesi ekleyin, böylece arka uç saldırgan tarafından sağlanan “sonraki” isteği bekler. |
| **H2.CL** | HTTP/2 çerçevesi | `Content-Length` | Gerçek gövdeden *daha küçük* bir CL gönderin, böylece arka uç sınırın ötesine geçerek sonraki isteği okur. |

> Bunlar, klasik TE.CL / CL.TE ile ruhsal olarak aynıdır, sadece HTTP/2 bir ayrıştırıcıyı değiştirmiştir.

---
## Düşürme Zincirini Tanımlama

1. **ALPN** kullanarak bir TLS el sıkışmasında (`openssl s_client -alpn h2 -connect host:443`) veya **curl**:
```bash
curl -v --http2 https://target
```
Eğer `* Using HTTP2` görünüyorsa, kenar H2 konuşuyor demektir.
2. HTTP/2 üzerinden kasıtlı olarak hatalı bir CL/TE isteği gönderin (Burp Repeater artık HTTP/2'yi zorlamak için bir açılır menüye sahiptir). Eğer yanıt bir HTTP/1.1 hatası olan `400 Bad chunk` ise, kenarın trafiği bir HTTP/1 ayrıştırıcısı için dönüştürdüğüne dair kanıtınız var demektir.

---
## Sömürü İş Akışı (H2.TE örneği)
```http
:method: POST
:path: /login
:scheme: https
:authority: example.com
content-length: 13      # ignored by the edge
transfer-encoding: chunked

5;ext=1\r\nHELLO\r\n
0\r\n\r\nGET /admin HTTP/1.1\r\nHost: internal\r\nX: X
```
1. **Ön uç** tam olarak 13 bayt okur (`HELLO\r\n0\r\n\r\nGE`), isteğin tamamlandığını düşünür ve bu kadarını orijine iletir.
2. **Arka uç** TE başlığına güvenir, *ikinci* `0\r\n\r\n` görünene kadar okumaya devam eder ve böylece saldırganın ikinci isteğinin ön ekini (`GET /admin …`) tüketir.
3. Kalan (`GET /admin …`) kurbanın arkasında bekleyen *yeni* bir istek olarak işlenir.

Kaçırılan isteği şunlarla değiştirin:
* `POST /api/logout` oturum sabitlemeyi zorlamak için
* `GET /users/1234` kurbana özgü bir kaynağı çalmak için

---
## h2c smuggling (düz metin yükseltmeleri)

2023'te yapılan bir çalışma, bir ön ucun HTTP/1.1 `Upgrade: h2c` başlığını düz metin HTTP/2'yi destekleyen bir arka uca iletmesi durumunda, bir saldırganın yalnızca HTTP/1.1'i doğrulayan bir kenar üzerinden *ham* HTTP/2 çerçevelerini tünelleme yapabileceğini göstermiştir. Bu, başlık normalizasyonunu, WAF kurallarını ve hatta TLS sonlandırmasını atlar.

Ana gereksinimler:
* Kenar, **her iki** `Connection: Upgrade` ve `Upgrade: h2c` başlıklarını değiştirmeden iletmelidir.
* Orijin, HTTP/2'ye geçiş yapmalı ve istek kuyruklama yeteneklerini sağlayan bağlantı yeniden kullanım anlamlarını korumalıdır.

Hafifletme basittir – WebSocket'ler hariç, kenarda `Upgrade` başlığını kaldırın veya sabit kodlayın.

---
## Dikkate değer gerçek dünya CVE'leri (2022-2025)

* **CVE-2023-25690** – Apache HTTP Server mod_proxy yeniden yazma kuralları, istek bölme ve kaçırma için zincirlenebilir. (2.4.56'da düzeltildi)
* **CVE-2023-25950** – HTX ayrıştırıcısının hatalı bir şekilde işlediği boru hatlı isteklerde HAProxy 2.7/2.6 istek/yanıt kaçırma.
* **CVE-2022-41721** – Go `MaxBytesHandler`, kalan gövde baytlarının **HTTP/2** çerçeveleri olarak işlenmesine neden olarak protokoller arası kaçırmayı sağladı.

---
## Araçlar

* **Burp Request Smuggler** – v1.26'dan itibaren otomatik olarak H2.TE/H2.CL ve gizli ALPN desteğini test eder. Uzantı seçeneklerinde “HTTP/2 probing”i etkinleştirin.
* **h2cSmuggler** – düz metin yükseltme saldırısını otomatikleştirmek için Bishop Fox tarafından oluşturulan Python PoC:
```bash
python3 h2csmuggler.py -u https://target -x 'GET /admin HTTP/1.1\r\nHost: target\r\n\r\n'
```
* **curl**/`hyper` – manuel yükler oluşturma: `curl --http2-prior-knowledge -X POST --data-binary @payload.raw https://target`.

---
## Savunma önlemleri

1. **Uçtan uca HTTP/2** – düşürme çevirisini tamamen ortadan kaldırın.
2. **Uzunluk gerçeğinin tek kaynağı** – düşürme sırasında, *her zaman* geçerli bir `Content-Length` **ve** **kaldırın** herhangi bir kullanıcı tarafından sağlanan `Content-Length`/`Transfer-Encoding` başlıklarını.
3. **Yol öncesi normalleştirme** – başlık sanitizasyonunu *yol verme/yazma mantığından önce* uygulayın.
4. **Bağlantı izolasyonu** – kullanıcılar arasında arka uç TCP bağlantılarını yeniden kullanmayın; “her bağlantıda bir istek” kuyruk tabanlı istismarları bozar.
5. **WebSocket hariç `Upgrade` başlığını kaldırın** – h2c tünellemesini önler.

---
## Referanslar

* PortSwigger Research – “HTTP/2: The Sequel is Always Worse” <https://portswigger.net/research/http2>
* Bishop Fox – “h2c Smuggling: request smuggling via HTTP/2 clear-text” <https://bishopfox.com/blog/h2c-smuggling-request>

{{#include ../../banners/hacktricks-training.md}}
