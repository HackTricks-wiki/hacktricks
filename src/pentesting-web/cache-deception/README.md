# 캐시 오염 및 캐시 기만

{{#include ../../banners/hacktricks-training.md}}

## 차이점

> **웹 캐시 오염과 웹 캐시 기만의 차이점은 무엇인가요?**
>
> - **웹 캐시 오염**에서는 공격자가 애플리케이션이 캐시에 악성 콘텐츠를 저장하도록 하며, 이 콘텐츠는 캐시에서 다른 애플리케이션 사용자에게 제공됩니다.
> - **웹 캐시 기만**에서는 공격자가 애플리케이션이 다른 사용자의 민감한 콘텐츠를 캐시에 저장하도록 하며, 공격자는 이후 이 콘텐츠를 캐시에서 검색합니다.

## 캐시 오염

캐시 오염은 클라이언트 측 캐시를 조작하여 클라이언트가 예상치 못한, 부분적이거나 공격자가 제어하는 리소스를 로드하도록 강제하는 것을 목표로 합니다. 영향의 정도는 영향을 받는 페이지의 인기 여부에 따라 달라지며, 오염된 응답은 캐시 오염 기간 동안 페이지를 방문하는 사용자에게만 제공됩니다.

캐시 오염 공격의 실행에는 여러 단계가 포함됩니다:

1. **키가 없는 입력 식별**: 이러한 매개변수는 요청이 캐시되기 위해 필요하지 않지만, 서버가 반환하는 응답을 변경할 수 있습니다. 이러한 입력을 식별하는 것은 캐시를 조작하는 데 악용될 수 있으므로 중요합니다.
2. **키가 없는 입력 악용**: 키가 없는 입력을 식별한 후, 다음 단계는 이러한 매개변수를 잘못 사용하여 공격자에게 유리한 방식으로 서버의 응답을 수정하는 방법을 파악하는 것입니다.
3. **오염된 응답이 캐시되도록 보장**: 마지막 단계는 조작된 응답이 캐시에 저장되도록 보장하는 것입니다. 이렇게 하면 캐시가 오염된 동안 영향을 받는 페이지에 접근하는 모든 사용자가 오염된 응답을 받게 됩니다.

### 발견: HTTP 헤더 확인

일반적으로 응답이 **캐시에 저장되었을 때** **그를 나타내는 헤더**가 있을 것입니다. 이 게시물에서 주의해야 할 헤더를 확인할 수 있습니다: [**HTTP 캐시 헤더**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### 발견: 캐시 오류 코드

응답이 캐시에 저장되고 있다고 생각된다면, **잘못된 헤더로 요청을 보내는** 것을 시도해 볼 수 있습니다. 이 경우 **상태 코드 400**으로 응답해야 합니다. 그런 다음 요청을 정상적으로 접근해 보고 **응답이 400 상태 코드**인 경우, 취약하다는 것을 알 수 있습니다(DoS를 수행할 수도 있습니다).

더 많은 옵션은 다음에서 찾을 수 있습니다:

{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

그러나 **때때로 이러한 종류의 상태 코드는 캐시되지 않기 때문에** 이 테스트가 신뢰할 수 없을 수 있습니다.

### 발견: 키가 없는 입력 식별 및 평가

[**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943)를 사용하여 **응답을 변경할 수 있는 매개변수와 헤더를 브루트 포스**할 수 있습니다. 예를 들어, 페이지가 클라이언트가 그곳에서 스크립트를 로드하도록 지시하기 위해 `X-Forwarded-For` 헤더를 사용할 수 있습니다:
```markup
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### 백엔드 서버에서 유해한 응답 유도하기

매개변수/헤더가 확인되면 **소독**이 어떻게 이루어지는지와 **어디서** 응답에 **반영**되거나 영향을 미치는지 확인하십시오. 이를 악용할 수 있는 방법이 있습니까? (XSS를 수행하거나 당신이 제어하는 JS 코드를 로드할 수 있습니까? DoS를 수행할 수 있습니까?...)

### 응답 캐시 가져오기

악용할 수 있는 **페이지**를 **확인**하고 사용할 **매개변수**/**헤더**와 **악용하는 방법**을 파악한 후, 페이지를 캐시해야 합니다. 캐시에 가져오려는 리소스에 따라 시간이 걸릴 수 있으며, 몇 초 동안 시도해야 할 수도 있습니다.

응답의 헤더 **`X-Cache`**는 요청이 캐시되지 않았을 때 **`miss`** 값을 가질 수 있고, 캐시되었을 때는 **`hit`** 값을 가질 수 있으므로 매우 유용할 수 있습니다.\
헤더 **`Cache-Control`**은 리소스가 캐시되고 있는지, 다음에 리소스가 다시 캐시될 때를 알기 위해 아는 것이 흥미롭습니다: `Cache-Control: public, max-age=1800`

또 다른 흥미로운 헤더는 **`Vary`**입니다. 이 헤더는 종종 **캐시 키의 일부로 처리되는 추가 헤더**를 **지시하는 데 사용**되며, 일반적으로 키가 없는 경우에도 해당됩니다. 따라서 사용자가 타겟으로 하는 피해자의 `User-Agent`를 알고 있다면, 특정 `User-Agent`를 사용하는 사용자들을 위해 캐시를 오염시킬 수 있습니다.

캐시와 관련된 또 다른 헤더는 **`Age`**입니다. 이는 객체가 프록시 캐시에 있는 시간을 초 단위로 정의합니다.

요청을 캐시할 때는 사용하는 헤더에 **주의해야** 합니다. 일부 헤더는 **예상치 않게** **키가 있는** 것으로 사용될 수 있으며, **피해자는 동일한 헤더를 사용해야** 합니다. 항상 **다양한 브라우저**로 캐시 오염을 **테스트**하여 작동하는지 확인하십시오.

## 악용 예시

### 가장 쉬운 예

헤더 `X-Forwarded-For`가 응답에 소독되지 않고 반영되고 있습니다.\
기본 XSS 페이로드를 보내고 캐시를 오염시켜 페이지에 접근하는 모든 사람이 XSS에 노출되도록 할 수 있습니다:
```markup
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_이 요청은 `/en?region=uk`에 대한 것이며 `/en`에 대한 것이 아닙니다._

### DoS를 위한 캐시 오염

{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### 쿠키 처리 취약점을 악용하기 위한 웹 캐시 오염 사용

쿠키는 페이지의 응답에 반영될 수도 있습니다. 예를 들어, 이를 악용하여 XSS를 유발할 수 있다면, 악성 캐시 응답을 로드하는 여러 클라이언트에서 XSS를 악용할 수 있습니다.
```markup
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
취약한 쿠키가 사용자에 의해 많이 사용되는 경우, 정기적인 요청이 캐시를 정리할 것임을 유의하십시오.

### 구분 기호, 정규화 및 점을 사용한 불일치 생성 <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

확인:

{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### API 키를 훔치기 위한 경로 탐색을 통한 캐시 오염 <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**이 글에서는**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`와 같은 URL로 OpenAI API 키를 훔칠 수 있었던 방법을 설명합니다. `/share/*`와 일치하는 모든 것이 Cloudflare가 URL을 정규화하지 않고 캐시되기 때문에, 요청이 웹 서버에 도달했을 때 정규화가 이루어졌습니다.

이것은 다음에서 더 잘 설명됩니다:

{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### 웹 캐시 오염 취약점을 악용하기 위한 여러 헤더 사용 <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

때때로 **캐시를 악용하기 위해 여러 개의 키가 없는 입력을 악용해야** 할 필요가 있습니다. 예를 들어, `X-Forwarded-Host`를 귀하가 제어하는 도메인으로 설정하고 `X-Forwarded-Scheme`을 `http`로 설정하면 **Open redirect**를 찾을 수 있습니다. **서버**가 모든 **HTTP** 요청을 **HTTPS**로 **전달**하고 `X-Forwarded-Scheme` 헤더를 리디렉션을 위한 도메인 이름으로 사용하는 경우, 리디렉션에 의해 페이지가 가리키는 위치를 제어할 수 있습니다.
```markup
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### 제한된 `Vary` 헤더로 악용하기

**`X-Host`** 헤더가 **JS 리소스를 로드하기 위한 도메인 이름**으로 사용되고 있지만, 응답의 **`Vary`** 헤더가 **`User-Agent`**를 나타내고 있다면, 피해자의 User-Agent를 유출하고 해당 User-Agent를 사용하여 캐시를 오염시킬 방법을 찾아야 합니다:
```markup
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

URL와 본문에 요청을 포함한 GET 요청을 보냅니다. 웹 서버가 본문에서 요청을 사용하지만 캐시 서버가 URL에서 요청을 캐시하는 경우, 해당 URL에 접근하는 모든 사용자는 실제로 본문에서 매개변수를 사용하게 됩니다. James Kettle이 Github 웹사이트에서 발견한 취약점과 같습니다:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
There it a portswigger lab about this: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

예를 들어, **parameters**를 ruby 서버에서 **`;`** 문자를 사용하여 **`&`** 대신 구분할 수 있습니다. 이를 통해 키가 없는 매개변수 값을 키가 있는 매개변수 안에 넣고 악용할 수 있습니다.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

여기에서 [Cache Poisoning 공격을 HTTP Request Smuggling을 악용하여 수행하는 방법](../http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-poisoning)에 대해 알아보세요.

### Automated testing for Web Cache Poisoning

[Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner)는 웹 캐시 오염을 자동으로 테스트하는 데 사용할 수 있습니다. 다양한 기술을 지원하며 매우 사용자 정의가 가능합니다.

Example usage: `wcvs -u example.com`

## Vulnerable Examples

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS는 URL 내의 조각을 제거하지 않고 전달했으며, 호스트, 경로 및 쿼리만 사용하여 캐시 키를 생성했습니다(조각을 무시함). 따라서 요청 `/#/../?r=javascript:alert(1)`은 백엔드에 `/#/../?r=javascript:alert(1)`로 전송되었고, 캐시 키에는 페이로드가 포함되지 않았습니다. 오직 호스트, 경로 및 쿼리만 포함되었습니다.

### GitHub CP-DoS

content-type 헤더에 잘못된 값을 보내면 405 캐시 응답이 발생했습니다. 캐시 키에는 쿠키가 포함되어 있어 인증되지 않은 사용자만 공격할 수 있었습니다.

### GitLab + GCP CP-DoS

GitLab은 정적 콘텐츠를 저장하기 위해 GCP 버킷을 사용합니다. **GCP Buckets**는 **헤더 `x-http-method-override`**를 지원합니다. 따라서 헤더 `x-http-method-override: HEAD`를 보내고 캐시를 오염시켜 빈 응답 본문을 반환하도록 할 수 있었습니다. 또한 `PURGE` 메서드를 지원할 수 있었습니다.

### Rack Middleware (Ruby on Rails)

Ruby on Rails 애플리케이션에서는 Rack 미들웨어가 자주 사용됩니다. Rack 코드의 목적은 **`x-forwarded-scheme`** 헤더의 값을 가져와 요청의 스킴으로 설정하는 것입니다. 헤더 `x-forwarded-scheme: http`가 전송되면 동일한 위치로 301 리디렉션이 발생하여 해당 리소스에 대한 서비스 거부(DoS)를 유발할 수 있습니다. 또한 애플리케이션은 `X-forwarded-host` 헤더를 인식하고 사용자를 지정된 호스트로 리디렉션할 수 있습니다. 이 동작은 공격자의 서버에서 JavaScript 파일을 로드하게 하여 보안 위험을 초래할 수 있습니다.

### 403 and Storage Buckets

Cloud
