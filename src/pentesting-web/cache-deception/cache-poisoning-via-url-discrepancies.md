# Cache Poisoning via URL discrepancies

{{#include ../../banners/hacktricks-training.md}}

To jest podsumowanie technik zaproponowanych w poście [https://portswigger.net/research/gotta-cache-em-all](https://portswigger.net/research/gotta-cache-em-all) w celu przeprowadzenia ataków na cache **wykorzystujących rozbieżności między proxy cache a serwerami webowymi.**

> [!NOTE]
> Celem tego ataku jest **sprawienie, aby serwer cache myślał, że ładowany jest zasób statyczny**, więc go buforuje, podczas gdy serwer cache przechowuje jako klucz cache część ścieżki, ale serwer webowy odpowiada, rozwiązując inną ścieżkę. Serwer webowy rozwiąże rzeczywistą ścieżkę, która będzie ładować dynamiczną stronę (która może przechowywać wrażliwe informacje o użytkowniku, złośliwy ładunek, taki jak XSS, lub przekierowywać do załadowania pliku JS z witryny atakującego, na przykład).

## Delimitery

**Delimitery URL** różnią się w zależności od frameworka i serwera, co wpływa na to, jak żądania są kierowane i jak obsługiwane są odpowiedzi. Niektóre powszechne delimitery pochodzenia to:

- **Średnik**: Używany w Spring do zmiennych macierzowych (np. `/hello;var=a/world;var1=b;var2=c` → `/hello/world`).
- **Kropka**: Określa format odpowiedzi w Ruby on Rails (np. `/MyAccount.css` → `/MyAccount`).
- **Bajt null**: Skraca ścieżki w OpenLiteSpeed (np. `/MyAccount%00aaa` → `/MyAccount`).
- **Bajt nowej linii**: Oddziela komponenty URL w Nginx (np. `/users/MyAccount%0aaaa` → `/account/MyAccount`).

Inne specyficzne delimitery mogą być znalezione w trakcie tego procesu:

- **Krok 1**: Zidentyfikuj żądania, które nie mogą być buforowane, i użyj ich do monitorowania, jak obsługiwane są URL-e z potencjalnymi delimiterami.
- **Krok 2**: Dodaj losowe sufiksy do ścieżek i porównaj odpowiedź serwera, aby określić, czy znak działa jako delimiter.
- **Krok 3**: Wprowadź potencjalne delimitery przed losowym sufiksem, aby sprawdzić, czy odpowiedź się zmienia, co wskazuje na użycie delimitera.

## Normalizacja i kodowania

- **Cel**: Parsery URL w serwerach cache i serwerach pochodzenia normalizują URL-e, aby wyodrębnić ścieżki do mapowania punktów końcowych i kluczy cache.
- **Proces**: Identyfikuje delimitery ścieżek, wyodrębnia i normalizuje ścieżkę, dekodując znaki i usuwając segmenty kropkowe.

### **Kodowania**

Różne serwery HTTP i proxy, takie jak Nginx, Node i CloudFront, dekodują delimitery w różny sposób, co prowadzi do niespójności między CDN-ami a serwerami pochodzenia, które mogą być wykorzystane. Na przykład, jeśli serwer webowy wykonuje tę transformację `/myAccount%3Fparam` → `/myAccount?param`, ale serwer cache zachowuje jako klucz ścieżkę `/myAccount%3Fparam`, występuje niespójność.

Sposobem na sprawdzenie tych niespójności jest wysyłanie żądań URL kodujących różne znaki po załadowaniu ścieżki bez żadnego kodowania i sprawdzenie, czy odpowiedź zakodowanej ścieżki pochodzi z odpowiedzi buforowanej.

### Segment kropkowy

Normalizacja ścieżek, w których zaangażowane są kropki, jest również bardzo interesująca dla ataków na cache. Na przykład, `/static/../home/index` lub `/aaa..\home/index`, niektóre serwery cache będą buforować te ścieżki jako klucze, podczas gdy inne mogą rozwiązać ścieżkę i użyć `/home/index` jako klucza cache.\
Podobnie jak wcześniej, wysyłanie tego rodzaju żądań i sprawdzanie, czy odpowiedź została zebrana z cache, pomaga zidentyfikować, czy odpowiedź na `/home/index` jest odpowiedzią wysłaną, gdy te ścieżki są żądane.

## Zasoby statyczne

Kilka serwerów cache zawsze buforuje odpowiedź, jeśli jest ona identyfikowana jako statyczna. Może to być spowodowane:

- **Rozszerzeniem**: Cloudflare zawsze buforuje pliki z następującymi rozszerzeniami: 7z, csv, gif, midi, png, tif, zip, avi, doc, gz, mkv, ppt, tiff, zst, avif, docx, ico, mp3, pptx, ttf, apk, dmg, iso, mp4, ps, webm, bin, ejs, jar, ogg, rar, webp, bmp, eot, jpg, otf, svg, woff, bz2, eps, jpeg, pdf, svgz, woff2, class, exe, js, pict, swf, xls, css, flac, mid, pls, tar, xlsx
- Możliwe jest wymuszenie buforowania dynamicznej odpowiedzi, używając delimitera i statycznego rozszerzenia, jak żądanie do `/home$image.png`, które buforuje `/home$image.png`, a serwer pochodzenia odpowiada `/home`
- **Znane statyczne katalogi**: Następujące katalogi zawierają pliki statyczne i dlatego ich odpowiedzi powinny być buforowane: /static, /assets, /wp-content, /media, /templates, /public, /shared
- Możliwe jest wymuszenie buforowania dynamicznej odpowiedzi, używając delimitera, statycznego katalogu i kropek, jak: `/home/..%2fstatic/something` buforuje `/static/something`, a odpowiedź będzie `/home`
- **Statyczne katalogi + kropki**: Żądanie do `/static/..%2Fhome` lub do `/static/..%5Chome` może być buforowane tak, jak jest, ale odpowiedź może być `/home`
- **Statyczne pliki:** Niektóre konkretne pliki są zawsze buforowane, takie jak `/robots.txt`, `/favicon.ico` i `/index.html`. Co można wykorzystać, jak `/home/..%2Frobots.txt`, gdzie cache może przechowywać `/robots.txt`, a serwer pochodzenia odpowiada na `/home`.

{{#include ../../banners/hacktricks-training.md}}
