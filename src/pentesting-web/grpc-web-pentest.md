# Pentesting gRPC-Web

{{#include ../banners/hacktricks-training.md}}

## Rapida panoramica del protocollo e superficie d'attacco

- Trasporto: gRPC‑Web usa una variante compatibile con i browser di gRPC su HTTP/1.1 o HTTP/2 tramite un proxy (Envoy/APISIX/grpcwebproxy/etc.). Sono supportate solo chiamate unary e server‑streaming.
- Content-Types che vedrai:
- application/grpc-web (con framing binario)
- application/grpc-web-text (framing codificato in base64 per lo streaming su HTTP/1.1)
- Framing: ogni messaggio è prefissato da un'intestazione gRPC di 5 byte (1‑byte flags + 4‑byte length). In gRPC‑Web, i trailers (grpc-status, grpc-message, …) sono inviati dentro il body come un frame speciale: primo byte con MSB settato (0x80) seguito da una lunghezza e da un blocco di header in stile HTTP/1.1.
- Header di richiesta comuni: x-grpc-web: 1, x-user-agent: grpc-web-javascript/…, grpc-timeout, grpc-encoding. Le risposte espongono grpc-status/grpc-message tramite trailers/frame nel body e spesso tramite Access-Control-Expose-Headers per i browser.
- Middleware rilevanti per la sicurezza spesso presenti:
- Envoy grpc_web filter e gRPC‑JSON transcoder (ponte HTTP<->gRPC)
- Plugin gRPC‑Web per Nginx/APISIX
- Policy CORS sul proxy

Cosa implica per gli attaccanti:
- Puoi costruire richieste a mano (binario o testo base64), oppure lasciare che gli strumenti le generino/codifichino.
- Errori CORS sul proxy possono consentire chiamate gRPC‑Web cross‑site autenticate (simili ai classici problemi CORS).
- I bridge di JSON transcoding possono esporre involontariamente metodi gRPC come endpoint HTTP non autenticati se routes/auth sono mal configurati.

## Testare gRPC‑Web dalla CLI

### Più semplice: buf curl (supporta nativamente gRPC‑Web)

- Elenca i metodi via reflection (se abilitato):
```bash
# list methods (uses reflection)
buf curl --protocol grpcweb https://host.tld --list-methods
```
- Chiama un metodo con input JSON, gestendo automaticamente il framing e gli headers di gRPC‑Web:
```bash
buf curl --protocol grpcweb \
-H 'Origin: https://example.com' \
-d '{"field":"value"}' \
https://host.tld/pkg.svc.v1.Service/Method
```
- Se reflection è disabilitata, fornisci un schema/descriptor set con --schema oppure punta a file .proto locali. Vedi buf help curl.

### Raw con curl (intestazioni manuali + corpo incorniciato)

Per la modalità binaria (application/grpc-web), invia un payload incorniciato (prefisso di 5‑byte + messaggio protobuf). Per la modalità testo, codifica in base64 il payload incorniciato.
```bash
# Build a protobuf message, then gRPC-frame it (1 flag byte + 4 length + msg)
# Example using protoscope to compose/edit the message and base64 for grpc-web-text
protoscope -s msg.txt | python3 grpc-coder.py --encode --type grpc-web-text | \
tee body.b64

curl -i https://host.tld/pkg.svc.v1.Service/Method \
-H 'Content-Type: application/grpc-web-text' \
-H 'X-Grpc-Web: 1' \
-H 'X-User-Agent: grpc-web-javascript/0.1' \
--data-binary @body.b64
```
Suggerimento: Forza la modalità base64/text con application/grpc-web-text quando gli intermediari HTTP/1.1 interrompono lo streaming binario.

### Verificare il comportamento CORS (preflight + response)

- Preflight:
```bash
curl -i -X OPTIONS https://host.tld/pkg.svc.v1.Service/Method \
-H 'Origin: https://evil.tld' \
-H 'Access-Control-Request-Method: POST' \
-H 'Access-Control-Request-Headers: content-type,x-grpc-web,x-user-agent,grpc-timeout'
```
- Una configurazione vulnerabile spesso riflette un Origin arbitrario e invia Access-Control-Allow-Credentials: true, permettendo chiamate cross‑site autenticate. Controlla anche che Access-Control-Expose-Headers includa grpc-status, grpc-message (molti deployment espongono questi per le librerie client).

Per tecniche generiche per abusare di CORS, consulta [CORS - Misconfigurations & Bypass](cors-bypass.md).

## Manipolare i payload di gRPC‑Web

gRPC‑Web usa Content-Type: application/grpc-web-text come stream di frame gRPC avvolto in base64 per la compatibilità col browser. Puoi decodificare/modificare/ricodificare i frame per manomettere campi, invertire flag o iniettare payload.

Usa lo strumento [gprc-coder](https://github.com/nxenon/grpc-pentest-suite) (e la sua estensione per Burp) per velocizzare i round‑trip.

### Manuale con gGRPC Coder Tool

1. Decodifica il payload:
```bash
echo "AAAAABYSC0FtaW4gTmFzaXJpGDY6BVhlbm9u" | python3 grpc-coder.py --decode --type grpc-web-text | protoscope > out.txt
```
2. Modifica il contenuto del payload decodificato
```
nano out.txt
2: {"Amin Nasiri Xenon GRPC"}
3: 54
7: {"<script>alert(origin)</script>"}
```
3. Codifica il nuovo payload
```bash
protoscope -s out.txt | python3 grpc-coder.py --encode --type grpc-web-text
```
4. Usa l'output in Burp interceptor:
```
AAAAADoSFkFtaW4gTmFzaXJpIFhlbm9uIEdSUEMYNjoePHNjcmlwdD5hbGVydChvcmlnaW4pPC9zY3JpcHQ+
```
### Manuale con gRPC‑Web Coder Burp Suite Extension

Puoi usare gRPC‑Web Coder Burp Suite Extension in [gRPC‑Web Pentest Suite](https://github.com/nxenon/grpc-pentest-suite) che è più semplice. Puoi leggere le istruzioni di installazione e utilizzo nel suo repo.

## Analisi dei file JavaScript gRPC‑Web

Le web app che utilizzano gRPC‑Web rilasciano almeno un bundle JS/TS generato. Effettua reverse-engineering su di essi per estrarre servizi, metodi e la struttura dei messaggi.

- Prova a usare [gRPC-Scan](https://github.com/nxenon/grpc-pentest-suite) per analizzare i bundle.
- Cerca percorsi di metodo come /<pkg>.<Service>/<Method>, numeri/tipi dei campi dei messaggi, e interceptor personalizzati che aggiungono header di autenticazione.

1. Scarica il file JavaScript gRPC‑Web
2. Scansionalo con grpc-scan.py:
```bash
python3 grpc-scan.py --file main.js
```
3. Analizza l'output e testa i nuovi endpoint e i nuovi servizi:
```
Output:
Found Endpoints:
/grpc.gateway.testing.EchoService/Echo
/grpc.gateway.testing.EchoService/EchoAbort
/grpc.gateway.testing.EchoService/NoOp
/grpc.gateway.testing.EchoService/ServerStreamingEcho
/grpc.gateway.testing.EchoService/ServerStreamingEchoAbort

Found Messages:

grpc.gateway.testing.EchoRequest:
+------------+--------------------+--------------+
| Field Name |     Field Type     | Field Number |
+============+====================+==============+
| Message    | Proto3StringField  | 1            |
+------------+--------------------+--------------+
| Name       | Proto3StringField  | 2            |
+------------+--------------------+--------------+
| Age        | Proto3IntField     | 3            |
+------------+--------------------+--------------+
| IsAdmin    | Proto3BooleanField | 4            |
+------------+--------------------+--------------+
| Weight     | Proto3FloatField   | 5            |
+------------+--------------------+--------------+
| Test       | Proto3StringField  | 6            |
+------------+--------------------+--------------+
| Test2      | Proto3StringField  | 7            |
+------------+--------------------+--------------+
| Test3      | Proto3StringField  | 16           |
+------------+--------------------+--------------+
| Test4      | Proto3StringField  | 20           |
+------------+--------------------+--------------+

grpc.gateway.testing.EchoResponse:
+--------------+--------------------+--------------+
|  Field Name  |     Field Type     | Field Number |
+==============+====================+==============+
| Message      | Proto3StringField  | 1            |
+--------------+--------------------+--------------+
| Name         | Proto3StringField  | 2            |
+--------------+--------------------+--------------+
| Age          | Proto3IntField     | 3            |
+--------------+--------------------+--------------+
| IsAdmin      | Proto3BooleanField | 4            |
+--------------+--------------------+--------------+
| Weight       | Proto3FloatField   | 5            |
+--------------+--------------------+--------------+
| Test         | Proto3StringField  | 6            |
+--------------+--------------------+--------------+
| Test2        | Proto3StringField  | 7            |
+--------------+--------------------+--------------+
| Test3        | Proto3StringField  | 16           |
+--------------+--------------------+--------------+
| Test4        | Proto3StringField  | 20           |
+--------------+--------------------+--------------+
| MessageCount | Proto3IntField     | 8            |
+--------------+--------------------+--------------+

grpc.gateway.testing.ServerStreamingEchoRequest:
+-----------------+-------------------+--------------+
|   Field Name    |    Field Type     | Field Number |
+=================+===================+==============+
| Message         | Proto3StringField | 1            |
+-----------------+-------------------+--------------+
| MessageCount    | Proto3IntField    | 2            |
+-----------------+-------------------+--------------+
| MessageInterval | Proto3IntField    | 3            |
+-----------------+-------------------+--------------+

grpc.gateway.testing.ServerStreamingEchoResponse:
+------------+-------------------+--------------+
| Field Name |    Field Type     | Field Number |
+============+===================+==============+
| Message    | Proto3StringField | 1            |
+------------+-------------------+--------------+

grpc.gateway.testing.ClientStreamingEchoRequest:
+------------+-------------------+--------------+
| Field Name |    Field Type     | Field Number |
+============+===================+==============+
| Message    | Proto3StringField | 1            |
+------------+-------------------+--------------+

grpc.gateway.testing.ClientStreamingEchoResponse:
+--------------+----------------+--------------+
|  Field Name  |   Field Type   | Field Number |
+==============+================+==============+
| MessageCount | Proto3IntField | 1            |
+--------------+----------------+--------------+
```
## Trappole del bridging e del JSON transcoding

Many deployments put an Envoy (or similar) proxy in front of the gRPC server:

- Il filtro grpc_web traduce HTTP/1.1 POSTs in HTTP/2 gRPC.
- Il gRPC‑JSON Transcoder espone i metodi gRPC come endpoint HTTP JSON quando le opzioni .proto (google.api.http) sono presenti.

Dal punto di vista del pentesting:
- Prova chiamate HTTP JSON dirette a /<pkg>.<Service>/<Method> usando application/json quando è abilitato un transcoder (i mismatch di auth/route sono comuni):
```bash
curl -i https://host.tld/pkg.svc.v1.Service/Method \
-H 'Content-Type: application/json' \
-d '{"field":"value"}'
```
- Verificare se metodi/parametri sconosciuti vengono rifiutati o inoltrati. Alcune configurazioni inoltrano percorsi non corrispondenti upstream, talvolta eludendo l'auth o la validazione delle request.
- Osservare x-envoy-original-path e gli header correlati aggiunti dai proxy. Gli upstream che si fidano di questi possono essere abusati se il proxy non li sanitizza.

## Riferimenti

- [Hacking into gRPC‑Web Article by Amin Nasiri](https://infosecwriteups.com/hacking-into-grpc-web-a54053757a45)
- [gRPC‑Web Pentest Suite](https://github.com/nxenon/grpc-pentest-suite)
- [gRPC‑Web protocol notes (PROTOCOL‑WEB.md)](https://chromium.googlesource.com/external/github.com/grpc/grpc/%2B/v1.16.1/doc/PROTOCOL-WEB.md)

{{#include ../banners/hacktricks-training.md}}
