# Unicode Injection

{{#include ../../banners/hacktricks-training.md}}

## Εισαγωγή

Ανάλογα με το πώς συμπεριφέρεται το back-end/front-end όταν **λαμβάνει περίεργους χαρακτήρες unicode**, ένας επιτιθέμενος μπορεί να είναι σε θέση να **παρακάμψει τις προστασίες και να εισάγει αυθαίρετους χαρακτήρες** που θα μπορούσαν να χρησιμοποιηθούν για **κατάχρηση ευπαθειών εισαγωγής** όπως XSS ή SQLi.

## Κανονικοποίηση Unicode

Η κανονικοποίηση Unicode συμβαίνει όταν **οι χαρακτήρες unicode κανονικοποιούνται σε χαρακτήρες ascii**.

Ένα κοινό σενάριο αυτού του τύπου ευπάθειας συμβαίνει όταν το σύστημα **τροποποιεί** με κάποιο τρόπο την **είσοδο** του χρήστη **μετά την επαλήθευσή της**. Για παράδειγμα, σε ορισμένες γλώσσες μια απλή κλήση για να γίνει η **είσοδος κεφαλαία ή πεζά** θα μπορούσε να κανονικοποιήσει την δεδομένη είσοδο και το **unicode θα μετατραπεί σε ASCII** δημιουργώντας νέους χαρακτήρες.\
Για περισσότερες πληροφορίες δείτε:

{{#ref}}
unicode-normalization.md
{{#endref}}

## `\u` σε `%`

Οι χαρακτήρες Unicode συνήθως αναπαρίστανται με το **πρόθεμα `\u`**. Για παράδειγμα, ο χαρακτήρας `㱋` είναι `\u3c4b`([ελέγξτε το εδώ](https://unicode-explorer.com/c/3c4B)). Εάν ένα backend **μετασχηματίσει** το πρόθεμα **`\u` σε `%`**, η προκύπτουσα συμβολοσειρά θα είναι `%3c4b`, η οποία αποκωδικοποιημένη URL είναι: **`<4b`**. Και, όπως μπορείτε να δείτε, ένας **χαρακτήρας `<` έχει εισαχθεί**.\
Μπορείτε να χρησιμοποιήσετε αυτή την τεχνική για να **εισάγετε οποιονδήποτε τύπο χαρακτήρα** εάν το backend είναι ευάλωτο.\
Δείτε [https://unicode-explorer.com/](https://unicode-explorer.com/) για να βρείτε τους χαρακτήρες που χρειάζεστε.

Αυτή η ευπάθεια προέρχεται από μια ευπάθεια που βρήκε ένας ερευνητής, για μια πιο λεπτομερή εξήγηση δείτε [https://www.youtube.com/watch?v=aUsAHb0E7Cg](https://www.youtube.com/watch?v=aUsAHb0E7Cg)

## Εισαγωγή Emoji

Τα back-ends συμπεριφέρονται περίεργα όταν **λαμβάνουν emojis**. Αυτό συνέβη σε [**αυτή την αναφορά**](https://medium.com/@fpatrik/how-i-found-an-xss-vulnerability-via-using-emojis-7ad72de49209) όπου ο ερευνητής κατάφερε να επιτύχει ένα XSS με ένα payload όπως: `💋img src=x onerror=alert(document.domain)//💛`

Σε αυτή την περίπτωση, το σφάλμα ήταν ότι ο διακομιστής μετά την αφαίρεση των κακόβουλων χαρακτήρων **μετέτρεψε τη συμβολοσειρά UTF-8 από Windows-1252 σε UTF-8** (βασικά η κωδικοποίηση εισόδου και η μετατροπή από κωδικοποίηση δεν ταίριαζαν). Έτσι, αυτό δεν δίνει ένα σωστό < αλλά έναν περίεργο unicode: `‹`\
``Έτσι, πήραν αυτή την έξοδο και **μετέτρεψαν ξανά τώρα από UTF-8 σε ASCII**. Αυτό **κανονικοποίησε** το `‹` σε `<` έτσι ώστε η εκμετάλλευση να μπορούσε να λειτουργήσει σε αυτό το σύστημα.\
Αυτό είναι που συνέβη:
```php
<?php

$str = isset($_GET["str"]) ? htmlspecialchars($_GET["str"]) : "";

$str = iconv("Windows-1252", "UTF-8", $str);
$str = iconv("UTF-8", "ASCII//TRANSLIT", $str);

echo "String: " . $str;
```
Emoji λίστες:

- [https://github.com/iorch/jakaton_feminicidios/blob/master/data/emojis.csv](https://github.com/iorch/jakaton_feminicidios/blob/master/data/emojis.csv)
- [https://unicode.org/emoji/charts-14.0/full-emoji-list.html](https://unicode.org/emoji/charts-14.0/full-emoji-list.html)

## Windows Best-Fit/Worst-fit

Όπως εξηγείται σε **[αυτή τη σπουδαία ανάρτηση](https://blog.orange.tw/posts/2025-01-worstfit-unveiling-hidden-transformers-in-windows-ansi/)**, τα Windows έχουν μια δυνατότητα που ονομάζεται **Best-Fit** η οποία θα **αντικαταστήσει χαρακτήρες unicode** που δεν μπορούν να εμφανιστούν σε ASCII mode με έναν παρόμοιο. Αυτό μπορεί να οδηγήσει σε **αναπάντεχη συμπεριφορά** όταν το backend **αναμένει έναν συγκεκριμένο χαρακτήρα** αλλά λαμβάνει έναν διαφορετικό.

Είναι δυνατόν να βρείτε χαρακτήρες best-fit σε **[https://worst.fit/mapping/](https://worst.fit/mapping/)**.

Καθώς τα Windows συνήθως θα μετατρέπουν τις συμβολοσειρές unicode σε συμβολοσειρές ascii ως ένα από τα τελευταία μέρη της εκτέλεσης (συνήθως πηγαίνοντας από μια API με κατάληξη "W" σε μια API με κατάληξη "A" όπως `GetEnvironmentVariableA` και `GetEnvironmentVariableW`), αυτό θα επέτρεπε στους επιτιθέμενους να παρακάμψουν τις προστασίες στέλνοντας χαρακτήρες unicode που θα μετατραπούν τελευταίοι σε χαρακτήρες ASCII που θα εκτελούν αναπάντεχες ενέργειες.

Στην ανάρτηση του blog προτείνονται μέθοδοι για να παρακαμφθούν οι ευπάθειες που διορθώθηκαν χρησιμοποιώντας μια **μαύρη λίστα χαρακτήρων**, εκμεταλλευόμενοι **path traversals** χρησιμοποιώντας [χαρακτήρες που αντιστοιχούν σε “/“ (0x2F)](https://worst.fit/mapping/#to%3A0x2f) και [χαρακτήρες που αντιστοιχούν σε “\“ (0x5C)](https://worst.fit/mapping/#to%3A0x5c) ή ακόμα και παρακάμπτοντας τις προστασίες escape shell όπως το `escapeshellarg` της PHP ή το `subprocess.run` της Python χρησιμοποιώντας μια λίστα, αυτό έγινε για παράδειγμα χρησιμοποιώντας **fullwidth double quotes (U+FF02)** αντί για διπλά εισαγωγικά, έτσι στο τέλος αυτό που φαινόταν σαν 1 επιχείρημα μετατράπηκε σε 2 επιχειρήματα.

**Σημειώστε ότι για μια εφαρμογή να είναι ευάλωτη πρέπει να χρησιμοποιεί "W" Windows APIs αλλά να καλεί τελικά μια "A" Windows api ώστε να δημιουργηθεί το "Best-fit" της συμβολοσειράς unicode.**

**Πολλές ανακαλυφθείσες ευπάθειες δεν θα διορθωθούν καθώς οι άνθρωποι δεν συμφωνούν ποιος θα πρέπει να διορθώσει αυτό το ζήτημα.**

{{#include ../../banners/hacktricks-training.md}}
