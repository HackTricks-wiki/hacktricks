# Unicode Injection

{{#include ../../banners/hacktricks-training.md}}

## Introdu√ß√£o

Dependendo de como o back-end/front-end se comporta quando **recebe caracteres unicode estranhos**, um atacante pode ser capaz de **contornar prote√ß√µes e injetar caracteres arbitr√°rios** que podem ser usados para **explorar vulnerabilidades de inje√ß√£o** como XSS ou SQLi.

## Normaliza√ß√£o de Unicode

A normaliza√ß√£o de Unicode ocorre quando **caracteres unicode s√£o normalizados para caracteres ascii**.

Um cen√°rio comum desse tipo de vulnerabilidade ocorre quando o sistema est√° **modificando** de alguma forma a **entrada** do usu√°rio **ap√≥s t√™-la verificado**. Por exemplo, em algumas linguagens, uma simples chamada para tornar a **entrada em mai√∫sculas ou min√∫sculas** pode normalizar a entrada dada e o **unicode ser√° transformado em ASCII**, gerando novos caracteres.\
Para mais informa√ß√µes, consulte:

{{#ref}}
unicode-normalization.md
{{#endref}}

## `\u` para `%`

Os caracteres unicode s√£o geralmente representados com o **prefixo `\u`**. Por exemplo, o caractere `„±ã` √© `\u3c4b`([ver aqui](https://unicode-explorer.com/c/3c4B)). Se um backend **transforma** o prefixo **`\u` em `%`**, a string resultante ser√° `%3c4b`, que decodificada em URL √©: **`<4b`**. E, como voc√™ pode ver, um **caractere `<` √© injetado**.\
Voc√™ poderia usar essa t√©cnica para **injetar qualquer tipo de caractere** se o backend for vulner√°vel.\
Consulte [https://unicode-explorer.com/](https://unicode-explorer.com/) para encontrar os caracteres que voc√™ precisa.

Essa vulnerabilidade na verdade vem de uma vulnerabilidade que um pesquisador encontrou, para uma explica√ß√£o mais detalhada, consulte [https://www.youtube.com/watch?v=aUsAHb0E7Cg](https://www.youtube.com/watch?v=aUsAHb0E7Cg)

## Inje√ß√£o de Emoji

Back-ends se comportam de forma estranha quando **recebem emojis**. Isso aconteceu em [**este relato**](https://medium.com/@fpatrik/how-i-found-an-xss-vulnerability-via-using-emojis-7ad72de49209) onde o pesquisador conseguiu alcan√ßar um XSS com um payload como: `üíãimg src=x onerror=alert(document.domain)//üíõ`

Neste caso, o erro foi que o servidor, ap√≥s remover os caracteres maliciosos, **converteu a string UTF-8 de Windows-1252 para UTF-8** (basicamente, a codifica√ß√£o de entrada e a convers√£o de codifica√ß√£o n√£o coincidiram). Ent√£o, isso n√£o d√° um < adequado, apenas um unicode estranho: `‚Äπ`\
``Ent√£o, eles pegaram essa sa√≠da e **converteram novamente agora de UTF-8 para ASCII**. Isso **normalizou** o `‚Äπ` para `<`, assim √© como a explora√ß√£o poderia funcionar nesse sistema.\
Isso √© o que aconteceu:
```php
<?php

$str = isset($_GET["str"]) ? htmlspecialchars($_GET["str"]) : "";

$str = iconv("Windows-1252", "UTF-8", $str);
$str = iconv("UTF-8", "ASCII//TRANSLIT", $str);

echo "String: " . $str;
```
Emoji lists:

- [https://github.com/iorch/jakaton_feminicidios/blob/master/data/emojis.csv](https://github.com/iorch/jakaton_feminicidios/blob/master/data/emojis.csv)
- [https://unicode.org/emoji/charts-14.0/full-emoji-list.html](https://unicode.org/emoji/charts-14.0/full-emoji-list.html)

## Windows Melhor Ajuste/Pior Ajuste

Como explicado em **[este √≥timo post](https://blog.orange.tw/posts/2025-01-worstfit-unveiling-hidden-transformers-in-windows-ansi/)**, o Windows possui um recurso chamado **Melhor Ajuste** que ir√° **substituir caracteres unicode** que n√£o podem ser exibidos em modo ASCII por um semelhante. Isso pode levar a **comportamentos inesperados** quando o backend est√° **esperando um caractere espec√≠fico** mas recebe um diferente.

√â poss√≠vel encontrar caracteres de melhor ajuste em **[https://worst.fit/mapping/](https://worst.fit/mapping/)**.

Como o Windows geralmente converte strings unicode em strings ascii como uma das √∫ltimas partes da execu√ß√£o (geralmente indo de uma API com sufixo "W" para uma API com sufixo "A" como `GetEnvironmentVariableA` e `GetEnvironmentVariableW`), isso permitiria que atacantes contornassem prote√ß√µes enviando caracteres unicode que seriam convertidos por √∫ltimo em caracteres ASCII que realizariam a√ß√µes inesperadas.

No post do blog, s√£o propostos m√©todos para contornar vulnerabilidades corrigidas usando uma **lista negra de caracteres**, explorar **traversais de caminho** usando [caracteres mapeados para ‚Äú/‚Äú (0x2F)](https://worst.fit/mapping/#to%3A0x2f) e [caracteres mapeados para ‚Äú\‚Äú (0x5C)](https://worst.fit/mapping/#to%3A0x5c) ou at√© mesmo contornar prote√ß√µes de escape de shell como `escapeshellarg` do PHP ou `subprocess.run` do Python usando uma lista, isso foi feito, por exemplo, usando **aspas duplas em largura total (U+FF02)** em vez de aspas duplas, de modo que no final o que parecia ser 1 argumento foi transformado em 2 argumentos.

**Note que para um aplicativo ser vulner√°vel, ele precisa usar APIs do Windows "W" mas acabar chamando uma API do Windows "A", ent√£o o "Melhor ajuste" da string unicode √© criado.**

**V√°rias vulnerabilidades descobertas n√£o ser√£o corrigidas, pois as pessoas n√£o concordam sobre quem deve corrigir esse problema.**

{{#include ../../banners/hacktricks-training.md}}
