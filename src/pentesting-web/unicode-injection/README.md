# Unicode Injection

{{#include ../../banners/hacktricks-training.md}}

## Introduzione

A seconda di come si comporta il back-end/front-end quando **riceve caratteri unicode strani**, un attaccante potrebbe essere in grado di **bypassare le protezioni e iniettare caratteri arbitrari** che potrebbero essere utilizzati per **sfruttare vulnerabilit√† di iniezione** come XSS o SQLi.

## Normalizzazione Unicode

La normalizzazione Unicode si verifica quando **i caratteri unicode vengono normalizzati in caratteri ascii**.

Uno scenario comune di questo tipo di vulnerabilit√† si verifica quando il sistema sta **modificando** in qualche modo l'**input** dell'utente **dopo averlo controllato**. Ad esempio, in alcune lingue una semplice chiamata per rendere l'**input maiuscolo o minuscolo** potrebbe normalizzare l'input fornito e il **unicode verr√† trasformato in ASCII** generando nuovi caratteri.\
Per ulteriori informazioni controlla:

{{#ref}}
unicode-normalization.md
{{#endref}}

## `\u` a `%`

I caratteri Unicode sono solitamente rappresentati con il **prefisso `\u`**. Ad esempio, il carattere `„±ã` √® `\u3c4b`([controllalo qui](https://unicode-explorer.com/c/3c4B)). Se un backend **trasforma** il prefisso **`\u` in `%`**, la stringa risultante sar√† `%3c4b`, che decodificata in URL √®: **`<4b`**. E, come puoi vedere, un **carattere `<` √® iniettato**.\
Potresti usare questa tecnica per **iniettare qualsiasi tipo di carattere** se il backend √® vulnerabile.\
Controlla [https://unicode-explorer.com/](https://unicode-explorer.com/) per trovare i caratteri di cui hai bisogno.

Questa vulnerabilit√† proviene effettivamente da una vulnerabilit√† trovata da un ricercatore, per una spiegazione pi√π approfondita controlla [https://www.youtube.com/watch?v=aUsAHb0E7Cg](https://www.youtube.com/watch?v=aUsAHb0E7Cg)

## Iniezione di Emoji

I back-end si comportano in modo strano quando **ricevono emoji**. Questo √® ci√≤ che √® successo in [**questo writeup**](https://medium.com/@fpatrik/how-i-found-an-xss-vulnerability-via-using-emojis-7ad72de49209) dove il ricercatore √® riuscito a ottenere un XSS con un payload come: `üíãimg src=x onerror=alert(document.domain)//üíõ`

In questo caso, l'errore √® stato che il server, dopo aver rimosso i caratteri dannosi, **ha convertito la stringa UTF-8 da Windows-1252 a UTF-8** (fondamentalmente l'encoding dell'input e la conversione dall'encoding non corrispondevano). Quindi questo non d√† un corretto < ma solo uno strano unicode: `‚Äπ`\
``Quindi hanno preso questo output e **convertito di nuovo ora da UTF-8 a ASCII**. Questo **ha normalizzato** il `‚Äπ` in `<`, ecco come l'exploit potrebbe funzionare su quel sistema.\
Questo √® ci√≤ che √® successo:
```php
<?php

$str = isset($_GET["str"]) ? htmlspecialchars($_GET["str"]) : "";

$str = iconv("Windows-1252", "UTF-8", $str);
$str = iconv("UTF-8", "ASCII//TRANSLIT", $str);

echo "String: " . $str;
```
Emoji lists:

- [https://github.com/iorch/jakaton_feminicidios/blob/master/data/emojis.csv](https://github.com/iorch/jakaton_feminicidios/blob/master/data/emojis.csv)
- [https://unicode.org/emoji/charts-14.0/full-emoji-list.html](https://unicode.org/emoji/charts-14.0/full-emoji-list.html)

## Windows Best-Fit/Worst-fit

Come spiegato in **[questo ottimo post](https://blog.orange.tw/posts/2025-01-worstfit-unveiling-hidden-transformers-in-windows-ansi/)**, Windows ha una funzione chiamata **Best-Fit** che **sostituisce i caratteri unicode** che non possono essere visualizzati in modalit√† ASCII con uno simile. Questo pu√≤ portare a **comportamenti imprevisti** quando il backend **si aspetta un carattere specifico** ma riceve un carattere diverso.

√à possibile trovare caratteri best-fit in **[https://worst.fit/mapping/](https://worst.fit/mapping/)**.

Poich√© Windows di solito converte le stringhe unicode in stringhe ascii come una delle ultime parti dell'esecuzione (di solito passando da un'API con suffisso "W" a un'API con suffisso "A" come `GetEnvironmentVariableA` e `GetEnvironmentVariableW`), questo permetterebbe agli attaccanti di eludere le protezioni inviando caratteri unicode che verranno convertiti infine in caratteri ASCII che eseguirebbero azioni inaspettate.

Nel post del blog vengono proposti metodi per eludere vulnerabilit√† risolte utilizzando una **blacklist di caratteri**, sfruttare **path traversals** usando [caratteri mappati a ‚Äú/‚Äú (0x2F)](https://worst.fit/mapping/#to%3A0x2f) e [caratteri mappati a ‚Äú\‚Äú (0x5C)](https://worst.fit/mapping/#to%3A0x5c) o persino eludere le protezioni di escape della shell come `escapeshellarg` di PHP o `subprocess.run` di Python utilizzando un elenco; questo √® stato fatto, ad esempio, utilizzando **virgolette doppie a larghezza piena (U+FF02)** invece di virgolette doppie, quindi alla fine ci√≤ che sembrava un argomento √® stato trasformato in 2 argomenti.

**Nota che affinch√© un'app sia vulnerabile, deve utilizzare le API Windows "W" ma finire per chiamare un'API Windows "A" in modo che venga creato il "Best-fit" della stringa unicode.**

**Diverse vulnerabilit√† scoperte non verranno risolte poich√© le persone non sono d'accordo su chi dovrebbe risolvere questo problema.**

{{#include ../../banners/hacktricks-training.md}}
