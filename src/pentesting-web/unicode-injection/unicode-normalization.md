# Unicode Normalization

{{#include ../../banners/hacktricks-training.md}}

**यह एक सारांश है:** [**https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/**](https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/). आगे की जानकारी के लिए देखें (छवियाँ वहाँ से ली गई हैं)।

## Understanding Unicode and Normalization

Unicode normalization एक प्रक्रिया है जो सुनिश्चित करती है कि वर्णों के विभिन्न बाइनरी प्रतिनिधित्व को एक ही बाइनरी मान में मानकीकृत किया जाए। यह प्रक्रिया प्रोग्रामिंग और डेटा प्रोसेसिंग में स्ट्रिंग्स के साथ काम करते समय महत्वपूर्ण है। Unicode मानक वर्ण समकक्षता के दो प्रकारों को परिभाषित करता है:

1. **Canonical Equivalence**: वर्णों को कैनोनिकल रूप से समकक्ष माना जाता है यदि उनका प्रिंट या डिस्प्ले पर एक समान रूप और अर्थ होता है।
2. **Compatibility Equivalence**: समकक्षता का एक कमजोर रूप जहाँ वर्ण एक ही अमूर्त वर्ण का प्रतिनिधित्व कर सकते हैं लेकिन अलग-अलग तरीके से प्रदर्शित हो सकते हैं।

चार **Unicode normalization algorithms** हैं: NFC, NFD, NFKC, और NFKD। प्रत्येक एल्गोरिदम कैनोनिकल और संगतता मानकीकरण तकनीकों का उपयोग अलग-अलग तरीके से करता है। अधिक गहन समझ के लिए, आप इन तकनीकों का अन्वेषण कर सकते हैं [Unicode.org](https://unicode.org/) पर।

### Key Points on Unicode Encoding

Unicode एन्कोडिंग को समझना महत्वपूर्ण है, विशेष रूप से विभिन्न सिस्टमों या भाषाओं के बीच इंटरऑपरेबिलिटी मुद्दों से निपटने के समय। यहाँ मुख्य बिंदु हैं:

- **Code Points and Characters**: Unicode में, प्रत्येक वर्ण या प्रतीक को एक संख्यात्मक मान सौंपा जाता है जिसे "कोड प्वाइंट" कहा जाता है।
- **Bytes Representation**: कोड प्वाइंट (या वर्ण) को मेमोरी में एक या अधिक बाइट्स द्वारा दर्शाया जाता है। उदाहरण के लिए, LATIN-1 वर्ण (अंग्रेजी बोलने वाले देशों में सामान्य) को एक बाइट का उपयोग करके दर्शाया जाता है। हालाँकि, जिन भाषाओं में अधिक वर्ण होते हैं, उन्हें प्रतिनिधित्व के लिए अधिक बाइट्स की आवश्यकता होती है।
- **Encoding**: यह शब्द वर्णों को बाइट्स की एक श्रृंखला में परिवर्तित करने के तरीके को संदर्भित करता है। UTF-8 एक प्रचलित एन्कोडिंग मानक है जहाँ ASCII वर्णों को एक बाइट का उपयोग करके दर्शाया जाता है, और अन्य वर्णों के लिए चार बाइट्स तक।
- **Processing Data**: डेटा प्रोसेसिंग करने वाले सिस्टम को एन्कोडिंग के बारे में जागरूक होना चाहिए ताकि बाइट स्ट्रीम को सही तरीके से वर्णों में परिवर्तित किया जा सके।
- **Variants of UTF**: UTF-8 के अलावा, अन्य एन्कोडिंग मानक हैं जैसे UTF-16 (कम से कम 2 बाइट्स का उपयोग करते हुए, अधिकतम 4) और UTF-32 (सभी वर्णों के लिए 4 बाइट्स का उपयोग करते हुए)।

इन अवधारणाओं को समझना महत्वपूर्ण है ताकि Unicode की जटिलता और इसके विभिन्न एन्कोडिंग तरीकों से उत्पन्न संभावित मुद्दों को प्रभावी ढंग से संभाला और कम किया जा सके।

Unicode के दो अलग-अलग बाइट्स को एक ही वर्ण का प्रतिनिधित्व करने के तरीके का एक उदाहरण:
```python
unicodedata.normalize("NFKD","chloe\u0301") == unicodedata.normalize("NFKD", "chlo\u00e9")
```
**Unicode समकक्ष वर्णों की एक सूची यहाँ पाई जा सकती है:** [https://appcheck-ng.com/wp-content/uploads/unicode_normalization.html](https://appcheck-ng.com/wp-content/uploads/unicode_normalization.html) और [https://0xacb.com/normalization_table](https://0xacb.com/normalization_table)

### खोज

यदि आप एक वेब ऐप के अंदर एक ऐसा मान ढूंढ सकते हैं जो वापस इको किया जा रहा है, तो आप **‘KELVIN SIGN’ (U+0212A)** भेजने की कोशिश कर सकते हैं जो **"K"** में **सामान्यीकृत** होता है (आप इसे `%e2%84%aa` के रूप में भेज सकते हैं)। **यदि "K" वापस इको किया जाता है**, तो कुछ प्रकार की **Unicode सामान्यीकरण** की प्रक्रिया की जा रही है।

अन्य **उदाहरण**: `%F0%9D%95%83%E2%85%87%F0%9D%99%A4%F0%9D%93%83%E2%85%88%F0%9D%94%B0%F0%9D%94%A5%F0%9D%99%96%F0%9D%93%83` के बाद **unicode** `Leonishan` है।

## **कमजोर उदाहरण**

### **SQL Injection फ़िल्टर बायपास**

कल्पना कीजिए एक वेब पृष्ठ जो उपयोगकर्ता इनपुट के साथ SQL क्वेरी बनाने के लिए वर्ण `'` का उपयोग कर रहा है। यह वेब, एक सुरक्षा उपाय के रूप में, उपयोगकर्ता इनपुट से वर्ण **`'`** के सभी उदाहरणों को **हटाता** है, लेकिन **उस हटाने के बाद** और **क्वेरी बनाने से पहले**, यह उपयोगकर्ता के इनपुट को **Unicode** का उपयोग करके **सामान्यीकृत** करता है।

फिर, एक दुर्भावनापूर्ण उपयोगकर्ता एक अलग Unicode वर्ण डाल सकता है जो `' (0x27)` के समकक्ष है जैसे `%ef%bc%87`, जब इनपुट सामान्यीकृत होता है, तो एक सिंगल कोट बनाया जाता है और एक **SQLInjection भेद्यता** प्रकट होती है:

![https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/](<../../images/image (702).png>)

**कुछ दिलचस्प Unicode वर्ण**

- `o` -- %e1%b4%bc
- `r` -- %e1%b4%bf
- `1` -- %c2%b9
- `=` -- %e2%81%bc
- `/` -- %ef%bc%8f
- `-`-- %ef%b9%a3
- `#`-- %ef%b9%9f
- `*`-- %ef%b9%a1
- `'` -- %ef%bc%87
- `"` -- %ef%bc%82
- `|` -- %ef%bd%9c
```
' or 1=1-- -
%ef%bc%87+%e1%b4%bc%e1%b4%bf+%c2%b9%e2%81%bc%c2%b9%ef%b9%a3%ef%b9%a3+%ef%b9%a3

" or 1=1-- -
%ef%bc%82+%e1%b4%bc%e1%b4%bf+%c2%b9%e2%81%bc%c2%b9%ef%b9%a3%ef%b9%a3+%ef%b9%a3

' || 1==1//
%ef%bc%87+%ef%bd%9c%ef%bd%9c+%c2%b9%e2%81%bc%e2%81%bc%c2%b9%ef%bc%8f%ef%bc%8f

" || 1==1//
%ef%bc%82+%ef%bd%9c%ef%bd%9c+%c2%b9%e2%81%bc%e2%81%bc%c2%b9%ef%bc%8f%ef%bc%8f
```
#### sqlmap टेम्पलेट

{% embed url="https://github.com/carlospolop/sqlmap_to_unicode_template" %}

### XSS (क्रॉस साइट स्क्रिप्टिंग)

आप निम्नलिखित में से किसी एक चरित्र का उपयोग करके वेब ऐप को धोखा दे सकते हैं और XSS का शोषण कर सकते हैं:

![https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/](<../../images/image (312) (2).png>)

ध्यान दें कि उदाहरण के लिए, पहले Unicode चरित्र को इस प्रकार भेजा जा सकता है: `%e2%89%ae` या `%u226e`

![https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/](<../../images/image (215) (1) (1).png>)

### फज़िंग Regexes

जब बैकएंड **उपयोगकर्ता इनपुट को regex के साथ जांच रहा है**, तो यह संभव है कि **इनपुट** को **regex** के लिए **सामान्यीकृत** किया जा रहा हो लेकिन **जहां इसका उपयोग किया जा रहा है** वहां **नहीं**। उदाहरण के लिए, एक ओपन रीडायरेक्ट या SSRF में regex **भेजे गए URL** को **सामान्यीकृत** कर सकता है लेकिन फिर **इसे जैसा है वैसा ही एक्सेस कर सकता है**।

उपकरण [**recollapse**](https://github.com/0xacb/recollapse) \*\*\*\* बैकएंड को फज़ करने के लिए **इनपुट के विभिन्न रूपों को उत्पन्न करने** की अनुमति देता है। अधिक जानकारी के लिए **github** और इस [**पोस्ट**](https://0xacb.com/2022/11/21/recollapse/) की जांच करें।

## संदर्भ

- [**https://labs.spotify.com/2013/06/18/creative-usernames/**](https://labs.spotify.com/2013/06/18/creative-usernames/)
- [**https://security.stackexchange.com/questions/48879/why-does-directory-traversal-attack-c0af-work**](https://security.stackexchange.com/questions/48879/why-does-directory-traversal-attack-c0af-work)
- [**https://jlajara.gitlab.io/posts/2020/02/19/Bypass_WAF_Unicode.html**](https://jlajara.gitlab.io/posts/2020/02/19/Bypass_WAF_Unicode.html)

{{#include ../../banners/hacktricks-training.md}}
