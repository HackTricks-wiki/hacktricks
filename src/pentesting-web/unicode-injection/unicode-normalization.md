# Unicode Normalization

{{#include ../../banners/hacktricks-training.md}}

**Questo è un riepilogo di:** [**https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/**](https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/). Dai un'occhiata per ulteriori dettagli (immagini prese da lì).

## Comprendere Unicode e Normalizzazione

La normalizzazione Unicode è un processo che garantisce che diverse rappresentazioni binarie dei caratteri siano standardizzate allo stesso valore binario. Questo processo è cruciale nella gestione delle stringhe nella programmazione e nell'elaborazione dei dati. Lo standard Unicode definisce due tipi di equivalenza dei caratteri:

1. **Equivalenza Canonica**: I caratteri sono considerati canonici equivalenti se hanno lo stesso aspetto e significato quando stampati o visualizzati.
2. **Equivalenza di Compatibilità**: Una forma più debole di equivalenza in cui i caratteri possono rappresentare lo stesso carattere astratto ma possono essere visualizzati in modo diverso.

Ci sono **quattro algoritmi di normalizzazione Unicode**: NFC, NFD, NFKC e NFKD. Ogni algoritmo impiega tecniche di normalizzazione canonica e di compatibilità in modo diverso. Per una comprensione più approfondita, puoi esplorare queste tecniche su [Unicode.org](https://unicode.org/).

### Punti Chiave sulla Codifica Unicode

Comprendere la codifica Unicode è fondamentale, specialmente quando si affrontano problemi di interoperabilità tra diversi sistemi o lingue. Ecco i punti principali:

- **Punti di Codice e Caratteri**: In Unicode, a ciascun carattere o simbolo viene assegnato un valore numerico noto come "punto di codice".
- **Rappresentazione in Byte**: Il punto di codice (o carattere) è rappresentato da uno o più byte in memoria. Ad esempio, i caratteri LATIN-1 (comuni nei paesi di lingua inglese) sono rappresentati utilizzando un byte. Tuttavia, le lingue con un set di caratteri più ampio necessitano di più byte per la rappresentazione.
- **Codifica**: Questo termine si riferisce a come i caratteri vengono trasformati in una serie di byte. UTF-8 è uno standard di codifica prevalente in cui i caratteri ASCII sono rappresentati utilizzando un byte e fino a quattro byte per altri caratteri.
- **Elaborazione dei Dati**: I sistemi che elaborano dati devono essere a conoscenza della codifica utilizzata per convertire correttamente il flusso di byte in caratteri.
- **Varianti di UTF**: Oltre a UTF-8, ci sono altri standard di codifica come UTF-16 (che utilizza un minimo di 2 byte, fino a 4) e UTF-32 (che utilizza 4 byte per tutti i caratteri).

È cruciale comprendere questi concetti per gestire e mitigare efficacemente i potenziali problemi derivanti dalla complessità di Unicode e dai suoi vari metodi di codifica.

Un esempio di come Unicode normalizza due byte diversi che rappresentano lo stesso carattere:
```python
unicodedata.normalize("NFKD","chloe\u0301") == unicodedata.normalize("NFKD", "chlo\u00e9")
```
**Un elenco di caratteri equivalenti Unicode può essere trovato qui:** [https://appcheck-ng.com/wp-content/uploads/unicode_normalization.html](https://appcheck-ng.com/wp-content/uploads/unicode_normalization.html) e [https://0xacb.com/normalization_table](https://0xacb.com/normalization_table)

### Scoprire

Se riesci a trovare all'interno di un'app web un valore che viene restituito, potresti provare a inviare **‘KELVIN SIGN’ (U+0212A)** che **si normalizza in "K"** (puoi inviarlo come `%e2%84%aa`). **Se un "K" viene restituito**, allora viene eseguita qualche forma di **normalizzazione Unicode**.

Altro **esempio**: `%F0%9D%95%83%E2%85%87%F0%9D%99%A4%F0%9D%93%83%E2%85%88%F0%9D%94%B0%F0%9D%94%A5%F0%9D%99%96%F0%9D%93%83` dopo **unicode** è `Leonishan`.

## **Esempi Vulnerabili**

### **Bypass del filtro SQL Injection**

Immagina una pagina web che utilizza il carattere `'` per creare query SQL con l'input dell'utente. Questa web, come misura di sicurezza, **elimina** tutte le occorrenze del carattere **`'`** dall'input dell'utente, ma **dopo quella cancellazione** e **prima della creazione** della query, **normalizza** utilizzando **Unicode** l'input dell'utente.

Quindi, un utente malintenzionato potrebbe inserire un carattere Unicode diverso equivalente a `' (0x27)` come `%ef%bc%87`, quando l'input viene normalizzato, viene creato un apostrofo e appare una **vulnerabilità SQLInjection**:

![https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/](<../../images/image (702).png>)

**Alcuni caratteri Unicode interessanti**

- `o` -- %e1%b4%bc
- `r` -- %e1%b4%bf
- `1` -- %c2%b9
- `=` -- %e2%81%bc
- `/` -- %ef%bc%8f
- `-`-- %ef%b9%a3
- `#`-- %ef%b9%9f
- `*`-- %ef%b9%a1
- `'` -- %ef%bc%87
- `"` -- %ef%bc%82
- `|` -- %ef%bd%9c
```
' or 1=1-- -
%ef%bc%87+%e1%b4%bc%e1%b4%bf+%c2%b9%e2%81%bc%c2%b9%ef%b9%a3%ef%b9%a3+%ef%b9%a3

" or 1=1-- -
%ef%bc%82+%e1%b4%bc%e1%b4%bf+%c2%b9%e2%81%bc%c2%b9%ef%b9%a3%ef%b9%a3+%ef%b9%a3

' || 1==1//
%ef%bc%87+%ef%bd%9c%ef%bd%9c+%c2%b9%e2%81%bc%e2%81%bc%c2%b9%ef%bc%8f%ef%bc%8f

" || 1==1//
%ef%bc%82+%ef%bd%9c%ef%bd%9c+%c2%b9%e2%81%bc%e2%81%bc%c2%b9%ef%bc%8f%ef%bc%8f
```
#### sqlmap template

{% embed url="https://github.com/carlospolop/sqlmap_to_unicode_template" %}

### XSS (Cross Site Scripting)

Puoi usare uno dei seguenti caratteri per ingannare l'app web e sfruttare un XSS:

![https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/](<../../images/image (312) (2).png>)

Nota che, ad esempio, il primo carattere Unicode proposto può essere inviato come: `%e2%89%ae` o come `%u226e`

![https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/](<../../images/image (215) (1) (1).png>)

### Fuzzing Regexes

Quando il backend sta **controllando l'input dell'utente con una regex**, potrebbe essere possibile che l'**input** venga **normalizzato** per la **regex** ma **non** per dove viene **utilizzato**. Ad esempio, in un Open Redirect o SSRF, la regex potrebbe **normalizzare l'URL inviato** ma poi **accedervi così com'è**.

Lo strumento [**recollapse**](https://github.com/0xacb/recollapse) \*\*\*\* consente di **generare variazioni dell'input** per fuzzare il backend. Per ulteriori informazioni, controlla il **github** e questo [**post**](https://0xacb.com/2022/11/21/recollapse/).

## References

- [**https://labs.spotify.com/2013/06/18/creative-usernames/**](https://labs.spotify.com/2013/06/18/creative-usernames/)
- [**https://security.stackexchange.com/questions/48879/why-does-directory-traversal-attack-c0af-work**](https://security.stackexchange.com/questions/48879/why-does-directory-traversal-attack-c0af-work)
- [**https://jlajara.gitlab.io/posts/2020/02/19/Bypass_WAF_Unicode.html**](https://jlajara.gitlab.io/posts/2020/02/19/Bypass_WAF_Unicode.html)

{{#include ../../banners/hacktricks-training.md}}
