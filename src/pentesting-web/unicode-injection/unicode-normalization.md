# Unicode Normalization

{{#include ../../banners/hacktricks-training.md}}

**Αυτό είναι μια περίληψη του:** [**https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/**](https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/). Ρίξτε μια ματιά για περισσότερες λεπτομέρειες (εικόνες που έχουν ληφθεί από εκεί).

## Κατανόηση του Unicode και της Κανονικοποίησης

Η κανονικοποίηση Unicode είναι μια διαδικασία που διασφαλίζει ότι διαφορετικές δυαδικές αναπαραστάσεις χαρακτήρων είναι τυποποιημένες στην ίδια δυαδική τιμή. Αυτή η διαδικασία είναι κρίσιμη για την επεξεργασία συμβολοσειρών στον προγραμματισμό και την επεξεργασία δεδομένων. Το πρότυπο Unicode ορίζει δύο τύπους ισοδυναμίας χαρακτήρων:

1. **Κανονική Ισοδυναμία**: Οι χαρακτήρες θεωρούνται κανονικά ισοδύναμοι αν έχουν την ίδια εμφάνιση και σημασία όταν εκτυπώνονται ή εμφανίζονται.
2. **Ισοδυναμία Συμβατότητας**: Μια πιο αδύναμη μορφή ισοδυναμίας όπου οι χαρακτήρες μπορεί να αντιπροσωπεύουν τον ίδιο αφηρημένο χαρακτήρα αλλά μπορεί να εμφανίζονται διαφορετικά.

Υπάρχουν **τέσσερις αλγόριθμοι κανονικοποίησης Unicode**: NFC, NFD, NFKC και NFKD. Κάθε αλγόριθμος χρησιμοποιεί τεχνικές κανονικοποίησης κανονικής και συμβατότητας διαφορετικά. Για μια πιο εις βάθος κατανόηση, μπορείτε να εξερευνήσετε αυτές τις τεχνικές στο [Unicode.org](https://unicode.org/).

### Κύρια Σημεία σχετικά με την Κωδικοποίηση Unicode

Η κατανόηση της κωδικοποίησης Unicode είναι κρίσιμη, ειδικά όταν ασχολείστε με ζητήματα διαλειτουργικότητας μεταξύ διαφορετικών συστημάτων ή γλωσσών. Ακολουθούν τα κύρια σημεία:

- **Κωδικοί Σημείων και Χαρακτήρες**: Στο Unicode, κάθε χαρακτήρας ή σύμβολο ανατίθεται μια αριθμητική τιμή γνωστή ως "κωδικός σημείου".
- **Αναπαράσταση Bytes**: Ο κωδικός σημείου (ή χαρακτήρας) αναπαρίσταται από ένα ή περισσότερα bytes στη μνήμη. Για παράδειγμα, οι χαρακτήρες LATIN-1 (συνηθισμένοι σε αγγλόφωνες χώρες) αναπαρίστανται χρησιμοποιώντας ένα byte. Ωστόσο, γλώσσες με μεγαλύτερο σύνολο χαρακτήρων χρειάζονται περισσότερα bytes για την αναπαράσταση.
- **Κωδικοποίηση**: Αυτός ο όρος αναφέρεται στο πώς οι χαρακτήρες μετατρέπονται σε μια σειρά bytes. Το UTF-8 είναι ένα διαδεδομένο πρότυπο κωδικοποίησης όπου οι χαρακτήρες ASCII αναπαρίστανται χρησιμοποιώντας ένα byte, και έως τέσσερα bytes για άλλους χαρακτήρες.
- **Επεξεργασία Δεδομένων**: Τα συστήματα που επεξεργάζονται δεδομένα πρέπει να είναι ενήμερα για την κωδικοποίηση που χρησιμοποιείται για να μετατρέψουν σωστά τη ροή byte σε χαρακτήρες.
- **Παραλλαγές του UTF**: Εκτός από το UTF-8, υπάρχουν άλλα πρότυπα κωδικοποίησης όπως το UTF-16 (χρησιμοποιώντας τουλάχιστον 2 bytes, έως 4) και το UTF-32 (χρησιμοποιώντας 4 bytes για όλους τους χαρακτήρες).

Είναι κρίσιμο να κατανοήσετε αυτές τις έννοιες για να χειριστείτε και να μετριάσετε αποτελεσματικά πιθανά ζητήματα που προκύπτουν από την πολυπλοκότητα του Unicode και τις διάφορες μεθόδους κωδικοποίησής του.

Ένα παράδειγμα του πώς το Unicode κανονικοποιεί δύο διαφορετικά bytes που αντιπροσωπεύουν τον ίδιο χαρακτήρα:
```python
unicodedata.normalize("NFKD","chloe\u0301") == unicodedata.normalize("NFKD", "chlo\u00e9")
```
**Μια λίστα με τους ισοδύναμους χαρακτήρες Unicode μπορεί να βρεθεί εδώ:** [https://appcheck-ng.com/wp-content/uploads/unicode_normalization.html](https://appcheck-ng.com/wp-content/uploads/unicode_normalization.html) και [https://0xacb.com/normalization_table](https://0xacb.com/normalization_table)

### Ανακάλυψη

Αν μπορείτε να βρείτε μέσα σε μια webapp μια τιμή που επιστρέφεται, θα μπορούσατε να προσπαθήσετε να στείλετε **‘KELVIN SIGN’ (U+0212A)** που **κανονικοποιείται σε "K"** (μπορείτε να το στείλετε ως `%e2%84%aa`). **Αν επιστραφεί ένα "K"**, τότε, κάποια μορφή **κανονικοποίησης Unicode** εκτελείται.

Άλλο **παράδειγμα**: `%F0%9D%95%83%E2%85%87%F0%9D%99%A4%F0%9D%93%83%E2%85%88%F0%9D%94%B0%F0%9D%94%A5%F0%9D%99%96%F0%9D%93%83` μετά την **unicode** είναι `Leonishan`.

## **Ευάλωτα Παραδείγματα**

### **Παράκαμψη φίλτρου SQL Injection**

Φανταστείτε μια ιστοσελίδα που χρησιμοποιεί τον χαρακτήρα `'` για να δημιουργήσει SQL ερωτήματα με την είσοδο του χρήστη. Αυτή η ιστοσελίδα, ως μέτρο ασφαλείας, **διαγράφει** όλες τις εμφανίσεις του χαρακτήρα **`'`** από την είσοδο του χρήστη, αλλά **μετά από αυτή τη διαγραφή** και **πριν από τη δημιουργία** του ερωτήματος, **κανονικοποιεί** χρησιμοποιώντας **Unicode** την είσοδο του χρήστη.

Έτσι, ένας κακόβουλος χρήστης θα μπορούσε να εισάγει έναν διαφορετικό χαρακτήρα Unicode ισοδύναμο με `' (0x27)` όπως `%ef%bc%87`, όταν η είσοδος κανονικοποιηθεί, δημιουργείται ένα μονό απόσπασμα και εμφανίζεται μια **ευπάθεια SQLInjection**:

![https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/](<../../images/image (702).png>)

**Ορισμένοι ενδιαφέροντες χαρακτήρες Unicode**

- `o` -- %e1%b4%bc
- `r` -- %e1%b4%bf
- `1` -- %c2%b9
- `=` -- %e2%81%bc
- `/` -- %ef%bc%8f
- `-`-- %ef%b9%a3
- `#`-- %ef%b9%9f
- `*`-- %ef%b9%a1
- `'` -- %ef%bc%87
- `"` -- %ef%bc%82
- `|` -- %ef%bd%9c
```
' or 1=1-- -
%ef%bc%87+%e1%b4%bc%e1%b4%bf+%c2%b9%e2%81%bc%c2%b9%ef%b9%a3%ef%b9%a3+%ef%b9%a3

" or 1=1-- -
%ef%bc%82+%e1%b4%bc%e1%b4%bf+%c2%b9%e2%81%bc%c2%b9%ef%b9%a3%ef%b9%a3+%ef%b9%a3

' || 1==1//
%ef%bc%87+%ef%bd%9c%ef%bd%9c+%c2%b9%e2%81%bc%e2%81%bc%c2%b9%ef%bc%8f%ef%bc%8f

" || 1==1//
%ef%bc%82+%ef%bd%9c%ef%bd%9c+%c2%b9%e2%81%bc%e2%81%bc%c2%b9%ef%bc%8f%ef%bc%8f
```
#### sqlmap template

{{#ref}}
https://github.com/carlospolop/sqlmap_to_unicode_template
{{#endref}}

### XSS (Cross Site Scripting)

Μπορείτε να χρησιμοποιήσετε έναν από τους παρακάτω χαρακτήρες για να παραπλανήσετε την εφαρμογή ιστού και να εκμεταλλευτείτε ένα XSS:

![https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/](<../../images/image (312) (2).png>)

Σημειώστε ότι για παράδειγμα ο πρώτος Unicode χαρακτήρας που προτάθηκε μπορεί να σταλεί ως: `%e2%89%ae` ή ως `%u226e`

![https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/](<../../images/image (215) (1) (1).png>)

### Fuzzing Regexes

Όταν το backend **ελέγχει την είσοδο του χρήστη με ένα regex**, μπορεί να είναι δυνατόν η **είσοδος** να είναι **κανονικοποιημένη** για το **regex** αλλά **όχι** για το πού χρησιμοποιείται. Για παράδειγμα, σε μια Open Redirect ή SSRF το regex μπορεί να **κανονικοποιεί το αποσταλμένο UR**L αλλά στη συνέχεια να **το προσπελάζει όπως είναι**.

Το εργαλείο [**recollapse**](https://github.com/0xacb/recollapse) \*\*\*\* επιτρέπει να **δημιουργήσετε παραλλαγές της εισόδου** για να fuzz το backend. Για περισσότερες πληροφορίες ελέγξτε το **github** και αυτή την [**ανάρτηση**](https://0xacb.com/2022/11/21/recollapse/).

## References

- [**https://labs.spotify.com/2013/06/18/creative-usernames/**](https://labs.spotify.com/2013/06/18/creative-usernames/)
- [**https://security.stackexchange.com/questions/48879/why-does-directory-traversal-attack-c0af-work**](https://security.stackexchange.com/questions/48879/why-does-directory-traversal-attack-c0af-work)
- [**https://jlajara.gitlab.io/posts/2020/02/19/Bypass_WAF_Unicode.html**](https://jlajara.gitlab.io/posts/2020/02/19/Bypass_WAF_Unicode.html)

{{#include ../../banners/hacktricks-training.md}}
