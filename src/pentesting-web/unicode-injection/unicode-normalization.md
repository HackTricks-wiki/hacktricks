# Normalização Unicode

{{#include ../../banners/hacktricks-training.md}}

**Este é um resumo de:** [**https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/**](https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/). Confira para mais detalhes (imagens retiradas de lá).

## Compreendendo Unicode e Normalização

A normalização Unicode é um processo que garante que diferentes representações binárias de caracteres sejam padronizadas para o mesmo valor binário. Este processo é crucial ao lidar com strings em programação e processamento de dados. O padrão Unicode define dois tipos de equivalência de caracteres:

1. **Equivalência Canônica**: Caracteres são considerados canonicamente equivalentes se têm a mesma aparência e significado quando impressos ou exibidos.
2. **Equivalência de Compatibilidade**: Uma forma mais fraca de equivalência onde caracteres podem representar o mesmo caractere abstrato, mas podem ser exibidos de maneira diferente.

Existem **quatro algoritmos de normalização Unicode**: NFC, NFD, NFKC e NFKD. Cada algoritmo emprega técnicas de normalização canônica e de compatibilidade de maneira diferente. Para uma compreensão mais aprofundada, você pode explorar essas técnicas em [Unicode.org](https://unicode.org/).

### Pontos Chave sobre Codificação Unicode

Compreender a codificação Unicode é fundamental, especialmente ao lidar com problemas de interoperabilidade entre diferentes sistemas ou idiomas. Aqui estão os principais pontos:

- **Pontos de Código e Caracteres**: No Unicode, cada caractere ou símbolo é atribuído a um valor numérico conhecido como "ponto de código".
- **Representação em Bytes**: O ponto de código (ou caractere) é representado por um ou mais bytes na memória. Por exemplo, caracteres LATIN-1 (comuns em países de língua inglesa) são representados usando um byte. No entanto, idiomas com um conjunto maior de caracteres precisam de mais bytes para representação.
- **Codificação**: Este termo refere-se a como os caracteres são transformados em uma série de bytes. UTF-8 é um padrão de codificação prevalente onde caracteres ASCII são representados usando um byte, e até quatro bytes para outros caracteres.
- **Processamento de Dados**: Sistemas que processam dados devem estar cientes da codificação utilizada para converter corretamente o fluxo de bytes em caracteres.
- **Variantes de UTF**: Além do UTF-8, existem outros padrões de codificação como UTF-16 (usando um mínimo de 2 bytes, até 4) e UTF-32 (usando 4 bytes para todos os caracteres).

É crucial compreender esses conceitos para lidar efetivamente e mitigar potenciais problemas decorrentes da complexidade do Unicode e seus vários métodos de codificação.

Um exemplo de como o Unicode normaliza dois bytes diferentes representando o mesmo caractere:
```python
unicodedata.normalize("NFKD","chloe\u0301") == unicodedata.normalize("NFKD", "chlo\u00e9")
```
**Uma lista de caracteres equivalentes em Unicode pode ser encontrada aqui:** [https://appcheck-ng.com/wp-content/uploads/unicode_normalization.html](https://appcheck-ng.com/wp-content/uploads/unicode_normalization.html) e [https://0xacb.com/normalization_table](https://0xacb.com/normalization_table)

### Descobrindo

Se você conseguir encontrar dentro de um webapp um valor que está sendo ecoado de volta, você pode tentar enviar **‘KELVIN SIGN’ (U+0212A)** que **normaliza para "K"** (você pode enviá-lo como `%e2%84%aa`). **Se um "K" for ecoado de volta**, então, algum tipo de **normalização Unicode** está sendo realizada.

Outro **exemplo**: `%F0%9D%95%83%E2%85%87%F0%9D%99%A4%F0%9D%93%83%E2%85%88%F0%9D%94%B0%F0%9D%94%A5%F0%9D%99%96%F0%9D%93%83` após **unicode** é `Leonishan`.

## **Exemplos Vulneráveis**

### **Bypass de filtro de SQL Injection**

Imagine uma página da web que está usando o caractere `'` para criar consultas SQL com a entrada do usuário. Esta web, como uma medida de segurança, **deleta** todas as ocorrências do caractere **`'`** da entrada do usuário, mas **após essa exclusão** e **antes da criação** da consulta, ela **normaliza** usando **Unicode** a entrada do usuário.

Então, um usuário malicioso poderia inserir um caractere Unicode diferente equivalente a `' (0x27)` como `%ef%bc%87`, quando a entrada for normalizada, uma aspa simples é criada e uma **vulnerabilidade de SQL Injection** aparece:

![https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/](<../../images/image (702).png>)

**Alguns caracteres Unicode interessantes**

- `o` -- %e1%b4%bc
- `r` -- %e1%b4%bf
- `1` -- %c2%b9
- `=` -- %e2%81%bc
- `/` -- %ef%bc%8f
- `-`-- %ef%b9%a3
- `#`-- %ef%b9%9f
- `*`-- %ef%b9%a1
- `'` -- %ef%bc%87
- `"` -- %ef%bc%82
- `|` -- %ef%bd%9c
```
' or 1=1-- -
%ef%bc%87+%e1%b4%bc%e1%b4%bf+%c2%b9%e2%81%bc%c2%b9%ef%b9%a3%ef%b9%a3+%ef%b9%a3

" or 1=1-- -
%ef%bc%82+%e1%b4%bc%e1%b4%bf+%c2%b9%e2%81%bc%c2%b9%ef%b9%a3%ef%b9%a3+%ef%b9%a3

' || 1==1//
%ef%bc%87+%ef%bd%9c%ef%bd%9c+%c2%b9%e2%81%bc%e2%81%bc%c2%b9%ef%bc%8f%ef%bc%8f

" || 1==1//
%ef%bc%82+%ef%bd%9c%ef%bd%9c+%c2%b9%e2%81%bc%e2%81%bc%c2%b9%ef%bc%8f%ef%bc%8f
```
#### sqlmap template

{{#ref}}
https://github.com/carlospolop/sqlmap_to_unicode_template
{{#endref}}

### XSS (Cross Site Scripting)

Você pode usar um dos seguintes caracteres para enganar o webapp e explorar um XSS:

![https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/](<../../images/image (312) (2).png>)

Note que, por exemplo, o primeiro caractere Unicode proposto pode ser enviado como: `%e2%89%ae` ou como `%u226e`

![https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/](<../../images/image (215) (1) (1).png>)

### Fuzzing Regexes

Quando o backend está **verificando a entrada do usuário com uma regex**, pode ser possível que a **entrada** esteja sendo **normalizada** para a **regex**, mas **não** para onde está sendo **usada**. Por exemplo, em um Open Redirect ou SSRF, a regex pode estar **normalizando a URL enviada**, mas depois **acessando-a como está**.

A ferramenta [**recollapse**](https://github.com/0xacb/recollapse) \*\*\*\* permite **gerar variações da entrada** para fuzzar o backend. Para mais informações, consulte o **github** e este [**post**](https://0xacb.com/2022/11/21/recollapse/).

## References

- [**https://labs.spotify.com/2013/06/18/creative-usernames/**](https://labs.spotify.com/2013/06/18/creative-usernames/)
- [**https://security.stackexchange.com/questions/48879/why-does-directory-traversal-attack-c0af-work**](https://security.stackexchange.com/questions/48879/why-does-directory-traversal-attack-c0af-work)
- [**https://jlajara.gitlab.io/posts/2020/02/19/Bypass_WAF_Unicode.html**](https://jlajara.gitlab.io/posts/2020/02/19/Bypass_WAF_Unicode.html)

{{#include ../../banners/hacktricks-training.md}}
