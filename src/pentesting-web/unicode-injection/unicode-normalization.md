# Normalizacja Unicode

{{#include ../../banners/hacktricks-training.md}}

**To jest podsumowanie:** [**https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/**](https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/). Sprawdź szczegóły (obrazy pochodzą stamtąd).

## Zrozumienie Unicode i Normalizacji

Normalizacja Unicode to proces, który zapewnia, że różne binarne reprezentacje znaków są standaryzowane do tej samej wartości binarnej. Proces ten jest kluczowy w pracy z ciągami w programowaniu i przetwarzaniu danych. Standard Unicode definiuje dwa typy równoważności znaków:

1. **Równoważność kanoniczna**: Znaki są uważane za kanonicznie równoważne, jeśli mają ten sam wygląd i znaczenie, gdy są drukowane lub wyświetlane.
2. **Równoważność kompatybilności**: Słabsza forma równoważności, w której znaki mogą reprezentować ten sam abstrakcyjny znak, ale mogą być wyświetlane inaczej.

Istnieją **cztery algorytmy normalizacji Unicode**: NFC, NFD, NFKC i NFKD. Każdy algorytm stosuje techniki normalizacji kanonicznej i kompatybilności w inny sposób. Aby uzyskać głębsze zrozumienie, możesz zbadać te techniki na [Unicode.org](https://unicode.org/).

### Kluczowe punkty dotyczące kodowania Unicode

Zrozumienie kodowania Unicode jest kluczowe, szczególnie w przypadku problemów z interoperacyjnością między różnymi systemami lub językami. Oto główne punkty:

- **Punkty kodowe i znaki**: W Unicode każdy znak lub symbol ma przypisaną wartość numeryczną znaną jako "punkt kodowy".
- **Reprezentacja bajtów**: Punkt kodowy (lub znak) jest reprezentowany przez jeden lub więcej bajtów w pamięci. Na przykład znaki LATIN-1 (powszechne w krajach anglojęzycznych) są reprezentowane za pomocą jednego bajtu. Jednak języki z większym zestawem znaków potrzebują więcej bajtów do reprezentacji.
- **Kodowanie**: Termin ten odnosi się do sposobu, w jaki znaki są przekształcane w serię bajtów. UTF-8 to powszechny standard kodowania, w którym znaki ASCII są reprezentowane za pomocą jednego bajtu, a do czterech bajtów dla innych znaków.
- **Przetwarzanie danych**: Systemy przetwarzające dane muszą być świadome używanego kodowania, aby poprawnie konwertować strumień bajtów na znaki.
- **Warianty UTF**: Oprócz UTF-8 istnieją inne standardy kodowania, takie jak UTF-16 (używający minimum 2 bajtów, do 4) i UTF-32 (używający 4 bajtów dla wszystkich znaków).

Zrozumienie tych koncepcji jest kluczowe, aby skutecznie radzić sobie z potencjalnymi problemami wynikającymi z złożoności Unicode i jego różnych metod kodowania.

Przykład, jak Unicode normalizuje dwa różne bajty reprezentujące ten sam znak:
```python
unicodedata.normalize("NFKD","chloe\u0301") == unicodedata.normalize("NFKD", "chlo\u00e9")
```
**Lista znaków równoważnych Unicode znajduje się tutaj:** [https://appcheck-ng.com/wp-content/uploads/unicode_normalization.html](https://appcheck-ng.com/wp-content/uploads/unicode_normalization.html) i [https://0xacb.com/normalization_table](https://0xacb.com/normalization_table)

### Odkrywanie

Jeśli możesz znaleźć w aplikacji internetowej wartość, która jest zwracana, możesz spróbować wysłać **‘KELVIN SIGN’ (U+0212A)**, która **normalizuje się do "K"** (możesz wysłać to jako `%e2%84%aa`). **Jeśli "K" jest zwracane**, to wykonywana jest jakaś forma **normalizacji Unicode**.

Inny **przykład**: `%F0%9D%95%83%E2%85%87%F0%9D%99%A4%F0%9D%93%83%E2%85%88%F0%9D%94%B0%F0%9D%94%A5%F0%9D%99%96%F0%9D%93%83` po **unicode** to `Leonishan`.

## **Przykłady podatne**

### **Obejście filtra SQL Injection**

Wyobraź sobie stronę internetową, która używa znaku `'` do tworzenia zapytań SQL z danymi wejściowymi użytkownika. Ta strona, jako środek bezpieczeństwa, **usuwa** wszystkie wystąpienia znaku **`'`** z danych wejściowych użytkownika, ale **po tym usunięciu** i **przed utworzeniem** zapytania, **normalizuje** dane wejściowe użytkownika przy użyciu **Unicode**.

Wtedy złośliwy użytkownik mógłby wstawić inny znak Unicode równoważny `' (0x27)` jak `%ef%bc%87`, gdy dane wejściowe zostaną znormalizowane, powstaje pojedynczy apostrof i pojawia się **vulnerabilność SQLInjection**:

![https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/](<../../images/image (702).png>)

**Niektóre interesujące znaki Unicode**

- `o` -- %e1%b4%bc
- `r` -- %e1%b4%bf
- `1` -- %c2%b9
- `=` -- %e2%81%bc
- `/` -- %ef%bc%8f
- `-`-- %ef%b9%a3
- `#`-- %ef%b9%9f
- `*`-- %ef%b9%a1
- `'` -- %ef%bc%87
- `"` -- %ef%bc%82
- `|` -- %ef%bd%9c
```
' or 1=1-- -
%ef%bc%87+%e1%b4%bc%e1%b4%bf+%c2%b9%e2%81%bc%c2%b9%ef%b9%a3%ef%b9%a3+%ef%b9%a3

" or 1=1-- -
%ef%bc%82+%e1%b4%bc%e1%b4%bf+%c2%b9%e2%81%bc%c2%b9%ef%b9%a3%ef%b9%a3+%ef%b9%a3

' || 1==1//
%ef%bc%87+%ef%bd%9c%ef%bd%9c+%c2%b9%e2%81%bc%e2%81%bc%c2%b9%ef%bc%8f%ef%bc%8f

" || 1==1//
%ef%bc%82+%ef%bd%9c%ef%bd%9c+%c2%b9%e2%81%bc%e2%81%bc%c2%b9%ef%bc%8f%ef%bc%8f
```
#### szablon sqlmap

{{#ref}}
https://github.com/carlospolop/sqlmap_to_unicode_template
{{#endref}}

### XSS (Cross Site Scripting)

Możesz użyć jednego z następujących znaków, aby oszukać aplikację webową i wykorzystać XSS:

![https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/](<../../images/image (312) (2).png>)

Zauważ, że na przykład pierwszy proponowany znak Unicode można wysłać jako: `%e2%89%ae` lub jako `%u226e`

![https://appcheck-ng.com/unicode-normalization-vulnerabilities-the-special-k-polyglot/](<../../images/image (215) (1) (1).png>)

### Fuzzing Regexes

Kiedy backend **sprawdza dane wejściowe użytkownika za pomocą regex**, może być możliwe, że **wejście** jest **normalizowane** dla **regex**, ale **nie** dla miejsca, w którym jest **używane**. Na przykład, w przypadku Open Redirect lub SSRF regex może **normalizować wysłany URL**, ale następnie **uzyskiwać do niego dostęp tak, jak jest**.

Narzędzie [**recollapse**](https://github.com/0xacb/recollapse) \*\*\*\* pozwala na **generowanie wariacji wejścia** w celu fuzzowania backendu. Po więcej informacji sprawdź **github** i ten [**post**](https://0xacb.com/2022/11/21/recollapse/).

## Referencje

- [**https://labs.spotify.com/2013/06/18/creative-usernames/**](https://labs.spotify.com/2013/06/18/creative-usernames/)
- [**https://security.stackexchange.com/questions/48879/why-does-directory-traversal-attack-c0af-work**](https://security.stackexchange.com/questions/48879/why-does-directory-traversal-attack-c0af-work)
- [**https://jlajara.gitlab.io/posts/2020/02/19/Bypass_WAF_Unicode.html**](https://jlajara.gitlab.io/posts/2020/02/19/Bypass_WAF_Unicode.html)

{{#include ../../banners/hacktricks-training.md}}
