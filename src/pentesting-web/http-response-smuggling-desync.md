# HTTP Response Smuggling / Desync

{{#include ../banners/hacktricks-training.md}}

**Die tegniek van hierdie pos is geneem uit die video:** [**https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s**](https://www.youtube.com/watch?v=suxDcYViwao&t=1343s)

## HTTP Versoek Queues Desynchronisasie

Eerstens, hierdie tegniek **misbruik 'n HTTP Versoek Smuggling kwesbaarheid**, so jy moet weet wat dit is:

Die **hoof** **verskil** tussen hierdie tegniek en 'n algemene HTTP Versoek smuggling is dat **in plaas daarvan** om die **versoek** van die **slagoffer** **te aanval** deur 'n voorvoegsel daaraan toe te voeg, gaan ons die **antwoord wat die slagoffer ontvang** **lek of wysig**. Dit word gedoen deur, in plaas van om 1 versoek en 'n half te stuur om die HTTP Versoek smuggling te misbruik, **2 volledige versoeke te stuur om die proxies se antwoordqueue te desynchroniseer**.

Dit is omdat ons in staat gaan wees om die **antwoordqueue te desynchroniseer** sodat die **antwoord** van die **legitieme** **versoek** van die **slagoffer na die aanvaller gestuur word**, of deur **aanvallersbeheerde inhoud in die antwoord aan die slagoffer in te spuit**.

### HTTP Pyplyn Desync

HTTP/1.1 laat toe om **verskillende hulpbronne te vra sonder om te wag vir vorige**. Daarom, as daar 'n **proxy** in die **middel** is, is dit die proxies se taak om 'n **gesinkroniseerde ooreenkoms van versoeke wat na die agtergrond gestuur is en antwoorde wat daaruit kom** te **onderhou**.

Daar is egter 'n probleem om die antwoordequeue te desynchroniseer. As 'n aanvaller 'n HTTP Response smuggling aanval stuur en die antwoorde op die **aanvangsversoek en die gesmugde een onmiddellik beantwoord word**, sal die gesmugde antwoord nie in die queue van die slagoffer se antwoord ingevoeg word nie, maar sal **net as 'n fout weggegooi word**.

![](<../images/image (633).png>)

Daarom is dit nodig dat die **gesmugde** **versoek** **meer tyd neem om verwerk te word** binne die agtergrond bediener. Daarom, teen die tyd dat die gesmugde versoek verwerk word, sal die kommunikasie met die aanvaller verby wees.

As in hierdie spesifieke situasie 'n **slagoffer 'n versoek gestuur het** en die **gesmugde versoek voor** die legitieme versoek beantwoord word, sal die **gesmugde antwoord na die slagoffer gestuur word**. Daarom sal die aanvaller die **versoek "uitgevoer" deur die slagoffer** **beheer**.

Boonop, as die **aanvaller dan 'n versoek uitvoer** en die **legitieme antwoord** op die **slagoffer** se versoek **beantwoord** **voor** die aanvaller se versoek. Die **antwoord aan die slagoffer gaan na die aanvaller gestuur word**, **steel** die antwoord aan die slagoffer (wat byvoorbeeld die koptekst **Set-Cookie** kan bevat).

![](<../images/image (1020).png>)

![](<../images/image (719).png>)

### Meervoudige Geneste Inspuitings

Nog 'n **interessante verskil** met algemene **HTTP Versoek Smuggling** is dat, in 'n algemene smuggling aanval, die **doel** is om die **begin van die slagoffer se versoek** te **wysig** sodat dit 'n onverwagte aksie uitvoer. In 'n **HTTP Response smuggling aanval**, aangesien jy **volledige versoeke stuur**, kan jy **in een payload tientalle antwoorde inspuit** wat **tientalle gebruikers gaan desynchroniseer** wat die **ingespuite** **antwoorde** gaan **ontvang**.

Afgesien daarvan dat jy in staat is om **tientalle exploits makliker te versprei** oor legitieme gebruikers, kan dit ook gebruik word om 'n **DoS** op die bediener te veroorsaak.

### Exploit Organisasie

Soos voorheen verduidelik, om hierdie tegniek te misbruik, is dit nodig dat die **eerste gesmugde boodskap** in die bediener **baie tyd neem om verwerk te word**.

Hierdie **tydrowende versoek is genoeg** as ons net die **slagoffer se antwoord wil probeer steel.** Maar as jy 'n meer komplekse exploit wil uitvoer, sal dit 'n algemene struktuur vir die exploit wees.

Eerstens die **aanvangs** versoek wat **HTTP** **Versoek** **smuggling** misbruik, dan die **tydrowende versoek** en dan **1 of meer payload versoeke** waarvan die antwoorde aan die slagoffers gestuur sal word.

## Misbruik van HTTP Antwoord Queue Desynchronisasie

### Om ander gebruikers se versoeke te vang <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Soos met bekende payloads van HTTP Versoek Smuggling, kan jy die **slagoffer se versoek steel** met een belangrike verskil: In hierdie geval het jy net die **gestuurde inhoud wat in die antwoord weerspieël moet word**, **geen volgehoue berging** is nodig nie.

Eerstens, die aanvaller stuur 'n payload wat 'n **finale POST versoek met die weerspieëlde parameter** aan die einde en 'n groot Content-Length bevat

![](<../images/image (1053).png>)

Dan, sodra die **aanvangsversoek** (blou) verwerk is en **terwyl** die **slaapagtige** een verwerk word (geel) gaan die **volgende versoek wat van 'n slagoffer aankom** in die queue **net na die weerspieëlde parameter** **bygevoeg word**:

![](<../images/image (794).png>)

Dan, die **slagoffer** sal die **antwoord** op die **slaapagtige** versoek ontvang en as intussen die **aanvaller** **nog 'n** **versoek gestuur het**, sal die **antwoord van die weerspieëlde inhoud versoek na hom gestuur word**.

## Antwoord Desynchronisasie

Tot op hierdie punt, het ons geleer hoe om HTTP Versoek Smuggling aanvalle te misbruik om die **versoek** **waarvan** die **antwoord** 'n **klient** gaan **ontvang** te **beheer** en hoe jy dan die **antwoord wat bedoel was vir die slagoffer** kan **steel**.

Maar dit is steeds moontlik om die antwoorde nog meer te **desynchroniseer**.

Daar is interessante versoeke soos **HEAD** versoeke wat gespesifiseer is om **geen inhoud binne die antwoord se liggaam** te hê nie en wat **die Content-Length** van die versoek moet (moet) **bevat soos dit 'n GET versoek was**.

Daarom, as 'n aanvaller 'n **HEAD** versoek **inspuit**, soos in hierdie beelde:

![](<../images/image (1107).png>)

Dan, **sodra die blou een aan die aanvaller beantwoord word**, gaan die volgende slagoffer se versoek in die queue ingevoer word:

![](<../images/image (999).png>)

Dan, die **slagoffer** sal die **antwoord** van die **HEAD** versoek ontvang, wat **'n Content-Length gaan bevat maar glad nie inhoud nie**. Daarom, die proxy **sal hierdie antwoord nie aan die slagoffer stuur nie**, maar sal **wag** vir 'n **inhoud**, wat eintlik die **antwoord op die geel versoek** gaan wees (ook deur die aanvaller ingespuit):

![](<../images/image (735).png>)

### Inhoud Verwarring

Volg die vorige voorbeeld, wetende dat jy die **liggaam** van die versoek kan **beheer** waarvan die antwoord die slagoffer gaan ontvang en dat 'n **HEAD** **antwoord** gewoonlik in sy kopstukke die **Content-Type en die Content-Length** bevat, kan jy **'n versoek soos die volgende** stuur om **XSS** in die slagoffer te veroorsaak sonder dat die bladsy kwesbaar is vir XSS:

![](<../images/image (688).png>)

### Cache Vergiftiging

Deur die voorheen bespreekte antwoord desynchronisasie Inhoud Verwarring aanval te misbruik, **as die cache die antwoord op die versoek wat deur die slagoffer uitgevoer is stoor en hierdie antwoord 'n ingespuite een is wat 'n XSS veroorsaak, dan is die cache vergiftig**.

Kwaadwillige versoek wat die XSS payload bevat:

![](<../images/image (614).png>)

Kwaadwillige antwoord aan die slagoffer wat die kopstuk bevat wat aan die cache aandui om die antwoord te stoor:

![](<../images/image (566).png>)

> [!WARNING]
> Let daarop dat in hierdie geval as die **"slagoffer" die aanvaller** is, kan hy nou **cache vergiftiging in arbitrêre URL's** uitvoer aangesien hy die **URL wat in die cache gestoor gaan word** met die kwaadwillige antwoord kan **beheer**.

### Web Cache Misleiding

Hierdie aanval is soortgelyk aan die vorige een, maar **in plaas daarvan om 'n payload binne die cache in te spuit, sal die aanvaller slagofferinligting binne die cache stoor:**

![](<../images/image (991).png>)

### Antwoord Splitting

Die **doel** van hierdie aanval is om weer die **antwoord** **desynchronisasie** te misbruik om die **proxy 'n 100% aanvaller gegenereerde antwoord** te laat stuur.

Om dit te bereik, moet die aanvaller 'n eindpunt van die webtoepassing vind wat **sekere waardes binne die antwoord weerspieël** en **die inhoudsgrootte van die HEAD antwoord** weet.

Hy sal 'n **exploit** soos volg stuur:

![](<../images/image (911).png>)

Nadat die eerste versoek opgelos is en aan die aanvaller teruggestuur is, word die **slagoffer se versoek in die queue bygevoeg**:

![](<../images/image (737).png>)

Die slagoffer sal as antwoord die **HEAD antwoord + die inhoud van die tweede versoek se antwoord (wat 'n deel van die weerspieëlde data bevat):**

![](<../images/image (356).png>)

Let egter op hoe die **weerspieëlde data 'n grootte gehad het volgens die Content-Length** van die **HEAD** antwoord wat **'n geldige HTTP antwoord in die antwoordqueue** gegenereer het.

Daarom, die **volgende versoek van die tweede slagoffer** sal **ontvang** as **antwoord iets wat heeltemal deur die aanvaller saamgestel is**. Aangesien die antwoord heeltemal deur die aanvaller saamgestel is, kan hy ook die **proxy laat cache die antwoord**.

{{#include ../banners/hacktricks-training.md}}
