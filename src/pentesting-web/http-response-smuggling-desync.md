# HTTP Response Smuggling / Desync

{{#include ../banners/hacktricks-training.md}}

**本帖的技术来源于视频：** [**https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s**](https://www.youtube.com/watch?v=suxDcYViwao&t=1343s)

## HTTP 请求队列去同步

首先，这种技术**利用了 HTTP 请求走私漏洞**，所以你需要知道这是什么：

这种技术与常见的 HTTP 请求走私的**主要区别**在于，**不是通过添加前缀来攻击受害者的请求**，而是**泄露或修改受害者收到的响应**。这是通过发送**两个完整的请求来去同步代理的响应队列**，而不是发送一个半请求来利用 HTTP 请求走私。

这是因为我们将能够**去同步响应队列**，使得**受害者的合法请求的响应被发送给攻击者**，或者通过**在响应中注入攻击者控制的内容**给受害者。

### HTTP 管道去同步

HTTP/1.1 允许请求**不同的资源而不需要等待之前的请求**。因此，如果中间有一个**代理**，那么代理的任务是**保持发送到后端的请求和来自后端的响应的同步匹配**。

然而，去同步响应队列存在一个问题。如果攻击者发送一个 HTTP 响应走私攻击，并且对**初始请求和走私请求的响应立即返回**，那么走私响应不会被插入到受害者响应的队列中，而是**作为错误被丢弃**。

![](<../images/image (633).png>)

因此，需要**走私请求在后端服务器中处理的时间更长**。因此，当走私请求被处理时，与攻击者的通信将结束。

如果在这种特定情况下，**受害者发送了一个请求**，而**走私请求在合法请求之前被响应**，那么**走私响应将被发送给受害者**。因此，攻击者将**控制受害者“执行”的请求**。

此外，如果**攻击者随后执行一个请求**，而**对受害者请求的合法响应**在攻击者请求之前被**回答**，那么**对受害者的响应将被发送给攻击者**，**窃取**对受害者的响应（例如，可能包含**Set-Cookie**头）。

![](<../images/image (1020).png>)

![](<../images/image (719).png>)

### 多重嵌套注入

与常见的**HTTP 请求走私**相比，另一个**有趣的区别**是，在常见的走私攻击中，**目标**是**修改受害者请求的开头**，使其执行意外的操作。在**HTTP 响应走私攻击**中，由于你**发送完整的请求**，你可以**在一个有效载荷中注入数十个响应**，这将**去同步数十个用户**，使他们**接收**被**注入的**响应。

除了能够**更容易地在合法用户之间分发数十个漏洞**，这也可以用于导致服务器的**拒绝服务**。

### 漏洞组织

如前所述，为了利用这种技术，需要**第一个走私消息**在服务器中**处理的时间很长**。

如果我们只是想**尝试窃取受害者的响应**，那么这个**耗时的请求就足够了**。但如果你想执行更复杂的漏洞，这将是漏洞的常见结构。

首先是**初始**请求，利用**HTTP** **请求** **走私**，然后是**耗时的请求**，最后是**一个或多个有效载荷请求**，其响应将被发送给受害者。

## 利用 HTTP 响应队列去同步

### 捕获其他用户的请求 <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

与已知的 HTTP 请求走私有效载荷一样，你可以**窃取受害者的请求**，有一个重要的区别：在这种情况下，你只需要**发送的内容在响应中被反射**，**不需要持久存储**。

首先，攻击者发送一个有效载荷，包含一个**带有反射参数的最终 POST 请求**，并且有一个大的 Content-Length。

![](<../images/image (1053).png>)

然后，一旦**初始请求**（蓝色）被**处理**，而**耗时**的请求（黄色）正在被处理时，**来自受害者的下一个请求**将被**附加在反射参数之后**：

![](<../images/image (794).png>)

然后，**受害者**将**收到**对**耗时**请求的**响应**，如果在此期间**攻击者****发送**了**另一个**请求，**反射内容请求的响应将被发送给他**。

## 响应去同步

到目前为止，我们已经学习了如何利用 HTTP 请求走私攻击来**控制**客户端将要**接收的**请求**的响应**，以及如何**窃取原本属于受害者的响应**。

但仍然可以**进一步去同步**响应。

有一些有趣的请求，比如**HEAD**请求，它被规定**响应体中不应包含任何内容**，并且应该（必须）**包含请求的 Content-Length**，就像**GET 请求**一样。

因此，如果攻击者**注入**一个**HEAD**请求，如下图所示：

![](<../images/image (1107).png>)

然后，一旦**蓝色请求**被响应给攻击者，**下一个受害者的请求**将被引入队列：

![](<../images/image (999).png>)

然后，**受害者**将**收到**来自**HEAD**请求的**响应**，该响应**将包含一个 Content-Length，但没有任何内容**。因此，代理**不会将此响应发送给受害者**，而是**等待**一些**内容**，实际上这将是**对黄色请求的响应**（也由攻击者注入）：

![](<../images/image (735).png>)

### 内容混淆

根据前面的例子，知道你可以**控制请求的主体**，其响应将被受害者接收，并且**HEAD** **响应**通常在其头部包含**Content-Type 和 Content-Length**，你可以**发送如下请求**以**在受害者中引发 XSS**，而页面并不容易受到 XSS 的攻击：

![](<../images/image (688).png>)

### 缓存中毒

利用之前提到的响应去同步内容混淆攻击，**如果缓存存储了受害者执行的请求的响应，并且该响应是一个导致 XSS 的注入响应，那么缓存就被中毒了**。

包含 XSS 有效载荷的恶意请求：

![](<../images/image (614).png>)

包含指示缓存存储响应的头的恶意响应：

![](<../images/image (566).png>)

> [!WARNING]
> 请注意，在这种情况下，如果**“受害者”是攻击者**，他现在可以在任意 URL 上执行**缓存中毒**，因为他可以**控制将要被缓存的 URL**，与恶意响应一起。

### Web 缓存欺骗

此攻击类似于前一个，但**攻击者将受害者信息缓存到缓存中，而不是在缓存中注入有效载荷：**

![](<../images/image (991).png>)

### 响应分割

此攻击的**目标**是再次利用**响应** **去同步**，以使代理发送一个 100% 由攻击者生成的响应。

为了实现这一点，攻击者需要找到一个**反射某些值到响应中的** Web 应用程序的端点，并**知道 HEAD 响应的内容长度**。

他将发送一个**漏洞**，如下所示：

![](<../images/image (911).png>)

在第一个请求被解决并发送回攻击者后，**受害者的请求被添加到队列中**：

![](<../images/image (737).png>)

受害者将收到的响应是**HEAD 响应 + 第二个请求响应的内容（包含部分反射数据）：**

![](<../images/image (356).png>)

然而，请注意**反射数据的大小与 HEAD 响应的 Content-Length 相符**，这**在响应队列中生成了一个有效的 HTTP 响应**。

因此，**第二个受害者的下一个请求**将**接收到**一个完全由攻击者构造的**响应**。由于响应完全由攻击者构造，他还可以**使代理缓存该响应**。

{{#include ../banners/hacktricks-training.md}}
