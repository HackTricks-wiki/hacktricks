# HTTP Yanıt Kaçırma / Desenkronizasyon

{{#include ../banners/hacktricks-training.md}}

**Bu gönderinin tekniği videodan alınmıştır:** [**https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s**](https://www.youtube.com/watch?v=suxDcYViwao&t=1343s)

## HTTP İstek Kuyruğu Desenkronizasyonu

Öncelikle, bu teknik **bir HTTP Yanıt Kaçırma açığını istismar eder**, bu yüzden bunun ne olduğunu bilmelisiniz:

Bu tekniğin **ana** **farkı**, yaygın bir HTTP Yanıt Kaçırma ile, **kurbanın isteğine bir ön ek ekleyerek saldırmak yerine**, **kurbanın aldığı yanıtı sızdırmak veya değiştirmek** için **2 tam istek göndererek proxy yanıt kuyruklarını desenkronize etmek** olacaktır.

Bu, **kurbanın meşru isteğinden gelen yanıtın saldırgana gönderilmesini** veya **kurbanın yanıtında saldırganın kontrolündeki içeriği enjekte ederek** yapılır.

### HTTP Boru Hattı Desenkronizasyonu

HTTP/1.1, **önceki isteklere beklemeden farklı kaynaklar istemeye** izin verir. Bu nedenle, eğer bir **proxy** varsa, proxy'nin görevi, **arka uçta gönderilen isteklerin ve ondan gelen yanıtların senkronize bir eşleşmesini sürdürmektir**.

Ancak, yanıt kuyruklarını desenkronize etme konusunda bir sorun vardır. Eğer bir saldırgan bir HTTP Yanıt Kaçırma saldırısı gönderirse ve **ilk isteğe ve kaçırılan isteğe yanıtlar hemen verilirse**, kaçırılan yanıt kurbanın yanıt kuyrusuna eklenmeyecek, **bir hata olarak atılacaktır**.

![](<../images/image (633).png>)

Bu nedenle, **kaçırılan isteğin** arka uç sunucusunda **işlenmesi için daha fazla zaman alması** gerekmektedir. Böylece, kaçırılan istek işlenene kadar, saldırganla iletişim sona erecektir.

Eğer bu özel durumda bir **kurban bir istek göndermişse** ve **kaçırılan isteğe yanıt, meşru isteğinden önce verilirse**, **kaçırılan yanıt kurbana gönderilecektir**. Böylece, saldırgan **kurban tarafından "gerçekleştirilen" isteği kontrol edecektir**.

Ayrıca, eğer **saldırgan bir istek gerçekleştirirse** ve **kurbanın isteğine verilen meşru yanıt**, saldırganın isteğinden **önce yanıtlanırsa**, **kurbanın yanıtı saldırgana gönderilecektir**, **kurbanın yanıtını çalarak** (örneğin, **Set-Cookie** başlığını içerebilir).

![](<../images/image (1020).png>)

![](<../images/image (719).png>)

### Çoklu İç İçe Enjeksiyonlar

Yaygın **HTTP Yanıt Kaçırma** ile başka bir **ilginç fark**, yaygın bir kaçırma saldırısında **amaç**, **kurbanın isteğinin başlangıcını değiştirmek** ve beklenmedik bir eylem gerçekleştirmektir. **HTTP Yanıt Kaçırma saldırısında**, **tam istekler gönderdiğiniz için**, **bir yük içinde onlarca yanıt enjekte edebilir** ve **desenkronize olan onlarca kullanıcıya** **enjekte edilen yanıtları** **ulaştırabilirsiniz**.

Ayrıca, **meşru kullanıcılar arasında daha kolay onca istismar dağıtma** imkanı sağlamanın yanı sıra, bu aynı zamanda sunucuda bir **DoS** oluşturmak için de kullanılabilir.

### İstismar Organizasyonu

Daha önce açıklandığı gibi, bu tekniği istismar etmek için, **sunucuya gönderilen ilk kaçırılan mesajın** **işlenmesi için çok zaman alması** gerekmektedir.

Bu **zaman alan istek yeterlidir** eğer sadece **kurbanın yanıtını çalmaya çalışıyorsanız**. Ancak daha karmaşık bir istismar gerçekleştirmek istiyorsanız, bu istismar için yaygın bir yapı olacaktır.

Öncelikle **HTTP** **İstek** **Kaçırma** istismarını kullanarak **ilk** isteği göndermek, ardından **zaman alan isteği** ve sonra **kurbanlara gönderilecek 1 veya daha fazla yük isteği**.

## HTTP Yanıt Kuyruğu Desenkronizasyonunu İstismar Etme

### Diğer kullanıcıların isteklerini yakalama <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

HTTP Yanıt Kaçırma ile bilinen yükler gibi, **kurbanın isteğini çalabilirsiniz** ama bir önemli farkla: Bu durumda, **yanıtın içinde yansıtılan içeriği göndermeniz yeterlidir**, **kalıcı depolama** gerekmez.

Öncelikle, saldırgan **yansıtılan parametreyle birlikte son bir POST isteği içeren bir yük** gönderir ve büyük bir Content-Length ayarlar.

![](<../images/image (1053).png>)

Sonra, **ilk istek** (mavi) **işlendiğinde** ve **uyku halindeki** istek işlenirken (sarı), **bir kurbandan gelen bir sonraki istek**, **yansıtılan parametreden hemen sonra kuyrukta eklenecektir**:

![](<../images/image (794).png>)

Sonra, **kurban**, **uyku halindeki** isteğin **yanıtını alacak** ve bu arada **saldırgan** **başka bir istek gönderirse**, **yansıtılan içerik isteğinden gelen yanıt ona gönderilecektir**.

## Yanıt Desenkronizasyonu

Bu noktaya kadar, HTTP Yanıt Kaçırma saldırılarını nasıl istismar edeceğimizi öğrendik, böylece **bir istemcinin alacağı yanıtı kontrol edebiliriz** ve ardından **kurban için tasarlanmış yanıtı çalabiliriz**.

Ancak, yanıtları **daha da desenkronize etmek** mümkündür.

**Yanıt gövdesinde** **hiçbir içerik olmaması gereken** ve **GET isteğiymiş gibi Content-Length** içermesi gereken **HEAD** isteği gibi ilginç istekler vardır.

Bu nedenle, eğer bir saldırgan **HEAD** isteği enjekte ederse, bu görüntülerdeki gibi:

![](<../images/image (1107).png>)

O zaman, **mavi yanıt saldırgana verildiğinde**, bir sonraki kurban isteği kuyrukta tanıtılacaktır:

![](<../images/image (999).png>)

Sonra, **kurban**, **HEAD** isteğinden gelen **yanıtı alacak**, bu yanıt **bir Content-Length içerecek ama hiç içerik olmayacaktır**. Bu nedenle, proxy **bu yanıtı kurbana göndermeyecek**, ancak bazı **içerik** bekleyecektir, bu da aslında **saldırgan tarafından enjekte edilen sarı isteğin yanıtı olacaktır**:

![](<../images/image (735).png>)

### İçerik Karışıklığı

Önceki örneği takip ederek, **kurbanın alacağı yanıtın gövdesini kontrol edebildiğinizi** ve **HEAD** **yanıtının genellikle başlıklarında **Content-Type ve Content-Length** içerdiğini bilerek, **kurbanın XSS** oluşturmasına neden olacak aşağıdaki gibi bir istek gönderebilirsiniz:

![](<../images/image (688).png>)

### Önbellek Zehirleme

Daha önce bahsedilen yanıt desenkronizasyonu İçerik Karışıklığı saldırısını istismar ederek, **eğer önbellek, kurban tarafından gerçekleştirilen isteğe verilen yanıtı depoluyorsa ve bu yanıt bir XSS oluşturan enjekte edilmiş bir yanıt ise, o zaman önbellek zehirlenir**.

XSS yükünü içeren kötü niyetli istek:

![](<../images/image (614).png>)

Kurbana, yanıtı depolaması için önbelleğe işaret eden başlığı içeren kötü niyetli yanıt:

![](<../images/image (566).png>)

> [!WARNING]
> Bu durumda, eğer **"kurban" saldırgansa**, artık **keyfi URL'lerde önbellek zehirlemesi** gerçekleştirebilir, çünkü **kötü niyetli yanıtla önbelleğe alınacak URL'yi kontrol edebilir**.

### Web Önbellek Aldatmacası

Bu saldırı, bir öncekiyle benzer, ancak **saldırgan, önbelleğe bir yük enjekte etmek yerine, kurban bilgilerini önbelleğe alacaktır:**

![](<../images/image (991).png>)

### Yanıt Bölme

Bu saldırının **amacı**, **yanıt** **desenkronizasyonunu** tekrar istismar ederek **proxy'nin %100 saldırgan tarafından üretilen bir yanıt göndermesini sağlamak**.

Bunu başarmak için, saldırgan, **yanıt içinde bazı değerleri yansıtan** bir web uygulaması uç noktası bulmalı ve **HEAD yanıtının içerik uzunluğunu bilmelidir**.

Bir **istismar** gönderir:

![](<../images/image (911).png>)

İlk istek çözüldükten ve saldırgana geri gönderildikten sonra, **kurbanın isteği kuyrukta eklenir**:

![](<../images/image (737).png>)

Kurban, yanıt olarak **HEAD yanıtı + ikinci isteğin yanıtının içeriğini (yansıtılan verilerin bir kısmını içeren)** alacaktır:

![](<../images/image (356).png>)

Ancak, **yansıtılan verilerin, yanıt kuyruklarında geçerli bir HTTP yanıtı üreten HEAD yanıtının Content-Length'ine göre bir boyuta sahip olduğunu** unutmayın.

Bu nedenle, **ikinci kurbanın bir sonraki isteği**, **saldırgan tarafından tamamen oluşturulmuş bir yanıt alacaktır**. Yanıt tamamen saldırgan tarafından oluşturulduğu için, **proxy'nin yanıtı önbelleğe almasını da sağlayabilir**.

{{#include ../banners/hacktricks-training.md}}
