# HTTP Response Smuggling / Desync

{{#include ../banners/hacktricks-training.md}}

**この投稿の技術は、次のビデオから取得されました:** [**https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s**](https://www.youtube.com/watch?v=suxDcYViwao&t=1343s)

## HTTPリクエストキューの非同期化

まず、この技術は**HTTPリクエストスムージングの脆弱性を悪用します**ので、それが何であるかを知っておく必要があります：

この技術と一般的なHTTPリクエストスムージングの**主な違い**は、**攻撃する**のではなく、**被害者が受け取るレスポンスを漏洩または変更する**ことです。これは、HTTPリクエストスムージングを悪用するために1.5リクエストを送信する代わりに、**プロキシのレスポンスキューを非同期化するために2つの完全なリクエストを送信します**。

これは、**レスポンスキューを非同期化することができるため**、**被害者の正当なリクエストからのレスポンスが攻撃者に送信される**か、**攻撃者が制御するコンテンツを被害者へのレスポンスに注入する**ことができます。

### HTTPパイプラインの非同期化

HTTP/1.1は、**前のリクエストを待つことなく異なるリソースを要求する**ことを許可します。したがって、**中間にプロキシがある場合**、プロキシのタスクは**バックエンドに送信されたリクエストとそこからのレスポンスの同期を維持する**ことです。

しかし、レスポンスキューを非同期化するには問題があります。攻撃者がHTTPレスポンススムージング攻撃を送信し、**最初のリクエストとスムージングされたリクエストへのレスポンスが即座に返される**と、スムージングされたレスポンスは被害者のレスポンスキューに挿入されず、**エラーとして単に破棄されます**。

![](<../images/image (633).png>)

したがって、**スムージングされたリクエストがバックエンドサーバー内で処理されるのに時間がかかる必要があります**。そのため、スムージングされたリクエストが処理される頃には、攻撃者との通信は終了します。

この特定の状況で**被害者がリクエストを送信し、スムージングされたリクエストが正当なリクエストの前に応答される**と、**スムージングされたレスポンスが被害者に送信されます**。したがって、攻撃者は**被害者によって「実行された」リクエストを制御します**。

さらに、**攻撃者がリクエストを実行し、被害者のリクエストに対する正当なレスポンスが攻撃者のリクエストの前に応答される**場合、**被害者へのレスポンスは攻撃者に送信され、**被害者へのレスポンスを**盗む**ことになります（例えば、**Set-Cookie**ヘッダーを含むことがあります）。

![](<../images/image (1020).png>)

![](<../images/image (719).png>)

### 複数のネストされたインジェクション

一般的な**HTTPリクエストスムージング**とのもう一つの**興味深い違い**は、一般的なスムージング攻撃では、**目的**は**被害者のリクエストの先頭を変更して予期しないアクションを実行させる**ことです。**HTTPレスポンススムージング攻撃**では、**完全なリクエストを送信しているため**、**1つのペイロードに数十のレスポンスを注入**することができ、**数十のユーザーを非同期化**して**注入されたレスポンスを受け取る**ことができます。

正当なユーザーに対して**数十のエクスプロイトをより簡単に配布できる**だけでなく、これはサーバーに**DoS**を引き起こすためにも使用できます。

### エクスプロイトの組織

前述のように、この技術を悪用するには、**サーバーに送信される最初のスムージングメッセージが処理されるのに多くの時間がかかる必要があります**。

この**時間のかかるリクエストは**、**被害者のレスポンスを盗むことを試みるだけであれば十分です**。しかし、より複雑なエクスプロイトを実行したい場合、これはエクスプロイトの一般的な構造になります。

まず、**HTTPリクエストスムージングを悪用する最初のリクエスト**、次に**時間のかかるリクエスト**、そして**1つ以上のペイロードリクエスト**があり、そのレスポンスが被害者に送信されます。

## HTTPレスポンスキューの非同期化を悪用する

### 他のユーザーのリクエストをキャプチャする <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

HTTPリクエストスムージングの既知のペイロードと同様に、**被害者のリクエストを盗む**ことができますが、1つの重要な違いがあります：この場合、**レスポンスに反映されるコンテンツを送信するだけで済み、**永続的なストレージは必要ありません**。

まず、攻撃者は**反映されたパラメータを含む最終的なPOSTリクエスト**を含むペイロードを送信し、大きなContent-Lengthを指定します。

![](<../images/image (1053).png>)

次に、**最初のリクエスト**（青）が**処理され**、**スリーピーな**リクエストが処理されている間（黄色）、**被害者から到着する次のリクエスト**が**反映されたパラメータの直後にキューに追加されます**：

![](<../images/image (794).png>)

その後、**被害者**は**スリーピーな**リクエストの**レスポンスを受け取り**、その間に**攻撃者が別のリクエストを送信した場合**、**反映されたコンテンツリクエストからのレスポンスが攻撃者に送信されます**。

## レスポンスの非同期化

ここまでで、HTTPリクエストスムージング攻撃を悪用して、**クライアントが受け取るレスポンスを制御する**方法と、**被害者のために意図されたレスポンスを盗む**方法を学びました。

しかし、レスポンスを**さらに非同期化する**ことも可能です。

**HEAD**リクエストのような興味深いリクエストがあり、これは**レスポンスボディ内にコンテンツを持たないことが指定されており**、**GETリクエストのようにContent-Lengthを含む必要があります**。

したがって、攻撃者が**HEAD**リクエストを**注入**すると、次のようになります：

![](<../images/image (1107).png>)

その後、**青いリクエストが攻撃者に応答されると**、次の被害者のリクエストがキューに追加されます：

![](<../images/image (999).png>)

その後、**被害者**は**HEAD**リクエストからの**レスポンスを受け取りますが、これは**Content-Lengthを含むがコンテンツは全く含まれない**ものになります。したがって、プロキシは**このレスポンスを被害者に送信せず、**何らかの**コンテンツ**を待つことになります。実際には、これは**攻撃者によって注入された黄色のリクエストへのレスポンス**になります：

![](<../images/image (735).png>)

### コンテンツの混乱

前の例に従い、**被害者が受け取るレスポンスのボディを制御できること**、および**HEAD**レスポンスが通常そのヘッダーに**Content-TypeとContent-Lengthを含むことを知っていると、次のようなリクエストを送信して**XSSを引き起こす**ことができます。これは、ページがXSSに対して脆弱でない場合でも：

![](<../images/image (688).png>)

### キャッシュの汚染

前述のレスポンス非同期化コンテンツ混乱攻撃を悪用すると、**キャッシュが被害者によって実行されたリクエストへのレスポンスを保存し、このレスポンスがXSSを引き起こす注入されたものであれば、キャッシュは汚染されます**。

XSSペイロードを含む悪意のあるリクエスト：

![](<../images/image (614).png>)

キャッシュにレスポンスを保存するように指示するヘッダーを含む被害者への悪意のあるレスポンス：

![](<../images/image (566).png>)

> [!WARNING]
> この場合、**「被害者」が攻撃者である場合、彼は今や**任意のURLでキャッシュ汚染を実行できる**。なぜなら、彼は悪意のあるレスポンスで**キャッシュされるURLを制御できるからです**。

### ウェブキャッシュの欺瞞

この攻撃は前の攻撃に似ていますが、**ペイロードをキャッシュ内に注入するのではなく、攻撃者が被害者の情報をキャッシュ内に保存します**：

![](<../images/image (991).png>)

### レスポンスの分割

この攻撃の**目的**は、再び**レスポンスの非同期化**を悪用して、**プロキシが100%攻撃者生成のレスポンスを送信させる**ことです。

これを達成するために、攻撃者は**レスポンス内にいくつかの値を反映している**ウェブアプリケーションのエンドポイントを見つけ、**HEADレスポンスのコンテンツ長を知る必要があります**。

彼は次のような**エクスプロイト**を送信します：

![](<../images/image (911).png>)

最初のリクエストが解決され、攻撃者に返されると、**被害者のリクエストがキューに追加されます**：

![](<../images/image (737).png>)

被害者は、**HEADレスポンス + 2番目のリクエストレスポンスのコンテンツ（反映されたデータの一部を含む）**をレスポンスとして受け取ります：

![](<../images/image (356).png>)

ただし、**反映されたデータがHEADレスポンスのContent-Lengthに応じたサイズを持っていたため、**レスポンスキュー内で有効なHTTPレスポンスを生成しました**。

したがって、**2番目の被害者の次のリクエストは、**攻撃者によって完全に作成されたものを**レスポンスとして受け取ります**。レスポンスが攻撃者によって完全に作成されているため、攻撃者は**プロキシにレスポンスをキャッシュさせることもできます**。

{{#include ../banners/hacktricks-training.md}}
