# Integer Overflow (Webanwendungen)

{{#include ../../banners/hacktricks-training.md}}

> Diese Seite konzentriert sich darauf, wie **Integer-Überläufe/Trunkierungen in Webanwendungen und Browsern ausgenutzt werden können**. Für Exploitation-Primitiven in nativen Binaries können Sie die spezielle Seite weiterlesen:
>
>
{{#ref}}
> ../../binary-exploitation/integer-overflow.md
> {{#endref}}

---

## 1. Warum Integer-Mathematik im Web weiterhin wichtig ist

Obwohl die meisten Geschäftslogiken in modernen Stacks in *speichersicheren* Sprachen geschrieben sind, wird die zugrunde liegende Laufzeit (oder Drittanbieterbibliotheken) letztendlich in C/C++ implementiert. Immer wenn benutzerkontrollierte Zahlen verwendet werden, um Puffer zuzuweisen, Offsets zu berechnen oder Längenprüfungen durchzuführen, **kann ein 32-Bit- oder 64-Bit-Überlauf einen scheinbar harmlosen Parameter in einen Out-of-Bounds-Lese-/Schreibzugriff, einen Logik-Bypass oder einen DoS verwandeln**.

Typische Angriffsfläche:

1. **Numerische Anfrageparameter** – klassische ID-, Offset- oder Zählfelder.
2. **Längen-/Größen-Header** – Content-Length, WebSocket-Rahmenlänge, HTTP/2 continuation_len usw.
3. **Dateiformat-Metadaten, die serverseitig oder clientseitig geparst werden** – Bilddimensionen, Chunk-Größen, Schriftarttabellen.
4. **Sprachebene-Konvertierungen** – signed↔unsigned-Casts in PHP/Go/Rust FFI, JS Number → int32-Trunkierungen innerhalb von V8.
5. **Authentifizierung & Geschäftslogik** – Gutscheinwert, Preis oder Kontoberechnungen, die stillschweigend überlaufen.

---

## 2. Aktuelle reale Schwachstellen (2023-2025)

| Jahr | Komponente | Grundursache | Auswirkungen |
|------|-----------|-----------|--------|
| 2023 | **libwebp – CVE-2023-4863** | 32-Bit-Multiplikationsüberlauf bei der Berechnung der dekodierten Pixelgröße | Auslöser eines Chrome 0-Day (BLASTPASS auf iOS), ermöglichte *Remote Code Execution* im Renderer-Sandbox.  |
| 2024 | **V8 – CVE-2024-0519** | Trunkierung auf 32-Bit beim Vergrößern eines JSArray führt zu OOB-Schreibzugriff auf den Backing Store | Remote Code Execution nach einem einzigen Besuch.  |
| 2025 | **Apollo GraphQL Server** (nicht veröffentlichter Patch) | 32-Bit-signierter Integer für erste/letzte Paginierungsargumente; negative Werte überlaufen zu riesigen positiven Werten | Logik-Bypass & Speicherauslastung (DoS). |

---

## 3. Teststrategie

### 3.1 Grenzwert-Checkliste

Senden Sie **extreme signed/unsigned Werte**, wo immer ein Integer erwartet wird:
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
Andere nützliche Formate:
* Hex (0x100), oktal (0377), wissenschaftlich (1e10), JSON big-int (9999999999999999999).
* Sehr lange Ziffernfolgen (>1kB), um benutzerdefinierte Parser zu treffen.

### 3.2 Burp Intruder-Vorlage
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 Fuzzing-Bibliotheken & Laufzeiten

* **AFL++/Honggfuzz** mit libFuzzer-Harness um den Parser (z.B. WebP, PNG, protobuf).
* **Fuzzilli** – grammatikbewusstes Fuzzing von JavaScript-Engines, um V8/JSC-Ganzzahltrunkierungen zu treffen.
* **boofuzz** – Fuzzing von Netzwerkprotokollen (WebSocket, HTTP/2) mit Fokus auf Längenfelder.

---

## 4. Ausnutzungsmuster

### 4.1 Logik-Umgehung im serverseitigen Code (PHP-Beispiel)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 Heap-Überlauf über Bilddecoder (libwebp 0-Day)
Der verlustfreie WebP-Decoder multiplizierte die Bildbreite × Höhe × 4 (RGBA) innerhalb eines 32-Bit-Ints. Eine manipulierte Datei mit den Abmessungen 16384 × 16384 überläuft die Multiplikation, allokiert einen kurzen Puffer und schreibt anschließend **~1GB** an dekomprimierten Daten über den Heap – was zu RCE in jedem Chromium-basierten Browser vor 116.0.5845.187 führt.

### 4.3 Browser-basiertes XSS/RCE-Ketten
1. **Integer-Überlauf** in V8 ermöglicht beliebiges Lesen/Schreiben.
2. Umgehen Sie den Sandbox mit einem zweiten Fehler oder rufen Sie native APIs auf, um ein Payload abzulegen.
3. Das Payload injiziert dann ein bösartiges Skript in den Ursprungs-Kontext → gespeichertes XSS.

---

## 5. Verteidigungshinweise

1. **Verwenden Sie breite Typen oder geprüfte Mathematik** – z.B. size_t, Rust checked_add, Go math/bits.Add64.
2. **Validieren Sie Bereiche frühzeitig**: lehnen Sie jeden Wert außerhalb des Geschäftsfelds vor der Arithmetik ab.
3. **Aktivieren Sie Compiler-Sanitizer**: -fsanitize=integer, UBSan, Go-Race-Detektor.
4. **Führen Sie Fuzzing in CI/CD ein** – kombinieren Sie Abdeckungsfeedback mit Grenzkorpora.
5. **Bleiben Sie gepatcht** – Browser-Integer-Überlauf-Bugs werden häufig innerhalb von Wochen ausgenutzt.

---

## Referenzen

* [NVD CVE-2023-4863 – libwebp Heap Buffer Overflow](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Understanding V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
