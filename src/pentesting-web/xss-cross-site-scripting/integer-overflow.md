# Integer Overflow (Web Applications)

{{#include ../../banners/hacktricks-training.md}}

> Diese Seite konzentriert sich darauf, wie **integer overflows/truncations in Webanwendungen und Browsern missbraucht werden können**. Für exploitation primitives innerhalb nativer Binaries kannst du die dedizierte Seite weiterlesen:
>
>
{{#ref}}
> ../../binary-exploitation/integer-overflow-and-underflow.md
> {{#endref}}

---

## 1. Why integer math still matters on the web

Auch wenn die meiste Business-Logic in modernen Stacks in *memory-safe* Sprachen geschrieben ist, wird die zugrundeliegende Laufzeit (oder Drittanbieter-Bibliotheken) letztlich in C/C++ implementiert. Wann immer benutzerkontrollierte Zahlen zum Allokieren von Buffern, Berechnen von Offsets oder zur Längenprüfung verwendet werden, kann **ein 32-Bit- oder 64-Bit-Wrap-around einen scheinbar harmlosen Parameter in einen Out-of-Bounds-Lese-/Schreibzugriff, eine Logik-Umgehung oder einen DoS verwandeln**.

Typische Angriffsflächen:

1. **Numeric request parameters** – klassische id-, offset- oder count-Felder.
2. **Length / size headers** – Content-Length, WebSocket frame length, HTTP/2 continuation_len, etc.
3. **File-format metadata parsed server-side or client-side** – Bilddimensionen, Chunk-Größen, Font-Tabellen.
4. **Language-level conversions** – signed↔unsigned casts in PHP/Go/Rust FFI, JS Number → int32 truncations inside V8.
5. **Authentication & business logic** – coupon value, price, oder balance-Berechnungen, die still überlaufen.

---

## 2. Recent real-world vulnerabilities (2023-2025)

| Year | Component | Root cause | Impact |
|------|-----------|-----------|--------|
| 2023 | **libwebp – CVE-2023-4863** | 32-bit multiplication overflow when computing decoded pixel size | Triggered a Chrome 0-day (BLASTPASS on iOS), allowed *remote code execution* inside the renderer sandbox.  |
| 2024 | **V8 – CVE-2024-0519** | Truncation to 32-bit when growing a JSArray leads to OOB write on the backing store | Remote code execution after a single visit.  |
| 2025 | **Apollo GraphQL Server** (unreleased patch) | 32-bit signed integer used for first/last pagination args; negative values wrap to huge positives | Logik-Umgehung & Speicherauslastung (DoS). |

---

## 3. Testing strategy

### 3.1 Boundary-value cheat-sheet

Sende **extreme signed/unsigned values** überall dort, wo eine Integer erwartet wird:
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
Weitere nützliche Formate:
* Hex (0x100), octal (0377), scientific (1e10), JSON big-int (9999999999999999999).
* Sehr lange Ziffernfolgen (>1kB), um benutzerdefinierte Parser auszulösen.

### 3.2 Burp Intruder-Vorlage
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 Fuzzing-Bibliotheken & Laufzeitumgebungen

* **AFL++/Honggfuzz** mit libFuzzer-Harness rund um den Parser (z. B. WebP, PNG, protobuf).
* **Fuzzilli** – grammatikbasiertes fuzzing von JavaScript-Engines, um Integer-Abschneidungen in V8/JSC auszulösen.
* **boofuzz** – fuzzing von Netzwerkprotokollen (WebSocket, HTTP/2) mit Fokus auf Längenfelder.

---

## 4. Exploitation patterns

### 4.1 Logic bypass in server-side code (PHP example)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 Heap overflow via image decoder (libwebp 0-day)
Der WebP lossless-Decoder multiplizierte Bildbreite × Bildhöhe × 4 (RGBA) innerhalb eines 32-Bit-Ints. Eine manipulierte Datei mit den Abmessungen 16384 × 16384 überläuft die Multiplikation, allokiert einen zu kurzen Puffer und schreibt anschließend **~1GB** dekomprimierter Daten über das Heap hinaus – was zu RCE in jedem Chromium-basierten Browser vor 116.0.5845.187 führt.

### 4.3 Browser-basierte XSS/RCE chain
1. **Integer overflow** in V8 ermöglicht arbitrary read/write.
2. Escape the sandbox mit einem zweiten bug oder rufe native APIs auf, um eine payload abzulegen.
3. Die payload injiziert dann ein bösartiges Script in den origin context → stored XSS.

---

## 5. Verteidigungsrichtlinien

1. **Breitere Typen oder checked math verwenden** – z. B. size_t, Rust checked_add, Go math/bits.Add64.
2. **Bereiche frühzeitig validieren**: Werte außerhalb des Business-Domain vor arithmetischen Operationen ablehnen.
3. **Compiler-Sanitizer aktivieren**: -fsanitize=integer, UBSan, Go race detector.
4. **Fuzzing in CI/CD integrieren** – Coverage-Feedback mit Boundary-Corpora kombinieren.
5. **Auf dem aktuellen Stand bleiben** – Browser-Integer-Overflow-Bugs werden häufig innerhalb weniger Wochen ausgenutzt.

---



## Referenzen

* [NVD CVE-2023-4863 – libwebp Heap Buffer Overflow](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Understanding V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
