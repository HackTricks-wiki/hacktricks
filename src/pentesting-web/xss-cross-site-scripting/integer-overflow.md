# Overflow di Interi (Applicazioni Web)

{{#include ../../banners/hacktricks-training.md}}

> Questa pagina si concentra su come **gli overflow/troncamenti di interi possono essere abusati nelle applicazioni web e nei browser**. Per le primitive di sfruttamento all'interno di binari nativi puoi continuare a leggere la pagina dedicata:
>
> {{#ref}}
> ../../binary-exploitation/integer-overflow.md
> {{#endref}}

---

## 1. Perché la matematica intera è ancora importante sul web

Anche se la maggior parte della logica aziendale negli stack moderni è scritta in linguaggi *sicuri per la memoria*, il runtime sottostante (o le librerie di terze parti) è infine implementato in C/C++. Ogni volta che numeri controllati dall'utente vengono utilizzati per allocare buffer, calcolare offset o eseguire controlli di lunghezza, **un wrap-around a 32 bit o 64 bit può trasformare un parametro apparentemente innocuo in una lettura/scrittura fuori dai limiti, un bypass logico o un DoS**.

Superficie di attacco tipica:

1. **Parametri di richiesta numerici** – classici campi `id`, `offset` o `count`.
2. **Intestazioni di lunghezza / dimensione** – `Content-Length`, lunghezza del frame WebSocket, `continuation_len` HTTP/2, ecc.
3. **Metadati del formato file analizzati lato server o lato client** – dimensioni delle immagini, dimensioni dei chunk, tabelle dei caratteri.
4. **Conversioni a livello di linguaggio** – cast signed↔unsigned in PHP/Go/Rust FFI, troncamenti `Number` → `int32` all'interno di V8.
5. **Autenticazione e logica aziendale** – valore del coupon, prezzo o calcoli di saldo che traboccano silenziosamente.

---

## 2. Vulnerabilità recenti nel mondo reale (2023-2025)

| Anno | Componente | Causa principale | Impatto |
|------|-----------|----------------|--------|
| 2023 | **libwebp – CVE-2023-4863** | Overflow di moltiplicazione a 32 bit durante il calcolo della dimensione dei pixel decodificati | Ha attivato un 0-day di Chrome (`BLASTPASS` su iOS), consentendo *l'esecuzione di codice remoto* all'interno della sandbox del renderer.  |
| 2024 | **V8 – CVE-2024-0519** | Troncamento a 32 bit durante l'espansione di un `JSArray` porta a una scrittura OOB sullo store di supporto | Esecuzione di codice remoto dopo una singola visita.  |
| 2025 | **Apollo GraphQL Server** (patch non rilasciata) | Intero firmato a 32 bit utilizzato per gli argomenti di paginazione `first/last`; valori negativi si avvolgono in enormi positivi | Bypass logico e esaurimento della memoria (DoS). |

---

## 3. Strategia di test

### 3.1 Scheda di riferimento per i valori limite

Invia **valori estremi signed/unsigned** ovunque sia previsto un intero:
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
Altri formati utili:
* Esadecimale (`0x100`), ottale (`0377`), scientifico (`1e10`), JSON big-int (`9999999999999999999`).
* Stringhe di cifre molto lunghe (>1kB) per colpire parser personalizzati.

### 3.2 Modello Burp Intruder
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 Fuzzing librerie e runtime

* **AFL++/Honggfuzz** con `libFuzzer` harness attorno al parser (ad es., WebP, PNG, protobuf).
* **Fuzzilli** – fuzzing consapevole della grammatica dei motori JavaScript per colpire le troncature degli interi V8/JSC.
* **boofuzz** – fuzzing dei protocolli di rete (WebSocket, HTTP/2) con focus sui campi di lunghezza.

---

## 4. Modelli di sfruttamento

### 4.1 Bypass logico nel codice lato server (esempio PHP)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 Overflow dello heap tramite decoder di immagini (libwebp 0-day)
Il decoder lossless WebP moltiplica la larghezza × altezza × 4 (RGBA) all'interno di un `int` a 32 bit. Un file creato con dimensioni `16384 × 16384` provoca un overflow della moltiplicazione, alloca un buffer corto e successivamente scrive **~1GB** di dati decompressi oltre l'heap – portando a RCE in ogni browser basato su Chromium prima della versione 116.0.5845.187.

### 4.3 Catena XSS/RCE basata su browser
1. **Overflow intero** in V8 consente lettura/scrittura arbitraria.
2. Esci dalla sandbox con un secondo bug o chiama API native per rilasciare un payload.
3. Il payload inietta quindi uno script malevolo nel contesto di origine → XSS memorizzato.

---

## 5. Linee guida difensive

1. **Usa tipi ampi o matematica controllata** – ad esempio, `size_t`, Rust `checked_add`, Go `math/bits.Add64`.
2. **Valida i range precocemente**: rifiuta qualsiasi valore al di fuori del dominio aziendale prima dell'aritmetica.
3. **Abilita i sanitizzatori del compilatore**: `-fsanitize=integer`, UBSan, rilevatore di race di Go.
4. **Adotta il fuzzing in CI/CD** – combina il feedback di copertura con i corpus di confine.
5. **Rimani aggiornato** – i bug di overflow intero nei browser vengono frequentemente sfruttati entro poche settimane.

---

## Riferimenti

* [NVD CVE-2023-4863 – Overflow del buffer heap di libwebp](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Understanding V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
