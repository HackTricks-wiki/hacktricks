# Integer Overflow (Web Applications)

{{#include ../../banners/hacktricks-training.md}}

> Cette page se concentre sur la façon dont les **integer overflows/truncations peuvent être abusés dans les web applications et les navigateurs**. Pour les primitives d'exploitation à l'intérieur de binaires natifs, vous pouvez consulter la page dédiée :
>
>
{{#ref}}
> ../../binary-exploitation/integer-overflow-and-underflow.md
> {{#endref}}

---

## 1. Pourquoi les calculs sur entiers sont encore importants sur le web

Même si la plupart de la business-logic dans les stacks modernes est écrite en langages *memory-safe*, le runtime sous-jacent (ou des bibliothèques tierces) est finalement implémenté en C/C++. Dès que des nombres contrôlés par l'utilisateur sont utilisés pour allouer des buffers, calculer des offsets ou effectuer des vérifications de longueur, **un wrap-around 32-bit ou 64-bit peut transformer un paramètre apparemment inoffensif en un out-of-bounds read/write, un logic bypass ou un DoS**.

Surface d'attaque typique :

1. **Numeric request parameters** – champs classiques id, offset, ou count.
2. **Length / size headers** – Content-Length, WebSocket frame length, HTTP/2 continuation_len, etc.
3. **File-format metadata parsed server-side or client-side** – dimensions d'image, tailles de chunks, font tables.
4. **Language-level conversions** – casts signé↔unsigned dans PHP/Go/Rust FFI, JS Number → int32 truncations inside V8.
5. **Authentication & business logic** – valeur de coupon, prix, ou calculs de solde qui overflow silencieusement.

---

## 2. Recent real-world vulnerabilities (2023-2025)

| Year | Component | Root cause | Impact |
|------|-----------|-----------|--------|
| 2023 | **libwebp – CVE-2023-4863** | 32-bit multiplication overflow when computing decoded pixel size | Triggered a Chrome 0-day (BLASTPASS on iOS), allowed *remote code execution* inside the renderer sandbox.  |
| 2024 | **V8 – CVE-2024-0519** | Truncation to 32-bit when growing a JSArray leads to OOB write on the backing store | Remote code execution after a single visit.  |
| 2025 | **Apollo GraphQL Server** (unreleased patch) | 32-bit signed integer used for first/last pagination args; negative values wrap to huge positives | Logic bypass & memory exhaustion (DoS). |

---

## 3. Testing strategy

### 3.1 Boundary-value cheat-sheet

Send **extreme signed/unsigned values** wherever an integer is expected:
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
Autres formats utiles :
* Hex (0x100), octal (0377), scientific (1e10), JSON big-int (9999999999999999999).
* Chaînes de chiffres très longues (>1kB) pour cibler custom parsers.

### 3.2 Modèle Burp Intruder template
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 Fuzzing libraries & runtimes

* **AFL++/Honggfuzz** avec un harness libFuzzer autour du parser (par ex., WebP, PNG, protobuf).
* **Fuzzilli** – fuzzing sensible à la grammaire des moteurs JavaScript pour provoquer des troncatures d'entiers dans V8/JSC.
* **boofuzz** – fuzzing de protocoles réseau (WebSocket, HTTP/2) axé sur les champs de longueur.

---

## 4. Modèles d'exploitation

### 4.1 Contournement logique dans le code côté serveur (exemple PHP)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 Débordement du heap via le décodeur d'images (libwebp 0-day)
Le décodeur sans perte WebP multipliait la largeur × hauteur × 4 (RGBA) dans un int 32 bits. Un fichier conçu avec des dimensions 16384 × 16384 provoque un dépassement de la multiplication, alloue un buffer trop court et écrit ensuite **~1GB** de données décompressées au-delà du heap – entraînant RCE dans tous les navigateurs basés sur Chromium antérieurs à 116.0.5845.187.

### 4.3 Chaîne XSS/RCE côté navigateur
1. **Integer overflow** in V8 gives arbitrary read/write.
2. S'échapper du sandbox avec un second bug ou appeler des API natives pour déposer un payload.
3. Le payload injecte alors un script malveillant dans le contexte d'origine → stored XSS.

---

## 5. Directives défensives

1. **Utiliser des types plus larges ou des opérations arithmétiques vérifiées** – e.g., size_t, Rust checked_add, Go math/bits.Add64.
2. **Valider les plages tôt** : rejeter toute valeur en dehors du domaine métier avant les opérations arithmétiques.
3. **Activer les sanitizers du compilateur** : -fsanitize=integer, UBSan, Go race detector.
4. **Adopter le fuzzing dans CI/CD** – combiner le feedback de couverture avec des corpus de cas limites.
5. **Restez à jour** – les bugs d'integer overflow dans les navigateurs sont fréquemment exploités en quelques semaines.

---



## References

* [NVD CVE-2023-4863 – libwebp Heap Buffer Overflow](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Understanding V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
