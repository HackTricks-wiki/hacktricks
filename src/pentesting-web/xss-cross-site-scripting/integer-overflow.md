# Débordement d'entier (Applications Web)

{{#include ../../banners/hacktricks-training.md}}

> Cette page se concentre sur la façon dont **les débordements/tronquations d'entiers peuvent être abusés dans les applications web et les navigateurs**. Pour les primitives d'exploitation à l'intérieur des binaires natifs, vous pouvez continuer à lire la page dédiée :
>
>
{{#ref}}
> ../../binary-exploitation/integer-overflow.md
> {{#endref}}

---

## 1. Pourquoi les mathématiques entières comptent encore sur le web

Bien que la plupart de la logique métier dans les piles modernes soit écrite dans des langages *sûrs pour la mémoire*, le runtime sous-jacent (ou les bibliothèques tierces) est finalement implémenté en C/C++. Chaque fois que des nombres contrôlés par l'utilisateur sont utilisés pour allouer des tampons, calculer des décalages ou effectuer des vérifications de longueur, **un débordement de 32 bits ou 64 bits peut transformer un paramètre apparemment inoffensif en une lecture/écriture hors limites, un contournement de logique ou un DoS**.

Surface d'attaque typique :

1. **Paramètres de requête numériques** – champs classiques d'id, de décalage ou de compte.
2. **En-têtes de longueur / taille** – Content-Length, longueur de trame WebSocket, HTTP/2 continuation_len, etc.
3. **Métadonnées de format de fichier analysées côté serveur ou côté client** – dimensions d'image, tailles de morceaux, tables de polices.
4. **Conversions au niveau du langage** – conversions signées↔non signées dans PHP/Go/Rust FFI, tronquations JS Number → int32 à l'intérieur de V8.
5. **Authentification & logique métier** – valeur de coupon, prix ou calculs de solde qui débordent silencieusement.

---

## 2. Vulnérabilités récentes dans le monde réel (2023-2025)

| Année | Composant | Cause racine | Impact |
|------|-----------|-----------|--------|
| 2023 | **libwebp – CVE-2023-4863** | Débordement de multiplication 32 bits lors du calcul de la taille des pixels décodés | A déclenché un 0-day Chrome (BLASTPASS sur iOS), permettant *l'exécution de code à distance* à l'intérieur du bac à sable du rendu.  |
| 2024 | **V8 – CVE-2024-0519** | Tronquation à 32 bits lors de l'augmentation d'un JSArray entraînant une écriture OOB sur le magasin de soutien | Exécution de code à distance après une seule visite.  |
| 2025 | **Apollo GraphQL Server** (patch non publié) | Entier signé 32 bits utilisé pour les arguments de pagination premier/dernier ; les valeurs négatives débordent vers de grands positifs | Contournement de logique & épuisement de mémoire (DoS). |

---

## 3. Stratégie de test

### 3.1 Feuille de triche sur les valeurs limites

Envoyez **des valeurs signées/non signées extrêmes** partout où un entier est attendu :
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
Autres formats utiles :
* Hex (0x100), octal (0377), scientifique (1e10), JSON big-int (9999999999999999999).
* Chaînes de chiffres très longues (>1kB) pour atteindre des analyseurs personnalisés.

### 3.2 Modèle Burp Intruder
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 Bibliothèques et environnements de fuzzing

* **AFL++/Honggfuzz** avec un harness libFuzzer autour du parseur (par exemple, WebP, PNG, protobuf).
* **Fuzzilli** – fuzzing conscient de la grammaire des moteurs JavaScript pour toucher les troncatures d'entiers V8/JSC.
* **boofuzz** – fuzzing de protocoles réseau (WebSocket, HTTP/2) se concentrant sur les champs de longueur.

---

## 4. Modèles d'exploitation

### 4.1 Contournement de logique dans le code côté serveur (exemple PHP)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 Débordement de tas via le décodeur d'image (libwebp 0-day)
Le décodeur sans perte WebP a multiplié la largeur × hauteur × 4 (RGBA) à l'intérieur d'un int 32 bits. Un fichier conçu avec des dimensions 16384 × 16384 déborde la multiplication, alloue un court tampon et écrit ensuite **~1 Go** de données décompressées au-delà du tas – menant à un RCE dans tous les navigateurs basés sur Chromium avant 116.0.5845.187.

### 4.3 Chaîne XSS/RCE basée sur le navigateur
1. **Débordement d'entier** dans V8 donne une lecture/écriture arbitraire.
2. Échapper au bac à sable avec un second bug ou appeler des API natives pour déposer un payload.
3. Le payload injecte ensuite un script malveillant dans le contexte d'origine → XSS stocké.

---

## 5. Directives de défense

1. **Utilisez des types larges ou des mathématiques vérifiées** – par exemple, size_t, Rust checked_add, Go math/bits.Add64.
2. **Validez les plages tôt** : rejetez toute valeur en dehors du domaine commercial avant l'arithmétique.
3. **Activez les sanitizers du compilateur** : -fsanitize=integer, UBSan, détecteur de course Go.
4. **Adoptez le fuzzing dans CI/CD** – combinez les retours de couverture avec des corpus de limites.
5. **Restez à jour** – les bugs de débordement d'entier dans les navigateurs sont souvent exploités dans les semaines qui suivent.

---

## Références

* [NVD CVE-2023-4863 – Débordement de tampon de tas libwebp](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Comprendre V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
