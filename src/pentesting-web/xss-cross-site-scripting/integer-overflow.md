# Integer Overflow (Web Applications)

{{#include ../../banners/hacktricks-training.md}}

> Questa pagina si concentra su come **integer overflows/truncations possono essere abusati nelle applicazioni web e nei browser**.  Per primitive di sfruttamento all'interno di binari nativi puoi continuare a leggere la pagina dedicata:
>
>
{{#ref}}
> ../../binary-exploitation/integer-overflow-and-underflow.md
> {{#endref}}

---

## 1. Perché la matematica degli interi è ancora importante sul web

Anche se la maggior parte della business-logic negli stack moderni è scritta in *memory-safe* languages, il runtime sottostante (o le librerie di terze parti) è alla fine implementato in C/C++.  Quando numeri controllati dall'utente vengono usati per allocare buffer, calcolare offset o eseguire controlli di lunghezza, **un wrap-around a 32-bit o 64-bit può trasformare un parametro apparentemente innocuo in una out-of-bounds read/write, un bypass logico o un DoS**.

Superfici di attacco tipiche:

1. **Numeric request parameters** – classici campi id, offset o count.
2. **Length / size headers** – Content-Length, WebSocket frame length, HTTP/2 continuation_len, ecc.
3. **File-format metadata parsed server-side or client-side** – dimensioni delle immagini, dimensioni dei chunk, tabelle dei font.
4. **Language-level conversions** – cast signed↔unsigned in PHP/Go/Rust FFI, JS Number → int32 truncations inside V8.
5. **Authentication & business logic** – valore del coupon, prezzo o calcoli del balance che overflowano silenziosamente.

---

## 2. Vulnerabilità reali recenti (2023-2025)

| Year | Component | Root cause | Impact |
|------|-----------|-----------|--------|
| 2023 | **libwebp – CVE-2023-4863** | 32-bit multiplication overflow when computing decoded pixel size | Ha innescato un Chrome 0-day (BLASTPASS on iOS), ha permesso *remote code execution* all'interno della renderer sandbox.  |
| 2024 | **V8 – CVE-2024-0519** | Troncamento a 32-bit quando si espande una JSArray porta a un OOB write sul backing store | Remote code execution dopo una singola visita.  |
| 2025 | **Apollo GraphQL Server** (unreleased patch) | 32-bit signed integer usato per gli argomenti first/last di paginazione; valori negativi si avvolgono in grandi valori positivi | Bypass logico e esaurimento di memoria (DoS). |

---

## 3. Strategia di testing

### 3.1 Cheat-sheet dei valori limite

Invia **valori estremi signed/unsigned** ovunque sia atteso un intero:
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
Altri formati utili:
* Hex (0x100), octal (0377), scientific (1e10), JSON big-int (9999999999999999999).
* Stringhe di cifre molto lunghe (>1kB) per mettere alla prova parser personalizzati.

### 3.2 Modello per Burp Intruder
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 Librerie & runtime per fuzzing

* **AFL++/Honggfuzz** con harness libFuzzer attorno al parser (ad esempio WebP, PNG, protobuf).
* **Fuzzilli** – fuzzing sensibile alla grammatica per motori JavaScript per provocare troncamenti degli integer in V8/JSC.
* **boofuzz** – fuzzing di protocolli di rete (WebSocket, HTTP/2) focalizzato sui campi di lunghezza.

---

## 4. Exploitation patterns

### 4.1 Logic bypass nel codice lato server (esempio PHP)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 Heap overflow via image decoder (libwebp 0-day)
Il WebP lossless decoder moltiplicava width × height × 4 (RGBA) all'interno di un 32-bit int. Un file appositamente creato con dimensioni 16384 × 16384 provoca l'overflow della moltiplicazione, alloca un buffer troppo corto e successivamente scrive **~1GB** di dati decompressi oltre il heap – portando a RCE in ogni Chromium-based browser prima della 116.0.5845.187.

### 4.3 Browser-based XSS/RCE chain
1. **Integer overflow** in V8 fornisce arbitrary read/write.
2. Escape the sandbox sfruttando un secondo bug oppure chiamando API native per depositare un payload.
3. Il payload inietta quindi uno script malevolo nel contesto di origine → stored XSS.

---

## 5. Linee guida difensive

1. **Use wide types or checked math** – ad es., size_t, Rust checked_add, Go math/bits.Add64.
2. **Validate ranges early**: rifiutare qualsiasi valore al di fuori del dominio applicativo prima di effettuare operazioni aritmetiche.
3. **Enable compiler sanitizers**: -fsanitize=integer, UBSan, Go race detector.
4. **Adopt fuzzing in CI/CD** – combinare il feedback di coverage con corpora di boundary.
5. **Stay patched** – i bug di integer overflow nei browser vengono spesso sfruttati nel giro di poche settimane.

---



## Riferimenti

* [NVD CVE-2023-4863 – libwebp Heap Buffer Overflow](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Understanding V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
