# Integer Overflow (Web Applications)

{{#include ../../banners/hacktricks-training.md}}

> Esta página foca em como **integer overflows/truncations can be abused in web applications and browsers**. Para exploitation primitives dentro de binários nativos você pode continuar lendo a página dedicada:
>
>
{{#ref}}
> ../../binary-exploitation/integer-overflow-and-underflow.md
> {{#endref}}

---

## 1. Por que a aritmética de inteiros ainda importa na web

Mesmo que a maior parte da business-logic em stacks modernos seja escrita em linguagens *memory-safe*, o runtime subjacente (ou bibliotecas de terceiros) acaba sendo implementado em C/C++. Sempre que números controlados pelo usuário são usados para alocar buffers, computar offsets ou realizar verificações de comprimento, **um wrap-around de 32-bit ou 64-bit pode transformar um parâmetro aparentemente inofensivo em uma leitura/escrita out-of-bounds, um bypass de lógica ou um DoS**.

Superfície de ataque típica:

1. **Numeric request parameters** – campos clássicos id, offset ou count.
2. **Length / size headers** – Content-Length, WebSocket frame length, HTTP/2 continuation_len, etc.
3. **File-format metadata parsed server-side or client-side** – dimensões de imagem, tamanhos de chunks, tabelas de fontes.
4. Conversões a nível de linguagem – signed↔unsigned casts in PHP/Go/Rust FFI, JS Number → int32 truncations inside V8.
5. **Authentication & business logic** – cálculos de valor de cupom, preço ou saldo que silenciosamente overflowam.

---

## 2. Vulnerabilidades reais recentes (2023-2025)

| Ano | Componente | Causa raiz | Impacto |
|------|-----------|-----------|--------|
| 2023 | **libwebp – CVE-2023-4863** | overflow em multiplicação 32-bit ao computar o tamanho de pixels decodificados | Acionou um 0-day no Chrome (BLASTPASS no iOS), permitindo *remote code execution* dentro do renderer sandbox. |
| 2024 | **V8 – CVE-2024-0519** | truncamento para 32-bit ao crescer um JSArray leva a OOB write no backing store | Remote code execution após uma única visita. |
| 2025 | **Apollo GraphQL Server** (patch não lançado) | inteiro signed de 32-bit usado para args first/last de paginação; valores negativos se dobram para enormes positivos | Bypass de lógica e exaustão de memória (DoS). |

---

## 3. Estratégia de teste

### 3.1 Folha de referência de valores-limite

Envie **valores extremos signed/unsigned** sempre que um inteiro for esperado:
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
Outros formatos úteis:
* Hex (0x100), octal (0377), scientific (1e10), JSON big-int (9999999999999999999).
* Strings de dígitos muito longas (>1kB) para atingir parsers personalizados.

### 3.2 Modelo do Burp Intruder
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 Fuzzing bibliotecas & runtimes

* **AFL++/Honggfuzz** com um harness libFuzzer em torno do parser (por exemplo, WebP, PNG, protobuf).
* **Fuzzilli** – fuzzing sensível à gramática de engines JavaScript para atingir truncamentos de inteiros em V8/JSC.
* **boofuzz** – fuzzing de protocolos de rede (WebSocket, HTTP/2) focado em campos de comprimento.

---

## 4. Exploitation patterns

### 4.1 Logic bypass in server-side code (exemplo em PHP)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 Heap overflow via image decoder (libwebp 0-day)
O decodificador sem perdas do WebP multiplicava largura × altura × 4 (RGBA) dentro de um 32-bit int. Um arquivo forjado com dimensões 16384 × 16384 causa overflow na multiplicação, aloca um buffer curto e em seguida escreve **~1GB** de dados descomprimidos além do heap – levando a RCE em todo browser Chromium-based antes da 116.0.5845.187.

### 4.3 Browser-based XSS/RCE chain
1. **Integer overflow** no V8 permite arbitrary read/write.
2. Escape the sandbox com um segundo bug ou chame native APIs para drop a payload.
3. O payload então injeta um script malicioso no origin context → stored XSS.

---

## 5. Diretrizes defensivas

1. **Use tipos de maior largura ou matemática checada** – e.g., size_t, Rust checked_add, Go math/bits.Add64.
2. **Valide intervalos cedo**: rejeite qualquer valor fora do domínio do negócio antes da aritmética.
3. **Habilite sanitizadores do compilador**: -fsanitize=integer, UBSan, Go race detector.
4. **Adote fuzzing no CI/CD** – combine feedback de cobertura com corpora de limites.
5. **Mantenha-se atualizado** – browser integer overflow bugs são frequentemente weaponised dentro de semanas.

---



## Referências

* [NVD CVE-2023-4863 – libwebp Heap Buffer Overflow](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Understanding V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
