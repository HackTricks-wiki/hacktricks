# Integer Overflow (Web Applications)

{{#include ../../banners/hacktricks-training.md}}

> このページは、**integer overflows/truncations can be abused in web applications and browsers** に焦点を当てています。ネイティブバイナリ内のエクスプロイトプリミティブについては専用ページを参照してください：
>
{{#ref}}
> ../../binary-exploitation/integer-overflow-and-underflow.md
> {{#endref}}

---

## 1. なぜ integer math がウェブで重要なのか

現代のスタックでは多くのビジネスロジックが *memory-safe* な言語で書かれているものの、基盤となるランタイム（またはサードパーティのライブラリ）は最終的に C/C++ で実装されています。ユーザー制御可能な数値がバッファの割当、オフセット計算、長さチェックに使われる場合、**a 32-bit or 64-bit wrap-around may transform an apparently harmless parameter into an out-of-bounds read/write, a logic bypass or a DoS**。

典型的な攻撃対象:

1. **Numeric request parameters** – 典型的な id、offset、count フィールド。
2. **Length / size headers** – Content-Length、WebSocket フレーム長、HTTP/2 の continuation_len など。
3. **File-format metadata parsed server-side or client-side** – 画像の寸法、チャンクサイズ、フォントテーブル。
4. **Language-level conversions** – PHP/Go/Rust の FFI における signed↔unsigned キャスト、V8 内での JS Number → int32 トランケーション。
5. **Authentication & business logic** – クーポン値、価格、残高計算がサイレントに overflow するケース。

---

## 2. 最近の実世界の脆弱性（2023-2025）

| 年 | コンポーネント | 根本原因 | 影響 |
|------|-----------|-----------|--------|
| 2023 | **libwebp – CVE-2023-4863** | デコード後のピクセルサイズを計算する際の 32-bit multiplication overflow | Chrome の 0-day を誘発（iOS 上の BLASTPASS）、レンダラサンドボックス内での *remote code execution* を許可。  |
| 2024 | **V8 – CVE-2024-0519** | JSArray を拡張する際の 32-bit への切り捨てが backing store での OOB write を引き起こす | 単一の訪問で Remote code execution。  |
| 2025 | **Apollo GraphQL Server** (unreleased patch) | first/last ページネーション引数に 32-bit signed integer を使用しており、負の値が巨大な正の値に wrap する | ロジックバイパスとメモリ枯渇（DoS）。 |

---

## 3. テスト戦略

### 3.1 境界値 チートシート

整数が期待される箇所には、**extreme signed/unsigned values** を送ってください：
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
その他の有用なフォーマット:
* Hex (0x100), octal (0377), scientific (1e10), JSON big-int (9999999999999999999).
* 非常に長い数字列（>1kB）でカスタムパーサに問題を起こさせる。

### 3.2 Burp Intruder template
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 Fuzzing ライブラリ & ランタイム

* **AFL++/Honggfuzz** を libFuzzer ハーネスでパーサ周辺に適用（例: WebP, PNG, protobuf）。
* **Fuzzilli** – JavaScript エンジンに対する文法対応のfuzzingで V8/JSC の整数切り捨てを狙う。
* **boofuzz** – ネットワークプロトコルのfuzzing（WebSocket, HTTP/2）で長さフィールドに注力。

---

## 4. Exploitation パターン

### 4.1 Logic bypass in サーバーサイドコード (PHP example)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 Heap overflow — 画像デコーダ経由 (libwebp 0-day)
WebP のロスレスデコーダは、画像の幅 × 高さ × 4 (RGBA) を 32 ビット int 内で乗算していました。細工された幅と高さ 16384 × 16384 のファイルはこの乗算でオーバーフローし、短いバッファを割り当てた後にヒープの先に **~1GB** の解凍データを書き込みます — これにより 116.0.5845.187 より前のすべての Chromium ベースのブラウザで RCE が発生します。

### 4.3 ブラウザベースの XSS/RCE チェーン
1. **Integer overflow** in V8 gives arbitrary read/write.
2. 別のバグで sandbox を脱出するか、native APIs を呼び出して payload を配置します。
3. payload はその後 origin context に悪意のあるスクリプトを注入し → stored XSS。

---

## 5. 防御ガイドライン

1. **Use wide types or checked math** – e.g., size_t, Rust checked_add, Go math/bits.Add64.
2. 早期に範囲を検証する：算術を行う前に業務ドメイン外の値は拒否すること。
3. コンパイラの sanitizers を有効にする： -fsanitize=integer, UBSan, Go race detector.
4. CI/CD に fuzzing を導入する – coverage feedback と boundary corpora を組み合わせる。
5. 最新のパッチを適用する – ブラウザの integer overflow バグは数週間以内に頻繁に悪用されます。

---

## References

* [NVD CVE-2023-4863 – libwebp Heap Buffer Overflow](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Understanding V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
