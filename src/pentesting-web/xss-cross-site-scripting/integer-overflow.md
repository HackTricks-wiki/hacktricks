# Integer Overflow (Web Applications)

{{#include ../../banners/hacktricks-training.md}}

> This page focuses on how **integer overflows/truncations can be abused in web applications and browsers**.  For exploitation primitives inside native binaries you can continue reading the dedicated page:
>
>
{{#ref}}
> ../../binary-exploitation/integer-overflow-and-underflow.md
> {{#endref}}

---

## 1. Why integer math still matters on the web

भले ही आधुनिक स्टैक्स में अधिकांश business-logic *memory-safe* भाषाओं में लिखा जाता है, underlying runtime (या third-party libraries) अंततः C/C++ में implement किया जाता है। जब भी user-controlled numbers का उपयोग buffers allocate करने, offsets compute करने, या length checks करने के लिए होता है, **एक 32-bit या 64-bit wrap-around एक दिखाई देने में harmless parameter को out-of-bounds read/write, logic bypass या DoS में बदल सकता है**।

Typical attack surface:

1. **Numeric request parameters** – पारंपरिक id, offset, या count fields।
2. **Length / size headers** – Content-Length, WebSocket frame length, HTTP/2 continuation_len, आदि।
3. **File-format metadata parsed server-side or client-side** – image dimensions, chunk sizes, font tables।
4. **Language-level conversions** – signed↔unsigned casts in PHP/Go/Rust FFI, JS Number → int32 truncations inside V8।
5. **Authentication & business logic** – coupon value, price, या balance calculations जो silently overflow हो सकते हैं।

---

## 2. Recent real-world vulnerabilities (2023-2025)

| Year | Component | Root cause | Impact |
|------|-----------|-----------|--------|
| 2023 | **libwebp – CVE-2023-4863** | 32-bit multiplication overflow when computing decoded pixel size | Triggered a Chrome 0-day (BLASTPASS on iOS), allowed *remote code execution* inside the renderer sandbox.  |
| 2024 | **V8 – CVE-2024-0519** | Truncation to 32-bit when growing a JSArray leads to OOB write on the backing store | Remote code execution after a single visit.  |
| 2025 | **Apollo GraphQL Server** (unreleased patch) | 32-bit signed integer used for first/last pagination args; negative values wrap to huge positives | Logic bypass & memory exhaustion (DoS). |

---

## 3. Testing strategy

### 3.1 Boundary-value cheat-sheet

Send **extreme signed/unsigned values** wherever an integer is expected:
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
अन्य उपयोगी प्रारूप:
* Hex (0x100), octal (0377), scientific (1e10), JSON big-int (9999999999999999999).
* बहुत लंबी अंक-श्रृंखलाएँ (>1kB) custom parsers को हिट करने के लिए।

### 3.2 Burp Intruder टेम्पलेट
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 Fuzzing लाइब्रेरी & रनटाइम

* **AFL++/Honggfuzz** libFuzzer harness के साथ parser के चारों ओर (उदा., WebP, PNG, protobuf).
* **Fuzzilli** – व्याकरण-सचेत fuzzing JavaScript engines पर V8/JSC के integer truncations को लक्षित करने के लिए.
* **boofuzz** – नेटवर्क-प्रोटोकॉल fuzzing (WebSocket, HTTP/2) जो लंबाई फ़ील्ड पर केंद्रित है.

---

## 4. Exploitation patterns

### 4.1 Logic bypass in server-side code (PHP example)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 Heap overflow via image decoder (libwebp 0-day)
WebP lossless decoder ने image width × height × 4 (RGBA) को एक 32-bit int के अंदर गुणा किया। 16384 × 16384 आयाम वाली एक crafted file इस गुणा को overflow कर देती है, एक छोटा buffer allocate करती है और उसके बाद heap के बाहर **~1GB** अनकंप्रेस्ड डेटा लिख देती है – जिससे 116.0.5845.187 से पहले के हर Chromium-based browser में RCE होता है।

### 4.3 ब्राउज़र-आधारित XSS/RCE श्रृंखला
1. **Integer overflow** in V8 gives arbitrary read/write.
2. Sandbox से बाहर निकलें दूसरे बग से या native APIs को कॉल करके payload को drop करने के लिए।
3. फिर payload एक malicious script को origin context में inject करता है → stored XSS.

---

## 5. रक्षा संबंधी दिशानिर्देश

1. **Use wide types or checked math** – उदाहरण के लिए size_t, Rust checked_add, Go math/bits.Add64.
2. **Validate ranges early**: arithmetic से पहले business domain के बाहर किसी भी मान को reject करें।
3. **Enable compiler sanitizers**: -fsanitize=integer, UBSan, Go race detector.
4. **Adopt fuzzing in CI/CD** – coverage feedback को boundary corpora के साथ combine करें।
5. **Stay patched** – browser integer overflow bugs अक्सर कुछ हफ्तों में weaponised हो जाते हैं।

---



## References

* [NVD CVE-2023-4863 – libwebp Heap Buffer Overflow](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Understanding V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
