# Overflow de Inteiro (Aplicações Web)

{{#include ../../banners/hacktricks-training.md}}

> Esta página foca em como **overflow/truncamentos de inteiros podem ser abusados em aplicações web e navegadores**. Para primitivas de exploração dentro de binários nativos, você pode continuar lendo a página dedicada:
>
>
{{#ref}}
> ../../binary-exploitation/integer-overflow.md
> {{#endref}}

---

## 1. Por que a matemática inteira ainda importa na web

Embora a maior parte da lógica de negócios em pilhas modernas seja escrita em *linguagens seguras em relação à memória*, o runtime subjacente (ou bibliotecas de terceiros) é eventualmente implementado em C/C++. Sempre que números controlados pelo usuário são usados para alocar buffers, calcular offsets ou realizar verificações de comprimento, **um wrap-around de 32 bits ou 64 bits pode transformar um parâmetro aparentemente inofensivo em uma leitura/escrita fora dos limites, um bypass de lógica ou um DoS**.

Superfície de ataque típica:

1. **Parâmetros de requisição numéricos** – campos clássicos de id, offset ou contagem.
2. **Cabeçalhos de comprimento/tamanho** – Content-Length, comprimento do quadro WebSocket, HTTP/2 continuation_len, etc.
3. **Metadados de formato de arquivo analisados no lado do servidor ou do cliente** – dimensões da imagem, tamanhos de chunks, tabelas de fontes.
4. **Conversões em nível de linguagem** – casts signed↔unsigned em PHP/Go/Rust FFI, truncamentos de JS Number → int32 dentro do V8.
5. **Autenticação e lógica de negócios** – valor de cupom, preço ou cálculos de saldo que transbordam silenciosamente.

---

## 2. Vulnerabilidades reais recentes (2023-2025)

| Ano | Componente | Causa raiz | Impacto |
|------|-----------|-----------|--------|
| 2023 | **libwebp – CVE-2023-4863** | Overflow de multiplicação de 32 bits ao calcular o tamanho do pixel decodificado | Acionou um 0-day do Chrome (BLASTPASS no iOS), permitiu *execução remota de código* dentro do sandbox do renderizador.  |
| 2024 | **V8 – CVE-2024-0519** | Truncamento para 32 bits ao aumentar um JSArray leva a escrita OOB no armazenamento de apoio | Execução remota de código após uma única visita.  |
| 2025 | **Apollo GraphQL Server** (patch não lançado) | Inteiro assinado de 32 bits usado para argumentos de paginação primeiro/último; valores negativos se transformam em enormes positivos | Bypass de lógica e exaustão de memória (DoS). |

---

## 3. Estratégia de teste

### 3.1 Folha de dicas de valores de limite

Envie **valores extremos assinados/não assinados** sempre que um inteiro for esperado:
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
Outros formatos úteis:
* Hex (0x100), octal (0377), científico (1e10), JSON big-int (9999999999999999999).
* Strings de dígitos muito longas (>1kB) para atingir analisadores personalizados.

### 3.2 Modelo do Burp Intruder
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 Bibliotecas e runtimes de Fuzzing

* **AFL++/Honggfuzz** com harness libFuzzer em torno do parser (por exemplo, WebP, PNG, protobuf).
* **Fuzzilli** – fuzzing ciente da gramática de motores JavaScript para atingir truncamentos de inteiros V8/JSC.
* **boofuzz** – fuzzing de protocolo de rede (WebSocket, HTTP/2) focando em campos de comprimento.

---

## 4. Padrões de Exploração

### 4.1 Bypass de lógica em código do lado do servidor (exemplo PHP)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 Overflow de heap via decodificador de imagem (libwebp 0-day)
O decodificador sem perdas WebP multiplicou a largura da imagem × altura × 4 (RGBA) dentro de um int de 32 bits. Um arquivo elaborado com dimensões 16384 × 16384 transborda a multiplicação, aloca um buffer curto e, subsequentemente, escreve **~1GB** de dados descompactados além do heap – levando a RCE em todos os navegadores baseados em Chromium antes da versão 116.0.5845.187.

### 4.3 Cadeia de XSS/RCE baseada em navegador
1. **Overflow de inteiro** no V8 permite leitura/escrita arbitrária.
2. Escape do sandbox com um segundo bug ou chame APIs nativas para soltar um payload.
3. O payload então injeta um script malicioso no contexto de origem → XSS armazenado.

---

## 5. Diretrizes defensivas

1. **Use tipos amplos ou matemática verificada** – por exemplo, size_t, Rust checked_add, Go math/bits.Add64.
2. **Valide intervalos cedo**: rejeite qualquer valor fora do domínio de negócios antes da aritmética.
3. **Ative sanitizadores do compilador**: -fsanitize=integer, UBSan, detector de corrida do Go.
4. **Adote fuzzing em CI/CD** – combine feedback de cobertura com corpora de limites.
5. **Mantenha-se atualizado** – bugs de overflow de inteiro em navegadores são frequentemente armados em semanas.

---

## Referências

* [NVD CVE-2023-4863 – libwebp Heap Buffer Overflow](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Understanding V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
