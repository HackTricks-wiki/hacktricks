# Цілочисельний переповнень (Веб-додатки)

{{#include ../../banners/hacktricks-training.md}}

> Ця сторінка зосереджена на тому, як **цілочисельні переповнення/обрізання можуть бути використані в веб-додатках і браузерах**. Для експлуатаційних примітивів всередині рідних бінарних файлів ви можете продовжити читати присвячену сторінку:
>
>
{{#ref}}
> ../../binary-exploitation/integer-overflow.md
> {{#endref}}

---

## 1. Чому цілочисельна математика все ще важлива в вебі

Навіть якщо більшість бізнес-логіки в сучасних стеку написано на *безпечних для пам'яті* мовах, підлягаюча середа виконання (або сторонні бібліотеки) врешті-решт реалізована на C/C++. Коли числа, контрольовані користувачем, використовуються для виділення буферів, обчислення зсувів або виконання перевірок довжини, **переповнення 32-бітного або 64-бітного типу може перетворити, здавалося б, безпечний параметр на читання/запис за межами допустимого, обхід логіки або DoS**.

Типова поверхня атаки:

1. **Числові параметри запиту** – класичні поля id, offset або count.
2. **Заголовки довжини/розміру** – Content-Length, довжина кадру WebSocket, HTTP/2 continuation_len тощо.
3. **Метадані формату файлу, що обробляються на стороні сервера або клієнта** – розміри зображень, розміри частин, таблиці шрифтів.
4. **Перетворення на рівні мови** – знакові↔незнакові перетворення в PHP/Go/Rust FFI, обрізання JS Number → int32 всередині V8.
5. **Аутентифікація та бізнес-логіка** – значення купонів, ціни або обчислення балансу, які тихо переповнюються.

---

## 2. Останні реальні вразливості (2023-2025)

| Рік | Компонент | Корінна причина | Вплив |
|------|-----------|-----------|--------|
| 2023 | **libwebp – CVE-2023-4863** | Переповнення множення 32-бітного типу при обчисленні розміру декодованого пікселя | Викликало 0-day у Chrome (BLASTPASS на iOS), дозволило *віддалене виконання коду* всередині пісочниці рендерера.  |
| 2024 | **V8 – CVE-2024-0519** | Обрізання до 32-бітного типу при збільшенні JSArray призводить до запису за межами допустимого на резервному сховищі | Віддалене виконання коду після одного відвідування.  |
| 2025 | **Apollo GraphQL Server** (неопублікований патч) | Використання 32-бітного знакового цілого числа для аргументів пагінації first/last; негативні значення переповнюються до величезних позитивних | Обхід логіки та виснаження пам'яті (DoS). |

---

## 3. Стратегія тестування

### 3.1 Чек-лист граничних значень

Надсилайте **екстремальні знакові/незнакові значення** скрізь, де очікується ціле число:
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
Інші корисні формати:
* Hex (0x100), восьмковий (0377), науковий (1e10), JSON big-int (9999999999999999999).
* Дуже довгі рядки цифр (>1kB) для впливу на власні парсери.

### 3.2 Шаблон Burp Intruder
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 Fuzzing бібліотеки та середовища виконання

* **AFL++/Honggfuzz** з libFuzzer обгорткою навколо парсера (наприклад, WebP, PNG, protobuf).
* **Fuzzilli** – граматично обізнаний фуззинг JavaScript-движків для виявлення обрізання цілих чисел у V8/JSC.
* **boofuzz** – фуззинг мережевих протоколів (WebSocket, HTTP/2), зосереджений на полях довжини.

---

## 4. Шаблони експлуатації

### 4.1 Обхід логіки в серверному коді (приклад PHP)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 Переповнення купи через декодер зображень (libwebp 0-day)
Декодер WebP без втрат множить ширину зображення × висота × 4 (RGBA) всередині 32-бітного цілого числа. Створений файл з розмірами 16384 × 16384 переповнює множення, виділяє короткий буфер і, в результаті, записує **~1GB** декомпресованих даних за межі купи – що призводить до RCE в кожному браузері на базі Chromium до версії 116.0.5845.187.

### 4.3 Ланцюг XSS/RCE на основі браузера
1. **Переповнення цілого числа** в V8 дає довільний читання/запис.
2. Вийти з пісочниці за допомогою другого багу або викликати нативні API для скидання корисного навантаження.
3. Корисне навантаження потім впроваджує шкідливий скрипт у контекст походження → збережене XSS.

---

## 5. Захисні рекомендації

1. **Використовуйте широкі типи або перевірену математику** – наприклад, size_t, Rust checked_add, Go math/bits.Add64.
2. **Раннє перевірка діапазонів**: відхиляйте будь-яке значення поза межами бізнес-домену перед арифметикою.
3. **Увімкніть санітайзери компілятора**: -fsanitize=integer, UBSan, Go race detector.
4. **Прийміть фуззинг у CI/CD** – поєднайте зворотний зв'язок з покриттям з граничними корпусами.
5. **Залишайтеся з патчами** – помилки переповнення цілого числа в браузерах часто використовуються в зброї протягом кількох тижнів.

---

## Посилання

* [NVD CVE-2023-4863 – переповнення буфера купи libwebp](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Розуміння V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
