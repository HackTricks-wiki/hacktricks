# 整数溢出（Web 应用）

{{#include ../../banners/hacktricks-training.md}}

> 本页侧重于说明**如何在 Web 应用和浏览器中滥用整数溢出/截断**。对于本地二进制（native binaries）中的 exploitation primitives，你可以继续阅读专门页面：
>
>
{{#ref}}
> ../../binary-exploitation/integer-overflow-and-underflow.md
> {{#endref}}

---

## 1. 为什么整数运算在 Web 上仍然重要

尽管现代技术栈的大多数业务逻辑都是用 *memory-safe* 语言编写，但底层运行时（或第三方库）最终仍然由 C/C++ 实现。每当用户可控的数值用于分配缓冲区、计算偏移或执行长度检查时，**32 位或 64 位的环绕（wrap-around）可能会把一个看似无害的参数转变为越界读/写、逻辑绕过或 DoS**。

典型攻击面：

1. **Numeric request parameters** – 典型的 id、offset 或 count 字段。
2. **Length / size headers** – Content-Length、WebSocket frame length、HTTP/2 continuation_len 等。
3. **File-format metadata parsed server-side or client-side** – image dimensions、chunk sizes、font tables。
4. **Language-level conversions** – PHP/Go/Rust FFI 中的 signed↔unsigned casts，JS Number → int32 在 V8 内部的截断。
5. **Authentication & business logic** – 优惠券值、价格或余额计算在无提示情况下溢出。

---

## 2. 最近的真实世界漏洞（2023-2025）

| Year | Component | Root cause | Impact |
|------|-----------|-----------|--------|
| 2023 | **libwebp – CVE-2023-4863** | 32-bit multiplication overflow when computing decoded pixel size | Triggered a Chrome 0-day (BLASTPASS on iOS), allowed *remote code execution* inside the renderer sandbox.  |
| 2024 | **V8 – CVE-2024-0519** | Truncation to 32-bit when growing a JSArray leads to OOB write on the backing store | Remote code execution after a single visit.  |
| 2025 | **Apollo GraphQL Server** (unreleased patch) | 32-bit signed integer used for first/last pagination args; negative values wrap to huge positives | Logic bypass & memory exhaustion (DoS). |

---

## 3. 测试策略

### 3.1 边界值备忘单

在任何期望整数的位置发送 **极端的有符号/无符号值**：
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
其他有用的格式：
* Hex (0x100), octal (0377), scientific (1e10), JSON big-int (9999999999999999999).
* 非常长的数字字符串 (>1kB) 用于触发自定义解析器。

### 3.2 Burp Intruder template
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 Fuzzing libraries & runtimes

* **AFL++/Honggfuzz** 使用 libFuzzer harness 围绕解析器（例如 WebP、PNG、protobuf）。
* **Fuzzilli** – 基于语法的 fuzzing JavaScript 引擎，以触发 V8/JSC 的整数截断。
* **boofuzz** – 网络协议 fuzzing（WebSocket、HTTP/2），聚焦长度字段。

---

## 4. Exploitation patterns

### 4.1 Logic bypass in server-side code (PHP example)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 Heap overflow via image decoder (libwebp 0-day)
WebP 无损解码器在 32-bit int 中将 image width × height × 4 (RGBA) 相乘。一个尺寸为 16384 × 16384 的精心构造文件会使乘法溢出，分配一个较小的缓冲区，并随后将 **~1GB** 的解压数据写出堆边界，导致在 116.0.5845.187 之前的所有 Chromium-based 浏览器出现 RCE。

### 4.3 基于浏览器的 XSS/RCE 链
1. **Integer overflow** in V8 gives arbitrary read/write.
2. 通过第二个漏洞越出沙箱，或调用本地 API 来 drop a payload。
3. 然后 payload 将恶意脚本注入 origin context → 造成 stored XSS。

---

## 5. 防御指南

1. **Use wide types or checked math** – 例如 size_t、Rust 的 checked_add、Go 的 math/bits.Add64。
2. **Validate ranges early**：在算术运算前拒绝任何超出业务域的值。
3. **Enable compiler sanitizers**：-fsanitize=integer、UBSan、Go race detector。
4. **Adopt fuzzing in CI/CD** – 将覆盖率反馈与边界语料结合。
5. **Stay patched** – 浏览器中的 integer overflow 漏洞常在数周内被 weaponised。

---



## References

* [NVD CVE-2023-4863 – libwebp Heap Buffer Overflow](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Understanding V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
