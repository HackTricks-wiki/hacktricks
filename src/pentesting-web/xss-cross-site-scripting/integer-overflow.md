# Integer Overflow (Web Applications)

{{#include ../../banners/hacktricks-training.md}}

> 이 페이지는 **정수 오버플로우/트렁케이션이 웹 애플리케이션과 브라우저에서 어떻게 악용될 수 있는지**에 초점을 맞추고 있습니다. 네이티브 바이너리 내에서의 익스플로잇 원시 요소에 대해서는 전용 페이지를 계속 읽어보세요:
>
> {{#ref}}
> ../../binary-exploitation/integer-overflow.md
> {{#endref}}

---

## 1. 웹에서 정수 수학이 여전히 중요한 이유

현대 스택의 대부분 비즈니스 로직이 *메모리 안전* 언어로 작성되었음에도 불구하고, 기본 런타임(또는 서드파티 라이브러리)은 결국 C/C++로 구현됩니다. 사용자 제어 숫자가 버퍼를 할당하거나, 오프셋을 계산하거나, 길이 검사를 수행하는 데 사용될 때, **32비트 또는 64비트 래핑이 겉보기에는 무해한 매개변수를 경계 초과 읽기/쓰기, 논리 우회 또는 DoS로 변환할 수 있습니다**.

전형적인 공격 표면:

1. **숫자 요청 매개변수** – 고전적인 `id`, `offset`, 또는 `count` 필드.
2. **길이/크기 헤더** – `Content-Length`, WebSocket 프레임 길이, HTTP/2 `continuation_len` 등.
3. **서버 측 또는 클라이언트 측에서 파싱된 파일 형식 메타데이터** – 이미지 크기, 청크 크기, 글꼴 테이블.
4. **언어 수준 변환** – PHP/Go/Rust FFI의 signed↔unsigned 캐스팅, V8 내의 JS `Number` → `int32` 트렁케이션.
5. **인증 및 비즈니스 로직** – 조용히 오버플로우되는 쿠폰 값, 가격 또는 잔액 계산.

---

## 2. 최근 실제 취약점 (2023-2025)

| 연도 | 구성 요소 | 근본 원인 | 영향 |
|------|-----------|-----------|--------|
| 2023 | **libwebp – CVE-2023-4863** | 디코딩된 픽셀 크기를 계산할 때 32비트 곱셈 오버플로우 | Chrome 0-day(`BLASTPASS` on iOS)를 유발, 렌더러 샌드박스 내에서 *원격 코드 실행* 허용.  |
| 2024 | **V8 – CVE-2024-0519** | `JSArray`를 확장할 때 32비트로 트렁케이션되어 백킹 스토어에서 OOB 쓰기 발생 | 단일 방문 후 원격 코드 실행.  |
| 2025 | **Apollo GraphQL Server** (미발표 패치) | `first/last` 페이지 매김 인수에 사용된 32비트 signed 정수; 음수 값이 큰 양수로 래핑됨 | 논리 우회 및 메모리 고갈(DoS). |

---

## 3. 테스트 전략

### 3.1 경계 값 치트 시트

정수가 예상되는 곳에 **극단적인 signed/unsigned 값**을 전송하세요:
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
기타 유용한 형식:
* Hex (`0x100`), octal (`0377`), scientific (`1e10`), JSON big-int (`9999999999999999999`).
* 사용자 정의 파서를 타격하기 위한 매우 긴 숫자 문자열 (>1kB).

### 3.2 Burp Intruder 템플릿
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 퍼징 라이브러리 및 런타임

* **AFL++/Honggfuzz**는 파서 주위에 `libFuzzer` 하네스를 사용합니다 (예: WebP, PNG, protobuf).
* **Fuzzilli** – V8/JSC 정수 잘림을 타겟으로 하는 JavaScript 엔진의 문법 인식 퍼징.
* **boofuzz** – 길이 필드에 초점을 맞춘 네트워크 프로토콜 퍼징 (WebSocket, HTTP/2).

---

## 4. 익스플로잇 패턴

### 4.1 서버 측 코드에서의 논리 우회 (PHP 예제)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 이미지 디코더를 통한 힙 오버플로우 (libwebp 0-day)
WebP 무손실 디코더는 32비트 `int` 내에서 이미지 너비 × 높이 × 4 (RGBA)를 곱합니다. `16384 × 16384` 크기의 조작된 파일은 곱셈을 오버플로우시켜 짧은 버퍼를 할당하고 이후 힙을 넘어 **~1GB**의 압축 해제된 데이터를 기록하게 되어, 116.0.5845.187 이전의 모든 Chromium 기반 브라우저에서 RCE를 초래합니다.

### 4.3 브라우저 기반 XSS/RCE 체인
1. V8에서의 **정수 오버플로우**는 임의의 읽기/쓰기를 제공합니다.
2. 두 번째 버그로 샌드박스를 탈출하거나 네이티브 API를 호출하여 페이로드를 드롭합니다.
3. 페이로드는 원본 컨텍스트에 악성 스크립트를 주입하여 → 저장된 XSS를 발생시킵니다.

---

## 5. 방어 지침

1. **넓은 타입 또는 체크된 수학 사용** – 예: `size_t`, Rust `checked_add`, Go `math/bits.Add64`.
2. **범위를 조기에 검증**: 산술 연산 전에 비즈니스 도메인 외의 값을 거부합니다.
3. **컴파일러 샌타이저 활성화**: `-fsanitize=integer`, UBSan, Go 레이스 탐지기.
4. **CI/CD에서 퍼징 채택** – 커버리지 피드백과 경계 집합을 결합합니다.
5. **패치 유지** – 브라우저 정수 오버플로우 버그는 종종 몇 주 내에 무기화됩니다.

---

## References

* [NVD CVE-2023-4863 – libwebp Heap Buffer Overflow](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Understanding V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
