# 整数溢出（Web 应用程序）

{{#include ../../banners/hacktricks-training.md}}

> 本页面重点介绍如何在 **Web 应用程序和浏览器中滥用整数溢出/截断**。有关本地二进制文件中的利用原语，您可以继续阅读专门的页面：
>
>
{{#ref}}
> ../../binary-exploitation/integer-overflow-and-underflow.md
>
{{#endref}}

---

## 1. 为什么整数数学在 Web 上仍然重要

尽管现代堆栈中的大多数业务逻辑是用 *内存安全* 语言编写的，但底层运行时（或第三方库）最终是用 C/C++ 实现的。每当使用用户控制的数字来分配缓冲区、计算偏移量或执行长度检查时，**32 位或 64 位的环绕可能会将一个看似无害的参数转变为越界读/写、逻辑绕过或拒绝服务（DoS）**。

典型攻击面：

1. **数字请求参数** – 经典的 id、偏移量或计数字段。
2. **长度/大小头部** – Content-Length、WebSocket 帧长度、HTTP/2 continuation_len 等。
3. **服务器端或客户端解析的文件格式元数据** – 图像尺寸、块大小、字体表。
4. **语言级转换** – PHP/Go/Rust FFI 中的有符号↔无符号转换，V8 中的 JS Number → int32 截断。
5. **身份验证和业务逻辑** – 优惠券值、价格或余额计算静默溢出。

---

## 2. 最近的现实世界漏洞（2023-2025）

| 年份 | 组件 | 根本原因 | 影响 |
|------|-----------|-----------|--------|
| 2023 | **libwebp – CVE-2023-4863** | 计算解码像素大小时的 32 位乘法溢出 | 触发了 Chrome 0-day（iOS 上的 BLASTPASS），允许在渲染器沙箱内 *远程代码执行*。  |
| 2024 | **V8 – CVE-2024-0519** | 在增长 JSArray 时截断为 32 位导致对后备存储的越界写入 | 单次访问后远程代码执行。  |
| 2025 | **Apollo GraphQL 服务器**（未发布补丁） | 用于第一页/最后一页分页参数的 32 位有符号整数；负值环绕到巨大的正值 | 逻辑绕过和内存耗尽（DoS）。 |

---

## 3. 测试策略

### 3.1 边界值备忘单

在期望整数的地方发送 **极端的有符号/无符号值**：
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
其他有用的格式：
* 十六进制 (0x100)，八进制 (0377)，科学计数法 (1e10)，JSON 大整数 (9999999999999999999)。
* 非常长的数字字符串 (>1kB) 以触发自定义解析器。

### 3.2 Burp Intruder 模板
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 模糊测试库和运行时

* **AFL++/Honggfuzz** 与 libFuzzer 结合使用，围绕解析器（例如，WebP、PNG、protobuf）。
* **Fuzzilli** – 语法感知的 JavaScript 引擎模糊测试，以触及 V8/JSC 整数截断。
* **boofuzz** – 网络协议模糊测试（WebSocket、HTTP/2），重点关注长度字段。

---

## 4. 利用模式

### 4.1 服务器端代码中的逻辑绕过（PHP 示例）
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 通过图像解码器的堆溢出 (libwebp 0-day)
WebP 无损解码器在 32 位整数内将图像宽度 × 高度 × 4 (RGBA) 相乘。一个尺寸为 16384 × 16384 的精心制作的文件会导致乘法溢出，分配一个短缓冲区，并随后将 **~1GB** 的解压数据写入堆中 – 导致在 116.0.5845.187 之前的每个基于 Chromium 的浏览器中发生 RCE。

### 4.3 基于浏览器的 XSS/RCE 链
1. **整数溢出** 在 V8 中提供任意读/写。
2. 通过第二个漏洞逃逸沙箱或调用本地 API 以投放有效载荷。
3. 有效载荷随后将恶意脚本注入原始上下文 → 存储的 XSS。

---

## 5. 防御指南

1. **使用宽类型或检查数学** – 例如，size_t、Rust checked_add、Go math/bits.Add64。
2. **尽早验证范围**：在算术运算之前拒绝任何超出业务范围的值。
3. **启用编译器消毒器**：-fsanitize=integer, UBSan, Go race detector。
4. **在 CI/CD 中采用模糊测试** – 将覆盖反馈与边界语料库结合。
5. **保持补丁更新** – 浏览器整数溢出漏洞通常在几周内被利用。

---

## 参考文献

* [NVD CVE-2023-4863 – libwebp 堆缓冲区溢出](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "理解 V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
