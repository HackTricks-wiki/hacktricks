# Przepełnienie całkowite (Aplikacje internetowe)

{{#include ../../banners/hacktricks-training.md}}

> Ta strona koncentruje się na tym, jak **przepełnienia/truncacje całkowite mogą być wykorzystywane w aplikacjach internetowych i przeglądarkach**. Aby uzyskać informacje o prymitywach eksploatacyjnych w natywnych binariach, możesz kontynuować czytanie dedykowanej strony:
>
> {{#ref}}
> ../../binary-exploitation/integer-overflow.md
> {{#endref}}

---

## 1. Dlaczego matematyka całkowita wciąż ma znaczenie w sieci

Mimo że większość logiki biznesowej w nowoczesnych stosach jest pisana w *bezpiecznych pamięciowo* językach, podstawowy runtime (lub biblioteki stron trzecich) jest ostatecznie zaimplementowany w C/C++. Kiedy liczby kontrolowane przez użytkownika są używane do alokacji buforów, obliczania przesunięć lub wykonywania kontroli długości, **przepełnienie 32-bitowe lub 64-bitowe może przekształcić pozornie nieszkodliwy parametr w odczyt/zapis poza zakresem, obejście logiki lub DoS**.

Typowa powierzchnia ataku:

1. **Numeryczne parametry żądania** – klasyczne pola `id`, `offset` lub `count`.
2. **Nagłówki długości/rozmiaru** – `Content-Length`, długość ramki WebSocket, HTTP/2 `continuation_len` itp.
3. **Metadane formatu pliku analizowane po stronie serwera lub klienta** – wymiary obrazu, rozmiary kawałków, tabele czcionek.
4. **Konwersje na poziomie języka** – rzutowania signed↔unsigned w PHP/Go/Rust FFI, truncacje JS `Number` → `int32` wewnątrz V8.
5. **Uwierzytelnianie i logika biznesowa** – wartość kuponu, obliczenia cen lub sald, które cicho przepełniają.

---

## 2. Ostatnie luki w zabezpieczeniach w rzeczywistych zastosowaniach (2023-2025)

| Rok | Komponent | Przyczyna | Wpływ |
|-----|-----------|-----------|-------|
| 2023 | **libwebp – CVE-2023-4863** | Przepełnienie mnożenia 32-bitowego podczas obliczania rozmiaru odkodowanego piksela | Wywołało 0-dniową lukę w Chrome (`BLASTPASS` na iOS), umożliwiło *zdalne wykonanie kodu* wewnątrz piaskownicy renderera. |
| 2024 | **V8 – CVE-2024-0519** | Truncacja do 32-bitów podczas powiększania `JSArray` prowadzi do zapisu OOB na zapleczu | Zdalne wykonanie kodu po jednej wizycie. |
| 2025 | **Apollo GraphQL Server** (nieopublikowana poprawka) | 32-bitowa liczba całkowita ze znakiem używana do argumentów paginacji `first/last`; wartości ujemne przepełniają do ogromnych dodatnich | Obejście logiki i wyczerpanie pamięci (DoS). |

---

## 3. Strategia testowania

### 3.1 Arkusz oszustw wartości granicznych

Wyślij **ekstremalne wartości signed/unsigned** wszędzie tam, gdzie oczekiwana jest liczba całkowita:
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
Inne przydatne formaty:
* Hex (`0x100`), ósemkowy (`0377`), naukowy (`1e10`), JSON big-int (`9999999999999999999`).
* Bardzo długie ciągi cyfr (>1kB) do trafienia w niestandardowe parsery.

### 3.2 Szablon Burp Intruder
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 Fuzzing biblioteki i środowiska uruchomieniowe

* **AFL++/Honggfuzz** z `libFuzzer` wokół parsera (np. WebP, PNG, protobuf).
* **Fuzzilli** – fuzzing z uwzględnieniem gramatyki silników JavaScript, aby trafić w obcinanie liczb całkowitych V8/JSC.
* **boofuzz** – fuzzing protokołów sieciowych (WebSocket, HTTP/2) koncentrujący się na polach długości.

---

## 4. Wzorce eksploatacji

### 4.1 Ominięcie logiki w kodzie po stronie serwera (przykład PHP)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 Przepełnienie sterty za pomocą dekodera obrazów (libwebp 0-day)
Dekoder WebP bezstratny pomnożył szerokość obrazu × wysokość × 4 (RGBA) wewnątrz 32-bitowego `int`. Opracowany plik o wymiarach `16384 × 16384` przepełnia mnożenie, alokuje krótki bufor i następnie zapisuje **~1GB** zdekompresowanych danych poza stertą – prowadząc do RCE w każdej przeglądarce opartej na Chromium przed wersją 116.0.5845.187.

### 4.3 Łańcuch XSS/RCE oparty na przeglądarce
1. **Przepełnienie całkowite** w V8 daje dowolne odczyty/zapisy.
2. Ucieczka z piaskownicy za pomocą drugiego błędu lub wywołanie natywnych API w celu zrzucenia ładunku.
3. Ładunek następnie wstrzykuje złośliwy skrypt do kontekstu źródłowego → przechowywane XSS.

---

## 5. Wytyczne obronne

1. **Używaj szerokich typów lub sprawdzanej matematyki** – np. `size_t`, Rust `checked_add`, Go `math/bits.Add64`.
2. **Waliduj zakresy wcześnie**: odrzucaj wszelkie wartości poza domeną biznesową przed arytmetyką.
3. **Włącz sanitizery kompilatora**: `-fsanitize=integer`, UBSan, detektor wyścigów Go.
4. **Przyjmij fuzzing w CI/CD** – połącz informacje zwrotne o pokryciu z granicznymi zbiorami.
5. **Bądź na bieżąco z łatkami** – błędy przepełnienia całkowitego w przeglądarkach są często wykorzystywane w ciągu kilku tygodni.

---

## References

* [NVD CVE-2023-4863 – libwebp Heap Buffer Overflow](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Understanding V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
