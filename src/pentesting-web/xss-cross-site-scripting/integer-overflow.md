# Desbordamiento de Enteros (Aplicaciones Web)

{{#include ../../banners/hacktricks-training.md}}

> Esta página se centra en cómo **los desbordamientos/truncamientos de enteros pueden ser abusados en aplicaciones web y navegadores**. Para primitivas de explotación dentro de binarios nativos, puedes continuar leyendo la página dedicada:
>
>
{{#ref}}
> ../../binary-exploitation/integer-overflow-and-underflow.md
>
{{#endref}}

---

## 1. Por qué la matemática entera sigue importando en la web

A pesar de que la mayoría de la lógica empresarial en pilas modernas está escrita en lenguajes *seguros en memoria*, el tiempo de ejecución subyacente (o bibliotecas de terceros) se implementa eventualmente en C/C++. Siempre que se utilicen números controlados por el usuario para asignar búferes, calcular desplazamientos o realizar verificaciones de longitud, **un desbordamiento de 32 bits o 64 bits puede transformar un parámetro aparentemente inofensivo en una lectura/escritura fuera de límites, un bypass lógico o un DoS**.

Superficie de ataque típica:

1. **Parámetros de solicitud numéricos** – campos clásicos de id, desplazamiento o conteo.
2. **Encabezados de longitud/tamaño** – Content-Length, longitud de marco de WebSocket, http/2 continuation_len, etc.
3. **Metadatos de formato de archivo analizados del lado del servidor o del cliente** – dimensiones de imagen, tamaños de fragmentos, tablas de fuentes.
4. **Conversiones a nivel de lenguaje** – conversiones firmadas↔no firmadas en PHP/Go/Rust FFI, truncamientos de JS Number → int32 dentro de V8.
5. **Autenticación y lógica empresarial** – valor de cupón, precio o cálculos de saldo que desbordaron silenciosamente.

---

## 2. Vulnerabilidades recientes en el mundo real (2023-2025)

| Año | Componente | Causa raíz | Impacto |
|------|-----------|-----------|--------|
| 2023 | **libwebp – CVE-2023-4863** | Desbordamiento de multiplicación de 32 bits al calcular el tamaño de píxel decodificado | Provocó un 0-day de Chrome (BLASTPASS en iOS), permitió *ejecución remota de código* dentro del sandbox del renderizador.  |
| 2024 | **V8 – CVE-2024-0519** | Truncamiento a 32 bits al aumentar un JSArray lleva a escritura OOB en el almacenamiento de respaldo | Ejecución remota de código después de una sola visita.  |
| 2025 | **Apollo GraphQL Server** (parche no lanzado) | Entero firmado de 32 bits utilizado para argumentos de paginación de primero/último; valores negativos se envuelven a enormes positivos | Bypass lógico y agotamiento de memoria (DoS). |

---

## 3. Estrategia de prueba

### 3.1 Hoja de trucos de valores límite

Envía **valores extremos firmados/no firmados** donde se espera un entero:
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
Otros formatos útiles:
* Hex (0x100), octal (0377), científico (1e10), JSON big-int (9999999999999999999).
* Cadenas de dígitos muy largas (>1kB) para golpear analizadores personalizados.

### 3.2 Plantilla de Burp Intruder
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 Bibliotecas y entornos de ejecución de fuzzing

* **AFL++/Honggfuzz** con un harness de libFuzzer alrededor del parser (por ejemplo, WebP, PNG, protobuf).
* **Fuzzilli** – fuzzing consciente de la gramática de motores de JavaScript para golpear truncamientos de enteros en V8/JSC.
* **boofuzz** – fuzzing de protocolos de red (WebSocket, HTTP/2) centrado en campos de longitud.

---

## 4. Patrones de explotación

### 4.1 Bypass de lógica en código del lado del servidor (ejemplo de PHP)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 Desbordamiento de heap a través del decodificador de imágenes (libwebp 0-day)
El decodificador sin pérdida de WebP multiplicó el ancho de la imagen × altura × 4 (RGBA) dentro de un int de 32 bits. Un archivo diseñado con dimensiones 16384 × 16384 desborda la multiplicación, asigna un búfer corto y posteriormente escribe **~1GB** de datos descomprimidos más allá del heap, lo que lleva a RCE en todos los navegadores basados en Chromium antes de 116.0.5845.187.

### 4.3 Cadena de XSS/RCE basada en navegador
1. **Desbordamiento de entero** en V8 da lectura/escritura arbitraria.
2. Escapar de la sandbox con un segundo error o llamar a APIs nativas para soltar una carga útil.
3. La carga útil luego inyecta un script malicioso en el contexto de origen → XSS almacenado.

---

## 5. Directrices defensivas

1. **Usar tipos amplios o matemáticas verificadas** – p. ej., size_t, Rust checked_add, Go math/bits.Add64.
2. **Validar rangos temprano**: rechazar cualquier valor fuera del dominio comercial antes de la aritmética.
3. **Habilitar sanitizadores del compilador**: -fsanitize=integer, UBSan, detector de carreras de Go.
4. **Adoptar fuzzing en CI/CD** – combinar retroalimentación de cobertura con corpus de límites.
5. **Mantenerse actualizado** – los errores de desbordamiento de enteros en navegadores son frecuentemente armados en semanas.

---

## Referencias

* [NVD CVE-2023-4863 – Desbordamiento de búfer de heap de libwebp](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Entendiendo V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
