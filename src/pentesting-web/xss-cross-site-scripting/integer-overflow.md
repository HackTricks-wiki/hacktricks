# Integer Overflow (Web Applications)

{{#include ../../banners/hacktricks-training.md}}

> Esta página se centra en cómo **integer overflows/truncations can be abused in web applications and browsers**. Para exploitation primitives dentro de binarios nativos puedes seguir leyendo la página dedicada:
>
>
{{#ref}}
> ../../binary-exploitation/integer-overflow-and-underflow.md
> {{#endref}}

---

## 1. Por qué la aritmética de enteros sigue importando en la web

Aunque la mayor parte de la lógica de negocio en stacks modernos se escribe en lenguajes *memory-safe*, el runtime subyacente (o librerías de terceros) acaba implementándose en C/C++. Siempre que números controlados por el usuario se usan para asignar buffers, calcular offsets o realizar comprobaciones de longitud, **un wrap-around de 32-bit o 64-bit puede transformar un parámetro aparentemente inofensivo en una lectura/escritura fuera de límites, un bypass lógico o un DoS**.

Superficie de ataque típica:

1. **Numeric request parameters** – campos clásicos id, offset o count.
2. **Length / size headers** – Content-Length, WebSocket frame length, HTTP/2 continuation_len, etc.
3. **File-format metadata parsed server-side or client-side** – dimensiones de imagen, tamaños de chunk, tablas de fuentes.
4. **Language-level conversions** – signed↔unsigned casts en PHP/Go/Rust FFI, JS Number → int32 truncations inside V8.
5. **Authentication & business logic** – cálculos de valor de cupón, precio o balance que silenciosamente overflowean.

---

## 2. Vulnerabilidades reales recientes (2023-2025)

| Año | Componente | Causa raíz | Impacto |
|------|-----------|-----------|--------|
| 2023 | **libwebp – CVE-2023-4863** | 32-bit multiplication overflow when computing decoded pixel size | Provocó un Chrome 0-day (BLASTPASS on iOS), permitió *remote code execution* dentro del renderer sandbox.  |
| 2024 | **V8 – CVE-2024-0519** | Truncation to 32-bit when growing a JSArray leads to OOB write on the backing store | Remote code execution after a single visit.  |
| 2025 | **Apollo GraphQL Server** (unreleased patch) | 32-bit signed integer used for first/last pagination args; negative values wrap to huge positives | Bypass lógico y agotamiento de memoria (DoS). |

---

## 3. Estrategia de pruebas

### 3.1 Hoja de referencia de valores límite

Envía **valores extremos con signo/sin signo** donde se espere un entero:
```
-1, 0, 1,
127, 128, 255, 256,
32767, 32768, 65535, 65536,
2147483647, 2147483648, 4294967295,
9223372036854775807, 9223372036854775808,
0x7fffffff, 0x80000000, 0xffffffff
```
Otros formatos útiles:
* Hex (0x100), octal (0377), notación científica (1e10), JSON big-int (9999999999999999999).
* Cadenas de dígitos muy largas (>1kB) para afectar a parsers personalizados.

### 3.2 Plantilla de Burp Intruder
```
§INTEGER§
Payload type: Numbers
From: -10 To: 4294967300 Step: 1
Pad to length: 10, Enable hex prefix 0x
```
### 3.3 Bibliotecas y runtimes de fuzzing

* **AFL++/Honggfuzz** con un harness de libFuzzer alrededor del parser (p. ej., WebP, PNG, protobuf).
* **Fuzzilli** – fuzzing consciente de la gramática de motores JavaScript para alcanzar truncamientos de enteros en V8/JSC.
* **boofuzz** – fuzzing de protocolos de red (WebSocket, HTTP/2) enfocado en campos de longitud.

---

## 4. Patrones de explotación

### 4.1 Bypass lógico en código del lado del servidor (ejemplo en PHP)
```php
$price = (int)$_POST['price'];          // expecting cents (0-10000)
$total = $price * 100;                  // ← 32-bit overflow possible
if($total > 1000000){
die('Too expensive');
}
/* Sending price=21474850 → $total wraps to ‑2147483648 and check is bypassed */
```
### 4.2 Heap overflow via image decoder (libwebp 0-day)
El decodificador sin pérdida de WebP multiplicó image width × height × 4 (RGBA) dentro de un int de 32 bits. Un archivo creado con dimensiones 16384 × 16384 desborda la multiplicación, asigna un buffer corto y posteriormente escribe **~1GB** de datos descomprimidos fuera del heap – lo que conduce a RCE en todos los navegadores basados en Chromium anteriores a 116.0.5845.187.

### 4.3 Cadena XSS/RCE basada en el navegador
1. **Integer overflow** en V8 proporciona lectura/escritura arbitraria.
2. Escapar del sandbox con un segundo bug o llamar a native APIs para desplegar un payload.
3. El payload inyecta entonces un script malicioso en el contexto de origen → stored XSS.

---

## 5. Directrices defensivas

1. **Use wide types or checked math** – p. ej., size_t, Rust checked_add, Go math/bits.Add64.
2. **Validate ranges early**: rechazar cualquier valor fuera del dominio de negocio antes de realizar operaciones aritméticas.
3. **Enable compiler sanitizers**: -fsanitize=integer, UBSan, Go race detector.
4. **Adopt fuzzing in CI/CD** – combina la retroalimentación de cobertura con corpus de límites.
5. **Stay patched** – los bugs de integer overflow en navegadores suelen explotarse en cuestión de semanas.

---



## Referencias

* [NVD CVE-2023-4863 – libwebp Heap Buffer Overflow](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
* [Google Project Zero – "Understanding V8 CVE-2024-0519"](https://googleprojectzero.github.io/)
{{#include ../../banners/hacktricks-training.md}}
